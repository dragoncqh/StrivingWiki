<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9fe630fc9b39dc11359638b0fbce64bcea916b9bf03e36dda2fe566452613f2be0338e432163a1b32a527b47f4317587a270422dd3677594b383508568b032a8af05f65755adf0c6416a3ec0eebe3190717cc2f83c12c6bb3085c1bce1f5d887e42fe8c8ab1fa511eaa42bbf37ea27ff0b6f174539a13495d6b1196fa2de83610f815c4f2fbff7bc79cde2ddd755f11069453665f883fb60d6301b5277efda817da6d1f7fecf8eb5d622d54f941fccd8ed4ac291f51a647af2503bdec9b81e8e74539d1860af1a1ae057fbf6d2a1fca10b8eb483d299773b7b46994ef4db63f75b4d70453c564a50e9e891613e47c4c4897159bba5e4a532eeaaf89e4048ac85844cadeeadd6da73b664a52c92466abc9cd35156e01c2bf79cd4265e222ec8817bf8c8dd3cbf2785dde14d8121b0a59e22bc1851a2e2602d74f5a566c08a50f9a8e9567c9b0b5911a2f0aba286ecd453474b084c80e441adb42673e929ea0a977d4821a9c7b90ada70da51fd6c1da99951f58c8154a1daa9f20bc35d013a812da82c84b81388748392dd73093ac2c382c407fe001dcf25f5d480ccfa3d52d1c031bc53e63ab8fea7bc3e762e0aae1b822c4c35d50eb67dd3910c1236057f0f04f9693717945f027735a81679166ea1d413c10f8dfeb90deae105eeef3f3ed76f5df939e982af70618a515b9256efebb596718193ab130f9d49ac39d22608f19d6b0e17c10b20c661f79ec544532e5553ba8fd361df69be26b977435253918128402d949656e9dd8f6483b0c925a7126a3254994e7ac04cae2fbdf3af41f5feb335c52b6759e04084f4a82dc4b4d551408a01a06c3dc850c968945ba74c87a8e898429f6b18717fea5b98a6db00a9eda51baf69b6713fdcd3aeb6d7f56451ffa54bd08743774a4a8e7ed345341f31d7c74bae0e5c60f0ddfeff3ce0011cb17101e38283cdd67bf754baace9173d6b8144efd5c25902999fe2b652478f00ef6a382d67201834105696dc5bb4467367e94cce7eeb3a372ff8fbe1d516828d3a2c8c7c013b159e6b8cfe3dbc818990c76baeee5cb412c87c8bfa5ee65ca3a9a056abb3c93dfd0262077d47f2a8e65577f5d18ecb80d9ae5a3a9c8fd90882ffef7ef699e20a746c79a046560a24a113161baab1b706a70ee76f2ba970ab5e62abaa80da2903dd64e62f4a608d06a8f932aae1969497547cb2e7e134e4b82bb73787090663cf9df0879c8c9fd1fe773c549981cd1b82189a1c3e28019ac5af56803c8a67f7c79b475a6cab81efeee627724794a014aab83b3a601943618bd82d2401f7da268437a5316207a04ba2f850ba552a4356fe45c11118d115e35851f5624ef6147b3a6dec3ff5e47dd69b44b25cd6444e537aea98fdcd9340baa08873d62975237988fed6f9180959884fae22ef7f7ab9fe449406e3314bc754292eb42dcc49c962cee855330570c167d955e514ce302abd2e9fa1b2a870b3f202feab9e163ea91cab312dff3d2754a265a548b23caad9a89a5b439786cc4ba69a518659ba159e5107954e56a2194d18ea33626bc83e2635ddd32254cb826ea36a34e79e48702bff86d4d3a40c651b3c1b6d770747bc9b4d691fd4ee52077da27c2269a96e16b1c09e22552d5f727ee6392c503c7403f37968d9c7ed740007719ed4222cebc30dea21c93e78facb57bced05e78499281e66bdeef3b4a5aaf8506af4b341515fa14c8a3037595a30fd57dec641510138bcb73a4b34fa50efc5230b02d32b9b8a685122031010d0d8d4772b0c55f2916a437d629f6dd249cb53d6dfbce3fa779ad851c352a6bc0dcffbb199680e699cbc3897b64aa793bb645f2fe5dd79a2d5e10548a30b277d6bd741a91039e7b9a8ba833dcc1af3879e90b4ee65031720b698858c0f575be8a33fba0196d74df17725a7936d5bd9bd3f9ccba1ba580eebe3e6deb09d1db68b0212152e033370b2490f946ba0294b961a887602e6b13078bbe7e37c8b5ba630989764d3e06af61a10cb6a4549a13141d9d3bed20eb5177cd6d44b7436f962d59164187a746aec47d631c31044deccacc21fabb012bd4244391138f7d7a4e9dde3814f3f63894c2aad7a5071de361f613cd0b5bed864fd4d8829b76c5561f385bde672819ae6d1e38750fb51a81cd6c4cc94bbc23e8191116aa851301bf36ae1dfa65248e8b2ec308fbb68123a6e09da5b479c1ac83fda35d3041896b8f496975b602beac13e2a088c714cb088f33718cf40f8fd131740173ffdba36df717238970c5f29ecb11f5518b6951e5b2ff5177606f76c19b2c6d4f72b8490c4bce2975d23888ec9b8889d0185ae0f22adde89830e50abcf8ad5fe18873ddf2d5b480f397f6491dd67043c50ddec73b74e7324ee444b5d407fb57ded83b11cdc4e7dd2fb892f8d47472d521828f36aad997a87fab30728179bcafa4c09b3708ca888d2750ebff1a183dc6edc48c9f718411a1aa6875ef8b34df21f39980aaecd06044e80663b33cc190070e777cfdab970e60d22c37a1cee8d924d64e27aef664badf54bb7b5a75e74615e92e2aa3ee8ddec55bc47b1dc6a88f63ba0ddc675c11d077b172b30640fe552a1dbdad06bffc6d976b9cdd9eccd4f9c372ade3ecc6f9370fb9eec6a6e273490812a01a85e5529e5794400da97659e5f604b55b258501522c31625311ccc49fd3e5ee0a494b3aceb545e6aa375faf0a81320db43bda2a1a9ff7e9492e141c3453f5474bf66bbdd6ed4d04fca5dad836e3eb61f4f8a78594e71cb2ac58a6d398fa116d6c3b74d8bab58a1c06e6a91a8a591bf9afc159181a38a305853a1b4fc4b846aa9b8c35bd6ecfc4185198c628a4cabc8ce24b29995f9ecbf4e11fe6338eacd3b9cff9820826ec989fca63ea98732d50049c886a39fb7553fb78f8bb1ab43a97853bc8c56421dd397b73bc5e36ff6acf1c6eb87dc770420a6f807cdfdf75ff4bf01e1ddf3333daba90aa6cee600e408f52dfa441bcf31bef012cf4dd9213ab5de217acc6693f04e9e2bc8645c0b6e5a304896dc15c0c2d42a339d2de4da56fdea7f0b74d0210e6bc191ea67bdbac89456c8b893bcaeb6cd264068964d1b4d9bb0094f2d8afb7a3b2d970d13436e500e8db927e9e72d68156f3931a75c7eba039f7ca0f5ef31ab993db45552580c7d610bf8deab5ab2be2d6cdfb02e52a048df639ed55d3a23ac1c72be5fe527c644c05ca1082d9eb739788e0c04d4e186f665e3c9a6e341a69aba76cec071a29ea8efbfb8f97b004b0251c11f6196cc21e9f4a847a700bcbb19d4a6313db83e736379042fe6b8dc84f6a49333a567478275b1d46b9229cd99a33b6c1c292183c0e02d94455d02bb1dbe5a3e749db238fb622d1d7c86f586ab44f385a6ff67089e82677ce011037f097010af9d2402664d7e91a38f316d10600bcba4511416d8dc95f4dd8f226b0c942e6c33cacf12e3f66577303b952e457730f1cae09ab56e5ef327e18eaf5580ac211ac9de03cadc523b63ad3f046525f2ce28dda7562b32b06b06f6d84496784549fe48c466661ad5bc93524b239c696acebbbb832e39912421e1ee2bffd2630463db5152ebb7cc1fd8e688f1f281c4c365768997fef0e8fbfa6054c6191be1b1bf434c186327fa72cc6dc951e92743ecdc1758b41f5b8e75360dc176aeca11dbc4a8ad0f845c69354dab1c196ee2ee468f74272a5229252ae127415758e538b3b2e6a4ae2982bd5d3d4f9aa6e3d54dad0891121a30b9b42caa300a202e00f5fd2c9b8112989408efafd7eb98af6f05c3c0b4ea3460d8f7653d3872855a12c5542bd39a846db386c20338a7a9e54dc5a4e6258ec3638b3a8e244b9b24fe20a0cd861d2e526c9ca55508b243104431c322279053c4608adb2eb2c79f9fd012bf3f5b6a0f0a5fe657d3c6b66cb43d16ec9869fdcd64903e48f31a65ab12ac40c3900bd6dd7a479e3f19ebbc0f9865b2bee40ba5c77296010df0b756de043039b753aa53c6329d16103345ba7d778d9e992e5018d5c93dd1e21cd194bcb5bd4bee09e79407605a6f421f48f0e13dbb8ce9ae6a9e5e351ec9eb59ea3064a14fe02f19492734fd699ef7d4f83339291fb8178297f1f695f0e28bd1393ab056a88987e5aae66996f444dad7703b7e7d1520fd75f35036cae5e9c9339eb10a9935601e131683840bc8b20a277e62d5a3e4b34d9574f392096dcac599cbd0a0aff7700a7a59feb1bc2c7d516ee4aa710bae1f59713c22f76e281c27f68940291b8f2f67fd5da6cf28e90b7e5129c8dec37cee2e6b64c1ce5688b7f8b8fe3d9c824958459ff947fe0c589da1c23d72a91c5b4ea39de00bcaa6f1e0c58bfcaabd744718d9ba0217cffdd9a1dd01a8d225902bade47a3b92de874f6c2fb491f5a4ffb0aaf18c37f0b05680873433edcf72ecb58d318e2078c2b155007f258f20e41aee4f600b26d40362737eecbc01b904b7f2083006f6f1af2bbafa4edf60ea3e69e2f8116865157d5e00227bdadbb12a3ff015001eb6bb9bd7d9cb01ed6a9baadacfa9d2d9690726d8fd0c0e9cd0ed438e4f6fabb2b75325315d33e6d460f2a392509259d3f37028cd96b85732d0ec7edcc55ceb984dfde5a66f67528714275130f5090b7490f85fec09e71ee365589957cc96bff767566a0124f8cd8215bf654d8d857f1f7cf3143d121f0a03fde63311099a42212b47806f98161939f74a8c5895f8128dc28f4e9bf1b3c19c0438598c656f4cc67d0a43d02307644c2cb2472b7cdfc6102d6b57913131bf7fc4a50c4754543de870eebeeed40cab75b574620ffa1723fb88cf3c447922d261b9f755fc06166061ce7bceb4a8a9d9e93f4c951c97df0ed3da3e51b4136196e70bb2e17157f0093f8e89466a11c2fff880515b7f7254910cbb51fb6804820a9cc033bfba94c263449053f2d01606d11d456952809412aad82673e998e32c3910fc21de710f1bb2ab64b9c5098d6fb7966cc368e2d3e7c736a8c6538ca4cb338dd1abbec3ed7fcbe5c33e7a468f567a431b2f229358c93a269536b0159d2be54b427e276cf1bb5c3b526831643743a4da3f93cd2ccf441b0d5b2ddc0aae07c34afa2072672d2b0f6ad752b7d7e42d71574e09f35d0d4105273488c76177dd7fec9c7f9f244c43c757c5d0c1091f7c00e836aed81d1d71727b41c3dab751752a5e9088630e6099ca3ecf2121656943317cf3e9823b346b31400e12ddddcf9570c058567c65351bbf38dfd094d932c7386662f4dbea3412e81ad7a79cd75137c3b06204f7ebf34d53ee23d2d64f8efd6a7774c6371d07852645b5888e1564440e9db3275987461acf9a8bfbe5cd5e427767e8c8236f40e67a3213de6786d83441a2950cec3556958567cc888896839e6c77f9541bec4c18d9bed82aed19660f981a5a8849e5cd41caf8e9202d126c71165637b1e532a697947b7884db9280d85f4dcecfac856af7e3195deb6487a5acf928b34f4f9a459f6ed30d66baf692b0975f90a07822bb15c8584a8708a314e6b23fabba746695ea6e24a9f1bb6b552ec8c47c93af6068189d0f224a44d289f3d7e7eb6bd59b5b127e42324cff174abe993ade1e182f452c458b3313c88ee0eebf4c08ad751ca7648109043c2005c7f98db7582aff96d794189e2735087f1fc8dabe55c1c61df00e8dfc8be7563048f2aec39828fcbfa41c8a668683133c41eaa8debd78268481af8e60d63b3683d072254de24b82d36f3fa515a6c0f46a1c9c34575f903fab100278713e53096cde6162e7d0f6c82a3f363ebf704cb54ada611797f0e7c2738f0e26f76a11dc6d9a5cb6acdcad039483879bf7248e15dc155203f71d9184c2bca086843e9065b30efb2be9f7ce7705f8ed28b3374cbe4bcc747754e33d35f36e1d0c7970f8ddff4963a1b1dfe72ec38632ba196a94ba08a85f41d2087fa666bb07198f5544e897e939a70a92fe1c67f0083678976ece70c33a96052e2fd7c33a0cbdf92890ed37b32aac577a4cd968906035e4bd459bb3710bfe3e57eb85593421de664f4e656f241e68d98aa897a7c8875e0e927ab08422945b7eefe6da5f89550d0280fdb5f37f033ce0cd60759969c946b04b48a1e811b0fa8429b55f351262c96e1c4a61f430928b384769f4d6cce9189f2727d718d6a86bc86e17e2f3b3fff1bf311a2e448bb5c67b439799d630f277abc9bcf5df5233502931723e0f6698091bda6c46cc6f2244db9185f1bdb529833e51bddaf0191573800d8e3605249c0154a708fd1ad12d673cf18766ce4239a623faf17ca548c6373033d8bb72233aba56ee08a57bc7be6d96e71edd96d3939d96d898c23d02aa454c61ad54d7c4e06925f1867924decad17096c108f462a3e46a8a2d30264d1a107fd1c738ce8bdc454ff9a64e91a876fba2975f054f49a628ddc16a9ea0512ad57fcc862bccb4328ba946dd512e50de95d4b17d8294d361eda2e34595da9ac3d5faba164cde057437c9bfa051162b54504f132e2759781942492d39c26cf7f5d2a1da70fc1daefbf70ceb031d651a3efc3d0acaaa2306539c29dc88c54807a70a8239763e4e94820aff7644f1134378051603a8dab112f014a4832c2830f1984c9479492234fde6778e1eb6a68ce9142543eb5db83168ddd61460284b550b19d51a32274768251695390c81a67c419074c3b68f54eca9f3d4e57f4ea7d49d614a79bc8d83585efc10ea280c1af50b0455cc6fe3535d7cb74fc219494c905122eb8a31c6e409ef2bfe30054c7da6a10f9150f6a7c62f40f1e3f3179f4c34cb41cab2486b8a099353e15f2e0bc8444cd35dcd49495f57d24886bc16f5a67f34ab1df8c52c6426347b7761ebbbf9f3cb27e082cb24c2dee57c1143b9c19dc39471d5f37e68c013a54adf908d75691612c479dd08280a6987971483e0a59149cf221156240d8a55b90b32de4be68cfa027fb5964392a6a9808a2d1c3bfdde353ebc3b82ecba74f69726b6b1948107f5bf20f65bcc637d53a0360bff24d8db39df53afe04952e017b8382b0baca37bdff69ecf25eb1673b12fbcf9669b13c810d86facac9d0f068cd9abc7a6d76a3c0fdf0be97c3b6cf846cb9b504f15ff86519ed5cf784a375729b2f068d5da776dfdab72d4248bc58e53fb30ec70ba2aec54c64eddfdfe114b45fc25e21109915f0b57d773a6d3664eae8349cbcfacc329455501370861bacb900368d6104ecddc78ff69972e793e0e2ac5890dc70570677bef47333858c05fde214bb0c8c7cf4d957bdaa5ac9fb06cda39af68c0790bbdb39008f8ae1952d4d3924e040dd7af38fce7b724124a82550841d0455a52b1299783863bf6b0924adff9263068b260f0fe0b622825e1a6c91379100917b85a901187cdf8ceb4e19f1e09131ba0b630d51d4d3549008d95f2f3e58f70b4af9553e891b8cde4b815a3989a51f17890fb5cd5b68ef671e743b9a77173897e45082a091e671b296f093c164d8baaf79b0378ae019f59ed6c98f97fd0c9db714817579689d130b2ce62d5a4ea9d070b9c4d3d93e353aade2d69672613ba769fa84ff71841c186047ec91fd816db8a18d893fcc03c1051f87293aa3094a8e5ea1fda3dcc8c2dad6cba89ea5efa50a6827ab8e49c6a58cce06ab69c48dd336f3abba62eca474c385d2f9188953bd98f5f78c678d533bd9998413f7dfb4aeeb97d7c2087d6fdd85a0011664f8266be5031837242e9a2ad43e895425d434ab2ff543634435b462bdccf88fb89d2578e669f3d9231af901828fb29d1ea02dd4e2e543c003724cbe4fd6df808c046c4794948910f5a2abd0ebdf4389f9071f5b0417238fc60b5442c49f434fb7980fa8a5cd7622e9b8a4e3624a2490807c9a1799fa7b09cb419df60d831ec69efdb383f18a8140b8d16264d79e87801c59cb53eb72b669c5ca3e9836651cb9a1372301d6f9c2a869c3a18227f650ab243978560a6f89f467e57776e2965f49cd52931f111bb9744310092792a0d4a84774ae7279e7652b073aa66f1a5d97e2b23d70ab33f36ef5f21aa57f6292f56f6d19af96cc2d31a339df8f35ac9eb5de4838d979d61c5d6e6995ca83d3273f431c78c2abc2dc3a3c74c948937ae6e3064a5baf889829a39988a88ee90359b8b36a1efe4f06c0e1407bfc09be4bbc60bc90e5f3d4e0e2ae7dbbf4037df823e623991b5d91fc6773ed7107ecda9e9dd451957454c10b3f4e05c9cc44c1e457095146a64e67b2318eea14290739912120f15e71ac28315d7502d1b99ed60b1596a9c4186d40a3c5b7022aca5ac370c89e797cedd08b3e2eda6d6624b64e665b324723caca79f930f6b0353f37fdd778c57932d36b85e4414ebfcb687fd58bcfbf7effd1d0573c6ec90363bb34fe123d3739badaac62236eae0f3d312d59d1c3d967e833bc9099316a8a53505db93211cc5ed8d829623b9cb5409adefacdb3212f339ee9e00219e20a7b3b1d12ebd51810faa7e74a7519c6776e03bea2dd1ada2614cdaa3a88847aefcf4eaf510a8d622db6ba81f5d7045e4e4ba82e3cd853df32fd6e9c8c5102050e526dddf9e287e04c398339b00c11175acb3c7c498076c010fbd8543d105da62cc8c65fcf6e752a880061d17b26a36f1f3ea91a5a35826ff6663ada402197796f104a62b7cd3d37ea57f1ed8d67a07f7c8e6ce1abd011090803121d910ad1c4665b698912030243b83cb2bbbd84ca418e29bba0f7ee584672b57d5ebd8133d5b67f87fe94bdc8c14433fab86b601440fac918683c9efd72e74b5cf3be3cf36a81f60689bbc81ad8d9375235e0667595344c0340e54113857d531acee8a3e796bd9db6e693b1710eda0abc963d00eba0c135d412640b551f162b957a976b993294b2d20ee3cc0cd1b05ef9b1e222dc8031ee059b369e7fb183ea1250bd35a9f480af0505f9f05af367e09a6ab23594f7015d466048b07b6035cb77488588f24da656a43dd9adc4c30b2a45b0da2819ab54fd5824b4cfdd726b0d77dc0df5c60d63a9f45a795fdb237dda22799d2611bec4ed82898aafebc01488c1535beebaa8bb60f221c45ddc7ffe80e8b97659857b04f46db8be71e329048f00c228002aad2633bc71d557ab9441d40dffa529a4a831260b7f5e27e69ddc3be195f33accab9e8db795567ed9b3cc411c60358fc3535fb3705b7a82ed57427b27833de20953401373e31280132e9f52ba9296d54a95132ea0bbe428c70d65a850624f64d151c517e8508dddd6e4a78cfd0bdd19ec4ee2ae41a34664bba7db71048566839e2755bfcdc3436e9aef119970339fb98d6813bd1e66bd87bcd78bfbcbb64b8b8527316304d2cfe64036e4065185f4a40600e38d7416d8ed4c2434130a4d8e66b2be982a129b43ed47eb125eccd67c427299fc3f6c129769f678451033a774c6fdb61ddaa0bd8356e1381caa23bf4bbe616150c28cf57b985427fd1473292c72933452daee45150dbae46877c290f5c6cbb4b632c05be9563363a8d1a35a2e8ded03bab64ca0d178b3eeeb96b31977a3f2fca3e941c5cc93a64a1d630577fc208a77101152cd7a072ae60e3845ee1035be783275a1d5b5eb2a7065bb6969f61999511d14f207457763b272297fcc0a47696a21cb513404f555c887fa13ebea7c439d7f5a5f51b9864d359c724e56ed95de6ec4634a64bfd7996a4979ef61a6f2d499eeb513f1243f0a58efd46ecebf9d81cb00edead61a7c0eb648108c6471de532001fa9f6218ed2ae9d39a1587348f56c2a1ca899c5a43444d29d45947c31400a46623ca29a234f0eb6cf3af0ad16d29cd86c9aa3bdd8d387a058314b30e49cb55b3748ef7ae429901c7e580186d4801ff9a9674c2aed7d8c855b857dd49c97b63f64040898b988cc455c2e506ab8d4a7c5384248f5535c00b21462d4d13dcaff11f0b159437c9a006057c22e2dcc7777321dde932b998e2c5d46a8ed96a3a46b78c01f70725a9b5c163964b549ca98571da82529d6409efe6c7fde801569f01f4646e1b15946d389e9d77f71fd237af153acd676d4e74ca778f31f79c9f5adf44dfd360ba22adb26cf53dd1916f3a5efeded5bacfdb05fcdce6fc6d033bd9aaac44d4471cce8f8b8ab4ea7a25e0ee5d04c94b2ddb25b58e472a4cba3cee30883e6a49d52eb994ae4591a062d5ef1251e48c155bbbe3de5331e4cf3940e36caccb5ccc702dc04671f09d8886aea8d971ed7772fdae485d7b9c5100a0925c858aa47a632db5134d9782891cbdbfe66ae83bf0f78a8261f6abce038aa06c9273398d1453978cdd8c488898b49f3a7f31f719ea7bee546224270658e6f4dfe6ed68b2e56a9258b37152c5b00d889d0ddc4f099c90fb3efdc327a380435cb5bf921d290f9ae769f4252dabedd58de9054abddb52d48ba0e2310957f867e94f314b43804ad3d3ab688269200bafacf3110fbe1867e7daf47b3d39e3aad9908df3c6ea7d893bd335c8b126ff629945a84df7562aad7526dbe3dc3c72ad86bc6867d88c5419e730bc040e2e8c227e8ca685ae48c4a0060d1961eb3953498bfa126080155c55698d52757843e388c67fdb75517acef726098d63d788ab68d955c68029d3a17cd5e832c36b98288311694871eece175c423eb79809fc234b149b330119f0c3216a811893d2d5feb38f757b7cf16f3fb488abac0098a82f745449ab0479f4b34ad7d8bcd3a03d3f9528791a624879562e3c265c619076d4f424de896db841aeabd248409230527ab2896b9026b8698a319ba05569fd5b7657f4bb3de41ebc15b892cb196a7de017eaf1c70cbd79ecee6e3b4ce0310cb742fa3ac8dcd418ae39d2a531d1f33ebe3924f1d7d1733e99ab76ccb8aad5ce94367a4aa30dfb55e48970a792742ecf01d10597a5ac41d3419cfd30a1a7405ca7788652017fd32ba6225ab9760f472e2e8f785737fb7be03ed799e8a9561bd402b356d01659db177bebdf010e32624d9bd8e86b0c6dc29678abf5a09e84a7f91deabd1d21a13aa55bfcaca97da1268486f53fbd1c5dfb50cf0ad8965a261598caaf88fece0473ed0aed690813b59dd6db48ee04be3623f4c1c9cbe874131c0a257ef12ff94a26527e548802264f4d6ef29dfa86b8ae8778266d23a2acd1ebb61c9a6a1b2bdf6ba5b41ca9385630964aecea2991afcc7f4293ead1e70e3556c23305d39279a94639591bd8299da4f904509a415105395f1d5d2f947d988405fccf10204ff7ac1fc5d278f959f729b80a3c2b04b85044e7e67abde8eb8e891079fa9df56879d93564eeb675b6cbafb0789aece477f47863aee1f7655fddaf7fc928768e5fc3c63fefb07000ee81ddef6fce95491ac2398083acd44d9b73ccff56b4fb3c322d86e91bd42c66316c4ab5355685d0fbcfe18f69ee22bbd774fabc126bba781ee2b0af8056186452c640d7afd054e690cbc78a50eb26b356de3312fdfd1651d75d60a6016c02a1c61c4d5941c94d78c63671114b660227a163029aec2c03262bf8ab30bfe5f3b7cf39be5aba998b70197cc909b6b98d060e125e9bfb00ad90bfba8ca22f1c1e8eca0b7c8f33dd954d90d6368aa70778c1cfe608950f238be9986e45591d050633a0df445cfc383dc5f72cb0d7308135082013c54c89c10553e05742a177952067f0d173ffe021277eaf43fa7895108f991b87b9740151f1ae4b3bba8ea4b7a3d93eb07ea81d1c31ca98c7eeaef77aab66a3cd70591f66919cc3dba97316fd1621a929565c3792cef59e9ecbfcc004f5d9d54ba4445540df830c240960da4ca91324b2e7a0710796d3516caddba84b15d96d1a19d3194813e7923a55973d3da8b70bf2ecdd0b280f2b91e7018d29752e9909184b6511ac89cdc250e48ed5ce0292aa19407e31d0395e68c1b05298b620a6c91a221da6ec2658e7f8d4e98743dc59b505412b57d4c19633684dd6547e265662fdf0a9323ad702fa508daf7d9fc5cf2ab077d2a974c1b2d02d417f01a3f8d65908e4535e3a5be970c5e2d56c991c820901ce2c0d608e9f9fd951b5d47353966aa2a4d3d8b62621a401c535300b251d33fe09d94699eb76c6757b1f25871e3effa3f8c93abe3c3ff81438aecfc8e92581d346be9c93be0bc5c28ba9d86dec44d03ff0a7a365bc151ce219dd347f929990c3e64ba2fefa3d5e23f72187b4a60dfce0c8de1e80d1aaef6c20f71a990a099c22b33803b922d8ad7203f1f352129cabe38ba7a4d6ee96937ea62029ce23c38e9e2868eae0a6659e3a4ee67ff6207328e9629501d37a228d949e7f8e6f71c94b2dfa57f600592b3f74047ed0d895d018ba5ef28dad2219584843e45a3878ee1f862bdccdcd15efce2c799996320f06cd52ef44d460be7546bd40281877a1b47cf259e69988ca655dbe104c82f0d8a001a8965238c0d5afd6bb80ad0d686aa011291dd648d6a00c6f965c41425d3026c65f56b75ce55e2847790d3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
