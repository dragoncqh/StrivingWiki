<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b623f6da1a4f58f676ee8c5243e26d7f8efa3c767b7253222081c9c08f8e83260cd4d783e59a8565c05c9c96b2c738a066021036e0f80cd9d8e9f26ea612c3e3cae3200f9d481d9fae766ff3eaf652650f9bef8157f46412d5224b6d188ed933fe68ce9d41fd39d218681f3067ea0efd0f32a239cb9048de559c3e99a90961f3c93c9659e7dcb851b7c5e1e7c96a8c7f405723eee95eb305014f5d79aeeb523bb2cd424be6d76a10edc337d38ffc51a2a4485e97a56b5ef5443073969e0750c88ff3acf5912a0ee2341fb9f7a32c883d2f4a8f331853714cf6629e1bceb6b9775433487934ce27faa715a4fa16373192f22a08e12c48fd09eaf3979db40b64cf1e209a9c85ac813c7aa626af392c7666bba7d867283435c311e41f4a150ed4f62a42fa904a46d8b6637cca782e84e0cd01f38be76e2947d1cd351ee4724e61ed676758f7bf1dc03bb0ac46a74731a8a32863699bfa0d74ef90af42597a51ee5c815dbabfddb940145891d65666837c967cd2a2a6105a8b10c57c5400b9d61227406d3763675004d0326e4f96eee263c6793f1e1dbcb3047ced0d1bbefd415b1b4c1a707da3847d43e21e82f0f36ebb9f0945c49b14cd7a4cd85b98777d0d2fd033f1177f870beec24dbed8975bb2066e3b9ac8a8a2d632151a3c73375ba831fc9b9860d4bce4f0c0ac095c6e7511f11079ab55b61f45c8a21454f5ec70920b6e196e3f34deb0b9ac6570caac538a912d0748acbbd5bd9a712081e76adbba845606861cc589d407114fd57288f0d3f1b85ced02ea18198a4f1687dda97911753993b0c4157b8caf4206b28ed2bfd6fe04d1b1e40b248a4c433fe836058fed0d4b6517c27ac310375ba3feb441358875abc54e0d277db1a2d075f308f8e4f7cce6bc10f5f2e813a5252debf115ddf26c39db50e664a4d13bb9e68308f499de886f4933f1131110d3d198853f0a6d6d45ef3b0d3179c0bd05743633e51d3107c51a6d762e3dbb42de2b63ed95f84fd911bbc46cbf2869575a5603b043127aa7249e0c1c00c7312dec168abe0ffd28896e8ffdd9583ddb3d20c65d438729e7d87b41e45bcb76db60ab86d20b6379affe080c5cd884df62e8b8b450259352ba6bb9fd3b11070c17b95e418db867812510d4da7a6c2805e0e4a55b231b3622926ce1a3f538a4a70802c947bc73b9f27babbd8696f5611031c47a74ed0715a82568181190b5cb1cb40ef327395d0436aa8b370bd316ad6498f84df8bab8a52676fe97041d2cee534dd01178114173b1300b51e63c18a04b95f4b511a67f42b45ee3b62f882f255df1580ac5de281890b33eaaea10f6141f008c04f9e9b6ad95239158b6a44a7c6accf58bc7497b95b15b2b39dc39f178b4523f8a438901bf5ad7efca0697a667bf2709e2e62d1a23534c20b30fbb7be27abf16ebaf87f90146dca53b7bcae4e1cf1913f37900d5a192abc0d87eb882b8d2747eabb311ada6d533ec5670025a8562a938efe21fbeab84e0f19b66b0d9d1bf2f8b215b1eaeb9b1c2beca8c12fc888a440b5aa60d4f67101f54a6b8bc865e1c65625b945515a61b87011f1dd30dfed026bd3567d2fb12ce672603c755269d38c500953b65309e644e8e75394d9ec99184872b8dad4780a7604c51f2158b631c17c8916bf03b093f24513852e557936e4256fb20c075bd49a6b41682343c87f3f0c970fdc2886f4dcafcadce059884de134574e84b59fec1cdcf363bad046a04f25103086e6b0955c5c3f4ee70f593602c8250b043c8bcf274b74a4111d9f3960b10078a22d4258821582ef445586611e072c97b0cc33fb5e9fccb085e2bebf0fcd538b57bb0c2ef45067e837eebc2b935b46ca2b3e6c019525ad9ea84b1498ddc75dec897b4ca77bb595c1570fb470a7ef756cc323bbb0e7ecaf56cc07399cb77d690205324a974f8365690577dd7cdffca9000f2a7580ed4ed88d1e10ea0c7c209b99334a16fad58301d1a24d966ab2bb8c2b95d36739e394b97d8981230ea577735c20e4f28dd56f0ae1e9632528728719a3373487a5b0e37c43bf339b34a22ea441223b6d14fffb2b0c18381f3af745e5a087e5920db9602e8e0f9e4d2a8d330b024d196fe9fb2740bdf1ec0ad1c501eb540fecbac903b228f527f48bd79a82059d4ef0008b787cbee49807f041bb3785456370eb24b63dc8465a57cb99ece23bbcf02905a96667b00ee7f217230db9d44adae9a2621a2486e09d0bd6126e1d0d652d17c420c35120a59c41f3bde5243deca2b01684330ba8d7cd351267c7a5d71af59c6e9e1fc21a8bf37fa817a0366108f595844f47356919ada32ce31b064afe5f6778b6e6bbaf487b874926f46fd8caae04c51ab8a9a52383d2aa02269310c48a7f3404549e60c574196680ba1b2968fb738b3783e90f5bc7b3088442fc2ca31ede62cec9d09de77998c67df8ac66d12c1b5157904901639a64dbc8eb55d75d84d8bccc0c016d14c31d6f493a2ddcc604851204a365225342d6edee268991a302e8b571a26f922c85405eeab9bcd9ad771c97b961f9a7222da9f9ac7ce2aecc8ca66dc68916114ac7242d27d9eb4f23ac15aad8b3c90ea4ba44badcbc96356aa698e2e862bb3ff628368862cf58e55e06f82ced6893aabc2d1a54ac187a3d2c5ac6c8b3d07a7c566c17d07fb0e3b2f3bc3c78c08174854acc268eb98962c857eb8959ca8d63a33bf0d91ba3e86541247b8d0950c52c8927af97970826470b792fe2ebb0e8b5692577c82e097821f711f8ae1356c8a4489349028f243bd2221e707067154e49864876bc4e104ad48e6791eb3ad5f1a855d7070200eafb0788f6e39c7a9a4d2730b82b84b41eda52f03de08216527350cc74bea060a3baec9f4cdd284710a60de927be6349bed393661c5230c47a05dd133ad4fa09727aa786da6df1888865e1bc19ab00b922c81bacf7e6562a89149c20af8e9b457308db085374348751b000b8b614fe1fc158c6ef29e8ed6e11ac15b08d001cd0c0d267cae523e76fa3bcf36d9d1e6000625e91429087c770427f359b8d35a841e6b4bd152225f8ae64e3012a6bac59ef942b0de0005400acabbd3778741f82cefad27ae5c52022509728d0ccea09f350af47e54e497e90e978bc19018d24a9dbd57a129c3a71273edf14034913857758ec2ddcdc737ef6e224efc29f573c2128c092025bdb24345380f5b290e9c7e74a40be2f36499eec394a6a34cb8fd563a641739aa0a9725c3ab0bf36d5125909aa289eac6b61bb568c148564831e1bfa7bb1fd3a9ce2799827bdf2f2d7fa739bf4f85f72a01854692057b08516056e0a20fb60d02bb7717cf06954ae44bf7421913362ff4e5f9168641b0e59889efaf72cbd22a55b9d46853032606ebcf3c2991216e31d2ecdc2658afef1b961940984f02615f9999a684f9f7d7e3bce2525044af8832af3c8c09f3b653dce342cd92a9b9899645f98ab9ee546790100ed6b38b9a7ad7b226b3608afed9b50e7a5bdcf60ca0630d6113bcd882baca71d9b1cb8f29b4044fe22d49c4a3850502a06820a83ceb41c89805fd3792a2e8e52d7301194cad74a852e258274eb8675ba781870793165a523a2fb5a8ed2840a9ff13447c00b0f9d6794eee21eb42a3f6af4fb181c245a125a86690ed8a4334011e9d721a47ab7a9bdaa9dbb64a67c1419f9b98299712263985fbf44d15474c0049d583033b53ee7b0063d3fa588d842f29e2f84777c288cfa240342ca1e18953762a5bf265a6f01005aea9d9d4526019c0e4db5219dd9755a912fdede93775e23871286f7d6f53d8828f92ba97e840b260cda4578da671e618a19011ac095839c4ae92c7f7768012e63652afa3caed54b2b14f3296ddc053c78773a7af584a787d24b829842126cf527de8d01484749d6583dd915728f192fdc6b13874de528178b46027ff9bf189ae7d42c69a9cc9e156e960e91c52d1fdcee32c069ed5b0cecdd1a39fc2688edb17966f5a3bd97d07c4c4b9f897eda9798cde34ed33e288c1913d8def8a4af16567ddbb4e145cc582a3e3cf096b687756610a2158693e978706f21ecd14eb940087ceec2e9ef99cd2ac9c3c041f3add2e56eb517a6d615aea08133786eebd81ed8b3bfe3851c2874861d56188fe1752ab2e1f0305647371a9f23c68d0064d6dbea44b88c94a54189cd8260d7a4cedab5f8edafe62b8264f06f4341a612b99f281816e316f71b12894fe5e6e7b73fb0d94d839272e6662ba4c5b406abf7dbf1a23ded23db98fffc8ba0722e84ce9ed25dc8b27398802ca381278b423e2b284074d932ac314902b3ff7082a9b402db5abcfa1e2fa50b65f1b8e4ea251957ca3bbb9adcd38727ecbbd4bed83aea4019f44eac72f7c7c820467e09637b995bd69c76da57cfeb1c1adf23f7555484bf8ad9b5c6558bf5ca65405a01f082c5caee74aea4be6155daaf6057fbd0cf93c5b69588f1d45a3e89e02c1db5117f6abac474d92d757d25751081bf9342fc2c487b9fa7c3f471de0d4393712e36216370dd6063d72eabe9aafd8448f8a19a1a3e0da553a6761e26af0ebadbf732c8f4b4b9cbe37f7a594f58d9c8ae694ce7b2525341995029a9b793d3daeb975ce4842507321ed519205f599e6b9e7da5d1c7c82b08166c2a545ccb2c2db8af33989370fc2ee75b8a1ea9f2f069995edd788c2f428ab9193219f21da0feb9bbadd2a947c754f9d22e02a38f78f0037743cfbdda6c14d17006cd2b86c598c1e63ea0dc399e15b6468a0a9cd60316650929e681752ec857387a692f9ffb05b012bd0106fffffffaa0be3cd42645d79fd43f3826208c76283934b402e7ba2f5a6bf5da290c04350868ed60d223354536e45fc5979e46a52f93560b5a999257dcbcd54bd4d00a8bb02ae0c8ff9cc6a86fe6caadf4862ceb97e866f6521c7fe0ef930410260a7fece2fcecd5c8872b79da0ac4e2ddcd01b4f2cca2ac3babacef3dbd627b6f820f3761517822dc589d3b792061d29834b70b9b0c8cba7bfafd3b00d44dd90f368a9ecc3ca66cf62167f95728db9fe9a893a849e862edad26db709d81a9f5906dc0fe1606fadd2532a7ba6e2f6fbe1734aab1a253c27bcd55e8a75eef4fb68884672df1c81d18a2e0b92ebcf5c2e4b6f9f770b70152b693d1b5356cf686902eb856e433ddd02a260333fdbeca79dea7f8db5e79ca1a41a4cda0bcea0a80cc7e7682d35575c7b71d033690e1075fb3d1f1f6c9815674072a68b0ea23b2a03a364f0cf1d5d3625ae3761e9c004ea1cfd39a52b97cac59b7675f433eb0851f03021af984d3fbad4d18277bb81828d70fac74fc7873a1f587e728cfa5256e395000ea7fe0427123cba408c222e68d07554bca52cb56ec3a25ece35c9dc2bca02bd53e07959793db74dbc56bf92e83726efbc638421a4da9db174c7bc5036442bab38aa5562df0315ff8b1ab4ae68ebdc299739cd4fc295a71be0c1b07b62acc95a68672dd3109e196ac339e9d1eee20f2b8e8d496f98e74753da7740103b24ceff4a1c26e80637d99f9b6335dda40abf5120fa9c5f104d5a4ce58d061110cdf6b3d34f96ac806d687aca231ddec87561b5a63114b9a37edb72d4b4670a2e765e16a879b5c14a0bfe443eac8d3089fe90dc51b6ba5026e5530da5287c296509ab9a0e69723f437a6c59016d0a58269c5657b78eed24111e13cae818e22a6d2bb9844e828401d5b8bfcc495227ffbaa41aeb861c1941dee2242df9f1ec2e957e22b1efc29d8762e0b3a6fa04277a1c23074e285acccdf7f7425b57440c3c59482c3eca543b5dfe0a7a719e64a30b4d191322c3fd16f392d4159f55cc574ae93b03aa777f87c40aacab929b4872fed95efcfa514dfefc732754117c93c2a400b0feedec91476307f9a681741e87555960ff473c99a79e44d61fd99fa60f4be63624b0b62e976ed6fc4443f5f271a3c5790bc3d838cde810aebb5319d2f32df0e38409775d2619c85f8e3ec828add7e06da21b49f3129fba17d2d6b949450f493183ab761846a3a7a8807b983dae1c08d27898c1af6f23a6bfff3cfabc85abe8f257bda14348ccce7faed957d4cd331c372b4de961eff948fa55c1c93682337bfab1574ca2ca264f5dc2126525695f655c388236d6ad7ffa17783d19e2d402d8509bef6db6d4d7bc1a2c362312d59c84fc4f6a2cd45c190783cafdb7db82cae2118ae699a2f1e92a51608da10e1174f04df540b110b42646ee8228711b52e3a0f1a6f8345d224d285488c08e7c93334ab86967ee46464c69940020e5f019a7222b32bde5f24ad588260d08dd5547e81132f55fe0cf9c2f5979472d267c519838a75cd68a5e7a6a63ec2e0a15f96043b6b604e2a85ffaedd44e0a36fefafe3e930694080ba708daf9a8ae05649e5fbe476250754c1ee4b4b4b0a0265b0b7b69f4e2492718e3926168beab4e05329eb8149fcaf7e9cb83a648853c67fe2ab106d55ed4e2d07d6b225e474476cb843179deb94946a74dcf2289b805ab3d3f60e23073303c8eb27c0e0d1c38f0a21cef829cd7e84963f26421e0485373c21be4c559f0dd0601f969c55be667841aaaf86da023224ad10ea981c40145e9d485e8698ceedc32315435f2efe6baeb06e39dd916b87564f7cda46034c8495018b9ee24fb2a7c86da2008337393ebcfa827af754f1319052c1ab31aba7a4b19058f56985c4de35d1b46a17cadf468d456036beecab35663b303ed5c3c96492948f8264224392fd19701ffaaf2384733d48038c42b217090c82670a605bbf75d3a3dbc7cb390d1e6809093774874e4d6581237aa6740e5b3e5e6acc9dd210fe4147916d2a4509caa01c7892d292e0e7ce12409aa974414871aa4fbe8eebbd1288cc05769cd5132df7d5e44ec9b525d5fdfa59c9b5181792f9fd07dd1a6336b0b9a99401064f9d8d3d4973c8870163789ba2813544af47243d7f224333d04948003dd8c52e8d374f792ca97557970ef5f9dee4e118929bba6a4781a6d2be4b8817e57aa37cef34407095f68d4a1989cb12837edf3940da1602d2177b401480f3209bdadce3d63f8e02c7e8bd4a7a4ebf6fcf6aca987142a2b12b61190f86c1dafac9e22e388213a4ef0fee5e93a00bde7403ec8187f3e87407ca8900262d1a5e2e12c630209290cb2c76fbd0397365aa95fb90957acd9c3ce50dab8cf8302691baca567b8ae30df8e4b1d6d43f3850e0c2fed757e6591bcf853d3106d1ea3dcd2b6ab7b53d43a028f959432fc9f514db835cff969fda9ca9eb70cdb8cd0ae15ad7f89f5f1022fbdd126ae435806e0c9a9cd8df13dae71b10e80253f27beefc92bcd657af15474ed6f0c24c866abdf2628676c7da8565b85d8058c3f5a60a4e13946515b7a221c4b9e0df3be6e919230b9896f9fec52e72bbf6839b12686a606e5279d1c49f5d4174dc1af21c71bd00adec4d777cb3cab0b2251ffd31eea0e0708a3f39591612281283cf7ab4ce4d14c89cd10c623e8f6b66cbcf8869c840b11b38df65595162a0dd8c15451556f4136dc3e398ea6b6be106aba033e396797504821353eed82f5ae066cc58a7efd1352325344f855492f1942c8bcd16f2e04e44fd3e55ed58fbbec346d2c2818b2a92693a91ce262b1ba96a85de67a828c80e61ba41236fc1f3b41b2018f51b9477644c86f80aeca7a3b6d0a302b6c7b12c35ac8d6232e54a2a8ec0d00191bb1c7939509a6ba6b6b473541c893ac9f90d08e61d1a6caee6eb1687d45995d20ed13a3955100b7cbd7460af224314c8c76778b3f031f873180b71daf744c78601e3f2acb3a684dfe5e5abf234dd62ddc94523df843ff3ce7c5fd12f4430d75c82211b979dc83775e3b4c972b2e6afa89449161a086f707ee6e0c1c0c774c30c21b7001603d6f43a8764ebfd87bcd461f397ff8c944a805ecf2e6a7f72fe656a590d0b2e37370c420b0bf99cc7eed3715121c58110f2570516ee25e2b4b23756efa0eae7635ba61186e6fabf9a7e76fee564f4fa4559117127c85f5ba19adc732e733c9909b58c155921a72594a473564fce37eee38188d7a2ada3a3e42a24a77e38aea3577edb879694e6d78597ff4fa7b32d06771826c0de31e752c9967b9496d5a1ae458c1a0f28aeef84fb6f0f59138a88a4664054e9edbe4cb8f09e26031d1d02e1901fd989ba83418d6a81cb6d3dd7435dd73549c992c58f979d629a17c01c5260c30b6d4119db9d2f2010ce48187a5c4ab727211984358f8938d44de88ef3b418a7abb8afe505e35d718ddb95f27840a1ab9792d1c4a9e2688beae3c4ace3938151af55a57f3ddad40f18b75eee63373fbf449f263b6a1a66d8c862e76c815e4b6d2234910c206957c20237e38cb0747b702bca1d9794162c42a842c175b7de82ce98c5bfc755b7f6c8e04a9fd943965b4a47ec908b45171d3da930df906edbb719079660eb62872bcfda935960ad72ee2d9c1071565c9bd958e526527b20b6ca48c58eab6d51389246c7a168c7ff48b9f1a9270e022c6d3e83bb4e30d6fa8a0fa8e0dfae5fad79db60fc2a0f90967d4278167f8b6e02c431e6950cc22b896b3d301b9a90c93c0c34362995ed29524b23e29b9f8fd9d6cd662503349940051b806725d1ad246ad5b6a1b445f2faccaa23f15553c3116c08e7aa0875915795c8224a4dc7478877088cc9a2f46e583f91427920d883c7df70791c3e972c3460e7935ba105ac22d70ed1498560357e370e7bd1d9e3948257b4a9b85a4ad5b93219c0eca5fc2e22e8f488e38b0748300ee3f85cf33c3ad5c6bbc04b01534bad05add7abd8172f88e9d3f10c983cd18fec8b7450392e07b33e6481ca4916b074b72a27ea9da57436458e052d0a1ea3bce2325ab2f7c510247d8ba5447a8200d61a0a5f49ab8fb8e31cea97babc84b9ad461ce07f92a27e8f1f12efc76ee5b0ffcccec5567589dae077d9a81fcf54064e2c165567eebb7fb6a671f0abe0c4e23407064b5b1132b0659c5f6b20769b597464b8ef10a9c20caa989ae73eb1b6a67871c02de2d79927409f48cb3462f4862c5bcc19f936707d4fd971bd1af60b9a1de7fa7b778b3c3057e46518215b0072d7f1bc94819a2dc358f95ab7d4ba4395204b45193823967bd9394abe0e0984906e6fa13dcf46da50d27b3835834c6f9c223ce105c5e776bed0d3a9436503b235965f35bea6d5ab3cdbd6276136dc4a07f5e32f2e876e2ce72b63b1c5c3e912f1faf4f17847c0923e440f13d3a2891efe05ddfa2288ebca7f88fb3d8f50611d204d3e37088748e4553f1a387285ae50f087e97136e13cf34619c6d00f40661dfd7eb9b1bb8640cc72dcef0a58a6b56315b7fdd496c6e959da78eff17a3f06e2efd56a57d47964e840d5833fb0e0949499b5bb8c6a57298f6712b78f6825de7af036228ccf5dacf1a00d48c2164d989774679e58eb199d8ec285805ae329dd82182570e4e505129e9b7fb75a62fefaca073ff6cbde6290aea81d97a99787498208ef13cd454c4abd05255da54bdcd83d078e336e6f60e1e08acecb86834ee3e8de3104907f34d601fc8d33f75ccf935877a209997c7db32d321ec7f327f9682c664a1423f2efe3f12b1e68dd30193b654366fb385ae65f2ba98c604969aba6bec9973200b45e1d371945ad1cc3071aae23aa0f18582edbf964a58a01b3f0e7a388fcc106b693052ccaeae4f0532ef56f65a5e48ba1b799f74ab198fa54e5f1735ea060a3abfbc53f9f5fb301893780f0c05e9e045fd039ad36b6f96f5156b35e74ee6fe4e5c72e469370f582069c0d109573b4e1a4f1673a5958c1647ac216077279c492a531cb27c723acad6d9d4934f24957fbdb030bbdaee2a024d9483355dc2a5d6102a60ac5cea3ae4da756af870407c04bc9bfcf04208eead1ccdd467d21f36347bca51275afae77c98de1a676804cdbe23945b8a4ff13305687ae32a8839d4b023eff39f8a5e6d3fff72870c329b17f0694ec2cfea09f044c97f4d716ca778222ea379a165f2e817e1e710ee47eaed5f5fc65a440c2f73adf0d671e147cf89ad8d7f9132121d8dafefdad4f23d3cebda0df3a29caaabcdddf8d44315fe8398e70a769b8473b9bf1114646ad8dca07262b704c8e4a8197b1f30b623ecf95de938d68b45bb1fb5fc3d346cdb3c20e57b8c81ee588dc0411f767e3b19a2463ef1d417ce89fa27f28b7fde948bc35bfe0414dd93ab9f66219e67c8dca5b26ead3d5fb3c1e36d2a747a52f5739cc17d5f09eb924623eebd63b92b600dd8e5d48a850624a98b113122eafd1dfb26753ffd0c7dd4824143290442cc56707cb815a91b2fd32916d3595de3682fe2b482804b26dbb4558381aca2fce9cf518a166407e701e46b6715169116f5c64d5efe82068070870463ec4f46518aecbfc11b9b61226dee62829a82087d4c85d3919fe17911646b517e854baaa74bb06fc435bb4a5b07e2a83c05e8f3b506ded41192b16909bf377f70730038891c0a8726586d5c76db0cd6f0febcc6f246117af3b594b5ff50f08341141801205361e8885fa71c1a76680bdff14f2c31bb12b95deb150eb30632d8cf9eb505c1ada9551492745c2993fff6b300386d84b889282e6d22fd9f0d952352b4432c92ed5c0b212ffca455617347c15d400765686d5bb817bf18ce416d3f121ec06f85fbcc8704f8bd75ab9bf7caa57ebaff1ec9b331260188d4de08264fae772a43015d6f6df16051ac9465017f6081c39aa9760d2ede2e9268b3b8b60aed30adba6cf7878402818e12de5e75de16a6f064892edbca45915a2c954cc4cd477fa45a6f2334b79f42ee6be265034ab8b48ae22bfa7a32942ee599ede3d0d53e3bece0d7c4c8422eb2d27d565f80d0e52642076913f88610ac6d764a77f1a5bd9ffaede6abfcc01d7e150420a4a8c8b4742307dcaa6ce18a2f65fa49419b410d030d87e3f9b0d5cfd7927cfc96b87de8e18343a8ceb181ed85aa35b44c51a8e80f7311e0246f7f85d2661f1d1fc5d391a4903cfa6c5a9e8c8958122518cb01b5d704fdd3719c5e39a95ee4c7d8ab3172a59bc7248cfe01a3b71d9764fbd49d41fc9881d19e34841fe6528ae2c57578491afdecc20f8ef52a3d2001c24602e5790e4346a45cbd252c2d7d604238116e3c8569fc79e2772e57e20179f999f5b1f5aaf6f3617970599e96b02392906d4c5588977da712f19819cd36b2d22ca8a14c2c8c1f1c99294bd2d5afbd04f5a19b3f6cb154df9290fea0fbf28c92b53827822f099e479a884de9f4694601da04cca9444ddd7bd1958bca1cb3868f891a1962a1ddc7887d1d6c2fb74ef52a37fe0b875d6adec4bcf177d2150c972797aa0f12c1dbf8dd5077cddde59b5bccca5a03e373c748a77923349c54024f33cba999574a59231b1f5cb70495f3ef7284fb6a39f253d12b5d36d4493d07e24f121b790f03626744223566d65de26d032c8c6ed69a73d743253b8b55633301bbe571d1b2cc89916c799d1559e64ffa029647b12ff623bf820fba132c9a2b569fd697310ed72bf9a75d83328578e4dd7e302d2d49ce0b45326d22a5680fad9cac88e9c57c940a9c8a73ff23a2751780c4bca26dd676ebf52597e3478eac1db10394f37d4f2a28e699dd3d014467ec01551d1e632d808e6d206caeecadd849b7408c0fdf76649c9ad9ac48a50016e2acae95ef02108b736e1599634a3e6a938563f11c92b2a9abab1f5711d11b57ae2d3d846f94a439c0df2070083de9c25266f795b29e653660760cc7ccaf3f8591d09b53546d30f794c487df214295c6e554c8a29cada32a36b11ba32702a4ff77a258efc4a325c46a687ed712e4fcb24a381c6b0f7ec2c436b36f9d9b321be7c1d7a79697eae1579df71c60bf812f3c28b14b4cf14f3c624ab21a35da84e950a1934f8a25d54587fdc8dfd679737ec9633c4b17f6fe7d1f22e7b6b07032a225d912966467f69e5c8c8fc1337f280cfb42b7384457e3026687f99ddb9721b3b66f52162ce525584d675b1b9ab8884edcc1c7ad37b4cb27fa54fde79959cf5c545b359044c6ec0cb4e1ccfe2f29f77a6ce2ec3986597be65ae802cc24f76dda4a4e6ef7b11d03e4064b639cbeb50f317dd5629ff094a8d3f9e67c9c8c28c260c78cd058fb2e58c5e246264b48879bfdd6f7ddb359579af379e136468aba90616dbdd400cbf6360abcf5b8cce91ec025ab72964cc98f2ec845081338c8715d1967a2c83ed9d32316865a146cfe6ba364249dc4cc7d9da5aece6e8087ef2eebd1311e3d9d1a7c215648a93b7148a83639143fea1763d8a0e67f5e6a18fce671c6a8eceb8a3698c73dc6e19e54620aa0591bbd36d7145f32b3923aafbb503dccc08dd7663856f3610a2759862e07c53611497eece92ea3d08df1f1d129cbd9804e335bfab57132a78329c79b57848490bf2a185b538833c44bca4fa0858f10b48665ce1b54b68c0c9962d30219bdf09942788cd935d10001ded9620c99efb0cdb741d0d8133b883ca23b66fcb3cd3c551263feef6e2bb85d727af29d4061a12d92190386406737527d4682c03178e36e06cce0a5b58c6ad7bbcdae5fcb9d4efe771646c4feba107ab70fa2bafaa6e970e8863b9f2480e5cbc6827c47c905f196c5b0680d708eb19db034fb9abf13e07a076382cccd1bdf52565f2db9fff40e5a72475e71a3534a3825d1598c5feeed5e4d67746144a8801bc43e03522a9e498ee9371378f550d4d7a1492c928af8bb868eeac3ab80ef00289fb2715b7bddac2fbdf2158a6854ea32e3e8b7b80721435277cd227049e407a7ec0762ee30def3ca7b74c223ade94ff4c9b49f179678281e586beb6f151fb104656cc17a8e28b04a9812729434eee122e642d8c9f8407563fa455cf12989cd4b2773b06341530ec17afe1afed2b2c578ddaafa15089ac84c77c0ffed90739ec104e87e3f272a5cb5b9faabbbfc41171c900446e8a791fae7454c540db3dde1c267db6512b63627f30d23654187e03e8f93e639bc59c7b26ac376646fd8e2e7ad364176f6796be92b76921e9cd67dd2f946d9e48398573f3bb318e78de0956027ebdb71ef883cc7fd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
