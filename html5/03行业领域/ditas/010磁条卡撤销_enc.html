<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c21f1b416154b190474a7558b448e0cb114cba97bd696a977abed83884eaa09bc9fedab4bc0304bdaaa791ff3f43514d471698e4210a2f9e6930470b4f7b86e2e64fa40a3d1650e9d136b429c706358ac1647be074e19aea43d45ec8dcd49800e6fa7b1bf52ca17c5261ce97d9835a207621ead775abae97a9810492c39a114d8caf4374438b55e11800461904ffa2a2dcf3c6b08dba46db58df21135828c163ede8030d77b0cf65edf2c4fc2cd5ef0db833a50700dfecc96aec2cd40da027e3e9d493cfb61f1b06a5d466a92319633c959da77d3ac4d44f417192d0b6c6f043930916e88a224fcc759183ef0facb5178473170375e1310cc1e0981789882e037c60d3f22b8574fd0739372f86b0876df2fb6466db336f36e7c20b7ebd5847beddf7342a36c51eedd14a94a312895a75235e788a2f38ba4e72dfac88c495f0a9ba98743b853fb65a296d3863f7934081f2d1be6fe4a7e576ccf21a232514da581a25144be13e0fbb88d93c949dcceb026cfd75e2cddfe3843753028968da7a304616081a822cc9d6c893731ea1efe334fe51024f0d1a883e9d959eb9047762f49c55196bf37ea39a220312272684b680287f86459de4165c803aace81cc86d55bd5a28f9f0c7e4dc60d9ee5f5518d820c1697db0354aadcc883539b78cf1645332af78bccad13f17282267eac33ad542c307cae5df770a7c31816c73684d95260632b50add84dead0ae7b0c20e7de3cc10c1f5b6997950e0bdd7222af94f84159e3fd4849b2838e13a428d0616f80d258b6fe7012582088df6a41458051beaa026d44fe39de907f6f4285a103db800f617aca18629e0c1e5129cfeaa2d77cfc6c8f35965d3f002bc8b3bf085600f281016f7ec10bf97b7a2efa3aa5a4285ce93ffb2145f339112180af26abaaacdd5a0ffefe5ab3d754fe0c3480f2554ece686a2186dfe3ae811747fa7b375612ebaa3ae4b265180633cb57ab4e6a93531ec8faf5eeee3d9e3de6b7478d1f155885827ac3d307dbe89b6217ec29f283706483274fa7e6cc75bff88ee14f6a73db05a759d411e3cefd7191c5c3d4c6335a62b462b369644be33620bd70f166678369dfde68cad5669a398e085ac68083f7fe832221deb5a31af3550399bffc0c32dce5d1fea5460151458de0f7181b4dd30cbb26175d10d5f6f90ee042b88ccc1eeb01474fbb0a68dda96c34f0558deeb21d9e67a7b0817c6a395581d219e75db7668a615ab5bc9bf5459f79b8aeb963c146593f7a122bca400871f25fea7e93f575fef6ed23871ed56184d6eca7f6a921ea2dedefff061d36b5c2b7230d053628ea2b281a40da89dbb1e71826786fc9ec498db2f744efc0e090551d12d98a353dfacd38ba1eef8cd8e5052e7eaadc6452b7180319f0b473f70232fddc71724fd0a77bfbab15b2881678da5f3224400fb6b595c9679f9198f0a4ec7a0e236c627951abbd115dd8146d7bfc7d9adc2170db5fa5229bd9b515ed561a1ad83aeaaca341876dd581a46d1966ddb0c1c05024158f9f2244706e52e5fef5d38609bd4c3f24290c36fdcb9c10e423e5c77a8e18720b33a69556b415923a9b60eadee315df678ec73b30426cae712f34dbea9a238abe005c2fd55facb5b30662552c3730d89b4be413bbdbdc69d944bdeed836a4bae70019ed3d3d53be656d21b1bb385516430290db0422b8474327a269b573a59984b77dcc5a7b2c765ca3e9c945006d38d5c2fdd8455d60f57e4b3fde6c8db6ea27550485b446465da1c50f8499939db5531579924a5939ee99486dc776548f32d53ab5152f476c64da554532389e857d84c98617d027c5b30e021a6d270ca785f1ac0ad1fed5b1ea9656783e09f96fe36c1f1309b233b846d5af0f19426dc18cb48cd12f9fe5c24f8a505028174cba01114862cf77d16df85179ba3ba7eefdf49c6989f4daab994a5a513e6fdfc50e762794caea20ecb1c596b70149fc14e2917408b06f1f3957e1d54395df6615c140659ac20a92d8573f9054d0d4a5c9e537b4be718f611983e37d535436e6d9df4290b1235d447e40a22ecb792982cc21600e8771ec0f6a990a4796ebe633847370307cc70e664b61fb7604116758ab73db7e9d27d5fd3cfa535718e0586616f2cbea597fe67b3e617f8bf595c2ab3c32906f8eb7d078883da661563aee0fc855606db3e117ac59eb694d16b51c54c711f8e74ca8942aba1415bf872f20bc6a89686772af955aad114e5be291035a11e5d8f8b827aec4e186d4b5446fcad321436e121f36a5116a6b94646730298a009cd173a7b3a38f94e1f5adcce3f7d501943df5b683538335861c9d892330d7c4395004eabc2bf9731539e697d1ecd0a616ec7134c5b70a1d6e9fd496b8a34953fb57fa7220d41d53a79aae1c0fe7c6e659c895620d0c60b9066eccb701052d41fd9a1041c21d80abaadd83cc70d2cde35f56121947ab0cadb9c17fe71a93a74a901d9334095764335b298fa9c6c1d63c8d6400a5b42e0b37db2143f0ab9942c9df49dee6d6b96295ced8d65c2c09c77af1e2b18586dc0df9fa252026d2ea4f4e83f9c899166dc6141203d09425782ed2b014c6d5c332b775c9fc27f6739dde159281520f4b4032021107ee64b1d19af1d715c09c97cbf8ef10d8512db4c7e6dc8bc92e0898756538b8c8d7ad503e62b55ad7ad16c2f3f1ed765b9872ed1a984b3c55048e8fcfd939137e47bd2b87507c1efafae7835ed252c2e619da26b7b121317323a9a847bd20ec0066cff0d58c4e364210d5eb04c4b5500464255025c73703d8a18231d3fe72acccba1ac7076a8355c6405b1b9a2b1ae0a3a57055834ddb6ed3e1aede7e05d981a3ac04c0063bcbee5d6be2d3952a413928e1a3e7286398672a9f636e73ba7a2d0729281a4d4ef3dd4fd1c03a7eebe6ef36a9a4a93b9969ae4a3b0ffd0a4c57810452dee609b8c590a9a5b0227f5994adb593cd7cf3fd630d4f4049ca3ce6e355331acb9e6994ba3aa9e50304a15647740aa308c4509dcf8826244b113cdd738722e567a3aaa2bdffed43df9dc529b87039b39f6ed832abf7a44bf89dfd7fb206b848c7f3e72f7d6e69a909a26207dfa6833e6083fee0a2bed6fea8e9b262c8bea6e178962bbbd93475e5a26b799e317389c6207c0d63a344962c8b520098b16e3c3ab738f2cf9e32981eb66a4868d4ef89c3599ca8d25a5102d64d0bad1f6565c5f6110a2df3a52b55b36a475d4a358c604e0a2cc87fabd522e8ddff63d3ff0988414a15d55034b8e28ae898f937a8f3f3d45edf843682b9700bddbcc64cab4614f1b50cd74f92f320ec5625e86b1922907bc372d4ce5afbf97eb3f88ef44b37feb16e302c759d22bf29fac147edd56d71982e78a1976f53df34cba01b89d4fe176e3345da4cadaf7826fb9b21bfad32df27f54082cc969353fa11de12fc03cf94ea54f24f0d95b763d2c542a745da57ed7aeb6d5d1a13a2641f5663ed5be5d58a004443a589997e365553ee389fb79f2992a3ee03d4788f888d9624419e7f3383fa3764445d148b5437dde8250054b2ce3beb993b47b9f0bf30226fcb60a81a1d11a0393ba520bcf02008c4765d7952fdafa81db5671597fbe4122b1136bd90cbbaefd5af16b3bcf970370a1ed388e9274b735ed737f1398b15b3e4eaf9a1c1c769dc521a23e53b3907871867e86c23851ec4bcf846252f378768f35ecdda6646a70b61f93266f8d6e47f38952153a83df05b796a0ef4013c4408714c279464e58bc22a6b026ace0dd0aa8f10ebd2d47b4a1f787227f6f9c6efa0d8a8b81e29c00842ac64ffd487dd8cbf11113e7688b828f2cbad4891a9c3e3c22eff47dfa94e03aad48db2677b56f34ab9d75fa69914c0fd82828b7d758dba4e079833ccdaa933f725f6977769bbf1f296bc0117b3495c75451b3e6709a80ef79d1e9b9449808320db6a89cfecd85e52640129b451c131a1454c9b5a91a303ea83a2b288b200cd79d21f562754b83cbba441e66ec01ca93ad35bd8b5c361db74aa0a825235676254df4442b07870f2d27d117de320b35440081dcfa059cab93d3c5b85696c16a6d8ea40197e439334a0293553f7c5dd24b4aabe85ed25076a46bc03a92650e8794a5be34c83f13e341620ca5e86b62830b8227a4083d9033d3d4309bed759dc68a6654daad7dc26e88d345e0fcef78a7663afcaae06821d8118ff670d3a8311ef405f5d9348583ba384db531081992ad755a55e5f93b2f44734a1f36875d33d7047d0f5c669ef9d79ce4d909cb8e1f0bd7f5e52b1e5c92786e092aa6f74b5956e0e1380f2bc4cdb258b4c60b7ce50a2ced740c4e61d880bddb5d02f432ba29d9e085359fc6630ed29c86b8d9db055d14594dabe9ee14b53e916110094a0ca809e1a848cdaa220bf6c8e1fc941825096b933281ff97e6f64d98fce75664c6f0a5f1b0f6edeaab36e8a814b191320c3f76009df18690d68ccdcfd4236644a8d39b7a12706457e0c58d08f194fb5c6b0552594da5df64c081f9035d8976127efffca95286039776c02e58302d9b76e99a9ac022ccb151d7d4fc6db5c8dc2351ee49892fa59908b71ba14b144d5502613f4cae4c09491eda1925a6b778ab3740a4278c1deed3afe5fbc4b91ecb9516a13eb127b73f9131c5b9cc2ebe64587a93e94747686a21dd33ca1e90eef58af5ac2aa8b99e1fe350eabca62654e7757af048c25a7d248aa7a9b4f190ca47d00e77635795c7dc1e063228a4bad1e4a7b249ae57c9a99cb1c4a2d377ec601999d8cb276c99241c5ee8aa68c50cfa2a45cf3b0073165330bc980f9725c0b1d46c0dae24376c3178fc6c6d92664a74c76ae92a8a5772780fe96fadaddea494174fea81ac11dcf7a0df5b14126c352dbb3fa7d0515d712d932c6907b2534534030f15a2ca190fea76579b9285b0574159644a1295bda8ab8dcf231c52da787bbb8887047d2376ef10f9bc968cb0a670b2b266d0ee5affdd0405fbd9fb0d0fa001d8416ebeddb5d576a435df4b71fb6361a8de891aab9da789089d40795a9ea5d27cbf45604b38485d44d1010ef5f73b0608f243f53d0a86d9e909aedd946b9686b76df913e2b9a621032dafd70efbc5dcb3486733c97a904c14aab30c0a4eca4a2fde4404d2d82d58ed057a0469b083e39492d20b6d78efcfcc4eb573829d96b7ecc88732376c52c491d970f3fe47713e76835beadc892dde05ac3a0e5a639ded79054892ef0491b29df6af43bd210549c8fd524daf96c905823b5b8d41eaed003658298bc74064fe45181ea58eee463dab5d9659302f11e13a46b8ace8a30a281640e8ea13caa423d17779ea933b93cf4a127cf645d47408b5739c01947f9186a7bbaa178918ac1a51eeccf5e917e41038a8cb61686d7c94b7c5e16b7f64e089e0fe16d4f065f632239872363ae05b908aa68e94d1425a5e8f0541cd6e0d76d027087d11d9942c9b35d876095a79cafd962f818529127c8fd5ffef93d5149834e2b6e91c397c6c458cb67ee7c0f8fb6b1cd90ec60e435a8c3f11273cb326012734bc57492f9a69447a22690f199c9cab2ce5d7af80a6fd1f68db828307d7b065f6b750286270c29fc4a33a003f4e67b2af652db7094b76bc7ad6eab77f1ed7bcb63f04a05a47cb74336570d79b5228d61add0f555390e9800c1d887790747633c33ca55af548e151bb884b631a42b2cc10a477f3ebff7a51711ab4a112194ee1a9c5b02cee141dc95090078e8bc7b41bfae0e9f416d30e8f25507af6b4a78d129573c9f13e573e5e0311a96a30947fe33b9026bd8fa3a27d6e87cabfbcca7d2d6ce6be14b66243be6b92de0a7ddeb862077c3ad1bd2c46f24972519aa2407d8adbaa3968358ffb5dfb6c7f397eb71e63df682462704cc222f2766fd0c5d83f1f49727b0264657311a440e10a9d55a41b05ceda11bf47c5839211e937bc433f8eca1b5fcd1e4f7aa9ee45f79154d8391ea5b2bba1e0631bf8b4fb58879135eef40031728887c71c84002803985bf6dcfa6452d3126d1f37b23140483619c73eecafd23c4a0631cce22386412a8adfd908fdff1343f95a10a729aa1f290cf0ee172fa32abd3a0427ff8f88c91d01c42c07b1931b4811acfaa7e79f383277a633e96f6bd3bae746697d2e9953d5a2a1fb7efaa42a55f6bb395c4de7cb056e0340398fccd732d1c6611af5646e20d7f71d41d87b4339b04eccf8a747147c92d6ac75cf2c885405b9ed13e2cb050518815f416f1cdd521d99d5ff7ce5d8403c5ce861184ccecec42a1073d8e38ceccfca2624f310f0f7cc07b50983de0b0116bfc102681283be1d59983aa7340357e6706b8bd8a19a387796428a13d7b9b371a6ed87345421e2e5ae44933084a997c957b722d95939562973c3101472363e09c1050defb4c1f6c89ce373d012f306663f3c97eabb0be89f5cc484a16241da27934a312321ea20e58f63d814749e9573822c31865a31164b522fb1e4b40ce86c83cc267ec30b454cb664ff614c4dec5a51827de9c8e6e79aaba5a66fd5f592ae31117f9902e9ffb539c85e7c44193ccea067db9ba6bf468fb1e0890f083f931eecbc9ff438cf0a1314a912bac2a08d06623bb1f0215e6183e7aad73335d363a2203e1d9163a2a7b1612593fa667263b1d16bfd242866164d5ec4d0be9562e00c2f2ca4f6476e9901af0c511a8ef2b0f8bc80f6e4b21725a219c873856831cb4167e19a7e5716ef628f7c636e6b44aafcde96af3aef7187e86eb5776d67f1443c4093538352004b03bfcb491f8eb6cfc0ab6995dc7b5505b5b89230805b13c24d9cb973543208525d0a1756a5f9e34d186c2c127173bedc10b47f10a8fd1e81f67301cbc13924137c1212e132e92b322f1ab20b0cc0f2cf77331fd0e9ddb89c7c6b34342a66e05a32aba89954ec9f6e5df00ed11c184c83c5a79d12b196780a453f2af445b7ee121d04723c75e4e6450838ddaaf325780f84c51a3308bc00cb163a3c54a727f208cc206fcb945bf5376e51540d585627a2f0940eb4efa97f8650985baea582ff7749f83a9a334e836c089706fe31ea9415d20d51800d860f528c5997f11ebd56cf0e15a7c85e8dd43c047b3c6ef08342029ba1d812913c46a90389ec5c414599a4ea9682f63bdb541b48e150071afe3f758ad112a6c8aa63f8cea524735fda6025d2a98ab0cc89b6b7f8b61f4f43ff568e754a395aac2239e7965041c6b5da1e6bc6c40ac81c51348c8dbd497bf89621c2254ea75279906870745b6cff394e2f84177c480b58a205bbf85ca1d835a4988c86a20f73b937f15db1aa2897355176d971e195fabe92fb1ab189fceedd9ca624fb5ca35ee3389391350b3c55022b71d7f68f6eecdafbf2f9030321600ea100552ebc136725b74d7ead1e98b5d14f1406635a1a4ec291646de58f4046fcedd7c86147524e0d44218c163f29e792ec607f7c03beae121e97e6cb4e8cd46d1560f80e489e9af1effa4503fca91c43b29c5755f015cd568e61951287a3b72bc425804dc1bb3ae0ddb820f8b123e827fc40d5f5cb9102f160fe01e8c0a1cc7e677c2cbd5fa88aef3e80ee307581e8d9cd9c03c80b7eaeb7e95b96c91620a6922f55cf2e6e8cd65b4bc4fb3612b3677736c026ef728188a8b5c26c0d3193b689e7b4ad137ed3b0ff452d58dfa22ac1ed3909aca77c644736bd56c3aad27ebcd2c36d290b6051b94604e45c595d0ef3d36ab65afd655fa30aeb343a4e8444bc797576cf044eacf675a4808af6f353a31534fc06061cf053fe71e3cfab3cf93dfd09928a274393b1a9ce79e1f0aad0637c4d5fdae525cb00a4a1234604680e10b4a29ca15c695b92e0f287b04258dc4fe9482d65971dbc7287a505df611b73121cdf0ae22d3e6d45d6843460e6f308c1ef4ed32ee35a3f5b7ccfd09b918c66f8e1e231f91cf72e1fd8bf2fea698449fda4465e5bd899d3d2971066303c9feb464dea4dfc52aee3b18a9822be34409739216ba7824502321fc5be818b01de9dcb08bc89bb7c0e49d3878257473a39ccbbbc9c3907459bb6bff50bfff42d701483502599e98157cb2ac15727ee0b6ed49b4aa91a6ac81d722bde15d12381a321e8be312204dbe3a8ac712775b8a02edb6c63d505be08cd7289dd7cde6dad79448b6df9f80f1fc034cd5ce443fb384420b553a6f8177c07890ad6456dc362e6e04b87843710412abbd78043fbcb039b25dd9f665ad2bd4661bad35783613d344789a8c22449fd5b01b8212c7a3ecfe23daa40e8973dbe98f60475467047901b62f5496ab9f6406d47bdcef05b7a7937cbf5d7e42965de33755453c20056a6ff7fe9f86dcf4a991b799c72824f8783b13cd91dd400ac2971bbd2f3a3503bb2d076f9a8941ba97a881204d064b425f3529e8989d1b2ba37263731faf1286bf29b902e7f937bf23d207b12730f33cf35d15e074e4a707b9c95fe60458f4e6970e5df8f571a66b4494f336fc09ef5ee5c75d369042a17aef7deb09dba1ebaa99aa587ec3e7d02f55323fece6fb5d26ca3318fda5a214e47a57a8312ebd8603af9cd8fa7743744d4427ffc10c0fb96d130bb2bf261df0673f62e7311bba16c50047e1cae757cc6e2adfacd03dc1e74b35a4b330dd2aac4a91561965c82510fc0fb086b72d607369550f9f646ab2c4c69989a2f3677d67cff3d04b7bb2fc825efbf35d9392b8de4357d482219b5cb3508c6a69e160a76e8f98c2cfad9be990929b0b75907c72d5ad976754e03e64381991255792ad27ed7d00795d4dec4ab97e04964497fc2f296edd0a8584f2f3150c26374fabc76f0409255948b0c24fe44b2219a0748c9e5ae70469e087b0c7acf4eabb2a48bad3e97f98916b014cd28a94337b3b3be3498103b8580cee6a99545e7bd94e0c083625b53644078efcbcbe5c2b1fddcfa4bcf5ad05720073420bf258833038af9bd6f1e0317ef4ee77e4d4c525f09978794f6a4c6e975acf0c60797637ddbee816837c74969caf3ada9860f87e16716174e5cdb094daca201017e92a44e5b6cc307c13b95d1454e6c5e25aebd8e246ad11f737b1323ee8c2c45c218f6bdd91b7d42a13185b5a50e1dd55e44af0857494e6d0d459f43aad1312409f32847c0b746aa0a91fb15f62ea99c3170d88c4b5647525abfb895af2a2cb3b05eeadbd80aadc07b8a1753a39150a91006b966f77c7e34d6523e397f3248ec2ea89f52b5d15e4f587abe1c56280f76804be7e9e830af5ece8f8495ff5e5ad6c062310708f9161a7281cd6cc0e8969dbc79e20259334d131e5ea0887f1d42fe14291d3a3eb78bf0252a119b1c1f9e094bd1b387073a6ec34ce7c5ec6cd950e5bd31604d7a24a146c94eb6e1c5b050ef47ee75fb7b7119cb75c2359ad24bb6c5d657ea588aa354ca7e438508970452f44215ddc5f518318715f777cea7145e2d6097a671f76084988a8eabc40150dc97475136ff41f5fc8c4a27ff62d9f43b0e54e8cbf12922833ab37ffa6ab771f45c3f7ca324a8b987bbda8de1217d81b88e2a18777fa59564822169bdcd7eb61fff0821e9f77d58aaf82138454169ce41ca20f7123496a7c36388c5aba2dc872726e2c01118ffdaba4547d233889102d0826652dd02f7ebd9879e8e30b7988a092057ecb0196e129e4c3d5c5df15cca0bdc87e44d556736686df7bbed137876d984fe5835e4059bcf2cddb0aa5f5309464ca1dcffe32a557dd87ee3f7494651b42960d24b36b14bc662921d567e2d700d98fc267b6d1b6b679481a0587bee4605db68cf310bd7bd02a479c8e32b6b2957828b298cb15720928dc8c9f0278af6364d4657fc931aea72cc7f0307517d88de3439a1874715cf52c96fc543dccdb28719a4e18bccaa8effe07f72f09038f8b30839a958fa1cfce35278eba5399650ba2b694d8850e57f28f75603e59b06a9954e62d3e5a683bdbb82105d12c0fa800715a2c2f193fa3f694df3d7a2d96537c00e20322efb50a7ed5950dee1a394176a46d520929b720a115febbfd33f5aa5e30c4b68fe51b2bdbb7a19f58b8c69790d6b897947008ec1dcededf7f66fadfd42a66e19ff7291e249247b932dcb51e212c2cefb5b422f27d165c1b8b3a09c6c4fd5c1a705d10c3901f33261ee00a9be302c6de2dfe6f17f671dc9eb0b4e6d1549eb83b829fb5a0d044751923974f9f498df966511552d230d0ab7c31b8ed7c5300b891d635eef6514171d75b07636bbb9d3fcada626c00b0f1a3e6aec2e123132c937fbab6432b645636f3407ea7fddf84aeb7caa3a0403bea10799b3f4a94aec52ce0d0cf8959580f91d66975146bea8c574920829ddd3dd96db6d0f469495fdd034e12d5b8df263316f850aac5a874e59039e655187f95edcdcb42bd35264276ace92454768cc0d939514f894ad4a2b77c7ece3f8280be8ad4f47963a14b53c2525194338cfb250709b6a354a88c5e4000a2478c78784","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
