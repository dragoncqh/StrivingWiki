<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8c3c4c714f29b78230da54bcce20705092c0d7285838bd2d8629aa8e5bcd7c41632396882b7495bdb27efa3a19363344622be36a30d8fda065e48ea0a84d8889e23255ad1ad31261b2da5bd85fc28983ffd582661d135bf8bca14d84740114d8e77264d806f5b1ce78e54c20097292449c60aeafac340b164b878e4304cdf1bf9030d2801168828105c5d3418167b7f1f861920660a336f8452d463bc53698e024951ad7248d027add2cf764d3346aeb347a00865147ad40750b1d3851f3b3796a48dd00853eee604a243b169d4f767ee2b165b2eb18bbb739e4fce4239d4c8e6db4998d498ebaa2f7e92accc6600c4a81e0416b151c78b534c94010bbcd6b944a280e93329d7b5ddf2e8af09b42c80b4cfbf19b7b227b23ebf6f20e13af70beef201aa98847c6bdeac5d8c3381c8456f2580bd551eafb125899fe5016d23dafd348b4f55d248df2e3e257cfe8b9f0bde9d49f5d778cd4b4d818613d0565180d80449e5ab067d1c4cfdb69ef6be3fa81b1dc5727861dd54a83e751a6588cfca5b0cdee297d7239e2ca7488b20acceab83b0901d222da5fbbabe74d8642bb7c47ef5effe30293ea08dce2b655a2704b6c6e3b82003fb8d028de260c4dab0b91e5bf0671f285dd86eb4739bcc9c22d9bb65955192b03c78d3d8a6825fbb106ce4b02e8d5044d9d93cb82b85b23f70a3187e8b9e7c00b301f1ce99702a334ff4e5313d0f2380f0b00205a03827a29f53f441b80f2cb6a6b77fcae7f14f4d225c578338bdeee4508e918c2be88745ca40587d9aefa2fd02540c66ca29305fd282736b54309685f6050301341f0abcc1a64ce525c44ddccf1d9e75f7e34f8b0d877da5303fd210e4439f8eaecd808fb3ace4734387819a1c489ae0c2aba66eccde944fed700f08662ecc8cdfb25a73b5b0e4e0599e4f91ab6aab6a2e5a4abce9802eceb88216fad3ff40399529b5c9d94222bfc6854e090d209556180ed992767fd6483bec04fee53050b5e6b9901273c1a3205bde245d25ba85ea5f4841a76bc52474e15134035472c52ddd25b58fa01609278e31ac0b399a18269e05600b4eb250f4692f83aed51d5f37a16bf319cad4b4cd4a37eebf3ca724d0bebe6218de77bfcb1b4405027d1bac0a1a773ef1cacc9c4607fa9f4f9a7584c0224a29684b79867708f754339b436629c7271e939a31ae4380ee492ff7242f23bfd5e8ed89b60200773d906f7b297626e74cd2de91cd4277eeb67c704e0e1bdf509783529f5ebc660c407a095d0c8d4f56c0834f8768186d354815458392dbf92c40dd00d989efaffaa84572edd401c557de822e67dccc767384d7a1535833b9229787f3439704d3bd6b872ed1973e699164301603da4dd3090d4e360aa8237b5600c177b35c015a7caef67903953a5ca37df39193467e9471d4a932e37e339bc9b800a2a83f52570167c1bb86b362598de92589d965cf5455b7f88e1795c15fb7abd42ace7b50f2d389b98249559662603b0f152ff01066a6f5c239e19594e71aab3ddd775b1a8fdc5dda286c8c08233d84bc5a94ca3c34547ce1bff8455ddd46da5606a254946794f59c14cfaadea867439be5e5b847f8deb9f6d47a478e614deaee65934f3cd7cc57f2b94bffc2a8a74b6f11db2e8e778fa987f818da186cb7008b27a937907dadcae77b7cfbb423dba2d0d5ee714c597b01dc73dfef202da2661dde34879915d0f5b7d4a949f027623e6493c5a2a6c60ef8830aa088257c8f87b717fe55ba01d8007a982d5e34736198f10739e17b94de85c3e09d2290929a2fec0bfa45c416ff96b521e1efd8df31efd05cea7042f77fd8831894a161a50ef0ef3f112b1b540e60cdbde8fd128abd316f7c6cf65af7a9a67ec0517fb9efc6e41cd12dea57a86e3645c3a18d6392eec8db28419891fd6b7a234fe48d7aa309bb7cbb874c36d99c262ce2fce2822517d74625457d618b11f5aa70ebe3c62706b82ff6a245bf457a840baf97f0efb7139f579d7f351544f24fbde3ef672d83394a588f8fc0b9993a6494fb27b7cd2153cfacaaafd912276c5e8a1a7e56453cf2a11079d7192c10161dcee5010cf57e40b21204916650a5650ec226484046eae49c1bd3bc9747420476e81438b5c75f96af44cc44fe853dbb0532631c491bafa9a0b12145bedf248ca20942a0dcd897bb85a4fbe8825ba8e882a5a22193aa489799c9f7173ac1ca7980bb48d47820ae73288f3079fe281a744019b1f4ac85abd1cb444a9dc603b4a67ae187e02763e8ca86b698dca934653fda4bf7430d43403a9b506c6c85f7ee91f6593addf784d401df1f7ea9753f08074f81123f101c5ef373ba5aaaf492f7fd6342c0fbf16bcd737b088f77a0e220075326d5feb61475567ffb346c78cc70b6128501d0469151fd6025721880deb78bcc3059c07e43115acd96ce5624bf296da4013d749dba536ba852767f38b55a2bb13d6c90d98741acf0a8df9aa34e5d7f6dfa50115b06c23481f370148308937328ff64256a15c66eec9419fe10fc1142ef32a7d1a6019389c828b4245e11c9c0f607ea5de93c8e3343bddfe424860ae23a06884b6d6f839d82333d6011221e4ac003e5ef2e107001ad62cc4dffaa1e32f83d4228420c9d318dce6c540e1fdb752bd6d568ae33588911a1ec8b33fe52da6ccad67bbee56fa18a8d23b75664abd5a980cfb49eebbfabe00a0946f0ba3c4b3d37d78a3bf8101702e56560f84d310186705d83fce9410bfdb11a1d7a9aa7551de8ff94e1b9d1aa24fb00ec7226da293e97a02cc7776981acd13890db44eefdd146fd8edfee8a0ccdeeac7d4ded3623868007519f87117ddac9f208ef84c11e93669156f5f989018f8664238ab8ca462ac7ed2760b67458e062fdab8043c4374faeac22a90eab007bc953392815bd4edddfc474f9fcb110984da580b1a165655b478c73b357dc10b98ee151d3de72bdd817e9aed6aaf40f021653382a236f57d0b2d73fcf26f00779692ee1a25e517a36980bdff4fa00c19fa12c9f501286dab02904e98b659ace1e44bedf518ec9cfe6666a08f74975a52c646bfdd809e12f10036f3a43d541e4e57ca6b4b5913bbef619c547b49a341a78de96857249900755269eefa6130c1e34d11e716922fd447bd612679984ee94029f77bc0cbf7f9f050113eb187ee5c6ca59269975318875675781a91398f6d552d6801f71b95666cbd5771c224dfa5499d9d04fc85af0977fa95b6f01de61e4c3647f2351da7c3f1a74a1eabb68aac57a3b220cbdef69bf9884296cc3ffe0c8409685c6072c7379c5c0890174d8c97cc042fcd12137ef86eb91a83a1428750950244948a3e78337d8dcd5804f830607910b65e037d64d76601ffacefbbac7ae366b2d463546747201be9fd42a235f255f7377a7954bd73e186c5118c88b2430651896a5f249e5b28a15aa8b376d83c63385306805d08939a8c8ea5af2066e6652f4ffaa0c498dd1476c8274f4f9bfaedd8316dc26c3ebda2cfb5fa600773934fcb0dd03649dfd828d97169428804c0c29312c9b844ff6daaba00906b5969ebd83ca1f6e6fd6f193cca2a0813347b58cd78dd5865d92d538198c0d7f905c382b3fc26a5a66f994b4399f11fd32bc9b0f254fac23acc0659a027e6e8cecc81e77062ba684b86df823fdd3ba3e1b8c73d5e602592c4bb7f5f4bfd40e3ede0d47551f36706fdf09f8525d58616f86064ed517486c9831ae446b32d51a167b9ac8a7e00d9ba682a2aacef92f0e35306f9fc1b97276a8514f501e4d0ba11bb0700315c0b07dd8f152eb6a3bc5572996e1cc8e97b64d8fa327a05117fde5eefe8b61d1d8ccef2e38899b9228ed7ec0ef7d5756254351750065b3dfbdd6442f3aec7b573571c604a1f134d5705be39cc5c7122f36d461f1aa4c3518e456c85e6ff399c41b99a365edaa083619e73e52e027037e9eee4843a5e5a7f1ee876232b61e1e9c2976af803d4e64fcb2fb5a9a9af040c69f00d07e1d8c9413e7408b834fa14b8e848bb86a32dbd259e06ed03bb10f446cc92e97b9abeb280294cf8d90e10fa9a727bb4b9a97afdc768f1d8e298e09066f873dc2810a7d92313e576fa652a8228e2ded6cfe916d7d3db3be5e92b88a0af8d14e32bdb40f65866222cd54093efb39613667128ec7794e722299f4b26ff33f06354074d5883e5e3e93688e28732076117458c247c689e2fea1f7e09ef8446e67534a96dfbaf8710d8e2ae2eb048bb42ae919956560c8350676e7f34bcade8bc49cd23b362d6fe65bbe03cc0af4cde6666eadb416a214f64de910f0887a5912117cd6429b562dda08b939c837af6395396a4d79fc20678ead11738878f32bf79f9fa0b12e8d6b0409dcca1c5330289be08413aa48ae7d77b89c8f6613d8a6ade363cfaadf3ca5a63a18ccfec274d768b23aab220d26bb57b5cee49d3ca5e8d04a59dfd9ccb0e98c03329b5c11737d252eeb7aa84b606f3b8a220b32a291398a1cbba91a6f2438a358af91f3d3201c3e048e83bcfb52aba85f5cea993fbb8fd88115173b6aad7c9692c0a9b8a00b03f5e4a8e501ead5bbbc0f13e4f41bcf1950b3d458989fbc50d82f33e83cc1bcf8c045f2018040d8838008537fd4c1c5daf0cdbc2d1e890f61439004c2f1ee8c644f356e41c5397fedf8376674cb6ba383189a9f5134f6b97223a4dc5d6672c77c2ee30c3fabf162e1681c2d6b5de589d973bfa623a77baea91b41c18c7d0cbc49323ad686038e3d7d4d8bbdc6b1da4c9750183957d5f1fe672885c38b327b153dc15fc6ad97b782907d307c5e91494fb23d63461d6dae408f531cd8a2c94e500db364fe46d2f5bf56f18af408e228328625b669e87623edb12ad0b46f5b7519e34c1bb8eb63715fd06e39d9fabbb01db38292a924d31365b24ecc873af3b72becef78f3db0bcff765b190101e5c4af6b420f17438214684279e09f65a94149509f624ed3073dadb2c86db2a2f95e24d3fc0bc5e592c14b20b1b15836a73a1636f769402ba7e97262a5f87dd849fd9d18e55f57db0688a99efafa896540142983ba0f8fade5dfdc1ebd6c452fa24c94749bdd602685455b7f15577cb58c55e2554b50a6f53594feb97a2f4d50bbdb7655e0d15c53b7faefb8db503881560314150988a6acf54e8de3ecfee272421603bc4f489c512d785ca50b6e021405575e626047496c4ee01f3f60db53d52571df733aa78f02475b432a32b0fe5ef5e2878dfb40d18a9543f77decfd2d88dff3573310906444b8b44ddaa0fafb42256b506d1f000de8775114c710f7f43d17176a35db91b49c3d154ca403dc9c45e5bca0b30d9ebcc51414bf46c4e4ade284c8c08fe8c7a11a076f8e7a350de5c1c746001ac055be200e26fb4880f5bcc6d1ea43fcffc68ba5bdc8d3d029aa8d93617918d1fc49485d923f9858c78588595ff119b691d98e2762a4948971d5ff37ec35009fcf8958703d64b07d49fbe9647dcbce2c47ba51f662e422488035686be0845e3207c6d2937ca7d7c7c28a184c9f22652a19a200ae78dbe4f1984089fc03d474d332bd8dc6a5a9208413c0f4e0643a240b2496a1904237019cf5d600ee28f1bdf000bc743f02e9dac7ff2951f8b400c3b086d2f21df5b9aa59ed36b6ce183b35f333acdc307192d8d80af0a06a96d02c1073d0bbc8a49d9e92894e59cda888f8bad720a5fd2de1e9d89a5ec5f22dce5eefe99cb45ea2a462a1d9abf3292e69dc9732b1be78c19f96cf2be7fc5de545917e3e256072483a4cb385c6fe9301ae141b6654780209514ffdd104ae64dad94cd23460d51a07bdd1efbf598dc06a937d97bfb16cc00ed2a38be0c8516751c7a1b538e44687deb68f22559352b16e90b43622fe3a0738951448cbc857e61b07b5cb08292e7fd46667fb6b13141da99cbcb3b3fc299f903635b52fae3fbe8e8aaaf724e06c276e968779813cd7ccd514b3479e14eb02215364ca164376da7cac1eb72f519fd6ed9a11365051991adf9781f0aa11ab17d8f0d0887df491c32ca91ef4e42ccd44b2f4e523a4d96bf4507bbadb3aedab8d71983265c3c052fd31ab0e66e725ea43badc54339378816d73a923cc1b4287ad6aa1d89760efc17f948fd1aa525dbd7762d746b7d6840183b13007a05217509c88a9f120b3d2087da85b866bf8739d64dd96f9ed4023425a4850753ddc098e3520f8c5b0b26646204a880d86fce535320af9bbba82540b8a3f137703af753736e0dce554f1b4443586c3f7fa43fe4495ea4da10d10131b6ccaddaaf8f3a6bb79f0f6779ecab55a0c22752365eaf7e5170bdf4546a634b5ba827afa93edfd8d35d46d78ee434774edcce81e98b236e24324d1106b744b1e703baa53dd4fdc1f61ace34a116dce9bbd56d1032f22ef8b4a744503ea5b41a4a6db0c7cbcb3ced0ab84760e85954918a414552fe2fc2af300ed70ed166c542c3b84583f84c69fca1eeff71fc360b22acdc481cb9a95242a29deb79cbd24e9a912f77703f58e425a0481f75aa9d5a483d79fd4f1a85482dba22b0d884a104705a1ce9d16d1dc5dac39684f5bbf303253f52b64beb1da72da0f252fc6c07392e18e55c822d51d5ecd09cf20775b71f6aea9f0ef910b426dab24ab0d789c1c59dcb3d0c30155d855ca0181d543811a5dd1f246615d3b43368d754c800dfd1f231a9e2b16c1db2dd20350f563be861f342b8e20a4bbe7ef99f26adbe739c68694d17228fc88ea7542481a4828f570ce386aca0651e0e9e0eebd137f1d91007cf8db93dc87d35793614d3399bcc3a10bf7c295df1a181bc054e3ceb2ba9003fe9b0092ac83feaa088e5bf96fd9db5c2d43b9626e52ef4859e3db20f5442a487f8134bc6f253af4b5cc11d5b02296b616eaff994f5bdf2e76d4c858589a9026a85624b6f93da06605e19caa181b318134db16e5f03003610874a64fd18a7aba854e4001371dbc6bf67f5b534d9de5a01bb1763f23a760c125eaf79190d2bf65d16d40407411342e319fe6b02a73cf109a69f7b9b5fa1babe0de5a00992be1e38589a5dd2bfb716c7e1dc1b5d0d508fb34005340bfebf397361143edc27fe3b914e0c4b7a420696e884bcf6b18a8c959f3b3410a1af72a18efc5c06f473606fa83887e2f5992694e38c6e2ebcb64ca49060b8737ba48a6ca108969fc2516789495012b008b2ad434f6c25a5695b13b4b17efc13337ddfdefb6fa0b0e4d5abcc5937ecca12a01337420d25f133b0ebac13c81d01eddf21078e8991123aefdb90a16a87f7dd233ef9d6d1787f92e4c93847f563c8eae1f97c49b429181d8f04c3986b743440eefd90c11fa921f1ee533731f3cd2140f6f3b24398ae41cad2966531bd484eb0078bd16b95684a72115c03a1a24774de52937be4c7fd7802c9d9f2f24f1657198c434a8898581ac55035931b3320d3bf2e64ba26cb13dadc5eb76da03d4f571a283d856e4e756d6da46caf1d1a2a86098c60545d95cb737f65013573cd8e377e23e35c4a8d3d608b2726667280c5eda9b21704daa437518f72daa9d7995ac4b5229b8718c2c54a62013b6280688882ca2993b217b9e5ea91565a3d4eec9ffe50a4c33483a78f04e7133cd8975b4b39857109c53ed1c57609fefff36eadc8d9550f690e93ff4fe78c36605bd9950f7bc97f85e891840546192dd658f904a7d446f8f610fd2fa2e33419a01df91848260693c071e3cc63e888a87e4077df642e2f33fa0e53af03045b4d482fb8520de9cbcb2d38e3762127c6d065f1abf285f3bfc95284d81267f30ba57ee445b2d6c8e8685e1ac59d8b5dd20f2a80d4cd320a493e1c1c281d77ab6b08989c4c7f3511e6d5721dfc7612adacc1f19594e379d7180019674ec1891f44aba57477ef25b804c922ff941cad3027706e774a206af2d8203ab8482c817c0db2a45303d25ec07956e7afb4731aa0a3582e638b483419de47fcf557d7c699287eea95295a8caf28367814f6d3d225b9779009d4ecb8afd7b9ed462deb38eff9f952c80409da2e2c81bd280e16035683f53c3393451fcc13dc065f26010a4f0ce4f5d708cc40da2ae9ae2dcada7379a6d94fef904fb4357e2cbee777593f0aabac19c3727e3278ced36c9ed1ae365ff6e5c7abe461ca17c0f3f7e053b12379f28e62240fee02c00f88a0ba937ec24efec3e36052126dfb36b5906bdacb18094f179d2441881554da2a0d233a5b4d3ce5e4acaa7c2593ab722d01167a5540b68c793a6e717c9fe65f43e363913138a8216ef1c03f513d75213db9b24fb4ecee5e1ad90e4a319e4edd29d3e955d46c438ee42b44467ea609aa7c5a6855cb7615d06bf1fdfc41bffe33c2f8deb80a58cbde95fb94ae16b0f283d0fa9b353a816c83b84accaec7ce5bb30091d68916b84bcaccc7df9c936477cbb16a91511964bef35b0190c38c423d0bb774e39a844944392738dfaf05dc7b927585f13a23298a541914224b620ed7fd7e1386b0033e2b6206432121762c07e7a302a7d0085ceec671cec7c2835f5b9707063c0b9e55f27daf05add14963482052440dab6fce7796f02111243fecee28a09086bcab91bccb709cb9f34555f417c4945f2a8c8e69e87e48951b2f60fe1274ca1686169630cf43426e14bf1a06df6c45a8c4cc97964afadc8da5cec281db2c6e89947dcd7869a0213a096e8d1e228754e24615aef414a5e67519a81ec0056d7b34e1b897c47ce4fe4829eb98ab9df06cf2f85e6c7fc729dc48437af12cca82f0b34881830f071f079477320a9a0ce76a73238f8a0fc2a135ac379fe1ae9b80313876889c583dc3a3147bb57597cca0ba608789e8a1ab89cfbcf4371dce5e1f1d06e3851eb26729ef284f2f35e745681eaaa1af00a11fcd80115d5fcc7093fe01e423cc83016483574560d493a7a564a549baf3df13be6fba57cf3484e875fe54ef80114b79d360ffaf0815c49696da133aa8688e2a9eb58f05d65b4b030de93b5649f1b303f128bd48900a9e30cec5c2feb0d882c63bb156c0c342491dc48e2f7640d144003f98b055b28bf14704991bc339ba5b128b9b77b022ff801460f43aa69ec4cb785a335906175c638e75236ee83d03c5b3ba115dc715bb92a33cdee6bb3ff7b90c34db5101cbd10c5a1c639ccf80ec5afbbaf464dacbec77cdcfebd10365a91c26ce6597794a2dc1e63ea230abac2c649dec8c1c816cff1749ee373de35e01d40d54896d901","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
