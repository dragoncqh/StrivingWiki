<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="zh-cn"><head><meta charset="UTF-8"><meta name="copyright" content="(C) 版权 2024"><meta name="generator" content="DITA-OT"><meta name="description" content=""><title>c#语法进阶</title><link rel="stylesheet" type="text/css" href="../../commonltr.css">
<link rel="stylesheet" type="text/css" href="../../common-extended.css"></head><body id="C语法进阶-3586019B"><main role="main"><article role="article" aria-labelledby="ariaid-title1">
<h1 class="title topictitle1" id="ariaid-title1">c#语法进阶</h1>


<div class="body conbody"><p class="shortdesc"></p>
<p class="p">一， 概述</p>
<p class="p">C#是一种完全面向对象的编程语言。</p>
<p class="p">C#进阶语法，是和面向对象思想相关的语法。面向对象是对真实世界对象的模仿，使得开发人员们可以集合智慧，更好地沟通人机，满足人对软件层出不穷的需求。</p>
<p class="p">c#的本质就是所有东西全都是类，一个继承另一个，子类继承父类。 c#有强大的类库，就是基本上所有你要完成的程序都可以用c#类库（有很多很多类），实例化你要用的。拼起来就行了。</p>
<p class="p">C++并非纯面向对象的，为了和C兼容以及提供更高的执行效率，它保留了很多模块化的东西。Java尽管号称是面向对象的，但实际上，对于对象所应该具备的三种构成结构——属性、方法和事件，Java仅提供了方法，其它两种结构都要通过方法来模拟。</p>
<p class="p">C# 1.x提出了纯粹的面向对象概念，并在语言中得到了非常好的体现。</p>
<p class="p">C#通过类类型、值类型和接口类型的概念形成了统一的类型系统。</p>
<p class="p">通过委托（稍后介绍），结合关键字event，C#提供了优雅的事件概念。使用+=运算符，开发者可以非常方便地将一个事件处理器关联到一个事件上，这个过程称之为“订阅”一个事件。由于委托内部封装了一个调用链表，因此可以方便地为一个事件添加多个事件处理器，这些处理器会自动地依次调用。</p>
<p class="p">多年的开发语言进化证明，函数指针是非常重要也是非常危险的语言特征之一。同时，基于函数指针的回调机制也Windows 核心概念之一。然而，由于函数指针很难验证参数的类型准确性，因此C#（确切地说是CLI）提出了“委托”的概念，这是一种类型安全的函数指针链表。这意味着，C#不仅可以提供回调机制，同时调用回调的一方还无需在其内部维护函数指针列表，所要做的仅仅是声名一个具有恰当委托类型的公共成员即可；而提供回调的一方也只需通过构造一个带有指定方法的相应委托实例，并通过“+=”运算符添加到回调列表即可。</p>
<p class="p">二，面向对象OOP</p>
<p class="p">Object-oriented programming (OOP)</p>
<p class="p">(一)，对象Objects</p>
<p class="p">一个以某类型为模板而创建的对象称为该类型的实例。对象是由它所代表的事物的属性的数据和处理这些数据的方法组成的集合体。</p>
<p class="p">对象特点：</p>
<ul class="ul">
<li class="li"><p class="p">1、以数据为中心，围绕对数据所做的处理来设置操作。</p></li>
<li class="li"><p class="p">2、实现了数据封装。对象的私有数据被封装在对象内部，外界无权直接处理，只能通过对象提供的公用方法来实现访问。</p></li>
<li class="li"><p class="p">3、对象是主动的，传统的数据都是等待外界对它进行处理，而对象的私有数据是自己执行自己的方法，处理自己的私有数据。</p></li>
<li class="li"><p class="p">4、模块独立性好，对象之间的互联程度弱，耦合度低。而对象内部的各元素之间结合紧密、内聚度高。</p></li>
</ul>
<p class="p">C#的对象不是引用就是值。在句法中不作进一步区分。</p>
<p class="p">(1)．对象类(object class,对象类型,object type)是所有其它类型的基类，C＃中的所有类型都直接或间接从对象类型中继承(即使是值类型也在装箱形式时隐性继承自它)。对象类包括许多可被其它对象共享的最通用的方法，部份方法是虚拟可重载的。</p>
<p class="p">object是引用类型,</p>
<table class="table"><caption></caption><colgroup><col><col><col><col><col></colgroup><tbody class="tbody">
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">object</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">Object</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">所有其他类型的基类型</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">&nbsp;</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">它是引用类型而非值类型</p></td>
</tr>
</tbody></table>
<p class="p">因此，对一个对象类型的变量，可以赋予任何类型的值，例如：</p>
<p class="p">对对象类型的变量声明，采用object关键字，这个关键字是在.NET框架结构中提供的预定义的命名空间System中定义的，是类System.Object的别名。</p>
<p class="p">装箱时就自动使用了object对象。</p>
<p class="p">(2),Object对象的成员：</p>
<p class="p">Equals - 对象间比较</p>
<p class="p">Finalize - 资源清理，(默认的析构器)</p>
<p class="p">GetHashCode - 一个能够标识内存中指定对象的整数</p>
<p class="p">GetType - 获得当前实例的类型</p>
<p class="p">ToString - 创建可描述类实例的可阅读文本，通常返回类的名称。</p>
<p class="p">System.Object的接口：</p>
<p class="p"><strong class="ph b">public</strong> <strong class="ph b">class</strong> <strong class="ph b">Object</strong> <strong class="ph b">{</strong><strong class="ph b">public</strong> <strong class="ph b">Object</strong><strong class="ph b">(</strong><strong class="ph b">)</strong><strong class="ph b">public</strong> <strong class="ph b">virtual</strong> Boolean Equals<strong class="ph b">(</strong><strong class="ph b">Object</strong> obj<strong class="ph b">)</strong><strong class="ph b">public</strong> <strong class="ph b">virtual</strong> Int32
GetHashCode<strong class="ph b">(</strong><strong class="ph b">)</strong><strong class="ph b">public</strong> Type GetType<strong class="ph b">(</strong><strong class="ph b">)</strong><strong class="ph b">public</strong> <strong class="ph b">virtual</strong> <strong class="ph b">String</strong> ToString<strong class="ph b">(</strong><strong class="ph b">)</strong><strong class="ph b">protected</strong> <strong class="ph b">virtual</strong> <strong class="ph b">void</strong> Finalize<strong class="ph b">(</strong><strong class="ph b">)</strong><strong class="ph b">protected</strong> <strong class="ph b">Object</strong> MemberwiseClone<strong class="ph b">(</strong><strong class="ph b">)</strong><strong class="ph b">public</strong> <strong class="ph b">static</strong> <strong class="ph b">bool</strong> Equals<strong class="ph b">(</strong><strong class="ph b">object</strong> objA, <strong class="ph b">object</strong> objB<strong class="ph b">)</strong><strong class="ph b">public</strong> <strong class="ph b">static</strong> <strong class="ph b">bool</strong> ReferenceEquals<strong class="ph b">(</strong><strong class="ph b">object</strong> objA, <strong class="ph b">object</strong> objB<strong class="ph b">)</strong> <strong class="ph b">}</strong></p>
<p class="p">(二)，类Classes</p>
<p class="p">类是面向对象编程语言诸如C#的最基本的东西。它们为对象提供模板式服务。它们包括模仿真实世界般存储和处理数据的成员。</p>
<p class="p">1声明</p>
<p class="p">6.2.2.1部分类Partial class</p>
<p class="p">2初始化</p>
<p class="p">6.2.3.1对象初始化 6.2.3.2集初始化</p>
<p class="p">3访问成员</p>
<p class="p">4修饰符</p>
<p class="p">6.2.5.1访问修饰符 6.2.5.2静态</p>
<p class="p">5构造器</p>
<p class="p">6析构器</p>
<p class="p">7方法</p>
<p class="p">6.2.8.1 ref和out参数 6.2.8.2可选参数 6.2.8.3外部</p>
<p class="p">8域</p>
<p class="p">9性能</p>
<p class="p">6.2.10.1自动属性</p>
<p class="p">10索引Indexers</p>
<p class="p">11继承</p>
<p class="p">6.2.12.virtual 6.2.12.2new 6.2.12.3抽象abstract 6.2.12.4密封sealed</p>
<p class="p">(三)，接口</p>
<p class="p">6.3.1实现一个接口</p>
<p class="p">三，泛型Generics</p>
<p class="p">1使用泛型</p>
<p class="p">(1)泛型类 (2)通用接口 (3)一般代表 (4)通用方法</p>
<p class="p">2型参数Type-parameters (1)协变和逆变Covariance and contravariance</p>
<p class="p">四，统计员Enumerators</p>
<p class="p">1发电机的功能</p>
<p class="p">五，LINQ</p>
<p class="p">1查询语法</p>
<p class="p">六，匿名方法</p>
<p class="p">1匿名代表 2 Lambda表达式</p>
<p class="p">七，匿名类型</p>
<p class="p">八，扩展方法</p>
<p class="p">九，杂项</p>
<p class="p">1属性 2预处理器Preprocessor 3代码注释 4 XML文档系统</p>
<p class="p">十，方言Dialects</p>
<p class="p">1规格＃</p>
<p class="p">二，数据类型对象</p>
<p class="p">类的概念是面向对象编程的核心。</p>
<p class="p">此外，C#还通过无参数列表的方法声名语法，结合get/set访问器实现了优雅的属性语法。其中的get访问器相当于获取属性值的方法，可以通过一些运算返回最终的结果，而不是简单地返回一个变量的值；而set访问器相当于设置属性值的方法，在其中可以进行一系列检测，最后将属性值赋给相应的变量。同时，通过同时提供get和set访问器、只提供get访问器和只提供set访问器，还可以很方便地实现可写、只读和只写的属性。C#的这种属性语法，使得一个属性在提供该属性的类的内部看来，非常像一组方法；而对于外部调用类看来，访问一个对象的属性和访问它的公共域没有任何区别。</p>
<p class="p">*构造函数和析构函数</p>
<p class="p">构造函数其实是一个方法，当构造一个类类型的对象时会调用，通过使用构造函数来初始化对象。其特点有：</p>
<p class="p">构造方法的名称与类的名称一样</p>
<p class="p">　　构造方法没有返回类型</p>
<p class="p">　　构造方法不返回任何值</p>
<p class="p">　　可以被重载，调用哪一个构造函数取决于给new的变元</p>
<p class="p">析构函数也是个方法，当无用单元收集器回收对象时调用该方法。（此过程称为析构）</p>
<p class="p">类的析构函数名称是类的名称前加上符号（~）</p>
<p class="p">只有一个析构函数，不使用变元，没有返回类型</p>
<p class="p">&nbsp;</p>
<p class="p">&nbsp;</p>
<p class="p">九，函数</p>
<p class="p"><strong class="ph b">Ａ，函数定义：</strong><strong class="ph b">static</strong><strong class="ph b"> 返回值类型</strong><strong class="ph b">/</strong><strong class="ph b">void</strong><strong class="ph b"> 函数名</strong><strong class="ph b">(</strong><strong class="ph b">参数类型</strong><strong class="ph b">1</strong><strong class="ph b"> 参数</strong><strong class="ph b">1</strong><strong class="ph b">,参数类型</strong><strong class="ph b">2</strong><strong class="ph b"> 参数</strong><strong class="ph b">2</strong><strong class="ph b">,</strong><strong class="ph b">...</strong><strong class="ph b">)</strong><strong class="ph b"></strong><strong class="ph b">{</strong><strong class="ph b"></strong><strong class="ph b">...</strong><strong class="ph b"></strong><strong class="ph b">return</strong><strong class="ph b"> 返回值</strong>//return必须在函数结束前被处理，不能跳过<strong class="ph b"></strong>//return ;//当用于void时用不带返回值的return来中止函数。<strong class="ph b"></strong><strong class="ph b">}</strong></p>
<p class="p">Ｂ，参数数组：</p>
<p class="p"><strong class="ph b"> </strong><strong class="ph b">static</strong><strong class="ph b"> </strong><strong class="ph b">int</strong><strong class="ph b"> sumVals</strong><strong class="ph b">(</strong><strong class="ph b">params</strong><strong class="ph b"> </strong><strong class="ph b">int</strong><strong class="ph b">[</strong><strong class="ph b">]</strong><strong class="ph b"> vals</strong><strong class="ph b">)</strong><strong class="ph b"></strong><strong class="ph b">{</strong><strong class="ph b"></strong><strong class="ph b">int</strong><strong class="ph b"> sum </strong><strong class="ph b">=</strong><strong class="ph b"> </strong><strong class="ph b">0</strong><strong class="ph b"></strong><strong class="ph b">foreach</strong><strong class="ph b">(</strong><strong class="ph b">int</strong><strong class="ph b"> val </strong><strong class="ph b">in</strong><strong class="ph b"> vals</strong><strong class="ph b">)</strong><strong class="ph b"></strong><strong class="ph b">{</strong><strong class="ph b">       sum</strong><strong class="ph b">+=</strong><strong class="ph b">val</strong><strong class="ph b"></strong><strong class="ph b">}</strong><strong class="ph b"></strong><strong class="ph b">return</strong><strong class="ph b"> sum</strong><strong class="ph b"></strong><strong class="ph b">}</strong><strong class="ph b"></strong><strong class="ph b">static</strong><strong class="ph b"> </strong><strong class="ph b">void</strong><strong class="ph b"> Main</strong><strong class="ph b">(</strong><strong class="ph b">string</strong><strong class="ph b">[</strong><strong class="ph b">]</strong><strong class="ph b"> args</strong><strong class="ph b">)</strong><strong class="ph b"></strong><strong class="ph b">{</strong><strong class="ph b"></strong><strong class="ph b">int</strong><strong class="ph b"> sum </strong><strong class="ph b">=</strong><strong class="ph b"> sumVals</strong><strong class="ph b">(</strong><strong class="ph b">1</strong><strong class="ph b">,</strong><strong class="ph b">5</strong><strong class="ph b">,</strong><strong class="ph b">2</strong><strong class="ph b">,</strong><strong class="ph b">9</strong><strong class="ph b">,</strong><strong class="ph b">8</strong><strong class="ph b">)</strong><strong class="ph b">     Console</strong><strong class="ph b">.</strong><strong class="ph b">WriteLine</strong><strong class="ph b">(</strong><strong class="ph b">"Summed Values = {0}"</strong><strong class="ph b">,sum</strong><strong class="ph b">)</strong><strong class="ph b"></strong><strong class="ph b">}</strong><strong class="ph b"> &nbsp; &nbsp; Ｃ，值传递参数</strong><strong class="ph b">/</strong><strong class="ph b">引用传递参数</strong><strong class="ph b">/</strong><strong class="ph b">out</strong><strong class="ph b">输出参数 </strong><strong class="ph b">static</strong><strong class="ph b"> </strong><strong class="ph b">void</strong><strong class="ph b"> showDouble</strong><strong class="ph b">(</strong><strong class="ph b">ref</strong><strong class="ph b"> </strong><strong class="ph b">int</strong><strong class="ph b"> val</strong><strong class="ph b">)</strong>//引用传递参数<strong class="ph b"> </strong><strong class="ph b">{</strong><strong class="ph b">   val</strong><strong class="ph b">*=</strong><strong class="ph b">2</strong><strong class="ph b">  
Console</strong><strong class="ph b">.</strong><strong class="ph b">WriteLie</strong><strong class="ph b">(</strong><strong class="ph b">"val doubled = {0}"</strong><strong class="ph b">,val</strong><strong class="ph b">)</strong><strong class="ph b"> </strong><strong class="ph b">}</strong><strong class="ph b"> </strong><strong class="ph b">static</strong><strong class="ph b"> </strong><strong class="ph b">void</strong><strong class="ph b"> showDouble2</strong><strong class="ph b">(</strong><strong class="ph b">int</strong><strong class="ph b"> val</strong><strong class="ph b">)</strong>//值传递参数<strong class="ph b"> </strong><strong class="ph b">{</strong><strong class="ph b">   val</strong><strong class="ph b">*=</strong><strong class="ph b">2</strong><strong class="ph b">   Console</strong><strong class="ph b">.</strong><strong class="ph b">WriteLine</strong><strong class="ph b">(</strong><strong class="ph b">"val doubled = {0}"</strong><strong class="ph b">,val</strong><strong class="ph b">)</strong><strong class="ph b"> </strong><strong class="ph b">}</strong><strong class="ph b"> </strong><strong class="ph b">static</strong><strong class="ph b"> </strong><strong class="ph b">void</strong><strong class="ph b"> showDouble3</strong><strong class="ph b">(</strong><strong class="ph b">int</strong><strong class="ph b"> val,</strong><strong class="ph b">out</strong><strong class="ph b"> </strong><strong class="ph b">int</strong><strong class="ph b"> valIndex</strong><strong class="ph b">)</strong>//out输出参数<strong class="ph b"> </strong><strong class="ph b">{</strong><strong class="ph b">   val</strong><strong class="ph b">*=</strong><strong class="ph b">2</strong><strong class="ph b">   valIndex</strong><strong class="ph b">++;</strong><strong class="ph b">   Console</strong><strong class="ph b">.</strong><strong class="ph b">WriteLine</strong><strong class="ph b">(</strong><strong class="ph b">"val doubled = {0}"</strong><strong class="ph b">,val</strong><strong class="ph b">)</strong><strong class="ph b"> </strong><strong class="ph b">}</strong><strong class="ph b"> </strong><strong class="ph b">int</strong><strong class="ph b"> myNmuber </strong><strong class="ph b">=</strong><strong class="ph b"> </strong><strong class="ph b">5</strong><strong class="ph b"> showDouble</strong><strong class="ph b">(</strong><strong class="ph b">ref</strong><strong class="ph b"> myNumber</strong><strong class="ph b">)</strong><strong class="ph b"> </strong>//引用传递参数,会改变myNumber值，所以要求myNumber必须不是常量或者未初始化的变量。<strong class="ph b"> showDouble2</strong><strong class="ph b">(</strong><strong class="ph b">myNumber</strong><strong class="ph b">)</strong>//值传递参数,不会改变myNumber值<strong class="ph b"> </strong><strong class="ph b">int</strong><strong class="ph b"> valindex</strong>//out输出参数，不用初始化，初始化了也会在函数开始执行时丢失值。<strong class="ph b"> showDouble3</strong><strong class="ph b">(</strong><strong class="ph b">myNumber,</strong><strong class="ph b">out</strong><strong class="ph b"> valIndex</strong><strong class="ph b">)</strong></p>
<p class="p">Ｄ，全局变量</p>
<p class="p">static/const 变量名</p>
<p class="p">注:const定义的全局变量是只读的</p>
<p class="p">当全局变量与局部变量同名时，局部变量优先，要用类似class1.myString来引用全局变量。</p>
<p class="p">Ｅ，Main()函数；</p>
<p class="p"><strong class="ph b">static</strong><strong class="ph b"> </strong><strong class="ph b">void</strong><strong class="ph b"> Main</strong><strong class="ph b">(</strong><strong class="ph b">)</strong><strong class="ph b"> </strong><strong class="ph b">static</strong><strong class="ph b"> </strong><strong class="ph b">void</strong><strong class="ph b"> Main</strong><strong class="ph b">(</strong><strong class="ph b">string</strong><strong class="ph b">［］ args</strong><strong class="ph b">)</strong>//args是函数命令行参数<strong class="ph b"> </strong><strong class="ph b">static</strong><strong class="ph b"> </strong><strong class="ph b">int</strong><strong class="ph b"> Main</strong><strong class="ph b">(</strong><strong class="ph b">)</strong>//返回一个表示函数终止状态的int值<strong class="ph b"> </strong><strong class="ph b">static</strong><strong class="ph b"> </strong><strong class="ph b">int</strong><strong class="ph b"> Main</strong><strong class="ph b">(</strong><strong class="ph b">string</strong><strong class="ph b">［］ args</strong><strong class="ph b">)</strong>//返回一个表示函数终止状态的int值</p>
<p class="p">Ｆ，结构中的函数</p>
<p class="p">Ｇ，同名函数的重载：同名，签名不同，系统自动识别使用哪个函数</p>
<p class="p">Ｈ，委托：用于把引用存储为函数以灵活调用函数</p>
<p class="p">十，面向对象基础</p>
<p class="p">十一，类</p>
<p class="p">1，类的定义</p>
<p class="p"><strong class="ph b">class</strong><strong class="ph b"> 类名 </strong><strong class="ph b">{</strong><strong class="ph b"></strong><strong class="ph b">//类成员</strong><strong class="ph b"> </strong><strong class="ph b">}</strong><strong class="ph b"> </strong>internal<strong class="ph b">/</strong>public<strong class="ph b"> </strong>sealed<strong class="ph b">/</strong><strong class="ph b">abstract</strong></p>
<p class="p">十和，接口</p>
<p class="p"><strong class="ph b">interface</strong> IMyInterface <strong class="ph b">{</strong><strong class="ph b">//接口成员</strong> <strong class="ph b">}</strong></p>
<p class="p">参见</p>
<p class="p"><a class="xref" href="http://www.cnblogs.com/lemonade/archive/2008/12/02/1346274.html" target="_blank" rel="external noopener">漫谈Object基类（一）|</a>&nbsp;<a class="xref" href="http://www.cnblogs.com/lemonade/archive/2008/12/05/1348651.html" target="_blank" rel="external noopener">漫谈Object基类（二）|</a>&nbsp;<a class="xref" href="http://chaozhou1986.spaces.live.com/blog/cns!CFEA20D71D5441B2!188.entry" target="_blank" rel="external noopener">An article about Equals and GetHashCode functions
in C#|</a></p>
<p class="p"><a class="xref" href="http://www.cnblogs.com/365up/archive/2009/09/19/1570225.html" target="_blank" rel="external noopener">对象和类、System.Object类知识点、学习小结和思考练习|</a></p>
<p class="p"><a class="xref" href="http://yunli.blog.51cto.com/831344/184846" target="_blank" rel="external noopener">面向对象和基于对象|</a></p>
<p class="p"><a class="xref" href="http://codechina.net/source/872600" target="_blank" rel="external noopener">c#学习笔记.txt|</a>:文艺笔法</p>
<p class="p"><a class="xref" href="http://book.csdn.net/bookfiles/434/index.html" target="_blank" rel="external noopener">C#面向对象编程|</a></p>
<p class="p"><a class="xref" href="http://baike.baidu.com/view/756347.htm?fr=ala0_1" target="_blank" rel="external noopener">c#|</a>:&nbsp;<a class="xref" href="http://www.cncfan.com/html/?80_6647.html" target="_blank" rel="external noopener">面向对象语言(c#
&amp; Java)程序实例化(new)的详细介绍|</a>&nbsp;<a class="xref" href="http://www.cncfan.com/html/?80_7724.html" target="_blank" rel="external noopener">C#
1.0：纯粹的面向对象|</a></p>
<p class="p"><a class="xref" href="http://www.uml.org.cn/mxdx/200805135.asp" target="_blank" rel="external noopener">C#面向对象分析|</a></p>
<p class="p"><a class="xref" href="http://book.51cto.com/art/200807/81807.htm" target="_blank" rel="external noopener">C#本质论|</a>:章1-5</p>
<p class="p"><a class="xref" href="http://space.itpub.net/14325734/viewspace-545390" target="_blank" rel="external noopener">认知枚举（C# Enum）|</a></p>
<p class="p"><a class="xref" href="http://blog.sina.com.cn/s/blog_50c771f901009j5q.html" target="_blank" rel="external noopener">c#学习笔记（五）|</a>&nbsp;<a class="xref" href="http://blog.sina.com.cn/s/blog_50c771f901009m9y.html" target="_blank" rel="external noopener">c#学习笔记（六）|</a>&nbsp;<a class="xref" href="http://blog.sina.com.cn/s/blog_50c771f901009ndx.html" target="_blank" rel="external noopener">c#学习笔记（七）|</a>&nbsp;<a class="xref" href="http://blog.sina.com.cn/s/blog_50c771f901009qv1.html" target="_blank" rel="external noopener">c#学习笔记（八）|</a>&nbsp;<a class="xref" href="http://blog.sina.com.cn/s/blog_50c771f901009qz4.html" target="_blank" rel="external noopener">c#学习笔记（九）|</a>&nbsp;<a class="xref" href="http://blog.sina.com.cn/s/blog_50c771f901009rki.html" target="_blank" rel="external noopener">c#学习笔记（十）|</a>&nbsp;<a class="xref" href="http://blog.sina.com.cn/s/blog_50c771f901009s6u.html" target="_blank" rel="external noopener">c#学习笔记（十一）|</a>&nbsp;<a class="xref" href="http://blog.sina.com.cn/s/blog_50c771f901009tno.html" target="_blank" rel="external noopener">c#学习笔记（十二）|</a>&nbsp;<a class="xref" href="http://blog.sina.com.cn/s/blog_50c771f901009ubs.html" target="_blank" rel="external noopener">c#学习笔记（十三）|</a></p>
<p class="p"><a class="xref" href="http://hanshuo528.bokee.com/viewdiary.15955247.html" target="_blank" rel="external noopener">C#教程—面向对象(一)|</a>&nbsp;<a class="xref" href="http://hanshuo528.bokee.com/viewdiary.15988854.html" target="_blank" rel="external noopener">C#教程—面向对象程序设计（二）|</a>&nbsp;<a class="xref" href="http://cm186man.blog.51cto.com/213593/41072" target="_blank" rel="external noopener">高效掌握C#笔记 第四章 C#的面向对象功能|</a></p>
<p class="p"><a class="xref" href="http://down.51cto.com/data/63352/" target="_blank" rel="external noopener">戏说面向对象程序设计C#版|</a></p>
<p class="p"><a class="xref" href="http://hi.baidu.com/sundensky/blog/item/f114360f513255ed37d12271.html" target="_blank" rel="external noopener">c#比vb中多的一些概念|</a></p>
<p class="p"><a class="xref" href="http://gostlili.blog.163.com/blog/static/11662714320095955212705/" target="_blank" rel="external noopener">c#基础知识|</a></p>
<p class="p"><a class="xref" href="http://www.cppblog.com/xinlanhome/archive/2009/08/20/93966.html" target="_blank" rel="external noopener">对工作很无奈（请正确在C#中使用C++好吗）|</a></p>
</div>
<nav role="navigation" class="related-links"><div class="familylinks"><div class="parentlink"><strong>父主题：</strong> <a class="link" href="CS.html">c#</a></div></div></nav></article></main></body></html>