<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d0fcacb8161c50f5ea367de5b8ce0ea4c2b35026294a389cd4067977cc72e7ebc412ec860c56eba85914ed75610aed77d3f85621e935f2d8421554a12fb7e9d5e978a48a5071145cce00c8867ab781384d8a9f33fbe8e4e162bffeb54feda40fd50d9d9d18a6aa0ed127abfe646d69030ecd0f87a4782e0ea253494c43df8b3d4938aa64b9860aaf106373a1a34a5c183cbe74388a6459e2a78c3129aa7fa2bc181ac5f087b3322da845857e61e514afda0486de4fb71c097a33609ee500ddf621fb420239de0740d495bd6d992864c02eda52e251fc4495705def51a29d0a263c8b5fa2c2084d2074b67b88b0fb3cb9932ffd981ef9f6b338239394f71c8dce415098bc8574796ef8062f21a8c71ede19b314efc8d8dd06404a3038908b6e180f448f0c52cef112247b3296ed758a969366f16f01c33698ae55999b6c917d56dea1de1fb0e13d9712af33176a226712116bad14628df8e08eea6b60932f15d770d3982a63ed16e73bcc2ee70155a250e6df03cc981ec01f6a23cf743ec10266e1ba0c9e0d96953c942af1ef7d7a4aab29bef7f92667c4dde3492eb43dfc5c775ebb3eb2ebae3bd5fe6d030f7a660080dbdab3ff05289a172c756d5b60616a46774ba40fc285c912698e5247aa919db593d9b9daacb8555f8326b1c41e01f749874e9027832a12c4f01c3a0086e547411a973529d5147c0f65696f04cc5944bade78d886d81ca10e17723a7a3134eea7eb192d0d5b224ffdade9a9bacfc13ecb6c85ec2512d48f37d361cfd1c1f9b3487974efa20006ef65944d3206205e007e2b431e9519dcf8f36417a5ce9f052f451170c8d77704849e8ac4a9990027e1fdc08abfb3699a35dd0f63a04d698e3169432e80fa681fd17be282dd7bc6a4bd5e31c40aefcd3f329151b54e58ffb8b4af72c400dfaef9551337d42d63de8a4d3458e35eec62c1b7e8d8142741d73b6fe815d8c42fd80d95cdfad560fad2fda654e6c0085d67c91b036f2d5319a15ca0799cd09b70b70e755a106c81acfe87c2d7b82a2f455c2ab7dfa5ab728c5e8e1ceeb47515bec886cd95a6ff530beadc843c95ef9abde005b2083ffa72089ebe0d919d7d074dde7990a6fa604652b6531b4e837ce7fa147b39b90756835f8d022025bf33b8ac1e1367d2cc2165b3277e4e0bf5b6c4879fd06b488594051e9eda97fcbf81e0f651e24dad0307a688e52d36abf32233910f84752df03d5a10179485658b549c72fbd11f6ae1f7ae63b0515afdf19354d41051dff78b7a358af3753d6795f921f351860c8a16039d1ce2e6eac39ccaa35e5929d9f0e3b08b92fe37998c23c71f95934e84ffff0020a13c2a679d31618547c464e9d6c0a085a7dbdeff9b9d37771fb75f99946029c7f245821df0c5f27c4057894ff37be5d6cd4efc416e237978062ddf61968c09fac535946d6c25544cd07e25d3d8d8766faae925680c90d389435a504c2422f8fc7ee51d74affb562e20a4a841d9ccd88f1deae27ae80270bd1a6204cf7ed40817148669c9b7609c68bc6649dd71270bebe91e9891f008618f68c2a8cc01094ebe47ef756dc99ee3bfde63ff5978a447fafd82bab6d90ba2540034b258b568ea3adad19037ee7ea533a5e1125821d675813c8f05f603156bb62ed68850cca8707ba39ed52c7ba31845ced36b5d719c3b2c7ab5ba511602c43f0fed38f743141840f7e71c18190977b3ae5241dbdf1cbb16cd7c3f99c6d27d691b6acba77436fb22f7cd736ca8e7999b02e0a31c728840c2a7016ab8009f8f0d24be1b3fc305932a314189c499cf318ee1784a77e0562f08355d87c2aafbf4e6f2e0ecab9cd4ad8769f187001b66ef5c65c14d8148f6d02bd3cdd847abc678d7fec05a9b723da271dffa56284eed56f530397b70d2a231345a2f8b1088220b68cee08e66e6ff2b75a39ccdc1da908d884d861952b396be4001d10384652c239914e56b15267d6f78cb069f6ba1cef49b42cac0b0c4667ca57532ce22f0b44f29dc76af25f06cd7ed929bcc360552526addcb13cce351a56dbdfdbc5363b0375ee9a6f8402540da1095fbea96f79029414b6bd37271e76e7bfd442e0b534f56755b2534d9129a41e8727801622c2c0037839a6605e8cd4e86d171f5a2d8f86441e77caca95db8f80361fdea9b72a116bf7b2a568823c3c855d4cee12280d596401b44f9dfd55104e0ba90703012226d72ea1936324ccd5e38f8ecf60fc6d046b76b41db7d24f794ee2e83fa09af1d3d6a4532b0478c38702bc93aa1e2c2dae300ea4af0e4b40afd5848169eccacfc1f24224f63641b472a477a3a77f9ef7cc2f812fe7f67410cec961145653d9ec1f07e15dda56f5214e733b9c375cc433148ad62d58ba4359969289d558d527f6055897bd316b3b531034b5bec4f5ff3aa3beb51714e5f01d0bf11fa519c0b1c5b60b8bf25f7066724a00d08d12a8551dd32c3369ce1dab8f0bbcf3f5b0c6d020944e9c9657fe0166893c7cf14dc38d041aa67fb414db7bc4822d4f7019e7d6b6999951823d1a0337df1b19d58188d207b888e77e38f341d5ec5073bd54f62796995e2432a227a3883398780fe09496b168094e602c608f1c076ebb7c7d76709bea6426fa0ba379debcd72a22456ccf433a236a30730fb6ff26ed29d099968a569eeb3cc06658ef8f15f0aaefd8627958b2c57243ad64b02478319c99010de4feea3a95bf68120c7b245a87ca2846801ee988d6b3f9dad79bcbad4fe4c7a36cd29eea3ee2ec76074a6b2f436482360f18f562891f3cd85deae5ce289fa87e9492c0c1fd9b98c9b90aac17b57794458e8918c442ecf10503cc1c3c1860c5a299b195c86fd13f04e1e4998d7b30618e6915de9e054de848d5d1f6c5834a073152032e9ce1ace1c2686e044b011a22a1f04e39c8e6698cf69751bfba00b18b256878cfff08f9cabbdf9260f5096c487a4e4e240ca2c2dc875b39c7575b60b159d55cecfb61ebf0e8201195a00d75bbec8619ec5ab28335185dd92bee05c191acb9c796e83414df956bde4dff3887ca0653bf7ad9902f64a4eb1551c46fb58ee09894de08f1f8c3c600a0734503d2d3fb95a802f1f2c17e4fe94e69a1334f2867341633bf4c2c2ea9dfe229a724d97130d45e9e2c7379f882207ddb1621f30ca0c67960f4f3f79a591e160abb04b1962d28bdb13a54f3d8b47cf7129a49ed452d77e18128bcf2377483aac0aad0e39b3713db64cba028b477a622817727705567802ec7a4059eb95217eaf16ec51fb3d59666761e6ece1f583fe2bbc9af572c35bbbd5d8ec812d3ec1618417e7063719d7cdfc2e9ffd5b0f409a0ff89ea688c7515e1cf8f4f49a2c4ebcddc23de070c70f09ccfab100f007148a57665d0e2863e2e448dc2f53860340f860cc6a764a9686337ac651a425706d8dc30752b26a2b7c1c2f07ede4f97e33d78ffad61b679529495695608fb2f84c26234dd888a376cb9977df78798c606b7de9a8fc0c7a15cc2bd35121d78fb354dd762a99b3a7a5577e2e5300bca164bc33a952bb32b29eb9d99ae2523e46610a5dd9b51f61e0487b60fa44ae3883a39bed56478bf97512e12900b3317d9e97930863e62de2e14292c2fdf8b249178bbf4abf99391a70661b53dd59a2fa070ff86d362d7045831d119d914eef2ca19380c81cd2a31240bed68a31795fb18834d6cad953bd692284a301aa127b483466d909b108df8592e667395f40259c3d561b800134e6b3db956cd6b84d29679d7243c515598dacd47fb177576c1ea33bd8057e0ca0141ce3956cc454eb77b06dbc36812a410610f9ecbf85b8c6b93f99a0a981b15c28fc5f22b0fde6f092f4c9b5c0821e0ab7375211f018e83c97caf463553b41206ba577377ac64829426c349f28d9fa1fddb6c31c26af482f220887982dc4cc54ecdd0042222ea4e372b1b124cd62d65be43d4a2a3eceb8446f14dbaf13dffa0723e33ece478424dc6de2b13410d3ae82ae9df3fca0dd72675e9d599544c7a23804cdfdd82c8c0ddea501adb71897ae09695fa934d2dea721af5dfd700e5268978c9f66566f57e3e39c60b7097ec4d456277b8e9edb4d300b4619db656280efb4ac36c2fb01366474ffc31bae53b99626590be7609c465cc9d5f86410fbbb5b6815eb5295f0d551595be7268f7df6a9455da41eb8840ca6b9f306e3716fb22b393acee709b13d684edf7f6ddb684c1ac5ac58d71cc2d9b512629a232f38a9634c90f655a7001d7644f04131dd8f1010b2b2f2507344d56afdf156363be23de39400f6468f44acb784f268e97e614d5644be2155d476f139f7a1648a04d76034c06017249cb3f010f3f06396fba8f86b339277e78a7af98a7c5d82219af7517368d19265d5a20415b36d0d0a54de93d60e78078d9885570c6db5b31a9a76dc3a00cbaf252c8b516fdc38b2457b983d74c773f8b5061184def022d2e8367ba094e98d6a1e919d2d7f62b3ed6819dd2a23efca11f0495e203eba3545e444dc7bf7489295aa1080b98a6a7ffab8d588443c0e6d72502c6b05b6a153eea97b57f9ae61e36dba067b334cdaa1748100dfb5ac14ee6e8d3113baa08f9f9bf7a5251bba4c032de8b1ef3c224b9ead766c071c376730ce05df30fe93ece0be978437510b6153fe9f5907dba2c56883f3c6162def6bc9da2f7e62beee0d1e55df60d4512eea71ece3e5a2ed06e1612fd7399ded85a9da9c0622a7ad623b205b5c01fd1413369e529a46c4b3187d1d3764238ddf7d8f1135d5ab0f144e96673373312e7197f3d6fdb02d1194a3d7cf5e4ab2e711c078b2f8f956f6e52898eeaa19c9dc81a6002e7c4aac36ff52eb26903fb8bfe7366a33a026caa4be2e9d5d45989adc85d3e3172bf173cb29c0ed0616048d7427281b9edc582199596eedfef2b3a90b8055c4400285edd669edc13bf8c9aca85395cfc672c001bd73b5ea7c240b67b1e982dd589ea930527b1e218efb5510c702da6cc22de221717b3429855bba52219089422bc9fd80f266935ba6bcec0f17a1c2a8258ccc166301938d954094aca52b15213c50fa793e4d5682a1a71d95bbbec3aa093939e8b104e208c979227308de7d1707b101fc8681d3ab08f56e73cfc7e51bb3f6b9dfff2fe0509cae01dc39626e724f8cfe057a4dad872be2d495d672e592a2751e8eafef268e2df09e513f10c529a0fcaf07f36723ea3d0602090bb077226c11875ebd27b45633d7fbaef86eb5ec421f14342bda52b1911da674c1e0426ace999d80277b72eed80b60b84469d19b61951098884dfd6e731e1389270247bbda6bbc919cc5a6f3c7a7182797130de5df5659ecd46b9b39b6709452ce265a558b0156c3ab890572e44893d875ba712b1f2560fcb939a9173a7ec7924a59f3131a98e1f6e481f31a7d3cb501e45ad6024f7e5006ceb48f4a53e459fd7210e24ee1f04b00dcc0e74c1bace98c2c19141fc2242649ec3df90dce98a9cd48a8895758a4ab63c04b5b37915aebae07a4d2d0b699edfdc84fb90243604eda9ce661eba2593c3a43957ac541832ea86aa4260b1989a6636171c2c959fde2d6b2918c11b67420a0945d96cae11bb6ed6e406f629cb5eb9ff72d755aa2382abed5225043201c60b5d95e6047f2f7437dcdec9009635e83e0a8edc1eab3937acc93043e584709de23cbc2297b5bca91b2a4a1e8dea3365728552a0f73fde7cd0a23323d0f6a16cbf4c61ce55709e3b10e4f90f5008735db11a4486f6dbacc708d721770932d28554711ebadd57c3c77a7e3af3e5d105b97cc30b8a44ec453dae3eba90e7edd27988a1ae702d7248962c16cff2350b82dd66f89f1140af67d230741c364cc36fe1fd3030a440489fcc40f704e7d3ed9b70df49967f44f07e6eeabcb813d04433dc20dd7b0f334871e8cb4cafce72280c74a7c6ae2e4368e5b7142401fa4d30099de16e909d5795a51cefd11fd47f7b53e214fa1d7ed70e72ae54a5371e9521e1eefe101c22f9a15928e4da3a4ea11290b52cd24fb59e92d26c9b355559bdeb450cd3eef8274ecc036d4043c30a47aff888b8c6d092405635199c03a980fa4d3507b76203bf2faab55410c507c99a56890d0d60951dd3138c8386d88033d1f463010522f9f46c90bf64cf3cfa00cfb296deaf171c36babc45ef3af6b55c9bf4e848a1d29c6bbcb25324b801f299688d270bdc45b47fdc2f62d1c1402815354e8926b43f6496d01ba8da170ff855722e19260efaefcc04d89ef02eac0d06705cf59aded32d21407d38b2a3803580cb3bbf87828a541125adf4007b25a5b811bda908c135d4ff58d76f69413e4f18d18c94b8d16b93d7762b59cc28d37f4b22a125710ba92570c90b07c5a352e78339448e371ba1c4db914c273588ae6d047c85229c7be009ae371a2aeb9054ac933ac088b571513480fba9aaf15f4b4ab150293a27c2c76be131b22c5ec67a19587a55ee7f9354e31f06bd8ec349f8fa3610dbd64e63a548d234164e0d1fa71956f80e84a170b350d50cf95a75cb7d790bf34121183b9ffdacb79638b7ff40d94a157b37a8b1f1e4018129f304ed3787748cdedf3dbae57cec7b12e03fa4e184b66bf7416601379b15a0b7ee5dc403575c14434c5365c02f1cdb8e8e08063f46b3544fec0dbbff903a26f30ff3a3c8a2945963204661e46c8b81fb3f1d726ac440e9becd91c9481c46b0ca97b104774bac4f59d50b4d34d0ebeb58b58381b4756a7ff15552216f10fa10f3a2608395df546a5c9a568aaeb27764a844c0362c770b2c251b8860b3d3d782617f7579c68026b3b134af2c9c79f4b28f74893444beb201924a52ac1fc9eaf8256e974db67c3bfd3dc8d66c053345e72ed858844daf1123dc991c94be8fb45d98957d9f8fe2684adc81d6db44ed257b451c591722a60ae30a1348315dad3bc6610ab7ff0f8e5299a2314cb1fc1fd4298c1ff3c44417e11fd6695eff122287a236673024a59104a2c3a293fd4de5b313869a9af3f416701312fd0a3265d25be2ff5da2b56924c5da6b99788168bf2670ab69f4c4dd86d264dc5642f8eed31c9ed1400d454e0b7f8fea8931ca12bb4b73c3073ffb53b7224ba0ce2009c4879808a49cdb36d403fcfc982fdee6a478b5394a1316d7cdb14413e72e2e56cdfad47c238c10377b3a9c4d34a9d6bbe74373bf0c776541774ab6b7a186872413818b5adea0f41be151398f710b7237d3e61fd3c3cf611d541066be3d6287a835fff473dd18c9bf936640596caa2817da4de54595e08b602d9bd121128bbae99a93f77df6f2d0bb39a228aa3900a82642b5e1738c6e8c717c941f439f9b661e61eca22625f9a6144293e4cba20c9e2b6666f0d1fe44d62c582c5463189d7632ec3376520e1cc24036f272bc68c932255e74a0e8279ec452a01b8d53f0972f7d78adb3b1ea7106ff84b06c900f2c248f97c3ba5b2b9c5398f84f51d789d4ce57934ac7df3db232fcfbec9c8d27f1f71da7d8e66fa38d1dc02e0e1e22b5d0c9ae32d1ed85207c31cf871f62e1f92521dfd094f09b7555f130546a090d0b7f71bf1a4a95953b4071ca215336633199d911ecde55ee695d252595cfaddb1870ea23d9386a65fc16501be170c26d2e661e52ee1379eb3121956d5c2625ec1394be2791dd9fbfbddefe9b4e683240d9ca2fea054e8861e1f3ee73deb0f9e7960865f4caaa7260210f3be54ce17710acc038cd11d2180f9d1fc6e535bfb2ad6f8e08988b6276742599147232965751c61194f94c6ae0adb1e4d546197ca4472b2fec427b0347d6a826b8f8d5bdae89d8195141bcc1645fa7d1f51f7cdd8fd14d3158ca99dd2313ecba99a54cbf3fee3b416b41c0610cb32c555f185a23c7ab7699f625d60d8221190ce63225a60530a0b8b9ae8c41376ca8ec6ad95de03cf818ccc14d3c01f4bdb40439fd3a1ac4e0eec419489b67d707c506d3fa85b18a0e7baaa6558f6e10e7975930224203e08a06e1a317815d42213beeb0e8bd32031f8e11cd210c719e4b12ee44a7f3c32a2f2bcd0520668568fc48eafc24ebfd6985809fc81f6ae071ad0d30987cb28f82d73e8a43b5f4b635aeb5410220c2068d283912ad7ccefb754647051f1f2a70112cfdadc4a58f75c726f2634253188b00a7d92b37d923fd40f7e2a1947ff911c59e1ded567bfecb99350ee3ee6999ea0449254e86d0f6ea5c01a5a4de8bcd16110bf038771510099b6bc64306c4e368d8f4f1d49a9d8bc608174ab211039f8f6bc9b648484d192a14b81f03617a62360e9389f38b211756c5f9024569242bcdb9d7b4732acd46fa2644b5ec6a39d20870d66e5baee07f80ca511e1261403706d5509ec560ff479a1809b0400f4e26d28f8446b4ec6cd3cb190a15bc6debc73da8e49b77d48a5f362879509571c6aec4300806453000f0ff53653b5083262bfc0ef5dfcdb126f5ed8bfd9a934c83e350879b356ccd697a5ef50779a030acc5aaf62ab56f30ce6ca87ebabe961cf88b03b57db7892e34bfb39d3e2213dad9344f33dcfa15a33169b5463125f41edcdf3d40461d45ac91846453f48228ef591dc3192987ead944e4d988c7208dbbc54a04473c0e6d4f088fb8f37e9cb27ea57ed834f6be980d430a1fac18120ba8985eaa45c51b9d5c75b3055d0cb7d552749387d42b624b1eb089a307900a0ad50cd6d42bd12db384cd407ad90378ad07320783e535ed39d50b654062f4ed81962cec9a84d0ebf13032ddf82f34b0f3a0aed84e4b29506ab4c455efe90b56b28d9787e481cf41c8d01a354eb5bc592dde15a8eca9368afb6b2753d60b789030335158d426cca91ff42047ed615ac129245f94cd082847c15d8b14c4f74f9ac9e20063b47a586304ccb304b2e44a95202fda2620d95185659534c46e8c93189991a985244731caaeb5039f248561196dcdde13e95c56f3daa16c81c5edfe9d494d547da778a5f64b95ebc5d8ea68747c13798cc2a3f67c44ddc7f760f7c251202535d630ad4c3685aba8a42027e1b2ec0a0019573c50fc845573d81233f9f3ab900d9a934e761ac6e3dbc4084a3c86751183a1e1f675aa4f486a84560c9f4cd9a51baf371b823e47f8c2ac9514d12a22407feb4d6b5ca8361b143f10b7ea0421b14d2a6168f217bef2b7c8bdd13f74151ce4021c5c6a8dd08a912834c150fa6937ac8a8cb72c4a4cb2b2d8775fbf43cf809216d6fe564a254b21e680ba2eee6844de4e953d8cb978914cfd1b8cc16d704ddfe2ada79082742f5afa1a8cd68fe36b20e7e785db838fe7b65533b2a8d954433f4abc321aa517681f0fd55c2b360600bc6e628f9be090466cf176fc3246ae7c997d4d4b9a0d166aca6f2d9f0db7be3a489e36ba07b2265ae27e1703caa24dc0acbf048d4be9ff132a09d3329c3b041f5c700e0e9eba12c54eeeb00d49368b6c24966d121752b1becc34c8d23a744a5fd4ee5d0d474b8d53e86a0186f5ed64adaf0139e74bb21bc05e282d7cc87f78015d97c9ac7641f8216c831b2bc8d78e895dc11d909084d8480fff539ff5bee914da2410df436e3b102a8a93be22816d85791a4d20f72c5a1f582e85386b1848d025a023129f1aba62ecf768b0badce521a1cea99552a62c3a773f00ed6a226bce95fd4efe6a29a9c07d187f61f89fa115dfad3cb2b6ca6be968a97aac01ef4440cba19f13842cba673ed3433b544c216a431880a69c8cd50b7343497a9ab0a6b5083fdf17926155835b2270c46f17f24f6451d2eaca258281252c56b4816d69f6589ef0b5e8c6de74f181cf5e39489278fbe739565886f8a3aba463f90ff52ac282dd5066e3b6cc585705d3f27c3e9411c750de0d3aacf367cf915cfdf3dadd9a10641a9ae2940fa555fc3debb8eb6ce93befd5a6a7f16c6707ecdd8ccc2cd198ce4a027d9088d7ee63e1c5a1af206fd86d410ca664ad0adb688131c14aea4ddca3a1a4b53331bb443b8ae22c2ad1491422a9088b69c4ef6ed276ab9904df3b9a0ce4aed785086339210e78a09d1daf2c85613a88f75e26596b2a7c6230e246d8b86a0180809814175745856675b05de42f5a40624ad8a90f6cdeb1996af445d3c18269ea4311b9473bf4aca2a981843d352315fbf8159d7cfed0fca680f86ff798af52db27f8f42c68482e03be7c96a5b61fb4c81b3da3be6400d374b1b2028b9fb2b97b7054fe0a318abcbefb09a15f3f6212d5c4199f9525f79e6868a83c229c370e3471db24aff0f325fa1e2a67e10428a1971002f252ddf9106621fcdbcece863d425205359f54ca8440576f659e2f23de48ca407d7b8bd9087d2d9c45bcb2ba4875b49e4eaff2e37b184425da832f8b9ed7fad34d8d2f94d91cf934fb2805396f14740d3f7a3ed2f4743e267f82113c61a6ad7558d9c853e5eee156142e3b19662028f2e21b233f1a01c178649fe07e92b64a1e287356fdffc27510bc7b8138c572dd17597b2ec6ef7f76607496649c350fb67b0402de8e7c9f2c419763aaa18f6cde64fa9e2c892a472f77ece936f3291a26a082201b6bed61982eace3166795327cbd0edf000655ce914b31fceaef6bb7f6ed717bbe020ea808ba28de68346b2269b6b7f388d1dda4683bc70624c5919645c912b1fd5d89424b6af6808f931b3275088e69e5ef3136eb05407bc19b543e40b2f06e88a2230dca21831811db54ba1d614693d0c828cd2cf77f016e2e8d93c528d5d7145ef90070a170ceca865a5e47c08a44b83729ba5e468d5dd0107f291d13419db03bb10254ab6062a4721bf12553de622cc909246ad26059e99709b75e18e3aa02d8fc92651d4148ab2110a6529719633add407fda26faed1672c662c14486a98d6aa3c582115343f015bb53dd46fc7e3cf2f70d4742886f2347115490000efa2838a826b4d7b97c6a63acccf13f7a2778649073dc6cefb84295c26db4334737a6120b23d89d075883dd6160b25a33796d951d9209388e304021d40e6e2cd48fb2f0d0ce12e016bf924fc8e796fa485a74c230053777ba98c1ccb8b74037bced7cdd9a3426ce081fc4ab8675abae065b976e23b7f346e8e4dcfbfc9916be0f3c10890f22bf8f36757f057ca570213693bee60d52999231fa0841090e912e839d455476921012150167651e3cfe8f1ababfdb70357e47baf54d10fbcb21345e60fde9bb12eabccaf73dd8bdf9752dab3134ef2c959506e14adf1b46857b567a1e439460203d70ff384fa5f9469fca8eba09c64ba264a65e69c7f49913c718fc8eaa99a932d62872e3c49251b7ef8472b029f900d6f103372d9cebdf09346e209d258c7ec189f581eae4c971f2909d5b58015eddf333dcbc9f7a4426c5b365f87e18d1e83c3b2d613945229014280b6e6f1f4fd326248ca58949f1e293123dce47f43ef569f279c74870b2af8bb02fc90626e4e88611aa66e963b32dfaa9a7c37a79df1f4dd929ad00b7327c08449aaf64953429edb37a5cc0806223ac7bc13995e91584996d77fc23c07e4826c59e5b1beec6beb602834628a09538b4b15910c2faf0fc9e1e057742e5acb99eb87d8346db1b3e41987389c8925576e13d94e709d940ad50797889a65900c283150abe3fbc6aa6eba6d318518ff62e42560afe0abb12cd5106c0ce2e9007e91d346ca817d29737268846f76b601aeba6c37f1bdc8b63cd082ece60f6c7692052cb78c9257ccc486ed223b4702afdbf3a67e778800e8c1602ea7ecb5c7adc3dd9a12641653eac954bbf068aba73ef8d5f797d363893395469dc1a3e5b3a8a189881eb62d2b6cf39f2c0732d4f28776cace70ed3e4ce45505f9a74f8398d0cec3435e131f9f9e98cf3167797b2113332063418a0eae5553a2a2a4ecba72b78b9cb0d7ee9a139ce9f24b5dd5100865e270e0eb35414b687260c3325107256d0a45800d080fdab660bc09319a2260765f0ad017abd1e2c7c3291e1b19d87751677ca336d05f462e1652231d953fa2a5a3913ee48432c6c60d66f5b8afcdcf7de2fbcb87d30731d292b1a24ecc252c64374586330b29dfb4e5aea3d55f2cb3ee0844c856c5b2fb78138caa2d2f7add6124c97144a07d48e388f743691a0249b751f6200f5e033cdb2d8be4e1ba08abc0e6a5252cf7692a5d8af3899e56146c11427873473742af1564332433701b8662e14820b608767f867ffce166fd43c32fd3ab47507964d6580794689e200cee5acb6ef58e648091ad87e58707a6b158179ceeeb820eb314184ff9ba596520d842b8d5091df35ecc9eb0f577c02a340e1474fb19f28e5d7040c460e7ee510011f6df91e4afb37563f7d82405ac0be0f6e764659374bcab6f2809d268de27297ce47037d2d50bc4323e56ab1bfa94c2774636ed323ef194f8056b47588abbcf66c878bc177128ede06e111ab74fd5eb30b40b67384be29dec5a68c6bda364eecbb36ca435eb7bec9425d9bc780387951d79b1b8b31e6be6c221df005f4d9c9609c42556d348a0d6218be83fffc9c3fd7e66161a2a36dff60c59d9a5d0bcd5bd28997194ba5e5c365dc1d37aef7ee2eb445515e53a4c5726229e27b0c4c8850c765be9b3a5481f38a3feb20d14771206c46a67de814baad9a6641f2097ade5fe32cb9053619bffc76b91d56083026e9905ddbe10bb834e2e998aad96b865433da4cc7bdce6e7fe9704ca883b20de595715de2a5868037afa7bef3fc401ba06f1c30a368514a960106a8a939d1bad6f170b59167ab0053bc58ef1996ea711389e40f6696128a6dee3ab04e0c2fe24b5c7a011d4adcc041e99089bf94efb6abf0042e57813a629ea8f30d57a6613525ae7815e34df1a5bd9caaefaeb021f52e9d1defa6fa7a0677334e49401888095d8bed3754251581b058dc9184cd9d037d7e80d01001bac70cf4cd78cebe621eefc815af9996fec90c2b1b15e46e2a44ba39e5b1d6f218bde799e4ba31a94f084e6f8e924390594b0f0ef154a4be63f0c011c58cb1fbe61c3bf5e790d2c3f782441cf055b9f230e118c823856ad4a53e95cb377962d70fc7856337c33ad48f88e933a36852eed4f688e8b9c8a6b8e53912105728559114a9ce2930672ed79f9ac02f555f52ae7006b9add9d7e608f7d8bce0f22c2de5c0045528f8f2e23cf8e48716affc7ec94dd248459d97bea6fc43d1f7bcbfed35c2afadd9c42b9dbdc285719c8164a693947987988a1161df4b75400f23b43f556a0d07844b565b1ac824ceec299e5791bc6294c5646a3f5db3b623fc916c2c8ae7c8c3aa0e6c1ca63097bbbb562b7d562b6e79a235ff0931880a071052d998c48c6247ffe23dd809fb1abba637960a6d80f893155a38a79b4f097d54937fdf2f2638f2c9aceced1ce9f2a918312e5687a0b44848ebad96ec078271510e4f91ec60c54358f315d3c08eb6edf5aa1a405a4bba8739196d04f29311ce929805a893503c3a60429421e72ad2ac86f4d4aaf2f8d52353fe9587a4142cca35f40683ec5719b48edfcfedf751b973eaf86d85a27958b0dde6a073f9a25b302c2f1ef291f6847b8e42eaafde6bf6ae977aa826bf48c69967555dc8ab0ec4b17586328a16eb32c9c784ef888e623dff8fd7c1284673904ed41853a585f817751bd576f80d42b1cecaa5a1bd12caebcf73e4e09dd2fd60468237765320ad5a35cfdd33250f24d91d881c6f3b5da36081f7a4b845867f58025dbc3eec67734ca0fb8d614c496c42d7f5b51998e46321ca401424d6de17f1150f1cffa908dab19c006d1ec7339acc5851b129b5b61eaca32f2f655cd51e49a244a48397e959102cc43cf6ef4ba460d2711b6dca1defc6c2843fc31d3fb0f2cb864081df2666613a26175801acc018f23c3aac729627249e519512a4617d620b97449ae7f83aac1cc9d0d5a49869e0a78f8451cccca7c7c6df5624c2e593c72ea05c19e17d01f976eddd8b01f2c301c28915154b9b10576050296adf5341e709e7f95df747fd8837d405564764323d1b4a847668465df3383e02776de14dc0e93e3b439ef9a4513b8cfab9086ff2cff9ac5b92377b51cc74bbe975ce94f526e6e580b44ea4e8955f88a73af06384c2ffe655d0c13f0e0bf5c3ba674266c3182e304b4d09efd6d7894a75d3e0c9012be6a9c05a0abfe28c779cc5dd6115996790448975733c86503da3b15270dc16f9514724833352ef294b8d9af355d83b6aa7ef1cbbdf620e2b3420fd0c6bc83a93ba04c3959334afc7f50a05bb1f23a4bbe0d98673292ae40f2a9e3fb0866082421c1bba04d291444c11aa3a5d068d242a7b8a3fd18f07871fa5074ac6a51f629f65cca82cfffe3ca5bd68918ec11719354ec574fe57031ce5065266bdb36b937bd668b84e7a4ce35d7664c9c4a9fc804e65cfd5c1b14af7e983536625f1289a2258b6230caaf9f3fc13cae8fe23571eff633b4e10fb9320e8786cad3fba62f5aa7f7cbb33ea784abb579ddea43280ab80f61c9015414d7b0461e60faff4d73f9d7cc371b73b085cf0bb2a54186b3bf1cf19e863ada677b889633d9d0eb71d7012f5255a8a366cd6c0886d41e4ad3e91b4f298c1d4efd5f70ec7e3cb3108c7feecf8139be76986265773214ec0b07bd8299591fae0aef356dcd2b3ccfa4419c690f5453eeef4a11b2f5f6d99200aca44d6509f66235b2583a4e301f7357a77e4b01a4d3643dd7c357ae916459cfbc10c5ac90852fcc351ffab38be2c8b324abc0c467ab97c456332fe3d92145c17b0255127f9fe173e070a54c3b6716dddc467f88abb2fa5d626d8f5158d171b987d0d50521eb91190d14b7ecf95ef038f34aa87325f1d5df5c551814e231e6d1ef97f2cf75c84814bff4184010d2da12db728fe280658e3a4753073f61268ed1b96d0d66d3358ab9faae8a64286fe31bae58f73aecac66241c2243d17c2cca70176e6ec7dfc91eb8699c6d8d7039b8354385be4f58d076558cf941f4c8f40614aa3f554ff478ad3bbdfbd3fbf507a2f40b807ffe6ebca66ea39f98ae1e54f15f8cca0815b10fab39699f4a36355bf54f3bc945e0acb9ac7534f2ff72967d572a3c00de91e7ffc251b54d254c9861ed4bf1346c700de0ee3602f8f0806b34a446d42748567b53dfb1f28c9981668d748e7e7e52c4f000c225ff328eafc478c3d2aa303e099b780f8440903417a585ddea168a9b8df7061ce20e7bdd09d42420972b96fc732cd5dfa5aee5c606372623644f30fe5ca7240b82d309b8d41b8ec7b9057e001caa4491d585390ccdf92cd4c7a5fb845693fd0c893952bab17004670a8e6f86f4d12a3eb0e6728a61d0417f90c12ed6fa7fe89e7607a1aa64f6c1e5054a412fc43caf9c598963e2f0458e2b8f39dba01980c69e7e24c3881983708ff07ce0a7c16f99950aa9ad259644a80e3e3bf1be2143fc212f3a6304285e660ec93fcc38b81784fb1e3429260f1397f9ffb17420cdfaedf2e9b8dc6b59f445433063380c16a80e8dab96d11acf59dafdae58aa138be818d8680c8bed2e4e7823563618ea2406fdaeec4d77153ec3123f093ae92c1862cd05688dc77f709708ca0fec4380e41ba3a0d648d05e858031541ce1f6cbdb5248ad68a71ef469cad3b224803ea2dffb057609ba93610934f679c600b561e4bd2dd028821044f7edfc14915d7ee875aebb584130529fea85bd08414fa7da26398d091692c1394939ae0c866f1a2a5558e31cf79556c468b40eee6b7eed51aa7161af650349abcee5ac058cebd03d3afdc4720590e44b3324467e4b268b4137e07a2ec177e4b1316ef78b0fb61f01b959693dd31b73269068cde877dd1a97a07e40ff2c7911bc214b3d6f79cffdea55cc45133829169527acc8e18589639b100ff812c7e3a8e9e67bf8a76e95d0268a0f2ccaed4030c5aa5d91b90297bd65fddb5cfd3fe6d40b3f4914cad0603b3798c66edb3d60b11783f3ead3a1053e6c2f0a608047b96766d1b5ea6d91170daa5ecb3a2846f072d8df001f38f3ed60342032f1922017474fcf22bab78bd5d993da9dde29d955896ad6e48071f4717103d6ade5f469f222adfb8e526ce80c3cfbe9c05a6c94d457bc455abe0453cb51e43428a8e5ed9874e9f1d6ecfb1ceabf1874921f8a0cdaf423ab0f69a81c429bc7eca85b4670b5a0fe94a2ff3851e41e1677bf6de904a9eb431767a0ea4a1f08d47bc00eb59af0c521f7cb024228ae58c53ebdec250f6556362b0847e64761b3f934153f192cea1863c766a2d51afbf425da68fe8b8db0e8af6838ee426a4c293eec739caf57c49f60abeafc92ba7a6d7700b54b4c3ce3dbaa266a4e8fb5fef2918e48d99ed926b34fc18cdaff5d7d308c705490afb15a00c82298126ff2536bb1c6072f4fb498f6dbce3cfdfcb4dbbb68521f9a185595f9b37872173d3787056b3de1688c8247af6c39849c50d8fa331e6e59f60998bd5c956538570ed5a451a24e1840cb66dd0b0ec9f999d2a30c01bb50dddaf56d111e990c3ccd20c09af8fa0c8a477601f790c9c323070c95d31832b3dd8259cb6ecfae4178812324295b6004bed85b711ed340a6d30516d90758c701ebf62a72c68e8790e0bc7b3dc2a826ee0435dafe2d81450afb218d6c833184e868d175c51e932321fd1a741181fe06ea8bd354cf6ef0c23200a7c6af2faf0753e2c5def8b1face775acca4c8ba6cd5fad035737dad4019f376fa2dd11964af03132a58b44b4f596f2640c0521110edfb95430bc5c16c4f0f00709ba16bc104a322e7a118be1000abacfa792073273106c0e4da8d5e3c43ccb7947185fb6b94fceaa389c5ffa338880a3a16dd9cc7e5c84fcbc3b6cc8e823c087ebce17d7e334641b0db7a25e4624a548f0e0be650a3ffc27c745b9dd2704b9b9fcb41a83742d029324963620054d3b5de1aa7562c6d8ecea8e95ad223a9c632e13c011d014c3d50a4d9bc9510eab4279c361ba16b5597a3bf87dbc8d081a6791ee3a62b5cce4a5dfc5492a43f1e2c8d5bca3ba7280f0e35bb401ea980ef2f22d08af527861b4e1187f522fa36d17f56ac65b5379f4db5856db5480c24b1b3fdfc69ab4ec63bc7ca9df3529b8b1b1f1f8007da872b261bbf6cf2db74e1d808f142575384f561eedabb5f2b7cf83f43e4bacf25ba43c905070f609e4dd7bcad46105f349a1dd3c47f8742eef50750802521a45c74e513440d723a19dfb8069165fcd9c3e1c86b2038da4dbd8bdfd901d90d23f39f159f846d0ca3017e68b12851c0222f0e4f9d07c97cbd4af16a742f58df2d86bd1e3395a82de6d110cc384005133f53ead982a4796fdfe5993a68ade851379f0e8846c973d7b9cd96781b99fb8925c52e58d20b969b174e087d401777cacf6c4a52f7a6ecb05fba3ee5762fb9a013247ccae789a895ee347a3e94a85fe99d0551a3912135f5327e2d88a665622897b99c9e1a943f9613bcb06e314d4929a9871c6b3901f2a7a0d8194d2e791fac19394974a9514441e773a9604b0ed66072de6917bdd8a465d7fad9bfec36d7e7d817e57a7120748ebe79ee01d1a81d550726a27d76164500a3addb6e2f4441899b030499009876968cd017a7266a62f6146cfc592a34c11a29455089f1794a43a1689637400f93ca000623dbc99cb8bc69c2d38097d7d54657a3c63b154076f6294d33faf5d89e312aca17f16dddf6f00f633dd5aa2675a85d2569c13c5bbb6da6e074b8bf33e75bfea2413f355e529979ec9f7ac960ac59c1e35ee43d36fecae52238da68d7db3e0957f0421923604d5610189473a5e63f60cf8220d790e9854c06051505f3388f175f5330237b8a26707419f0585d247c39574f30895ac1241793eb3424fe81a96e2cea59a24bc290b62a6af007634d3d8d1615657621ad22544276e09e05c07f3384814f48a2d18dd8bd2277cc5ff3ebbc418636589f2be3598fc2a3144c65cad85e05f98040abbfce5f3cbcd44351e0a892e1e71827192bd5151ae9a14824484890c5a64afe7b5dab4e20474da62dcd01d318df9a89773d135813e08837bf7ff28d156d7eed6abda79a0434e84471d224bf701df7335a447a4bbe419cfd3182bf5c291a2821a1747acbf0db71086f276a02fd06b05818c357bf15fa7323ac76c9b7d291b66bda569a7c36860429621fd179f66a5096c1f5dad0d2108603a270625e09bf413ebe8032bbf8ff24b35ba63c02d8212eebc7e1cdc86e7d75f047b99fb404243a8cb462e3d70c15a3d94aef8f534b7f23dd7e3685cba523f079ebecfbd8b504b40d89685a447eb8be43ebc7830322a3a5056751c68f2ad9da04c09878713c5056693e532ab30589f666ba6e6e880a836a96a082fdaed68e93b0082415265fee66ff8570a0eb7acaace23add20725a78e9adc892b9e45b4d5f8acb0a198d5a85dbde3b111329946b3edd274d886a58a32073cb88dee15fef336b66436c389747aaafd0e6d031ac5f0fb8073d6ab17c38080d9478ea8d29ec81a77a6835d53d8593ac2045c4cd487947f08094968cdc8a53dd564ed325cb3ec48b0250e36d3bdc94cbbc370b83207253ed14f286decc1767581f46599c316ed14fb814f07f98abecd1f037421bfcaeb95977dbc6f1e658274e03b042063c1fd9bec8ac33669b6668379647935ea3c4a469d94794e42ba133a3dde3072c133a7ddbf41f91b31d601e46768f716102066b453631e8a55211aae1027edf45571f0c0dd22a116a7b03bdfcd63c276768592d8a9f91c2865985dd25cf4e81845766536aeb1ce842fd486318b4c5a3db2014909f658de002b42d71bd1ba9190bd7051036e4a652743693853d402aac5d70ec022a2f996d7df98a77bb71eb62f15db3d605c91f1ea278496422fab0ff12914d7acbfb6586af09cfaa99ef8309cc972891a68eeaa22b23eb968029b5c22d2930e7183b69a82679a6c4dab056d328d8a1c0466421a9425be1d394b8f687cb8ebf448ac17f6c9912eeab1d6b8c9637747e6c2624e84ab1f28af7f219a1cb9b817abeba4cc552a50cd078ecab3d10cdf0396672dfa5255d2ddbfda6c776e6ce4490de963ebb4e201aa4a6b16dceb0e3edb4ca63f2418db5f23d044d6eeefb98bf35e410be2192559ed0706820fe0250b42f76ea85b140cc7f8292066dfc713850d73f55041b7fe867ed99a1b14c5fd84de38a7a6d265a23619a3430bc7ffcd1aaa2f556b31866e45ffae30ea8eaef703641b4d280874b683c230da232242e36562a78f5f8a02873b990cb8c445e194c5eef404ee6243e72aa8e91881ac5748c4b962aac6debe74fa721307f753376a40fb9b39ce1b50d3364d728176a9c217480be4a72fed9901929b1093b3db72e38f468af376534bfd0158a4bfb5c7ca772b92d91debd4e6277731cfe4244fe9f1373395a119d28b64f9eca9ff014f56bde8015da1990c686738c486d20c451564db53baaf3bc323b717d4eb1fc12bf580fa971ec90da9583c34ff187476fd65802e0e088a1736e1fc3d6107c3ec7a0e3fbd9aca3513317babaf0b919ca187aa384544849f65e1e0dc50aaabc86b26f4ced50cb7f73c1592884c561bef288e59864612f56ee3a705e8de0de55a273dec7d30cb86997d4242f7c59c27cb0af3286f262d0fd8850299c228a257a9d9e1a1b45005328e0585fcbc02851cafafa52161e6a1dfab3552b2a36eb34","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
