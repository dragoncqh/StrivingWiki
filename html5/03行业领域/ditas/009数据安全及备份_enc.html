<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"04816a4d62737a8018422f2ab11b0d465d5e9e731c0e5d7e97078a9b5fa95077bdab19b2568255d6a74c7bfcf16851e942a80851ec5e881d8aab280ff27efd2e80727c7de994ecc052684cb8599451bdee1acc3aeef59ed18b4b4bb0e68a3b01198d79cd38494031e098df1f8a2b35651591648b5758114a02c509a86b96e6f7a39fd72cc464418a36fc671494802041a1d59ed8eb164730472540975227417ea3b9577ab465690dfcb9f299c89cd41531665ef20e91a30d49b6a339a0d59e130421e912c5d72ca8f57ad6b37e40ad2797470b5f6d65d4f33250bf1a7e325cd951321c81e621560cdc6b188318c3b92367c344217c7ae0c1cfacfe45134fb2ed0298f115f8c49781cd14bd5fa5bdb7b6034c3e9c061a1f6f95081b90319b24b87ada2983154dd61f368ce8b2297b0be4c65d54521fd7aef5a8a4b121b8e9bef33345c1e3ba1224bdfb6b8eccbce488b1234211c1baad3d7aae00eebd7da07405621b00c34949cb4557b15e3cfb8dc8fa3eaeab4792e1fd1993382d415de7c94cceab99dc435c25583b4bbe83aa4c391c49518524cb0f7d76c703f638dba700c962585a88d8abc01080324ea5c62bceba5652502e8447311461eb04744ee8cf0dd0cb05666dd3aa7a9a3f9463b80ec77d78ff14b4014f29ebbfdfd59c31841796e1a18d086b5dc8242d50bb8c5c5b401fbea80183fbc4d3562bf057a8d83813cc12a4ac19ac68e61c2d2156144d3eefb55b9c2897743090626f3e6a0be0b8570bf8d800371432b48b4115df1d32be73d16d83d75eb22c4b32f45b32277b404188e954c2aea769279994ddec5ca373167032fa4ed226a992fc935bd16b21f3e9e93cfc3601fbce918bd7934528fef3928056001e97d5ff703a9c6a281330b492ad0c0c2f292bb1bee3958b89a60bb85509188db8435811cb2e4228ee139ab6c100ac105442520e603ad960f8231c8744ad2dda21aaa5d3dd5628bc3c9c963a9eff13355b7f27fb33bfda2071a931d8f94dc879554d6fd56a23507121c333114dae1d9a4514787010156c5fadc16119099d1ed295393995879e40eed9e806aaf8399517ae521abdc5878576dbc3c842bea0facb554d6a6532e5ee90b4c7f5ced46f3987f2a77404373be4b0bf247674a4c990dbbadaeae48d15730614c0f28ecda89b40a8dfcdaa18405b48d687234d779d899b871a0084997e6ab8ff0f724f1856867b92ca2eee86042f695adbcd9c2875119600dd3cf44199716c5e9a48f756f86248a1aea40442f377a15195a6d75f314a939905d71e89295d5ba0e9ec10542cd9111d396dbdd0bc1d8ac033a4a5ae643a85d1c93bba8f8c414c89affd46ecea81ec247f32492c8d23b15a9fac8e395d2508252fe5419d0b9ff306e5f2aa18f8f669fa521b22157209861c9c35cec893c0dbbfef889eeb6cd300928c551e56eb9ea2671ba146196b2bc0d2d15965991cd11225dcce704cce11dfed01f748f7ed215610d20bdcf427ff2e8da4073acbbcfa9138669bd7908d8a7e586dfaf555996f58f1932e149338adb672c1f93f471ae22866bb5bb25e7b73721a19bb4ec49762fc91b2e4b8fb5f92ec43ef52ea62bb1c3750e936f7674ea4994ef128f384c4fceb782e1dd42b4d45284cc729083af1875878639983f6cdc637b6518dffbcfe5ae1bd6623f0d0301c3cc983cacb49df73b1e479d53baa0ac2c3a6ed95d5cb4ca721e996f63cdd48e50e18abf3c0ef350399b9176a3b640bfbeb1cc58ece1384cce59a87c44345cac207dd11fd3dc78665d8c882fc949adb657867cf1dd301ffec162afc56cb432cbaff770016db32de563b7c3a3eeda70cd2c66e877bc5ddabc796787872074f99d14598237383d8b3ab3eb20c25f85b522894b6de85b67a74ddaf75297067187aafaa0888f0d9e5a844b34e58e44892a1ee01b2fc181fcb82ab73702923d89a799f07417e123ea91a0971085035863af73299d73c862bf7e6379f48599f86e91f961ec7cb28c3b68deb2fe4b1368c4116e54f69d6b5318f3151b8bd2584fed2b053bc7ce70912564c84cce86c57f2b721acbfaf0a25277d6a1b04f3ab0d7b8eb63d87d377b5d95e88e7c1fbf6a63c3964874e43902190fdbea680f5d5ed2a1978a39e13c007956e0a531fde7922a6462cbf52a264201155dae25c9c91b0bf4aa28ffd44eed5e38599dd4b70c0a166d121d6e41437e1e5b4064184a54591d896fa39bacfcb9c6b92f4029bc976b115f7a8c5fcb0006d7d7465c06ffdf68d9adff42696e49dc46f12e8545ae789a8ad45221688bb4e9310f89dd3450ebea4e57a24f0ee65ff7845cb6e38ee28a4eb0d769fce05a90c423ef63ffcb0fa6ad778a01c3b7c1eab8d0f4a7c6d388198574a9e9760f0d44c9667123fb6afdd6bb0f3fbb51c91959578c7014fcdcaf8cced5d63161a3f4e5101982cf005342b5745f24caae777a2e9bbe272b097e7d1be84b457c3084273997be97cf822a15c05e32536ea493225cfb9bc9d3dd2796d2f893fab142c18ab6cecc38723792f48e772aca631780686a539d35e8979e2260861671926a4984f50025559865ca1dbaf40a4ad0c17d293d489081fb0795e7bf119ccd2d288d5ca433fc4d13abf75e886a99246e2b83cfcf6d460a0c3f522895bf2d84a8420c7fc0462bd1624bc4049c36088f722307fffbe1ac760d2bfaf1d0a3f25576e88008eab4d3d5fd34b2b0cbafe716275b20a875d43b557b1c1f61ec2f87e756f88d9850a57f08526c3b7a04b6559139ebe880c6909c9ce92fc105c00ce1eac66f6dbcf859f1027cc844079e3e8eb4882d8b659e3405c90d16f590f362a27e5a0097ba53483e812ac802223c8ab3ea17f9af4063d316aeb8504c879311ed909e704d48a32933cad7d9366f34a7a28b4dc0772fa71055b91f69a366a49c1db15810ce24dfecb798db74582d15a4d3959ede07ee346b40c2291446906d5a9954219ff3d22806995c5fee4980f1f227eb136b15d37d47d0e44660dd64682218010a6effbce9ac7084217cef30ea34481c294999416a669b84008c03ae51c912c9fb0a54a0dda3bec4bbc9c54775eebec16956605f87421369b12234cc1d15c4f1948f3afc07a8648b581cfa8c5c01e45d7cacbe0d7429f51ae17973f0c3fa8b4b6f8739f9600bea0540ac7fd1e53f1397fffcc45148aa5c430c44bc70ee3b239c129ecff64780c9e85135088708b556f693e9ac70ec80a16bb2110ae5d64444896101b1ebfe0a935d2d4fab5f82da534099f9f5ab622520d7ffadd650b660b05f03d05a604ec1d697317a533b83197d4943c09acb68c07556310b239c89cae2b61c64440af0d19c2e3a3e012b22e1313ee9235f1b194003d16792b92286ce2e8df9fc7d291e2f905c302a2a2638ab0b2d5f19ea47c3683524ce56d911a1162ac887f2adcccdffb278c3b9035402ea8c6b9959047b9ca2c313299f90b18ebc402a1d41ad7e8561235d56dbda85b925152787554f79a3463dac042d202826abb14c41fb05ca0721834e7aa69472f33f2fc84d6da28232cbdffad7782e017831940ffca760e5cfd992d5f805a311b309337c32fd97c2eb852cbbd37d9525290816bb534e23183882812c8d413f5140f5337a9c303882e2e7c7533b2ab25d4db1c18dff2c11b651556021cd104a5bf4da63ca96e74ffcdd731442e4703fafb9da2629290793336b86fbf00ceacfd0dc46833eafa47caf1ff35d143874b116d445682886e87f9de34530907146eb925156500c1646952e1708fbd52ed03c0c9e6acc8820e58ab9605e40186719569d370c7829c844dc4345d22790e1e4fa9f1ac061166393795f5b89e3c47ceadddcb1e41699fc50ea7686f5648d7e15e7f435b0690f0dd1c676b038c8d882c3a53b92ecd7fee3f6d2cc0cd41b38bc202b2bc5265bc0ae3635e255e0c0640152afb7bca10aaa7af89334112bca37d0db9b7004d25cdcd2d57f4fee772c20a889d1ed17dc11dba03c774ad684c294eda7b5ab795bd4d06a56337a2626c5fa9dd25be88f24c8a801b8f80b85b0ec2d34879bef2a47bf583abeffd6c9db396155ae7c88a92804046296287a043f5b93357b90db7d1dad46dbd8e52ac90bcf526421c6a0169c3fca35985011523379ece6316d90a48a2451600651e8d842fae87344bbec5e7d87a00301e8469b16cb2e3a89592ddb91382a51df888944b24e0f6ac0ef88d647c77897bed856f248112e36d400ebd61f75e71c59d43192f1db06ab28878163745d267b3fb1f7936935e4e7be7f05dae8fd71fc0ae7d50798bd4354c005eb1578c1a5225af07d52903da09edd18395441d7f53d5471e60f2139b55968467c6c4ea77667289112f6918add2b1ac8c00d56ce7099348dc3b990bc63df7c7931e86e0878acbae356bd9db4cd9d345cd0069fcfd26477a598b8f362c7c8f3b1523b6e023e2c3f99c51064743c0a40c009253abf5c6409b2a61df7bc730daf7028b03448cc6678a8a04427ecf104d30fc1b12e6e9326d9d9cf6147a7de9fb4b01cd9871b0ea9d419197304ae538aa5b1d2e181f40ab44c39b4dbe6ff89bbcadb3ea6eaa8c67ee3c30cd5b6685862210d7feb2c81a3b16d212a46815a3e17aa5c13f19608889182586d6b52d6b9f16cef68e73fcebc7c74030dab6b9bac1d2febccff588d9b5fc50c40a30676a3f4e108c7126b1fb55750de199f9b10fd62ea18b1db96c1a230a463acc8c5bfc3f356cb33b9b426521a7d6cdbcdc8a98fcf18a3c34df014a7360db2851c1544d30ab69e4bb5bcd3bd4d9c9e894d3352d5fcdcb19306ac78b41b75f18a61d81b8f96a9b3b5996b0594e3e4aefb119ccb7622b122c0e8b032701349ec34988fee4c15be214aa92527cc3d48a859a5add7185fb9d41c8774649b6cb655d5d68bb9de03f7462c9b3af4008a1867ac854e2ea7ac2ceedb2be8ef6ff6edcf80e00f22bf176605b6566b8ebdb1e2850b9de25123588fd0693011079340d23fc078c8e64c273b5945f7d1b5b47276d73c5b862deaf3dac970b53ec8758b9574c88fc0a2fbb8ce4593ca201c1022f8ce0e6cc0686f671e12a5fc9148327b5ff714ab1ebb590659aeb674bd07f1fe851e76eca141bb19d6745ba60c937fddf627ea25b1fb2a2ef470310caca29d4f359b37e8865ed323218c465b8b148a3682e8673d7d6537937f6b2136305ae78b53ce9c08eaaff3e6c62292ac729d0a827d00a40c7b6a3b97e474f4b383ff060f5baa8c166c6febb8df6338a876009cfc07c108b128c31626af05442cca1daa0ad71c768d80d773efa73235ebe42f6fd66ccd63f9bfc4963eeb24f6d1c7b8cafe49310352b629579a0f6cc5fa1cb9f0bbee6837c52310a2ff54125bee58d4f78ced3e8a506ece44a0a964bcea583232f600073f01fb1eed28d7522c9a4d47fcc471375a5fe717690b881ce17261aa7c7ef369f76c8be15c90a074158d7cf216ab7b260c53ec3d6c82c509a191f9e26a0db250840bc51a7d70146b88cd98d5d9f1da4b94d7159f29af965f5dec7ab15056fcd1867d45134f27360bfdcdccecf49252627047aa62ba9c62eb3e90502c355db424177abc4b516d61108a60901ccee034dccb38eb21eb925ad4e82a2195984031cf261ffa1d847eba563ba9079cb19a9f464eb598dfdf76cc9233665b9e7c5dfeafdfba2090ba7a4b4987d68278f763d25b51f8ae40e7f3882b7042ee00411476d818f05bef05008e5194d56fea23884f5910d5a05befac8dae59674ef8cc5f5c788c4da63dff23f1adb5428266e3912ba2138298504f78217db4f4163a8ef44c307c9941a5863c1594ab8ff87ab4127347b39523ad9596a827a611636f5c420b6ce1ba8a49c094dad0e1904bc425d16d9604d769e22e044b03e18da740ec65379a41045f69236e92a1c872d11e19bbb7155c398cdeedfa1cf7be6bf077186f26cbbd8827736af61c6fefda9962de035c1d42f741dfae96ae418a892f3bc619406e3f1622c113b51d18eb6bbea299193c15da4f80acce26f5dfda98d8d7372b282d01951348caa31cdc8ea265803dbd96cf84c9171e0e225a2bcb3488dc35eff96c8f245c2934a3feb2624bb670a28cf72886e1e8d725730680535c3fe2618d4ac2c5f2380ec7074ef0a4441b88eb22d864bb86d8403ade8bcaed59afa1e4016d2921de84f9dae1a003ca503814fdd1d46365b6022ea860334515486f9d2f4b8c74037b3218395f2a220a87fec8166d51da16c973eb97aee25740669aa8168b22b638989e3da8fa2705be39cd2018bfd1a256f827191c6d368dfd94cbee5ade1083b3f9ffeaaf109c662848fc29b9c63be3691113ee4c50f84f9638a4a6fa90bbe10dd285761f0563416d54d0343a0d76246793c8043b6727d64ddf6abc34094851772916ac87df593688aadfa8aac415ce239f1e83d4715602e99e7b580470384c0dc7dafe02847b16e1dfa50c731dc0a1593ab5e017542f813567bbcdf7ce8188343371fe0979a5167f3efaf65cc1cbcc8b06bf1f76c493df8a41df6f18856d55c336d57ff632dc381b48528f52eb23f1346b69c542c1eb74cade9c93eeba8b644dfd9a70166845406e75aaa254421bb7360bca2f62184a975821d0a8f8f82d2fc12f0732896f1ba0e4a3f364f438157a77a9ea0b62580caa804bd95e77dce9a1f86e65d011df69fab21e15bd2906546e37f0f2a7b1cec330f6074b899eb14b7968afbbf8dd8563a609429d6fe815206550221f37901435a52602c1eda8b3f0f90ac9762e9bb28d38bc455aab371af7d478340ce0ce46ed71bd83ae056334ac8a31105e99fd83465e61b0e59318bb3c8fe1d7b8eb42dc97c14674a6a55de32919b0f0ea946e4e203a1c785f167ddef0303320566a6dea70d39b373ed4e8fbb278cae64157159558122655838c39ea3b61eeb4a714b640e0ed8892fac0b8bd94f0dc1c20c5a97fbb24ca33cd9ad676ecc2bcce1bea2d123f90fa8fd38c2bd800692c42c4602c2058bce22f27510d34b12f5ecf8a49ca70332bc4b4109ca3ebdd2dcb7b144cbbe91325876add9f1c64e9550a40c2611f3d95a192c918ca3267c6eb440028314843d8b1f41956879c631f4e164080b67c08212e6474c2460471d53ece7c83317f8e6ba2ba38d133223c84cba43e2fd918dc571a96be7dbf9ba637ebff029f1e0cd2a9490c95c7539ba162d9a309b413efc937d0ac5be48817140beb655cc66d542cf048bcb446d3cc23784d3b938e47054e5f4bfa44d287dc5bd34572f3a86e850c1bf66f092746040cc26b48906ed592f5ddcc1725fcf368cc06a4040afeec30bfb9f08992be5ce6d8b5d943c6d26dad330","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
