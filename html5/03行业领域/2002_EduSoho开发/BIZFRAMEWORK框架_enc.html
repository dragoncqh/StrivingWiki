<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4e2f001999a56d4d76021fe542a52c8ec27012a15f5f3375b1decffd6b2b07a4528e354debeda74e70cd43913677d29601626239774e5d5161ac919aa6ccbb37c80518d80541193ea74746bb164a3edd8b7a32f6fdb4aaac7de9f0031a5e32559e76305589ddc533d33dd5fdb0098d9d342c0b666de6a87e54a34c698bc87a6940c59e566b563af1841fcd97f7b9de4146ae5006ea4befd102d349c7ac1721a37b033f89716bb523f2d9a4df0ebcdf7d4262e89ca36379eb68ec3fee54f47ae776a0b4c377609c1df2ad1e92c8933a7506dcee3e78492c90404018480a129d8e38c2e32946fc5d0898792cbae7d00b0af73eecc3522fb4c2df647d0318a10e1d1da04dd94bf81310009d8ffd7ac91b8366d5275345fef03c5d0a7403569982b9c9149a10a785750403c219429f5f64134fbe3f2055b764e8915c6968f930b50d4f60ad3f0509393fcba6d22feaae08ae8f4913541d260c9eb286d56b18a20b5459750b576156afcb0f038410fb487b6a300d49513e162a912f843c27dcb52216d974fcc7942ab3c03fe386e8d992a6a9edda1370364c4d17c6c1c2da7cc1bed0b159d101070690dbd75c652c0633411a32e73a639002a98e262bdce28bdc9450ddfbc10fb7ab12856039904a1684e37114b238443328b0a50b5bd49a776a1735c8a62e97e227da2f3b6a05b82c6779c11c930b40ef9f5e015ea53587c5eb6d8cebe6aac9f474f5896b9ffdd06aa295626600fe20f91dbff5ffc4f36bf883c1e57910c1e1d6f43847c33a48b8a052d16a6a0798eec2b28651f33323581b336866ddd7d408e6a855df6be9142a6434fcc390804a5bfe5d503590dbda3f68e61be85c15bc22fec82942c78f25754b514d1422feada00184f650b22a8db5aac3cabc9bdc1cef388e40ce8aa4b4cfb85317937d19b98f6b53653ff3d6cffcaf0c93349054a5326525a8e7821c69b71329aa7cbc5571f3336f90607bf3a88f1a934ccaaf00f93a67bfb5fe0718060aae2ef9964e27000e2a988b89dc428a7fa93b298bb829e807f7588d71d3a6ff7e78f94b6072b07db96ff2c3c07ef66ab4c00f127c9ab362f1866fa6443d95a1082a450e85a5e2cb732faf1ab7f0e35dbbbf0a3dc511c8c10f790815f43f56acd5a852316941379309b71da54d6eb92a944848f03a79615552940dfbe7258a06d6955a828942e5311cd5c5f7cec244111672f46e6e5a2be477244f9b1eec699348ae2e776b419a3e1e03b15448040a4f5cdb2e9a4c1cc37d63c423048f684069dfd2abbd3a5795e9831fb48141b285858d4fb896067933e29044ed33a65a9e4c2002213bbf611061342f9b8ed0a758a4d13bf41efbb7abe15900d2e227f4e94a560ab911375b3e59cf6ebb47d953cfe4b881d10248215e48cf0a982f17eafbe5ec519d9db4818984ec7f54e68c251d40691801eddf5ecb9797df3055fa9fbb25d085c8e1b873a170db2c16d87900cd4282f847516e0f7c4293eea9d209cf696b7cebd30a640fbf8d7b222775d19a57f640796010b7dabbf1fabab637f434c8d4a2efa38a206b4f73dc8fee289b0e2783cca2efcf91df2d68191c347c7b5fa1e62b4970f0bc5913ddf5a476917149a57ea85e32bae17619219423710a1b7f7a87d1b25dab0b094b1a9896acd8fa50c60a5c900a552cdc2976d22303244ad1424bbf5a9d8728f5eb1caf9bbf28359bc0802366d52d087e9fc97668b35a595461c2e1068d4d5fc8c59d2ffe80a9887edbb15c43c5e02020e947bb11b25ca68ddff645e63b9985c2a62d5114ca779b2c15fa1c9ff48ef240d540da2e398bac30ce0c53064db277528a36d14764db58b1be931425ff393f0da10163a824f4efcfcc73af208e523f63614f4600cf6cfe901390fb74eaa8b95dd4265421dc142007cde252710cfcab6167b29dfbf7d8e6ed1f97409bf49030d465780e30f95815869763bc6605dfd4126acdfc39a4ff075ffd681cad5607e4996d6bd1422042cbfa26612f5cc8463644ddad26bbe2a558b3a9b8e8589dea036e047b022a53e1d38fe29d4970526b4398fe9e196f08c9c89b34563e67de12c0a60024b11d5a2cddf31a81bf5d7732d8cc2313bd590fdf17e09464c4f8f9565efd369dcef25ddb5923d3fd4831892302040b8f77dd40b0857d9e42c80d15af0773f0bd01a01c5569a8c9a49bc083bb422c0e07a38d753b973ba5b22cb9159847fb596f297b1524b344708f022f029a53af146487880a6469d7d753d3eb625d80834c9243b7f2b76527a4ca3601e25f3e049df0033846def47b236b19b6f52862b42cae003002489ee013c932dcc24e619980f39b639a886770a7008b5100a72fde6eaab34d71e0489e251f8220e442e28a01516a0e23f593dde497cb956230ada1497546aa01619d471227b8c460b8ebd3c617f8d05c5bce3f3eaadf6ae7fd6a9d6bcc632bba08aec090d05041fcb53c6733e83502a720440b6fc216cd35d04997805ee3b5a69e35949916ec00cec807c750315d94e13038696655f47c140768a64bb75b82c6fbf6db191ac5b0b157f110efd91126a6ddf012b70f62d69c901371f1639bbf446c93a6963229b5aabeb2f123f8f5dac5b4f28c26c23f5934483a48c3afbf5e9e54ec88e9a87681bc4dc3869b12501c28047a27c9436d15e3cdbb1d01bbb181838fc0569ed517f0f0e5c8e0a32a817ca9ab61f8c31f0452baee956bf927e0d95b0a0639bc703d2edab2d6367d4147aa828102679f8befac04bf73136b230301b64d6a803f0147a0b8ed63734adcd9bc911777187fb958a835232bdef82148eae7a9f1c83ed88f04c96f5418f3a7d406f0bda72cfd25b6acd6a6d8e2d7962833a0001e5fa93b13dd92cb14c9897e5dc66e5a4df24ce169c45bb50438ca5ee79e893768db9e36fb39d9c15a60f22ed35f6661d687f343c2a881278f152966a8ba2912032eb7742dcb943632d46f7f627bd859856adf884f2c45fc59c6dd1f9c6b413fecdcacdc87a5e2f5507862660d9b0494d5ed41274ec81320d64418dca77650500dd63cfd4e1a2e9ad0cd58b53768e4cf4158286cd3a3af80e599eeb1651d3340fcd36fd33d72fefcfcc650a4e132f04e088fc40500d4ccea1d953824846c816d10a114b64e778ba579b563bdbdff56012da81cf119921c9b44cf0fb4b43d3a07a139d5ea7584e3bd75bcfb15065e20b9ee75ef9964a5f661957655a68920f5ef5e6cbdc6103cb4a1a1bcf1f657267c6df4fd2b39f6466e85d9938dcbbc0a4f10947c65ba7a54864aeda87c291637a7268117a753b43d84260137b35ad4dabe5495342b768dd09262ce48099ebaf0975b630b8fd4358a65d1d63bab614857e1da360ed802fe67000f6cc909a636f6105891532101aebb433a657a7b9cae9599c7fe3c95868a8337fc258c28a07d5188ba472598b43b79c56876fccebbe50672315317538aa20237ac5eb1b6e2d33f41ddbd14eeb3dd5d64944070c8adb2b9a690b0699cf6bf6da09d34ac58792b635e1b537e47ad8c9bb2b79255603d55efd842a0f4cea7fa6cc2a70e6477a1b5f0b768eabda0282f7ac887193be66ed16efcbf3b93ae8e3ed390d8d074bf37f1c3f32e5c5958de566a47c290314aa9ec1b19db3a08c48263e9ca6780da7c59e44724b2c82080f30b9124b5cb72277960dfc9fae70ec811de824c26b1d153b57efe7f2cc15dfb6efc42a7883cff171bc6a5aacf81ebbf6786def5383f49d309ab5120348fb4b1f7e6ecf8c734ee9478b5d7b21e5d732da547e76ffe101518bbc38f2312b1b99720ddda0ea3372448adab0ef59b563df02309ff7418b4780a2ee2ba72b03d2c807d601315b0bea7f800aadc61c7218e3629769258c73a83ce64382d9a7fead22eed33bb09e19c2498d56ee5735ad3f55640face26d82d0748993546284721bca1e51c3bab1d640f9703124e557e6d5668e0c7a1e64947a0a24b6e7d3f7f090a31bd8ba53fb7371abce4542d8c3d8c0cf378f0dacfc76364411b99d4f12ee852101e8e9737962bc0428a01e21e5288e30770f4f8a200ef1770d1ac098899f7f30b061c5d51c1ae48181ebdc669256340959e7fd20de9a380ba7bf8307ada28fd5cba4314d66ba4547fa262b9807df157af1f85d08f410ccdfe5f4d75bdfb7bcbe66305d73fff95950934acacf59ea2295398561bcd4d44126e5c75396767036f6b00e4308dfd409ebd39ef917a56185330ff1dcd8a4485f082197f394ef31eaf2233150c9cb06990c0d3aa769430e91f507c27e1965b8c8d1659aeedf4856e67f6dcb3c81b724f267dfb6feecc4a5b0a2259c2cb7a553a23375b3a0ffdf3362d259c353ac56d0435dc48f1cbbf38bd3452047c8807e67ddf85debd59758ced3f3045548b27f23afa012f8b6a4fbfbd4405161e5be816bcb8f2cd67faa7f200f6c667d8de849967221fe7277c866c5459d3b5aba526722d9c335dbc3b2e0d99f2bc2ed4e0f9485bd381eda7137b73210043e15777fc3f877de1ea8c8de7375cc2d12b661a988997b31d8936b9fa71effb08718f67146a662d771d5391192801dfd3f92d66d4f67eda8f5f937dc320aadf5aab4306dcd00370f7eed1da7d66b16550862434be71bc85267489445ed5f12fe17aada92f5ee5f8d7c39dcc2ff5cfac54e3eac86a5e08115fe25f875f91dfd65cc778726228772192b9ade4913d0123e4bebfd530bdebc220d81198c5b4586d1f0e8ea11d3f6184748a37267d1c4bf6b4bb492edb79b733fa4480aa25d99a1a447b6b810d864fc70adab160292b31114a8c5562e689e94dbf43d15a18b3c3b5241efd3ea69d3aa596776765471c0bd1575f363234ab754c99960d9f0a67616a7b2165444136b4ef75e07cdac79c938f57ba863289b6fdfc73ba27b296ede0ad331552e16b06a9f493207c900f34f1618916502ee83459176ec7a1a2ce9b24312914b033329cf7851aa2176da4787c71afedd3841f95a2a49ba4cc63dad59eef338bfabe78f8919d8155979d71abb19ad17900d0b4178205852f09a8d28efd83207ca735ce4a6510943cfe4830ea1bec9bfe4ab05afc2df0debb311332243e718b5f53adf606fc18cd3f1136bb0560c68a370cabbec079b566b93fb6f54c13dd39616c1d476052a3c70d7a72dc47d9e3108a92d5a3747e67f10c34c482b9461419286a2f0c81f1281396c689751f6dc56abfc1abbd885f9f38733212f25484d1f49f246f97c61b8fbd37514958eaf9953ae9d4f5da61e3ec5e4f44ea4cd57df89e9e46c7e62bf506d3b9809645d6847c0b2e4a0f923e0636c520ac5a752cfeadbc3d3c7ac799424c4b0473bd4ecb1a93d72064f7dcafa3ac380226459ff1ec0b592f6055c9a780856deb7f34e8b888125730ecd7d2681ddb45d95b95318e301a54654a0049777e2a505063a3d5d9166036a791255fedd49a090486549b28d871f65d4a8672e111ac25a9124f6374c58d053189377eab2b3db75c03c382bc671f138c172b204ebc47db0b47c387ee592c434937c60359ff3745db9db13ac8d4715fe6d1c3ab41d442b692f17fedbcce7ced79e536b184192d32718aa9c9915442125e943dcf0c0287130a5e93992caf16e9a7bca36bb18ebb2c498f26f718f898197ceff965da46832e48e222346c68b00c3f0257477f1528f7e72eab357c680d67fc3f96f597811852029ba5d2995f6f52a0155ca0aa64d766c66843aa45df62b2457f218ec2de74a1ebfea9ae26bbdc17d02f0e95e0d7f9b10fd2dadd494da7682126c179ba341e005ec14fce26d70213dd2a1e436853bbdc705640002f87e193fe1aee1d203f4aaaa2578a64967ef99ea82d93d81cd635fb39895d815b78e0cadda4000d053698a059427ff83c69c12e94655355b8188402e8dc9162192fef697f348b0f7d5e7d8d18ab7a59d7a88ff3520f66a2fddcc3443f37977a83e08e647c4ff424dc754856b4b249f1963832f5d413198c384a7ebc65c404b608de6e96d170682f9428d4b7ed8ac3754ae3d67280401f48f9b03924aeaa947f1dbcdb960efa1c2410de17ee94d9ef0cc96291b022aceec57810c3c9f3716e9a80827f676cf77729b757f20579938a7c804fada64a5b1f9bf3900fab6536fb85cd45eb29013736443cfb45df5756012f80aa8cacf4c948f8ee5bae5d31b3c6caf87a51dc76568d15b4a4d219c2ce0725d0d79bf475d70334e793381d0b918104f955db6c0f3a238bf9590a054951ee40bb83cf1f8056fbde40afcdf9231c09b1325322c59fbec4b68c2ad461cc23b3f0f0d27a3e6e4ad86286531ea978ee7d682b839010e7bddd559887dadf9ef8705854f45e16363c69ec4b70a1b23582e246d9c521d2f54f070f3a2533a989fcd12bdfc9022df5401da21e9286348bf4ee1d9ee239ca9d3315954c68c50ecaf8bc1841a82699fa04e79e7f06ce988ed090dec3cd1c4b287717505dced6cc276320f8c32b32de634c63e60c76061e01b840c78d69009fad9006742ac2b228d00453e79ebbb678206b812b9f6ba3a84ea3c437fc0e44c59324fcd06e07d12c219b5e42dd3a539fbd1354f0233bd5767cc92d412731ae8b56669950278a3f3135c2bb8a1ad9e801448e9cdc3fac4e5439523116d3ced85f415695659e72d3843dfb1aaea923b4228394cd3b55bb2e540fef38b9e83ccc8047bb60bf76a4f42dd09f43b136fdf3dfee0aae928193f55e7bbac26df9abc48c1bb6a13ef9af5bc0243633e594e009efecd0d3a6c7afc54b0f1e89ae0bcdb13b95435e771538128364ced3966a539ec8cb7433a361b1738f5f27d6bcbb367edac1ae151dcf5553033378596b907e2fee3d41c8ebbff9a8b2df87b6c20e51a06cd0ba6ecf9ec3d4d105c01e3cafc492298924e723070080a637e5260863843501233bc6b7aa061da9f27810bdd570b7d41e6bf7e49760fab3fe464269c35965c5891da9181c134d7ee71c263837483e1f7c4920445ef4456d05333654217654069895c538a5c3a37d08cde2602f479a91a52e32fb6450dc13b2687868896398f47cc7d17f80d253674840e767f0d7ca0912675d559a1635f1a0f76f16c3517f6f73c22fb05aea5bd8709513e6f463f5cbe304c9dc5239b7eb503e503939c31c0aafdc350d8f2dda92145370c55bcb867ec01d9f2bc274d1e4859ea3c3e1d549696410e2203254ef754fdb209e950075294665330d659a335d956b5a397db7f8af5fe5ef74f551d345854ae461e94f8cfdbe520ebe04548f6f284197d67aedc4baccb86ef5431e921d2500929c3dda430920f1821901e10c9e1e16a14fb0e5cee63202e90674359d8096e3d1e7e064a2196be0517d59d36498fe4f041138de782924f6a67420c33ec253816ba55e38b8beb67dae17ab98636e651d043c6b3dec35d84cdae009d9db872a3249260b849d9849000bf2652618eb15101e68a5e4245601e49a8bd1c9bcf3314e36fb2d5b686c2bb111e54a4a1a08801ac37ef80665a5d4fd67a0b6913e6ac97e68d6da50d60149708f57706bac30e9fd1badb413f48677a11b52121c9890927c5a00fe4ef2e653a5d27167c49e96697235e97ff7fa56d9679b0886df093d36e9635b4e9ccf584f5822cf6ac272d1fe9259cf57293fb30b513534d32afb4c00096ed753001dfccfa0f6a1092912beb63900254d8a1e4162e7316285832f46b529ae0f76922d4daadb904c781a64f192d801deed0366ecde6431fc86c4735acd3a6231ddce9c19fab33a1af6f2ef8552df44a3425477ea1424e6e60af2bb52f4364af8a072570e790bff86c9caeac4e0b8d73fc17949a5d68d134213e7acaa6104d1a09d2b501bf247a51523f3fcff5a42bf72c06d0013bada285c3eaeb15e74428e3e23c0cf1ea64e03d89efa8b493378f57a0a0451f94ab06fb47c44432d7d1db93e24a2e28fce4ecbf34c243475c86226024022cfdc14bbaa7de78ece31771ff2d86c645be80e0c1ba3775c65b03d642fa3bd448e221e1e65cca4fc031ec13efc7639ff8ce484c859b93ba4aedda1a7f60fdb0617727a538c84e1818425964887d5ebd6c6269fa8c2c807834da47a0df6b89578bf968a17ac8322f6af79388c2ca249230eb1a391de385a4077266203e24a2f26d0d907821b639b4b6899ae6eb0595e139016f593af052105a75be072f32c7e985b34c88f44a7d69615648d55481b7edafbe40e3ebb143b7ac0f22a1e99926bd75458e150df97c0a3f427bd9bae9999186cad5adcfcb6213ca3b8358870358b9f6f298260cd48c14e1e09925e817fde181ecda333b22c152050a441730650673b513197597f711a582b6cb24de17cd0e05db7fb4cf74a954063a5f57236dc7d2e4b55099a9e6dd15ef7f53c912acceec8934ddcb31279bd506d8efc8cabec51a767e91a06d1489857ac7030a5e0b6e2ed231d70415db37087821dc05eb625d9a2bb52d8e8af5884e73e2c8eda126aeab8ac772ce2f538be3d2d883aea2f336b8cfdee72c2df8c655211db9b753dc4d72af38f926b50e6d66d49822dbd195266207d62e26bbcc3f5ebea6a64eb690f7b6f5ae85cc81cec9085e1c0a68736759d28af3dd7902dec55f8cad544f7cce2c133337a11bc0b382fa7ca5ed1aca47feb24ad227d5c40b2746415b88cbfc503831bf8a5cfae862dc2b0d67bfa268b74fb503ca1fd4ab7fa1588cb2656d9162212aaceaf18a11da6ca7f6c86725b846297658a5daad7cdfd500dd9e17a0c8b60e778551837031fa56bc9f8a544f914c3bba2f455845487525714c2a55e3e9a476ba10aa7951b83dcf17fb15198bae1ea8b76914aa715630111637975e093f3298798b108caf375a2fb844496b17ffe32ac5d3fc579bbcbb06ce291d723b332db3e5bc184807099db97266199e188095fec60d41e7223ffd61a6663dab8d13b524960ab3269873d0df710b92706f86ecb8f4c7478edbb8776bf0a577817ce16c64c10e7e14a2378ff22153a4dd9eb8fc25ca887f4ab6bd165901369a900375adc4020dd85efb1a5376665779fd8cb7fa9bb1b54cf593c92c8b328b32fe638e01b0cba0382ce3b81508f8ffef320adf915494352067497ddfc69f07eab2af377a63a846164a66417bc4b2bd11b080b364af6b87481359cb8e24377106d17e8085477c6e8dbfc2cbd4341e3871ce7f027335a1444bc852c772ff2ba14d655b9e2f311b64ab5cc4cb86006134a414ef3836b8e228a4572607a2de7aca134d513ca66c4bdb2b1686858f00f90a90810db08bf580983731cb3bae78cd952be549c0d012b9b6e7b8099fd5bf4ba54f17710479e9ba065727de503c01d8bc8592eaa011b1b0ea33ca3bc526d696067129ae4de4c6f082c2f88898d5e7e576e6d61725a6b18aacc90cde4a9f529baad0f459194296273d49f280529dfbd9a4eae82d6cb8c60e462c549a773c3c1e548c61d7311e33b6d2eaa0aa5e97e9f462e0dc59ba60b070bdc63b6d27e6218143e0ee76de17a9798ccb038ce432dd992c332e74a127ef807f0a34b9c8b2e436529c7022d33d6ed677ae46d66767bd4b396130c0e52ea798a3bdf820bbe32f104e44a3e9ed15c91491e153e821378dd2e2e40f8cd0cd04ee9ae4f99a8bfb169993aa1964b988ca9ffe07854d547a33bf5ee70d7d9f0979b1ebcbc8de7ba871ff3e579bbc605eefdadb8eec43b74bc835ae8ec1d56c71e1ae354141b088800b53bd8e86f55278cccb54490913feedfb713abed1d5707e5f8a90ab060b58a0d8e7406161cc1f6ced361cc8b9d671c3e576147f8c5314034fdfb70dd9dd60461830d2a81ed3cc5fb7b04b57664de534f8fc850d58b5dab95d3a458484a3381fbed72e72dae8bc19bad735bd343ab8a8c4fec2ce2b2001ba6c1a6a8196b8c6e032c30243e1c696a6589211918c188f531388712816bbe5d4dcf1fd68549b8184b9955d3448c32dae48192f64bd033583d19b13930e2470d6ec6b88afc2d1a9ad4d83bcade023fdb7edfa07410cb35a0fc28481d2d5ab6f00d7ebf5ef087a83768dd0c0742d786cbc43b827942031ecddfdfda00c66a6b101e1e6dd639f3abfb2fb30d8cd3636d0eacf050a7dc3cdc702124587ed091d24761a62e338a539fa329a566eb53c0d57289a0556810d3211504300c0b81d456d872f14e7b01aa32dd0a69e978a51ca836e620b418da03c48ebc98b82c0793b0e26ae1f6e94a82423b5da244eb5720efa54c69e0007c506b75ee2cb019f531437a8f904025b8057d53af3c3353ec7ceb8e1f32f60eafccaacddc7247baecba34b6fede9f4c7c3175c0a8139e782d7dba5842523f8abe78aaa9862f8e479b6a06e685a8c7d196afa78737711f7457da56dc4e0433f71a950e189e33c9ea19db4b44dfbc1e7bdb09b1a16040306f6dfc030bb4d4b723ed20889e0b2159e49e89a59efd7fc6ab264075032d127648efcb2feca03651c97533c1ba833ee10326f1d10effef08ab7c4dcb34157ddc4394e908023c1b43c5d6f70d64c9b73ec05976541aaf092ef4a8b6069636504545c632e8b391adbd3f2469293f1df2b5a7d06c1239f0bcca3e533b30e67add9ede560fe62938199f4f8772d97a01fd39129cca9a7060cc4a71b3a6478b920921411a9a5de7e42dc37cf92a3e2b20de4913de88908bb166ffdaa3b1c3b27d625ac2e36916a91b1a3cb8ee8e1a7159c100d608818f064bc478730d7bd04ca43473c708cbe79dfabd7aec5ada38da8826f9321f9445a1fbc26d90ec89b922c2fcc5f2690778cb42725071321e85ff5dc62e3ee65f2e725a3798a747663e5e6fdc7bad343ee18822327e86b3fdb36798c7fc3ebd33c0287a2530d125bf1ebc320e79df68e2225d7ccabb76cb16e09365f99b6cdfbcb92e3a0b52b0b4399057e1135e18e6e2759eca8cb31392b93682249ff1c0b08e29b462c93ac9179c5197a596ccb664319d366a4f15f45fce3630f079d94a588b8e2f0063e579868fc9d90e60ea97be6e5b3bc90be734c65a61890a08db280014eab3429209ee205626caa4d7a446a02b1eddc91a1b65917610d591c46dc2b729bcdcf69c7ff8ec6d1396440f798f77ed4f71c315810352a216c2d9630547f67fdbbce7fbc9e5340317e1dc57fee810bc7707f1ba221aedca2038093feaa43d1e1af619600697faac0a66253c2c5e6dcbd4b2202cd3316bab1a0c7445f5265130d6ce1d815edbe743f0a5d7769b7e9333b510eda3ae324a28e2f6ef6996653bf42a99a1c13679a4a4dee83cc82bda4c1a500ee8ea74360b8a99aa37418e915cb78eda1e1c4020ac4210a5d7385fc0609e9014281b19dfff8410d325823524fb92df94e3fbea2e596245a49f1ddc915fd875f0d3f8c0cdb47c7d90b72c43790b01e3a8eace723ef8f17f63f8c6bd660df52af3ea27d0eba168c63e1ce68d472059cc7f453ed413c4c7d1a7ae7bd3518788b9a0338cc2bba190211ff263217b5da904d1fe6d54625d5d6f2ac6af55ebb077f3769aa33fffb59f78b235fb7c1114124f9b11aeec50f2d09a38567e9bb5409d725bc88fbb7d05ab27d3d6308a0308b1f31173f828be63fa1cdd630cd1b6a78ad06811d5eaedfa9da0a16d79711b726fcde153eef7bfb22a92cc631842a35370cde43839088d59d1ad63ba264671e73bd49c8bb5bde5c2fbd753b14317b2eb3cb704475d267916fc80d152190e196869cc9e08181ae11dcc692618de0f0eb94f544333299f1444b94b219c6a779cc26a3679305b9c7552acb1734e69628ec015a4eef83bc0034fce53363f5e4aac5609ae2720795a902d5944caad8b52b0d7425b3cf9dfd4c521a2cf1987e491b6dc206cf89760ceb1ac290ab199545caf8de3ef715a26dfea5068b7c026d0ea3a7e8f8592b857b2d93cfc28d216640344825f36783cf320b39e1ff15b49297073fcc6ebcbe528a2a3baf510cf5c5713ca975c22876f905fda3be3f0ee3be422ba5af4ae621ff19dad3dd5579a1782cce131d920a6be3e6b687aa093d4e091487cab3b42c632629dd4036a903a0fc8dbe434ee4cec405afe58ee00a0b90c189df2b39b88eb600aeaaae8a693b3d4535d702e9b8521105bd3f4d9ef9806b7f6c19689d09ad411df7b6c116d73187b0880c4b73eb63cf65b9b3b1f19347e2213c098ee0f2b105828ef32a0afa476e27a6c1ab7dc4c871f6d5376df2359c6e7ed0c3e2fe6b1075bb3061323c438066d559e2837d1f79ed4411099eb0e653695b5c921e116ee3e19aece37aa3c2e6b6b244365a4365e6adece2f5b5dcd87351c637dcd9f3e84538aeaabd2b765748a85fae2fe48a17ad86b7513d98d63c023075bff5d5a9bdbb7188034f719e2be9d9ed3ae6910cd4cf225eec8e9632a122899ff2ce17f5a84ae071d1fa52996f7091df9f77c4d2da50bf5a4f5659d967f576c596cb29cd79455f916346d09cc66efe3a4c9778376248293867c2a78d7156e809bea389be722ac7828d15c21b2974540c7896187f4a16f573e73adbd50dc611aa975c03aaefbc07c03f9dfff8c65498cd633f67567dc6fa822f1a0d9f95a43077b2708801e3d893eb729be8727c42222901d4b16a10e0d612bd580fefbeed9a68cb6065192798a238d14b057a974bc46124245c9e5bc627832033b1983e8e7218a9b501a6bcbaa22e4578dcc25d8f9baec2677793d8e5764a2a497b4029b3f89a0212cd4a5fcf44de52970992aeeeb3aedb93660657cdc39f6d0667bcdf3c21d577c0399d161b7a5ca90137d615beedac8e02254dd7abe1e1e9d5986049ad1dffc3b650540c4cd56e664ce17e50712bac99d8e14bf739608225813f7430f360321d7172146020699f4b2a90ace519fc79a8bbd767192eb43d429d3327866ab11ceff5fbdf6cdf4e343317d50a6e34157ef584335ed3e387b7f9536e548d55eb525e520c9b2dc8e8b7007bb1d280257558dcf6a6238114e45f2312a50d313ebbd0214732dd1fa26be89d6db23bd04892c173eed5ffff232d172a73925a55f5dab58d48f942baa1b9c329f57088c31b80874c0a3957fd58a6a7cc802c3127e745865ddb1017838febe30f9c16c161b2ec3532d6fed6842dadaa216861d1f70bc3bd31c5e1f6ab35e53f15355aebe549a4f0c5b8079de5c08f052890db3c11988d116db49c8839e96d2b1dc65b09589eb41cbf29673e0921226707e07c07f5afc9c2289925c96edfc0e7c49b26233ea305a935581930c9c79f74993fc3913029dabab6ba2261979d99f983eb5d1fb7ab4327b958919f26634a0ea97284262c4e3080ff7a485c137e835e5aa08606252376e4cd2f694116705b8ccad54310ee284df53209088233febb379f2ad5a76dfa02c007572136d898b337def4b6ab007320e6d5b9764230bcc43583860614a8b29b7eb8ad82f45a8e55eb2df896a02960c739c9378ff88bb65575db42e60325502efb05547adeb4616da8e26ed99787f9ad26d53e2994ccb93f5f4a6525993744648ec16cf1cc1a988ab94dc0fc971db4b07b1349ba7692089050f8ce63623595fb843f3aa38c783832b0a72c3e1d85dea3059918f709e6ccce0e16b6e111bdaa567aad88e074557f8f0e09fe6c2d0e9925f18d3e2513edad86dd6aefff503e7a67a675a44b8e5c681986c710ce1554c2f18cf3d8e6be3f8048a12138d642eed8f7e1afacd3bb6f5d745f49620201ed221728537748130a756ce2039b646dfc46d96b960d06a2f171c3d5ebc2771522c2866983cefdc3682edbc29bd390fc13995b3f4f39d57a80b70990acbf8de476886a8ec1e0a16da58516d3a061a69f572ada452327e066d498d7bbd35c198ec7feacf500d657eff3a49afaabe6db7db32633e55a363e686e66fdc93451b5e262a4d67eb190446ebd24caa5415b88ff5e3a89262564b92532a78c05977467f12598f3a42ac40102f5414441279d69d7556741aed75719bb3aa850f2c69bc01b23f94ece02e9ae10059413372acbd0435fcc29de2b749e04de7850abeeafb42f4827efc0cd1cb926f9d6af6e99a832d0f67014cf76bfd0c8c8eeb31253f514a84e3aed6fe85ea9c452c1c34da647afb113d8c0563ea7459b60a040b55f05768490a309dfd461257091e70fee9cdd3f6c97de3a434da5801e36ced373cbd235026bf0beb54526837305f02a90d0b5964d5da93bcbfcd8355850f2bb6a34a08287ae6b287963d218260b8c31ee6f961e06c91e65ce24b0b846f4b76fe99ad49b9482901702db0f85efc82a983f3204e4d845a8d81a4845cd4242ad9a4f7836467478c07eb505974dd11b1a9474eb193c8cf61c179f6bc174eb6aa87f9004d0e562eecbcedbae1672f28ee674eb74d00116567d96eefdd4ee9c2804efc53d7c72f55d2efe550741a1b0984e3d3a7e2f7bb3ccfca566a69a2e37ac5ac90e73e11866bcbdacd0a341b09ed538b7b79d532865d4d3da0129c73e861bbd3328550a927584163e1d91d7b4b4c895073248de2d277e0fe787a4e05915f1a3aeda1e4ef5cf5c8fc3cbb12b1ab0b929ddd32c170e2e4d1d8e04ddb67a0df7e6354e38a84131a1db3372c89864cbe0c0687d391f4a74be908cb003e0c328ae8da2e58d11373b4c681c80590d6303d7990483a21273620856ef656bcfe43fdbf74617950946f2f421a8bc8fb0bf8b766067b2487aacafe96bc92200da8950633651c4a130e15a07172e60f1f4d1c985292d146354a2176a9fd54cf5cc4768a8ddacc75a89179629c2de820c4e75ab8277f46c6f217875f9e2825d5521d549d9765d7348e05706e3a7d99e918e876e2513be38a00a6f70ddfdf9e75602594e2c6e094953c9e2be516cf838e372aae34dd385ae8608da02c39d4ba7897f9e5f6fde3280f241784fa20a66cc547a302afe5acf245e0d625000a6f7db2af96f8083a0378e6ba62fd255fc9a8efb90bd5b9c0ec4d71b098253debfcd02c6f8448e37e64a99614d70ed3ca8f6c7b2e08dc40e0e15a20bf994160ce331fe574903dcd7dadd2b577f78c2772be10278aed21e448362d091ea06741df99fd58685b3dbd37046084462416d53d9474033685e81c7b78f2ba6c75f85a3c1c1d7ddc2c531f135151945858c62b18e225d889e02753bd21705db99922fb6d9cb20e9065c3f0f253c16515854e10ea11038dcb60bdf8a251886fd6d2c1df2358971c9cbcc67a009be3907cd5b0a455ca4254b8bff346e4f50a68f1a118fafae4e9c03fbd21275d54615661754ed3ed85758ab1bfc59c57563b25109f859cf9ac20909cbf08a5c2d0a2a003ebfc70212f75bf98","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
