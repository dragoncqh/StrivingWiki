<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f4520b966675672a12e0f62c6d639dfae38b4a721ddd52aab6cb624eeee6e29980fbd74db630e2e77abe93490bea29755abea28c92925145659f2214f0522e5539106d05b2173847f9f8a74f1e889d18ab58e5e2d12a8eb99aa31629b292e155f4e93fe5833a8887af2e4d72d23328c658e13a93a67c013ad07cb6c04c35789a43f29535e7aac6a264c4df9052b29b9d916d2443674debb241a36c4dd28a018fc11ac6662a036d3bce0798d240dd078465c34a8504e237a6dc39f02c14272b4c8d8fe0cc447dc6a389b9fd6c08fdf5410e8e6c97727943d08e2ddc0992e01a87e7557e501b4f24491a9d9095bcc617035c9772dbc4e0de2cfbdfa13bc909d6aa8112eeed68144fee90fcaca9c344687e4502a22aecac0a67698d3f4ad10e215f8b0329be88b711f642a9e96edf05ae4fa6b6bb10c70a61f5cc4d6d087d0b65d6ba1ce0fb135be00604b4291187b6aef416300ddc7dde39dfb03d9a795e022b17e1cc9b445089e157946adc7b44457246ef6ded73871ecb08627cac8e205fcb9d5fc74c06fd9ce65c56540a664e31c51ee7ad8f2d10bd4eb67fb4c4ad9abf55210eb6460519fcc4e3f2d4d78f3e5fc19f1b69d75b38e84b7f3729a517fdfe385101b384e7d3b6aaefdc25e773a6ee3fd4f88b664496dfcaa164ff1ae90a9c754537efa7bfb2d66912305b6b5761aeb96f11e6476e2778655abb805a467793a0298b36e74600b73c1993131bceece8aaf371c2bc2b58e5b01678be120c81d861294a1141ce6a04fff3bd58a3138340a2866600c06740a937ea5deb5f0dd67b3db7c70b899319090c6c408d2859d71c90b6a03a27eabbef87f3d6bec1a8a7805057950715eba40c6d4fc1fae5e8afb71aa1c117a3e0d387387db75c3dc6f9e924572c76a1a6b9dffe9c6ee27c679d767a61dead006b2a7ee42e266322b29c7507f5de90f319abc9bf767cf5e75b4704c174273d66abf83f5a207ad05b07f70f2aae23e3046f4f15e496a7c8965b2fe5ba69625d3491c1b49e0628fbbbb1bf272200598a003b69ef71d54f0f898cc22b3cd3473e31d2b17c092978039a0160c351e8050a51e789bff8be85d00003cd694469992fae607d9045668e64747dd975573e0f491fa5b9fe3b09c7dafd2dd465fd04256e4d49405e3531ee792e3fad32f352b8e22e6df201192ae28f36d500d59ddd29c066f45434de17da3acf5f09dd26dde7439c3506bcd16e4ae356304d0ff203bde833fb301064c96965a7de033f1668c8c0673b952bfdb195c0eb4a58244aaeecbe2722eb5965d2044d2b9f493737451daf7e256aee44d8a7827dde5f623510e40cde7203d5fa8df725c595605cdce92704d96351c01324aea697b042dfdcdcf0fbd20052cdb9d4866975f5b773a7bbd343a9621e0e7992d80e7fc2019891a111254a63ade474939843ec0e7490ba9f93aaf96d2a3e8cce423eb1a4a6ccbe0a4b473d93a8fe2fea90ee73fc8193dc37a3ef17062d9dc31b47be1e0e62675922fc812c185ed1248bb8ad50ae6bd10e279b35087c8df5eb24ed27598f5c226bfc0e9c7b4107467e347ca630d7c718a0052b60032017547c4f1186f486721806c2d1128f6a85ecd743b135997aa9d6249c8e962c5a7f33a52dbc3ecba21f263381f835b7d05bb67b55a476dfcc7185b8ab81a0983574134c5ca42ead3281f30024ce2c26171fdf52bfdcff9aa3c747096906edc66efc65454a9711dddc388549a43e516d87a4cc917ce11c375e9b62f0ea3871b55629e2fa7c8fde17b52638cc626c64e45f0da1c3e3f80e0a021c90b9a3622dd0b80763be81f4f7e4dd47b819885baa55bbbd31259c662ad6e47713cc553873cfcf718e60b8d4bd5aa15bc069f083a0dcb405a5c7cda9bb249cd3dc3a65f75ee2139cc3e1dee91d2c4466d85ec5aa782b970efd2fa0c43c8fe69cfd155d97635ca79f684620551f0f4696713af43449560af7ef1302e032b71c4cbea0802abc060f88c0ec9689d6212bb3cecabd1b4479be11f6d3bd9fbdae27c1c96bc8702ba3c0e2cb9af7026dda07bfa3efb53628d6f8f4deec521f60ad624e1de74149179c6b1c8385fc78d753e8b4c5df98d5ce5b368fda913fc95c38760edffa106ef60ae29cca4e6df9d3f8e7518763ea8d67e1d008a348846796907e2e4246abcd9731690b8b9396f279776a6fb0fce929c6aeff77133340c45b6dd59fa53ffe5c1d393e55f52e7a43d3eb00b571afb70a03d55338b99a0be6e8ca103ecc092572ff5f9706a9bdd442c20e495b50a3fd187edae76ec83d217622dca1d96b44e7ee8c8f70bd7ef69d6934355bad42c47f343a5b8f82aabb3f1445f4e7ecba786b1a66299d45b69d7ecc360a330a7b796dffd4686d06a3a0e02c99cd65a6700d9a9713cb297893ad94d3961d516e24b0f46ca89ebeaece4cedaffc2c6825596c9ebe1a95501db46ea90ed30142770ea7074ce7943197f01928180d0b484bc4ee91579292a80498665aaea78bddac9106969429c513111ea7d1584f8b0b5167c2ed3654c158700cef8c983a0b37e93a158b6893950910b9e5dc83dea4c5005bd35bb088dec43369e176d8f0d1b580a378100eb02751a84bbb8fce9230de8dd4d6f3832d6eb8a5f590b07cee1c05fd55c708f41cd10b748ad3f8f6f5b03f21471fbc3e4c1d4b162b9eec50e73c1537ca3491a4b231e1335a7b8061cd1e58b7729ec61b692603b8edf47425873991cbc4b6158e683c19c83fbe6eb17532dfc78462d847367a7cc06ee36b5bf779c3b6023f2e3e08b1e1b54b0d617b633480c43f43e62f42f7d6947d92c853888734d912348ada34aa9cf524949d18813d1bff31fb461b4ae4ad9074ca116373a89bb4083b364e8aafa2bfebac5f308ddff3449db3c7eec4f6950678a637bad60904c991f93e81eea5f389d6bab50df598dc8cdada9ed8106abc24056054cb9cce96cf4230699c3de2bae567d2d1b328cd17eb80a7e696c2982a598d33863e396ee7198c50f1974f7b6abb24b4e403e30799f5f0c3cecafb8486b9db624cc3afdd0f838efd1222283187ed5e710c13bb8c541e43802da79aa1352a168de2c55ce5bbe170f5f6c8af852cf12c4e99b19455657b21e4b9c7afe25b549d4f046d63df36eeff58094176fb2ae7fe12342bdbed558bb7ec74139288722e82938e5102c7539750d83dfc3b419bb6f9007a5ee1ecbcfdd7fae9e9305c1a8ffca6accf917c0a2a347cf36e40cfb125e3389387aa52ce47f88f5958f4d4e55c420d7df80d51734e45c17273f97c5784b7e711385122b20da672c37ab1747122b89e2d6a29ee770a5012aebc16400c83525e5e13eefd598b34dc28e7292b27b6c345afa7824d66c32aa81d339527ca4812c735ac588f1b93c49dedd97aa5b84c30ad3b507568f89e566fab950506fbfcfa0e8ab9ba682c034213abf6f8453791bb1a5071f22b5f9b152238e009734f4716f890d5d0efc83a70fc7f36ab8ca4f0ed6f44c078b57c398582ae514888f90658647fe9ef284b353d04af42a16c65fa6f9cd58336a8dc83774fe9b0137532c63eadb92a97dfe2bdce91f873467b5b8a01f0bad21158a8740b66ce109b1321d9c0b7c7b935a61df20563a53762bbeaefb873a5c29aec431dd2b15d55b653079da85158bff3cafb83d7669c86274b88dfb47bfbb032d7b758e8eafc10d3843fdc2d498c9fcb7d9df16d566d2353556c1b21d4edf56791acc69ff7db5cc1bc62067f09d4f202b326edac949764263c5bc08339c6d329db77338bb2b0f3e0903e976c8a59df40657e9055fd1ee0555a293fb0085fbce5632a65f1d898ba04c035d2a8fde27b11198b25fd1289aa536236ebb4b028614012269b2c4c57850c7dbc6220e3a5e091f62ed2fd6206a5bf9c72a6db1c9c5bbaa970d72ac1147d2cbedcbac31d8eb9913d4ec41fa585b12c9f3652e23665b763a4e929a94dc97141c4388af4653a31854ca78cd704bf8f9171bf2d189b54068ebb3d683bcedc226e974e456255c7100d25499935dcaf7665eb6cadf92e66f9f8ade322a74004caba6aa21dab0cf91632fea03c2c3d42002d0e73780786ca0a0423792f040247f3321ed734cbd5fbdbd807ba1761a2bfad99532b4403fcc703f67c0eac7ed0b21d87a1ee0baca11748f25e9b3e0749238b25940cb5e2b0d54ef27e77f19bb2c6b13bcf5e3ba08ccdd10785e8673321c124da698944b85bf300e4588744f4badbf700e19531e35c303d39713b310d268da0113ed72632653d0b8f8ce806598e3f4346c65a42a7756f1ac87ff49cebe44f945b194e2bcf6c99219d871c4c2726d50842a519a620f1d9e64de486a5235091712215da56afc9580436d35c8c9b5819b3aac9cf596810b9b7e52b2027dbc51f8b1ce214e5d5b92b334e56ff886b0274d2c7f83cfca9dc7672ea02b4b50647add426470ea16a9fb954a3a3ca83d1088944d0cf24dbd323a8cb2af8bd11eafcf492f70d3cc3a5b4dc61209ce0ac8ca5672addaca75b52b2233bb1686b705d0a7a7d0ae70ea5e80de58e9f527e9d50d7e7c0e121e0a1b23639851b4a7f6063360bad2db5c873e9ebf7d1594fc806a0b0ea1e5987faf3141235b51734ebdd0e7eb0fc7721e00a9fe388af434d2588de84b29d733a1455969456c0d9559cc84799876cd92bcb1dc9d7f3caeef90979e8628688ad316838ea9817953ac2907f3c26fdf193a19e7bcdaa9657a476a325a04664413464048f75c69707ba859a96cd773f0bae1a56d85530f071fc01ed05c02b5e3ebf116318e9a33481f417cdcd5864e6ac8f6f30ebd426d519030b75c12966f096ae87e8236f43cac135a2ea23d924d075aa704a4519d2cc29463a4770f09c0b41ab4dfcafda288918f72c9aebf2f6ad126b6e0fe9930ceed398bfba3c598683a62bc5393ad4385ba7995dcfdecaff334ab3665d629b6b76b45c51e11e8bdab8a8b33ad8e25b409e6e230c77f4ecc85556d367233707f533a838b81a57b2cb881f61345c50782eff2cbb9de6442951680cc7bea3946cea45aa80496a96b3904be62ccd2c4aecbc51da6eefb97f1aa8963c2c9a52ddd3dca11db66ed3a5a0f8d9165f95678b1d4dcdc1afa7372a2e7ff2a376e0afb8d0dec410a6ed8e765352e648ae5a26c59a02db84bcf796a4ee34b2954d7d1676364f4a2c130c38e19a7a43855dd8a03525f1f37f6e21134ebd731a3051c423176c0db011ab1ed078232e27282145c48c66536c12f14280d0d660bf4d0c3271fd55945745480c32373320ba2490ec9024fa929e4f1bf52efe4e384a4782b12c0f2ebf3960fcd14c940f85aa7106683b4ba0506145a070af273c3570bcb546bdabbe3135421d3a3b684c3d782390951345ea0edfe33b41eaf47ccf113ba98f3456480846cdc91a2e5df618f79216b394029835dc64a44bf51435aea2a3aa97e4b5c3343e57e138a148325907095701e351d7c015695228bb8a0ae2b23fd77a6872ca853aa385a4b63db0e4f8bb6bbe5ce36fc645f781e28c8651929581f07f2c1ce5467a26938344a703561ee27dc1a46d4ca2cbcd7b07fd37ccb69a4971f5cebe094ff4d1337c21124f0a2b3af321412b7c10e4e8462b7d459b6a32da0f3b426b5c4b6ebdaa6d8b5393b450046c88fffdbc7984dc5fd2ea6ed23bad3f450de8dc766d9a194ad254d39c024550a819d3105e544b680f4d6d6b8d0a2e975c68cab9b0f600b933492dca9b3df51b9a9fa48664f69a2dd786663af656e0ba252b7dc2e45a33a45ea2addd0d4e2ee687941c1af896d4f009ac1626781651ff43dad0b685e600c1de7797bf7d710fe45ced4ae7222ae77cce78b7b5f14b01528c186156475ec20dd6b67288e6222d3dc59926f9f8f661190bcb732a3df12e734302c413dafd909c5d940a14680cb5f22e4add33427840d2c5d7efc90357c2092243a464a95b4ebae20cc799c0b4bfd38ccf1806766ca860438b7318f43c237846191a04a20ccb34c6546da4aa6204a76db0ebf5cdb63da6ecef37615e80f0407fdbc5d66f268e2cfcee17401b483cb7bff1255874f4ea3d8649f21f231dfdd24f5f9f31d7c2eacef850879628dc90efb7ef8e7947f6b5bf26607957eac70d731bddf815a0f3a1c85efc58132c747ac640e59f677ad5e123d1b6680393aaedab9f6cbc8d7b5f3beac46ffc81fef593f9ee1b20110eaaca0a07a8d9e22221528b70592a1a5d06cfa4c8590d5aa4b3edca44220cfba91d01b7b256e920f68b294aaed7c2667b0e7417137e49d36ab8a05e256bebdf7bd1a3f3b5fe17afedd87d1b4a023157283de112de922682ee9b2bb6814c6ef53045f9639a638a49a7274a2fe6b0fa29a0514a06add271613777d35a0eb7b0611ba1162f51f47333ae9db982b01e0092a1af82d8e495f54596e71bc0e591463be98e40dff0d00ab3f80ffdb89f1b01980a48b0cc8c8856717caa11e8f56451355f6a88e1012613e8aef2b30271bf9c05e1b63818b06df639bc9f05e330f1c31f37f136f8d81993547681fed3349faee6124d0f2dbbf32f6946de4d6fa6f6e0d74edd3ba845845541d7841effe0c12d84a3467b875500c425cbae820948e24852133edbc240af3b65bab7be365bafd76a681e01e1151904c4a4fa098783019052ffd30112e36ec0d5b160d68aef7ae042f1d334bfd21392a07a9eae5b99d5b53578ded35b11ab7a4bd85ac00deda84e3aa2bc922f131f9b26e741989ad885f24582e4c99d863ce2fc802d6ea419b359f7e140eada41d44a142f38b9e3d8adfa487f8d8b2c2dd4edb1de5a8d4ce1bccb365b47dbea62aba69d1400b13a2dd000b40ddc2bfa61784ad200838b1c1435a10b798fb38be952a2560e7fb5fcc74712364b5a6155edbf49a832e8cc3c7a057eace3b252105f04d2f615a528b90bbb23ad8f556961084a518977183133a8e58c5059c4d375946d8e8de8595cf613e6773bf92d52550a2cd13f7f752b6cd026c3ac858ec969ab6310166efe9edc06b8d14cf051c84812eadc06d2f2df362ac634742176077ca5180045ce009ec7195235445f5b293005ef2b098065fac100ebd0aefde3b3620a1e75f2e301d531f2314a9cac556e6188be902b0282630df6e05b846e0fec50b037f1cb569b83648090e6a0d1d04ff1185583d254d4cb96aed6a8e38300b1d1d773a68fc930faa91277c64dc1e4814fcfaf9f18e99f9bdfc61b6d1453d6b0d0af86d9e2bf78dd7a8ca58423c6a1dbc4d808b4d3267f00b7dc6eeaf6abd481c53281d8788adeb74439cb7e4c8a848d82224a2bba8641d784e6008d16c447cc4c7535acf74f0437dcd5461bccc18ff68ba7c734945af614c6b4479aca9a0da7cac69b38c0ab1be413ffb0541b24e657cc63b51b3c75d9b49831103ecac9db5827a81e6e0571d36f6c4ffc5d9f78ef2ab91d5e5e241af513504f22c278bc231f9d55fe425922243d38c09710f01f327510c87a656226f3cb43c8ef8ffa1efe4dd893bafe0376586112a735a05e39a0dc17c6a910ad71168bad8f30168e4bfa2e7b0a33d00ebf750e4ef4147daedcf73df6311a077d9e0b3fe2504c3a98b0d3ea7362f283e163200965c34842ffec7a5db2292035652640857594a84e399fd8d57674eb8ccd0dc48c507200c64f32d745fab52d37466e7548f4e7a2e4b9df30cd75c3a25499c55a41c0ba8dde006ec68727e156a7734727f2111c9a971c187af465b5160aef7b50a0c13de4548c9271d5ca5ebc847f68caf65c5728d461f2ce0faf0b1471229c59027abbb206c7eb26144640a9ae3f23d7efdc066636395b5292fe379be22e9151e8bab112bced01c72627e370c266541bbadfe72d24eeb7ce9f4074ac5c645b183863c86429e6e376031aa73dbc75b11f8cf99eede111ab149aefa98fa8d00691582c679bffd03973ba3e3258c8e11e6e77eef8e0a8c57722c33a7080fd23a1cf10999f2b7669870837add2809e7560a7e770b8321ecabcf8b8338a343ce559661e36fcc646b183ec90bf2452f8d4b3f9b73d1b5f04e9c68266875732ee0e4202ac7c50eb8d789cc4c7c3a3d099576f5a4f7146b92fa82b7373c1c289f5603e98673ebefa8e75c91cab7f19cdd480bcb41bbfc8a9cba30e5ef69fd4d3bfd9bd80f2ab2848fcc30fd7283e09ec61667dcb5d7f26b118b555d27fd54c0548ee9a57e714b63062ab6c3cae97d983ab6dcad2d094336b58f9205f1353ac05422d81be1adf0134477fef441615af369419793603849c780e744e3dcf3f926cfa7421dc7f28e8d70bdaa8c44725b44714f009a544f2e681951dd148d0d12810e0a5b9df6a9b19284c8d0c8d283401be1fd0a118a24a68bf543c9e87ad96691d9c28bb1ac30ee8ee4f2fef90745b53b767173ce1a0a6346feb1ba2a408804a5f1fe7cacc947ca9f57f7d06797c3d4d49a665d2e6ddeae6976089c80397fea3e9484190d655b1307280e320bfbcaeea41fed0446224cb5023df958faabae19affd1e299e4ea5d8344efe98737858c9a5abd71c9a5ebff2f889975bb85d8270a47fb1915de98e6c19f8f157b9bb3486d3d4b5beb3c89069eadddbd166779540921c60978bbfd09b04620f98ca89c48ad275c93188773e58b4bdf826c052bcd6b28509bb33f1235767ec7698508e7943d83309ae104a005279ef8a307e495795ef58c52953b48974f1380eb7c7cd761bb733157c934370745f88520461343e5328ba7012b39fe6db0242f9c868f21d411e072058e86ba6ae6140e16da97ae555a7f18a3add3c67168fb62a58839fd3f79b111877edadb460d425eacab3c9a333cfbe4e6a991a8ce88a48512628ed60f6ceff26fb394488edb7bef361520b9a4b6b0fce3ea50202b55b6512f481039817aa0ab7ee3d146f89757207cc20e96c7dfede24c9c27d5571410142fe88a59093c03e9d9159e74198a8f70e9e46fee2cf663dfa76a1dcd00b22440adf01bd1dfd0a8b3a3800b673125d8761ace6c69c2ac9d3d0115bfc896d7af34740e2618e8274e9424f36d2414784f19ccdda3db3b69935113d57d3a85bc768bb1dfca2e53bdbe6be3ec06a1918daaa9eb2b74f0e47724688c7495ee8c4883f6b36766eef5317848ca1c08db7fcfea293214b8a8dfa15deabc1204ed3e5768c166f5ee5db6d94c02bfe6c4a31786b5f56afd2ced78899518312bdd0d6ad4b764cb0e72945c010b10d74b9662a086071fec389a100fcb5e3e76f4dcaaca4d39daaa20a7b38d606a92db696b0a18a8e2bd3ed1860c478381c8e4496619b3a6b2b50d7ef6433f55acc87a777a3360c0a3399c45961fb75390020550ded3b64055a47a2876e6e1c0fab28c9b49aa9fed30fe84e14efd15990e7cad19602b785925c44c5ff9ed90a6bbeba013503ebfdd783065ed746625172230a2edfc2f32f515de54bb31158cdea2d9440f3222653e263c6ea1576ad58cf687a80a9ee4dd0474e925167e986e44e8e3b1e010d7e09c0aa27943b0758dbeaf0fcc36194d34100a2637497c8cc0cf99d662c561f648679637b997785f78a4250c2c51a0d36447bf8a7da869a9eebf2e656f7d213abc612991ac93f058468adae45ed57d271ffdaf1bc8d47bcf270107a2874513277c31ac14a0605fdb3b7509460ad37d434b83272edf8bac7f433a2698462a30f9ee64850c7fb89dab0fd8fbf427a1cae362940a99d39fd28fc1f7428883e2184c04b8bfcf9e4abfd78cd2dccd466d3e33af6d44c01d3bb5693e81c279d4aa6c0bff3ad4608f49c48b90a8ad3c80f4c7c88c97709af711809d12c897d46f6933e17dbf86e4444b2644193d136073a065c5a0336e9a7a9d23a5630a03d04c728566aaad1ae6194fdbe30aa4236083629827356b8b07661ee0e6c2276f20ab8b38b5f46d4725d0adaa549e350bdb6292413ae1ba8eb420dd1f950427e69a55de9bcf7b8a598ea31698a3d4ec00579975b3dd5ee1b28af421ed1e6094bf49edca34062eb4726af7b2364b05031300228d46e00906ca2eb40ff4700b6aabdb993d8a75620a8d7a73b2873be2262557ad3958aa2c945f2c676b66bd291cbcb1848fc570d2f8875883e7b6b38dbd617cba005ff308a2b73eb0aa172f7eefb786fbb0f1de8b7ba782f7b155b47d101c97ae06be42aa40b1d1b0ce2fa1564968b73a507a94234b72408f2275e6242c885c31aa344a30de9c102e4999e06528aab21103dd52021621b9a47a8421e92b2acf0a041668552e0ba3c87ed0e353a3baaafd104366e5c0f5f980a3d2c687715f4a3c38a173060678ee99b34add824cae2eb957257f25d2604d8fc86a62415b8d89ed19609fe9d3322e42665456516870886475278a3e24355e1b17eaff24fbecdadf9222877e4d64a274183dd8d1629a504e8fb8044a9e454768dfed84aea3bd905c6b0ae05a8cd1fd154bcc44778478d2d621c7497778a074e83d1df446e5e4d4a8a19f2decde4c9660efc4c9b4f6891939f6be8c732078366020b98d353132c21b440b76cada1293e34b684b8dbbacc5231d5f80cca433801aadcba0a43facd5db0c035bc8b6658973cc346048c6fdf3567d6e7563d501a6bc9866cd5d558d0c6e91f860259224cadcde877b7fd80e8ed5b4fca0894948d1fc4d9e405abd6fdf1914b6a1147939ad321a720a5c98de25d3dd9911ace9ca668f02a6602198f41d9ee080acafc1fbde3382cd05785c9c08d3da489384b15cd3c99a7c86053d2a7e28fc0da749c2dd088bd7e19566da99ae12d2a7036b8b6b3faa3e04437ebdecfba077e7fff29070d10582e2c2e37e60e403f2f8b931da779a3ca1d03f2d50da35e5700b6c61885b1cb7fc0461f0f3b457c1b0f24ac8d44341b36ecc2b28a293784f940b363fa066c79f9fc82c879552873ecc4752f65dfde8b25ffeee99fe64a642436a2d53f28c66df78a5137f20ec63a1072c994b482bd8f7b390d3f4ff39ba78c4a7d0be14823a4f6aa4270691c763135296654934397e4dec6706d7792f2c2cb022e3c730dc65cacaf9a2a030fe0a7b625513acb84b12598e1c02e3235d55a6a4a4daeb1b29046b79a0ff9e6efc464c399741fe303ef95a84ffad556b7ba69c4cdbda1fb33a2e245ddbfc288d98e45a2a2121290b01ca43241de04f8ed98c4134fb6a20b1039a906044d25d4d329acfc8de8f38582ed7180b7930ab646668ded2ba93d0a38f5ee25172e50a246c8f74bc82749e219107728247f9ec4eeb433a8dadc5d0e4e859291635d25f17df7802494792aa258e7523d8331c2e688df3e342cc1d5758415444de85ce319726f428b6fc686aa74ce69d54545ec52da607cde74cdec7fff5431d749fca89b1e4dccb4ea3366ca9dbf457e08acae45f96bd7efdb8b74ca0f0d87837e866d7d6d7fd720e65f2828f8f222fe0fa83812ead87f8646a471255fac8af46eeaec4469db1fe0227b61da2ba9af678b7d279c4772ff55d4eca169ac3343795663b6bdcc935c8699ede54573013aee7e9efd1e674efb540fa925d34eb07ef66e4fd5793613e08a195a6a19a7b802b2df6e2a2b7b6772c4f108441be2e0b9088ff122fbd9a138cfd00c01c6354f27dff4c1ec3615715afe61c3d7bc2d08f4aee4829ade76f7a9f6832f60f32db44224d166001c70213369f39041719be052368aeb72f1e09ccebd4774c0b26f740505beaec4a5e902fa228036b8e99326f6955ed36448e5b08c4a380d59eb837c6f354265abb204707f23cbbf7e577bba0f8eca697ebc09ff1f6930f3710d784ea77467860631e7bc73c33145c3224327aaab7c432789dea0ad03c1b51c42c19d82708f8bd792d7bb957f72dcdce9b5a527e044b47b4ab481e2c4f066e0da590278c5e7257e82ed8552db2a46cac1c53cb41f9a53fffc8c5294c1c08b38d8d6356595d5f352a18d2449c326e1f565ca973d84c53114103f5cbfb0489ff8a2e7160f876d0e33533d81f447c4b59fb5a97534bbf64cf48c892cb0104467937e199bb4668471a507dbf8d0034ee5f83ad08ac6941cc15008ccc17e0db12acf25f63209602152303f85048b0871424b2fee3f66c7197e790d687916d2cbda912f3897683e9e8496fd026af5b364da906d8cd898bedfd2723486d811f6e8c328c19f68ec904606d4770052353382a95ea046c66a810ade1e7c727c585f1249c77a60dee94626faf35811767e9f0961e3e38545be091f54bd3fcaa6eae980d2bca51b3775d370bbbfeb42f320eef623bcc8b8672a2e539878e3280deff71b33f6232a32db5274971b745e291a2be77ffc6810779963f60cdb93722875b8f9210937394a8e42caad2631661ecf21c9fbd0279d17d46884393bf1b9a729497dc8f7441516d9ca5f20aa5b4b3d26efe1ef336a4c60dc9790de7368bd1e1985443a3c914cc334c1d64fbc145a21eac3c67e014f7451b94e1b331d7bfa0e2e49786a4ce4a02a9c12292010210bad7ef4a2a54227695cbf2869879163ab3863ad4882663412d90a9f32c881efdf62031d1cf333648b03417d03c6ed26b8d0399d09705b9579a3e061ab86fe7051c380d7f152dcd2d80e027e631a066af93ade9529d14a2e07453e61fb56ebef008610296c0bc182c4cde067634b0dac02adc9c88935c72898b947dbb2e13216e1945a286921a3f6c5a51a98b8b3cf62ae8f914125236373b9d724e3ab7b1a69d6c507756fd15915121740caba9e8b566488311c3d57b9de5e6083454d073c93cb790d80d8c477abb97c510fd25c4d70b457a80ec64d3369d605725137751074c87db0c1bda46be86328cb7aac11e0e7429ccf11e09f266f7b6916e643df84d65f27761eb4bff4b341b40ef0556d4c9cd6915095017b6a2d9ff235da11bb3b41b8ff812833625f55c5fdaf8bcb9b5784b306ecaa5be1257a55a28d216300285e5b2204c6f33c1f5009470c30a0d6b21057ecf87db04d36a61a696fc8e5b5958f31574da4655d38eb9165b13c3255025f16cda383dba439455d4df31faa61980952d86d11367419955123039274c2c03ca2783028ff2319475853b8232d6b23ee634db97008929a38e96235f310f07f376e9560e08eeb620b8b42058f70967d79188b893dad19816c084f97a612c9717e59750a82bf55a36fba6c3a8be1708999a9541cf5d84e7f428a009753b290c1d144fb9e35adfbd8d9c4ccbfb44b9e9d2f606a13f8daeeb15eb095f069914cea0fb5542054d592168e03bc90ab1f45adfd31f8b3c224bf00e48396b9d2e0aa0010097437e42e677941773808c7d4a4de651ef9b6fb7eaecc256e86be130f11fc384726b8066a095156d1047e8b3bd8692deea4bc07415e496f7ba4fec71917a09af077094727cbdbb3e0460d280840d444557376082c25c4213697af3d884bbadaf3daa5088916d0c1190757c54d1647a98744dfca0c75719d8b6f56d0e8e7b04a43906fa77f55d9cae96bae4c622782f74a3a27fada3dfb872e13dd4057ca739a37ae58f1ef9324c59e9ead21335d9a9fe682256842bca0c2ea6f8ed7fd133dbd4d18248feb155095fbec7cd2f14dd2b526e18e8b10036444ddfbf770156fc5afe51b49b3cddca25ba6207d92004b13c951a3fc7bab732f9f0415c5964ac10aab6c42c06eb21ff69e06d5383b710b1588952dcb49769b1b0a20ec05118e89d56f6c4d17c91fec79041e523bc7c753a43a3e216d159dc77e4fb3eb90406cc7c789370eaf435b38bb60d5152327b49ea5ad566110bd815e9caf59b30bfd27f81ab7da19a980ee4e424aed6dc00383486a15864635dae2ebaa066e881b0eab09cc85b70d693c0809832080bf0e53c9a97c9a812bea095173a3c49ada39f11b63ea9228c92df65939f96d614be5523ca8bb17d49a050f02914c7efd9407c990241447ab8032686066378410d87239817155254aec26d4c0aba7f8332aa0a25e8e0b0c3b4445c8d7d1b4e7a881571f7170df2d69017e1dd2509d13e30f6f2f687835ce107eacf7c6245daa56396cd08e2b4d26a8f2ab1ccaa886a174b3c223039ed092b109ae16328321ef5fc093a75c69f958350826c85d3c3b9a5bcb9506c88aa977c558dbd462e86c1f10c874dd9d7f2247f8a766c50b53a1220a2772393d0c5e63476a25f3ff6c8ecff04cdf9e6cf2567e8944f715dcb90a55d8f9a235f2fa9af4bd13410c8f7d0ad7032a31bcd983e76f7ee907bde517019b21924fe4699db4736bd79a28150009f21fa5d52c8201600757fb4fb3f09ed6ebc871a2b631162dd0d47fb35249a1b37b57d3adbe9fa8c4980961f31f88de6b7cec0003172e9d96ee02db044c75b0c489bba7ebdffa3fe5d6a62c4c26cbb9a2823fe36f6a7c48eae4f6fb68d6ae765c2b792d73f306486128192af432cdd7fa9eba9c9eecb88f2178a867a3176009a4193a45db1c88cfa3561f65999492aff66b942b9134b005d5f5027b865bc769281cea76ae290a9949403100e779d0b2d65a7c438eb07150aecfa3416ec9565b7bf3a30a76bc056ac4d32fb7fba2612be71fbd1bfbf9e25b6970bcff9734894936a0ea1ba65716f81ee7192a8d6ae22b354e03a37c5c84576da52a6dec10f6a05f54b66e17e57cd17b52a5b346321b2384269e5c23677098a149dda2bea36ac143ebc44526583bdeadd649fb91cb64caa2a87acf694e6595de69aa095507417dcf763f1d0c36cf710d82fdfade0c2963c5405cc64e2342c06969206fee089805b83e1fa326baa75aa224e138db91a732ea856d8640d87147fea601028ad54abfec14f14716a4dc84fff34af8af5f9e8885490e2841124dc4dc582cfcdc64d2cf7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
