<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="zh-cn"><head><meta charset="UTF-8"><meta name="copyright" content="(C) 版权 2024"><meta name="generator" content="DITA-OT"><meta name="description" content="Symfony是可复用的,是组件化的。"><title>Symfony架构分析</title><link rel="stylesheet" type="text/css" href="../../commonltr.css">
<link rel="stylesheet" type="text/css" href="../../common-extended.css"></head><body id="Symfony架构分析-D9A90DA1"><main role="main"><article role="article" aria-labelledby="ariaid-title1">
<h1 class="title topictitle1" id="ariaid-title1">Symfony架构分析</h1>


<div class="body conbody"><p class="shortdesc">Symfony是可复用的,是组件化的。</p>
<section class="section"><h2 class="title sectiontitle">Symfony MVC分层架构图</h2><img class="image" src="../../_images/2020/route.jpeg" alt=""><p class="p">M：Model 模型，负责数据库操作。</p><p class="p">V：View 视图，负责调用Model调取数据，再调用模板，展示出最终效果。</p><p class="p">C：Controller 控制器，程序的入口，决定改调用哪个View，并告诉View该做什么。</p><p class="p">如此说来，程序的执行顺序是C-V-M
或 C-M ，和MVC的名字正好相反。</p></section>
<section class="section"><h2 class="title sectiontitle">Request-Response模型</h2><p class="p"></p><p class="p">Request-Response模型</p><p class="p">从本质上来说，HTTP协议实际上描述了一个Request-Response模型。与之相关的PHP代码实际上都在做着解释请求、生成响应的工作，Symfony则更进一步的将Request和Response对象化了。</p><p class="p">Request-Response模型是整个Symfony的基础模型，可以毫不夸张的说，整个Symfony都构筑在这个基础模型之上(参见Front
Controller部分)。</p></section>
<section class="section"><h2 class="title sectiontitle">Request对象 </h2>Request类很简单，封装了原生PHP的各大超全局输入变量:
 <pre class="pre codeblock"><code>use Symfony\Component\HttpFoundation\Request


$request = Request::createFromGlobals();

$request-&gt;getPathInfo();    //the URI being requested (e.g. /about) minus any query parameters
$request-&gt;query-&gt;get('foo');    //$_GET 
$request-&gt;request-&gt;get('bar', 'default value if bar does not exist');    /$_POST
$request-&gt;server-&gt;get('HTTP_HOST');    //$_SERVER
$request-&gt;files-&gt;get('foo');     //retrieves an instance of UploadedFile identified by foo
$request-&gt;cookies-&gt;get('PHPSESSID');   //$_COOKIE 
$request-&gt;headers-&gt;get('host');
$request-&gt;headers-&gt;get('content_type');
$request-&gt;getMethod();    //GET, POST, PUT, DELETE, HEAD
$request-&gt;getLanguages(); // an array of languages the client acceptsxxxxxxxxxxx`z`</code></pre></section>
<section class="section"><h2 class="title sectiontitle">Response对象</h2><p class="p">Response类也非常简单，用来代替原生PHP的echo(),header():</p><pre class="pre codeblock"><code>Symfony\Component\HttpFoundation\Response

$response = new Response();

$response-&gt;setContent('&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello world!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;');
$response-&gt;setStatusCode(Response::HTTP_OK);
$response-&gt;headers-&gt;set('Content-Type', 'text/html');
// prints the HTTP headers followed by the content

$response-&gt;send();</code></pre></section>
<section class="section"><h2 class="title sectiontitle">Front Controller</h2><p class="p">一般情况下，代码会以各个独立的模块分层存在。为了根据请求的不同调用合适的功能代码，一些如CodeIgniter的框架都有一个统一入口文件(index.php)负责这项工作。
在Symfony等一些框架(其他如PHPWind9.x以后的版本)中，单独抽象出了Front Controller的概念。和CodeIgniter中的index.php一样，如上图Symfony分层架构图所示,FrontController是一个统一入口，一切发到我们Application的请求都会由其处理，然后根据接收到的Request不同，按照配置的Route规则加载对应的Controller的Action。
处理请求之后，生成响应对象并send()到客户端。</p><p class="p">根据环境的不同，Symfony自带有两个Front Controller：</p><ul class="ul">
<li class="li"><p class="p">web/app.php&nbsp;#生产环境</p></li>
<li class="li"><p class="p">web/app_dev.php&nbsp;#开发环境</p></li>
</ul><p class="p">之所以没有测试环境对应的前端控制器，是因为测试环境可以通常只在单元测试时使用。</p><p class="p">当然console工具也提供了能在任意环境下运行的Front
Controller。</p><p class="p">Symfony中的Front Controller非常简单，遵循的逻辑可以概括为”处理请求，发送响应“,这也是整个Symfony框架对Request-Response模型的实现：</p><pre class="pre codeblock"><code>// web/app.php

require_once __DIR__.'/../app/bootstrap.php';
require_once __DIR__.'/../app/AppKernel.php';
use Symfony\Component\HttpFoundation\Request;

//初始化一个prod环境、非debug模式运行的AppKernel
$kernel = new AppKernel('prod', false);

$kernel-&gt;handle(Request::createFromGlobals())    //处理请求
        -&gt;send();    //发送响应</code></pre><p class="p">至此，针对Request-Response模型的处理流程已经总体规划完毕了。</p><p class="p">对于一个Symfony项目myproj,为了方便起见，假设整个文件夹都位于/var/www/下,当我们在浏览器中访问：</p><p class="p">localhost/myproj/web/some_route</p><p class="p">实际上是在调用Front Controller来执行与some_route对应的代码。事实上，上面这个URL在默认情况下等效于：</p><p class="p">localhost/myproj/web/app.php/some_route</p><p class="p">当然，在开发模式下，可以访问：</p><p class="p">localhost/myproj/web/app_dev.php/some_route</p><p class="p">激活debug工具并能自动重建缓存。</p><p class="p">正是由于Front Controller已经实现了Request-Response这样的基本流程，在Symfony中为一个基本组件（Bundle）添加页面只需要要遵循两步：</p><ol class="ol">
<li class="li"><p class="p">创建Controller #定义如何根据Response(Request?)生成Response对象</p></li>
<li class="li"><p class="p">配置Route #配置URL和Controller的映射关系</p></li>
</ol><p class="p">当然，为了避免组织混乱、保持结构清晰，实际中，Route、Controller等等都是以Bundle来设计的。</p></section>
<section class="section"><h2 class="title sectiontitle">Bundle</h2><p class="p">Bundle从PHP的角度而言，可以视作一个命名空间。一旦一个PHP命名空间添加了Bundle
Class，就成为Bundle。这个Bundle Class的命名必须遵循以下规则：</p><ul class="ul">
<li class="li"><p class="p">只使用字母和下划线</p></li>
<li class="li"><p class="p">使用CamelCased命名风格</p></li>
<li class="li"><p class="p">使用descriptive和short的名字</p></li>
<li class="li"><p class="p">以vender名为prefix</p></li>
<li class="li"><p class="p">以”Bundle”为suffix</p></li>
</ul><p class="p">Bundle Class的getClass()方法返回这个类名。</p><p class="p">Bundle是Symfony的基本组件。Bundle存放了与某个特性相关的一切文件(比如PHP类、配置、甚至是css文件和JavaScript文件)的目录。
事实上，Symfony的Bundle和PHPCMS里的module作用相当，类似于模块、插件。但是相较于PHPCMS之类其他的框架，Symfony的Bundle具有更好的抽象和实现。</p><p class="p">一个Bundle，通常位于src/VenderOfBundle/BundleName之下,其中的目录结构多为：</p><pre class="pre codeblock"><code>Vender/
    YourBundle/
        VenderYourBundle.php
        Controller/               #控制器
            Spec1Controller.php
            Spec2Controller.php
        DependencyInjection/      #DI
        Resources/
            config/
            views/
        Tests/                    #测试
</code></pre><p class="p">想要添加一个Bundle，应该先创建以上目录，然后修改app/Kernel.php文件，为registerBundles()方法添加一个该Bundle的实例：</p><pre class="pre codeblock"><code>// app/AppKernel.php

public function registerBundles(){

    $bundles=array(
        //...
        new Vender\YourBundle\VenderYourBundle();
    );

    //...

    return $bundles;
}</code></pre><p class="p">以上两步可以归纳为：</p><ol class="ol">
<li class="li"><p class="p">创建Bundle</p></li>
<li class="li"><p class="p">注册Bundle</p></li>
</ol><p class="p">当然，添加Bundle的这些步骤可以用一个命令代替：</p><code class="ph codeph">php app/console generate:bundle
--namespace=Vender/YourBundle --format=yml </code></section>
<section class="section"><h2 class="title sectiontitle">Route</h2><p class="p">Route是指从Request（如URL路径,HTTP Method)到控制器(具体到Action)的映射。所以，
一条路由规则有两个要素组成：</p><ol class="ol">
<li class="li"><p class="p">URL Path</p></li>
<li class="li"><p class="p">与URL Path匹配的Controller</p></li>
</ol><p class="p">我们还可以为这条路由规则起一个独一无二的名字，这样我们就能用于生成URL了。</p><p class="p">路由层的作用就是把输入进来的URL转换为要执行的Controller。</p><p class="p">Symfony会从一个单独的路由配置文件中加载所有的路由规则。这个路由配置文件通常是</p><p class="p">app/config/routing.yml</p><p class="p">,当然，Symfony支持高度定制，我们可以把默认的路由文件配置成其他任意其他文件(包括XML和PHP文件)。如：</p><pre class="pre codeblock"><code># app/config/config.yml
framework
    # ....
    router: { resource: "%kernel.root_dir%/config/routing.yml"}
</code></pre><p class="p">当然，从URL到控制器动作，参数匹配是必不可少的。Symfony的路由系统支持:</p><ul class="ul">
<li class="li"><p class="p">URL匹配 #通过@Route()设置</p><ul class="ul">
<li class="li"><p class="p">必选参数 #通过占位符来设置</p></li>
<li class="li"><p class="p">可选参数 #通过占位符和设置defaults来设置</p></li>
<li class="li"><p class="p">正则匹配 #通过requirements设置</p></li>
</ul></li>
<li class="li"><p class="p">HTTP Method匹配 #通过@Method()</p></li>
</ul><pre class="pre codeblock"><code>/**
 *@Route("/blog/{page}",defaults={"page": 1},requirements={
 *    "page": "\d+"
 *})
 *@Method("GET")
 */
public function indexAction($page){
    //...
}</code></pre><p class="p">当然，威力更巨大的是condition属性，支持无限可能的定制。  </p><pre class="pre codeblock"><code>contact:
    path: /contact
    defaults: { _controller: AcmeDemoBundle:Main:contact}
    condition: "context.getMethod() in ['GET','HEAD'] and request.headers.get('User-Agent') matches '/firefox/i' "
</code></pre><p class="p">这个配置会被转换为以下的PHP代码：  </p><pre class="pre codeblock"><code>if(rtrim($pathinfo,"/contact")===''&amp;&amp;
    (
        in_array($context-&gt;getMethod(),array(0=&gt;'GET',1=&gt;'HEAD')) &amp;&amp;
        preg_match('/firefox/i',$request-&gt;headers-&gt;get("User-Agent"))
    )
    
){
    //....
}</code></pre></section>
<section class="section"><h2 class="title sectiontitle">一个Bundle中的Route </h2><p class="p">要让合适的Controller和Action发生调用，必须建立url与之的映射。</p><pre class="pre codeblock"><code>#src/Vender/YourBundle/Resources/config/routing.yml

specController:
    path: /specController/{limit}
    defaults: { _controller: VenderYourBundle:specController:yourAction}
</code></pre></section>
<section class="section"><h2 class="title sectiontitle">app级Route </h2><p class="p">尽管所有的路由配置规则是从一个单独的文件中读取的，大家在实际中还是会通过resource导入其他路由规则。比如，使用Annotation格式的路由配置应设置:</p><pre class="pre codeblock"><code>app: 
    resource: "@AppBundle/Controller"
    type: annotation  #使用Annotation reader来读取resource变量
</code></pre><p class="p">如果我们手工添加了一个Bundle，我们可以把它自身包含的Route规则导入app level的配置中，即应该在app/config/routing.yml中添加配置：</p><pre class="pre codeblock"><code># app/config/routing.yml

vender_yourbundlename
    resource: "@VenderYourBundle/Resources/config/routing.yml"
    prefix: /</code></pre><p class="p">当然，如果是用php app/console generate:bundle命令生成的bundle，那么这一步已经由Symfony替我们做好了。</p></section>
<section class="section"><h2 class="title sectiontitle">双向映射</h2><p class="p">Route提供了bidirectional System:</p><ol class="ol">
<li class="li"><p class="p">match($URL) #返回匹配到的控制器及参数构成的数组</p></li>
<li class="li"><p class="p">generate($RouteName,$paramsArray) #生成URL</p></li>
</ol></section>
<section class="section"><h2 class="title sectiontitle">Controller</h2><p class="p">我们知道，每一个Route规则都有一个_controller对象，我们当然可以用完全限定名的ClassName::ActionName的形式来引用一个Controller，比如：AppBundle\Controller\BlogController::ShowAction。</p><p class="p">但实际上这样的表达是有冗余信息的，最起码还要指出BlogController位于的命名空间Controller是没必要的，所以Symfony还支持对Controller的逻辑命名,
一条指定Controller的Action的逻辑命名通常遵循这样的约定：<strong class="ph b">BundleName:ControllerName:ActionName</strong></p><p class="p">通常这样的逻辑名称会被映射为：<strong class="ph b">path/to/BundleName/Controller/ControllerName.php文件中的ActionName方法</strong></p><p class="p">比如：<strong class="ph b">AcmeDemoBundle:Random:Index</strong>这个控制器通常会会映射为：Acme\DemoBundle\Controller\RandomController类中的indexAction方法。</p><p class="p">另外值得注意的是，Symfony中Controller的Action 与CodeIgniter之类的框架并完全一样:</p><ol class="ol">
<li class="li"><p class="p">CodeIgniter中的控制器直接输出响应，而Symfony中则是必须返回Response对象;</p></li>
<li class="li"><p class="p">Symfony支持从Route和Request定制Action方法的参数。而且对于Action方法声明，参数顺序并不重要。</p></li>
</ol><pre class="pre codeblock"><code>use Symfony\Component\HttpFoundation\Request;

/**
 * @Route("/hello/{firstName}/{lastName}",name="hello")
 */
public function indexAction($lastName,$firstName,Request $request){

    //$firstName和$lastName等参数顺序并不重要
    //可以直接使用$request
    $page=$request-&gt;query-&gt;get("page",1);
}</code></pre><p class="p">此外，Symfony\Bundle\FrameworkBundle\Controller\Controller提供了一系列helper方法。</p><ul class="ul">
<li class="li"><p class="p">Redirecting</p><ul class="ul">
<li class="li"><p class="p">generateUrl($route)</p></li>
<li class="li"><p class="p">redirect($absUrl)</p></li>
<li class="li"><p class="p">redirectToRoute($route) # new RedirectResponse($this-&gt;generateUrl($route))</p></li>
</ul></li>
<li class="li"><p class="p">Rendering Templates</p><ul class="ul">
<li class="li"><p class="p">render($pathOrLogicalTemplateName,$array) #render a template
and return a Response object</p></li>
</ul></li>
<li class="li"><p class="p">Accessing other Services</p><ul class="ul">
<li class="li"><p class="p">get(‘templating’)</p></li>
<li class="li"><p class="p">get(‘router’)</p></li>
<li class="li"><p class="p">get(‘mailer’)</p></li>
</ul></li>
<li class="li"><p class="p">Exception</p></li>
<li class="li"><p class="p">FlashMessage</p><ul class="ul">
<li class="li"><p class="p">addFlash()</p></li>
</ul></li>
<li class="li"><p class="p">Forwarding</p></li>
</ul></section>
<section class="section"><h2 class="title sectiontitle">Symfony2目录结构分析</h2><p class="p">了解框架的目录结构是框架快速入门的一个途径，一个成熟的框架，每个功能模块都被划分存放在不同的目录。 </p><p class="p">Symfony的基本架构十分清晰。与架构相对应，Symfony的目录结构也是非常清晰的。默认的结构组织形式如下：尽管拥有如此清晰的文件结构，Symfony也支持任意定制目录结构。</p><pre class="pre codeblock"><code>|--app //Application级别文件目录，应用配置config(插件的配置文件需要import进来才生效)，应用缓存cache(缓存的类和模板)，应用命令行console
|--|--AppCache.php
|--|--AppKernel.php //入口文件里面会初始化一个AppKernel类，AppKernel类就是在这个文件里面，Appkernel类的主要功能是初始化整个web应用的Bundle。包括Symfony2框架的核心Bundle、第三方插件的Bundle、我们自己编写的应用的Bundle，Bundle在Symfony2里面就相当于一个具有完成某一功能的完整的包，而且我们要用的Bundle都必须在AppKernel类里面注册。
|--|--autoload.php //该文件负责自动加载注册在里面的类，通常我们不需要手动修改它
|--|--bootstrap.php.cache //Symfony2核心的类的缓存文件，Symfony2框架必须用到的核心的类都会被编写整理到这个文件里面。这样做的目的是减少运行的时候打开文件的个数，提高运行的速度。因为不同的类都被存放在不同的文件里面，如果没有把这些必要的类缓存在一个文件里面，那么我们每次运行都要打开多个文件。如果把这些必要的类整理到一个文件里面，那么我们每次运行这些类就在同一个文件里面了。例如：Request类、Response类、Container类、Kernel类等都会被缓存到这个文件里面。所以，如果我们想在 Request类 里面 echo '在Request里面调试'; 这样的语句，我们就把这语句编写在bootstrap.php.cache文件下的Request类而不是symfony/vendor/symfony/symfony/src/Symfony/Component/HttpFoundation/Request.php里面的Request类。其实symfony/vendor/symfony/symfony/src/Symfony/Component/HttpFoundation/Request.php里面的Request类就被缓存到bootstrap.php.cache里了
|--|--cache //缓存目录，按不同模式（生成模式、调试模式）缓存。主要缓存了模板文件、Container类、路由映射相关数据等
|--|--|--dev
|--|--|--prod
|--|--check.php
|--|--config //存放配置文件的目录，config_dev.yml和config_prod.yml才是被Symfony2框架加载的配置文件。但是为了方便管理，我们会把不同模块的配置编写到不同配置文件中，要使这些配置文件生效，那么我们还需要import它们进config_dev.yml和config_prod.yml。
|--|--|--config_dev.yml //调试模式的配置文件
|--|--|--config_prod.yml //生产模式的配置文件
|--|--|--config_test.yml
|--|--|--config.yml //通用的配置文件，只要import进相应的调试模式下的配置文件，就可以生效
|--|--|--parameters.yml //存放配置文件使用的变量，例如：数据名、数据库密码、数据库host等等
|--|--|--parameters.yml.dist
|--|--|--routing_dev.yml //调试模式下的路由配置文件，我们在src里面编写的路由配置文件需要import到这个文件写才可以生效
|--|--|--routing.yml //通用路由配置文件
|--|--|--security.yml //防火墙配置文件，这里的防火墙是web应用防火墙，不是服务器的防火墙，里面配置有角色权限、ACL等，这个文件需要config_*.php import进去才可以生效
|--|--console
|--|--logs //Symfony2运行的日志，同理，不同模式下有不同的日志
|--|--|--dev.log
|--|--|--prod.log
|--|--phpunit.xml.dist
|--|--Resources
|--|--|--views
|--|--SymfonyRequirements.php
|--bin
|--composer.json
|--composer.lock
|--LICENSE
|--README.md
|--src //项目源码(包含Controller、Model、View、路由配置文件、应用的配置文件等)，一般以各个Vender提供的针对网站各个功能的Bundle分类。
|--|--DemoBundle //src目录下存放的就是我们应用层的代码，一个功能就可以组织成一个Bundle，例如简单一点的一个购物车功能、复杂一点的一个博客系统都可以组织成一个Bundle。
|--|--|--AcmeDemoBundle.php //每一个新Bundle文件里面的Bundle类都需要通过手动添加或命令行生成的方法注册到app/AppKernel.php/AppKernel类中，才会被Symfony2框架加载而生效，
|--|--|--Command
|--|--|--Controller //Controller目录，顾名思义，这个目录下存放的就是Controller类，如果不懂什么是Controller，麻烦请先学习MVC
|--|--|--DependencyInjection //该目录存放对AcmeDemoBundle的扩展
|--|--|--EventListener //该目录存放事件监听器的类，Symfony2框架是一个事件驱动的框架，相应事件触发时，这些监听器就会被执行。
|--|--|--Form  //该目录存放着表单类。
|--|--|--Resources //该目录存放着Bundle的配置文件、模板文件等
|--|--|--|--config
|--|--|--|--|--routing.yml //该文件存放着Bundle的路由配置
|--|--|--|--|--services.xml //该文件存放着Bundle的services配置
|--|--|--|--public
|--|--|--|--views //该文件夹存放着Bundle的所有模板文件
|--|--|--|--|--Tests
|--|--|--|--|--Twig
|--UPGRADE-2.2.md
|--UPGRADE-2.3.md
|--UPGRADE-2.4.md
|--UPGRADE.md
|--vendor //由composer管理的第三方依赖模块，包括Symfony2的核心模块（HttpKernel、DependencyInjection等组件）和第三方插件（如最常用的SonataAdmin）
|--web //网站的根目录，全站公开访问的入口，包括入口脚本Front Controller(app.php和app_dev.php)和静态资源性文件。
|--|--app_dev.php         //调试模式下的入口文件（在调试模式下可以额外输出应用的运行信息，包括加载时间、执行的路由、执行sql语句等）
|--|--apple-touch-icon.png
|--|--app.php             //生产环境下的入口文件（相当于TP框架index.php作用）
|--|--bundles
|--|--config.php
|--|--favicon.ico
|--|--robots.txt
</code></pre></section>
<section class="section"></section>
<section class="section"><h2 class="title sectiontitle">Symfony启动顺序&amp;nbsp;</h2><img class="image" src="../../_images/2020/symfony_7.jpg"><pre class="pre codeblock"><code>
Kernel-&gt;initializeBundles() 初始化Bundle
&nbsp;&nbsp;&nbsp; Kernel-&gt;registerBundle() 注册Bundle
&nbsp;&nbsp;&nbsp; Kernel-&gt;bundleMap生成Bundle关系图
&nbsp;&nbsp;&nbsp; 
Kernel-&gt;initializeContainer()&nbsp;初始化容器（缓存）
&nbsp;&nbsp;&nbsp; Kernel-&gt;buildContainer()&nbsp;建立容器
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Kernel-&gt;prepareContainer()&nbsp;预备容器
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bundle-&gt;getContainerExtension()&nbsp; 获取Bundle扩展
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bundle-&gt;build($container) 编译Bundle
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Symfony\Bundle\FrameworkBundle-&gt;build($container) 添加了不少 CompilerPassInterface（路由、事件、模板、资源等）
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ContainerBuilder-&gt; … -&gt;setMergePass(new MergeExtensionConfigurationPass($extensions))&nbsp;设置MergePass（CompilerPassInterface），用于合并Bundle扩展配置
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Kernel-&gt;registerContainerConfiguration(LoaderInterface $loader)&nbsp;获取配置、服务
&nbsp;&nbsp;&nbsp; ContainerBundler-&gt;compile() 编译容器
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $compiler-&gt;compile($this);&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;开始执行$container-&gt;addCompilerPass() 里面的 CompilerPassInterface ，（包括 FrameworkBundle-&gt;build($container)里添加的）
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认从MergeExtensionConfigurationPass 开始
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MergeExtensionConfigurationPass-&gt;process($container)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process 包含
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BundleExtension-&gt;prepend($container);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 必须实现 PrependExtensionInterface 接口才执行该方法
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BundleExtension-&gt;load($config, $container)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所有CompilerPassInterface 依次 -&gt;process()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;foreach ($this-&gt;passConfig-&gt;getPasses() as $pass) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$pass-&gt;process($container);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
foreach(Kernel-&gt;getBundles() as $bundle){
&nbsp;&nbsp;&nbsp;Bundle-&gt;boot() 启动
}
$reqponse = Kernel-&gt;handle() 处理
&nbsp;&nbsp;&nbsp; Container-&gt;get('http_kernel')-&gt;handle($request)
$response-&gt;send();
$kernel-&gt;terminate($request, $response)</code></pre><p class="p">&nbsp;</p><p class="p">后续更新CompilerPassInterface 详细顺序</p><p class="p">&nbsp;</p><p class="p">&nbsp;</p></section>
<section class="section"><h2 class="title sectiontitle">symfony调用的流程 </h2><p class="p">symfony框架调用的流程</p><p class="p">目前这个是在RegisterController控制器中的一段代码</p><p class="p">$user = this&gt;getAuthService()&gt;register(this-&amp;gt;getAuthService()-&amp;gt;register(this&gt;getAuthService()&gt;register(registration);</p><p class="p">&nbsp;</p><p class="p">现在我们去找getAuthService()这个方法</p><p class="p">** 仅以使用PHPstudy
ctrl + F 查找public function getAuthSercive() 类似的这种控制器 **</p><p class="p"></p><p class="p">return $this-&gt;getServiceKernel()-&gt;createService(‘User.AuthService’);</p><p class="p"></p><p class="p">我们在里面可以看到在Service里面的User目录下的AuthService控制器</p><p class="p">** 找到回到上面，看到getAuthService()-&gt;register调用的是register方法，我们去AuthService去找register方法</p><p class="p"></p><p class="p">public function register($registration, $type = ‘default’)</p></section>
<section class="section"><h2 class="title sectiontitle">参见</h2><ol class="ol">
<li class="li"><p class="p"><a class="xref" href="https://www.itminus.com/blog/2015/04/10/WindWhisper/PHP/Symfony/Symfony%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/" target="_blank" rel="external noopener">Symfony架构分析| itminus</a></p></li>
<li class="li"><p class="p"><a class="xref" href="https://www.kancloud.cn/wang63350837/symfoy_project/267243" target="_blank" rel="external noopener">Symfony目录结构分析· symfony开发blog实录· 看云</a></p></li>
</ol></section>
</div>
<nav role="navigation" class="related-links"><div class="familylinks"><div class="parentlink"><strong>父主题：</strong> <a class="link" href="Symfony%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91.html">Symfony框架开发</a></div></div></nav></article></main></body></html>