<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"38f5931b82ee9cd99d6018bf54433c2fd1c4ed94a963644ec5972e076a4a15cd658c45e156e402e69d6eb7bf4df1e7a0f34dd8ed00fab87b550b0d11a025ad0a620bdedf3820d7a297c6d88381e5ab4206881adb57502d8bfdc9487633d5ce09b4c7aa350198151d5ce7e53965efbbfed3d47a325bfa211eb72911a4ab3b67f8b6c7413fec986e0a5bc8716ffc60b2799a69f7414a69d3b3be0e117b3b8b2320716e89ac1cc90cb9274feb9790c1a5d714ef6d1fa9e897279a6e3a32bbdf50d8435a16d4459af9eede050f53e9664b8fccc70efa11931ac1fb4e3b39191d680abce03a063897c8545f8d312dea84b07195a7ec2d40824c3a5a806e5e2ccbe83fca04f587622f082e16dc819a9fdb7db95f573dd90a248a6bf0a2dab7249adeab8ef4b23c0fcc70c53d40a5127ca379f3c9b7ed1cdb7ce2d6fb039ff666175b895ea28855a9b3c259751a2ba6504ebb2f3eca187b680f676f6f0696cba8a5cb42f8e9993ee5d9a77086f017ab095488b314eb45ec34f768513a0951d10141fa62583311e1cd723f063cc8788490e02685161cf96450ea22b789bd9ec8fe6c140de67e387fad5a3bde2761eaf915fbe1cf608a8184b77516d8cdc4d5fd31c20ee3916fd23e0a4528471812afc35439cf971141b46acbba7c354de7ee8cc4edeccae734ba6d8a288f3b382b96f2867ed9580363ea52488b6eb05c10aee367237241ed77b270c1074fa05969fb0fa7f582c52fb2a8e95bc6be4b953e9bdd13569ef723c95927471c0c4083058f621adc9f43ebbe2fa9837d92956eee077fe1d1255a0be8acbd78cb87d78ccf4ff857b245f60152e31c5b821000cd0911b2b6a3171dc08232a4d0f74c96c74c4c5253b46728ab4f0a186bd221bdd6ebe6913548825f51fe59d811d14df06f704c08bf43a29803c8e439534e82f532a9dfd01eff212f40bce41ad6c044b76b85976677bf5d9d9385adfb1f2c25f3e433012438a08c1438e10848d649faae40f4a4c6b0fce6ba5c6a118651223051bab5f21b96259053f55cb29e422ab7183d4725df745efde3988d7bfc6e8275b13cc88f794165e71bec61edbfded6f6cba0c3d70efb425509faff277e230b03406b49eb8287608e5a5de03fd5303606f56d7e1d5c45e10bf0505bea9d60cf6dcd0cdf09f873261dad51b388e65575898b3405d93301c2abdcb64bb5cc623255281eb907d8c806f5d51dde81ab4a90c2120b18c0f0d1b6634916acab4c287a30a61c5daac9e87225ca00b2cadb492d1a8ee85fce3f515d579d1eef29f2454bf5ad96896f9b3dae04627c9603e76071a42943ee362a2daad66c68ce2cb2f320d2a5ae83f074c190eae94909431bdcf7abadbccf54f5f9044f849cca17092261c1c2cc56da8b0413c26ec10416b79770a46cd98b70e2f933f6bcbc9b4c5739b6624fa5dfc8721dda921cc0d6beb4b2b0df938d8ea0381277277eee7b72560a808a6946892d065bc12c3ec433492723b8cddd3c91702462a9cca8e6222472067a325a8ac7a93dd8c7527a1aa02eb95e378d35a4b3d7922ca111471c91729dc79033a404446ab50b0700685380abfa5b68b91281660873f0ed49f8d81f9901768e84216a13afc3e8c26bbf62ff7a2807c0665efb4f7be5f643ddf959936d34d4207f3bf43f6365149a8b68a534233a0ddf174471f26c9f65b3c223f51b33c50347f5462a722bb3b6526b80dfae0c6af18349758700a1116db2ea44fc639f3625177637de1518133e08bf32afad03dd798e456bb4cfb9b1b853252870459bfc1edbde971623564bca6d6bca052ec5ac09a6f61fb306e1b7a8025f41a4d4ae30e0474b3983a96e64e879a75f6ae9aa5a4f2365d2f3d9a9da7cebc0c8fdbf882a457622ac6ed39696cf5c777e4f06817cd7349c62490007561102a4dde956d9dafc2b5b5d47a7fb0a3a84220e550be2293bd6fd9264343969b9cd3c5dc9ce3bd68953b6b9c7b9c20787277f4ffe14f1be2c018feea13db5b311c9365def1ae615611f245fc503ad2db156f07ac767a37718516fdaf5285fe7257040eaf2d29b396fd5c35c77c032386ce407b33a8e9277302e0c8bca95e8c1f9c58f29e1ef27fe868ec8e386d79f0532344ef2a1b9a3e367a5a59f7988a5446e41637682a417e205846e90ee539177ba7e1936b253bfcaf9b9eb05f4b0005f92e8bc3cf802a587065cc36fcc1ddafa977c674640e8984e2b33e80cc1a3028a93637d89d032e65f733fc13301390e0ca303ab99eb41e1348ba1d95e5dc857d17657dc56e6a518587a46a5e84c5851f8b689807495f643831e3497c8f0e9477cbbcb1bb6c8016e7bc8b861877da4c21a3b5a5ed0060b26d55d2e65781935b471b406d123eeb7f62d1111fe5fcdfa617204cde27e16e930172d8d39f40fcf5ec8235f88803ffc03fd6e64ae9468ccf688dd21b1f32dedaa0528df3cc8cc676f0b932d523c08ebb2aad872b1f64c75bcaf8b6022cc30eaf3fb72ce954349b1df0ceeb3986cd9509753ba4d27e63d962c7f9a873c3d3996ae264b3dffe7fe1db0e1900ff11c0f47421ad38b0f7c26016016887959180116cecb2dce4f55876c318fa746157d5132f82cc83f35eaa47710ac15225f93bfffa71c7a53f325fa2320022aa822030d217acbeceb509bf04717c9c220f035ac5707b2d0a563ca05516c390e7da9ac10bedc8fd819bb997243133e9648eccdd72b91101b2540c29ae7cbe8f768183093e2ce4bc338c094aec7846188fe43206fac75e44ab684f703f6fdb3e33a118ad4002f5ee680afe995ad877e1225df54be65875d9ab7cbf171232ef94a4d6d4f7c5f7381fc13847dffc4c45bbacfb63d514e7b5acd7ecbff0425c8bfc8b7fee842726811e1ce238a41f780073f011f0e5ab344c6246585b7d977286ca67d3fd54e89de4e5cee213509e7ed81cdc7729f9922cafda5e9d756cf78dcd95254355a9af55a1975167c1c16855aa6ad20d7516f9b77ae6758ba0eba002205520fce8ef099ad2cc906370f36bd85ab17fd8e090d731f85ffbc7c449ed735a278516d290f7d6e3c911bb65e34ce8fe13925cb202294248f57a5dbaabec7585c787f5d253817a2c418a4c096a3a5f36fd16eb02747fe0a13b75f92edbd9853821d3d6a3bf103bac72b4bcd37e532b4d01b76fecd73e02a7339654b58c85119c9e882ab54a5f4147ceeac7fd7dd4ffbd7ef3575e5cf6568f1e1bdca745bcc8329dd4bd6af8b7b9a97356e0096497114ed4341facf531f9e070136a6ba24bab03c6508ef8ea11f6dca4bbfd24bf03970679b2c02cc31483f2a746460edd4b8689f917847402ada8027ea48537f3004026d8d09bbb9b6cf1e5a84be28dbdf911da8ea2d1c20c032ad3712faa880e585c124344f35f88316a632f2c05560ac0b5d086470436f857bcc34f1a1b225f86158888405702a1009d8571bab3c6dfaa0b209ee5fef31c43213eab3ccfa584570abf874c75aa5e4a7527d4b71d7541d1105400740c06fafd35e38b95608dd741974e03265e5ce693b3927bb16dde1aff4ecc42aba96204ed6253ea4595e958cd72cd4ea8b09ac670078e4259da456543e894af2b6f3cb0bf38dc2eda43bce829fefad3153b9d01fc3488e5218b1a45a3ee65cd61e72145a9be4972580adff9ecd2f7ccbf4332a57e9c62c1c7c11fff061d5cfc0fae05f1c84e854e8bd08f5bee78ce6ab1976666f390212aae8cebf0259c4b30a55046464aa56c64365688afe733ca04ed3aadd05512a96464ae78f2a24ab7f6f06c095512053871c6c8ac2bb210fb4414ef78c8294a92a5761cbafbce6a6698555789af03789c6e30442bb456533797db775336368af4a226131b157ac2e524f1f7b1bc3530d6d663f16982c3cdd15eccd77a68440f3a6113b12efd2abaa7fe4f8a460187f84eb6491aeb6bb2b3bbebe80b17eba0b4788c01820de0dd87440712e7c46a1d689935d01c96ea4b0f07bf8e5a6d1676efcb29a2e791067ffd04edbc249c6ba90c08fb288012cac3a79a9cdbe0786eeaf4523de8e4f830239d786bcb2c8ffaf20d4582a5018a5a90554398b08332a7c4f8759aaa99940a492b8ce966752ad6f778dfac248d8609e5de654d5d46c539cc016ebddff72b0909095971f7fa3b2e29dceb0330c4726f8c64a0f3979e9e51f0cc9a7c862f28744a0a8776111c614a976f5d17a27d3e6d88210720deb3187d1b6049138eb7c51169268461573bd0f56ee915cdb34eec17a58caa50f838f1fc2b3bbe0bd408c52aa22aa0dd04d105aa07f36b8e049f26b7cb1b59f037bb0519c676069fc30a7e76531f45213304b11722f10d87925be1774928707576e6efd80f7245769cf6a5924b206f74c75f82f8f0a30a8fd4ea47c6ef31af1edb33eeb4535e3b09dd00095eef35659dddc645325312dc26286e6754046aa55b7a632becd90c0412d9e0c4bde6c9d228adc6b1e8abf970ef730f97fc32c1f9d1a9ad59bca65821cd6ed7e9d8fe9747e3e33bfef614f56ef45eef5a14adf416af0f9a3c13b1640c318dbe40ea5344641d804be88ec99ef0c282833f7bf9e02edb043c05369edc22539cc25a55b963d9b02be86c35843cbebbe0ab348c4977302c1aa0db9170ed33ea9a4e49448703e4db76b818dddd045807632dd12c06f484b5a35a34f7e737349c1f64d4107694950e2da04de792948c6897b6822f1e0c4f00d7cc5353a87a88bd3b40d7409e05f9583c93408fb9a3c51f00d40ed2b7a9bab4539808499ade4194ad6e679e81f40090a32829e66784d7d5c28c8807082419424a922293651579bb8de5bcd6c4bf58ad3d686967ce6a2871e6a5a89dcc5029bd317a6bce3954be368ec6a4a4d0e0b1c629024d23eba40e60bf5689cdee306312df48a2ad9fec5062cda86de680229fab3186019cd8f00fb2f385fe6753f2800798bda3c4ddd27b812e7f7c4f878b4938cd45bc168ce6512e5a35ccdce36882d47b8e2ecaeb44ee4ce05255785b431b857b24de2826270dbb15cf8b2e01d201be464639372907dc9ad100577ecba511f022a9dca3eeaa0c4a307332b163a5c0ec47b37f54ba585c33704a2a77a9654482401eb42af77fabe4b7cdaecb4f81522e26369e52050d645dc94011bca0ac5076ef197100a45cfeefaf0f155d83079b75e512653b68c498153843e43a524d21e2afa915473cab833914c9dcb89e09c6edee888441ecad96144270b0b90cc4b2b78d602ce1b1d4430290c2161b0f8f89782b1eb414d7561b453cc4c9f14dbd51c5ccd6ec33a4cbe6fea341015b72a1206587ba52b94a33b740580cd03429f862c417f1a352ccd6b84eeb5a17818f0e85b1e04f4bebecbe46d4993e248eeb33743a4355480134844e87f51076ad91643f45b4972bf24986b743310f4c8f569dea1f91c3a22f261f0fbf0b2e721e016b7fa2225f265afb6dd87c354f9c5262c7ca343bd20887dc180cde1ef70fc7fab360806345e0c18a354047672861badc0450c5a360e875c6f62e357c51ac1e1a610f27de5cfc4a1e79ca8e31c903c9c3fcf759c1bb099b508eab09b069f1aa94c523df372ccc4b96c12035c23235af447fba85ed1653d367b7d4a3c540e8db8e722839a02087410246779f72a4c97b507107295c28f5e7ba9d359afb33a0dc01e231a8cabf510c18dfe71bb8e6d7a2201cbc0bedbd2af590dd4e4a30686924a51c7ec1bd57856693f2a5ed596f933bda779f8a187151dba2cf6cefb0e47cca914875c7cab24f37a2e907c18aafb26db641faf2398e2cbd0032db242d7dac8b988466ba6136ebeaa268237bdd3bb876b6c333bad8e1001831cec01668b79b176734e3cd74043cbeb90ff92b94c3cb2d6ee5db591777eeb58eec683628eec29c09b3add89df6ce094e6826441434c999d855fc8673bbf940e3b4837143f87747539571ad9c7ce98036350ae2944c81e14ef8c55f990989625af69243109b329fffed031ff8fdbba9237475fd2641e3ae100b4ac4ae520efe924b4ef16a9fba774ed50652ae359775988132ecbc0d7d55cd6a829237633be4a78fc2b3bc6cdefd01dbc55382e238c8aa06c0ad4d20da66372b025cebf0ee0d7b9f410ebe53879f1f337bee789d4039d3e62dcc33b699e32268487f300fc6e4a49d13d7416e0b7c328278ab6d43bdf94dbd970d389fbbe389a452f4d39c0bd2af3ba246d580e6a86a31d883a03f0947c1182e37e0b644491d5f25dcf621fe8f3650b965063672f777c293a3f92b75d5d99e82fe0d37be5d9e47c7d7c67b0e8d502b3f413946314792d8c1896b2dbaf4289c768d2f852a5752bf7b4dc078ef85fc15855348caec60c27c681fdb4be0e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
