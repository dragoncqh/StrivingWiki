<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1b00fa89837630bcb7635b5e772578226dd35b670ae39c4d965fd10eb618f83c1d0381ff015ad288e28b8bda379ad11df4550f172020452f659ef6b270efbac4896080a444f6fe49d29c6334e729afbbf50c4608a2717d5f6d355f65f3bb98d1903613a7e2a1e463a7bc973a6fbe8299aa936ad61cb01352d60eba4829eb39f34db61a6d92651b640d238d32bb5f14dc74f46b02f87b5247ddd11431c31fc73a397310331bf8f7fc3d94efee7bba257776b1e3dc8ebb89016a3c6f193229bc7f4f4853599b5992e4786b62a46dec76636d15a47c77be9dd085a29320235b8f30b9561854e7b939b248b1af8f73e849e2128db95e4acf73a83d031ff76b31e741c488d45d87e229efee589647a95e6eaa080467606b2c5a319dcdcf39abd435c78891406ba622369dcd8f711ac4b0172a9b7a47474091e9c501d19aa1f41cfbe4ae4a936bd570d596262189c882f955d31d83ee38269da88119d9c644c4de0f7539735fac8c0f3df1d27fb0673fcaef241dd550b84a9da783f7c2d73efb2e6e2c307d78767a36157271c0e9cbf36f9302fcfdbf1e4a822861874bb8fdddeb8ba8767be7f3aa98bd25b47e8ecf3ccfbe3974c7a127922f611f867c3ba5912cab4267c9f624271753cd901a0e61362504d56291c2293d254523452d89345dc471901216797c037d5fb14ae3519575ff2b7e168f82232fb97b8f25c85069e49cba66a1a26bf4d510ab135f9a43c21640753db2fae7c2e10985b1772b6cdb3d8a2ccd6ae5cb90a66bd67ced1930ac3c9383931a8f37b1afc7dda8c00dd70f5982a132db2f81a15accbf97cb2be9abb6e8531abe6ffcbb5de13567a66ee698e23b665d41dd85b5b37ba7ea06345da808f7a6476fd5fcd4fca5c6150863c25a8c773787ad7957996dadd005279726226aec9ddc4bf1b52e854227d2d16ba1826f1bbc4e25431c75cc9e0263819f4b83bb12ed39bea135183ed3859cbea7224836cb4a61f26cd4aa8dac94e7fcf9f13e72a992c217a7ec71db02af00405f318771a588fef990a5b5eab66a3963b65fad9ba7bf6afcfe0b2997b2960e168b87f8efd182090a5dd758039ed5529b72b39abd08c9428b4da4452c4c166995d0a8110f039d501a35728cae26481150f46b018dabafff4644e8850bf75e209a9406809861848c96d3fc2a807174a795614563051c6c248a123b08a9fc10dca35c14988dc8d5a4f4e872bdc502f62b04c042372a98f2c816c4bafff6251218b6b3effc969326768ce835cfd2d57024ae66d51c05abdf9d4c53eca0e41197fa468694709011e551f6f816ebb2a243ec7cfd1bf787a224af4c85abbd54751cef64f662f3a540244a805ec8537e8778dddd6adf9245c2f6c0d416a23f4848d70ea5a2ed86508d0ad7673347ac437ca039266d589145d33ada6aa1aa1ad3dfa0d6ebfbf73967c3b2e970f8c7512b2fbb97a48d26d28baa50cd749ad2a4cac63d1d928bb9e4c5d7867f22acd562ba93150ebd2157972addd0dd2761f17e09b6e2643908382928c598a5e00de41bb50b872eb6ce50d38511c8b0ff07faf25bc84ca98c51304313a983e5874a616deea66582187ea5e399bd36f181957f654629eebc463c18500b8586565f05f030423538983ac3138de2b62b155997dd4d4883e316ac871fb47fd2d3573cad860a91d830d71097e0392aa8db982803d71ba2a5b9ee865c4735f6ad1a4a3709f8082c50025483493d3cbe04a6f84e4dbf47cc1d343b37cc57e23564370f7106d7b7c5259f17b3df3896fa229218672b371da772e216bba65df3c15b92e92ca2eb59726ade387cfba3c8fa666eca194444ae117f4b1af7439af16729010aa978d41874a13c08e767161624ff09fcfa0a62f26ac11caeae4f711d1deba89f761b0aaf6ec7b3132a2382bed948f73b2aee5bac1b7ff1882706b941c45fa1d1ddc1c4c6624d9956aecf554a6410378968f2e69b1e825e1611f6e01fec03b43b105a6063cdcef3844a8b155b43710f5f38f76113baa9dd1a147ce9771379b9a19d49245947836b7c6ce8c4868ef926804df7c872758f67b0eaef486d59779a830fa04aed7ae541001143114a6c96ec21dda1816242cc2d246be75ce99009494a803ac65a500597d447b84caae0b6ebdcd61522792102b9913ab6e5755a6dcca277a8b8399b3ed55d9b8daf8cb0287957d3e07079515e9731d59e17dc34a39fe939bc392e9bdc25bcd3acb898f405e3c0f9d4f4103d6d79fcbdc28f11307dee6d40f65765974c9176bdf3ddaef335274aeea92e6f9370c6203a87385559af43cac25d5d78c13bd9e263b95603cc03b94ad7ca43f51bac9eb51b8acf44e63c1ab448d82730dd81d84a3ed339df2fb8f8db4d4dab6eefb3d5c856c7e1e71a57d06c94ed10dfe32ab2eb1c5052b8fd7e26818b33f470ebb6f78713a1733362a4568a37736b5c38cd59fef3baee5cdfd505978b02aad6202f120b638e703486e700266979c88cbe2a163cede0d500c4fd172175cfb190b1279f21455dc8270d1ee0be1c9a06d04c024785b8bfe83daf5d4ede36f75ac8049a4c6ba21cd1c47106dd231a1393b7c556fb6c679250965f24e24a99ac2ad105693d13d55ce7a0ffb44ed4e5fcf6b23abf8239e326c59dce11cc06b83d339546aee05f821d7657ab239bd132eeddeb7bf7a9cdbe4d7695ec1fd6a2fd23c75b1c2fe197b01f4a9453f204b907e0beb679f228b0af7f0b89363481999ce52ee8815287c50e87ef8e8a508075f3df22c1e332063f2f44ea567f25fd48df9154e3ccf1dec2ec2e3c61ede64e34e218cd9b0ac9bd08e173664b4c924168327d271bf6486c88101d5f243394a21f94766810e046506c1fe329cf022f35a6a5c2aaff7bc0b460002a7d634043df1b2b60e0a96974f93232927f445ded59edec89cf00c39a0c0368df6f1a4ce18b8ca8eb80808b3a2f40af2bad4740bfe8c41bcab72c57c79d6a861cf9af799bbe21ecba93b303795d3250d5fd6669311c226006278d4513e32f7bfb068549bb225edaff31f72324e9e69c95400f4333a971a9d3d3ac364ba69d540449504d6dafaa27b0d685049f52f683d2f3d9e489f15171b30b7b958d7517ea802fc3ca40442f33c56b1e3f81d3c3ace7829dbe4f9254485d51840aea5667077bb0658539d80734b81e310caf599a18428afc79a32df7c556cd5e8ff9147440b61791d01a39239ddbe087ff585251e1a5685d102e4dbbb2b7ee7bc6d12204afe019736b3b2188dd5aaf6e222622567a45dc091f5f06f8da819bbbc2001e643449c3331e84b01291e6c3023a8b661c785316583cd59d8da33d7b42b1b36489040addaf167e75a06b05341ee56c11358bc2758783901c87d5030dfb59e6bd0bbc216b970f58c4f2b0ef6f599e287c6895a8f4ff0080a9be18c643a1a3dd480022b049f3fe4f40b1f054b5bb27946e7ba13ed2d690eedad49f4606cd929efe74d858028f75160e5b3bdfe3120f5c9dd356fa7ec467a89f30220b8b4904451c4891a5e2d1e97c42b685ed9d45ba4382cfc94c1968c3de7f9637f0713642ff052cadd312693b8b56bb1d0d0818b51ddcaa185ab0e9d4f840141ec6bb33f813643e62b56d1e18f82bac3be5558c7ffb0df3e93fc0e3455c7ffab09b851820fb270fe497285a24444777d93553fe249e46061ee7329360aed4ca02d6e2d6146a2b121a52b02a576eaf1b23c1b4c07610ac6b3c3b1c3235fa2b0e2c50391a1fbc7d4b8ea7e05fea07f87fe99145ba875e5f2f5cffad271b93ce4f0877908b15b5880c0302537991334dcdc3ccfd5a9ee4ae34588d86b371e173ab56fc64a0c889971a46e625deff93bf900ac9aebfae601c5f16585b22e9b2bf54ab2243272dd5bc02494e1eb4ad74cd770ce31d409b3c33de794b0c49d6215b2f2a614288049164fdfb8ac2eb20fe69d54465e8d8bb47827a70d3ff33c9404dec4094af4802df5df30dec4b510d656319052c6646b77c6f91e6ed2c26d01389adfba4ce7b121f090daa273312526ea6d320c129d72909bfb41e4c013f3638e6470374b112330855d0228dd16134c11e298521531cbd657eedfdbdab3219543ebde37876eefbc8c9ee7a4f4a9e5a32374c7489173e569d0e22ffe456afd08ff6b4ebd5cd1a3fd67eb0ff908e0d26b2b1b97cb6a7ccad00741376a51702bb5ed371c512c94bfc44cc929cc7342607d421ad518860bc018fefdb6d4955a186e717e09b587a99d853b805739138aa6188213548166ef90ac3eb44a2668cea34d7e34d6a4a1cede0ad75e506c0a64ba1d0eedc95c201d099d30776c690eb4cc5ebed49b8658ff94be41d2da07b49f078a9a2ee6e1ca307324175b0a569f52769ea9e61bfec19515d3e29bec29bfddd7ddc1f458d25dabfbe4f9db4e76228451fb2473dc47ccff308da33b209e254418d77a781fd28098c160c9ab7e466c46418cfaed35faab61d6353aada24ef2bcf0c2d702127e2824f555fed1ad289e6dd7a4bc12341ad11dada5e3b1b16bcb4f9ba3aea575d99375269707a9d8f4474c1bf254c1fd546b7433c5466a2756edeea370fa593d91b357256989f545212c52b94c9a1f882d7056da134f0fe7b05097f8632abce708e3e237327fac19a47d022cdb45586e228c5330ede867fe2bbb3fe61f102c73a19eb2ab9640da4d3059e5d997a019da493fbbe372e039b2fa72d0ded0644892e63638976467852821e3ab46d01fb2ee5197ba09650613e60e0ac84689671e2bcf9ed3686a75071554934ecdbd7ca73eac61d53b7648afdf639d151987b97ab383fe98d55d1db1be389d374200587320fe8826f4bcfd0d44e18a842ad235a737ae24e22b6d2618c523f196e589820e3c6a8b3929c626732f432915473c3008a36e85b213b43cf61068335a628824833631787258f95674c6de30d00bc6c9d12a04b74a62b4718482f4a9ce08a727850e5c8da52a7486e974c0d58f6e73f8f633d6693b1924b4f577e922ee0da11e4c8ace30058875e27ad89be5ff845f1995a71ba1516c7a7c0ba631d6a55db908a18aad8128d4d58a766b45a55ed9f7469de69e66420e6184c499db74e549c6ac3e24c73905b5c4d83433fc9f7f2d1dbff12f001b42f14d18ba059391a1639843b28e8ba17be778e8761722ff6899e33ea3354073f6ed73b5a071cbb4367aeacda1ea28f21e9deb244dcf9a3753d0b4aa17eefd0756f919ff885cf6a7af403cc4e60e789445e94e565064fe044f3ac001d39762d643d629bce6612205d6ae3f3e3d6effb29b650682ab62184d4864d04d11047fb9e53009de8093bc1db0e299028d09e61c5cc5958b097f435c7eedbebeeb685e1ab23919a593bdcdf301804a6bc245c951eeb789162a0281e248c5758c72526660df7961b328f27081aee46426174547ea69307acbbe4bc9b961808973d724039d7cdfd67f0ce3b43c2591028c16d75577474d00b6708b86866d79a2506cd28c07ad5b5d9efc0f2481f9563b2bb23f931c0a2304a674cfa00430afd11caae07760e75ea816b087ad2b91618c1a574814f57b9d0988d2cafe9abfb63f6ea22afd7bf466cc66dc24bbc8aa24cd45e3bb4fba45cd5eeacda42efb51fe466b1dc59f44e7be1625e1c9747ab2bd5ec79d71919b9b7b3b73ee8d330a8fda880bcb3a3c7a82178d6da503d7b4be3c982a93b2c172d2633d52169f826bd80a6d576d3173fc45fb42ddb1b8d8d2a0a3f900bc4b536046faa523b2a625beba511cd867ce69896c125103287b16d947d0d6e2f058c64e5496e5f872393d5a458b6862b62bafb7ce1ac601a04766901ba1b5925a0485b9857d566dc7bc2958924e53b5098a9f275a691153f0aed12445245e0b81c4952bb687e966b5ab8abcc7605e8bc41efdae8e4be2d7851d74ced56a99815831affd2f39317621649f6a4665cd168bb1ced1cc906a6c9bcee30d77be2e46d9be412d65693740f5ff6b316fcff102395ddf2cc5274445a5da0ac3cf9a84c0866b30ba7573a78bf73b18d12e1041505551f305a8b3f482e12c6e0ab80e81ac9f9c7a1cb040ceeec9382696aaeedc9d935df88ba93adcca477b7210e928b1d950de764ee306191c3492dbcd0211bb171da876051a32eebe9d8608120901310b93149b5abf64ead9e43a00113f5ab015f0a9105f7982c94e0546a1f592975340aa4a541c8c2250ebc1caa6a767bc994d2b9c574a98e1f2f52dfc5a543a5cbf8ce2cbfb62614c1cc558d77069996dcb7036f98d917acfd13e80bb7e37a63d4b06202efd5aa015d9c914fa60f754acffdfaf0cab68f461f0afc60488beef0f160ae921d72964f53bf821edc037bf6e5d2f921c387218ea3eebd435b2c2e23fd24b6e80bd7e46368396b993937c2df52a6e60c683660b79c651d232142f5a1d870320323e4fd6f9e2b1a6f5ae693a5b9066db044a182f0d53c272fbcfad361c17038b3c2483f63fed9648d15da767e5c43ba4fa8b184db96f13aa33b19b20d8cf78bb773206ae80c5a23d630eeb72a41d0371b7ff98f8b56fba2cc01d87398bcbde8dfe5e4a2d65f16e7137a028d5094be9864f90dee2940870c17c9a1399df324e51812dd13e62ea3c0adebaf8b852b280d70f21ca133c3a779ac86c5c9fda7ff10232a0e586f47a59cec42193461f1822209f2e3238152f1ad00944a6ddcc44defb044ddeb7211cb43c95f825b020b3d7da4d5408ab0952a167d2592fd000710cddc1875124461304e5c2566247cf5522593e5719d80bcfd8f90af1449fe00befacd7459fed59af734a4fd79d8c7fefdca84cbad2669caff2555958597941d2a738ea83b461879df7b5f65d266999bed5716d840acad894453e56367fa9cad64aa33e97d6c496fcbbbfe025ca0f9ee7cb41d139cfbc8e734870a5178cf520109ecf4e823cf5198d69113bc07e2fac30b6d82eb59fd058762f8d1a9bdada02e4d0d4fd270a6148c58aeec9e52204361d79a64415e436ebb0e63b11daf8b0660b7d0c7b798722d44ad1aff97b6e42c4bffa71691c2792af4f30827dc08c47c945cc8ab36e6534de6adb8cd13768b7bfb5d4a6268e389671c15fba213aa1125b4a6666b2b2e6adeeafaa91fcdc88e1d19caf9d6f3a27a4fce8819a935fa56562a775342a90c9562e5b1d546839af21d35f8153487512d51d5f022c7266c0a1ca5097a856148de33acdb3f203b25a0dabacb37cbf23d963d562f2e7944fe80c3336ee1ab36d7347147a96f22f673111a76c5c95a00813219e7b00dea146df21a6ddb619bf6c661cb8874d37229c3d2fa720749290cd318131c620c4736a5d4173ad286d6e934a3ff2aa3be56f439bd0528d49d32ccf7645863feb4c4e15040eefbb92af4a15fb45a55b4734f1acc8ee02b7bb2de5a25b5d4985f35187e78c5d96f88fb2c6b9a192c7437a2fe53a0b2a4d2162e8d7d78d5ce58521c5339fcf50a21ee42fd5256b012e91d0f8a9a6abd1adf296c174448127b4f491852b0a088aa04ff909913dc3f6a15d0cbc90a38af65d0c9ff103255e761e0515f19bb9b9ba0e757e61d406ec2d576eaccad6d340eb49bc082271d6e891c3d8952a20f83c320e6da0296ed321c011d79195edd4277390eb834e9027125765d48db1ac76aec2eed5380b94283fd6fce2c91f75fb196d15390344bf625801db0f2a241632cd64d25ffc683e4f22de085d870e341d39eb590a8f4bc5c25eb4747dc428e30dfcfff057f53f2fc342fc62e18e2d19a9a4c7cba2d8d167b2d6b84d2477536c02733df3895366ec16df3e7bfa487c6fdd6d306e8029690dcca3c8b1fbd2c522bd4eedfaec17bd56b682eb4b37d0132536b01f88d8e75e26d7f3b9d8dfb36a549f82cb81772f63894f9064d95f522682ef43a65136bb0bb2bdc8d5510f2f21db1e45aa303f555038cba6a5f64720e78daf6f8fe9f244beeb9d08f36b0885c0cbaba2ba4da1ae4fa9c08b609f1e6463456aa7ecdf043553b198b5cc13db5197441a6aec4ca6ac81257922c33edb22de35e6a1c2c77c15f63e51bd94f28076105ca2eb573ec0d51795b39e15f5efb8916ac2367cfc8654835ffe5c866fc989530e701462a4a659f57b82bb85098592b8a8197bc5d6d6075d88c94576105018f9555e5bce643dd8063ce79fc8ac7956e7f9e3eedb07aaa58a0f97ad342ed524f3fe34669ecfa3c597382f97add9034d48ca32bfa5111fa108d08278a9486f10d7f54c290b7abafdef24f6c467ded378edb74e2abf225c912155fe0860a6db098af8bd22c58bbc8025e987e37a062c57f89bca091156ff51b28264e3bea39a61b691081e659dcbd25edcfac867d335ee7d35993a448fade679fd8f29c009fceacdfec1996952abcb7209e6650fd4a84b3cc2c84eafdbf2ebe4d34b7ef1eade18b9edc99ae58f9418d9c564998739daff4b69f0baf993119878136e56d1ddb97f89b3995846ea0b01a8ea8672e6e3c2dc28cc4007a7efc8a057c74c5b7c4deff9a3cdd6effccdf1fb97c05dc34766e9e4f8b5acc91199be94892a6263db6b1118a9500121e993217960c48b87372431869361ae56b35701874df552d03d202e512085ed8917e4b14065160096d7fa2c4787e0736d63c9ba3c007624d7305ae403bdecc7c6b8f61891ff2d9394ae46482fa1522880e464c891e0395e336efa8c5c7662b6cf718f344eaca044a20818442b43bcb4570ea09922c95e0ed850649aa20b3841f934b015e8e245d83eea96626215f734d04465eb50e8b02a33987d6f3aaf5aa0f34068422d9409abba5ec3a26314a5ed809d27122f63609c27d36a148aeb3eaa05ec6f9d8cc3d54bb2ea367cc928ab058c9ef53a78e609caef00b5716de67849a44f3210369b0ed7334f2dbeeaca00aa4585198006fd035e810ec5dbb59a56391b80b17053b3a1f3b98ea0365370ea4f0d51e0b3d9f766e2fc17548afee82a0878d07899103ff24f3a5473355316b58cbb31a2a112bb40e16c0dc0a06b74491faa2be23359a0f81ccf03f2072f061d730deb8dba5dbaa5c5be7406c8c74a61ec2041c3017487800cb18a3c9916d113f5eb8e54f6fb822360ce18a1d3c2f6556f03344f4582f05cd83f9d787180cc8ff4d4ab5e85885fe573b6fe4bf58acc58d3b42e3fad2fe50587665c4cf06d7d8cb409f36b4dd7670606d0d76f8c2fa7127ab213d171efce413292df182a195d0cb2db36034c3c38802bbe642aa0508e6ffa91c4424dacac38ebe9a5d2991d47f5f1a24859a467b32a8cda21daa64f3be69683c52cdafde26e42ee935d549f3eceba5b674b311633bbfbe8f3766c000bd5d3fd7714f491088fc6d0da8c8452cc0cca69d9c74bea06c85457630f643b8843e8326e7ed01d2e12a9cf4f9cc98d6e99c9e8b2c6cd58faa00306b664298ba4b12e10044076ff2c58ec3271e7083215d1c0b8c72cdbc049cb80529198d735e8fe0cf715550fd420cca4abea9637a32744729129760db7d4b78527f59b40548edbe849b08a1cce527e732e8fc6be376207fab3e6a51ab7510d6455ee709988a655a5cbdbca4cb79cc8d29017965e63aea8c5cc1ffd16b77b0b41d6d49bb2453c31f5e0cc01857ba2fc09b1954c77a972849652ea5f218bcc53713c935608275d5dc0ca53efc68f5262844c8e31c708187dafc23a85dad9e9feec9ff045c7c087dff57c5f25a72f81896facdff2ed060c12c742d4e87de986c8f2e5ed8b1da325a2e1bd306f98b9bfae399de906c25ca94ea293e1aba57dbce4a96a097617f140769fcb298833297e29c96bd29eddc0e5fc6c96fce2dfc4c4722830d0093776ea4b9d06b10154b79e90ba1de7149da117aa49de8e5f7bc2cf1e2722c190a2afa22d76796fb1ca9a3efa1e09549d0163db40ac05434e741f2484deb20e8e2f66a956042b411a7d8742848947d8708edd5d836ec40d26cea8ebc587d0377d830e56abc8be3a7428afc3940664b488c8942b78d151b3537a21b64fcc47583a0e35c33b4b8eebe92e65a0d86018e7c50981d938dbc6ce12303ef8b0037271ee08e12c9249fa907e75e585bc995ee3b6f4198a43efb5a418ebf3c3d2399f60935f3a61a2ed2ec868bc4f06094fd438e60104a85eefe9187ad7acef9439b32050d03ad25b2f1bd19f86a2aac424f82fae94e9d80ce86fd46629dbc7c3e1173dbd4193c0ce0f4c5e9b1d809080b8d5d08c59b553c96392f7fdb19fb8148d447469b95b8c5317f43baf87e87af0ddc44ca773a0221473d4ef5cfa945e4f878b3b12bd07dbf0115ceb80cc32a0c6256fe17958df7b1557945e4ec4c4194bfdc32cc004e6b5ea6ec7c27d133c05acb56f0679d89750688c4c3c618362d83d664f5fc68dded18291d9f98c4b4b3a76c92a4f840140d4ff851d61c4cd5ae156e24359b8075cd36fd1241d6987f358ffecc4ecb68eeaf3104f11c8aebf346d6d35ce6acdc520099f610237b555361b7150296d15988b269e6da58bf0507a5027de8943ab37e11695f0a9601f186f5494c40f4e0231c037e58aeec5368a122344b5cc75e4218ac0845c62ffe697f18d7a241345c0588184a033abba2bf44a8b4c71bda8c5f88f9301175e0555662fa975fa2e952df5e8e184f31011c4314b4ab9533d6966a4b9aa298d203677db1e71ac8e5a77a7cce228abfd65aee56936beb62ae8ae59c765d2cf3d6e9244debe0d9a4ebadfe95c95e37ec31da06aad8a035e3e387c5717deab5ad6ced93ca8db2854b9adb0f9a1d4a5cb4c16375a0f6b1095d94acd0f2edeac49404e012a645cf13faed912dd8e03fd4ce693873dc806e76fdd0d2f5eee07e7efc526b66600e76a4d9857733b2eb241ca60335acd649249555aead730ed25a170571ca71c8e72d9b9a51819d40f3e8a3162bf72b27cc07fc8a8c5ef29599ee5b136eeab48029f29c9d6ed1bb4cec989ece8cf03ba2eaaea6915fc18f34ac35f4430c2b6443d102c255b53bc4f7d6c637343b76436ad871452c9995da855cd5e4dc51c53417db35ca3447c95304a5f15315eaea31cee855bde5f82ff3b1c7a9015a6444ada1758067f9dd54f2f15a60376f90b3e44b48b934780dbb1f8812f9f583d1a3445ee4d6e22ce2cd36189df36edaf7455da4cf961d7d9c09afd34bf897d486af486799f3d3e51ce2e11f730c75ee41b51b263f72503f8ac3d77bc2b3bc862915bd8ade317dea7dfa193fc1d44e7645ce65b242fce3967be447cfdd41a26690bd7cacc9972ab71df28606f181eb3647200ff8160ea2ce816a6b76004bca174a0b8c3c53496cfd98ad454f9bd6da59d2d93040f6a195404241fc4dc3757e6ed45588f74eca108e82ab9d0040de03e4df24c6bf9594148e28ebe4eb4307184df86f0e7b9ac5ad394d3ef0c78d3fb91a4d023899446e74bd014ba56cf6ef2f2d41d334a8cdfd9bbfde33b62611f9a38a71d6072979478df9ec0911c5b180652b32eae40c17e06d47447e9827cfe5b13f5e8988b98b5ea50feb46d0dc1da020cfa5be5fd57c852327449c3ac148a3ef847bc2dea54e472e4a351ee44374212d20c33583525184223ee1be9d424e8fb42c16d3a294af6de08a89f382f77bdcee1a1af7d608b50107a758f3979a533a791b8d04afe024a0d675dde4ae14b3d3da4ea05f644054424fb998052d0a8f35a5dffa01144f2e6c767e376abdcc32915c9aa3b14fa4d5ad80a318d38f190e25bf9b33003dfad9e990427a8cbb6116210ac57a9f7b22a244d953c7d9a2fe3fd4cff0946604b7beeb4744221926b6ff4275779f4a120cb659790744a032ccc68dd179b2c9581eb5c308dd03588dd613ad74b905073383a626f704ef556e0d90edf61981ec454832e396d9cf4e03d076e56ee404b052664d48b08597eac595e27c20172fc2a6d99430c446fe3777b16f9696b31bfa4cb478e6db5fd4b7a1d5b568a54a18ad31c3439ed71754c65750b4e1454fe7bece301ef4bb208b98dbf3373a77275ac16f41496e668dfb81c7c79611c09dedcb8bf3170cb9bdb2a311ac0d3ac7f858655477ff2dd995d1068685bd8384516d96d46cc15591bf2606e28be07e3cff18ab89c55f717e1c21a96a4db2da9e2b2a6a0c99942dfeaff730bc46977f8b07d9881c3648db31f2c8be1c7544b5e752ef5e9a7279e256dfa7cf4105f2a1adb791c3aa193c0988aafdb77d1c884b725873a24c966ef5ee828b851cc9b41d1e7110eb348fed82de23405e54a2f9a4976349e88e0f1b0eb0688db0f7b59c89399a773a66741852e8e80d8ab20a6b7bff267dbb5a02c1707885888c7145733cce83f4b27254872c7bd54c7f599b81124ed0f979cb01a2aff8c65e51d061f1f290c0374ba2fa8ea13b5c34421ce821a2e113d9a99918d412002eff3caff3ac6a79d2e7e5ce643150424102a11269cacb4bc819eb4b0d3189cf35145964a6f17461de764221a8970be2a1fd2f9d25666865f4dc218553fedb4a814fb0259d6f6e4e8de18053e1ab86bd0548b58d2fdd77b13c2d54dd355ba5faff73a37130bf70422aa5deea67a047398ac2693197311d143466f66fe9c918566d51e59505d702b78879e6ff3b8ba29dd63dbb764260e9f87292e85ec6536fdda3848526c2b144357179600d624404b0e540b854dd55e064332adaee0c58b24987cf5bb12dac5009c06c96dc8f2fdc0eabd1a03b91478c80b9691212435cc29370a34aa07212c538b42b76b1a0bc7e9f41237919948d3eddfddc5d99f201900013808a378ab543974423064f3b50f5075150cb4330a9fc0e2e7331bd56f45c82635f8a1e23c5c9a91dfbbff90f8cd0072b40c185e0c3e81d4ddf324b259a6819ce993be02416f1d8253f4601532326e22c637908a8b2a09849a10391c3d9e886b49f8c976ed1b6f0f68dab75e2e663a7bf944bfd2dbc843ba710e171405004f25973e401cbf26053aae0bd9567dac1a0b7c91da185b27862302dfe0654294dd79e82e4c2cc08feac97f39c8906e3e859fa6b2869f3cc707f46d8d6b0a4d9215043034f34acba80ada6fe27a52e0e441b867f50f719e92895744d3a13326bc022f9714a3ddffa7583b610292399c147ab20270376971ea944a6474c622fada401e34d353eb8c241034f201ada096e829a01792a079ba25c23fbf87333f902cfe30bb976be084299bbab974136b57bd856a1fd567a0c5914c8dcb60c3d0261d9d3e590f2bb897c42259841e6fa674bcce8b8a9d0aaa47e57c4dbc00b1890c88a02c949e46b4d9a449e278061924c9c5c21a32b93df7128861958f16a038445c814fa194317daf82d33e57b16ad34655ef0a757bf34cacaefc514200df8616c200c5c2eb19bb86d0f3609a808ed5ac748eb2a52206c5ab4781f2eaf714dd7d70657465d36b12c0a7f1aa2a22a0f278be769b760bfcd4544e7baa51b2517af35e68c0ce23b143519a62f606cd7a76f91e73d4f2991046d3bbf0db886e01082cdcfa4876e95bd6b78d4a78463f40a965c89cd73af5ec9fdc9a4fad9ecb423da981ad687aa5d628e712c7a0a34b028374377eaf28ccab63f4e09dda2e7560e293a7d1f7f2c69f6b8f70eb187598e6ae94f49a75be62f5ccc0fe459d3ee971b9944278523df60461ff0c917e72dbb9598aad284c1e55d6ae28bb8812caa8ce8a681c20842b0afd53828a2acccbe8595b6db95b2ec60b4173cc513a8d71f9f15ee474364ef2544eb6727b8c919858e95464b6e5a94e6cad2f032b7f979ef62f490dbec8c0aa508b5d2d8f00437dddeab2a875e4defe362e7826780aea24ccdc0f81d763ef4d3b329cbeffdd9870646e2bf2592725c83b59918f4b29877c7d774c8499a62a5d227ca8772b2fa063a583f97456edf1f0d491dea9be098558b0647413f35bb0a7c0f88863c4b1f08f26bf185197db5b68675ab0bd0128ba643b72724d846dcc6f8ad41aea0b92f82bc7726473451ab323bc4b97d0ed5693adb05901f1cd2a42f522e0e0d65c85e58526e2eff9fdf85896f085e8429371b6cc85062480c01ed539d7dd99a603d8916ea7d0b09e2ed3059fba11cc56da479c50ae2eb311cb754cb8c5cd5b085d184a380100660f826acc8ee616cd0e633c6d7def0cc6cf87606ab9d92d889258182bf4e80ea4a7817af54aaef2a9440c0a0e894ae9a8405ac467a9dceb0428e8a5baff59e2c52f29a091b6c2257b9264ca0ce6f1ef9a39a206ecbd8f55bb628e3231eadffa56a0cfb0d2f67212cd55bda968fd12446c5b43bb5fc29342c576bf5d665d2748611ffeef7588e8190a5ed5020d7dbe162af91e752f925c03439faa907704e2275eb7e35773aa2df8a518c1a5910bae04a6b9714ce6037161d3d79f29e13a94840a77ca48895a433e223d0502318b28c957e18361543b8124242f55494ef3d2c4ac7584ecb68bde5f4283cbf3f7d12abe7410a51f34ff853f4fb10162831d132b4a8a3cfec77ffb18cc67945ee5f777b6e4cc7f0e11ab40b4ac51bd01efd67a5484a15af282dcdc303c5fcda53ddb4dedd32ed3404c2434f1554cb701626a59861647dceb74215a05af14abe010b5d8afb5baac2d0a853e31064d5e0b9d2db86ec7ee1d5d3d8e450409e16975e8ea9b14f5d8120aac7d249e0df3809f867a7d0f11ab3eaabe9a330e393ec41cb5a08bbc5c8ed49783acb5f14a1f3b4898251cf0fa84b02d97a0a25ac895457b34224288abffa109238251e5e04e6f177c7338e89942a1842f0de4a8667bffb3120f28da58aafb186b8a6132c44c2a1c1c62cd2c23d66633c924957192add956dca04b199cb8659aef8a2590a40dd011611ff93f52b45c3a43e0b7ae8a1ac1ed80d2cb57a859c6214fbfbead562d75d1278dda480313aff4527136c9ff2ffbf3436449b2dc0f2a76a7b6c3a4fe7c68b85a94866b747490ab4e574086fcf2730aa55ed94157fcce9ff7fa04ba704f3b33de99479fe85525093f1d3bd58218fe122a4dc5601b2c516c59865a4e039bedd219041fdf93091ce6f4713e3ae1f8a99a869e847e6228113316f1bec4a8d7386c78925b48411d597ad33ae5f194300d0127e611618661bd323c43e292c10c85b7618518ce7faf79cc1865b2db3c4aa6ead2f987c0323494c2fa23da975834080a1929b070da797c58baba19cd9e09c58a4cf352bdeff01065f4aed26853105bcd659ba1f3ef3af082b3b5d547d37bc3465a96cac7216e820aec1fa2cc62c4cd98fe93121a08a13c1b919967dacab2908d35f10ac3ccc4fd3e821623f8013c38b3bd2b069ae3e9bffec3bbadce0b65db49c107b1a655a52c8ea70dc8bcb2b806e8ac69b9626a7e80c03098d151e16a368d772a7f9f55a01eb5eccf55934dd04783a20efc092ade01f51a0813e8584094d57428db7d83262ea194b8e672675cee62948292c538bed942766520401230ebed19d935ecd45ba01b0e72a9fae3e8e51b14ea859475bb55a8e558179048afde9bb58b9be36059e6f0aedcba53bd7aeffc7a002bc242bc4d1beaf47889c812d3eb4bd8bfce50ce3a70cca0b48f4114fa6b03fe18e0fae301ce706ff338cf39b19556fd6ca166a6927cd19dcda4b5d0bf419eb504c4e3d6452d9d81e4dc638b9a534306e82e9497e848029fac9d9556c83e012cda57df0eea360f89cda73253666cbc63125068ec4f7b72f6bc4c656b2dc850152f52b7975914d1a18c70ab18ed9e2d6452d59a9aa6cfd5350fe1da0370e013e3f74af79269d0837d9d6d0932c67e2ae279c264fa0355c9e02309b5b3892d49a5864a5a527b3bbf1a8f06d3723d47befbc6cdf1163cdbe5f1c7ba7fa74cb21df73d963e6e05bc866b24e664747cf3bbf33b2b165cba38f56001b159ce2518d91b0da0ecd5ab4802ef6d3cf39a6fb1e45d26d473479ef25f8541ae07cdb4aa887d93e4ee6c626b0c7eba1ef86c4535f23ac23e7816b2368ceee0001ee71914a049253cbff1afe6a6675f3c70ba34f3d3abb589f0ee4e576ac36ad5f1f4bd1810b15dc5c2245e33110e8ff1901fbb5a6fa37384ebf84126c75ea04de639001332c851eeef989d8b6dafe8b01025d02d28847ba1600549513ff3fa891dda791d9ed34a1055c15c8b22343340e58321ac9367c12b2660f5337c5933e15415c5b73ff534573f57707d3d1968f8c3736706146803de5b6ee4f537dead988c5287068cabdd7afd63beaac39ec14419ead388b0120bd02689de7e66f893a1a675766d09c8c963708aaba3c0cdf59b5897d8f540fc737ef834bfced04f09b5f8265b16879dda659ef9917c9a0ef3426a70db827e78cc58bfe1d1ddea1e01b6ab209696d10e843cb4d924c8a43137c32492ce119a70a59f87f7d34136caedac76febc79c8540ea61f1ef48f8ebf6096470bb0aaa5d94344113bd14304caaa0ad8c2a799eb53cef776212713bdea2508048969f48fdcd047f0cabd69299562634a55ca60459d93a22c3c878823bff86c516798336f6a58dacd54a7f7e5cee1942db9d857c7f287ff9c0228a16b885209e9259de557fb40c352993c9ab03fd5be0e98a299a0759d9505747d9c452750d0f9502fd7251bc8186fd23c2245c8f2dca234d28d108471decd8fa4863f262c7416054b6e18eb9c8958607430e465a65d7af672dc381cb736a117442e7803e445a352e6e637eea1761303aac375619d5f8888ba51b4b3aa013d33b00a9b570f68d9b4f47f31767a2cbe7a27ab794a0c2792e143ec6437475645e291d559a1672b7634f210e6698fa19aa25c6fcece9c8ed6d619fe5d5a6d069eeebae00358b1ff7b501a7322f3b0076277d8ea880890233c9ea8f95dbac7d31b00aa6cfa6c9df4049aceb039b162359a583ee0c46cdd538576dd1e6b2ba24175045b60832e686ce0560507793427b006f8aba0ca39f495dd227554f740a9bacbd67e5684c808a9f189be7cd915256792792b723109a5979d660ef0feb9332a847c4ea0f489599a1b4b2d5429b53db265dfe6584040fc749dbbceeebafbf9e2d9ae91c985ac96b8d45bd939a988a0bea0bb16136418be41519e7c54f6c753ff30b7b255e3c929624b8e12778434093f4ba04706999330c2e3cb1b5f25fe167b8598e963b1db3008853f5720afe373b43077dff97c053be380e8385d62eaf97e8ce337db125aaca103db833f0333d8d388dbd65ab7fe2ef3b45bc454b08775e28b91a785c46ae98981fa9c09b1cabfe772276a81768a90b8474d3da85f240cb1b1a3fd36d7016b0323a12358a857226d34da6cec1baeabdb6435c2b5feb598cc0aa768eda9d7afc6c2d58fc6dd6283021861f9cc8a7ce7133df109461bbd6d927443f240e251d26a0d488bffac848b18e6aa3ff9c3ab3c8c05f1a88428ebb6c6c9a99a2fdaecf30854ded5c0d1c071e56364c0f394c7ba41f1a87f4b574360af72401bcfbbd32f401c5e0e74b50ac3548b56b8f795d1cbc39a73f2ef889d5c7df1a09a8d3ec072a6abad17bce718bf403de546b77","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
