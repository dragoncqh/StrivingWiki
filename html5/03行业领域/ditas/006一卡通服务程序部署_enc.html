<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"41e3568ff90cc164d907c424c7cd4ab9c8c49a0a455700cf439ce7faac9c8cdedd0b68a3e48dfe5537ac74f6e8df52944a89dbb8d5bb4a66b81e12b3923983e2b679212b77377b0123c3adc9018e49528d332b78cf34e14459a8349fdc87a7682959e90e15a327b504e65e36c4c19ca4bdfc6b3e2692f0f3d7d50cd0713533c9f5dd8f1fdade67afcf4bdfd047bcf5dd1dc17d05e38f7507fd14eb690202d5462368c17e22053a051347959de9ffe14563db7617f3218ead6affa6dd7d81d1f1c583eda0bb76bc4f5bde485f6ea753095132b2f09d76ded6eec6283dd89366dc5235017590c68c12cfbbb8b5d7f53afce80b8b6c0079e20ae15a78dc0a681721547d6ddd75f7ce1e8b182198602adfbb2fd0126772ce7888ac15420877965f54d3d5e2b4189b01e5ed99086c89c2a5b25d08ea509f3c071244a0cefe75c50657f3b83e6a5d5aaf3309a53d07403d7ba9577e0d4d984bd993b5eb58001dca84f13329ef47e90d70d1d05bd5093239a979f62181aeeb155fc31eef02a28e8e860273195ea7a20884da33ff6201cf7627a57b92a0af97d0ff549393f8a6f1d6b5bd55c09b84e968ad147d42f547c160fafd7a3a5836843048c33676a5c2c83f421d310039ed37402e8004b8500d76da0bf9a41e7946d766c6a98ecc02edc81920906f1dfe744878bafaaa5375df8080c66238e0936bae5f8e010ef1c9bb77d3cbdf353a68e810c0dcea696975d4c7391a2108b2cb0b29454c2163b2e562b4f23f545bcc0425fa8cbb093ede81dd88ea87518b321952fe285e4638f487eb93f01633a358fcc534a73180aa32f1ca2bc6c1455c79c1f48b654c4e9c1b2f6d3c0c4ebe3e1c67846b70d2823ee1ea546b09f2114a9558edd8d6678a4ed8188be96edc9cd95b53e6f4129203258a28c88e8884bc7b001fe6874de19ecbd5482851e97ba07f4f1379efcf9d7bc97f567daf2e0c2a7d26dc0d79194ec10212055c8735f2ad04cf4b0143f8de40c98f222a339902358dace171b521442bfde61f275887cf590488d016943d9a30455cce4437c06d874073872ee26006426d1e3b1eb4554257947712377e786b718fa3ac67c4e0ffff4ffd2f9e0a3e8017cd910ea9320186630f62c6446184e139923e083e81117e7c642c6fed66f3e82a2a16e91e41c6da6219998b3f35921a691ba80fe723ae6e6cac26771ded1691b75cd40954c67e9e4f0a8b4625202477225daa454d5530e5e6dd8902d491f8b35f72db03df79dc2e3c165edbc18802874369aeaac4f5d2df257e7a92aa083d9ab9821f42e68d6cbd6e5f1fac738a78619cd5baf0e39df03cc6aa590bdb50a53a32f2305b778a54fe6c8d04898e7e2aa6313935e80e6975af0ca8c6f64163b25543c9a0f36500d8c3ac384ba7fddbaa4dec7c9edd9c265876f72731da0500fc04cf471b7e09abe7a5f0036c4df9242dddae35638d4cde174daa14b8f8cbcd2c3c0a2f473f7854439f9563b39903e9f58fec7d43375f655fef959b54a2e7377eb620b3729e21215ca8f53299af7656deba80291c5667723c056619e826b93a5abaa04e1a5f21c4506f164b566d5414329acd25b078dec005188613ba0e3c3736d0234b795b1784ae6dd4bdfeb2a0762595fcd93c36b2a04d4756348eb509829349162a3821b34793f5cc67fe3478717087e95af7af1fa1cff40b11330211e51972f599130bdcfb78f8031f83ecd455774630514021d3417076fc0bf27af84fd45cdae66906d61323a319904bd3b0434b76aec56d4ac476082922d614f5c4d488fa4416546deb043ee7bd6342cad4aa21bfea2711b5d31d16d0bbebc1cafa4fddaaba0bf008cab4184c9ac6168ddb738b43ba3a5aaafdd6c060cdb76e0b36d31d4dcfd12685710f8f16c479420c8d0cae80573645632b3fb304f23b446be76244f6ee221d3dccb48d461b672fbebda8bdc099656213913754e10bd5bbc1fe103826ef437aa228c118f720722e637f5cbbdf3ea7cc6f27dc8da4437044cb708c1795d31fc306c8ae6c7fafb3ba378a5eaf841bd91247b4188e2056b7ba840a6f41903fefc949f88b21eccb82f8a15bc89a93f70e1a270b45202656f1fbccc1a04c19ef12c3695f78fa02134810989d292608355bfaa6b5dde8e09fece4d9a514b047d961ea9fddbe4570ecea370adbb12d350718a250dfab02d1df1a8bb5b92793af29d042b6f0a3be5f6f0217475b820935a51074968bb122b8d2e0f655f04b3819519daa2b1f6219e77f5606aac5fe9964eb62602c02d8f745a65a57dfac9e29c4da8d48a865b3c0ff17612a0c0f740362332239f972bb5d58c39a06205f6a48dd852620aef295322ffbe24ba9d3f430f6d095f772c4b91333c1c1fec8dd553ab8a54cbdbb783d7660564d8010431d80c5dea5f7685b1970d70a777bd1329ab4355b9ce06407209fbe700d4b908c3087bd69920ede472e196cf688394d8ce3095b0e963e1fb0b23d1740249a6a5d3b9029fbfaba4dbf6eaa70234c3b4c9899803dcb88d8e320c50fe39602c08a084c805837b873803b40e48c26110aee7d9c5ee33e7e876b2f7867b19b9671cc86540229fc56b15c7771fc1e8af8ddc905603c9b0e23fd59b45dbe575e7fa7f1a0476f39163f51e41d3a48c6492c4ec3bf2a010276dfdce13018243689fab3a11781626cbb8aa8a6257bf9a02b0ed2302cdc5b3605ed13b2f1c3f88b58cd3aa4b74888f00aeab375f9b6839d94b6b85aaa5b2f8e0f260fc95f629b99b1427313fce9963b47cf5ea33c556dcf7dcd55065aaac2bd8846b2d178d56ce9b72d087ecb270256bfd4514ed56eeb0b06e78bb4ca5909b43d1df2ed684d92d4738c3e657533bf0b15720a04d797e04d8ce4cfa41dc34f5a7dbffe01dd59554bd5191e7318129799d00836f0d583cf1b920699fa0e57702af16d264b231edcf7ee7f658397b39c9f35b3be41c8a572de3aa9e50c67ce07b51313484f4f49ce214f2f78e84857915e0dcbb46575683e61e931a3101eed9077b453a05882b510e14c529658e6fe86ed6794110b1eac12bc6a394f0db6afc67e2da0e6ec5d2a54575ef67ca5684e3691fb5fa73e86d79b8572db25acffc9abdef6ee03c87c6298c229c6e9526a6ab02701c662d17b71c403a498c19fb47a7182891b323bf99f6900a39ad58651296fd988cbd8f200851bf4b41efa3b94739a5259c210572f7b00539d1c35ba20668b2b022854ffa01e0a5157ba066f386d2e7a2fcd3b65e0d832476d9dba3fb1ea8cb7f1d68c6899322be052943cd2db801c832e3ca770ff19f4abbf42beb442bc84fbe6a2266aacaf84404fbb5eb7eefb30894aae6574acf6300a52250e3aa00e92ea2f357b5900ec6ba4bed81302dd3182a75602fe73a6312031f6686547d03b9c295f50152603f4f0bdf48f3d27b5c5f838acea5416fa198902362814fd004dcecdedbb28a273b5bbb16d21815cd06e0ac936e6f0e44ba43a2fe259b5153b657ddb6ad37adc2aed8e2c62542ef93421e21ef65577614247eb9e631f032251098654a0fb7f4ac287eadbd7d02b5cf52a924e0226b4140938b7d2003cf1e93a15d915a09d70b224da4817466cd3e8b90656846a6edf94787a2b8b65fd3357535f4b0e938d71c29ddc59c82e8a8ef62abf9a6f3def9a905447442aa2b27a71ede527100ba71958f3cb4b933a467851fb0d4b3c2dc748fcbbd1257fa304150eb786e17869a3fd292aeab9463105fcc27de0e204441f467e485eab8a2ad2fddf07db0d902d2d605bd75a3ff2bf4ec68e3eb10c4fc59dff4b1514802d77cb0a5d16faafe045869aa492de8ff44f4c19ab93a5453f7fce50950492e4a3b465264200ea47817f9f12be4e5af70cbc64b717f7c113e88f0125bd3d785a6513054f9b7c2defbf6cf94812ead530c799637d4dd19e4cad1c7c09cb11cf0da3b8b889b711e58277dd349cffb310491e828ec408a84a3fa779097302466e3d63ddc0fd10983f5397bc2ac9fbb3781b2206e15aab471119a3c2548b252b092d2fddc1bf8f62a206c2dfda11607b270b0a22a9ee22e2d3814b2054b3fdc9a447f6a7a97a3ba451b6ef0452f42944a100d7b5e74880472bf512bb22517e065d0565abfa155771888d5c3303b5aaf02debacca8d9367379d57eee5daa6717a7afd8b7f27e394bb3a9d165bf7d9a13184149809b69c2d04b46e50d627472f997a822a3210f21d7f1c0ef2e5898f8e95ca5b4b942fa28744a9ac9a54cad0eca4a5ac5ae98f2f49c68c7cffa85bde47471e7cdcb7eceed965f2e9bedfbb019b2b837ab861cdc373e304c42794b5b4ae10b4368b2146ae1f9d6d15f1f64d18c61f2079551a5aa5923255a7080011185a8ca667a363e656f49c79a8c7ae1056dea28d416e722d080c20b4b88245c47b00ccf1fde18f375e4f46494f6e73418163935c4e77ae70de0408091a322ce6975bfdf897ed1bc74de027988b367a4edd06fc5b3108e06409d10a06f947f662abdc7d5fd6c9a5d554bba491ffbe9c04de8acf82cc209a65d9301dc88406b0d7849f7ac315a88bba33a5e512902589bd1663c28eccc997092471c0d67773a79670af09534200034f7aea1fa7731e037ace3bd4dd849f1e5f5997087298ef861e130b8ad3438f617b54d79c01c880fbce98e83a5a62affcde6d23cac601d32afa8f2468269f8d3298eb73c56a9b7e58a1078ae54e17ebc5709d8ab20edc1ec7eb97ad7a63432837e67a21923d7331bce6c52b3f684abdf7064630089c384611eaf6813a2ee4dd043e5ab3796fd553aa0fc1c923d110425c27596e30875617cf5b8fc62bf57d7d3aa59b9a0a1d9204485e2a6958f5e1e1c84350eb736b1f0a3e629cf4ff1a679c9d1d50aba8df841926b62ebbe4bb5e276196d13e54993284bd32e3a6f5bfd90a9ee076e07f2662bdd3525645a7786b66c1a03a6846727944eda543fcf9f88170c3876a5a6caaea3a5ec46130a86d4682c5652a9ddeccffa95da140108478970ec5f8e98461565e377c11dacb498fb29a2af8f6822ea56bb725736e7c0d7b3b49e66e6787cd1aa745d28686cb952f7caaf86434a62de7ca7484021c87de3406022874fc7309ac54cc8b55ed07d61ee54e84ccac0caabdfcf04ffcb981a7c3f98b89b909244cd58f41aeae4984a138544c71145e6c259cbf746a5306fb3741f4a39d435d473fd35d332717b4e9be35849a0426cc974acc3abf4b088fadd86184db3ec7e42fcab8e86f57e47db909dbf5ba02e7afb5c93275b85c7112a34012115efc8d190deb910e711c1875c5eef1b59ecea43b64011fbd2f320ef15fa7f75753645f9fde841695d761382d63b3fcc461a698845ead949ff3584db8a4e8b0fd43d5a4b3a7bcfdaa958d8b74d8868c050af10f6874ad6b8259df6a8e2b63493e66c5aaf050f8665dabe47c3b1da4d4684a0aa92d5aa8b347651623de78268be469ca9de4c4bd3329e3c284890823cd4d954a0ed81d8ed37d511c770be947600253503264c88f31b78fe5fa308a8ec2a2d69e69933982d38c1dbcb3f4d896cc5e185a1ca1091323e5147e6fac9f6b485307750eb610aa5ba34bcf84f2a6eb67d5d15706aec7072cccd2b9688cd6112461ea7acffafaac11ac8c471d0e33ad28c8c5f4d2b5b443cff92033f9fa74d4e55b960a04c85f4af3bc12c013d60cf7f6778f58e4295cef1c8b50c7181ed54352d64230b9088b7301604d9cc8496d6bf4cd550cbaa3a884d66365254bee47930df66e4ebd2aa97aa8f4ebd72d4fef8936cead4521f3000838d65c54c678010ac8dcfd131382132b75b48d5f3eccba301782d13a952e83d1db90f096873f0ce1f86e5f4878fb8607e192149e6c781c5c8daf3e4964f77da2299ad3bad02de2c23cfedc6492b59ce05f63de93a9626ce818e48948f6ace1e94ca51dab900759b5c221099d9eceb0441bd1bf7e230cdfd8c4d5b23c823513d336ebfb661ea1cf7a2bef6aa9c13d52d5229657322efe508663e4dbaf96b8f7f07a283361b1b297c5cb30f007f35b79f7a56c36bd9e039dd2881b3d9bf31593466f90a9f141f1d49c44d267384ec11be72def3330516a4943e96f512991a04ce75b3e71292fb294e066050921e9dad6b8f67e35c71c4fb44af3063f518040c80cda34d30ffb4f715ac2c1153f708ae9796948bfa0211c15ce68c1d3c8d80df74a32b71d90d94c78df0b5118b9d46e20e3e71250d9415fdca1182c86ccb9bf3998db6d9c6d79b09f31fca3e09c8cc8fe1e4bce745e29970d21c70759208b09c08911b1b9d525f5de9044e3aa2a3ac859e2b5b5d85a5eb177adfbed8c734818a9ff57fccd75d77ddb01998880cdf02e4f241076a12b8e276739c14617353452b5bca44e83907fa760c1d6cd6d44cf430797646286b8be0bd22d5e21e8e8a4694d87d15b641c1c2a1316a62ea467d49dedf93b2bab8c12ae8575a0d0396a1cff02165891f5840b9a3e186bc5e0c81d105a3399b1aec3aeddaecde1754162ca9b3ffff3c0aad4e9eadc94167045ea77e48fa12111f006fd72e7816f5595ca25007f672fcb6bc2d4d0d5711ba5b2798813f3850da0e72bd8f1005eafc4b33a621cb2aeeb112c2031f0e8aa9693adff21a19d43a56e98999fb465ec57cc590339fccfdc5c490fb70ceaafee7754368f6a8447e4e8849980d48735777e6b3b2a1944429a0280e41f7e1fb8f72c54e4a1fc8a6c58a4e4dd44ce74c548afe405535a1de179040c0b2ed17b41c671f5a6a8987296e6009bb6f833ac27eb299a97d3300d55e1f3b4214d1570d92f0bbd65ee46695fce2e6c30dd387e87ba9b461a7b140aac974239b42ac250fd789420eae481ccb53974021adb7be2eaeb38aecf017399461f3c0e3a94f26ee9e6755194d7b11d7889f7ef5232e095eda335768b3f8958d5a2c2335da5522e87a5a9575ed023689b1dfa1f95df17bbb3c668e630315b13762f1c45704a74ca3bae8382b7060534b6009a9d3e285cda083c0bf466b8719ac3f56617fa79e54711719dc12f3be435312d17c304b59bf0f765afcbbb90c80651adca4ffe3a9a1f235445def959d5cab53da1917a273536506baceb47729da1bc478aae6ca20ccac967bbca4d85aa119f8ff60944114857d2f1c0ee4fb2f64c5bfda846aae17275da55dd1131363ff1d3cb4c6300fd9138bf3e1ec19e51d53f50303064f29a969995c80526cf542e18132c446d22183926f7bda5dac97863e7574568681c302514ccd4cc07a51ee55e7aefa374ba27dcbe72245306cee8e2d2976cfc9ca894f41e1366a28ac0b0aa05aa786fed4a0d7a5b5227defde4ccec71a9bc0ed46ec7f92e43f74be5850254874674480cde9f44f052a66eb1036102b1747918fb735d87de9b5ab9d973f70ced9c0a26ced1d94a26d927df5b71e5bbdfd58be0cdcf1a9f7e8033eacace5258831405f7002638df370cf9498144ae8b3dc9fe3d2bb63346913ceb8693f2d2660e61b0758789595548a77392d27412f46fd95548193ce24564a7da7a80efdb8e53b810fc0d4cf705432ea3275cbc8616237da1b57936b58084ed4ad79c55380b880c4d25ae13ae014091eafa020ca2f8cceca68be7ffcef8ece4ce46d3c3cbb93f7c2ce6040d38b02460be66e9bf84a2e38c9cd33dc11939c302674b18d992707b00d3d3b1027960870f3f4085160378ca78f09267099bbc472bfb1d906fac42da400373bf780ac60f9826f8887c87ca34c4b2ef3730736e95fe08da2f5389577d390a8db5857820dfaa5e2a4ab2a7a5c0a2405f1203652fb67ff7156eeff55453e74a74cb8a7a005e95de31bed4098edfcb6da203e4357656b2d53fa8d0d5b8ae2bf3ed0b496ebc8fe6732e04bbd9224813dac4479e890c6d839323b20e7236fc1760417e81fb3a6a5545240d53c4379ec6c29648027704907defa21fe4069e8213e2904ca73f3d3b11aa13ecf01af2ad276a8910bf0704bc9b1e71456d09fc1510c4ad59433d023a1f67047ff6c7f3279826da1a425015497725df336b3b154ee1592dd2217d28718894df65043d2576ae8bf8f39fa3f2d2baa562f418829b2462cdbe3323822d23b9e1b2679b4c66d2624718c52b06ac4cc04f1ce1431b9461804815ee75fe612d667c9d1caf650fec22bac9b0729c9c2dee87c96b69d02d6c4a73bc8ef42a53a0d36331ee604806d268453ed5a1b2b9b2f5250880da82ca7c9d3de589e5cac7cb2821175fff3b02e8edff74e1e175dcd3387ca0f5dc74a57502647d699a69631a9c916a7d68435305b00eb53b0864bce42ee01691f0ad458f35f3cb8ea48a033509f472315bb34acb6a544bd08c250f6aecb52c56d9fdb040a12e879896d56a4557b1b9b844038611762c66b1160ace7cfbdf7127fe13e84e85acf4c23a80e497a2d2476b093417391239d32b67df68a987fcc6cf673d495187d47ba739fb5ee20ebaa98e92478fef6eef388a12d0f6de1ceead38648efde699d53c4822173b0e19e3a613670209dfc130d958ac9b253ee319aba3252b8f3e59dbe68ef5d6440951873999a195fb077110f842cbda8b2950eab2a0858915936b9465c9d81ecfe07073ce2e8f61db2cd39576e1f1107744031ed0a4db4913a23b808cebaf04c987147890cf5d31c3a499b3358de6f92fde9ee9ee070a399cdc45011b5d5802e02782a022b2ebcc680c3f12eeda85fff542725c77cee667ac696b789d9e7e64205abc1edb7fe79221ea170a7bae301e2d74df4a3249d1ae7631705b0243cdef71d7eea2e8143310c11065f0b00f605bd16f41e1bfc699a250b7448fbcb62a2f67528e9f8aaad7b51d93afa4967e6f785d1ebda48fa380fada0e30e703c9beb8eb12663e723b69a3b341e11b91a161336e9d93d8b02db06977bcfb5552b60957566af863fc2c0bb1ddd7f989b5e6216c33d85eadaaa7171182fc056d947291528086acafbc700c6fafc67cb99564afdabe842200c6cffc4599f9f6b163ed16a7d8699cc93cac0db2dd75fb8d805285e7a7093c2b760abb0d088278225c68f15ccd25dc7eedc9619e37dd41bfcdecb345cad0a8db878b2c78c0952bdfef78171e6e5e8f340797968748dd34540410875af1bace550ecdd5fb94289e83b91c0405b7e0fe4ec8ccf36e9293866cd4bb9d382e90bba7c886f01f8fee0e0a698234c4b68e2dc7fb91ebb1fa6f759aa5b7e5bb894850a9e45bdd88a7129390daf9551257ddc6d8c4049804ba700a65d206c57aead0eaabd9387a29295434e66b74766cd0986e46a1d0c4c356ddb20ce303448adec8f88ef332f51d5215898b2ddc644899896bc6caac2784355ac73cff3e8b8d01f69fb8cab867927fbc9c18526f0147228571a74b5652426173b744a36250b5a8fab94f492fd48790d57c205f45d4fafd63df968d13d8968e80ed72f8502de6c052964b1341d3808b828e4e58d28c662f44db44e5d9e66162b1280e50c9295408553d3fb9fc11d6583dd9a1e2c922b31558f6bfdc898afcaf875d8762a404297de0d18502e414eafd1c1742b5b1eb7fc736bba84faa335c560e45ecc9b21411ae517aa0fcf76ef91066d0c30beaa5c1d3c85aaf7458816dc44e1e90dffe3af55a2b216e35c3481d47e216e28ae771a6c6d5248163a154e263ba618e6fd50e790e34aa5a784fecbc500c8dec6a0cd5df485b1400f35688b83aa5d5f25631c37be8b5981903ae9270ccc0189697554f24b161ebb670bcd3d1139c20346cd706e399142a293c9350e0634ddd175620f293befb359d47ac9b14a32e3e2ada6c371bb1b741027eda11bae007e04903cd1ceb7fe9cba1953cf4de0d5e2300b8418cb48ac944cb8221e76e7a61f2e74ddb6fedef1ca62bfe6f81020677b06bc7a1f50828b766e88f5597d5b7f7c296c864b22f2a3854d237f57fa878a5cf4184d47262daf4995f8087e5c9b021094adf8fbfa12fd3c04664100fee7b428953e72815d2b561820a463de5065f65dc8c6e559cd8a006396e27a5bec130f7e1c21b25834b1c87c3123f95be5a22e012fe542eadc0e0fff7e8ef3f939329d856e78770378d387791c8825e5f28d061ceb4cf34eac23552317c213a720ad9317a7dcfab5192d5d4a5e75653d5e49dca752f9d124812317347dca95d5dd1ab8b069c8e45aa9233021797fefba02abeda060251de1bebbfed8ad97c49e3afcb2c5848491168f7f59d2b1b7484c60297fdad172cbca539a839419828e8f0150ecbfba261454318296bee4f216b9765c3cdc86b876b90bc882e9cc587624f28294f8040fac798ed1553cbb5e9023aaad79bd2e074b93614b33ee3223e78455a687579a0c6017e4ececc794d4f62441dd3959496512dc5c66d708b3a834685e98163e7c0b5149d511b55bc1a75c0ef801a3fcf21f4aaf9eff16e4b41e4f59efa8b84e730adc5d68d5c88031fa25d3c38f782ac9fc279fc09e2dad947d330401d915f9d261704d1b05e468813184e0d879875182af83fd8abb13eae604048f3f136eebf4c0d8e1a78d78d62c0c7542d812d73c084b4698857ac52b07a51622aa7239ae70d5e0eb95ad19dd78a60942fed6b1255733f8dfb5b6d41c9f763f57a1db93f97336eb4a508e64426aaf61e87a838b6f52f36fd969ff02060725f806b949d899573e83950e24904000ed6470a1adb9574174e6b22ba58227751446f6775665d6cce8c5ea32e5ee0e572fe17317530775125695cf49a6a5be498a601bcc8b8914019de2bb8714ffcf52831c5551c1bef43bcddff81a679b4e2e39804c61f8ec9f1e68c86d4218ee7ac850c134f4a9eae628d0cf6ecafce039c96fbeb3fa526a7ef462eb600b4403bfd2516a58f8bf21e72fdb57f97ae77979fe833725e623ef646052baec82e8c9e2da794dbb5efb0ac6ee21b0ff894e3a65503e0690be95856e77e5db83e238ac680c789812085f8a93eec5a31edeec6208864daf659f78920436c7d4d80128bd53e0eecb64ac87d4cad94c623a85306d22e2b0a5637cfba4d3ae8007c504dd1a84604a6de6c9e0495464a727f7433712def787b1266d7a78bc9cf75af7239c34dff49defa2ed66f5bff52190150543bdb743b347f9a5bea03887f53d852e04b6942d427d414860d2aafba4a074557f10a284fc38933934610e1524132805246ce417bc94cc0005e7624808cd710a726b08c45aeaf1827","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
