<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a6bcc8ac278f1607cd517dc32fd2fd9175693fae276a6fd6c814af7bafcd7a2fac7a5bf9d2078dc466a019a2dfc039dd6a57a63a0981e4f0b549104741e7cfb4a1730a24b8ed9c90f372014ae578da1cc461a7fd49d4f733f4e3b459beac20b5777f4190685f9525927af34b6cc0ed53b3005679ecddf122a62d038f5c7502c7445d95102ed58c777d4f6c26718993a9f8f5c0f982f125a9e5f78dac4d146d09e3571a2781d5ac555ea039f33d4b555c79c9486af5c2e739062433b9a982b4c6976fccaf5c0a7960f89651ed36053e7232aa0ce791c7d61692f8d5c2d5db32ddf5fca2d425dcf504dc8c2d5d56fdc2489f45924b400a8417a0c432dc9cdc13f4221d9f0747500bd439d05b872d5badf563c9a3fb09131e15a125158747ee01dd95b58d1c352354eede0106de8696e28005acf3071c03bf21ab38bc3650fd654c6e23d90dc90a728913542305ead36009dd295f54b76245d8314a61092cce8560fe1b84f1f286bde09f6b3ce679637d26371eea2cfe603b6981b5b03c44fae603621e7aac94513b2993c223b5991a56bd624f14d841fcc5d0766a906d35c7e3430d879f8770f92767932777edcc09483a261104aace060970f1c0d1790e43b6014621d7d2004dee99b12c741cb5bf1c4e0c41862819d6084ed31f84a1514c4aa1a695fab263767aea9ab989d93b342db61ed66562988591ea8f8d4578a2add5eecc660bc6285d8fd6ce0dd00dced66db010e07d192e71708345dc167d17f01a6aa06c86e737c303d78a0630f5ed98087030f8b824cd513944073bf78ee04b83d0ab1d747f5bfb81d7f7df010ddb8f9168da6f0554e7e3441eb44c58915d0e8cccc60f08f5953e9e44bdacb01b8d3e187fc60846477446c479098201d76953e3e4d211416070b21c03284a214a3af9b04c6db0c07a07d7b8e3bd5f20b04e311549ce28b4d02bf596f77c0a099e648266924d3d4162a3d3ec6fc1f142533c9fdb3ad257ddf95bbd985929e7ec71e7961db7a9108eb46fc4eafd47d2e428096b04d8d027f9ae184e87d0b6f60a85dedc19a6220f97fa2f138f660ff3c25476e0e0337f63930260ebd3e012b7dc66b6138bbbcdab66d535f8e640bff85685cc77cdc9282e25c69d0c13496344f1dca5cee0595a6d493054229834ee9a5f46fb7d322beea2a30d681564be30fda337ee94b0400ecc24097ce492d7faa5b9714eced298866e32bdf8e43048cee5204e7fca86d0f93d18bdd756486f9e07c5ab289166e277cbf84bb1e047dc1d73b56b65d815e1772f592d8b6e1e53f7977ba19bbf05a36bfc93435b652360eeca892ed1c69da3fac37c889f61234b20409d3cb15933050806ca065d64316d1859fc8d8f9c07c7a80079cba36d595c8c02902e4dc1d4750d498c13fb812ab81e73754b2df523aeb9133e93558986745305e3ac1ec0e740c5899d260ac5ea1013d1e121a8dc90497516656a5544dfd8240de4bfb591a6ed6fcb756a46b9507ec778987c5c2169d9ca73deb271b05b3ae9865c64692a932f0fc1172c34d7b1dee6dbf73b50577e6f4a0ddac6b9feb5d497d10438f3d9ea15da6b27cc9e98519d5b9568288a43163ffe4e70f45d88ea7edeefc5128b679214b329b477b7e6ac8774940552bb118507093483a7e90369b63bc006f736bce682e05af81ee5223a3d7e1a8788acfc0aa593b8cb24f1c97d480a6bc741f301309fc80349b33ff7bf24e5fb1feec26cc9dc1771211ba3e73e056ebce84fd475e37a83f7874afe2e66e6858d19d4bde1afbeda43facdc5b257da2b740b551d51b3faea0876a287b370d6cc6ae7fefd4d6b29284a3d473394e9d416d8a2f151907ed05941867ecf080ad240a54dd6913060ea30b74a7ebbd6bcb6911146b26abf105c64443a7756e9622fe2e8384e3bb1f16f6d0536627637800e1693cfb0951648b52148bb6f93b0a2e1a63b6c28e00801d3321608fdffe15bb12458c8dd3736453e5ab9bba211d4430378f7c9f9aba9e5b9f1591dd8af74089b2f88e35ebd25ce49b89b5114f1a2901b3ed57f7d54a2165fde50218169cfa0d9a17346a76f44cb1785b221ab4f7fef3a1cae98ade0aa9fe5b8c7100ac3c2c0791fab0a649573dc841bda05dc8dff7f69b45d909634ec7ec289c48970f1af1888e1a2bb6cb393ae315e95b80ab2d6857c572d948df9e97ebcb9ff4a2d805b437ecfa21cd9be13ac1ed39fd7134b0b3bfb11d9bf27c24bdf210051921b44ff9e0412ceaee177627aeaa9d5d001ea71becb3b6c72845b0d36422b7d2e3855914347bf74b3918c6d4ccee562274e3846e4843c3b93ebc357ff33115a35cc49435492326a35fb2b54b99723ec63a222655a70b74dcb612ddea171b8be91155d6d38ccc822445c3c43912864729fdf2371a314d5f741ec4cb2e2df9303044aef6959682b9f6a19b320bc1a08fef33327618c745dabbfe4a2a14cb87493804f5e807d397e50d24ee82e7e5e71376af8f9af38fc4ab2f64831529c5850b5b17906ddda8d9437adc445dcd53d7ce8db0cd4571bd2c147845471c44c6d8414a5cfa5123bd0eefb292603c35bbc4b4905cf6ba177f4e7699c66ddecdf2065ac683a057522f29355fde67e5ce81b455e549bb6841ce4308fff5f96ae0fe81817e26f245ef9e7c4391d837a927b34c4f3b36d1db8c50aa088f21a461a9f65063df7306cb3ac16dae1ef4fdf892bef197b4039c2415b5b14152bf4e63d6c833775d95fbb1f03a1fccefbf2ff5f57d884f28c54c825f2fdf437e47ed9fa897d757f62d45a37b8d59f3227efe404f19701942fb682b54713f298bf16f65120c497b698de627bacce57d505a508cf5be661eb7ff6eb98910a7fb3fa5273158062bfd73a83d48e1e72c821128855af71d2465d4013861c41975f998c0d07209cea195c60ae34b3812088f9ce6efa8f628be5d6792725f30a0f7c1dd30708c841d826939bec05a0b9c1f03ecd96795731fe2d28553f6a5c41185138b703e59641959c46fc74dd288365098fd712b75f6790b788a473db8eb5c826dac82da575c27cc17f8ef75f301fd0b9142509b3e4d5fbf1ea5193d311b4501e7ed29bead883b13d258cc33c3d36196d43449809367cbf71489a6131b46782f62cefc3b0687e26e83ccb74089883cb8024484d7ec01f08fb016e3c29a5349c02ab9ac0a1e70470ade4660425bc5c49cabc836c7cd59b95cea52b12241524f357bbc602d3d82500ad7de282db99274c1e3cf1b9eb9873ca825346166fca397b5b8bea170e03e595e0e6e36ae952f7208945b2b49647a6d6c3784903b2e78d7d6d21067af6b399483c9255bef8c8e3d6cfebde1f1a934bdf9066d9b9e4cb8b8803ab75fe64bab4f954575aa09c0a38c7cefa5bc106b30539f83b4f7761558d58079b3dc353357b6cf6a1b0c3342e65b2044098888e80fc4732f06d878036f8afe1144881a91e0ac3ed30105854d08f3407a1eae53115e11cdb5edd1e461d47d36bd2a408e33a9e0a6c1c6718d303050c7d9253bfa5a4401b384b87bed380e2b96562369e0c9bd8fbbbf5c4dee0b1e9b96aaff718ae592500d90ecdae38664844456cd36a8219efc6ca931f1b6a4ef18d1b2ac3358dbf49e2cefd5b5fe2f0b26b2006a00a994016ae13f487f675a4a37c6b71d7ac3a1e551e57010784372e61deb717949752641d9887374cecf97e2d8813c64ba14b478e64fcad5271177cb175760d3f122ba3eccb378154dcdb026d620b941205365d41ff2024d849c60b89c7b4f5ab637bed6217c27e81e94ae546b73f3eff7e9c4740ecbfcd1c31d0986ce71bb04ab041f6060c35d51b4b6bef6afd0f24220eeb6d4c9a514e916fc4d5b2dca965bc05467a1bc74aca41974b11a755c422942f73913b23ec16efe4dcf024855b6380e4600cd362dfdd9290eba022be89c26d9a2a907dfbd0ecb4b4cce714e6d4057fc865482b07545d55e697cf2649badf4fc0570ab6acfff951e1b33b3d7e292924c68d7f31f793dbc5044d937f510e95ec11f26c53764a937690e29ca269c9f13518369d53e8b257491068bddfe875e6e1fc96dc3781b10ecf2c26230e800f21cb90ad6ab69c7544df22a39fe0265b00d87bf511914673185e3883de9e7b89a3ee751b7414e4ebbad25bb4ecbc235b1b52e4183ad7194a999ac184193b2bdc1208fbe3de7e04f6625ed87c39e17fb65b1fdf107812d77da8934509ab68f4280dcb81cf4ce092b13b024b491a6dc841cc4ba6f31eedc4b5322db5be4c21d109188950e5af469fe43c6f71bb45711706ec25c53474b16a4e51e9389a82ee7c115c1c1212c254aa7a43784fb9302d181e322ea3cc3523eaec692c932bf2f58719b14a156c82cd94e615730a06030da6a642471824558142bacbf3aa0893273c3a5a40c159c200294de60728b82eec9eff42f21e0cfa9e8c89cce273051b53b3e04764aa443fc8f4d0eb9abaa58e74b352ec863c5b0a39a3328766bae5e5f150fa305d37f915205c462933d31ced2080ef8cf5201ba77608cb3d66918949d02efac9eb2ce9ae5ef31a6abe89df43c257646fae53b0d3abe2aa4268ffb30e4354f6d146fa337bbd719c12dc26ccd97e19f24250e90c3790e3cb27573565fe6cd60a141238a83f6c4450e5bb1b4fa63cb47e08dc4f84176b0e9092a0cb8ee82bd40b201df6c6c67269e91eb4c8500a1d2ccb146a53a085cf1e35d14fa18e670eb452288b664ff243d1f1a4b0f1b6cd1bfedf5a2efc181710bc83b65c183b851b6a20abbdf477d825ddc94f371fd7ef95c1e920502a612b5be2c9b93f3734f66c8f6102fb4bfa255102967c9f1b7d501d299a1c12cf69a0176e4accfd48650f5b4690eda8798cb7204c0ef637a9fb3bb3f7e17ea4ba6024dc4b496351149299fc3264f71448d930bfa9e5c8402eabd506d36e98b6ed6e292ba491b69e48a0b3b7103d5053df70aa785ce0106a372ec4efb5d6c95ce04bff7d4c68539e3ee5130fa71869da1528cc1907da8eb1963a604d909c1b86128a0d00b812eb647f7da8e97ae143a035fefeed2554ff7c9c58c56df9802052a0e73476ee0f376c66e704540218a263cdc34848d340bb56a59bcfe827b5ef133d19a885510dd581fa757c2bf9db42f2f9a1d7b751e5f6bc6aa11f1f6638e35a072c8a88039a86bf978b3b53473e05c8f29d6335be707181daad94b856bd963c299bef3c64eab947f4b37edf27ad28bfe8bd26a40beefbbf91c5283ac7fe07e64af673b803667a2d24a74f51636f4f236450936a611464e974edfaa86a83767b4320db0f05024a972990a0b512ef485568a0069822fb4ebab8123bc1d7ea63c1b6e02622c4356de0c96afaba2cd15f9eeeb68852e3e3fd4202068364f69c735045b13dbf1d5748dec891b7f6679de771df4bc99d4caaa204a38ec1e7081ed36ae9a2e78296602400a5aa97aecfd34c6118e0524b632233707585e4d5057e1d49283e80ef53d323267d02b9cc49517864c31f1ba2bc4b93d726e4702283f0244102a87c2cd485b538aa773aa21ea7053bd9cf5e84f0ca0b61b1d06f3f4d3ee098f9e38ded23803f65bf9eb3f09eb546a4d193c708e0a24c9b544af265e505d0320e4ea3fc1b839e6e35224cbf32cba872c439997c808aef09198c9d63b5eac0d12181edca42e3343ad04e5c9637f3ba67aa366d313a8056c3c387957205334c9ee2adbad8fa813d7ebf942c09eaf5b86a0e9a96d149fe029c4094b46a4ea7b8f73ccf0337b3c0e13755fe21500c326289343bee82dcefca4592055672920baef94aad493dd9169d896039749bf884777e770343e99c325a6c1bc95741636487c430d2f71d1322a33bbb9cbf2f61a372b9f00be6b41748fa41ad84057380c75353ecdcc8ceb4e3488db37ca281d01d64c4052532a18ed4625d5c92dae4f7836d62ba8ad5cf14f149dcc4dfab11b5be5370ab5365e797153a492fb1b55cc63656f7bd46e1b84f1cbc4ca18a29856b1a161fdf7b51ca2a483d6c94d008bda4f8a731fa61f9bafd5ba413120b107ddbe951fd622ef9235bb7af3e076d16b7402d9347d372b872c15884a0e4eed5fff91903f46c7fb785f1fbdb1cb168d83592112c242f4999a36884b9288f422d2465abea37792a763cc06af3686f9e143419fb99c0b55cdae73fc1214a89ad95d3838e2b38cc244550c480aa06ca686b243c1c3ef7dda76e2cb5f4cfe26f87321fb8cb8309b2dbef8e203b70756e6e4309b5af05660ed7027c599df8e20dfb2c61535f8fc011641b57dde44acd38f3607fcc46f05adb290fdfd1f0505965e6d25b238014669a465dfca47740eca206d86da3a6f74f25b7bc8cae6696e478d099c0f31f8382c3dee4a1e23ace56ef6ad55ab34d033b04a1718ab3c9ffec4d8edc1e01ded5059e7e2b5a917e018ecd7bae8d3c83f23d3d6e45486cf86a879b0f033760179afe6c4a16da42bcfb6e5dac06698d838bceaa2950d2e9a8def0d36bdf207729e771649dab35d3d2be12a1b3e9c216d785a3e60b5efa5b71ff31ec6441f8ffd97566b8432d7e4f67d04c2cef8142c687303d17349680ab5e5fc27b306d6723b5faab8c3cfc5c3dc6e08bd00df6fc0f55f23b50d4ec21f081cde7cf9ddda34a1e9af84a3dfe34d4449cae713b313edded8d15c677f70116523218735c57e3e2459dd6b5c5d248884ddd9826bfbcb1d1ad96cd8eeb3e4e2338ec8c37f8999b3443015a785e589ae773c30b0e3acf29827e08caf5dfc41e767f65bd219ce69c2ebe790ce170c49f6a2c7eaaa5ab2ed44868d82122a75a098fc7128585df761e505ce9a7d69db379e076afc2e4337836000ce2de6c0df4d7acff37e23c542eef3314b17d3457a649f927b4e4d8c10998af94291785a7fd6b54a92e51fb8fa63726b3da0cda2c7075925737cc8e57d400ff78bcf37b4266a5dba30472c6babc7d47c7a418e7482a4304ff7debd881b835549959315e4ebbe89d89c7b708fa61887fd2008252229e2b8c74f71af78d5d8513b0a5015ec182725558a9c77f8fb1afe84b328381a5c799401d9f9f106d0a2532c3d885952345eec081c874a313e4ae4708867f7493dfcfb9b9db0d55fa0950858249c9e9c4475028ef52cfe8009bc0687076d0dce78dae6165de2e03fa109bb5ba11c365e0b9a4a6d45cabb3c3b654740614a1d1ee3e226798a26e3f160b6d6293a53d8289b3f161ff567013a75b184ca70b341484a3a0837937cc23a01cbc15e8b9a40c2eb711a8ad3726483a5b1a5e5ddacd9ce7f3d3d56dcd0bfb9045942021961c7bf8cbb9c4bd9bfc7f51eed7434f8217290a2ee8ae44481eb933f3b82da88e0f86d2d0d48b776abeca9f35a79cf1eeef29a72c66d4eb208fa8b9ce68bb877cb102de52c7ae39ba90af3db5ddd012d75c6ba54cd18bd906aed788c106f78f21757731ffecb76f6660d385abc79a591d56f87c01939e50928d281982b5bf11db6027a77ba6ef4b9b886b178ff7e4ab08002af001a92b2d48e972f83de6759ad36051306850256561e7b138f217bae1dec4b1c381c9a588f65b6448f0d48b0fc8dae1cf2efed81fb00044b22c1ce7576cda57c762c9eeec2a80dacb4332a991af10b55db6b1616e60ee8d258921de0f8affcaf9e1a31e326fd6abf3b254d07486b3ad1fba509b63af40abacb86a4edd747ab900ccb6f45c8d14d011d2238d3c4b31197726c693565eb0d6d99bcc4202b42b39d1e16c02dc5915edcfd2288be4af42014db4ed96c81e4ef16c3883a8f5496343d56ed38da71366a8a0b4c226a8a1d548b4b80c66ce32b10c7d1f0b8533c56caf09dc61d05632c7810e6ffe8efeb287ec99fafa0de08304cddbf1ec93985f29fa093eab1323497b9773a7f0b70bd53f6e059a91f2753f942a7e36d383412bb96bb9887a9e9c6db4d9d8581fc0ea15f8d8a6cb4eb5a466150cd93388ac5bc94d45a8becb19b4d4b6b5454b32fbac92441b610e38e4200ac412b0c39d2b8d22674328769b3e821aad68b0828682f2718baf612269d0bc3f3cd2a5cfe922f53a05930e8283bc812aa0aa9bda664729d140af31013e42626e7d15c2d1cb21c2bddab3716559ce5b1b1f534e2555f7098cc79a14df8cc5f6d917d11a55370b5fa5070eae10cdf45e65daef2919e2c4abc7b6ac1005422597f381707eabb6be0b57f880ae76777208fe8b7d26b72ab9cdd237a4382667306931228f5feb8c1cbeeae3922026f321fd9c8ab84ce65ee4762e45352aecba8d5456bc68b6b46b98ecdf66ef9d4aa40a5a555c4bbeebca4ec25264fbd48757e54764638e348b2c4b724258f00fc478a044a2cb1bbda32cb710e0e97b7431ddbdda64e05494f0763b572008afbb27c9452f0df137a9e0796e88ddfa984b5680405961a8727f8f836e6b10fb168ec6ca4186620975c5d2eba33f99c9fbfea0aea7f0cf4d9a02a73ffb263e2e5d2c405d31fb4118be6c6196f6f7b10606f13817a9bce1e859f1061233e1271a21c7375693664216e14fe6162afb6088c8608b8ff754f875dca9a4fda4c7aa68796e6af3ad9c490b791178c72288d8fe78cb82e33eaed8b88722d6b96a9c5c2eed4000d9e9e0ed33193b5c92e95b64049e2654cf84228c0a2899118f332bd2e00528dca7e8b2466b7e582ec8b4f313c4a3922c236abfd6181833074704b927cc8b8bddd5bcd44a3ecfd49043f539de9a85666acea7055abfd687ec5fe6de11b5e2094cc1328e7e0b606283a0b0789b9d77d396128219e6c5271a4a5e8a3af1e5deec2b25bc99a27e8e1201a129ea2f891577ad1579a90c990bdb090816f6e7369338ba9be48ba4898e8b420c60c08877d23fce3532056c402fbbb6dca9a7efeecedd77bc052f16b05385ca9d879eee5a92b9d2066520008f0650a3b9e15e2b1d8b9c88e36ef5d5c9af0fe797ba03387d92083f6e1bf8b2f4f87877648d86116ce105272175bbe609f013d2e8d4b12044fa837adf8a7010fe48dd1da958dede7d65d702fd05e39a7b4367c7f8f79aadbfebcfc09c3786790869514eb14cf5769663383b9b3af84c546b882b24b74d1c94d03a4240617bd0c324c593d04bf58b5f7b4b28e122eda2ff31f7aa9a7198d444f5849b546ede4a65957d59a7d21e05faba5e3df39908d3b2eeee959b93d95a31569376ee3b0f85721aa17179578411eb7092d6055cb35ed56d8f753d0524464b31df999c148464ce81143a2d768c49ef2972112e7de6b6aa59b060e430641dfb8a7220f101ff3ac3873fafdb6e2ad7df61246a051cbd866a2f1c89961211fae648cf9b4f31fc90e5bc1878d8ecce6ea1483de933c94c558ab4fdcdaf47e4afbb5f46611c6ed9fee4a74c4519baaef29cda603052b2e85515b9cdb8c08447a1f90b30593a29cf7a626b23fdf42ee0a985e151a2ea1a3077096507dac68ba0ea53d0c070e275ac89c8961ef2069b629de4a6e39fa738","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
