<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="zh-cn"><head><meta charset="UTF-8"><meta name="copyright" content="(C) 版权 2024"><meta name="generator" content="DITA-OT"><meta name="description" content=""><title>VC运行时</title><link rel="stylesheet" type="text/css" href="../../commonltr.css">
<link rel="stylesheet" type="text/css" href="../../common-extended.css"></head><body id="VC运行时-D061A50A"><main role="main"><article role="article" aria-labelledby="ariaid-title1">
<h1 class="title topictitle1" id="ariaid-title1">VC运行时</h1>


<div class="body conbody"><p class="shortdesc"></p>
<p class="p">Microsoft Visual C++（简称Visual C++、MSVC、VC++或VC）微软公司的C++开发工具，具有集成开发环境，可提供编辑C语言，C++以及C++/CLI等编程语言。VC++整合了便利的除错工具，特别是整合了微软窗口程序设计（Windows
API）、三维动画DirectX API，Microsoft .NET框架。目前最新的版本是Microsoft Visual C++
2017.</p>
<section class="section"><h2 class="title sectiontitle">VC版本</h2><div class="p"><table class="table"><caption></caption><colgroup><col style="width:19.03807615230461%"><col style="width:10.62124248496994%"><col style="width:5.0100200400801596%"><col style="width:12.424849699398797%"><col style="width:52.90581162324649%"></colgroup><tbody class="tbody">
<tr class="row">
<td class="entry">名称</td>
<td class="entry">版本号</td>
<td class="entry">环境</td>
<td class="entry">发行</td>
<td class="entry">备注</td>
</tr>
<tr class="row">
<td class="entry">Microsoft C 1.0～6.0,C/C++ 7.0以及Visual C++ 1.0～1.52c</td>
<td class="entry"></td>
<td class="entry">16位</td>
<td class="entry">1983年10月-1993年12月</td>
<td class="entry">Visual C++的前身是Microsoft C/C++。还有相关产品：Microsoft QuickC 2.5 与Microsoft
QuickC for Windows 1.0. Visual C++ 编译器仍然叫做Microsoft C/C++。</td>
</tr>
<tr class="row">
<td class="entry">Visual C++ 1.0–Visual C++ 5.0</td>
<td class="entry"></td>
<td class="entry">32位</td>
<td class="entry">1993年7月-1997年04</td>
<td class="entry">1994年9月，32位的MFC 3.0伴随着Visual C++ 2.0取得巨大成功</td>
</tr>
<tr class="row">
<td class="entry">Visual C++ 6.0</td>
<td class="entry">版本号12.00.8804</td>
<td class="entry">32位</td>
<td class="entry">于1998年8月发行。</td>
<td class="entry">集成了MFC6.0以及ATL3.0。一度成为了经典中的经典。发行至今一直被广泛地用于大大小小的项目开发。但是，这个版本在Windows
XP下运行会出现问题，尤其是在调试模式的情况下（例如：静态变量的值并不会显示）。这个调试问题可以通过打一个叫“Visual C++
6.0 Processor Pack”的补丁来解决。奇怪的是，这个网页强调用户也必须运行Windows 98、Windows NT
4.0、或Windows 2000。</td>
</tr>
<tr class="row">
<td class="entry">Visual C++ .NET 2002（也即Visual C++ 7.0）</td>
<td class="entry">版本号13.00.9466</td>
<td class="entry">32位</td>
<td class="entry">于2002年发行，</td>
<td class="entry">集成了MFC 7.0，支持链接时代码生成和调试运行时检查。这个版本还集成了Managed Extension for
C++，以及一个全新的用户界面（与Visual Basic和Visual C#共用）。这也是为什么Visual C++ 6.0仍然被广泛使用的一个主要原因。</td>
</tr>
<tr class="row">
<td class="entry">Visual C++ .NET 2003（也即Visual C++ 7.1）</td>
<td class="entry">版本号13.10.3077</td>
<td class="entry">32位</td>
<td class="entry">于2003年发行</td>
<td class="entry">集成了MFC 7.1，是对Visual C++ .NET 2002的一次重大升级。 </td>
</tr>
<tr class="row">
<td class="entry">eMbedded Visual C++(即EVC，EVC++))3.0–4.0 sp4</td>
<td class="entry"></td>
<td class="entry">32位</td>
<td class="entry">2000年7月–2004年6月</td>
<td class="entry">用于Windows CE 4.X/5.X，在4.X时代与Platform Builder、VS2003一起使用，从5.X开始到6.X三者都被VS2005取代。</td>
</tr>
<tr class="row">
<td class="entry">Visual C++ 2005（也即Visual C++ 8.0）</td>
<td class="entry"></td>
<td class="entry">32/64位</td>
<td class="entry">于2005年11月发布</td>
<td class="entry">引进了全新版本的C++/CLI语言以替换Managed C++，以及OpenMP的支持。Visual Studio 2005标准版与专业版有支持x64编译。</td>
</tr>
<tr class="row">
<td class="entry">Visual C++ 2008（也即Visual C++ 9.0）</td>
<td class="entry"></td>
<td class="entry">32/64位</td>
<td class="entry">2007年11月</td>
<td class="entry">支持.NET 3.5。Visual Studio 2008 Team Suite更同时支持x64与IA-64编译</td>
</tr>
<tr class="row">
<td class="entry">Visual C++ 2010（也即Visual C++ 10.0）</td>
<td class="entry"></td>
<td class="entry">32/64位</td>
<td class="entry">2010年4月12日</td>
<td class="entry">Visual C++开发团队考虑使用SQL Server Compact格式的数据库来存储源码的相关信息[20].本版也加入了现代化的C++并行运算库-Parallel
Patterns Library，部分支持C++0x。本版建构于.NET 4.0之上，但仍支持机器代码的编译。</td>
</tr>
<tr class="row">
<td class="entry">Visual C++ 2012（也即Visual C++ 11.0）</td>
<td class="entry"></td>
<td class="entry">32/64位</td>
<td class="entry">2012年8月15日</td>
<td class="entry">支持Windows Runtime开发。从该版本起，编译出的32位程序不能在Windows NT4.0 / 2000
/ XP上运行，这是因为在程序内部使用了自Vista起出现在kernel32.dll中的GetTickCount64函数。解决办法是在编译project的platform
set选择为“Visual Studio 2012 - Windows XP (v110_xp) ”。</td>
</tr>
<tr class="row">
<td class="entry">Visual C++ 2013（也即Visual C++ 12.0）</td>
<td class="entry">RTM 18.0.21005.1 / Update 2:8.00.30501</td>
<td class="entry">32/64位</td>
<td class="entry">2013年10月17日</td>
<td class="entry">支持C++11与C99特性，并引入了REST SDK。</td>
</tr>
<tr class="row">
<td class="entry">Visual C++ 2015（也即Visual C++ 14.0）</td>
<td class="entry"></td>
<td class="entry">32/64位</td>
<td class="entry">2015年7月20日</td>
<td class="entry">改进了对C++11/14/17支持</td>
</tr>
<tr class="row">
<td class="entry">Visual C++ 2017(也即Visual C++ 14.1)</td>
<td class="entry"></td>
<td class="entry">32/64位</td>
<td class="entry">2015年4月7日</td>
<td class="entry">版本 2015 和 2017 之间没有重大更改。 更佳的 C++14 一致性级别、CMake 支持、生成吞吐量和编辑器效率</td>
</tr>
</tbody></table></div><p class="p"></p></section>
<section class="section"><h2 class="title sectiontitle">MSC编译器内部版本</h2><div class="p"><pre class="pre codeblock"><code>MSVC++ 14.1 _MSC_VER &gt;= 1910 (Visual Studio 2017)
MSVC++ 14.0 _MSC_VER == 1900 (Visual Studio 2015)
MSVC++ 12.0 _MSC_VER == 1800 (Visual Studio 2013)
MSVC++ 11.0 _MSC_VER == 1700 (Visual Studio 2012)
MSVC++ 10.0 _MSC_VER == 1600 (Visual Studio 2010)
MSVC++ 9.0  _MSC_VER == 1500 (Visual Studio 2008)
MSVC++ 8.0  _MSC_VER == 1400 (Visual Studio 2005)
MSVC++ 7.1  _MSC_VER == 1310 (Visual Studio .NET 2003)
MSVC++ 7.0  _MSC_VER == 1300 (Visual Studio .NET 2002)
MSVC++ 6.0  _MSC_VER == 1200 (Visual Studio 6.0)
MSVC++ 5.0  _MSC_VER == 1100 (Visual Studio 97)
MSVC++ 4.2  _MSC_VER == 1020 (Visual Studio 4.0?)
MSVC++ 4.0  _MSC_VER == 1000
MSVC++ 2.0  _MSC_VER == 900
MSVC++ 1.0  _MSC_VER == 800
MSC7.0  _MSC_VER == 700
MSC6.0  _MSC_VER == 600
MSC5.0  _MSC_VER == 500
MSC4.0  _MSC_VER == 400
MSC3.0  _MSC_VER == 300 第一个微软自行开发，兼容K&amp;R及随后的ANSI C语言标准。1985年发布。
MSC2.0  _MSC_VER == 200 增加了Large模式（用于16位编程）。
MSC1.0  _MSC_VER == 100 基于{{tsl|en|Lattice C}}，发布于1983年。
</code></pre></div></section>
<section class="section"><h2 class="title sectiontitle">运行时版本说明</h2><p class="p">我们平常玩的游戏、用的免CD破解补丁等程序常常都需要C++ Redistributable
Package的支持。但是C++ Redistributable Package有众多版本，常常使新玩家觉得无从下手。本文的目的在于帮助大部分初级玩家解决区分c++的版本问题，让他们很快的找到自己需要的c++版本。</p><p class="p">首先，我们来看看C++ Redistributable Package究竟有多少种版本。以下分条列举。</p><p class="p">Microsoft
Visual c++ 2005 Redistributable Package(x86)</p><p class="p">Microsoft Visual
c++ 2005 Redistributable Package(x64)</p><p class="p">Microsoft Visual c++ 2005
SP1 Redistributable Package(x86)</p><p class="p">Microsoft Visual c++ 2005 SP1
Redistributable Package(x64)</p><p class="p">Microsoft Visual c++ 2008 Redistributable
Package(x86)</p><p class="p">Microsoft Visual c++ 2008 Redistributable Package(x64)</p><p class="p">Microsoft Visual c++ 2008 SP1 Redistributable Package(x86)</p><p class="p">Microsoft Visual c++ 2008 SP1 Redistributable Package(x64)</p><p class="p">Microsoft Visual c++ 2010 Redistributable Package(x86)</p><p class="p">Microsoft
Visual c++ 2010 Redistributable Package(x64)</p><p class="p">Microsoft Visual
c++ 2010 SP1 Redistributable Package(x86)</p><p class="p">Microsoft Visual c++
2010 SP1 Redistributable Package(x64)</p><p class="p">Microsoft Visual c++ 2012
Redistributable Package(x86)</p><p class="p">Microsoft Visual c++ 2012 Redistributable
Package(x64)</p><p class="p">Microsoft Visual c++ Redistributable Package(IA64)</p><p class="p">如此多的版本难免让人看得眼花缭乱。下面，我就通过对大家常见的问题进行解答的方式来破解C++ Redistributable
Package（以下简称c++）版本之谜。</p><p class="p">问题1：装c++ 2010可以替代c++ 2005和c++ 2008吗？对于一般的软件，版本交高的程序可以替代并兼容版本较低的程序。然而c++则是一个特例。由于不同的版本中包含了不同的库文件，因此c++
2010不能替代c++ 2005和c++ 2008！</p><p class="p">问题2：c++ 2005、c++ 2008、c++ 2010、c++
2012都装在一台电脑上能兼容吗？这个问题的答案是明确的——它们可以互相兼容，不会发生冲突，因此建议大家把它们都安上。</p><p class="p">问题3：x86、x64是什么意思？其实很多软件上都有这些数字的分别。其中x86代表32位系统，x64代表64位系统。由于64位的系统可以兼容32位的程序，因此x86版本的文件可以装在32位和64位系统上，而x64版本的文件只能装在64位的Windows操作系统上。</p><p class="p">问题4：我的系统是64位的操作系统，因此我就只要装x64的文件？错！虽然从理论上来说应该装x64版本，但我们必须要考虑实际情况。截止目前以及可以预见的未来几年，我们所使用的游戏、破解补丁、从网上下载的小程序，它们都是在32位的环境下开发的。也就是说，开发者或游戏公司在开发这些程序的时候都是调用了32位的库文件。因此，如果我们想在我们自己的电脑上运行这些程序的时候，不管是32位系统还是64位系统，都务必至少要安装x86（32位）的文件。经常有人装了c++后还运行不了某些程序，就是因为他的64位系统只装了64位的文件。这一点特别有迷惑性，希望初级玩家们特别重视。当然，对于那些使用了maya、3ds
max等工业软件的用户，x86、x64在64位系统上都是要安装的。</p><p class="p">问题5：c++ 2005和c++ 2005 SP1它们之间的关系是怎样的？其实它们本质上都是服务于c++
2005开发的程序，它们之间只是版本号不同，可以把c++ 2005 SP1看成是c++ 2005的更新版。因此如果你的电脑之前装有c++
2005，再安装c++ 2005 SP1时会覆盖c++ 2005。不过不用担心，有了c++ 2005 SP1后，需要c++ 2005和需要c++
2005 SP1的程序都能运行。因此除非特殊需要，建议大家安装c++ 2005 SP1即可，不用再装c++ 2005了。c++ 2008与c++
2008 SP1的关系与c++ 2005类似，不在赘述。</p><p class="p">问题6：一个程序只要05、08、10中的某一个即可？不一定。一个跨代开发的程序完全可能既需要c++
2005，又需要c++ 2008。因此还是那句话，鉴于文件都不是很大，建议把05、08、10、12都装上。</p><p class="p">问题7：网上说某个程序需要c++
2008，可是我装了还是不能用呀？c++不仅有大版本之分（如2005、2008、2010、2012），还有版本号之分。也就是说，同样都是一个c++
2008，由于它们的版本号不同，它们之间包含的文件也有微小的差别。如果你的程序恰好需要这个有微小差别的文件，那么你的程序就无法启动。在这一点上，微软的中文网站给广大的中文用户制造了一个不小的陷阱。比如在微软中国上提供的最新版本的c++
2008 SP1的版本号是9.0.30729.01，而实际上已经有了版本号为9.0.30729.6163的文件。差别还是不小，因此造成了有很多人说我从微软网站上下载都不行。请大家记住，微软网站（尤其是微软的中文网站）上不一定提供的是最新版本。比如最近很火的愤怒的小鸟（AngryBirds）需要c++
2005 SP1和c++ 2008 SP1，但从微软网站上下载者两个文件后问题依旧，其根本原因就是微软提供的不是最新的文件（有关愤怒的小鸟需要的文件请参看我的博客《AngryBirds（愤怒的小鸟）无法启动的解决办法》）。</p><p class="p">问题8：为什么c++ 2005装不了，总是提示“Command line option syntax error. Type
Command /? for Help.”？这个问题很普遍，其实还是微软自己的BUG造成的。有关这个问题的详细分析和解决办法，请参阅我的博客《Visual
c++ 2005 Redistributable Package不能安装的解决办法》。</p><p class="p">问题9：上面列举的最后一个文件中的IA是什么意思？IA翻译成中文是“安腾”，这是一种专门用在服务器上的处理器。由于该处理器包含了特殊的CPU指令集，因此需要专用的文件。来看本文的人99.999%用不到这个文件，可以忽略。</p><p class="p">总结：说了这么多，总结一下就是，不管你是32位还是64位操作系统，都至少要安装最新版本的c++ 2005 SP1 Redistributable
Package(x86)、c++ 2008 SP1 Redistributable Package(x86)、c++ 2010 SP1
Redistributable Package(x86)、c++ 2012 Redistributable Package(x86)这四个文件，对于需要使用工业软件的用户，则还需额外安装64位的文件。</p><p class="p">我想大家可能会觉得怎么需要安装这么多文件啊？一个一个下载然后再安装太麻烦了，有没有简单点的办法？当然有，这里我要推荐大家使用
DirectX修复工具增强版 。DirectX修复工具本来是修复DirectX的，但是其中的增强版包含了本文中列出的所有需要安装的c++版本（只有DirectX修复工具V3.0及以上版本包含c++
2012）。下载后只要点一个按钮，就能完成所有的安装操作，简便易行。同时，使用DirectX修复工具还能顺便解决你系统中的很多其他问题（比如0xc000007b问题），因此极力推荐大家使用。</p><p class="p">程序链接：http://blog.csdn.net/vbcom/article/details/7245186</p></section>
<section class="section"><h2 class="title sectiontitle">语言标准支持</h2><p class="p">VC6是98年的产品了，但因为它的小巧而一直被众多的爱好者追随。对一些新入门的朋友是不错的选择，另外我偶尔也用它来编一些小巧的程序，或者临时打开来测试一下。
 VC6是比较老的一个产品了，对C++的一些支持并不是很好，对C的还算可以吧，起码我没有发现什么大问题。另外最新的C99标准铁定不能指望它能支持了。C99在VS2010也就只支持部分而已。而且在之后的版本里面，微软在编译的方面上也做过很多优化。
 一个这样的老产品难免会有各种兼容性问题。 </p><p class="p">vc6对现代c++标准的支持不好，在win7以上系统上运行需要很多额外配置，不建议使用。如果考虑产品的兼容性，推荐使用vs2008，他编译的程序支持windows2000后的所有系统，而且对c++标准支持的很好（不是c++11）。
vs2010编译的程序不支持win2000，没有常规方法改变这一点 vs2012和更新的版本编译的程序默认不支持xp</p><p class="p">在Visual
C++ 2012以前，完全不支持C99与C11的新特性，仅支持1989年版的ANSI C。</p><p class="p">Visual C++ 2012开始在C模式下支持C99的部分特性，如designated
initializers、compound literals、_Bool类型。</p><p class="p">Visual C++ 2013很大改进了对C99特性的支持。</p><p class="p">Visual C++ 2015基本上完整支持了C99标准库，但需要编译器尚未支持的C99语言特性的那部分标准库除外。</p><p class="p">假如我们的工程中需要引入多个DLL或者EXE（多进程合作），那么根据你使用的VC版本不同，可能会有不止一个CRT被使用。很容易理解，假如有多个DLL中都需要打开文件进行操作，而打开文件的函数代码可能就会存在多份实例（静态链接）。上面已经说过。可是这取决于编译条件。比如，如果我们有多个CRL库使用/MD开关链接到单个CRT
DLL，那么会出现冲突。这和我们把一个CRT链接到多个DLL中产生的问题一样 —— 都是多份代码操作一个实例，势必必然出现问题。但是现在，MSVCRT.DLL被重新命名为MSVCR80.DLL，程序，无论链接到MSVCRT.DLL还是MSVCR80.DLL，二进制都是完全一样的。
现在是否可以这样说，VC2005的出现其实从开发者的角度就统一了Win32 API，无论你的程序是依赖于操作系统支持还是依赖于IDE提供的“高级”CRL，那么用VC2005编译后，本质上都一样。如果是从旧平台移植过来的多线程多进程工程，最好用VC2005，选择合适的开关（DLL链接）重新生成一次。
 </p></section>
<section class="section"><h2 class="title sectiontitle">工具链生态环境</h2><p class="p">编译时，根据项目是调试版还是发布版，动态还是静态链接运行时库，编译器可自动使用默认库。如果使用编译选项/nodefaultlib，需要显式指定使用的库。对于VC++2015，所有下述库均为多线程：</p><table class="table"><caption></caption><colgroup><col><col><col><col><col><col><col><col><col></colgroup><tbody class="tbody">
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">情形</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">编译选项</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">预处理directives</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">CRT初始化库
（均为静态链接）</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">vcruntime库</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">vcruntime
DLL</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">Universal
CRT</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">UCRT DLL</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">Standard
C++库</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">Release
DLLs</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">/MD</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">_MT, _DLL</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">msvcrt.lib</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">vcruntime.lib</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">vcruntime&lt;version&gt;.dll</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">ucrt.lib</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">ucrtbase.dll</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">MSVCPRT.LIB
是MSVCP&lt;version&gt;.dll的输入库</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">Debug DLLs</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">/MDd</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">_DEBUG,
_MT, _DLL</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">msvcrtd.lib</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">vcruntimed.lib</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">vcruntime&lt;version&gt;d.dll</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">ucrtd.lib</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">ucrtbased.dll</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">MSVCPRTD.LIB
是MSVCP&lt;version&gt;D.dll的输入库</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">Release
Static</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">/MT</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">_MT</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">libcmt.lib</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">libvcruntime.lib</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">None</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">libucrt.lib</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">None</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">LIBCPMT.LIB</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="1"><p class="p">Debug Static</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">/MTd</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">_DEBUG,
_MT</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">libcmtd.lib</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">libvcruntimed.lib</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">None</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">libucrtd.lib</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">None</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">LIBCPMTD.LIB</p></td>
</tr>
</tbody></table><p class="p">Universal CRT (UCRT)包含了C99运行时库的函数与全局变量。UCRT现在是Windows component，随Windows
10安装。UCRT的静态库、DLL的导入库、头文件是Windows 10 SDK的一部分。</p><p class="p">vcruntime库包含Visual
C++ CRT实现相关的代码，如异常处理、调试支持、运行时检查、类型信息、实现细节与特定扩展库函数。 vcruntime库相关于特定编译器。</p><p class="p">CRT初始化库处理进程启动（CRT startup）、内部的逐线程的初始化、终止。CRT初始化库相关于特定编译器。CRT初始化库总是静态链接，即使使用了动态链接的UCRT.</p><p class="p">对于本地代码与受管代码混合的情形，使用/clr编译选项，这会动态链接 UCRT与vcruntime，静态链接msvcmrt.lib或msvcmrtd.lib；svcmrt.lib或msvcmrtd.lib提供了受管代码与本地CRT之间的proxy。对于纯受管代码情形，使用/clr:pure编译选项，这会静态链接msvcurt.lib或msvcurtd.lib。</p></section>
<section class="section"><h2 class="title sectiontitle">参见</h2><ol class="ol">
<li class="li"><p class="p"><a class="xref" href="http://www.voidcn.com/article/p-xzposals-bkz.html" target="_blank" rel="external noopener">VC2005 运行库解析- 程序园</a></p></li>
<li class="li"><p class="p"></p></li>
</ol></section>
</div>
<nav role="navigation" class="related-links"><div class="familylinks"><div class="parentlink"><strong>父主题：</strong> <a class="link" href="CPP%E5%BC%80%E5%8F%91.html">C++开发</a></div></div></nav></article></main></body></html>