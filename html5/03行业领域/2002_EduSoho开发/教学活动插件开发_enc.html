<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"915c8d63ad9d6339c5892dfd5f8d51117f5646e8a023fd094b7e9f06b07fea2089df665dd7c4cd9e754e226ec2d4fb1889c24f514c600b74a02f96b3d32d9059f7062e481d228bf32316acf287e1c2edc9f8f120648ce336c7aca3377ef3079eae15df7389a4e823766c2cefae7fc8da9fc35c59879bd336b9acdecfa6e5738e49a91d54444777e83ca4a6c6b4f060fa101c188bbea847fddfd04d88492c4ea937c80f49212ab09e777c38e9d13a39f970d6141de59fa91e2ef66eda9119b9448274cc0d741e1a501bc0b26dc6100d63b74f4b7e1e436576659e7eafb398c58519376097d18ff29a477d674306c0aeb3bd13d234f4e53d63532fedd44188a23f1781cdda607e6d0bde7597d8487764005c995de26dac937cf722888e787892d3e7421fa8a50754bf4bb1345b20f8c6d648a253a1944ddbe2b69432bdcd08daa9c28ea3f56d88c8f48b6d5a0278486bb6d98cd8aadc584bdf733356b58372bf8ee1051612fe3b2d8658d64306ba9bbde4d62832b0bc82bddfd46a6d3de267880bf2a0dad84d45341a06c23ec1b689836707866338a7e39a8054256d94ff6d683670e5b145dacef8e9671304f5e7bf9a4f4729b11ce5d97fec489ccc7284b9d99cd2aeed3aa5ba92d72bea3df305be6bab7b8e932d68da75b0a3b31716308203b04f7fcb8bbbff1605c5f14e955c115241a6af616ef999bea3a57b3234a5276e2642ad168b2980d08aaf0869ffe6fcbd9f72c048bfd51034b8f857f337aee98a7774dc75b53eda5f04e62c761494d6a7da811503a4e26eb377dc23336b855cf5dc1d69848aa3d91d2e259fe6915e2f6159b63ea1c76eac418cf2ae43f9329da0ebf88736a4ce7a32721186b1d022c8b7cad83a8fafd3cfd87cc66b835d4045d61c26ff5a2f3b5d6a85f602f12fd2cee3ddbc32b59e1295337143243fa568d08b2dae443c6a0441169a3da4c4ed37771f9e78c04f7fce88a95e25e1772a9c5b238b109022bc5d0d056aac339a666e9d230053102792854b9d958ab3a3a6ac2239a93c65540624c8a60717514a5c1af37100180da6f75ae29aa9fc06ce25e514fba692e74e2d2646a922ed63919343633da753b171c97eaa4839b642d731265a03f56b7f33e9b210ac840eed114b1f49b6d9dc2bedd0690a1ad11b069b8854d61901f10456f9a84fcf07ac327ec24b9295cd631196eddc51b6938348b38662885ce384d8cc177275d8da54e3c0993f187f6f9d8d8e97852421fc5fe4927468eeac321d0320c77135a2fb2eb053b0cc3d42eb165c462d592f2ae74d4cf12d4fc322becadb24b7717180c4884854b58d40f6975a5f304b48613c89a94be01d7b1b1fa3b160e7b106048f627172912ccfe60d4e94bffcd2428ef482c71158c6d901439081dda08995d90cba24fc8c0b38fa5876346441f2bb864b5110f06d7da713cbde4709901c3139f539267c18a0815b0c06b66a7de3c1147f26f139a0d4dcd3dc77c5d1bfbd91c9e9d710c8095130cacf266c291835f3334d8c599d725a5b6292e24469e888b7cabe5e64ec243470e5961beb0e1a0337b7bfd3cfd217724b88a95841db0ee6ec69329e48baf32a5fd5d0595be4b4cc83dfd3d29d5b5ed5f9d99e6e0619d103584f45a8a161b2409ffcf50359d6c04978a870ede15f8eed1251d638dba95c81ea1a1f587d8b4518ea7733bc8f2c4b105faaaebe248aa931cfddc3ed0b414d8e86910b7dd6a5362b6a3c989f064c5068935b533f5582a9348dec4bb224df48e3d3709041c87758d9284dcaed581d447d03222d4a527f6d57cfc58707ffb0c4c691e872c2a79a0a54e59cf31fc8317ee6940c5e1317394a0c158a1759351306eeef3deb905125bb4e5ebcb310a6c9b517023d1bbc481535bfedd501a25002de1954a451caa59ca443fbf141ae34ca93adc5f765ad3d54a9d7a2d8d36646eec4246bc0aa452a35b5b668a42edf02dd1fda3dc1ec59eecf11e3fe5300872f9fecd06bea290479c0b20f6766635278c8625305be3b2a19b57583c328226226aead79b4fd8852b6e4d5e323c51608af6cab6f9bde72100a6d206223d4cac6feb15a9ec51c72ef69ce52e1216fd86da0bf1d0ebac7406bc28f8ed05a3de57666e4b279405d6574b912c009239c88e00fd996ea104eb9cb97f82e65d792f63a7aa38c4244ea5b8f689d63960e2017e370af95e6f667e553bf7e2590a90babd89a7925feccf554b5cb5aeb09ec422ec7a4ff714b9aef0dfd506dadf28bd965f23f66ebbfbff59f2cd7e01cee73e1e058fa3ab15a22457586524bcaec00b41e1d6c142a5fe48a2566cd5ad453363fb5a586b780517744e34dbb16a1603fdf658971d16e0e1d04d959b19dd5c02d2f01b61931c7f762319fbb14cde40968bd935bbf13a6bb25449afb870893a6132c313df999b217c7460e243cfd7d79c018682c846bd62140ad5d75d0e89f055cc948acf3efcc96508b469fc75b166301502ff2dc3d5969724812dc5fe9feb21591f06b0336b2ce44eb62fa653a508cb44eb1017967b3f6915393e65c9d5b9d3bdfd7788f932dccc49f74d69720b0684b5b294898a93f20356127033ec147daa4cb8c0e8be483b6f48bbbb6f10be7543ab4df1a857a738908c7276b08a31513b7f137137069ac82a91a098aef5a4d05921443cf86b1c03237d9f83bc6c6f4c4225cb5a723e6f36c14c3771629f3810386f39c54123005174c220283dbae406e11dc4ba03efc67b72fe81b3ac3433983b46a2d4b4ce2bfc1d585bb49ae20f53a15731a27ca8e2063b39bbce2ad2dc6d78c1b5bfa591a8a35187755b5f5e08e872569f67c54775575f2dd7dd0fa3b1de7f51b3d4c5906595dcb7add81b67b41a4d1258382742d8b04b1b7201289b9b0aa14feee2bd6e01201fae12c245789466c669e6f5486515ada6ec81279637a6a089df06943a148bc730e1fbfe93b38e7fb7ecceb62c8b88aa2e90a3a8baa3f6b1e412d44679f6baefb456d95b5eb00a7328c38147bd0fb285499fcafb91f3da6494e1c0787643631296e2275daa480187dceee8b6ad03c1ffd5222a5aa37f469e3494715ac1c45b0151a83d669fae4e6361466bf5a354497f73f8e9b3c0d6536091ee147b1d2eff70116c7a628d9533779cb3dae245dcc2c437989be0de4abc635317390d45bc504e892ce15c52528ef4f1ca0bea4fb84367d989a48781b307c42887a275e8d13b1ea9b3c8d6d7bd94fc9ccc814f038df672baa081783523b5c4abc76ad69368c25abdbc13d5fa6260e21fa6cc6d3c2f7e7baca73b12782b7a4feac8567d36bc92c72caa8cbe096920c946230cea6681e60fde92564744265e9148e68276323fa30cb94c5fb85006fbf31baa30923e75be586c6c130504df305e1a2d10f8f8a43d5e06e0befab46644c733582a623410facf8417afc7ba1e47eb0a7bc6f7948e19aa8f129f31909b0b555ba2295ccae178ab9a2bf8e4ba54acc3aa80faa3e796cfa0dba349e35b75c36498cc8de026c2475a2bc1dbb49069d6dbfde50c42d722781b5b53828b488f4d36a2467f9d1cac03687f6da2dfc29dc25b2045bdf4b635ff1fea5c2c3299fd1638bfac1e236aa3ae08b7f6f9914b9ff5c69d72fae16933400b06f2f73dcad940790066856ec17b7e621e7e08d5ffd89329a59e5e5137454b60e96dd18ddb051f3289b8b06363aaf376260f2ef084c7d6f9805e2b08dd4b22de3906d005792732d92824b617dfbdad2b8e05c2eca2e1138a36241578cbc2fe8c0cc1238ca071b3385b6244c1097f3c4b462d1da0f382965795eb29d623733e569817b1da93931d2ea05d262e60ed4294309421551f2ad19bcc7bb5be0b1069eb885a3acd852ae4eff83b18ba93b593952625d8a47d1b6af1939eb2109ecf34e8e6ea55929cd8baffc93b3284b9e5178a79c5e04aee007c90dc4bf5efb39151b6be841abe6a77c32ce8bb503ac93c4a4cbb9eed468d913d0353d234cccab7848f3dca1f2b451f43b72240cd13d0d4dfcb64b0e2e926568a24d77aac56e24ffa8e9dccb6367762bfb00d1e685f8f2a6eb0ee5769ec34adef1c10cf4f3eeb54156fdc806baf6fd5c823a2dc1ded7fc63f6318a268b1ddfd47a136fe842d95f2c65d70ff5224a3dff660947873fb9bcde42e839e2763206d771afe6bda5eb00507a6d6bcf483995b15b1554d0b91d4d217f82275b8f8e080c0178e9c900c3c9068e0b91d1727caae53206ea45cea69d21fa43d15d3873e656f61f2a3fc956bd1774eb2ca7f1e8f08821c077cf12590f6dcd1f62b032b2b25e23b8d9d6905f9e13e6e8a9c688d3d020fad6124b82825c53654955a49990241f855b74ab38bf56e65d7b0041d245304ac175787ff9e9212cceb8f4742725b5b9a009da7a147eebe2ac31d6ff1a6f605d4ab447ddcfa93ebf33765b5085da6dc90a290ba86552cab73b899d3a06b99ca07e9764436b9c4c1add8a05a4e346358407520480e8b8c2360016bbbe2f6ce823d7f7c4f1fe71627fd788859d3a40549a5d1754d86d7fd8339cdcc0183ec7da5bfc19da2ba3666fe97b5fc1f51cd5586f631be09397b07f9175f538edac937e6476da3a9858c7dd34b1a03b2ab7d7b773a3ba8ee738f29496c7f28eb64fae38cb8546d1499f17c55745c4e1065041356069addc1eea8e5c040bce92b3a9d58c0cd17717dc341ecb962720a0cd789d123988bb3c1af361a68f1d7130779eeece270d19d9243e9934b829a641abb32a3417a10ee17790271134d718bc42f769f9639988615a9471d252d1a5558eb46f4133d7a6fc6bbf4f82ff24f5635c5af783d1bdb9ad48f224fada9fe1b6c171cd1a440c7235fc9d97c6bd696f4a8d9121ddd4b07baa8454cc217873072764d3e6ec6480951d58f8c81eeab35e451a6067da51a024afb968f776d73d614de224189910cc486228e791e02c98db0cd18ff01eef1c8de6b12b8c161f794388581f3e1bc59c72350794007185a1885f10298d15ed5d9adf6385581a70d90e6eb8a4195c51cb0c8dfbbb9b97333c49a0f3102b86765a52c5208a04251a05612429a1d8eabcd24cdd404c343bb7157daaad494b4fcc63341561b53bf2ddfb6b6d0e7136e2b1aa13831c46cb820bad1790ee6bb4c83dae756f61beb18918ca9d1aac8cbd907776918fd7df464f061d841dd306acfc0370c87c96cf471279e805c62d9b5d8338cea65c98988c3d9c922a4b567ab56fc27c29f2da4bdd32df98a6429cac9cc2f5ab2e6d9eb25ce5d1b533f50aef39a2d47ad8e72d2a1e1e1bddb83ccc9502b8d2a2874b809cc2f4eb3ee0174e1650cf38921cc6846805d18a0d1ce7470083c2807c24c281e012b6cd841c1fb7757a777155c9dcdc8b3419b482e3af9a3d0cfed7ff326fb3e813a14bab91ce59fa03a2c78e06a8cf6f86df8346fd3044f8cc40063ffbe0800bd613b60bfc47fdc538efd58166e8459f4a3117ac0a71184d73a51dc6c3d5ede31e1b13331d2b9c7ef34fe59da92b8a4a00494bb234b9c0bf2575180e7197cc0a0287b4356cdcbd9ee293162d7bdc81eaa63f691859441f0bbd73a932ad60bd14b4f3529866d45441e4db32fd21f5e286e0a2a1d14e080794ff2ef4a9ebe8bb94f3d83188dc182ba386fdf82e50a69bfba22bb53ea0d863608b7059760a348e55373285a5f1589546babc6c7641dc9a0a9e7827da2a8b2e397aa6fb973cca0572bd7f3001739a99d93e6f14aa5d2caaa11dee06e988c1c02e9c7d295595252f7855d937148cbac84084c898c15f0ce95a99279983d0f1a7d8b0c01a0e9c91de03801c5da249c9bce3fe11ae617ce42019b82899470a3872c4b7323cf7502c42f2cdbd536b2da9da0f83bcab895f31ad0aa27258d552268a0d80b82730d986d362659758285f25de2955a9ed76ec47f6b6a54e0db45395e5321bd65b74fcfa4d6a426e0e71ba7da1dd7f765a01c5a59468d6d43ee2100bcd317c63d3b2605a34bf0263a18e22eac269aa6282c1da5a8e8f61ec24a8c0f75024d1208213a62fbb3330bacf03114ee5a65cbe8d4dd7faf3ca7d37a88480a718a3a81aea4e3b6e4cc4c1eb3103d2d898c50e5c301600accd59e2b988e3a10bba6a75aa09e3e3edf98419a629846fbd69f16044c0154df388ef3cd0b12a25a834c691ddcfdfa1c1a5ab1cf56ea88f9423e57ec72311bf1d1705d8ac350c30cb5d5e088b8a37bf4993a5e186996dd723f644cca467685e7d3ba130eebb7960b22bb88b695f22f3545a351cf2cc2fe06cc5a1c5af390d048edf1f727b60be05829378a25878fa2e4b8c501e907dc4b65993e79784165a6fe583e7e9a3fc8829be7842e68542330fd0b1e80a81f54a41c48ab9182c643b6ee76a7cd59dfea0fa407114d7067de39ff074740f8fffc0709a52c2d6f7ecaa24ba6ab60d5a8fab7173d6aed1317eda71a7aa5890c771a372e5691c6dd981028e6777ac402d44e068d97be7ad262f8362380e8e36605f6ea9afae11e034a40137e91932fe9bea85ac8ab9daa4151ca8fbc1810dc256096f5b2a8424cc7ebe469782ac099c516a905ca6f5cf8c2f85337f58fd4215ca1212ea3cd14c49c83fe042ab7386c966de7f8f326a81677f324788d21dcfa6cd5d887c0abb58396958f05775909ccced61f0eadac364a71dd478f6efa1e8b6b58fadc764964acc0b4fc528b76edb22b1f73a470dd728bd3e2ea61ae66a6a5f397687a6d36aed3e32e4ce3022161c2bf64ed727d5efec4e936b6fc7aaa2393e406eed81e49ea6c52bd60318bcd48f9a5690f99ed7237cd6e914dfcec86b1c23a2e789f77a361cced15c6153625cef1a1125833ace2ed7f4d7e224a150736b1ac9546738657d3e5b264ab64552d891be8aeada6d54caece021a919654857b6026d596c90fb43717abb4b84f8dbfca7580cf23903a127ce4c01b3609ad65c54536b4078afb6558238710aa8d17d1c63030e646fbd34a35bfa43f9c416cc7179aab988c4005e855d9c773b813cd4d12acc1fcbddde1d690b044f4a10256851f32dfb10711bcd9689c0df3373923ec9f4374a281ddc4c14f09c679d28d24e4dde89552ca21336f43e72a3a7e3a5a25a3868280ab7000ac557e00af691d1a8db7413ba31412a3503823c6bb2ac6ed0ba05a93b4a69e2ee53cf0698cfc3500558b0f42b7f035fd126596e67825081cfa17e4866c587065a642e45bb74437d13834b0bcaf61ef79af830acc498d12beeeb54c427e2c8d99a96401f4798f91e9bc423d26c4591204bef5db177e6ca251728afd3116df72a235fe94f532123fa8068e6768ae82ef8dd1fc7e78358a5d554343ae4d1a1006eace1f82fbfbff35de698ebedf5791e5d83bba7e2933d5c1d43f531b10730715e5ecca02fa019f63f8ff554618c9d529212946984f7a353d6b153edce76e4f29bb8263314138135001008357bb66757568570ee0d9930b0a3c2d92be06450fce264cfe53e20ea438994ea568f56def334d0785a678c589492cea61b44960919c5d31f8ef6a6274041d794fed4922a23ed30a09d675c1268836045eb22528c41038bb5c565a09e7b5370bf4a485318482cdb71dccd7de1c568b387ec5e1da13816cfbd67f3a4afca419b8850671abcbd2af52e2763ac5522c4ba320080a3fa3cb47a5e00cdc6a3b1b7b34120185c3345154c15d12879d4ce5333c0a503d94239a4dfed720b97e6627296ecc5ce554b6b2bf0d468b235123a1935dd6621e40b923336db7d2d720494f98473c82ba2aafa7a56138e3aca85972f1d0e76a6ed66dbad26e44f00a53f3730243b5529d8c27831260233da2005e6f92b03ac653ff70c854fbf8e510eb8149d5135a1c7a00c9454091b4c271d88f5c2dfadecea679f57d56d9eef4c450279f5b0b1d1d57f72561dc097e8c5d806df1c20692329eb74dd7da93c845c2609c9cfd17e95a01a468912d7fcfc97ae12716eeb9660465d25ae4847bc82448c0b38905d03e1a4e7f04a29533dd0491a1310c4cdb4a0c0caa2999a5cdfafd1fb62e24849152ec0ed10c5f205f67d4a3d4b21fb7ecc2774becb644175be4638e1a60f07421ab2a7030ffbbcdeb2556a4d5d385bb62e97e9ff7a15a8362c814f926c5e0178d8a41a444972edcfdae092c8d8f323ab12a9e088f51a1e665746eae305939637a284fe4cfc8bdea07d9269d044b17e58f552292565eae0a42bbb5cea7cb97e4cddc6d0730b88f838a45438e1fdfe8e419148f170737eebab0f68a94c9dcd8d38b7ea6db1bcdcdf51761707f505dd6d78363fde2e9ee941ff1b2cc32f0ec9805a74c4f4faa46d9d045c5bd0da306b97e779233e6b9a4632b1f024352633d35883e5a32230dc2e745a187141422c96097b990317ad4aa62222a535973736019ea541ce58928a6f4e7541b60dfec1b138d31bde86b2aac27d4301cb7e6d4c31f2f1c13497154a21766199051bf424a271e3f5a730db5d6c2096ef38bfa96a20e25fbe9130d6821f02ba8004a828303295e3e8603773f2655b5abb649a09b2dc0dbeb9fd48e980a9d5b94ac5e7a0b1c391ce4151ce63812deb6eb038b9b4b1138ea5b5863d7b7c41c4d1d187c05797580767fce7645d2dca0326145d25c5873e946b0245e0bda99882c57b6b7422c81a0d6132fd06e0b6a0bf9639efac89493e3b559d3b760ead2c2beaa88c51e8e77871f53cce5dfc23d300b15b4160ec99eff990ff8e59f8d4528e64ba842323d69d6cf8db7307a4383574e3d67f68f3bb092aa4202f15c346c22295275bf5b306f9f3df610efe649c91a8b7388496353b3ae3f02033f5e9725c90cfb51ad85a02f1f93fbc270f826d971be70817bf18316aa4ee970e92880380c89fe03f7a2eed4e265ce6b5e2a7dc2bb8639a2891af474d1bf24fbee0488f3a773067b4d9cb91bd068d4cd4c218136203358771f746c94563b962179cf79b2f7eb39d28af7ace11411173013bb6d3da6ae5506b71492163ba26504471af0e918ea42191018764b90dca50bdb730a4bf3bfb44dcefd5a35d676f893333de7759fc1c21318fa8cbb95e0e505fbb62d8a481b917ea6e19487a14810185f814d38068393666e95679a39d17320d02951f58ffc90c02cba4041ccd62f14e5583afe1c23e9a37b913623656dbbb0f106c5812cc81794512532853163f07eff21f386e0475a35c8449052a399ec07c086b2d707f6c8fef160122a95fb5c2d7b35d4b1bd8ded96e9607c8dac3e9e9b8b36ee0c72d1facd8f33ee74a5e542a46f358f76e8b8626b330a94b424a0de5cc42515ab2aed72182e1522f30920534adfed46068108a3af1df1e79e996cdf9dfaa2543fcc3871485f56a6b5dd215bdc0e507565b466beed132b83d51e0c04e8f26b87885c80711429f27762a4af5b0e144494b440dea082ee232489fb0bdf7be6185b1d5ec378daa069d83a6ab94aa7d874955f70411c221ad306d1cc17e874bf3756ce4e9c33f01220bb4bf199dd9a41937c72c960252f090ced4c69a0fb15deb351ca797c520f0dda8a0830c831aedd4d77efc5f18088c229feec9ae853372560cdeaa19a71ef12c8271e9c1e3ad6a8166008318edcb63b18169dcaa6d7034da600fd2aa54e75b6edfa9b8b11ac0122f437d4ae116b0a295ab69fdc8a0e1a82285701cc0dfc8668d698efd27ff9548fc9375e932a55fbe1c1c5ea66e59b0fa1406ca1010623674b5a2fb1f261dfb85cc3f913e32fb545dc8b26cf7e09ee12007f364c695d307b510780bf3e2a4b137769e1e0c733a5c1bcef69c77c06081cbfd5ccabce075bebe487da0eb998a2c1dbc53444d5d507fcefe45317bd9a1b155d0472c2f10a026a3030d1e5d8efcb6c7caf8879709bc14a027efcc26c75586328cbaa087a7536755a33bd3208763192b857e9efbf89063b9fcb4210623b10c43c46523870d4799c5adb1fcdcc1db414de50b0a0196c776aa3f02af870243fbb3fd0ce0f30a81f2df42b13665bcf5cca436f6f452f5e5790ecb9e1e0df94c1192891fd841d70aac2d8f239341f192afb16f38a6b0774a6bd8cb5967abb63af7ed0d8cc89b5bc311f636d38f7a3f602f25a86fd5c00cfcd4d7f9dd4eb13dcb7fd7b6c5e39bc7fd2590e7f8faf6de9a2891d85c9a268b46a7e815acdf9ffb6b71fad11214487e70f840856863fb2b01398d6641c89127a42098e341f59ac5886df0df0d48d66ba8d395c38e0108566e1b9f3a750a1277f9d5a7b54728953c95d132a4d29e7278bfe0fb17ea598124ee530d223b5ccb1a7688fed482d6656871576f36949ca7e6446729bcc42c2ada85cd364402130dbb44c17f961b806857d103a4e9e703251b428230161f352d37962094d76499034310db15346948b61f2d7e1acfec28c9e8fde6dd6a5713ae4b02bc411df8006c29deaa010c266e65f1e9ddd071994b80a6495656fee4a9195d191643e02c26b633dbadce92e5682b90ce6bc44649e20f8ef56556d79a48e8989682c1353b4a8312bfa470c807be02d3e50539a86d20f2b24392f04f6524905f369db86c41618cb137e11f0c680a0d49bee1c8414c4481ba416187694f67cabfe386955080596b43ba956f7654208a943d118ba24571b1d5e163975b0fbef0b6ac88f166c6e1798e6b26517a936240cabe4d79ea16d6c81236913f6539e64f4b30aadb32a39f60d1e068003f029105b0d7bb7152b2d6241a0c6fe6930687239f96e3238f903f91fe5e9dec7501bc174a38edd882cafb008055b1ab4f6cd558277d00214a7edd52ffc23a2f8aca799e9d311b0a16487cb5b99865a49acba30dea17eb78be55af13faace5230b2a271e6aaae6df303f79a2a97b26e8e94fbf9a06ac1955d0f6323453e313dff6e22995913f3c7724ca52429e47f0519c9d4f05f1abccae07a69e206fc15a0fa546f2961f58c0fc25f451cad3fd0908f46425081434ce055efec8204cfd02ed544ff957375000bd0c6ef3b541f8891b2bd2977b168797e294a8de20d170c15e4268a4bfee0a3ef4df2ebbf661dbf13405016630bf8cbc029ff450ba4011cf32b4fb02d1df4c467ad691f6444a02997370684d414d8bad8df99c11482bcd5ae0dcdea0743e6795631864d86bc17ed2d67f2ad036bcd1006f8b2386f335d9fb101556618cb5b4c465873185ecaa6799f5d46be6fa76d60a1bd4ac83eac12e2a87590272b0a45b50555058dfbf28f42f7d6e45bb792c9cb414c1034f86310c57270738f646d6a70f978758b678c24b2465eae2760cdab06d4133f8a0fbd7dc9a1b146dc34d296622aa45c26469c8fd0c58a8b1a4c060da0328eeb303aba9729ab6f2c271dd5537b44fed9234fae029f83ee54e816ac26723f9cd77632e2ed95d9c47ab6a8d1d316aa968faa427082dab0f35f3540eb204e96dbb142d9ef4dbbb588318918c050dc78e73b64a8a971b98f4cf938c299a61d56e712a14b9076d4a91d18aa76e6a0365307e502ef8d91c3526677efc1e85b09ba70410e77ce4fa8487a1f393b43c140a32211b348ed24a5b4c40ca16123a2a770d933151fca703df7c159dbaef477a33e5b7f61a7f049748bd03f14ed402fbbad2827c05c4c67b4983af0f8fa5796bde9e58c66060af4e0648ffebf5f837401a39b45062fce740b0a962f0973f23b2408f95096d02d7a6b1189fe60876ecffa9e31819f08383400974d81b6f3aed0e0b15de3f37b89bda92f7ffbf147af7e8ca7e8a21c5f88947474902762302a8690dbd69bf7ed8c09eac6242ffcf8175dcf049f88a7631c196c015f3e42796b780358bcbe204199afb6c34015196fd408d039d95a51e0c592e33a34bb71bf4294ddae158d669d14f48fca666146ce6ec7da30a0497baa232b0b021ddeaf47461060ca490","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
