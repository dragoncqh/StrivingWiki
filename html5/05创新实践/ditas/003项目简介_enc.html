<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"81d634ce4d1806e5e20fd045e803441645b574dfcd3d223f086e19f0f4034991e1094a900403eda45d4a5b1a0b754fc75b38f373e23c4400c50cb0cd2c95c2dd6f3b8ba6d58c2a46e3863a1401c91cb91d916793b0949b6bfc1c180901452b5af8ee51ee4189d4028444208212aa89e60f62805f6b3f43fed99f002a1340e44f8564a4164f026c0c2561cf09144ed2c7c8fb2a5e70ea9a2d08ed9029b52c1a6667bda86a019a492498f962baa30308e96c133b6c9130064602bc7fd0684fd745ca72241d509c677646683559fa92cc3b5899ce74909a78b687eaf6b9f312936d9e104cd9c8bfcbf2f35ad025ed4fe55c6ab64257d2cef24b2da9d6a58f7240ac03d0b395dd8265c82921effa439a6848fbe56f4e576d889afe8c861d4b8345df88018fbf81eef9131389fb998db83ba0531c0cd94c80c12a846f648355040b7dee74e37020deaf768996016009c78ebca43e09ac8ed38fc929e533614c73ffeb585fe99b3c2b9bdeead2619ef836e6969c28136abaa48576dea07a928ca2d5e19c586eafaa4c4931a55cba7eec1e58198325997609943f02cadb813f5191f09afcae8a246a2be9135d8538a35ce3c09925a5b110bcfd479b2d630493972b51e8ab4e72b5e795f7094579280e5b036dcd094f47864107c3c3e73c230e55ee1786942ac9c5af20f59d690ece60975afae59f717a9768c80995857136b8b9cc26492e1d518b2563d05f277ae71086c474d1d17f519bea114e73b86dcf0a6c39bb0c6bd4f5270c427bbf5abc0b851d56458693a0d8df42c3cbf665c84cb9c25457f66a97ec3d16c654b3faf1d2fce08707c4b830ba9877db3e1844268c1d47ea18d75a62f8466054b26322879d370307819b31eced602101037a7759387448e7c37f4003f7a1d427e1d17ab992f2d7f113575e7715e3da882ec2be72a14eeedc1e2c7aa6fbd61208b2acb9310839ccc27c8cfdd3bda11357bbb64a728cb1287cfab6d7748ae6066d988d592b32ba1b23694da9941d65392d06783f7e6c02aecd60e91bffa42fd13dffedaf58b26b6f6b24ea89983b07dc9f0d69d0b9e6fabf92b994e8ffb199d54b09fe4b6675b26ad2da5a7e43179a9409576e13b746d719a0eafc22a0809f7f4f11c5f85cdb0dfc9f025559295746579437831f571762872c6946a26c0d05a593b16ccf9753f58b7b4d775154e24520da3c4eade1e84ccc8ecb4672bdce209762a99fbea3022da01449a7ff9b7085ab0ea15ea9fd4afc77f47c5241b2c134c5de67ec066509d58d2d7fed4ce991bb23a89507b2b81800d47dda999969013874adb499921ce2912c54942f840bdec4bdeba6f8cc2102513b7a9016ab70511d1fadb25c6ac619381e3b416e1b350b67c00bbddd7ca1a3d7b1f27b1960c42dcbb91badb695c831b111350782aeb3b58c5e3881c0d0fd0d0bb87317955800627c271c69304e68698010624c1f52a3f3d65abf71ae89ca0de531dccfb31a6e7b8e34f810e49fe939fa4dba5ce2f2d8e9ab162544be236bee31abbd115b62e83e51ce60455f77ca0035098837efedb5ccb0ef0b0c3aec03794b122040b84d1fa7348465cd1c3dbb461f167ee613e345c5e1394f382644ec4ad2f62dfbfe4c9ab9c49810d230d0f7b933059dc0957c3426f1913a00cc72bbcd9f70c42b6b5e7f7ff26990603e975ed5a233b75beadce37aa905e07ae0c50c49d47a75362a9427bd1167d96adb4bd1464b7611a5f0fd5ccb58decf751316289a1560522a01c162b92333e4e1a4b2af3910b92347f80a85c02969f42ce82be48f86f8176685a0a17b208c9454baf204d3c19ac604ce03e6e200a9d5964a1ee01cd32c1f543511291fef206a4696228cc6b10156deaa19c6023d3385dd98251c9ada33b6da336fd470b72be89e0bb1d3741bf8e8e81decffbd1afb6c64bc9db4791f8857e96e29ae7302edab7b38e29cf78fd7fb37ac8876224fe5ff23d18e480e4badca0d6aa88932727b012ce73211877eb914c280bd32287d2d39885e9072525f96a1bc6d45191e6ff8f9a33dab68c1d6436d42a2934abdcb47c0d9499f93829bace4966a84d308db183b8f0e810977e2b7fc1018f82b8ca94e2be3966aa26ffc75810d2c9d925421ade73620c3ad68b94e5b890b1208da8cb16636001b1f587a502c3b51510d7f139c7b1cd34c6198cbb3a9bc9914efe68c1bf9f75f6a718d45d46e92cebf87ff421c36d75191e059f81092fa2a19cbe5d1d8982b432acb77c8cdb4134c49705eacdff3b375ba5213f9ec3e63b77fd76f30e35f8c1d8c67478d6281bf7c807e17b34dc9ed7a531520ebba599709be79eb0303ceb906b2ddd133517d80db3aad9498430e06c9aaa0e9017f69f8272a8549c00a39687ec45fb513b2473a32df32ce26df7f051c85107fd7d9568de0d3f58c9eeb4bfe7cbe053237f277f1cc9103d44898013fd9371aa825b4ea9c54c28de3a1c325b5c030eaf52e8926873b4c2955a50e9919fd1df9eb5662549651205c3e5195a84b58a87cd7712d23af9d81c90b1bd8692f68f211caae8b02ab1b73a0c633d7716451c15caa0dddd6a591b8e9afa591ccf7443e98efacf9d2b003f4b305d7cbf03b8876c97386166d76448b582c312672c68f8891adc09691a4ec7c1624beb5b461131183de0bda504d94e385b2e0624ee91b78fe5533073c59921168a0a7501ae13314e842bbd8e5b9849e608bcdfdad7a30484af6cbca071cae3b0adb075287d07cad79a7d61b94b55de7c266e9e5446709b4e26a722235676c9ec62b26fa571ee58ee94fc3859bc39c3f9c38eb91dc420ca79d7b787ec8bba157f2d4ac256c7dae46bf8522ac4bacbda78406ac848dabc5c2119011eb037a45bd63c406302a42aa0888eceae069ed8003465d7e10249827968a233582da13ee796071a75230be52a72c210c6ec6479fd27358b023ed3486434f6b148ecf77d41ce2c04ae0ba390eaccd941a984b3978568433fd9de34e41ecdf2a9f6f032468c29917aabae727241868d862d38a6ca44fde2ca7908e811e34fdc6e579297e9803ae4231e5241e89d0992b34e1ab567c74f4fb3d03956c325dce80d6d98ee9c3e1347df9a5b5947ace7fd737ea8b3138318ee385f88678f207aaabaef04d4c58c074120b2b8035ef7671a923c69b43b7c01d5e58d5b18e1dcb019dbd6950749504e3cc39f758653a238232fe3a5e2283838add9064c6595e071b6ddf63e0ed74f148025b2445cae080c961602ed133ec2abd9b7dad529c4d606e04227c761d77cd47683c6e76d54ac2397dc343d7c3410d6fc6d6a2c201db61a534fab4e74a17675a987ff84ec11014d9668e0e2a64647cf4b8e982e2262bd3fa93138d4d7fa93db2251899bf22689fd3f0824e34324314a23891331e71a830482f788a67b529b8f4eb00ee77f76d76c77c15fd46a69d0d5d1d1d3d23b29903787fe737df95330318481b55e0205c969646cf4c2d6ee59c8fae9f84fec06bbbf0205c432b7db2c03c553045a7f7f695b0fa071ba610e835d4cc34472efd71e183b080346e0d0914f480605a285a2e13e3342160598ac817fb61703b1c77280d261d267238c616ba0beca48bf9ff2000b5c7ccadc7402f040bada670368c33d19666782819e5a9d522dff49e5e6bc9ea5aea5b5d01bf8a16d81f99df4428b24c86dcf126aeda5647f09c9d088d22336d6067432a082df6d33a5f0dfacef83caf7f8601a26903d04b9c1370e5b6529568c4a11a81eb57a8515659fb53f279587a5e32efbddbdbd182ef7eede651d5b4c0c37e6da50d6b899c5371cf5c53b4e74065388ca3f2cf972bc2e0438670ac86b93e61d9c1c168a0519b5da8ec24fa863fcb5a60165aab2673763136f51538db4ecff120fa2b184b4e4b8851bd28f402fd0a312bf60326fc91accbda9baa32e92c6c6940ce016b3288730dd110b844624b19f3d4074b88df5282387e877eb6e8062a01b18140d4bdf3081985c6e7008417fb4a1a46542fd1e60a863458415c5728247d5aa986f9024d4db93a2566545512d33e5e6b38d51f64e4249e5e043d288f00c8f7f025bb62c6b7ce5eb2acad42c36f341c249b31da9a050b1ee9a5dbf5916bbada97a2a8f19643ed8a3f34591cf933b2cdbb47bc647ad82d084f459301b7fcb0078091ccc4e18fee7b5768b18230cf5a698810d8742b206f89bacd211719d9902b74fde0fbf50d832384b626d7da2183b47b207b6ed6f9606afc2380c166305bc12475ec46fa6bf6cf5c09ddfaf5fdb36e2de2dc50059c862e59de2495af115f71e7a9f3aa3a8ef38d9572f20b8fa7c8f0b1c8275f8aeecbfa22f2d1640255124f3af18964a788686fdae7f6f2b88a61d2979e50e99c8789cd89f6e0ad556f51632edd9cdbc35c22e919f708b29c5e16d7c2faa8c6559592bf7061373afcf5cb4098cf00539a4023d846ad88c799608f7857b3a0c57e3c976f5cea02831a97957fb08c6fa9c158980e97eff8652d8d430fc1f85c3ae7dec6a8aad81d7ec3bb92b08046ba7bc36ef12d99ca14676697e4aa930fab3991c8273ea59044f3882f40227f67a4764797621fc62c4eb62ca2c527fffa5de48c06589054b26a570c7a6f3fc3074a3ffd2e9546930ae78cb10d27c3386c9fe231a8f48c2fb039f7e77915510e29de891b72ba2b2869bb55180cb719f64f093005b72fd48d6c043103e25431236c98f2bd481b70d5cd306a48c309533a0af5c3cd980ddbb95656a2cd9213c5df5dade6a0db35248edf8a79d3308f831df6c1f00fbf522a7e4c61f9cc0fa0c24a84c09aff01cc4ca77444e830b8c01ce4e0a763f61b6fc9c2c9725f9e97bf965ccf0cff09ee6500043116aa5c592edc77b13178d2ad1493f11dcafb101a351c00233999740ccd575c839fefa0eeeb1c830d321fefc247b80eeab6b0f949d69568c886d07318db4c34685120cb9880f7a31aa1ad65a9790ae450a2705b8ac3126fcb59d40fb684c254c7b7712d3d0c58370048b121403e7a73576035980d11dd0b0e635efa5bc18769a9223cef0fe876bfdd71038b8676dcfe674f27044c51e1434ed93c8b242b4c7b1745331365d5851b3e19bff9014a255b024abedecbf39a0786b544b38f1e5bd20914773159d5df5635c5a5a10d15ddb01bf5cd0835f28dcb890a360830f4007f6f4bfa80730a9464d6ab760bbdb5a72ce682ac0b2d2c2f5d504c371708a7746f5c923468924d6170ec22048b76c1fe6ebcdd46e737240b14139692ce6cd92fcef8c7adf270a0a84b4cce4e8f04561a49cf32e498767c48b1acb32e123f5152360f2d5ef358256e01b61d49909c60fb88ba0f92211d56c70bbe5b2290f0d8fdc1e4e3ff91e9669edb3f2d33ff9b1243531c107bfa0cdab4c0aeecccb71acc5f8ce9ae3e9ba9aa1ca33a63e34e032cf706ca9feeee9989be85f842d0c88986c51b835845170cfb755f6fc5b93cf57a5d7621b41cd742d1a78611fbd07b83b5c04f54d16091ddb2acb7a413ae0059127bee3ab92f57df5c87f7f8227e0781f5bab571290724d81f26c4e2db1d92a0bc813f5e1db6f3882fb4b5ca329731fb9a87e83ce968b2a72d85402c039a36620edf4601e3ef175a4b6119685b9703b6ac1c421e4453f1b28f279029a53d96215dcb250eea9db22a681070e9d536218251576e247214eff8719a56ee353829b42d054336531898fb8cd387f7dbdc97d8b258e23c01ff6a3a8ffcdad54e5e2d046810d576ec7cac24950f58c6a2176ca3577706a16d71d6a55ef93c8c424dedcee3019a09234cc060f173b40ac6edf3eef25df06aab08ff72ac23431c28d1137a97735b8f8d998be7fc7190339d59d7a8babeb948bf5097893e03783d836618eda731609bfacc613e60a05e65ac8de3d4c7363db2d87d3819080de09177715366ee779fc9b5897e9336ce4fd68779a35000d4acedac3817bc090b29bdd4dad5e55f8634eea50bad6e72676ac8722d10dee2485d1979f7c7b381711c15d76ff0d47e59eca657fa3a3f1bb0ef870c95f7a5b36ad8d42a7c51b177cb68704e76b4693595456fc784bb216e1cb3930f9f499c65145da2cd7e8154aa7072a3c72f6ee3028493382e64284b9541d2f3472494405ccbc5ae45b9611a556f0efae38a8926bcccee4e0a9c282ac05ec793e08558ae95473d4a168dd06c9db8d104410f4acfd23cbcbd50e0a0d891f13268386a39cda3ddd0f2f64f916fc090b49e1a5a943370746973da0fcb6ba2e3d242d8f3e241c6ae9019eea0db51048c1f29b63b7d88ad80175428b77aafa6c1f7c1e22f3910e2a44e70bd7e3101d5adb4f8b982ff5ccc6ad7d5dc8fbc25cebd61736bb2f5382919a1a961396e12ac4505877bc3f5ab60472bb44b4631a997b0deca32110f3d8872dd42dc3a6f444a7ffc9548afe0514e86883c4619cfe9fb60eb34c15ea083b3e71e6265c94456a5f91e0e66d33a7a82000a77b1e350c266b9bf93abaa3a8736745c17dff62bd1f9f759b9b465dc1dd087f74d89c48c62f3367cda50e954a84865b63139cd8c4d2b841d22a583da51808dba9e3dc0223600326927a06b6d6386621b92a905b678c184329b2300f44ae2aeec62713fcedea1825aaf09859fe778f05464531c025b8dc6c519b750d50d3948d2f7a6598109f13050c5ee9a0c9c88168d024cdfa8292381bcd2f25db74d80671b1eb9c2b070da502fe0411143439a3c7dae0046da4edf9722e6d951c2e18a4d94296cc418d7359448ec8ca7c0b4148e7ee57553966a14b4ade123c098158e40f1356c4451c6d9e6b6a3640c429c3657cfba1ffa3ecffc532adc1fdb5a48d55f4122452e484e0f38261c05c2bcd0b9febae7c3ed47896f08d12feac071dd82180ae3b7ba0bd027cef7b39b357d7492017b04537ac8cfd86de4ce591e23cf4bdfb4cb268fa981865f3d4ebc62113e9e49edf52cab33b384eeb06829a8ed76f7f958a694489307b17c1d97d685e3e12e9d798957cf5a5c9d40d46fb95bf49cd68c43f0265a695ad670bc7934f5a490a1ffe420ab3cc426145fd94345efbccbe857c49976ecae5ac7e3f0291b852c579aaedea152ec533aaf006d9ec42c504a477ba70dc2707044598b5827c04442c2d440fae02357b759a0a530840907282729d4eb87113cb433c99a1ea3d9b49a9333161bf445d5478400c21fbc41761f650ce2fbd8ded3f4524e4ed0a2d4ffd7d592446bf539dc16803d68b633acc6285518b38f044aa76e503d46f14aa8163a6fe6c419f2c453c955d03791fabde42eef42fb66b851f8b079542835b75957b44eda06f9f941f0c5e15fcc388a57040a9da35b111a549aeb3c1971dfe3e7d0e28d6a20030c2c9a7c2aee430fd19b82b0a34fb84ca7e580743447fe4029d5813d2d5cf5ee209fe19e03c1a20afbd5d6eaab00f29934636cd643c6400c9e2c2f3c38af6236259e1aa45bfc20761a5f735278ecfd2d66168eacbcaef9f43250f93d6f97052cb6641b6dbf5befdaf1a060bc41e061efe4e4d7a84ab111daec2226ce8a149a39f1fd2248b5da69d323fa30423408da57f3f50af92198f4a5444d5a680ea1bf857546435f3f1846108d7aa3686601f3e812ea3bf338ba00dc9976a126a77a8fb7c0e8d7cbcdb50767cbaaab90174c1a5b1c696d05dd789a2eb9a3c411c9fb768b0c11499f568a3d501f80d4870ea94768af4ba992208c0ed9fd11ecb20c39fb979ab3062a522900cc13af01cc7fb7022bfe4f91ec57b34c5e41aeddf207a1fb318c607d0f9df03c10869cfa82522a313995e9a79d7043b53e30df2430a9264233c2e279fb108d377d86397a5a1a4beaaf4472fbb58645d2d846eff7180403845ce0d41d8e780fac8966404ac4da6a5fa024753c0cb56b4c7a2c69876b76ada427d39c44622104d564715a43561c88af7ce7c202c3c6e869aabd1bc5e2f36d6971638901d1b8e2a12938d667c14e52d39830514423c3ff93bdc4ab28ef3f02b0979b89142eb1bbc025d9000dd1e8400718cf416d9040343af7ac98dc5ac7796520a9efd6f5cc8332434311bef1624daa2a3758f6e3419e5ec4e6e360921e978759562877984460e4928be7671aac996aa7c981577bd70d3bc62e42a67ee0318ad94c8c66d3d368a20f3c6e621753b8b6c9097c652f6257e165656db73a3af095132a5e60bff98562e0bee891b1f40b9a2ae7b7d7235ec769120f9dc0ed88804a650828758f28e423deed5f6f6e053c68c6b5631dab87cbc28cff04303bc2b7881ad3856a3846d5ab870e37f6397ae77415e4b0f1bab2f142b3cdc8f45744f7930cd23425f0ac2dacdab5b9a87f0244463cb2dc1b2e46278004a1290d3ad97a3c649b13e0f4abcc35ea1b4b0e0ad6bfe910827b8c968620d5ae95199ebafff87c94716fedb3eac45fb354cc6c74e3a3190915d7fbfcee427c5c46be52460455b15c5e324814cc9dad87c16e23a38948bab5572957ef1b46ac0a994107547afa97854762757b7243e3bd0da01c5616425ee563b614eee4f6460ccca8c27c709b5da8f0461c8f578afdd27233ce99274d3f0818cf43c703136e6cf53afd31d05b5b592fa1692230a214fcc63576a361c569ff5b77bc57afada6fbc900268b48d537ad1e31bb894e5b50d99567fa2ad7644ae276125fe614244f8722210eb3471695d2ef97be819e0aeeb248ab1f1fe1247fad3c1433e047ce3da531e60b6faa95b74f3abf9a4961c690656bcbbcb278ae3ef7e75a6b9eda4359ce1e423579e9298fbf80eb0b765c634587b893c1073ed39a1847c61d834797647964e83907dd995dfb8852c33eb3ed084059e96e77179dfbc7668445261323e09e368ac2e98befb7c80344eee706d6ab35cd0dd78ad49ed97f1f41a48c494cb67ba9455394fbfa65cfd63ec8721a7509cf99536bbbcc5cd0890eb7908d68266f4072d57840d99042839694c6f6bda6eeee97bb5938030fb3ade7029566f2200a99b421057321d50f659aa889d6cd4f32f504bf3034b77eb64625e8061213521689f4750fc93654795bc9bf7dbc948035da5d9274ddec95ccdf7026a4f9b2d6dd2af5c76b2f1ba415295a5f5287b62ee1faa174062352c2795a2a64249e8068fa4deb4996f3ce9955495d1133e8b9c062aa4eeb6c87ea50dad3385ea02b44d12eaf26c804c21b7039b8f7af0a3a45cdf1f209a3cd5b5d10ee3b64e85587b753e213055338e2f4a6b7d8cb591ad21ba4c341193c006ede4f1890a733246caf83631f4408525e09eb4cb01c12f9dfa984c743d12c409892c0193dc647bd6018a599d1d3dea5fe77ca74fdf0a6a60dd8c20a6651bc6c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
