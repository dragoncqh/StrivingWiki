<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5425381e0449ae23eee84676e0dce1d1443a082d88ff09c9577be743897085eeb3aa80f8e5e538b1799825e4797f3d4b360e53838e516c048c354150da4f2c10a7a6d8a370d01b3bd3f112987eeb515dfcd66dc004fdfe9e8ab13e2804b5273cb5c95b8b7b289183bbb521d3b31d2fbdefcf02228bbacdd61bfd30062a4daefd159da23d0a044481203ebdf0ecd18821d0874efe9a279083bd2170793806a01f6ee831de9203244f50e5e9dbb66a1951e78e50cb176105b6ac8eded2ec7ec5d6ed2c29b89fa99ebf174990e690df4fad7c25a49ec0312d03a6ea86a82a6a0be3baf9cf34354ba8f14217f7ec2ee754f5c62081a5381e991ff1d3202003f6f14e5c38661f3037a3c1a30513e27ae063c294ee5e33f4b385cc2439e2e4a2eb60326efabf8f46413af3f48831c5d56cb701388dfc3f4da2b8146e2f5b4769123214d033c4137b3a94dff13fa8b6b8100f1884b163d877ab4fe3fe35ade9ffe377c3dd6e14cc0916283e83fb03b81ff51438f439f684f52bfd9347ea40f69087fa153e63a2510aa3da8dfa396fb30d4e4810040aafbae419d81a11018e73b9fb6c27d910e2e3bf883fe27c76fede1a06461ab2fba9e77a42948f60bc59277bb8b1e2aa8dfe2e17778391677839c83c70811cd7b83ae8beb91ea70e86d5fd4a6e926936df38e67977d0fa0fd5f97e22d7faac872f33db9f2c04ca110a3e583bedec6fc79e92bf1fd23dfec7ad12f014d5f0805a521e2b232e19195412c823da420d45f966abd42d81972c8e4fabbcb473e9685f0a75776d8730099ea9b3687fdc7a206144a53bdf04e67626e4976c804d2d4d068eb0407e31a7691a7369485b616360b9f50622ca2981cbad150d4f30a002a81644e473dbb579a0b4129299a9e995723df5a2b5c14ef114d0dc880405d1f55ef8ae388e1259e332cbb6b5526758cc8fb7d2b63d767596d92177395735f9a7324579408613d24db4df0ca4fddadc03291eff6947625ca83c5abfea76493c06c3829e8a2972145b732eb6fe084520db03057bdee3bd65aeacdc054549e81933d311b6200e199e9e37eb9bde8c75be10c682e7f82b25149607166bc468e89ba59514c5caab05cb99ce84239d77ddbf47c9b9449dedf08cbf99151d1344bbc4585a71dcd74ab02b3a282e6ff6014ebf89e676da2dd887a1313ef243b7dbeb1395a3bed44e18fd9768d2067a3afcc9126c1b1031bb3c6b0537a956b52b15fbbd46fc022521eb854ea2084e61b157b1e76691eb773d402810dd745399a267e6e8348952626fd2464a3588508c28667d56c8f29e9d4431a2a6c8d20ad45bccdf5bf11e95698973342ae9f5f1db1e60a8861715fbe21d9c1f488147bed94ee087bf3d90b0c1d13a8c1fdb750ec0b09e99b378f297b1e8fb7ab75304ff8f85e7604dd51d9caf08cf4825f6a1399dd1fd8326b7b728c0fe013b5a7b6987889f6aee8e1367b42a1ff23118a295336a2f6ccfb6ad6e85c6ee45738db052a4ebada4ae44d46ddd6694ecfb1b17b8f57e6226edc7beaf177537b5b7e120700f83feb18406783852a03573f7c92581c355b59c939945b58405b5f3a647f10953637e021f22cd346393384d8a426febd6241cc974c5080d2b5b753dcc3370ac789e94d489e809214a321a2f4380a1c435ba254a2d7fb7beef77e8d6feb66d0ecaa15570846f143807622c5072f1ed1983c59d6b5e08e8c116d92cd2abe0b0e986bceb5f57bb396daf106c47c502f8fbb18b81b4c2791bbd0df3ecdf39f727880b111a4f4d174b7ddb85bf5e8b47b39c4b122673e60ee374ab1f792820bc4018f4e95be75e0cafed0c2eb1a94b51fd6e8e3959dcc1e93e01f4bf1fd6db6987846800196d44e4a8eb9f072b923889c78bb58843d0f092351c68e548e3e930bf34140f940e30906306af09a770f569982bb3ff5213f58e715d1a28b9a6dd6c32c9b7aef1a4e18b2b4acaa982dc10ded58cd6968b5cce4f1309ec8bbdc193f65d25fd645c97719242bfe9936fd06d82da953667f335aea953e1331bb9d8bc138a6c627103b140b192aeafdec8eb0bfed7a6fca2b7149663da5f75a4cd1ba1c39d2a828562f7bebafc51de5ad3f5e786d9cd5ed8348397919f89c8dc3d9cade74675e057bef722f9387d7ecfbf82e9d4d14d996b739061b596ba88da0b4ae5a9e599f2d1c2666fa4f55cd2bb7143d8764ca5bfb448e3009b798ddc0082e1fc1668a34bc0d50dac850d874dbc04286c6ec88a322c639a1a8cae251ade70edcd1e3e0d0df7f8065195a8e7dfc166f835d45ed5e7e410cb6464faac03c404813a59c08312af1f220480f82989398377c22cbea7246a08dc76608ce5ac3c46ef3c1b2b6072d9b0b3fe748eac05f2ec69d0a382f9d4ed6526f8adca108716cf36ad81b25e8d72db8d41650a6e5597ed96b9d5d59f9e609d4b8a3ac5929826ed24928f35b36b726b61be5550c0c78f399aa2ebfd84f8118b20def46431205a552d14b416613785807b9c47dfc1d0deb3b27cef3b89eff3c902177a758a5130cc760c0c8e2fb83e11020d89ff58a1bbef82f7ab56b47e8a3afc44e4b5ef7ed8ed703a3bd7acdb445d62f46fd4acde925bc006dd95f188c33f4678e32c80287fa232bf882b6780f71cacd0d508265bdf10c9a7d78061e339cf6baf530d4272eb455a199668a359d8fd551c83ef098478c8388909f51a7902450fedbafa8c9291389c216b48c7b078a201a173e5f8bd57283d7fa380fa81df7a0d1fe96400aeb95b6dc0648884d4206999a132cdb1f1096b49cd26e4361a3db5bb566f012ea8b72d5b1d51cea28aea53da70e2a869bb580a56552cfbce432145a1bc453fe155cceff5879f45306f3658fb86bde5c734222c282b60d9075ed9a9b852aef1d28086ecee386042dcfdad897cd60b1139c2832bf5e2d61c83ff62ee00bdbef3df494b97c98402dc278aee2e6337d14bd4dfc5825e5ec1c977c87c675ea54da49d0b697384a8e34e85ceccb7ed36e891606ca3adb3c54cd43202234b6005f7ddf03790e0fa228d364b6a9e027142bb0ed591caf73b9304fd289fccf1f89d35e10787a1cc17165ab60da4a71762541fc258fad3e020a0125a29b26c18584917fcdafd06a9aa29ec779ffbb96c747b145376ff502f9656f6b931735a1e949e7e860bedd16f23179c8cc4e93d118198b8184c422785506e7c38faacdff36839e092ba6e116a7971886917eb3be8d7511195b23521d0980eb043079868ca85c0538384c0b9b5ef4abd11d61f837dfd0f9d6a6aa8b2d9d583d9924f31bd1ba523f2cd5c90965e7af014178a68512d360b4d5bc5b071bb35d321de922682bfcc68e4cb823c847d18b11a3cad59f0ff1ba97b798cdc3459bc9d8390c89553ef6d23e38f1389bffcc9610b422e4fc054811a0ce0697c8b2c59fbcda9faae63c6c97f816645570c426e838432daf504afa18127753c91bf1ac18967e3d78b4b993fdf699ce79376e1ea20aa2c75ee69198d27b06e7276c397193d909cba9b1d7adaedf2075f799754e1aaf700d6c2862e8b09b0cefc3a60f2d6c1b3f60343e715795b3602df47f80ca9ae106c9ed814066a35bd09380409d53bfd28b23d56866d80cb76e162b60d9fc8f3e6c0f2756fd0c36fedad6b62010448b79c85b7b93a919d2a2af11907f3f7f572b84bd5f5bb6e3075ec4e04a6376cce8a4193f86589bde1d87268e3f2c3393b6d8d4430499ceb27f25747e531cb72cd344e157dcf81cd1bedb14d31e91ad04349b013febb80c926b04e8d41704d8ef5e1c0c83e8e1b8d8a288eeecf0e85199519c62cae7ac444953efb909e1990b6c1265c0bc362a5fc038d280a4a5896bbf0f55ccf9a9f1cc644e21875e8e605e7866b4db5322a73a36eecc4a5c01a5519b117af5ad70d8917639063122a3c18533212b149b0908573795b2f1291e11ddeb1021232162fd60eb5724a8335f7dc462cc820e83a051fe2bec97bbf509a96e9ced3808de2a31d79a813ed5a6c5185d0ca2841924eb7cdbe53e91bc1379ef024b403cdfd5d376d57b2a24c94ddd65d0637f10b99ec8e4a1fea00b2b615116e6bc0c2801e28ae83fb8e847bb533d7eae9afe6870c5f04f00dd816d2a3c085a6a91ec886a1cc0f59cbd2b6262b2e9b68a11f3ea9ceb4f7f092d1d2debc31e8f81bbf8da196547162602a8656262de841640ff2e5407bb5b5ffd9a4d4880f00c48fe4e13845dea7c7da29a38cbcd15c22e24ab0d22741d6094c064cd50c3d90d8275fce5b64e2c23249120c35d6ccdc0728e4fce6b6145b2a501f52f5a10f90687d302b16ef5beac1a25a5b40e06730954de2ac960b2a2271db718e87bbf210e6f7420674856fbd71f978b07393b4b51dbe3b8aa8989f9c1698930978451d1001cb44ffb90f0cc8178d94b3637846102389f80f187ada6595fbaad17c7fa0b9e3b99396c527dff07baa4472e2ce1f2928303b68288593ad917542a12b66b8dd4f2746b2ab401d68d6066eae231ef8f8548776654768e46891e4242e34631d8365c18a603a9d31822210877d20f70f3e1f3bdbd1c0053c7c5ee3a426c825d069619e7470653684dc49d20fc0ddb316b54299bafb2011fc64ff1cc528c70e3c925dcb8a1a9036d804121441450c25febf4e1fed57ae1aec9210488774f1e25df896826d3e4dabf5cd192bf78bc7e4e516acb5f710127f4bb63a1006ab0ebf906ad43819024c526c038bb043275a5559679b3333ede2b8f8112b2425cd9c697deb8d25d954e183c85e2eec2783428bad27fcd2bc9e50ffead6bb60de4fe3b18c4b3ed27879a78e58d519acf0197b842af938742c22d4501e368d712c372a34948c1c7edb63d9ed75a01c0d6e8414e1b400b947496a2c72900d7f38d7e0929e135d7df787b98bc0f70fe920ffea2c87f0bcd3a16c0cd88ed3892b38516ea4a87c46ca34a45f319aa2450c0f2eee6458304a4e09f6f36f9854b8a449b4669c35734fd643b4239d430fc380beb42392940ec144da3f3e32ce864de9addb59c02d60fb06c31310a72325c5d5be9a5c6ed7884d02288cd1d95624358d0afe27e792ae7b54089b37af675f306529db09aa40399f89073cd2da600e443a3d0ad6791c94e271fca73a1bcbea46be9fd080b0f101bf2ade23d8af2edd8f6d8e996d6cd6929ed69932d10259a11f805ff0a55d26663ad9278ad6e1057077a768f450d3c6c9d4747211d58dd02945528735fd79cf689bd9a17ed49b440c799671db61cff1287fb6ec29ccd4c7eabd4977e05331b3c1686b015287c2a12d3cbbf04a07fa7a438e9b1bc5da4ab5be5ee2efc6a7362bc9e3ac6cc0836fb9c32d99ef2c69bc3df195d1f578281600d098966f30257e105f496f29e18634bd3918bf21bc13372c0d8569532b352d11ceea9f48a69512e96676ee61e3444a43870b89dd985ca497df5c124f1f921b0ea7fff72ee0109e806e3b420514b8d3c6b42abaf1e10f674ae7ea22f0831255b471f2100c0c33a216803a7d30d854241ae04bc07db30f30130d6a5959ef0e127e94e0dd4645f801cc6924d7bd837c561de08313c274f85373e4910edbabf19cdd7249e273adf07e04ac7a6ff69513db87dd73d5b33cb3231682d9ccd52abe03906a94bc4aec31cbe7fda9842b6c2a601e5d344f53f2684edc1dca428a23fa79b4a6d8432684a383a6ff8053f68da725b4fe186dd16fc5ae6ea88e613e757efb1af132c7ac2acf79655ed7435dd839b7b636831818e639b29c7f5fd4893176642acbc938fa48f17fee639d3d326e86d23fca1e9afb3bfd0cfbf0a3d851ccf6b969f55193135ba524968bd82ecc7dbe511bca162babde0b4908fcc43563fb1cf7574214dcda94067fe086fef8b251d82e4825ebd8a02688f9721afdab8c9a705d622482b0d007e12e2650bc1b35239e5ff5ef39a92d5856370d4a70b8577dedbe740c45328edb7f9cd83f09174b679c3edc182578ff59caf9552918e6cb50eddd02789a626e1a0e276039d98efd4526ecc4f4a05c78b2ab4e2b72008bcd4487635f3cd4ef8fd2347e55acbae20d2a8dd957b942a89cec1f1133b782402834f1dac3bb3651b899744af648b16483a168c0c04f663a1845e31609f177dcb68b35fe60101f1be7886e3613dea3ad9cd12e503257d75e31f09f2bb2a46b4be7a22e74ed6672108a220ecde9751d532e17d3dcd6acbdb3c293b4c32b660f8357e8abad38f4eb1f75a3e9a702e5206c5ca2a9bd9e14d0a38915c516d94cb0a689d8eac5d7f5b329a572b7866ea72e84d4f30f6fa30e529012f3ad97029db3b4e20a29d103f05270dffcd570c4b4acd5171ce553d5a4065fe0a772b049ddcb982a6fe3885a65050c3bf2f6844eab8635802232e57509e07915701560740347d6a7bf67fd84c4808558daa9da5468899f3859713bba44d8cfff70738660ef95ce13b8fdcc3314ffa1025f693f044c1ccc6954204da926603c9596f8ae4fe1c2f6977c75e571eaa15c426d2b9e92b1fcb44f75eb1a0b2fa89f24c25a56e7bad6a38d9a2c2b9b8d590fe59dfe53b166c44d7909195f030dd08910bdffda7b7f818ff38d2680dddbfea69b9a8b5ecf9f8be99b5c9450db94e019a3c9a5c29ca4b7b92cf7def25c227a2b1672aa5050f3641a87c9dd1dab24007e7126868c8f8fceacb5b4ffd8593122ae23e0642f31c9ebaea40da2c0498083f494797a61805dde75436d4f23d27f1eac712b648b8094560f11c6b012f35f06610ad12351693c720c1cc3b31046dd331ec733f5b6088eb55263cbe9b490510fe4ddf968157cf6350b35f81eb4c1c16375d68507b5c99022b4bc247c81622c9a19f3aa445e38c15624e282665d396f2c35a525e540210e0d0902fd4988efdbfc98c52cb900c70480e53ead8f09a253d10a5062b26b01e66936f7b5d1207d48f161c0e258fd021c6de9913cfec17e3e996fa03a6aea29c397e9e816991fd08bd3dfc7f1c0237e14678743c4ab079b637562207d32edf36fbeaf2e6f1936b9c67d61e3006c932983e5e8ca239d6b7843a7cf4f1dc4b97b365c2e4d28ed6af7fa508f8962588199390b94f01f6668392742ac623f3e39201df4c6242478ba5a1fca17c6da28b9783a6280492181e8433900dae2edf925782793758fe4070022758baff5b1e4fa2318ef48619e1b5abd0041e953f1e5d68832766e850c79c15885967b2a40ae29f0886251c1afa88815edb92edc43cd251ecd36f6b89d7435a49d0decf5a7ed46830fe8802131fad8637ba4410a1466f71ab8f77440c64ffa65a03d806622fb8c26794ada182fd0cd4d3a6bb9e247b0e8ce601755e58c390c8d2e12184634c01ec65f60edf54fb7f3f843454d5affab99113ae521feb07cb585409f962bb4ed29fda8fdad61af3077681ad065af3f4b8381c2391b95bd406770950690123f9e717acab624364de3888de3355da6a8d927158bf692a599ae186d4971d66198ec005c5e2bf81c72b3f0d5eda0122dd419a3f303c5f81292e4f2319b9ba48389c59bd37e17fe75de0eeaeb10c54852be1a1698c909fcb005dd8738c5cb21816cc505245cde41f414c007ef980bfd682c2064dc364950ce8c4ef617d85b2a128ff3b5d8740e567b239dd4e0728369052ed13a6caffceb0cd7e7409d7ec3656ddd978818cdbf8d4d3f37783b4f6526a17f3ba000781e56ab61fb05217bc3606846cb18a329f854e19ce23d902882981441ff2b4b6a1d92b61641320c9edcbe5aa05220e0dd3597841bcd63b757753a4a3df209b85cf4ad5891e463a189b297805e39d4a1c7a4735e38f500260e13ee8dda8cc782e0d4a1a93b4055e8407ca933de49383827436b7a6905018d38e3cc423b1a7b5bc5a33bc115b67307c5d7cfd72daf1f17154f29cb7a2f4e0bf1521ddb903278f93987fa015f6d062d28f5f98b60297575a94ae21a4f5dea73e5f6708e75696115522be690f3014982169d958293f44be8d38a0266f63a6408b3573cf97e7312e6f2706bc61898932bd4a2ad6bff882524a3ddf9c9dd3468d6a8de90944dee53019cb43f07251d2471df5a0f860154736436de5b2d507ce7eb4d025cfa94fb7ac7c4cb0186a8e4cd66c8252c043688477dd8e1b7d722a789b0fcf66fd497c039f05040e6c38eed1fa57d59d3c2d6b69e8d6f6048ddfaf326cbacdbf4acd848f270d42841e8b41ebc216a23798670285966db3d376ac822d475548aaa65832b389ed4b03d4a8303f1bd9827caf1c1a5c99940fb18ee6b399b31a65005fdcfaa6ad1f5c47a52f3f792d7fa82656fbac6cf815870522101f0dedd798035553f16ab4ce3602d03e7a613ac3d86ad0a7c042eab4c7e4002a34b4686fb1ffd0b366bdcc4e7f3c87f3715fc416bc6fa6bd491a8c34d4514a3026da4797d3a94cb692876b55b52e6704aec8135b2d2a8caf2b9bfc17c6c85ac768a5d99ed3b94eb817a0e31db3864ed304ec1721a5362dece2b072e382293ff7b5d45fa56b50e8ff18fb182174c00c07ebf4b6a790612f740fcec27db139b21813bb6862fb610d3cd92a566b8c72a73148b676c2a8f56e642a90d28615de94af0c65329ab2dc90af5e2f393d71a47725fd3fa07fef92d1abaa2fa0b45b77240d8fa4bd881c1bdc216b469f7709a1c4218569af0e6fa51c792eaa6be371088763c639f821c9d97043a77e92e3666c44883fce30cf5c87283d76fbba13ac59bb8482e191b670bf536d4dceb59e7765327ab80d1fa198ca7a5495960c00cec7376e5eeae15eba9e3bf5435896bfbe117b508da2ccfce9e375f3b51933f4ae87d074eca04dca7b4bd3f4f60368ac3f26206d1cca99a910ad74815850e79784ceb037aac6061ecf68cb0ed1ecbae0cd21aba9395ec3182ee311351474fb372a799b93572c133f3e1f83dfa8ae186b7e650292764bc54c1912e1856b156a00b5da5867902ef697b81661cca3906542d9fa8333006237807121570d8171f8b6f8b40d7163fd3f0e517ef326184966ff50c899d617e3c0356c444c8b902d3beb63a50039a1eb7f0d025a8edf522d21ee555bc35231d64f365625b76b301ba713667ee175c8292af421ca39474517e73875c508a28849eba192564ce45c5a0238ab8daa951222e08476c22ed20798babfff499baabbe8474f2e2824d55b4ff80aefc39db3f832123778add160225d8f1014c0186c01051d9ced945fcd18e57765f3a9d1bfe681ddc28f5f809c6b549a4abdfaaa42e1c192af5f4475fa272723285ab9dcd13772360b00779196b0b02acaf1d8352c8079cd5b4d8d3232a5bacd4603fde0c68a113fd82c8a8d97e685cf40a662f6d96bb2a01ca16b3d2e1666bf550731f2ca19eddfdf7ae9bebdaadd3825a1723acfe7462ea04c0e1a11e7db9a655d3fc2e0cb0636e8b16b88d37ab21df12ac14f6d599c5ff3e0e108e6dc3a162058582f88ec6d2af1d97e6fee029d27b7b6a906fb4f173d9da5e657955012515309365ada39f78acc3d4f0f495e1e46564c15d9056116cd7c4c08f70c86c5a4f94abd16b14f1cd1cadaae6cddfcced6e61a8099c38e62e905e61d7d5076a2f9ba2dadcce23e8a4eea407b5526d76a220a9296b568abbf98217e3498f7f071d32e2807296117326efda0f1798b14f8eff81b9ffded3818e65e946184978c11638cbcbf95b55818653e06a076484aca073e5e828bd789917157b88abf93158057592a4798bceb97e2df1263fd43d11a918f2c40e6b1bbf624a5bdbf3d557bdd55ef597e2d520f941e0a479084458d9b896c94875f129ab6c2815b72d7c63ba516c53035e8c61efa4b39cf2373b27f7bfbc1062260cfdac320b10d3d188fe4e5d2799f1276aff207ba64e2ae47dffe82695c610c80b85ac7655528e222180d9a43941f2785cc64d3cb096a621b51189aac248fbd9fc0b8bbbe16b0bbf2d9c1dd074ef4f1667d090b0c83464993d9304fc6789f0a79754d1602b3f09762a08a84ab9186375748efb942b8ed40366a03f915233bd729f09b30389377617f25d494e08159bdd264bae7ac015eba82497c2c4361baa42af757133eda82730c64aee1762a4eefe1cc2506dda66bf86540c2605c1330a58b73ca568ef3faeb846b045a5013331224cb423609ae745db92b8d68dd25984a71d7d3c900f15e09e4623713489d43d6afdb6445f067a73cc0c5ba717ee1f3c4710923dbcd39e5c9d9fc4a1d2f2c24a33919fa43fb6cad07f61c3d4f06e7973442f11f538308ff3c225dbad5cb64cd8f300eceebe421cc2878da416f73d75451dd67514b2f5b0b5f2e12d0277167178b804ca676ff466612b3388b852632cd775e477499a93c3aadf7042254a8b46380af60286c1e10df8938103c723f795e3933d13ee0fc3369476cd78ff037b3e037286bda2664ceae1a08b7f264f21b8b80c2abff733dbc5b9bdb085df7e4f65bfb148f945ae059d0901d185f3a35595c4d27e2f29a259e543b9ed8b5aa7bfbe58a08c4fcfedd1e6dd65ccc13b6069ff359de51e718118ee455c1add7b6ad2d99d16ded2d9c9f4f0a73c129e55210a6c1c4d86959f14157c3fd0f498f858e78dc336a50e16d59016601eaa85ba311618452c2ac049cd9482bf336a19a9c2b8fd1dc59b92054789d54e0dcc2be594be55e5e4944c2636da2850b135a1b4f42b34f7f523e72568efb37784839853fe94c0fbf3f9ac9da9529b6df37627e200d2441a35d92033c627e9e9c4f3d259b8c43f95b33ee335b43c2d7766c1cdd8d513b47cc6a5fbe81a68eb4fa79ed60e206bc7c457656b9448861d7ad62d32b35351d9e3e8983069546d0619303bb5a9f08f5a29660f2716a4bf67aad02bacb9b001172d11376f106d094a7f5c5a40cc18e76a2d1c48db3e54c0d30bac34b7851deb568c3c9a7a6ec4d5e92ba4b9686f994c8a6686e133d4bc0b37584ef21a4ccd987f638a774f9cde086dbb6a0be2a04c3e2a6ebef8a389735ee578c2a908fcdeff60005df374c273e2b5f7759079b4967f785f42d4ddc6283cabf477c95442b3c785b8169ceb4a8772b364b1b8ae2edd68c038bee7155b71cd3b9473f26e6d795967f501754e8c3254008ebed8f6716a29b107cc034799162517d7eb1b6d7254877c984ec1510ee549c9ec81910e6e8de5884863e7ed48bd9c5e39fad415e4cd8ef0dd243901c8294d891aab801a8338937514f48f906e617a88d662e6484a79db4a7aa67c494c397f33f611a793181e7b229193c6409d781be75cd0bafebd068fe64d826597b1bf2feb393e728397236926dc698892ce4f8287f9b6f4d27a65716e971452c4befc24fff3e4d8b980293193f3750018fb571f2de52bfc1931ef763f4598f6de6939c477a9f51aa929e20308608013e7eff69dd9d53f943d74e056a0153d2fe5077f60cdb0ed12354f62530f86989d3bfe720560e154ddee24612bb847efeebb37bf84cd4fed32d9766dbf3382e1649c8b1950fe46d6f95cb943b8351fe44078a9bc6f291190c2bf29a321c3d7f8fb234a7d527e349ea1e00c581944706e93c29f73668fc2f472f326d5f61caab1648adec5cf1073bfbfd23ab18dd55736c52917ea760106a8903514c8cb68c1211e6f079945ad85f5cd76d2b222fff127377cb1f28fa85e12ca72752b6924181594ee3d4871bba932e3002c74f39b442d52440f878f9b7907f47c17dd4ece09bcfb35c33dfb7a8dbe09540501eb6395757045f76deaf7cd9a134cda1188c9d546c47720b9a320772f6c23455e03fb21d9093b04b6e5877a69185ad099bd1141eea407a48a2671f54a3cccdfcfb8717b51762e8f84680fca7d4bab53e2dbfdefa77a68ba8145bd737a83ebf1d7be7c3be161b391d4f71a9cc1f1d4fa99923300dcdd66ca2a1942c83cb9a464c2731443a34296628a24a87460510086a153bd13c131bbab9dd424dba40738bef7c529bb555b257bc74b94a618fd5bfb018c3d838aa827307b5a0bbe3f45c4a0c895f36f52f9e4871ad6f3e0c9c8672235b5977890ec7ac8cc3888679634ea9295e8940b535338ca0f73da75d4c3fa4876aff0652af9879dda20bacd727e1de169fd216df2fac3bda9227f493bc300d2c89588fc54cd9502821cb328defd56fc3e71f0590ddf00046ab8b0819a1ea877a576702c7c97367b660320fbf81f4a6a4069714dae5bc05cdba10ab0268b5e0d1455d1763ab576ebf34058976940ebbee7a19aeca9b159c647f3e79dbc8fb868fba3164b1ac8be363b7967e7001f9cf729dfe50cc3fd6b183e980d449a4aee6f77a93bb6694603cd13dd755321f03098bf2d169e59a3aeba9f0a9ff60a40cf0949f42db8230163af3402507cabdbe1786d36553644996a4e4e66ac86e9b0abcf76c367ebbdc9c6031a3fef1e1f4a771196395d6a901d76e235d39044737baab146cdb50c3aacd4bb15daf69a5c02b7db6732e1977afd3aae44b16a2e89fc9f4ad37cd2b4cdb6a9d9ef8c26aac2617831d8fc07dd3061acd00dfa3133e15ef8724144ffb9aac38e2692e32dcf3a36a6b85e1ebc851d71bdbe2d2d6ba6228dd3cc4c65e8117df55c685cb3f72fdccebecc6b778e38ac7c0fd4ebb3808394775d36df71b7658079f7ca09e58f084b2454112f65e6765129be1c563309b53b1f8e9c6aba79cba9e6308ed589e9976c0a05fbfa47a692ca08d9f61bb28ef51bd2930ad97ba9383a52e68cbce705bc327f45b96e16a5da059d0b883647680844c62f44479a5f87656f25092f2f99182970384f3b0a7f47592e796a6e0b71009f5cb34fb0fac9c01305af57a6ad5984f6f139062b404e2d959487f3f6eb0782f87dbe218d89b9970b5dfab30689f704c49e0d2b6669612994cf2b09709e4796e0a6924b88ec9d662694316168ae5cc7b0d8cbda81570633abed2eb4938c2a14bdc239c12d95bcd55fdcf04ed37b557928390638adf551634afb3738764bedca0b3c61fb6a94da2e1d5621e6014e6b9cd3dfb995605092e079d02decccc62e4585fb7159300931e27403d395690b4a754e205f39a02d3ed310e7f2e53dee4b3e058a42b72f6ba0c95ac7a7d7837efc8066235e33b57ef6c2df0559c0493dd61a52be85bb98dff1027ec88a83ebd40bdf6da8e6355f15ee2da44f73e33c63351905f24d62a9519e9bcc4fe2870f5c7fb8099262f28faeabc8f51e2e85196dc5f7254d967ac2ab60ba7200f893c4081d1e95dd212d7c045ca553492466d11632a6d1fe1569ce91e89205127eae7efd2db12e69b5fe95a29acc071fb99a6c5d4d14c3561e38ccda4d9b7581d3e90fb560de3f63c5d87526a74ccd46b8c93ac7629c1be6b035f4ccf30dbbe0a9c4cdd3c8f0d271d9d236931857c88d2906a19e3fb048312eed88e62ebb96998efadbc88806b7716bc9bc478b0b73761e38a14e9da9325f5bb4fe8fd4c59ea3feecf8a73d6d39cc69615dab94f0a1a17c98d7e148bee01cf32a623094427a5dc6dcc16adf4b68bbc13b8b06e0818c75df48a09c0166e6371f2671940241c11c1dd89afe72f2e1c8345fb498632f15df4df483703b5f85884c011f4d437f12f7dc574630160b28feb1c1f84c72c68ab85f3b18d079765aa232a05f304edb8ed350e33f04704b610af9fb00345bccded29140d29f4c1c0cdba35d38c8e0856e55e4053985463dd34fd25900c414b4327c3b8e7c9bea41a11a4dc6b8e1a1925f6dbfb6d42cd80c65461184cbb165963d97941a30eedacbacc87d12f16f9bcd40f6cf4a28711fa864fc80e68b18e4fd8a5846e5e873ba14e55f61638a5434e756a1d4f8b8ac19dfdce1e9a7e2113b17a819142e827020986c5896fd4c93a456ccfe92b93466a4ceed160b652a6d5fdbdeb697883b2963a9049c798e312ab0989fc7d21363838d26d1b19df15d5388d9e366e26af327d19dbb5ea8769fac29063ecbbe791cc082809995b75dcd283513cc7b8f9b0d23d3aa3fa96b68997bd02876238870b26fe6fcee30f1e947f5f8263cbe5032a0cd740f3ce3ffe6a34c16da2beb960928da79d2751c3a751db85c82548e4f3ab0003b77f635a2fa4551df56538277a01faa42ab8b034a08ce6c4cc7e05c3aafb3ec3792e69d2d2d59279c68b0260904b0aae94f6c6336afbdbe80e2c3294fa97ff3cba67af49eeec7ae8533a5a1e816d5de965a88cd9120c0295e9e905ff020dc61a2202a3fc54f4c0fca319d99e2cb821bae94c2df4dfed40f226afcb2d5ffab6d273ad0a994182724651286e9f7eb17100fe6525898c87ed3ee22520db57f34fe5866f4d873b5edb0b9d964dbeaf38adfc819b817a248e48802888ae7066ecfb9cb9ec969c95566263c867a94867ad76931a40027aea1b093ba7abafba289b5b54a8e7420c31af49feb6d3b9ae61171fe5774fb11f03a7d2d209a2e46287816b54e451b64fcd6db074b0c2ed8249d5bce7bb97ca53b013c4142fbb06a60a29c200a617b03f83c19c6a930551e811a37e23ca338521a26c2d44f22c66dc50668eb20535810bff66f33e2fd9ef6e692f2406522491b00c4d115bb1c921aaadc7228669acd118ce1a5b2a1b8650f626f3e20e074952f2ac6657aaf0ef8cd2e7428a4ab2a40fdc1555e5ee4ca57c43f5ffd13e0094a79fc1d41957d181aac0080da7e9a12814a5f07a80272ec634baea95700989877a4995623a46b756d2d3ef853655f5bf16546d385b0b0c4bac997441d4ee95f93f705bf570b3ddbae1ecbaf1d9c3eb8d83bac3094453d293fd04fd2de0635cca4fac6ec5a7c01dc70e3b3c6912e94ff5c6d78c004c559a4ea79aecdde23155e7804da6f8a28bdcd06342e5e595e5941f60f81e4816f25c618e015ed8403b0a67a6bf16d74ea4441951b71524f078234f905fb5f50a14521c18a7ce0baa42bbcfc3a1005cc5b6f7c17334359784f1d7dbc783a7ed7c1e8966a8afb71666ed5a37584ad9c1fe838c05847be8629006390011e6d228a7e7aca6ef99afa835e9d8b3cb7bd6685196589ce7701490f7f7c0efc6401ba7bd9506fbb7154f54d54aec040bb741e5c829e1ef34b4610a9d8fb17fcfb20b98415542073adc860a161e2a1dfd1f90da834e2f7340c419fef228034597243d03088d068b19e8ab4df24495308f9b308bbb6f03ea66d3f57da188392fdf10aa54f767b712807c7f1647085bc6907d6f9c35b98ffdaed661effd3b8ea9efd3110c217008d48e39f75fa48090ae8fd4e4b1fbdc721cbaab739f6a93c7e57a04bcf404abf8a36287b88432ef2aab0f5c0f0d956a47063b2c01152a4eef07423dad79c924b161b6df702cd66f48ee6cc1822aae8fb7b16460c623dcbb74415e904d64c30dbe0996535def257ddb4c743b1c159be1d516372350f0270597e40af6e2ec1c167260e29aa01af94e4ba2a20d0ed4a1641a5a513b2d36e45bb7b1a7bc62158906cf3586d2188bfeacab0b734ae4ea230ea5ec41833c556ff362d07c3e8f93581271504ee13cac1ea23786c72f56f19274ee4f2774a94570b01b85f483a3bb16b2a51079e55950823409ea65c96b7f0c7b5b9b86fe1f1c960569a1ea15525ac5cd5b3b982e668050009fb7f9836f6a3fda1b9466865c9b80b875eb198c53fd921862f6fc6e6aa38049a78ef115128317e3e2c0104aabf7a92df33a71874d1085f6de541624189defd857a24c4b842f126f5df00703c727ca064404be98ae1abbd780bc7aac8fa8fcbeb8244bce0898e3174b570a085953123bb767f280dd372a9c36b588f96a6c1406ab26e7c0937927c734357e8282b9a0309041392eb155966f6a0d8cbda586b8c83804ef0014f5b631165f75436e0fb60c8297da055c799b0ebbb00322d4a4e5ad36ca71130c64b3a89fc9b4d3af22c48ff8695614df3fb2bc2c0b0a799b1d2ea734d01d4974d77f6885cb5f8e28fed493c1b649756289fcfd61589a0763e5e11dfc018a8f733d4c3ad0f584dc8a9a603b81b2ffac684a5cd0143960a227a5e99658f97f1fd59c54fff234923c70303198ea3e9967d5bdb872e4dc77cea779fa91bc8aece0f15a97f092c5839be55f2c41c477c26c94acdfb72a9b498233035f5336b3f95ba65e91027e08663e60aee632ef1d63e5486b73083eb28d804062a7fde81359ff6b3926ccd514b67fa42a165c676ff519b66108a1f5b275580594046331a39c60f03867a594dd0ce01cfbadd8814f7cdcead2a6396dc7cfe779bb88c206c55758ebe3996978ad5a45eef819bb4ad6bd85b92cc82be9e71cd1da1b12ca7ed42363013037ccc4a312caf222013296a5f9e607507f666d110eaead7d1aa55a43bb631399f5a3d3d676b3584fd6e114efcff7124352f7c40f0b6525933e2a5c00d9839f5b70d4453c9fd6614f6de1e01d892a06819ff97531ec227f09000dd0e1018b8983d4c632a2953df3807be5f08007410cf23378e5f30336f03e832299b38a3da5fc58997297dd701748fd4e82ef424783984b6ceef4a40682734073d279fb179322f913304e8e6698c0def055721c47953a317a8876bf726b869ad1f89c0df2a61d7338fe4b96348fdc7609d048ddf84dc1d9a5adb1c45a9a1061ae97af8a0b5c041e5d355f384788d579dab7c84b2dce082fa65c3771b4b8edd358b4bb9129ecef9c7d1ebb4f37e4c570f35d1b44ed8cce2fe66aa1d4c52417552f52b2b6d51854e9ac45d37376266e092d3eee43c00ba721bf31e80bffd3db2bff82c3544099b68f859cf9f193187c3574a405acdc185a161d28089da6f2eb1b659dac0604e8fbf6d321ea052e04b4b4211efb28947ef33c8249c7c99361b60101dc637507f90ecd174efcd910ce4b49b13a182bb2600fdf54e39334dd36eb3817b10b372614195fd33bfaa36640a57a920f72325f42c32fbd7e4392819424686e4867743b0ffc39b69e13e2444b9b0a13246721092ebec6f9d711e6324347d04c31cd7b972b325a5f2f27fbfd92c46dbae5af65206d6582851c3524622fa56844ff753a85e2b3c810bca53598dd1a5b43ce92661f42476d238dada98fc75dbcf618cbd8e19833e874cc4b40a1599aff8a754de420c9058799c22d028ed944ca2f89873c00b01ceb83c10702648afccd980a1110ff1126f0996e65093b47a901e992503c25d959e2b9ea0b6a7bc876609e524b62636ade036dc4e39f08419c998679d54f0a2f9005da932bd6f9cce118e295a7b0e34f713848cb4140069ae7c94bbc1e0bf49c171f00d2df1b91dcd2e34abf9134acde716d10f2e1f9856e5cb7ae54ef9ae278e1cf6e0639a57edbc74286337ca0ae3a175d2120d8d559ff4d7d95719f69b20011069199d4e6c3bb1573ff2fa3c6a6e6ecb5636bb148ea7deed9d5c2f7b53835c93248786dbab203944869c965fd2a405fbee99ca96e851f391230472f13f0140ec25dd31c9c8983624519524a833bc337c144af0e60cee1c71fccbe4a819fbd009a47087f70b793cfb9df672980bc124f934ba9956c7c2ba065a9fd0a6f2a5f9db73d52004598f9c8fb5d3716d6c9ae1423797d7759a2e379dbc49b111e7b6a58b657441a5d083bf134eb887e392f7e267081138470269aba9e270d19038545208b34c1ad1bf860e41508b9f8bf4ff9dd8a565703ccb27c02d202f5c6eb979848794420978f5c239017165a45fedfceb785bde5609adb0fbabeb926a6a2329d6ec88b143d3408e3e7b3011ce66d08dd21c22d89a2447eb184792a59684e20d17c96648749c56cb31c666b273a9c5dd77ad1e5641f656a2909fe19d488e19d98ccc0aa89792ba03a19be410396774a949dbcfe1639bad2ef2f8ee9f59904475926e3b2a0e837293ca1c07d13c839d0313b5942a2910a31a898f997ddebe349fe0b0fee2284205e487c221bf28d183953cd0e862e54b6650c19513c38e71c71c4bda75ac7302e7fb61951c4f338e17fdede3247193df061e1be388c2568da86eba224b61a2e0412c50bdccf295a91311e9c1778e259e856b482a69bc1bf50892e519a322d540dfb2da8a63839905f940d914302cc77eeebb5698a9ed4238f9de384ad8adbe801e2edaa5d856cea186ce237d4aaba40cbf6f5748276b58e17b3871a1acd58f0fc8333e152c94d4c689dcd24a6ac97378854f789ae74fb3f1993c2c8c99d5efc60a5e4465455dd0c77efa885eda78bba5211191057cc89993aae3122419711af9eb0e8bcd7c605f519f2c12b430e5fe74f455a7a090c1f353378a9f16c10e23cb7bec77d36ca722f9b29e9e34787a6f04db952076abb6d017df30fa43ac7ae03a1e66921f9750b0cea0bc5c238331fa5147d05f4d6f7967b2c950ee2fe717d745186b2e75e48d74b127eb878df399010f7d2b5825025753c7b39abc2fb816d3bbab0b93eb5e164030c927343a66278d0f7b2b33d7cf1981118350782680112f6e4fc913a5880aa90c3c8796667b1e9acba13ec5aac7a37eb100e5f6a502d99afb60cbef82ec135cee77dc1b013fa3b0b1cb97732c77da37a1809762b04a1f93e9b9a832e5b7eee4633608b8b4c1cec767b2cd7ebea405ad047ad69e451fa423a36ba6dd5b8509c4d5d506806df725355661365874cacd29e5b7ee2584381635dc52ac7fa01107a56014c42b82b9850d00c50f4f21932fb2f4be20883ebdaf4e5babd226b583bd28620053ce6bcfd653c178f8de532c1135481f30d34c97446df8631cbce9e6d4a5640512d0e420b577d670de4b5ae49a5a11b5099b835d661950acb3a7343b64e47e1322e80e5aebd7cbcf35cdd1a53a75d15960fda82d8c324dbf6772bb57b0c7a04d9ad8c93a6cf9ac45d492c6a9e1a035119fecaa17ec384923297acab3a4c6ad5b2d2ef122dd4b1cf3c78fe60c6a4d7c5894f37c29c07edf48dfc1cc49c8a1d68c20c245e8538aaaad247a405d839ee1fc6fc840ebbc9fa8e7e1444f6a4205a031ff5f2bf49f299561bb3665e9b5812e780e6aac3926c51fb5b707e45835c4deeba6d424f3888513d300da6ddc56cc62d43a4038bb00b757482175b3a2b766b411cac84a94e0cfb9ceee839197fa28b10f0e9cd50a44f6fe25db97cd3e155c972cb1ad21667a31e2c0f40c217fa7ef5f50f27fa54176aa45cd6f9db56f6c0abe47c24f71d73180db94a5b3db24aca282490424bf920068669e5e7c14a10e68f5053b81d6733ac97ab35f56dbe24f369c66ea825c268712d128fc120a00e2c5a18206f3153996c5f28f586a667ed2c0f594baa06ea06f09537db184f88b006f16883351e584682bd20069f03d7e52abcafdebbfc20fba20bcc0e032c55deeae002b834793390cd313d45d7a41f17bbd4d59bf7ebd722174e88900a5086ac772457bd136d00dbdef9b5e596b6efa4e36a96a265bd285bd185b0add43513fca753ca5b25e299f8ce9b7206df15e699033e57933c33030db4e45d6b7049bbc6e6e0ac692e4aa54e54d2ae3f9604156400a97270ba219226985b0a1679b8a603fce097a60e672e0205d075d089d1df4f498b5b1eabebd3b2f24be6c03518f455a4ce5b6db26cfdf45baeed68059ee91d5255b5c90371da749d0b4f135f2cea32ddce4d739c281bb265152825507946dcce8220a90f5ce3f26af069d9fc8fe79d8aae0f1f03c7646407dcd71d4a96a427cce443b8e6360c836b3176bcffe2ff4c387cb5d8e19a7d55926f84b1a9a93435316745f427a74d659","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
