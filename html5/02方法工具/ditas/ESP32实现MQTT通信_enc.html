<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9745bcc83de14dac63a2c573df73f71149d7de2adcda8936484dd40d830c903ea50ffaceeaf421882c80d94d11b27f9664e9a252374f8c9159a32291780ed0c166b2c5fa098fa2ec82b0ca52e7c8ff6915a169e794210c7057ddb0f03f5097e97c7c89e6fc2b98c877a1f5451eee0de7afd3f2379a2e8a781fb4b903ff386c813147f1498c8e6906827ea8a574dab39c529db2e92761e369cd6f702835b5aade75624108031c0831e31f0961188843085b01d15beca38d01f4dffcc0504d6b014f3bdc8250aeb5737f7a4477ff3e07958f66e9ae3f05b44a6ac0a5ed5f23666ee02e938eac2288de9a98cd337d3912157a2bd6be4bc75256b629073669021b2aa762bdc8d23138fb88b23c26a0296abff26ca02e7740abee6e992a7cf72a2cb468be9d4089653446d80d58ec1911cb3a3ae04c5951738ed0897a0c4376e980ec513100b98092729d51b7e4297cc9892ee7ddb46fac98da6e9cf95a00f58fd4c0e3bc1f3a788c5925a7f18992d2701780a4272add94c30ccaf63fc52ef4ad59f99fd5ca299f552e81a001754f85c30e49713a3a2f4dbe82ebf9d35c88fa2619843ed88ba1a793ce263e068a6f5b8fb352be88bd43fd23d631ffb0b7783a6cfdc5efc8f99ad9643cb19b2b4e9c728ede39dc9c6c3341d8f19b3f541ceecfda00eb762f47fed501c908e8b4aae93a739f6f55f9c60ea9a884f08dde00dec09fb06acfa584200c509f954893b39f28bdd78f40a2e4906920dc8840c5f94669a1a5bc75b29c549f22133aeaaec81016e2a29e5d3cf83bd0aa09a2c28ebe1b56338988b769efb633036a94c096ad0ea19f3fe7484eba92bfc37b3e597a7c9f7a72b6526af18ef7198a7d65e384c6c06d5e02e913274a86e1ff62bfb6ac8a029b8f1e380e50a3259f7d09dece1c28ae6501c31ac830598e04bce77139e09bca272ba8662c441184de789085395f9851f79276536732658578c467a639ea3f290333b8c492a0745b367403e211f95bd7febf1a71953754bf41738cc5ee7a28378720ccb5f90da6a03b2c0c23fcdef5899024d70f56e4938f0e08670fd79770508d83707f6220a2940caede10b55fee5590be3c431e6b3bf3668e1a387a0e576eec64a96ae761409ce5c685645d41dbf4a98d604bc19f04d8ef3d3aff5a80a883b7a0d4c51c734427739aa1d96e96f09ecf436cdc94008125b6131f9223595123c40968c7e0e1c9b2b524f49bb00db15fa868c1ae8d0f3e60572ae123e79ccfa230175ffee3297468061022b234dea0335de5496663b425ded98eaf16e20cfad7729a7626bd4c79348f36c805dd70d7cd79d2fd3bd2d7d2dd47beaf3a51ca91794abd40b7fe34d4c83ae0330f4d1f1231f8de905f4c4915006c61379b029a8db25026f928fe014dffeb1a5048490f42f9590780f0127bdbe996a687c13a522d49f16f51cd97529b8252f1e0109bb156ca0c5b3bdfa91232ba5f1c3fa477b33f95597509f1e7d341524122563e2c2cd3e0a606e78422149660a7e266b15839e3ad09120c670fe80dfb7e5b87165dd0efb07dcd18d1957ee2f23784eb169fcf91e21d03cfca88f2b32f62d8a48c17da40f1d2069a2a68dea236a596e68e6edd635b0c4c5721668a41680dfa742b6a1af88fc47695605f6da0f7f84d7686d8d062f6dcd5094f788891d5f0c4468d05a56c9338010f76bf0a89c51611f34a571711c441b92e724635f0173f4fca2733ed7f8761ae8ee5d455e66e5709f7667a82c55f932c3fa8130fa24d2a75eb1c14ddea37d05cba8cf4c15f53b1db18fcee210ebbaa987dd13d8d52fce17abb59d1c6f91adfbb796ee0f19882bdf39b22f555aefe790bcd8a22cffb1ba67f251989bad92a9acfd9da6c3ba7c8c7a2099d5a30cab4ea749ccd7ed9c048abc6370c947ed7970bf8bb7028f657d07780591690d7a4e2682c80d22182a9c0d1b4600f156e0d757741962a7b0eebf1c6d288ae156946127f4b4709ca2b9429b7d66ecc58986e645793fa9f42bae86feeea003fea2637a309f0a60fc95be0c6135166046fedb7fd19408b7d5a2c424c93e0490bd689b42443ed4aa634cd71c3200d5b974a65176bb5610a7c4b1ca70d3c0821a2c5af576c5f4ca422b5de768bef2a4f3a18d844cf22a25a44c95f2e91651fdf6e5919201c5bbf751c12ab928b7e1b4a5e7961f4a038c0788700f9012f9d142d4b2632bdafa6981e587aee576a9ed10b68b3617e4cd249d7fa3e409fd16283e6862a6990aa53235bd57ac8287cd7629d655ff375879cea06624816faa96e2047743d45181260ee7f97c154a5d4fbdae17b92e00fe109db461d53ac547ff30d5c47cc47ab50dcfcadd8b07762c0a053be9884cd6a02e4b993bff20e3311532ae37bc85026709509a875236e5ee498aaea52c9f0efc27cb0259b921e375001fedade3ded5fef049bbb49f85e09b7f131d795f933136f6f764646ee433b5cd1e5672c148d93399a944bbc8bbc3490faf91fb0e955d4f1eb91044c0ce26a846d97b54b68885150e9e68791ee7fbac66b670f5037f6daa44f7265da6ef77cbca1c5ac258c512ca93c4e5282bf6d2eb5cf65da2c0656136005cb3c27e453ca1bf4f99f9f94ccae17be434e3749d22aed9ce7d4c66087901ed63ebe6b6c77ac959403a2dc592bf519d9b70031a845547f48a7d026b94769744132f699b2148c670239f586253415c3cdf0eb10cc33e900dfd605e166847671958fbf31daaf03cafdaf2b66e25a6789c3c99bb144abbf4d15ea30ca2106c473ba435c317187745837a5c3175029572bf4a162927b93518d5493bf76e728996ba6f2fdc87acc0d2cece9682dee3e1edad54d566e90323a6abd326d0f8e03c511fb1b17aeac207599e1d8036a23b954bb2353f671db18f4c03ab8144ce6b65522a3b3b98c672e035c3916cabf68abe17905f3eab412bf8c04346b2359702fb6a49e967ebcf36f7f38aa4bdf9254ca88e9b278ded97512c43494ae6e2028470e207f3244757b0608cfde46a58ae5e44744a90acfca5b95e54a9dc30ca823e1d1166d117bcc5c7f7701e6d525a365dd553341d1a2535bc196d8d57017744b333dbe17081e557b34c787c0c9b934616e75215d32f67b592ef05dd89e609789f4b85fe3a74959a40af54c46527e9ee282e5896ee72961972487673c7bb99dc71db93c475eaa9f786f2b43638c329f671b1ec6de8b6ac2551bca5782838e39b5aef7b7550af017cd6e9f28bda8c8400792eefa31e344f55f6a9f4063e5c23952c148820fbe9129f09ef1d7e54466f2ea681056bbd8ad0160525ad57169278797360c6c9b70fddc6d603ebbddf6ad11420e2b045f515a0b19d951842287afb60ea0e48db6ea7cacb07e1d4407afd86876cb30376ba4dcde0bb12103a5416cf1ddf1e73c595cf795cc802202fb5801c52dab523e8866497c8c9fad29fa1010fe9f8b3043a83c5126f15ba956a5189386f9d661c19e2c2458dc28c4c4ff14923a6f22afd8ad3d98e4b16df7c146ae18c27050f4ee3ecbc39e07ac18549a39a25d989609a6cb54c35826aceb3be786a0d01f7688b93434ea04f6f4f16963cdbd51f74e4b86104acfcd3309e37318de8bc08d919a2814d1983a8dc4cb9a6b9c4379529bc0849f50290cac5447adb8af6fada25535947e85e1facc25db206332b8106aa935c7ced906790ff4c3787f186e7ed90fdfb8ee58d879a00e865ca2ff0c3f9066e6b0c36919e3dca96b7e3b0058df732fef51af91808c5295d858a6cb838c461dbf6872b68a95e73159a710f425683cc66f9340fa484d4fc2735d96344e9ee170d3ffa3a8fd1bc0050ecbb2222fe02f65e5d3d0bf77876f179a96e3776ef0d4017671c7de58e486ab2d13e369bfec75b40e8c35e7d02c17e1ad19451f2f0cb52474b2d04845617415c41aa3d2b7be39a0885330c3053ea198e6a7b07e20d611fb012b5508581918f4462860cd3ead076315781e1c54db4bfeb210e836b5059832f033728b7a4c57e538c36ef1769ce75e89edda5c63c4ef424d24117a21a3ffc0cde240cb76960dcb7493780a324d783a848235d8fdd93dc6b4a5016e84e1064fbfd51a41b5fc8145ae12d4fdd4583a8b09bbc2a8db0ed6a02bb5c5ab94518e33773007a826b3b6877c39c5006e3f1f6cbcec0ce19ad957b47a7c5d73bff3ebc1787bff106c4585401ee1656c8d8c0a4915f327797ca45da18eb33ee11e9b8909459b472f400e8e7c5968d784fdba4ed97fb077b81ec0472391a51dad2b79077a81bc2604cb1d09001208a3a3ad04e08e567dd33000faf1d981c5f13fe63fe5de05c50cb2b686f507a21d7de7e17c5a77bcb2f5420fecf96b52eb1479562eb6af6e7981f6405f5f671c11c1e7a5ff967f5d0221441748d30023e6acbc95f0555fc1aff13ba8648db381224f8cfc4a02056a9d438c107bb5d2a1c8477c055fa4aeb779327f43031fffb311b8cf914cceb846378fdcd71ef7649b6587db7c5ac7db7453be59920df6f19879bedee58e5202d3f165552db8b7a145dc763116000ed52348c371218210fd0295b6252bc62ddc31b5a6075d15b0bd6a157b0ad776b9f80d6bf3707592c405d71cc37a5a3480c6c4c058e3da9eff6de2aa3264291a7ebe65656c6f43cfbe629a54094156b16ed61dbdfae8fd8a951f961e778a0f82a0d5b596b433f2e92843bee07f698b2c84c5034555dee02aef207ea2e9f6170cb95c3b470ef369b5676f614e87455e4569661d6855f4daf3d1890844d873b06082a0997d6e0707a34564615796aed7c0a6ebdce8b8b9b41d56ca8eb6fd16bfc84b1e626906b8a5f0fcf76e49b97a0b57a01ab39592b99be79841c3a8f98c4919713e7722bf1995e4616c3093992864483190e550bafb1c20cfcb43812a05a4de9f82abacaec6e128d9460e3f9c722a5e96fac70254e9d99616a40a8755dfea0046462c80168f15bddf8bfe9b29136bc857ac1fe07832c99e69ee04a4c72db11e9403eb1698c32713f7b9205d4afdd056ec7c39d4f7f30ca0729654cafcf6ac1f1eb38d33a564030ce9fb4da8beeb26f07c31424aaa0a8dde5fb2abf450e3158ad7c8ac25e3a7d65609d1e835a9ffce01acdd5fbb2b33a42c7742a0fb75154a47fb96f426331b3fb3ce0167a1fd7984bd8f02975254d462ccd7e2142cd6129c9f2eef727c4baa297f06dfcb7712acf0750a8d3236ed504102870a71661cffdef1613eec5919fc98863ce8f7706cc770275788c1dd645499ee4240be8f82132101abc4459b3d8a8ba30fedde791cd6b8945e6d49919fbe309d822fae4a3d42c1fa51e5b1800bdc6a734c762626f75045e77af2c68563cc4d253331d21f008f01818dd4bde08f22637a70d94bff093a6370905ddc7d8859703424fda97ef9cf918be5c0090cc8c16d6402cd3f859afe633a98f40ad82cc3e752864ab1d9476784d2f6d4bfa98f07b55ff94566541f5b37cafab0541372ac0d048894334053ae1fbe87394b58a7b3ca47f47bdeaef2b60bd0a3058cb00a51a26ae4ac8cc1ee0afb35b4731e7c1faabfebdd18d4b9847e369ce29e8fa808f12bc03bd690e63a0a4c6ad2660ffe0830f1050b64a5cb5989785108f03e8e751070e0b7c441a8ba0a8eef11c1b2031fed13afb41d98cd2a8529fe387a4a75504100e567ad35ba2e312091b2e965944151c5a97ec9c8349211593f174450a814e81b5d5fc90f164b09f56e83bfdbee209a071aacb48a9a40e94001c9b1d60502e3787abdd47254467457c19a233d9f22be40ab1a12b8eb9bdb19e52c135ea2fe6dcbdd1559a669ded22cd6053e49880f0a0db9550b6bbdafd25cc46274547fa39c7d428670ec4a2a8f89e3322e3af356ecd4b872673eb9fc35221549029dbf436cde00acba4f89af52aa30759bf21344feac162d835ac62b3f8e5c81c14116ef80d81e3ffda6f1765962ac1c01fe20e061b0ef0c75d192f7aab05db635e45ee809f54174f5f1fc3cb58cbae106e2ec5b8acbc46e9520b3be8239c828e56ffe596ce44d95dd0834d29c16a92e8ad59838d6566d371463bd1ddddd562fcc6357e78858c84c1fda97a5296bfc3953b08fd28d0e016976b99f7094933b1c63db8a17277541a04007c822c8df7804327921a95c6ee7e9656ab1f778c6d887794314b03a5b490a8c49c5a6cb747f38d191e29da6072e309ea77f2710e5ee7b7195201d1aa9666dd5535bd6cfee060ec35cf22aef73d3365f3481db5331b5dcafcb98a5e627665fcaa4d982cb18b3a17ed30ca9546f5fb678546ce74bf8deaf4b6022bfd49c2e4d26d731c02e1ad36fef2f649c91d6490053e92f65b57966680eb99f2e110fe4f4537713f241f8efcd3bac212d5323a9422adb7b3264eb24b2fefcbe4caeb0c961b440a810d39f0c7a38ff0d37071c1cc45d9c123e944dfc24586d7fa794afd31d2edfcfe20c17fae24934a6f2142436ab83b04d8067485977f52290e7a7eafb3721658089d1cf4bd7873723ade732af448e9ec986c7fc8e5c98deeb8807a40135e111c39beb941b7ad3b15ff09eb38fd9e31daa4ca65ed4cc7772c5c4145ade8128bebf9200045860608b341837bf970391dc2f5223e54407914aa2ef261e9474b87646a7a783f7c3b73b47bd538644b15a5f0558a05d334836bc5b14f17f410600d4da02168a77f25eb828e473eef5e71e8f424634ed6276d80420ff6d2f3fc8d8004020b0d0ef7c432b8319848749c7a800ce1e207fbaa708ee41f00c5542524046335fe74f942bcb0c701e4fd9bf675f0d07c733baf91566099c76e6cea2fecbd132321e712e379eef8fe13477e17cc81d6dd0c6c7ac9a096f50d37d62d10511a41654cac11b780fb86cb27d0fc0a1d07cfddc400676f6dba1c07571b9450d5f21e4f98fa90b5cfeb9d87ad5f4cbb87df4376afc54aafdf0e7d97e48d5fdeb2aa667f0a27ff4bb8a7c85b578e27b68e56f02cf1d187e18910ad378f60db566f0d2ddf8f602a056bcdbc1ab89a2edb80b1f6bc44b213f4d48bd53a33b7c041a63c4cb1c9bd9794c2ca11e0e14109c3b4c96ac5ebdadba8c7c4e1d9bbc46348915c92012529f0862d592f0556edb6d819de5c23010a42a4229b2f5536ff72f7cb378d3ec2716d7832ea6b5b0b10dc379ab85c4a4c7a536badfb6c306ab84d7e0db627f158c4297caf1731059a960611a36e8b030e2b2713f95a775448c32d4291403280a3a3c249cb2a15719b2213c76889abc41109cbe27abf1fb43719dcd639920b9bef043174c39df4a8483faae2a63342c3edf0295f04fbd3723162cb546268da7faf7c2a153fa985d0dcee296100faf254316f224f6e1fcd1b314abafe531eecbff54ce3cf29e5310fb9c6a570854d06594ad96e8c0b0a9d7cae4572134073ca45887c32a5a07110f92bc620e63929de6be79a929a9db2f86af0198682cdf88ac3bda0422ae3410f3e3992e444baefa72c501adea5b711e14e3785e0495bfa792ac46959c5fa04f4576b16849ce477f1ac0930d7b552ee73f695f7f96b2428c457f8538021db054fe24cb3fdfd5e698ec4d57d4ea8e1b7fa17cfb0d6f09c960818bb67ed53a433ec4074d31744530708fb67b1879501b7926204c916586f6c937d5d0f61b2c215bd36535da0174605d1e14f2af51b90808e77486c841493ee52ec43c040ffed6196510ca9f800e8ddac02e264286da788d0c0e33361e214fe12015dd4ddeb1c388ee3b8ad524b043b9c9cc0e13bf9a33b7b3af2435714bd9a6acf0beaf51dd2dd41591ce116a5e37f3def5e4c65a5ab1b370905426bf8209a5e2226bfe5224c2bbe925683c15878200a660994de5ace6ce244b3cc47366fe1f404c33fa215743fb6e6a728c698e2f3162a2d10d8c5ee3b009f0f679e31dbb03953f22b5a7fa541347539b681df3e6731f5aac614411639d62ec0bf86c9c75b8a65a29ed48831c10054d66ac83644563200efc9c9ac2a5276ad7983177156821571a8848d06ada2d4308564ed2f7827a0f4c2006ae588b7c1446c793b427fd59c62e248e6ed5829fa1829f44e6d0de8054f0debfc54a63570c49c6cc30691955b3e041e554acd1cadcb55e5406b3961bb2ce9e600c89c6253064932794f6271cc51e21152a7e148ffcdfbee9d92b85daf91fec578f1f81ac60fd424143048e6bff79f59c89bc9f3db2f57a1345451640ed9cd153327b066a92971175f3ca0bd0419b97201e9afad10f5762cda0b44d298a3a655fecfd73d02d8e8be53534edbb41973596b824ace8eefdf11911cc7549f4b97bf7a1d0a960fdc380f6c843fca8f83f92fe2380e5782ecb1e7afa58428970f57aa8d5830f772c794023c9e0d05f4119b2d673fce0e183e96d70588c1d8efb354dcb119fcf01c6d2b77495afbc05c6a3e801033d310a77b06bca1c6af827a2342505b6cb8832646f043aad7c45a48ea136386088014550a486ffcdec39e53ce3a0233fad83c810b3cb7d781537362c98fa26a28b8b1d9f4b211cac435f5298e51caf262b3e0e78cd755057de4faf4aea572cb53aa28cec6412f34646407e56dd1300472efa4ff255ae60aede2264997b74cb7176549f48226b67fcafdf6f4305c911201735a7fcfbdca7a1bbe2559a02dcf5dbd24f03a285c5d77602382eaebca81477ddb8e57306fd1a51f0b6de41088131f414117eb88bb2d5a38d8d28f31239b893cfbcdcd1b641257c7e6801e5c4359f479d630cac0fbe3fd8de863a1e7012cfedc077801a1dc8bc09d0f72ad94f1ffb915336d3d671bd269d9bbf20407a543f7b3638d2068baa273a16f6fe91d45d69214cd97c0327b7a2ce4810dd59ce4fac860b6712c122f812405f824858622c7f7a44a0ccc3a93db8281297225feef21a3256c5cb17f4f5d6749e2429eaade22685d9bd4ee902b19b0684fd765e574311fbd985a0ce0556403897a84db1ab714fd6e40b733fe7fd2765de75203805da60f18ba46cc8c7dd515369abde86bf503ac4eedb3bea9c2121f316a267afbd7795fe210797b931fdcee73f88b6a748578d6a3da556721e6bad9b9a3c46981bb34052b4dfbeaf21d36075549e26f563e012449a0f697365b0de6b7ef889f297dece3b3e7ab3a387f3edfdaa1a66816ca6f7ac11fbdc2007910e745e62da9b9bab68c7664e90aed3f44b837a3c5d175e15a398eaa0d13430339f5b15309ae27df2b2ef1461db5786f6b7f4dee0428cd4a7c9a9d3018363c7e2a6776445704459064d82386162938d25bc530a7ed2557f8b597652631051b721b0fd1baa86e531af3ae03b62b88b73cdb2c5b3ae0631a1c631007487b20322e1ff74ce78cc70836a77c533a28819e5c94f6f342580bf82860d15f4ac731c55f3ce7a5e9f00ad682bfb10d3e1a55351cd3cbe364b46914a3bdb086f9ff1bae8249fffb3fd992d5d4a6a5caefc461c4c4ba0bc6f5ff94fef3a848ffb4f7b5d8496680aac31a2db6ec30e978a6fccf6915e997deba041515f1e3cbbfea42c15adb814c06ab9ba189eca75a64d21b4dfe1af093ef69ed894b2d866034a2e2e5b62812d2d6fbd8b523601815fcbbf98a8184e09b876fbcb72a556361203546ea4b40f239f26ac46932e63cb997385e5e9b8b6b08140a734b65a94093b9bdc5b71654b6c4f7ecace49befce5d493fa6667325cac1d90d394ee2d7f810a02a731b547a566b31ed7cd4ebf64efdcd57f9458e22eba7f1b4355376bab824ba086e7b52662382bdb195e23ebbff3395e81cdccc94832c2af8a3c6d2341d3773966ffbbc2d9d5c205795f30b9abecc5ca6db1d585ec03d33b14ae99d475881bc30335786df1b2b848c69e8a8a85eaa10babb3407d9e36e1905d76e8ffb9c650f6f5ebe7494f81add3803a9fa7584f5c41bd8b69ae59c176f52b8b1e962971d7ba096d9bf62b90798cbc55ebc2b7419f913e3b518882cc026069f970aa7f345dd92e2b16c63c8913b4923ba43c1c0868740cf0cbbc210a6fcdcc8dd9617ef7bf66eb3ab178b63a12b71eb3cb55f6ab20b811b7c2b6cbf3f3bf7060183232b803187af20013f197c2906fe23a4225ea2b98c333372fa136ba6732d2d6c3759b436f9ece43b95ff7827e3c73f0e8e9beb0ba0cbcd09a768be32740fc5f6bf26988701660f42cba60ea7f0e26a1f57a1a4dd527af3aad42e80fa1b1798cbc357d7a17b39a62cf827b02d478247a7e473310192f56f271fa0ef50d634c9e511b79d548f38e592aa354cbbccb0398edd0cf607df7ae3d4fb2a9c555b7e456f45a85198fdf0f8b07e8fcfe37fda9a18c305fb6d310aedd30d35e8d3984363d1be389680fe88af79955fd848a305fb384060095bdcc2f17801757e85f0034576f1d6c63a2ab3e478fde686636cd2d067321344d2f086c529e38e368bdec40558a4967358fae968360503f2d29e38eda227c1922385f9fbde50eb1d7e1d9d144734dbd407fd82b349e58a552ffa9cea7cabbe361d3bc8b20e3c07ce1cf7342362299335d19924a9026151f368346090081914468079ef947b3fd6b7f6d90ce7bd13b088d6ee972c3771156f72ed8d4f61179c9b3e8e894f02e5077864adafa878540eaf388f8ec07511a46b1627fdacaa8ea563ee596cc9d3ad7b62f8992f414393e4fa41a2d2281202cee3113e97a0fdb6eca93316d3080c25591ca9bfe7caaeb328d7cbfbee20e988335008341bbd2477f9a2d01a980ad8b71d9566ee0210ea7eb456e29b228e3950b057255ab72f2dfe89aff8fbab3e42fcfb1a403fdf13d039ce08d31a48ac07b8ce72170554bf871335cb4cccd4cc7f1149100d490639a0ddee6ca9b4c5877172e2a13659606c245560ca1ae6877f3d020cd512dfeb75532dec1825fd9cebdb0710ddb51f4a39416968b628f8568fa8d3ebb40add44c01262b7c3e915e41b6c3754fc09d75aceccc8734ce093177a3abee20b02cbccf33c46fe8279a21d03ecc1e2c5a5368bee6aa1692f6f539be89fb56f84e27651dd34e792aaeb9a75fb75a4fcfef13d9f236ce7443314be137633ee5376b637dd3033e7d57267591ef423eedaacd63b51d9a7cccdd54269d2c97a1738451aa3aac24a3a8b7ff26c1a97d1fc4a35840e0870dad9b4bde3c4b4dd7a3af65dca5b4ccce247c64a58466a837a09c25e765fdda97c3715a7cdf58472f3d4b1c59248b6c3536d492a782bd0f276e6153f3d326a837e98770157d65dc9d593dfac808964d69bbafea46cd17381efa6faad67dbfdb7d2b2e767852cc2aa3927750d8cdb13db005efb33f55fa2cc582f66345d9d34d442780e89a35c8a26e7e107e61a343f1ae094de5ad211ee44d0c4c88030afa2853d6eca74e81ad850538a99de67bc541ed62155644550205afb10374cbe09b32b2dc79ad7a7d39abe0a4e3861a2a1c383780cff466af9ee2f99d37e348d04d094d601165d6ef760cf0e4c1bfda0f849885b7f566ff91254fce8b0cbc5d9eb19f96ade21cfaeee8d035bbee19634891c6ceeda7824f51cc1d5334d73773698f62d821386ff6c229161f9f2dd1c7ae228720de1fb5fe98029ddadd98e334709fb2d4426ef7df1a65687a1b4e20eb27595cc9a8366e7b15f5a73ae40f812264d1bc653097fe76745e8952cf441407b77daabb1ed1e051ed9ad6377f5956230f4957fc3667254cdce8a7e3ed5e346152168c7b06c988d121f95ff6d5ddac4960bda4157236adc356313f014e5f6073b90a0c8cfcd949a94d7a81d68d9c8203f9c230809caac2de971fbb41bd0d7241e5e7012b38133c1630f2ac48bba0f4366611ee192613428694b89e520d67bdb3bd2b34aec2093943915c1bd549dc49b2c5a72838dbeeaaa698eb5b71f37f9da9275dc7598326a9d09f9b12631f6b8347ce3b8eee5048ab4bc56f48169f90e6c77fe6b5f5742866940f31ec1e91bf645b718f9333ee8408629f9a015e0057756c6e4593cb28026e21df1b46182279183514b57d74d11da2a37014db91cbff5e29c6203e3257edb47028f4127f30249e7d87e57e81f9da27312fdcda052886d2690cd99e186f56b6842cbe586900fb1c2c34da8aad5163fa73d7f8f61596c19a8a21af1b1845350e2193b27dbc37068fb49e1af74278bca10421bb9e650459a4304ab722c3f510eb1c66522500008642804b0c595817555f62c40e847a33d0ef8c3fa6d3d0bf7154a5a9819a9ad8d6372602374bae64f0a09576bb39ef8a21f96877f615184fe3a9da98cd4104a70fd1f56265881ee5ae8f646f8d4683c2cc34250141a2c619f84fd7bcf7c69bbd91fbe516aea89c58e505c1200215a65db01b49924ef2e342ed439b62a511eaed933dc7384c79247f8b46d44b57c5ea4bf1a16313afd0fa20f85d92388de22eaf70f39540ea3feed0ef278c638465dceba103c688b63cf9171514e1b78e0ea8a7c8fcf26b6f60fbe34ca882df7242f477b5f3a502bb0518a4e5baf4e4418d60c53ac384","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
