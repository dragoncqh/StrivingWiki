<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3e33ab4b46d1a502a387e87010995719fc8d5eec94a1383cb6d62a9ef4b9856a61fe452108f41b2eda8f75e29a5fccd4f0d1dce8558e1fde637c6eb3456d30ff35316b8b0b633ae0ab730a1d6cc4cbf5e6ea024fc0fd0a7d73a17a8473fffdcd663dba0300dccc4f574b66b9688c2bfb801291ee04f0eaec8f94fe30fd64be7773465e9d27655a6abd028d60579bd73ec0bf1fc2f0e1a54491c933b9fa149f3c8e17283f96ce3de5cda5c82a4ac57b56e8b5d0031986fe99715943ca68307f6d1535888468a22017e57d852a23c1e55eb4d68b8886bc82f4c4a6a3645e21c0b01bc7d83eb1478efd76a3414fc74c2515e6769b596f5fef0cc41c7d3f6337c0fddea1adee3b1cbbe1a6666155dbfce01a3a133122c5efe8d7c35797ee1f2cc3c81a6dcd9f075ad9591c1be10b336d5ec25d5b6b15ffe7f2997e07abaebdf404319ce809bed9ef786b66d0d7244d420a32255bb1c31f5fd69feadf7150df002263ab69f88391076b130d0b5a70b61d7b2b062078d0cb065688137266d7df4ea74ca643af218ad5abc2a588597472f96193806d76ffaa10ffdd7302aaa9551b82b686fe760a2d60733b621f47a1950323b955db71567ddd5d15a680769cb040e80363d889dee96407a008fd20ea6b96eb14722ea83da5206d4cd8638b9db7c1b09a441cb2ffed0e7eaba83f48b384904454dc855e3ffdcd57d00a1f92a58929e751e5d0fc9249c5fa01e930f77ac78b82814cb616e673ea630d6cd3c9d3e76cf9dca651ae6a77103699611a00554e7d8d55835b3a977e4ae176d9f47cf4c4794f99b0238aad4e9735225e05eacebe36e1058ecd27fd1fe6a1f77e582a2e8f03850cc74609a8e55765edeac13fa1d74bf6e6abdf0a6e40a3cdb10cc8d7be9180624ebd665e40c1c8a442f39c055f2768dd1bf8f449d45d37ddaf2f9fb466c9bafc8dd1ce7f7647c57274c70e89ad3e4b750530bee5dc8d673a4beb7657dd31ef8b5b95aa8f9a788e86747280865923544b3804d74158d25e6cbfe448e90bc1a70a1d35301cf4335abb5c3bef4f0ccd3a716aff7a145c90c89b570631c1f7e5c108545a22424a9760bdcb0c9049ac5b459b613074b12f511ade7005154f8d4a0666cca55eafbebe7518650af412f639ab54894f0b45e0dda0cad4e9595d2cefe70af342b30f8d7a7f78679c070c44c3487252a3e87685f57dd394944f0b5748fbf371f5e65ac12f5d3ff6e2c5f3ac897be49ca0694b04d46b07a879c9182b7d2eefe45db361bc3b3100203c9cc25a90bec2ea19b6fc137250fd15a0cf1e2f9981a1765ef39822845201393028a4edcac0846c60810f091f86968491b37408b4b59fee198d168b52759151ee1a78a1c5b9930add3d8e87dde79c15a8b969b9837628eac35533c207e6090a4b405d39fb4896ddd60a8c4c2d11dc84922bd2abe5ac7ec5627362c539c23870b636e40138545c9a9e0d106b7ba087c020048a6204bc6b249bf39a342212de01ab22640d8751cf3da6c8524298fc9eaa0779b1df60b1ac6c8128f8a4fa82fb87274abc1d477dec48fdb8c545dfa0a75a83f67c16f3f7f698f12953556056e64df08dcfc3e5e5f0d2a07fac415b7e2118252ef4ead29a6b17d9a39791baed98acf6bfe2c759afa9f85631279717552c6e3cb9660766fbe055e667b3522696c3310ab834489b3812f608dd1238cc711f96fc63a84e6ef5152ee1e5f693292ff0f7d88093ba01b530a62743448f9c84eb05e41a56dc3875dce75d717a25e22fbd091390ba08e4fe51125b84479c09bc897e70f56eaf192abede301d92176eb97b8cda6eab9ff1ce42e75f28e484a5d7ca7e04133e47052df0cc2718902e61aaca69cd425666fd25c2c5c525b0a04396c0ffc27ea12a90191f5465bf420a28651a68ea5798a33e45d3e989ee016d821cdec142ea6bab78648e556e7a4a09462fb8a05a918317f5894c97302b231639d456e37afbc01c7cea15bfbf1ae0b65ad6750e872f45e398a083f4334201ebb808d811d476de027fc0213f8232807d9c99f75695b864838fca1732d855f9917264fea76f4e2303386fbe23e8361c82405b846335f0ad9a9d69e2b48c5f6fab6137a207f41452ff9eee2f5a0ce6451f5205d51c41d830a4f336c5555132ecfdd3daa8d16bc4fa507c2d44549606356d9fff832a462e9658ed00780d32ecf5f21243e85d8e84a05aeed706f224437614eba794ebc9c51dd8b2d3a2000781a03d443cae7215c50d929279a6ca38acd524fb9f8f7dd4df0c26900de39f6043dadaaddd1cf7a3049a9712c9ba9209594336c5f8672e784f869fd190149bc9d6bc058c28be02d807387c1b123b92f2a91e2f5670aa81174cdaa37263f0d3772d92704276b96407ce9cb248c78f9cf25d5e7674faef54c644cf85e959800e1592f866d5d83dd343b1106ce51cb2a88212d8d729b168d080e840376d2861f6a41005a7b2516abb47603052628478befd5f5576f276fc62fb459cfe3a44badd439825825ab32108489b2034bc36929ac73fedb9d1428c3dee08f0f92fe49fabffabb33946c26ecf3dc636456685dc41177623fdb5eea422743d42f947a6858c40004cd7c014bf83f2dba0d82d4a03f94048fa8243c92501cc22a3bb5c4bf7c1d142c2f5100095b78711f318b80c65363085a8a639581725cd13d70d6c701cd7db8dd6a07ce2a0c6cd17d05a91b751ced05a02682e5daa8293dfaf27f2c10cbb6bc8ce5f63a2b097aeb2f2a595d611c94cfb088442bac13b0765882e9307bbc26a7988aeff69588d1e20d11aa1aedc77da1686aecc346797aff8728f5a62fa377eb7471581e3709500205a47f45aeac453c29141793fd5ea2975b246314a901da904f9604e8f853866fba21a6fec5333ac9c4245bf140d0de9784c63929ff2ff395030e1ca6e9d671107a2712b962dc0b12532fd57a19e32b8aa72b750bfb087d41805ac9810e323d505f5d9ddd5aa361f4e733ef37982252e88ed811ffac1bd03ee52d853874feae4bdce75a415ddba457c8532a30d2b47816d78eaa3d6ac962d507670e8e1722a7ea757c70abe0c4f6cd8523dde4a2ab66f7c45db64c427ae3b61f8e584be89a642531bd80342552f6354eb5e3a2cb14aaa07d6a6ebc206f345d0154f628fbb7b7bc86c5fba7d19168e555756ebc6d3a284cdef179b90cd77356a20f04391e88d168bae9a482d222e6f15e4102f646c22589b0b1bc195bda2ecdfa03be76693aea29ebd718ddb91416c1ec4248c9954f41072f0d58f810a514b9669ab01e11761e43468b3b71bb1da3a262c16dc4fd05cc9af85e94cb325ada1da2708c91b3f000e3484b8b11958f921aaec6180aeb18abf003aab969e442be407b2224269f7e7e9900461e7dff6cf7bbf9b85bf2a6370b907921e7420a2d91794c5142a304ab6a4dfe472604a6da1adde738ec8ad124f47df78e987908c35253266d6447dd7d5d50c3ef435c2d74cb47456101c7b2e6d1f782e6baec7a7051a29b1cc904b12f99b94ef3c8a57ae759f90d0c3c7965e44c72d57b20fbdc03880844d7e3aa3225f13b51411a191f9fd36cba0d1868132222f5c37b9ad076460f0e558f5530789513e142a0cc308dc0805883e9a5f1da5cbf88885b6fddf2779ba0b3f4da1d43785ed7781cbf738d295724ee43ec7db6febfa08592ae41be76fdff5cdcbb0ca5c9b700915bc0dbce1e1092c012ca77c3a0260ba0c532839b8437f916f6af0dacc7ebcb0b1a422f1ac59f7055ac736b7077fa33eca88ae4ec9b9a6387350c1a6af7c0d8d17f2b5ba2b74b2dacd073afb3ecf2f1151ab29a70ba2fcb349c1baa6a699126955aae1fd7f0a71c14f91a91c21626716c433982a3c8721f859531bf125f710b9a384b3d24ce9db29cb4462301db50a477ef26b56642504f1ac94b6a0b399c5d23ff212aa73d2c6b861f1b4f2dc4f2055432a13ad9c4503a35fd9099a63f229f22255488c0dbcfe8aefd91b0632a399e8abb31e875ecda0e9aa7718356313c1aed798916631308373b2d79b0b9d97ecd8e96ab4994ebea28d7f481a3b3c9c247021689be45758ee3ff82939149c2707c667361bb0c370c2a52436993fdbfe8eb961a09187b4a524110b6bdf5b867eefbd1b0454422347462ced72000f637d33a5a28d1672d4601227a49aca7bc31c1d04be376f29370d83836ef28715503523b1c2b43a5c0ed76a5aed1e6855b648f57c1418e650cb7f3f407e3fe27e5d78d6abb5c14cb8e4a4e1ceb2c312883a4b395c101c5e0bbe9d9b67f76882748b0da818b81524433ce2b826da10bdefa6620b0000a37288166e567b83df68603d70a50429708d6006bc71bb0c4bf6073bd4800f8624009737c8b1a863214bfaec9b5e23ea41f24a4f5552440e950ad4315a391c928ea77fd47c04be064ce0172916b177c954ed5b379d59f72f3869207aa87a9cf5c7e78e36c8f0b1265f98a0b52bad6bf6ea161690ff7144f2d559ceff0728b96aeb3288f1bfbc56f70cacd322713641aea787b4e9918d64655bcf15186031c6fa7e86da0bb73705d401a1a0a4f23daa9f9126bd865d144860fef4faff9c92b60f4ba7731ef71c99b00171ee130d14e72a687ef42b986a7ef1f33872c5c3b4fb5ec20060f950c0e0918c0037e361f97fa3cdd5cf549cc9f694928d06271b28d7221770a709fb1c8b7d5d8311f0e9b374aef490e6c604818d7019d8614b53c7f49817ea394285cd9a96fbc5e65014594f1b5994161c4433458f058816c3027a976ccaa3d17cf5694ea79e11b4565ac282c7764a4b3243e75d11c98c87d13bb99e419aae28b93ec0c2202b41d4fe2a5e26134a45901993576deb48cf84dc36898d75075de1eb66226287773158a46855be3ec8e64e9c6d87ab9497180152d529dcfa6cc632d64e76d0036e274459c0e041f235eda627a22fed03d11cf89ceacc3011390be4e9c721f7cd8ba70a34cfc59b428b5bc0ff70c6e2f1abab8a6c3c74093718d567c4602b39eedc5c1de96d7b9f05d651cd1214a0e7b2a49239aed5fb195f7c97073729dac1e293bb551c74f27a02a51773ee7ec9626a8a3f1ecb26b95659aeaed0117a776319262b1025e4de0d52f5dc607a2aced161dbd2e9cdd1d892afe1faff6b5b7b51222dab2212a447c16fd8ac2a6b8f73381f7d14f9fb2faeb82e945bb9ea5657f915f9a8830bec8733868705827eb2df48e1d4bf2c8df1756ff8770ae6914b2e3d1af0802ed7e691f1499a80bd8eb6dda337ac0a630ea4e1d3891b2fc8c1e8fc911c55a9557a3197c744eae0799cd6c9e515c380ddaee5d4bc6c41389b3e7f020e6f7579ada18c11a51f53018a537fea0c30c4680b72bc30da4fba934e66cad234a0ade2a9e16cdc29feecd4a0e4ad42426e3d2f3eceeec1d0a553bff0aff9f171dbf65d8130450feb31becb46e850b4669d6cb7aadf3f68d8eaeaeb573205d5e5e6f396d85be27009fbfccf8f1dcacd1d5351566e43434976e467ac09e4f5ee4e9be407450436e6c890c5600a093c2140e571493d152abbfc2f2133cc977d76cd8ad9c170e00f694b7e8487680a0a997bc5b5481ced9546a0cce4b1694ff64c9b4a7a5e6af7375f016a765bea17038bb2809ee0d786c9a557a623ed8c2bb798359d9dacfb2d57c9aea44d6e8bd9e830f24c964fe29410ba3724ec572662969d1f32289c020fc8f16af46229145b5583732ea04d1f4696bd63e7abd51712a4bc238f43045f437ea7d23df23d0e78c309ed06bd36afbf92de00ee87316d07ac5c2a9122f683f430f7464ee5a9ff654f04b174c1f67e69ac3c4228b486008c4ef00d2487625d05a01e63c6f24657631e52b7579e47fd405993f2e59b8f17fea0fcbf3a5ceb57cfc073dc2ac1e7d685dfaba499e8b8ec4518ff285786a23c332656674049f499253963b8ad40ffd8ac9bee78bb347611f105feb5d7472ea938d3b095d66c2041d47d7eb6155ce585cfc2c2ddf8b0a076905d143616cb6bc2aa32419e4064736afd06b2b845b9111c96578ebe6e82e1655db02e8b48d00b164ba784c48fa7d2ccdc0f31314e75c01346bb01250b417f59406d83a16b71b0c290ac8c32247bd0e0f91874fb04f8180c7d5883ccea59d42bba7c183f2c1a8183793169b4fd69a0643a6e5f4a8e3dedd61c8da66c816b5956dc71ebbf88f7978789416c0e0ee969cd2b8c73c622efc8aa2c5b2fdb45c3ff26abf6c3343cc378a538ed541c5403cc83874bc50b561e662f622584c36e297ed93758d97fb084538b5968ade3136ca50aff9e7af2ebaddb9aa8ed68cb262fb780a80d7757fe522f3bcf7b8c58bcccf3b46074022a69e29790b305c3a73777495c0184d34c143ac8741ca414e9ce4de907f29ccdd606d7bb2ea3c56b27f4196f348df5e5f6e4923084b4fc18cd2cb0f9158acdc769e409fc858283a31a3cb0405a35582cda64a19d6f46a9146a03bf0d595034fce37a0daa183f59072082a1e478fc1d40d72cd2581a8e2090dc5331e91d0c4b74bce813f30a52e4acaf32e9c4ccc4b004f4a72dfb110b63a3a55f07c9180820a79406e48c5ceb489d36dfbd30b12538875fe24c917580ffb3389bfaf96150358303e6cf5f765affc9ca5823f41e3adb6871dc6c1b0ccdce4083a56cae76b5dfe40d527c889f0db889a44d1754c3104efd79ff475c6f59c98c33cce75dd8ad78a4bb771a0a6efbfa13f6d194e70bc7766d0a1fff3b68aca7a0ec393036c0143680cde50671ca67e89cf225092cc8c0aafc13ea434eafec1ef2244197cd79f2995f67f788857db72f87a181736728d853604df5d249d271bc6b112c3ba1f708a47b1e8c37426ed61fe8ac9f75280f9dbd9d8be52623f83a0b4f09c2b4906aa840fc976ddf3ae8fd24a063223c93b654257745ed3ddf4ace06fc7df42c7c41354b13a6d7768cb7dcf5a278548238c7977bda5a9fe35c9d837cb774a040d126e0ba0166262258c6ce2d2332495450d2921af3fc293d1348ea1c61f980776f0230eac570c19efd6017dfb93ec9034cb8c2afc457e05c35b0b669bfc5ccdea6f24a18dec4b18b9b874f85696bd44728b7e3bd426e17714842d868f19150637debe25d2a05827fba1b364b27685f997721a0e2505b6be39a7083cfc4e50c66b09d75b623d6407107c8b7f15ed588609f935fffb872b62f5c953b29bace47fde56927ffe4f9752fa6ce209368d133bdeb550859f45ec7303d463a012387a3b1dd36e1df7ae00633e699f428b73f159714379de66f1efd9be6d8d41e3951f5ce17639d088cb4d1f94d605fad05e80d156bb3b4ae1b5e98fcf9fb8ac28b4fc4ddedfc23f734cbfb1fa8cbfd87254f8ba3b2def66470786218d78509f070412030bcfde24a394e8dbe4bea2c77dbb6eb91afc8018fc0eec6bedd13af5121a7f175b2f1edaf68af935b5a0442129c65c22e2deab90a23bda0ed8c94789f552e49724223add1f102e0ecb34cb5804c4b1de4da11ae751ced8763c6914685328c0dce62f14a58a1039125ddfc3c9c85f3b0ce7ca831ec6f495058cb1c74209b9a77673ab48f2aa4b24bc9cf41ae3d99272b3759f29b72248036d0e2587e535b65aac0127f2c85f47ae01220d5e1396ef814711042e7b9882106b8441d35013fb8417d700679685657dd510ae55ef5c93103a81ae1a5578d348c68d2f261714dcc014633d6b83bc72bc25828c62541a0fa42ad5dee21f14e95ace6ce735a13233431aa67d24eb145a67d09c643fdc0b07bc064738f053395e785ffd898f2ce3b729ee07c5d2e6b2915de640d8f4d33a4d02774f9e3e2400c7a5e0ccdc0f1750832f6ed3fae3a867f7415177ef64ea4da1447f9823a56fcf77288def58a8ad8284c4b0d3cab3245b6bbd4eb2fc7fe1960f16a94b8146ea05bb56375db232c5bbad8d74473c14b0da64771b64bb84a10efda0aec44a3975710988f71bcc7f5be8e8b46641c632645c0d9046e43c56fc4992e855ec4bf33b9485c16961eff91a992f9ee7e4ea05a681ad0aa62297916c92fff9ef092e5d3788c3217430ee5cb5bf9d975c305d45779c032b2df4d7e549b1b0ffdd7b8cb239092b2f0141b2199752491227a53b47cf0c96535acdb02cbec6c1200e49a264025aa0d4af4349a9ed7c4a45955b7fe542da38fda61586ae5e3e584af63885289568e9386220eaa00b61806649deee4371ed96a8a2664a1aa7bfc27e42a4369284d17c4e123cde09f19ed7011c3532175919fc4c1a04545358172afa3e6df801fc80db19b17e64211679dede94049b0cefd6aad2df7e9649138b953faf391c3a933a94b434de562cf7f69ae1233d26e9b9a6ea33f1fe9aa63093a2a854ef6f90a08f19b61b197812ab24a388367d5d82bb895dd5e836b63cbd7f4970a6dc70b5ecb0a9a09a791f9654eca45a9cf8c4702cfb2be54a67bb4211a4a285f2d1e28e213e7d34ea1d0250a8a5a2b141fa8e510a4a12dc9d3d2e2f864eb4a454c854657bbb12b18c385da6476514607820939339012d962b6e60f5dc53162c99d7ad11c113aeef9a07caa557a8159561bcd50356d0c5647500bc1aa38db1cc871a71928b2e7f00578ceba5197385b55cffb1d1902103def64ea48d99c7f8857d7a3092309b3bac09daa7e9c80b76a2259c75b883c101c4577bcc5d014838cc57f7c929c63f726c06d63f52b4f9b2dbc550d0386f376faafbfb2cc72c89aa5f7983112d01c350c014b5c52a1e1f4732f686bb1ce072d1dea0424f3f9c8cae0bcce56934f195f38654de003666570389e14e65caee61c6e09f8b1757c509bf6e5e4eb8c31f1bac92e4c69e18a2be4b88d8f9ba36d31a77d1777a09b6c9f2cbf21607ebfa9ab8a62f0bd256a92e1ec2a6b1ba3e012290f48e17f94a90a5698d3996f39a5150022bc20323855b32ff82bf5aeafc3f236ee5e66b646fe35b98a2c98f9987c7cbfd8e6b19a247943034a0f4c109aea9024b4470f49c465d34c67d0ed01d3cf83f7425d76efc6a5c8e8142f603f067b2738e1a90b7e010719694f21cdbdb9f10d994cacb52be9ff8293948e8a4c518bb7e6e01a204dd8f0b826123e077318ae3b61391797953c7f54be7c80bf36b280ff6020ca393d1530345a3b56c776adbebe3296ab9c6670c18f0ac9e4fbfa06643bca209b594317279bfc8b2d3b803d98cca4473074f5dc3701ac726448b722a9ca12a5bebfdba8c343d516df103fa62f11198c70ab953b9cac1363b68d1d3dffe327e9999f9a299b6393b58111c0027ef587a8f5002848069e09772b33c28d541b54d9e5786c2f7ec2d059b412ea145b5b9fa36f25ee6e0e3b109e7b2e00ba55c4aac494499749cdb958bb2fbe2c935b4ee34719b1b47701e3886ddb9881a7f6b78e23849525a37221deff188cca480010bf7d3d0984b61c00c005422b4beb30768597c5aa4ffeb3c5356dbb79b13ea9bfed3493c5cedda525676e215861149796c861faa1ff0a0e54ad401dd566057e535bbabb848b5b8a543f66283cc292420d855dc3487cd654c0d45d6bde1f7d2dd5947e03b4840e83733a3431157fc77273d76935de01e00c0aedd656fc2234606cb09eccd95c66cfaab1f30e8f6c1a0809b96b3802a30a31c831e3093a6e583de2f596eea715ffae83ac31ec08e53d994da3b1a2f84b6531171bef09b44d1454c5a99c25946795a00ed63327e864e6a9596afeabb9bd8bae4d87f9d26ae146ed4ceca3b9e84607f5b7539ff4a6bd169d5406f90d057b5e884b2d9901e0fd4036333ccd92922c2a1892e44e7acf2530b99c13aef79893e208f2bda23affc8556a87b4057f4cc22b8652dc638f8e7c6f25b63ceb23767aadcf99097440db47de2eb25c22ef7fed13476b771ed7207b9f887e2d866f351bbb0cf59e8531d40d2a6b118b4a3f172bb4002da361c65a09d7ec83d3dacddd6a22be36c29f49a3751ed4c22486b4827e0393375be3754797b658d9ba34eacc114478d1929a507ebbf3aeb7fcc6483c37054b31102946c3815338aa96a0db331674197b2fa2899dcf1cc5584d880063ef84e67f0ee00400dc38219b8b045d53759fc9fc1af84594465b8ddcdbae1fad96cb6c4b8b2b17ad8e3dc80fbb90b9a30f860007fcabb7c83562db335c7fe740e1cde9a994b177c2d139c1ab3a2e08c516da238086f47750c50cfdc56d7122193f7aa1cf5d7e98fa161427301e83eb8e5c2ae9aaa719a9e04665d923c3735d4429095d7ea7bb33b34d4d6a91a5219f09df4b342a00770d096b243d297b631f73040913d9f31f69f0c22f287d4e28a3629c7e3834c1d0ae62031041321a7d2acc967c4fa2705b65203968e7a0cfbd5e5a60a66e049d4c40dd8284154004ae87e6cc9d7f238e1e00588bf0ec442d953c2d2611466110bdf728d1ebcbda88cf43c7b58dc9ce512e50ae9ac3f418da9910d81903f85fc26d27c74136474928e6c25bbe236e9c2037602a7e69e86ab1307669c9cc1322996424584dfe7dfa38006331a6ec3350c21c45537adda67c3bd51f84185e632bab36fbb1ea4a56e3f17a584cd2d584e6d30357f19fe59ab2e8d906a49103b80b56b1999690e864b9efed46e4afc5b1b05ddb18fe2ab131ab73b235deb587620b583a2ce20b433ffcedd266a49212cb6b2a8aa8e02883a0ccdc9f5253fee086a7ba95e7e2cdcdcad95c49b1d20b967c511b6af22e67c71cafdc9f270493d5c78f70da7997990bf149262a6ade8bcf0a0dac8ae4e9a01c8e0d07fe60ee0ea6fe4eceef437391c2f562c9ae090e22377e260c51902859e626df658fbb1cf0edfd5be2be599a9aed18dcf42b118ed11e833e59a124a95167c5ddf6f7f75dc374c07f6393027439c2bc9daa5ccf7f76b3836d850b5a4ad512a2d31e64d424a8e82f79e088f1185d786d687783a7d8b78dc98f92825e6ebe98c7f073498e80a458fe1c019e7a57986f326a8732191ee768f68ee113dc01e73acea4d0e0bff2c39b521151b93d11fd19f53b615c2ed1769f33afa5dd7cd62aca45687c7737d44ed09bbec57b3a69c6f6d96c10164510975b30ce680cd013be76a87caecfe9928bec641b2cbf6e17373dc8a41275b621bf9210bdfc7dbbebeb001f949354ba0889752b61d69efbd32629e968b1d5f927c473fb2f724b7a1da3d7ac0216cfcf33c89b076e4ad059b619bfad85207c5da4dd5ebefe8fd7c39528179e7dfc35c30384b197b42898c3ad29531c1b19e28f63c92eda508114861e2740be40c57795ca94313a4f23feb17e462c0a1b0ee794cf6ee11d4a0f33c8ee17fdd826f02d4b38017bd453c2ef287bbefffbb43f615f768d61da46cf4f131d846c76f80987c9f4e37a7f04da1fdaa3b8a16a969745610b3427a4ebdee36abbb100bc452919551279e16c382e9460e80bb70481c5249165bb9061f3bbe9759d96c64e1c6e1bf44ddc94c37f904e4643b63a9b5248cc4a1856a7c5ab04d869ca3a930d03ae478fc6a3585cfb51769f7a62bbdee1b998b6eaf1c1226050f0f21ca87847eb8f3185f0a6f084bfa59d85b957a9f00ac17cc90f6721a58441bb1a43adb1058fe90922912813efc72ca65019099bf9577d5e3ca458192747f3504f16c1e5747df49052a68f3837be614b6d2388d8d585b6363fdc83c11de4f283d6f8199436c25787369842a33134ff19d22fbb69d11f74ffb8d9504b44522d56291a1aeda19ce95e7f29c488a01dc712264c856d27ec3c8ac5ffedb8d10c66088d3984bd2ce429e86cf6846932927a98a71e7d0ec7e38e6d5b662dc025a28f9c1769f9561e99001f66c0671a41df901787fb73f7b7a11c3e3f0606a26d90992c3f83e5c81d28be6bb95394d2e99d330f27105c92f9cf026478701ccc77e1ac281eb314478ae340857d185d0fcd523c66298c975fe09f6e214b04c816daf0f8074a78e43b63f19fe987869faa14e30b5c2031a2d5f5a4f0414e65f12cba00cdfe1812b090c30ef9523ec86adf8b8c335ad70411606a6b697db55d5fbf2894ce5b40a8017ee9714f0daf793b9162e6f5bb5d7d8b361d038967727151b2f70d98cda1c57f8a6ea5284749203e58959c686427a3eeb26c7fc0b6f6e751ef943c30dee9848955fbc6a1916497c17db034922031b204ee1ef537d97f47b2063e04bb2f1cd2002003ecc3a8ba216f2459b91ea8e0829c86a88d29d337aad09b88bcd72dc0f74ac30afa32181778629b1f97ed2d16a0a889d67975c3da35bda93d344c2997e3b3edd65b813a0176953251b79061540747c10d2640f0e9a83b16375e26d5038dae7f9e2165740bcfb2e44da3dcc0c03492db31828706af07717a3ceb5e4ab09bec6f07663d22f9f885cd8f55df462ec3f2973b07fe940472552ee298288566dc1f1e97a58b5b7c1db68d5992fee75273d748a655aca874c9384a23709799a7f4c648312f9ee40f46efb2a265e2c7d9916c761e75b998dcb6cf475df06f5763fbbaf048f54e405420dc807b8565078837b79fa484be33e50dc7940c2e616cc6464770bbd24cfa41000ea616e8251f00fd3bdc292c0f8403f38206863984075adc7ce6326bff2806c20ee2a1ca98a5d7d604d346828dd6a7386a9b8abd42672d3fc8f24b37ab5983b300a9eb50d222496c1836303ae6cf53c04e3c4a2764c32614cd094bbe8b9319a2398507acc44f4bbf08e62dffcbc60f6bdea44682c40a78ab41f777b748f3d8f96a79c7735b7067a50bd1b263dd39d6609e977a9751c2a197e58d8b7441f67f6ec123bf784f68252100d5ac7da465144424129599d64e3e861cd5cfe51b45e3439d903d8cef2f7e663ccf69791977dbe88f4097c0877284dc53cb4be5a2edd24e0ef00198f37633873c2d48948f3d5c80945cbe292fe3961dd9f94ce537142d5ba03208b33e898e62a1e8f97ae252625016bcc2efee691b4158c039d467a2fcf17cb536d78524bccbce4e8f7dff8e506776945d7e2f8be116f531f5831f19eeafd6d24bb706027b71ff7daaa4c3fba0be7cefcc30c085b3ba686f54a77aca56a88ee6df10ca6688e75076cc7d0d3336cfc61e527333d9342f13c8116dab5ded6392636c1b68e5cd02d49f0b3526c8056391f2442a7b9736319b1576c3a373bd2f54ee0bfa346c589dd11f8784598dc2bcd0bf09c9d7524ef6542d7fc57df5b21b5fa08b21d20d77d3247a1aa5193d3b24dfe50b31e777890e3d9e31d84c6be2ef6ebcafc7ea8f6f8abb7b0ad0a271943ded467bfc341f0eb16391f2606c6ff41137bd390c9651be07309b909624e6530fe7d5667bb7dcbdb8691ebd8ff4c8c6f767d8a3f954d0f1d3e1f52414d130367c2c0583f388c047a376399af1ebf19faba86b66e5c2217995cdf3cb0fea780af485cfa36575d74c833e32f41e3a19247144dc2e0c7410cc7ee5496be739ffc1a7d24816b7163d95f9ec7f436ae70c88e69f52556c97606207cee05787cbe6b5a23b77c18e4e91c9509b4edb0bb1291f15bba3cb0e59bb3267b1011d4661291ecc3a1556f5fa8bd9a61c300708d279a9cc91dbd75dbc5993844e532ce36ef30aaf8dfe21abe48567b3b3da83b7121093177b954621590e035aa98d554354cae90b2d1071057840430466e08bf5a106f4b67d7052c345ce2fdf225c16f5d3e0c83c879b09dfb2fb475887a9dd6c2f8ee75ae828ff3f81e7d5adac20801d62684788968b7a2ac9a75303daa17f7f4adc8df7afd1415efd3a77ad36cef495c478d00fc3d9b460dab7182f268b911020e5e78c041073389337f6fa9b93138e92ee54cfdb5555a870dca0517e7ce11a46af1c15cac0eef350325420f07f566c1b1177398c6146e33c62447c16d7b0673bd4781e7b36472afeba922c215f7dd6008e7ab76bff917bf6b7d5bf5fd7bdcb3904aa935f1b9c6f8604a54cff2ae93e98f511887db4ca13dee2125790a932bbb1ed73e53c863604d5c584e0f47ed7927699e4096898293e60bc9f806ece84411c4256f19fb4c5b60310454efe172b6747a6935afc4db835b8fac77a183281b220abcac0c06261af19ae37478010d7da9dd047d274c11f2dd1471c31e2f6ee1e68da70d099a47035b099dd33d0a74fff84bedf7cb83f608e91a096072a90eac40060224da4577cb52f21140aa3faf1cb37116b8a9245e9898f0f73840900a00ec73ab3a3d2662015d034b3891b0200a11c46336f9424d75973823348a25844f5cffdd22e821a257fb2e9c360e3a0a4786cedcd29ed4d12a76bb3ab13171105e238f31b735b7e1116bf1da626287b01bbdb6eb11438004ad608349c483a3a9aec5a93cdf16eaa6d7d2f890e9a8a7542830a9a92ca0bc963f37562987b38a1504c5faf7bfb721cb3eb7ea389ebef4b23866cea71a57b5f9addd1e8270c8984b8dc3e6d4da487ced8185c397adc31feca8344b295a0635033695242c4c97518dfa74f672371cb2ef4507195cef3d5060b375db94c92ec3d77196f34fd82aa970d492bf5dd0b85a1fc8d45434e17b8fab1bcdd3a4d470396e7e59c011fce03ec5a12fc4c546341680424364fbdb36ef49e9b0ee38fe94de4afc4579cab6468e2a4499f7e7db908f1d3ac486e3bc80b85996265e12fbfc26f5c51ce307e082799bbcc41ad79fd992af0ffe4a8c8c7d19f3182cb6f5c6956bb8c4b3aa1e97d84c7d49f26f3f329e21ca9d98ed9cd315ff67743d278235d60a746a44d2a0fe3c0bcc911ef0ea9d6766d18ae19dc3a602941eb1191d05ad247cf287e8b4d81ece103e8859db11202735e76ead57ff7c4a12d533209f3be8bf01ee990fe05ddc4a8ba70f4373c280b7e736217be6da012aa7fe83930e193853baafb93f9ce7c4db11357a40279c3c9a056a0400d58dff2e2ee3b22467cf886196e0532664026f569b85ae5493592f70f47c4a425b97778f7600dfdf4f041125ebe2e34aeb5de2d21a4a43dc1ee8eedc9b5f6748059abac0737a29f3ef34b37c774af474c79d524ad0cc3d67def7b2124bf1805a489ad79e07069b3e3f6a9eb7b7bc89edcb27adf3f2e540cae80c793c6dda07341975a3885eba0a72faf9276f0511c4b824e1384e901d2bd9fb9a29d21f76d55675f4c7729ea90c271838b488fb1b5ef1a5182fb354c16f8471daaf69d3a0a2d71407b29025725bf99c39d5cf516ede47de9746d7e7c7150052b75f89d5fa573783bb9c17c1dab9b47e1d7df32e17180ebcb5745babd01eaa7908806a7c50244c38b626e6a27f5ab8b999dac9cf67ad6077ddb66dbc4f6a23fb39ae7401be8318d9d964948e7b3dc092363eba07e66200d992c57676b4f7513402a8f4e2a1b21d5fd7aeaf32040c06a4959e9d08348ed47ee5204e0f40713871e64318872e309383a248865c790256420b98145dc9f955db53413220d5d893c9c1008fa741055dcdc7383ba459944066f49b988f651941bcf561e2a538595b74bebd9e919021bb2aeaedb43312af804cf4e0bf642182883480f1cf573e225b3a2aebda4f3253068dce9dc1b72f4625fa71088741890f38ebce9df8fabd2d142bcb4514e42895bfb3076d176d2531f07304f337a5e9f244677745690eae4605c5102baaaf98b152678cd13afa10ee7816b920fb14e3f9c36c84c44b0d14fc03d95542bf761732b13d735616c8bd8d7a4fd22903b8fc803ab87f710c4a3a216da198f8950f04c9746cd6bc23280a26bdfc43ccc41c37718ad7a0d48914a8f93e0099ea8eee35b218c3c5703e04186cde3f15e4fb0fff675ecd8e025e958c1248ce065df976287f6e4a6c9e017d9c87ea886c580d1976a1aaa760845400599721dfb85e08c85fafe771c92b4090c1236d867131b72b6214ff9301bed728a32147ad5457e686e6f8efebce9808c1f7e384100a1d1ccedd3444c88e589059be9454436b989cfe305b6ea79250e3e296d7473f7702f2a746218e30c933d5006bd86acf6b373a568cfffbda23f9287f1c34b47943db19dd57f0926119e44e611c08ffd2c762e4e534c4f11d1201f548726e61d8d358a522c645968d52ef0f0aab6f671d937174b0bc90aab68b5563a738c5c9f7258876dcea0a0024754058c36708acd7ca6c1c74867ad969a132aa5f024c6f3f2e0cb50fd9ea3df244c12521cb16492dbf91263b250728101e45fcd3a8e32cd3df16faecc8c1b4a8e38407194f92df315b26cc96ef8cefff4c93fd89a12a74b28fdd6d517d13abb91b6a94085e20e3268c9095b6e7ecbc0b76892a55c088a2916fded098c14bd3563ca4239294e2822ef6db34fe10b6566ebbedca5159f232002dc15f52a1a3a3bfe5d31e4c2cd13b6a487e49f6603e1071e3f81d623bd13fbdb5d1db5268c2569bb51b3a02bbb66888cb954c1540f1ba32deef7caacc0a211b8d201232180acb6c8a05821cb2b4006865f54b82a3f8a99563f42e85bd74f24b8e4b1507e16dd08efafef4d927f74d00a2c2045db5d66df4356b144896b0686133fdfcd2d0fcb20df1f14a35716157ea2b0230eb1039d277c77389656ecdfe9b5805f1f0cae44782913bcd00e3a95818f9b4b92e92405edd60dcff055b3dd4051913c7395d54f4328e27bd08ed8a53e2401ebe6ee347bafbb9a368498d2031674cc354a13734021017caac9adac486a8b84c75676c4deb65e59bb36fef866440aba5b3417da63df30b10cfb98adf4175326925d451e7a5de8530d3541a4c4d182e2b8000236469e52a9e158643ea313be054fb4d1e2c70d0167586037c5c55a062f0e3d88fee2dd9ba72249b5156617fb88e7872e0986dd7ebb800c463e25cf49f7707898e2f83c8e12a982a34d18295c6cc576436699f82b6131f8b923ddf19df9b35005c79d2a89147907117f9d4a67326663e48e6bb0cccc1ff83927f3ba01864579f601d2dd64103d227ca3bbaaa12a4e267aa2701f5ee6eb635bf8344f57d621b8805fb581fc04adec5cb64c53e62e34e97c0af578aeb0dfcf2d8fa31c99de5d5375c43a2daa42ced475db535b7fd0d4b07021aac04e0181a93a416c4124858fef072bbc3a2ba2ab79df1573a2a4c0f7106fd72b810d190a3bf6dbe7c7482b623187cb5e4e9cccb66fe6b3c1480913fba7b1c4592da1159fea809d6fcd611984cfaa8246c4cb33c47c241842d5c246bd861154880317f665b5613b13fc98f473312e881e8be60a9b8244c3c2e7e6895156df43be5d06394e0b24ee2ff3922521c598897a30352c8015f462633c1b46ebc4d6f8995faafa5af1733967a05665693649b188d9663996d1a27eb8cef9be9b95bcc73fec93acadb5efc2575865711ddfac98ac8a351b82afc69f4c8895b04d1a454b6d2ad6a7a1c384092af8953ed8cd49ad8e167f1582bdb9156429d13aef7bf83d8f60ad44ddec6fa1b7ab1e349f61422a994c1aee966faa547d0741612bd624e52e93885662f1c8977e345db882e2a6377b974e421350b04bc935f6d21615083b103d98ef25c2ce8a607b2bf825b983fb403e30f14efb4767dd63bfe04f20e0156381897f8b98e5fa2402a61715226df939c38ab0f2b1cf709e7be4519907b703ca8d15a212fa10600f17912312d946e2d559fb03aae3bd429f16af4db86ecdd7dacc797a510f8f561b3fe40316ea3f520323f7d2e10696cea5f4dd1f947ef661b92dc693863746831432fd81fa398b1d80c88b24108c10a753e7e403b977f982f331904158fe2962d0751da00531632a35ce6e67d5d6d59d929817fb386d469019923aa9805f88af4bfd06a9326f6ac0a19afbdba1e9ef337adc80f86e798b9ff33a48f3782e58d09e00b9317d3651d6ca44fdb62d1f0ea2d7dea4d7f163cbfe1c131429b096e4323a0c95e92559ff7c2a2e4423852a27d167010ad9c58f862a344a306b9ddd6f8e998c5e55fc53786e65e3466381a189730b0cc5c3ceb6f51391a0fdb2694cf0d3ca259535076317141a84ce69f0271e7068cbd0201d39f9eaacb13b734e8e9a1b8f102b7b0eba1c304cc8425d6afbe1a6b3ee1103aa47d6a8fa8bfe03d0d1aea7559ae2f9fa6626a747675cbfb1ba103f9d3a70631f65da7dc07657e8fb3276e1a96616991171c8bcf7a005b048a2337e88ea6f26152c19ce17f1342a61e96e4fb8a98c29a490bf15a088aaf55c0543bf052047d13f6f806a6341f1977d0a2cee8aa44fcf4a94ed3033ab2fd0c6f56017a7b559339a46b3a21628b87af6272265e163db895fe6dfb76686dcb8d96b941cc98e92223c26a80202486c86d2b5d3e766439f8594997792a2c49d70330846ae73363cc98bc71f1a74add5fb4f7400c114960150bcc8e413466d6c5d561a26b3888496aab8169efd3700b36a3de95c1256024c3160199ef15f63218d5c46a925942411dc6218331ed6991858ec1080536871f410d77ad4d44e0b085ebf225c2884736e1bcc2b1da168fad717707ca76f25a26aa8520988bbc25e4df71d28e993b8e2f54c2e52020cf8d99e0ab31232ee3ad8f07c8b8c424cfda25cb54c5392ba4ca4c4d633da21e4c605f60df7517220dcab15776ab79a3fdcf1e092b0e9c6b5ae1e8345f0d501d53f0679214d7e67776fa295ed3db8aa5abef985ca8c6f23a829858d71b825f2fef23d1785afb52fdfc8f2f4323c49c4a7a8a9b8be95199668a666b45e450e35bdd41c1acf3239fdd72e00e94ba144f25f975ade38db3c0a9e3d3281673013a3ca0909ff3e39e4a3668afe5e503d95b64abef40e3024074be121100c6157572b682309bc04bddc05f0749c2e20c6a78dccc74b1fa67be012dfc12a15d49122a3b5956e2c6d54ab049034523ac18ca7af778ff955891c115ddca7d4f3721c3bf7a510c92a82e774e4ad98db5b185615c09f7ae7d5835f57854815d8690e6493cdf30ebe265b12961ef9bb84c374704b96bc9143f88a4c1440d1a0785427bf1dcb45827911db08553c1fe92f73f404b0eb51a280fe4521757a213486eefb6e5a36e61c8b107d71b80a22b09f1336d7d8e6f281cd7b8ebc055710a9c754619b924cce969d760b5e8366806b685d7be953f4c85dcfd07c6a5c3ef5ae8ed4385ad40af02d630d06bd5e76c150516fd52788d73c82de194eeb000c18f898102e50860eb148b1f0dad41e3f37a6ddba890a6b840deb15f3340deadef16a782c118021bd6777d18d68ffaa8e2b0ae5b8ba670b1dee67fd10ffec12e270c91fed6c5fac63e1ae90a2dd3f70731df4a47ebf7021f461405ae0a6521ead8c368809aeb63465a6dab3adb99610ab23ce9f4441a881f339851da69eeabd268a287e8083e28c4a9ba6975ccb9f064bc3f03eff09f39e324bb8a1a957623ab66103881c87b22a74daad8a38e0cfdf356732845ca8d9fa22d9b6339334e0af06b32f78b14d10506b7b297486ffd07167e46e3290a82bf028dd7b3a9abfb57fca667c129950c8d6f3879d69c6fe8ab59820c8625eee3eed343079c3f7e507855acbfee3f1f75d16a8599ebc3cd0986bcb5b3675c4a60aee4195ae9f8e4ca419fafc985f31b30f0485317c562f4e5481171b917d1941bf6b5995beb71b5afdd4d5ddf76f5c7dd8b18357d676c20edac797b5b7ff5ab32f3cb44e856e999f9b040935a6ca7e89bfaa89bf2ee6b99fda4345509df720129306067afdc8812618008da6ed018f24d133d93ccbb3cd22fb72e979b9cd37428da1a035d05d742f235a5b41dec76719a264377c2e0332c58f1b921eed3a6bcc2beb7b1a11f2c4da2de63682a5b14cb556b8573dc3e882744063d5b238aae1816a7df1397dad2f72165d0680fc03f120811b407d15f81c5c3da8f77022aecac7b28266870c754e0fad8e70b2e1ac4ad26872d3a0ee5939450e9425c6489a834e588e990bcca102c570e5f882aa35f8d4a194b1c16bd5f1896435b72d392a8b189bdc9064c25ac0f84001d7f7b62c2857f6038ce4920a662ac4167f6abe0734a94f1f15053a5cc7d27e1b919a219341921aa5ca7942677b974d247d578543e9c892d1f859c4c638ec47a84a1d7ed2c611550e0e575287c6cd29c73bd893c84f7fd39e57c1d3d0f4d367f95b461cbccb6b0e6666612644fced3b32662bdf9cffbdbfee7aedbb74c2341451d0b25f86fefe91de3fc21fa09609eafe4f2c3fccf73ae6fb177d384086463bcef20d79b0b863d593d88f8562536a9f079982bc05afed44a0cd0c88918d5cce8ca9da92d0320c81d8010e5d13c6eccbc8f1dc488e281f7863318110fb1f8a981cbc4563d4aa08bf1e1ad4f41212b56c931196b93c1f74acc29ee292ee","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
