<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0b73ba884e01863373c7ce5fc3587c8053cf306027ff55b465479ce89b80d2ee5be30df0a76132ad642501019a9e620aa4e895b1442c53e22618589435a6c66ea335c1944ab587f2ea576cd46c9d787811be488fd3c46e26a3716eb63973fa187da02ac92f37167bf7f487ddc8fb4fa2b5fb306f04fb0609289ff3adb5dc6f2a0dc4dcb9422b3d689d50b98981069251f1aa949850b5f5b25b34b8cbd22ef7893d1470a2cb2fd1a619c527159e9ef08231fac76cdc27521d3ad38c5167c5688a04d6a2b3a7f2753d971a767ac4ee8cc6e293da22587424db6ed87d1ee01da5a5eaa3630c442a40cc2a96db47721f322dadae3d2bad809d3194aa5b7911517d767aeb130aa09af2035f44db007df2744d94fc0f49e952c0352165e8c5e818e48d7eb0d442b1e6f3bfd61a23aa1e25810622a12084b8d52003947309d762e66cd3e23096a8dbeea76a2372a446fc5215af8e2031ebb4f52e644fe81448f36c543c4a9385f63063de349f10d3190a810ca047d3b7d018d927202ee66969ef31c4a6757ce8e6bdefc571ef7e89a694f2e2acbbf5cd131666de90aff51892bf7b5d5be0cd5577825c9952a9a00315f0923b33d81c00933135add8326f1ddf08d4aa97cfc4ccffb18da520b487e902ed294c5ba4e0398f7f5098262f32f7ed78230fb18715b8580fed78b975130987abe057b1ad337da60ac9dc7386882b4d9f43fe0b41fd21d321639426d51ebb06c02fb62f1557e6f17edfcc28a59a7fe6c2e74639b9caa8777a69d54e129b17d0ac3d437908c8ba30d694cf561df4062a4c4786b28f25a12f80045f666d4bc958d959b8ae6b141b07554784840e91a6376c10a8e030cc12397607abbb251a495ab5d2363d498d68399f3a0405c2c68e7cf1fece6ccc8d4aed6bd514bc8941779c5796c5b83088474dabdf93f9f6e97285d97e1f9a2adf1f9560f10e5a27a3170cad17ea828671e4a9f68c128fea08aef295c1dd00f66b44631b06bd20aadd64eea421f757710cff8375c04add700e9911ea43825d1088219cfcc1217846c4b565a45410f0e7d1f3d50dba42f40dafb4860db0d784e959fbf862cd0e7ec015e5daf704661375053f06ddf746d141c433673e32ced19727948cf9d0609a0af8d045baa7ed632704b2e99a88e3b2ad0905ae1c93d79b5325fe7500d930afb11a6bae6e472364a0bf2dd2de79a677a1a52ed1da74f7c19955d33774c74c16774bf7a8236616ece64f84dea6cf64eeb1e4a441f90a4e24120a9470d3ad80b82f7332b795564f41f30da0a0cc69af84a9981d1b2009debf2398139c764d9eedd3421f15e40abce357f0af510e6183764dd23033dcc70e8ed99b32bb18c0d49a05ad67ff778ef60e08c7ac78b89f1295a28b8e0c59b9f3ba27ace00efc43595681c239c95a6236f101a17928ec36b5a90314e52717ca8307afb90538c87982dcf52e8e2c592febd2c46ec531adfae4bb8579c3785fe047e4241658841c591ff713824f3144f3e2b710ddfb7f1145d2d698768f506bc02f4f6ffaf10af4542b1ad1bfe525eaf70dc2a715dff60c65de612f0e688117a082a0fd28796c1572ef8092436f9d82a6a7ce5d515865d5c166b342fd8000c399acfffebff8111f2f44c9b7b3eafd0316f8daab2bd78dc8cc3237983ff215cbfa4f7845377a81f36682500192edf7451497a26da0242dbd8c56fc158e107d68383347d3c2c2bc753dd813045320dd35dc4cdbf434cc8b3b79e527615ec84644722c7e141bcc5af7e5a2414233b662d8c603fc10ab1d602d7b2de51bfcd44910e1614883619f970d3f8b5e6b9fd142b687ee5aaef5d5ba2dd793545a0441fd60694bc3c55660a6f0a899d471492895795d605410ad76165d4d9517b91403daf25ac874e47800a593c285c7d96e79bc2795cf0d16fa9d45a1d175dae8fc28e3b88ae8d3a970119797f64c4775e6fd014b666ee27e9d1b8880ee41d735294235bf0bbdc158c51f1d4d7730c94853db4896b668aa13080e589f0791aa7f255308d227dfa18ffbe87b22245685eca15221f6095cb3b471c1447c87493203f6a8cdb6399b10ac4384dc5116cd0b29b7ae22488cded2c2d116965b4442b73e6835563b535ef55497144d9eaf407405b908461a1781fb44e938367387f0bf4e9a7b57378c592c7d0716d7112bb5902420da02820b5f5a63f6a9d2426555ed058963265530f09ee5014ac06fab5e0d346a0393010119041abb7ab6fed0fd9a01bb24e2e0c974af995a362d6b677f4ed6f372ca9eada3d6b598f156c9f9b3d8d659e4191fa2f9b20c374cf9b27f780fb9535bb98e41f6d0dd3de34b276a663857a9655fd0c2665a0551d966d3cc2db377bb37c63dfc5b40b9a4509c5c7c431f8a92496fab2bcc48dbef55d9f9138818a7ef952c8ca6787b33d894c6146bbbbd7928f2c21061dc92313630d1cf113baf8bf4c6f80175eaab052ff8962c8ffa0daf0f6c5c4421ecde6881191746bc17991711eee0491ae42571f8a0b52f69e2074187e6ec01fc005582056c7a093680b740545612c7c58a68b52cd4bc6358ed443a387b9da2df454990c1e34aa86da26df79f26892839d84a706651ca4b23089a34a36b9e226d6436cf0c80519cdd1d951c739b92d7987c4be67c3b839ba3370a8e5a50adffb1a05cb30fb21619ef7fe5bd43f5711400abd02981e531cefd839293456d2ec13b6533cd9ccf03a5b714fff6b7a1550e201e28de62e33b73f9dbca8101b9393e8da1e2485b542dfddceae544051e8e358ddbb85ce4534fb0bc595797e9c808337a5e1ac9e01b572b25a04df3942cbef89ff3f907c374eac43e1919ffbbb86f41583c554c30e7d878e7501637ec176e44ce1e39163753bda5527a47bf71097164ef40af3f27431b4fc45980594a355cfa3748cdf97193ed0c87b1edddd948ed85440def006cd451c4b571789c1f0df71c4d9c3f81acdacd4405d9a14e3f9f0512157ce1f683574ab1365a3a2c42666fb098ded9875b074ae104d8e0b06482e721f7d4e6c70f363a526ea83dd6ae282ad24f50e2b19aa98f787b54df5fab2c249c3aacc39d4cf39add1a1c40795619d1700325762be956472ae8a101da9b75c3c68fe829ed08bb484d1cb4cfa59050881de481eb1b4f3210e947a17ec5d37eb936d6666941d96ed26b94d09b6a6af0bbba6e5ad0017b7584e31b54fde7696a42f61b511571f4a3a5d8b2fe572e89b5823c8a4708f8b5c3a814f5e595e9d267444184464f36b3d626e8945ffced1968a7487cf0a072fc331b9cbbdf09d67efb3270c59a7496015dff963c796dc49534de4b7f56e66a891c436ef0fb70893687fe96ede8fc9d25c656b4d38e6859367e2b142848a7107a1dc5b42689494bdebcf7b54c89ece6b036783e009d682a42a344e3aa08bcdfed97932389da09c9526a6efb8a7e74809e6132840960269714452273257fe06d017900bc96e199c2f48a409da89298e89e4196034a531e960999db6266010de7a34f631c863283f7367d22e8d21dcca2694be2e8c89cc05bbb7db6c8fec553247b7b78e8da5499c47d7583f8bf7791e494d265dfc152bcd674d0e25000431fde5c047dca9af866fda7797ecd9b74d180af8e24541b44d7188665262359b9e8a163346230748222a363ba45af98ba947463655cdbb0b4076134b77e5a05118aeceee906ab8d7816996eb2995472dfde0355b3dcac7f0cef3731358e8e95d56b3751ef4dbf7bcf13a5c35bfa877f923b7f3ff4c1c4ce38fb42aa190082c9f08f35f7014d17f26259364e5ebdee93eb532a69fb10a380900720ed1928d726cc8ba0f6958d54839445fa92d58d1f34a5ffe847b6bea7c757f9b11b767fcf82743d54288e45570a118e2b2c950a11fe690b240f06c2a4eac1fdb72b43359cebd0af2643b76e251d31bb8302b9dfd296382d721642d2840bd61c4b4306b3533ecea2a37f91a5b198636da9fcb6e7bad9d26643fc8d0ded2607b58e7f3a07c5e1816e0576eb00d8370a9f56af09f84efd9b4155b82e89e951ff7eef27579b428291861e2e0ee5f05e828e27b0c48f737cafd7bc4bcc2f33905d319511e46a4e2d720f7ecbe948c70e13d500b325fdb5925959f2e7811aac9917837a8ad7767bebeaadd9f8e41490b5d2a406271ea12ea957badf46e5949318e8315526876e87855e4704b9d3f26b99f1781d1d3925e8fdd03ca1481248e9b56c08d48fe7882a6e2d3acd35928e2692da1a43690c55f7c90259124966e2d881ba85c7e8c80bee174ee4e9bdcc8211f22f80f5734434629eac174958a00791f92dab9c2c1da16aec5e7a7c7e8dc30d2603082bd2d29d059e633932775c6508320a4453d7bf11d25957d86c89d6fcf0ab2577e907e4272da62c9ecf1ba9b7267e4abdfc68e39df6f10284ef1870a36e91866e5adc5d82cd44341b00bcb1a97a88b3ddf28beeebae8f6baba4901331db65e43cc21b026ae10465a6ee925b50fe627e14f2fc4ecd9571d100ea6001c0832ceca90b039e95a0ff92273427020208581de8215714867255ae054ab16c61a028ef9dc8babd01600f09d1809e1d76927c4e1153a651869514b56ee4dc885ac3bf2b73399472aafaef49978d599294aa8e88977d97988f285e7c8639cbddfdbcd35246ebb971b92c9e2e8d87c40f098c13040f7ce3ed1107fc927d0db55ddc8e3de28a9570034d1888a8cb5407f3ad84498c63b9da386fa15321fb53034bd1755b7e871bde71f95ee553657b0b94eaaa1e1f64fb98e6ca1844c6be1a1042facbb9dbe9d6f781df204657c675e888b88f154022531e91f52ea2dfd72b7aa4579a3e55c224a8e9afa8b24cab4fda9b4a611d7f48b1e6e239c7034ce89ad0a65fa54aff90868eb38719af63ca1510ec4259902113de493bc75d29da0439a53ea5f6c8ae688fec22f44eb8d3c7d0e729b5a10001a18ec32ad76f02edf0436fff8aa5a2f330ae14b6ed7e75a241b950d9d0b124e6939578a4bb67da1f36275b67f983c8b159251785b05d5a6c6ea493894f06b0ce271523d91f1ec8d73599016a69850f79003dc8e1e14719b043d5c493b94eda224e173745f825da204c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
