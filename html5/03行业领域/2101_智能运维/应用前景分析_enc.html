<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3561299d0a753a8b0541bea89ef31fb7d7fd82daf0616a99fa438a7cdc13294c86346221508b473ca70ee780b4043594209b5466dafe7ecb9089793727c2edd4e25fa44f179a45d784ea3e52fa1470a3da2cf3fc5978ecb0a8f846c328e7f50da1351371996be46a48fc68aaa95981e4e72fb6112564d63e9e73feb90566fc59eb0e0160c3dda08bae40660fb6489ac5ff58ae5895d902128b973ecd4a573fbbc195f129506e6dacd3d6a9127eca9934b5874406b0e048e678930c7dc4ce270fe8642affd5fde99313929a0db0ac6ff36bdc9ac8f6eb0ffda0b2e6b0d2038df9a47fa235227a2ce9af34ae5f2d9955dc1310661b6d1b41847fc72b8f88d142b3d9f73853808c93215eff1c695a280d8084e1cb11b8074dbf9611b0c9008ad6a63d6b498b998254b0a068e37195928bbd855e7c6cf342937d85f2caccc4f96ca80b9dc51c970787b57148a174a679aa000f59986e04d51a86b4ae87a9fe469c19a5c7706ba57cc742356cfc58858e6374731e79742f605babba057522c506b02a606c8abd49d0380176f66c96b661bbaed4c44b7beb6c6ff624dc42598416836a7eb71ef8966926e1311663a4529fd19329102d5782f861e00110e3bef16ad4bf04c40c8bdd73ae393b952214fdde7e687cdf28e93d41871ad9d45bb10acd4702cb15c2ac6aa56be979a2467b6b6152a1fbf22176c247e0b75e50d7c9aaf620a6494346c32bfcbb15bbc81cdbda582a77c57d71cb28157baa201bddac54d1e58192190d4337f27835ac31616580e2e62bc0719eec20f220a41e1b198d2fed4076a1b4459a27b913a62195eb506a5a250d8f95df4a7f358ac1457d90970d5404611a04288a2f624bc749a4c4cd77fbb1a8e06c8331a4c78df634ede2d22654a13493b6a009a10dbe1a390efb33e53e9015ecf3dbae4fadeaf09b25e3a614ecf579ed1b0d2779655f2f6c19c7a759c6a484f1104d2c24598a9b2812aec3a74a20e5b4ee7d3ea7154cedcbf639cc050a528675c76b1225d4f38c3f5028e43261027cf33d7fba6304ea7b2e607c745ce010013b41b3989b83f45aaa22e3940bb5a864061025d946af3fe10886fd2fa76998598819889f0af6929cea61ffde02524b14a480c6983fb23b6f15d5ff400eacd4daeaa27221355350fa64017cdcdb903661300ed36576e8e1983b501d4a0b3edbee73ef24fa5a183ec6c1fb71fb2d0b82778351fcdc7ea2d4129a6ab0953d60d34ff7bb818ff13c7e863def3a11e4cc3800c615868e28626580ae7e63f38ac6ce61ea58f8821f44209602461ee71f4e9f658d9c5197623bd1f051702bc7a2a891a156bb54cb165aa0a860df938fd96a06ecd1f694c3e71e374049fc52a05ff545af7bcb34b67be514178f445e61edae26f65b2d264b2cc362be7074edf7a44fc39b9c95cf2fdf71821427e8cfc2667ce68b489611a56cea8b47304fd01be09641cb7cf6f58885f8d237281cfc92e4778f6192754ed9a4820568ada562a560cbea6abb54f5da3fb8f3667497757ba8ee5c54dfcd99ab7b01f5d49f639645a8e70465a98906767ac96cd93b2c49b23d9377a3278ef5b2136421bda8dccebcd69609e575c8e123b78923c3fec96cf6aab24d1d5d65af7c5452543e1ae78ce77fa21f22f95eb35c1e03bde2982dbcfdba615a200e96180d197fd8529e8c0e3a0aaf388543c9c9ef65cc723324950d57b33ec6afea872f660a14dc165ddd741b91ee0c8dbc1bbe59f63748282201faac745eec482e90739226565063382b3dab8466872e715369bec9fec6126137d9a153521e3fb7198927b57fdb5f7439edbc68ed50c4eff51e2a859180f936b6e20e4798141226a16d9849eab6dd859d221738848bc94e48e87b38b1e0b262b12680d8935395d5f9caba7d357371bc83dbd55c9e49d867d49e7a1e5dad08eda4d2ac17435e16e563bf41e2f9d422ad35c484c86aa8de4f46daa5b482a620e56f4bbb5b1a43468539048aee74b9ecfb3b87761bf13a4f1e28b052cb9691f913b664b37e226dd063d725abce0c41b35f56bbc914a41278b2a962ba94b2658456ed0243ccbfc714bd7230bfdc32fd4da48d81397327e9ed0aa87aa6139dee879ce6b6f23fea032cf249aa778d11d4a67c3a810231cbf9c6b59693db9f624bb397b1fab44264da71705f2aff3e0d7370fca2f71dba966ff86aa6614f579166d95bdeef562399c8d5c2edc1541d997f2979e1b9121d49e73c237b2a3439b63b8d4becca3c938d83d26f417a10dd56cc78641d546622d38ec39b48d85ca9b9f0b95eabfde5c104a9d0352ed4ad16b502c5baa801561f48059f53914e4cae718ddf6d4de624a379a825fe83c19acb6f09dc9fd004a9c966e8a24c818df854f685f9b6700f3295f50af12b360acddf8e048ae10a222ee3dd3038734aa75851274d3be83ddab953a2bcb4abc4364c660e73df4153888113185637e91c57424b88e39dada0955b6275e9632b76d5559bf34caa88f0fc4b97342bf0ed201c4c064c377c5a28743ed838f2213ba852fe1b65baa4a6f7d2d09fd45f5005f5c5635d1c72e2b63f0d264a49270d85743fa3dd296d1f445ccac5e7028127bb759fe34ccd7e8814fe2e28e706c9920db269fe2623a09721b25fe517ee120c42427d6876e97a55dd8a1154d8fddc9c508330e14af733da0027bfc93c21bcad8c39a9b6bfb9e67f9b267406b3981d1a57ff0c6312f0227a3e71ff977392811ad301d1e7caea53bbc436025437eebedc377ce6bd25d0054ce7aa9e2a2ead4f3a6740d9aa3dc64e52001cf0863d360b3c5017a13fc4ec67825762f53c1a49d5c6b19f4d3698fa5b55abb501d508431fb89d1648d64dad98e3d024440d8be459e0611c7d05bef14e6e1c6ff00847e472add52945d45933deaa549da9eb1db9d66878a442d75dd05bb86c4f2832b099a48f56c261eed865e6b2477e1d477fb6449bbd3e37ec5df4e1779fd6f6ff951c0ffc2a092c9cc59b1ecfdb3ab7f4e49b377e6e9b786fe5f9e1b9f89ff0775ae2e2802fe33846136a28af9ef9a825dbd97b6a55ac1d82f9754e1ccf4c231be1499f3b37656b568be153b880fe118eb508d099f26b45d87fe6430c29d7c9b4e0db6908c21fccf19e515d99bf7064f72a6572dde047161f8d819f363ec9fecdc5bbedda58b4bc5277c6eb858bf86237df70d2425f8c6664292185a17d9bf868bd1d927e25a6d735d7117b6ce63d042c91d89a193bc4b0c0f6ac63fe04fffa74b6fd0955f984b27071ce8b80b299869cbbfd9119b001042b359c2e6c380df0c7b0d54f4472793c0d440c2a489f6b7ea6a5c0976180ba8218eb4915250a31567c656a0f148fdfbe5e55fa3ae92bf33f7c73230b8a01d8b8ea118c71a41af205357e941baa0ae71c828c6f09239edd346bb00efa897ad83f01c7e26768c8f75d25bd7e85543afc3e41b00ec28445f90c5baf7d4815392cd0765a71bffe018dc2f07d3668176bc272052d099e3320ed904cb09ed5c08e308049acc65108b6c2c0ef300f0c28368938a489bf7d98e2fa2ad7da484837b422239d0224de6035713e7c66ebfac160d560679c8055bdf0dd09fa5fbdb9cc9ce1617f775659348a45fd4c7ec9923fb4ab7690c1fa92b838dab654bb41e406ffee129939e4a38ebfdc7191c96c917d7441ff1fa9a5bb2b364040824b1e934d89b60c85dc794de54497a84f36d84dc940df669e9e937f451733fae1a4f093410c907f62519374d95928d8b3a144d31c44e75886e32e58e816294e8edf9b9f38abf1da34017bc804b1e6f163a60736bf99fc0f9bad6383483ed4d74e90882383b6a894f9913dcf38e03494ffb9c23b3f6c53dd352e1605b9c8b8e2f2ba15ea0c3abe6b7da43e37ce200d7f39b7f37c5c9fedb97f551028d5b0d7b3c5557c904e5782e38e5cd842c21329849f27138267e8f295712777363604fcc01df26c66e62392f02cb5f2ec727504deeab727baa6f33dbd4cfc3bc1d4b1f06204c858fc09063b473aceee3bfb94bcdd76ed08446f6972eedb47cf1f324b25869bf77bc6308d07ec407625e39a12f722176ee60a78270edadbef1fe0ce6aa1301b44eddedf099cabab5c8a92694f4cda00f2b7fc29f167e2d3d80a3258b640d052fcde97e9ac68397dcca70a1ff74e78a538d587a22039d852048052a20b2c0f8e71c5b0a8c7f29bc299ea7e00bdc67498bda370b8d56c009f06c161c9868d39cf8e4127f7fe7f4a633b1af44082f479ae7d71ceb1ad2f7c59cdbfb8c9befdb35638873661aaa30e70f7ee23930999c38159c6f66afd719d86ed6bc4e47848dbd7b5186448ca761ccafdc2a455f1d0f7604512bb093c40044be4b18810de9c285889d697018a360a6f278c81d23488cf3da7d82a9afd78d6e9cfb3b7cd57ca55f4954b4aa394b19e4b041f1f6d23c75a809156894a90c24c0ddb56e46af9c9f99a1f2e0f745f2049d9e60d2a8da2a07ed9de8a155821309981e38267d856a95b1e74bdb8072cadf4b9a491abb030869542c40eb2604908c0691719d8d662bcf14a243fb720bbcba57eaf14f0f6fdecc8bc4a634228d7ea92d5bf01dcd05519ca5906125813d091115372598e9046e7e77a2a54896641aecef8360eb04b97632ffbb55d16beeb33800e26bdbf3a84365f46b97ad14944b471b2a7be9b026f3228c82349ee8de3184b4f215b689c60c0b9c71f4a1cff34e66abefecc15930ca723ee705717c6e3f21a8d64b67505778f446045ad8fb4910b8a44bd5e045939720171a75e0f4577ad759dde0cae825a60f6c894be46c9f2911a7c14eb4ec21994fa18139145f412865590fba21998aff639d73c010e89ead23b0b2a156625acf1ee1cbe250c80c706ba7e53db010cd1f1e6c1d387ea85edbc79e2ec08935167f43feb9a1d8eb70c166b95b3a1f3fd723b2cef2207458968e25094f6724391ce1c07b04172d199739db7c4b2be7b98716aef617c3ef7edef49c4b448279c1223bfe7846b4f83bb797f73cd422f5a233f6e40b15e4c884be1aef567afb560c0cfbc343a67351d7280c2a96e98b728c35d5f17c7bb0249603c81dfeb319983332b6c8cf70e9ddf46779a41b0d9bdea3eb1f77e4c998259198a8bc16aab3e60bbe4395b3ff63b6febae0e018c798d0915fee53442d47faa12db479ceeab1595b611ccb743e6fe4d1013d10c69b2ed276d72dd9727701ccda8e382eac9a52ac17ca525463b04b2408997781f6e8969ed866351fff7cb35131cc1d490dbb77fd62d2d5141c3cbcd6b92a401e544e9c1d3fe4822de19cad12d9a409ee2d2c237717ccb8b307de8f70cf15067cdfab2c3604ff9a333e7e0144ae4dc9b0212425dc7469f232dec2ba24cb10457ef3a0d2cd0347fd7bc4c89ed18191aff4c34a0b5eceeeb9ce8b36acfab4d9c5f4d31fb7b361dccc27588a949788b07e0a64a452c4b0b8b9679e186dd99a056e78d01e551cd4aa8a64e932fef435c643a678f06f08da274e7254c642a229a25b6753c6f8b5ee27a0253e7f9c598f4c6b0ce875c51a4952d40ad50582bffa4c184d26545dbbb861c962f1928f1627083d0464300d2df767aa3397d55153655742696570de462f4c502ac397b10ed5698e5ba8a3dba672eae1f2ddeb390f72a007db4815c617017f4f9469c5821b9f50e4a65d2ca01dfa6d82866853506639056d600132b9c7f5a0dc28e990887b6bd05ad4257076a7a0dd3981abc3cfc994a779d7978a763d2ac6ecf5faeeddfe8ce513955fe66690f87669340240e4bf802dd3f83511c9a98e918ee1fcba4fcfe0730b81f566dd634a19b87d3b028fbb0c16c2bdcbcfcd3fcc422fe87d01f8ffbfe98ca4ab31e7b3ece4d6025d064e1ca2234d3fbb8daaeff9fb37ea42df1fdf86acdddb92f9260f20579839f97be106cb313a81745691ddaf9b612515803f5cd3a2c680c2b5ec6f6bed21e1e5ce940c465275a55caf22d34270e40fa1b712c6ef6d2c4e4307b4e649fb82769263eb3d8845af31ef93e94a34d33f816015d1e7a16e857606c6e4f6800786eceb5447827a40aad5b63811e4f62aeb7b72a16a826f3f5e2a8372e1233ac5c33d9c651191c06ce516247b6819e9f76392cfca2cd97e02790631254e4a69923b18c4bfae5103951f696b58857d2bb3b0dd05f9283267a371827ffa113c089726f5fac38c3f314f0599c41f1d428711d7ded731b532ff1c0971a88bb072d62f0d19fb3d29cd8b16cd4bf6bb21da7f2aeabb601e4c486da59d4b61c8e6d71d1be4f64c1aae5e8bef97a61ccb26b1ac8be5ed6a6fed5834ec1a5dab8a5913979e33bf43309affe5dfb96100e506fe63079571a28a32a0dd25487d984ebb51a7f2929dd9e3487cf2cd4594d2b2dc1071aa542968db775efff4c97260d111883b3a316226160a6f941dbba8278994f036626a0234ae79bb0c86be9748eabcf139705fe3651e98197ff8085f40412e2d29f11c16557cc45221faa8030e195b591be651060315b97bad2fd2a55307ab16f06f6a524b201121ad9fd079c7d8e11b1893017191fcb89d8ff1fee89a100fc5ae51717fa4ecb5f14a3f9c919d17256cc5ff75a2073c8c1fd4709babd277850b5c8be556a9c70d8a6068b019bcfbb0dfcf019f5424015f9057fbf207cd1c0e4e36ceaa46988fb2393f12c6312e1f910b57b59f2e15f63821ef92648f805be9a0f8cd9b4beeb4a2e42ccb8295d5d6902df0c90cf181a8a79326bb5012cb9618fd1aed89b18ccc9e4b9abcfbedd297e0c9874ea9695addf6f9a448c0daa50ce28d855439f70964896089fe9195f34eac3e6d7704ce1b375aca68dfec6e1ecd1dcc2ac5746fd9291b96cb0e34bf9591196dc2390502e8ff3ce389680ca5184709976f5dfaebceec26ee23c290556d1151196266a41199325ffa1d11c77b06f6cb8ed8391b3c39089f2f2588d914e6e9de1f3f9124d1583e993a7d0f4b2858221e6563be53f1bb8c9b6b31e8eaf25789d72110c30b9870a6ed3cb6d0d1598eca28a5e039a1d5cb7b42ef1a3a34ba402864977e6938e5f69d366e808e8b60e615660d20663b7398e03e418b2d56b7506c2c421a80dfb3886b5eec80f0b5d608ca689f0b4b95520c292efdab9b99a07207da2be9b37d774054a50c761eb0e75fd9d0dbf254ff7c2c2f822d022c8c7c74edb948417627947471e9eb9ded7d2685d1db5418bf1b839e118a94798173748fa8f415b02e91dff90c0849b5a9359205fcd946b7bfba6f38f9d86ed1b53ae26143953d978795a6aa3249aee85159c55e6e36bc04c0c86759b3911e14850122b7ff10cfd78e06972e8faa5e9dadabfb48568df8862c69f0795242bbf6e7add053ecb11bd147c39b3df3cf1165418f6d8d32572a950249c7810045c7f736a2704c4de17cfc4adcfde6be02b0910af586e5c024f39daaa424b4f1abe12683136f5df60f13b8a7ee304c9fab88a05ed40724ac68c77fbbfe269b76f362f9605ce23322a697e329e6e2a3ced1f8212ca7ec5bb3b7031f4965f07659e0c802583c70ca4a17646bf4442c7eeaddf3ff8637ea2310c40eda2086176ce74cf2d90baffa5eb5e1f77344e47500661b37a1a83605b782075a2ba0db97f750bd7ac0f1d99e31e4f8db8b6dac2b6ab7269bce14802c566576d62eb1d0991f843a64069a332e9dbf8a9c231fcfee756753890229a3b3ca24928eda843098da3cbe56b37f8f5a4d280ecc5ab2cdf4e63f0139df02e7b51c5ab2e2c47f5c5078b7cd93686c69ed9a018141621d8dba88245cb80dd90526f4feba6d034482e96b7bef0964743d0a67159e3d0fef83ef45be0c5f3a4c27e3831d4684eb31071774bbb9fb21e954556b342f47f57a6fdf83357c4dbb6afacc85bb7dac8f12bbc329048916163d06c81e4ba171b7afafabaa4fb043d2c649fe14f0e7704de6c334f819e7f62932fd7cc56b2121c7654cb96d40ff66fce9ee5369c3925d397a04229d6d5033506a55f02c5961ae4d7e7d12c5944735516258ea8c93c47c3fa893d318da2af02fb28b76d6f34f1f92bac861e86be3435a23c5516957d75f9cddc17edd97d19046837fd06770bde04531cef96dea718fa20071239a745914a5f209a16bee229b5f64e23e63f34b469812de3cb62a37b6c101cb3bc2ca48e4be9b25c268896d77778cc897c13b685bedb5263657c3765315b524ffb00de87c16caf13199750f685fa6ede4459ba9ebe719358dfb379523f33e23dde4bccb916120e80740de6d130852f348a3ce8b9fbffc67d0e324cd13d98c5f1a9f88228444ec0f9043b8582ebe7184724714adabfd19a68db59f4f872308cdd0ca33c886200241f00a8fa1284e66a099cee72c40ec2f22d343e6f51820486dc888cea0c5393339ea1e5e08f0dbb0e5a1f9fcb84731912ea1ad098935eef12596e57ad610e9b3af1f85debc48fa5f9c29a3f40f8be3134792e61d4ea12971df6758f5042c4611869a3cf23c0cf950a39be6f2bd4e81a68292141841cea4624211231dd6644dccd2eaf3991f6fb49675a3c22a463f79df0290b3bf83e524ad161ceb93738761bab3e21504da42b8ad247f19265246ae914824564dc86c277c3360a2c4cb6a1ee8688f4d0881af7653f0ebeb01fed4a4bf9b914d3698d80daca80fc34712e19e7ce98d4eaa6fd00584132cd94221e7eb0134875222cb0fed9b9d7c87309c8949e0ca571388666a0295102aee613b90929ac5fad251d3647856a5b5b861d2837609029afeca7a835883f099486e89f6624ab8c4de4f759c6c8d2db50957a38015c13309d7f4e4fd99d1aa14f68a87efc39c7a2bbb10896a856a8790290817e14575ab32f7f92fbefca28c22a27c05675912e72353bb83c994d1b0a98cf2f430b876ec8ed242f35634997e6dc38143f63a1d9fe2c44e3de9d189b19a2a92e674530c68da0eb32558261f9938e3b77ff94b6f059f0dfe6871ab792c922c7c1c3cedd7eb0f9b24dc6af517257e92cae5754c576e8b9dd5967201118960961e2a5925f51381739cde59c063aafd8414c8ee675a5271fb1ffc24ee3ce19a627ffe67d83433349bf168d03022d6fa75a2032d843cba79399195be7d14ba178dd69cbbd168fa521aaa9624bdad6cffc8beb084ae39b137c5342285f38c1e8c040e99096c5c6282ddf82516909213785e1cdc87a5dabf3b81000a6bc2a902ebed6a25247ec4528e42a42285653954589c15d6af49c38b0933413fa6194e98410434cd6b784acff6b3d69161b5ab8bfc195566a9eee55cc10f9d316cb32b826334ba91f0dc0024fb0969ae2eba1aa7742d14141c223567f973c528401a855186309b354332149d233a7885fd4d588edf8204bcb4ce446020f5b0e03fc9eb5191d7a12b1e74409be0508218f527af3895fa85bff719a86219ef6771d9cf03bc4e0cefcc5070f06e4e7b058c21ac9a4a42d71cd14c76bea1853afc2bdd697cfbe872fed7eb2b1ca61469543515093f3e6047e1c3396a33048ed37ce14b814dfcfea33b7b00d1bf051391b2e6eac473869f5e663910c0069ca73f5ee3edad5cb01ec443d5bde7da59181dfcf2ee46b8a3adcd52fa2ad50ee9db65b06835454101e22f5955865f75d924f9cfa1e396f012efb05a5b0ff498a9058d0849e575970b6ccf1264dc39d7eea0b839f1e52ed5e141b405708541e54e334be8e9e6d897d2f61f2569405e7db105cd72eb9cef7f8a14a88daf35589245c83e41b07a0949a172543dbd8992b67b6a79cf7d77fe25c671243c3a6816e68d68c68709dd69a1498317d20daf3303c072ed8cccf02b33a2ca8d6dc51b0d28a7db6444015adc63fbee813d5cd5d1fa870121002cb69ecfe8d57ac7546dcf6835855ad524c9b67f76f1bc0782299bcd735419470b621b3f64768bbeb91643fb3863e0366df61e329bb3dc010825d9d7f129f5a39e7e28871943a74752046f6d25883fef6df2e3c2789e25e3ae2988b2ce976b4656e94478270827b1357e433704ca148f481a7d1864e5f0669879a75d16aa023e4e5646a4c3724f1dbd351c50e5bf6bf22a709594b19895c1df4c60176c4b68a465eda1d1d71f4bb67b12a5265ad8afa48d79287cf0ef4ad92432eadbe9866ba588c0fdaab25d355813de2f5a726cfb7655530a3656320c986c34f1a3e2199844c1c8eb55415270137f51a264e0121c1918660f0facdb05f04bbcb491e537f32cdf30782374094fc64b4866064e65c6d9e84d9ae7ccd6b80a575f72afcd4588c6704f4a7c4bb973d9b13a2e4c6198043832d6a488b125c4dd8c5824b9fb47d7f1db0cdc319cc4042c3b6bf1ab65ed32f10ff404faae5e36065fa9f16919f105fbae00204ddc782de21142fb3e76defa4cca214fb8d3d2570e3c3f3558d071e4ff63507f67b337f7e2cd6c9f5bbf3f884d36fce8f7fdba5c668247c4ca0cced16ad853e745672acb80d69155cdbb5d90dbdb30fadabb7c36072b103d83520fbc9ded54b4f035ea06ddfe776b348109f5f7026f1975a292c48a7330b721f742842a81e66ac","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
