<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"950a06c13c3cb3f85cfac8eb405a7e4d3b0f974dccd58915c8ceea0922546466f1262a06300925326e92db92999827e6766194b268c23020ec0699e4134ad499b2c12973b31637cfd4b3fcddc1000193d5d7bf739ba905a1caf828433cf7d8caf0b7bff2f1d9a9a3bb6acafb4db90eaf90b7b904ad8124c0966e6ace95b63ea198173aa624a7d86f80b6fc1374f607d88a8c6d53ef347727991c5be38fbec95e14b36111c3db3947453e6cfa03c1a977ab7233df88d92b25fcf3ca89a9c222fdeea9768e8ef3a878a93d0588cc7478fa2b6c3181aeb26bb9d9279f656cc9783d62263fe8daa43dbcad520fc2269f9f2932e71b93c9c0efeafef9c05d175a4ed0814711d76a39f2641570daa8bf7f76fc226294a6d40e7e1d49c4b24382771cbacf069e548faaef357e2dfa7d4ae6f3060862fb8dc1415eb2c92ceb14e1668d5562312f61f52568feb219ba1a60f6ff962fbdb8ab0ef39d1239037e963c6e730b76df0cb50ed361b9aa599c13a814818923ea5bcca51c0692e76c2c4b3d01260983f743a97c53adbb11075c9819973161ad7a7d4819baf3800dd0e066ae6a682f55d181a9848d26929e976fdd7a8d58507cf9fadfd0dc9698277f0877786d67de4349c83373bdfb1916670c07d66eea1953d69f21310f02d8bca2f6dabdb0a6cbdd4f8a4d3eaa84ccccf563fd2de70cc046aed4e655a2530a03343a7797322feaefb4530d2bcfc8e171b4face1458994db4e2e3cdcb7ca17f5d9937a035eec4d4098b23f9b2b907e352deeaace07131e00b921e3d75d9eef8a94bf0247b6a234b56b41cddb65465afdb32ee85481c248983324e8748c648793edee1d394871c82506fbb69b196a62ab07214062fd26ff99fc9c1deafcb2baca39606588bd187f93a9c07f9ceeaee90c215a0d552ead3a37711af6bd9033097959613805eebc811494111498738af8df0410def51869c2257a9cb46870cbc70c799d75e5a0ab5a2f454bf71c791376f97cd4ba1ef8ca35bbae53b36549c7e679cf2539cfe1f60a540bc7778750aea4be9d4eb4f535603966140fc3204cd71c891eba233e7952460ef97cf543f0de69d731538fc5b756eec9b3b2b1627f5dcda511065c7d3c26c9d3ee54ca38ec1bf485fc441d619069122886c7d4954fac7eca819c22ed0382a5a15413986dc186cbd0d6e0af00ed4ab6072acf47776fcef57ae235b09348a1509bbd721492f1eac2c86dce8ca4fe60f253a6e467858d805a1c747ad21b93a37921680e09420af486abcbfd5b4223fac8b09ba1f8ae0bd873229bba0fa8bb8aad11dc4a3808e8f5f87807e2883d583547e87e5e5af8b19a7eb5347c384bb1c6a0d95f85247e546a2fd5438c83ce96c0eeb25776a18e014f86d27e96984d57fca226c51c2cee6e9bc7e1a7af9544d23e4c24820be65cbc939c264c05a89b45b314cb2a824a918319045142b785e91bf182031a7d901398278c4de6f0f00c8ef51c4851e09595152e9e5859bd893d00bdc21a955ca457cd88cbde645a2765d9b14060bd8ddbbcdf2b286fe3c9d5a102a76d84eac832d75b5e84b8642be3b5c00653c0d8d599f0e3c6cee8c23368ad8d3f28c669c46b966947f7f950c51a2b42799241260abb8f2ca365255be3606eb9cc56895229761e39400d7eea555616d81540d6d85ae4a0f90d0427e1310595004c22e61d7faf676a5778add5592d9bc8f30fc1bedfed61b60440f0afb7a17e33897bac4e4e28051da89a5c51d6c824d822a2e74dfe7313b605c1c04c8f28f6c816a30e6e684d336ba1a6a5e5d24a622c48e597e2f0fa077864a0174f24b4a55f2f8142d7e68800e7294475d16119f5db4c235bd3bc928004b75f9f3d602968593388bd0d1c8e85e2ca0c2c520fc4b3dec2229aeb190c33bbcc4f15034ecbab894efc87e7a1a88ec0363ce8ca284e05fa76c352d4f3df0a0bbad5e57421c7bb74628f25e5bbbad13c7788f012c9254e8f17560888b953df984defd0e67b21012d1a34066d9045746a17f470b6c1cc513cb3fd8c489ade361d56fed2aea20fb76209de9e919c2ee3cfbee846408ce6aa237262cacf0618f002cb3c51ef53da7f1176d1a637c7880bec9813ee8f799fc6fc868d8f9e221c938f7be6026aa72a66d126ece3f0abab9a1001beb9f9f433e1dbf09683df849c7864fa5643f704e7827dc36120fbe2ec53063d7a16173d42d0a2325961463877560713233c36753148b9e18d255b771da71750ab8767cdd398d8f9253ee4f0bd0d558f11e230e606d419e3835d791c37b130b7e05cf30f3c327b266296a159f12562b4218430cdc3687095693e7ff1f5eee1444a901bae64355ec8b88bd4f583502c79ce3da4fe4bbfb9d3e011531a12e5d612cb19e516c904d2e13b5c0bb2866d27d803dd3e6f7ae87e58fac28cd02c0b198be3b08c45b8783d3383e173ee86952b2d815410b6296a0809f21a82ed3c3203e16be72218b15c7f4717fdae2dffdc3a30b61051aac8e9f7b36221887dd515e72bf6e3a3bf6cdc9f1ac600c535c545dde29860bd984f06d76c0f187eacfbdfc5d324a6cf335c550aa769643e3f0c53ab9a4fbc64840659c53204ea7cd1d5937157fb950fbe283ac7c635713db4e7bf1868a746dd26443c65097d90a6e40c70874eb7c1c40f066939e5070ec3b96c975650f71811373a8bb14924807f8137ac679a5c8bc33bd55b57b297eda0edfd30422af1a6204047c0c7e3b8098edef7438e8bf7ce695b0926652e25cc40ba267c809ee03256cf5519bd4afb7742b4321a47a6d6941bc88242da758769c0ba732097808cbf78258ac07226c9abd520503973af1bd9381ae1f1ba70a2581d341665621304d65070c1530574969e1c71e5db05d0fb44425d376c40232a08507eb51948b95d6c7aa5ed1a51fbc1046d8a1a4836e730a095c8dcefbb16369c19747c0af7c0a4923cf3a8bc13a0cdf3f6a97bca958791780677ab5dcbc57ba5f9c17f2052ec512c6ad97527e922266b6882b9f34be1064707e9342346982c93e1d6fbc615df868f62a93bdab52d95793ce1ed3def7bd5fb85e2d3c64b29ce5640a50f9f1170ad4c3a56a9680376cb9e0e8eca4cde8ac7ddc74e0d1e52acf894d1f11abcd10e029e1b55abcb9898dad8bd3fd89ed865a31a34a48c6d56174e55323157f299d4f6444dae85295b0c681d2dbf9ed26f4fd92b529ef407e2134a10b595389fde60327762957ac6b12ab45c1d36b6caab42098c273df054b9bb4507d28985d65db49ca5e801c3793f6a5930dfb3c4baf98c1b4c25d2f61115a91f7d498a715c939af9f75c865f8884269b57cb47edd36e4faf2fd92d806648679fd90c123dfa41ae8be59fb717bd15e6323591ae4a20c67b7d347ce55fb74db2feb01427a1d8fea06863b7b53be98c19d4001a85edafced4e0ec7154c64abbeee10038f54a161faf9cac65fee2e29ff9d8afefb6540a264627b2227c6e62553c3a27523c3aa8e30ce46431347277321e193fd58fb2f1cdd672eb179a03cf543b547550e246e84ce6d0fb8385feeb8d46a549d5a54baf0046da67e79c3157cf08564d0d7941471345f46b23cb63600ea4bb5712cc4c896578d56db0c8e5c288c7524f13a7f2fb0b8973e58d66de9b4eb4796ac340c2aeabd77a29b6598f17cd47044a651c48362d8c2565a6b1c116d074aa485a7327100c7ee844fd63e27a6ae97d8a05e7d6272661060d422f57b6b87958b028f2bc981ea362025d53c8425939100c31f3e4f17b989933c64f9d517bdc619762a76ab75ce127fdbd7ffa783ab6d6dba1fd71a8054b36f77114eda9464f4dac15245a51c0b991ab0e9c2f4429e6462838844ce62941fec382939ac0f1a949ddfa4c68025b21505cd3aeb64193d32a135b0ce39b6e4e70f60b081b98e4c08a2e0d9e489524f5d1b93d32d5b6e573577e6a053b24768d9648c12922bb14d198310cee6bdd14276d1e54b1628d6fbf42ec512639e5a2a40d9c11047470bd7869d69ac500386dcf8d1807e28b41811536e4ddc8028022b4622ceee16ad052aa3d0fdf2e0c90065b2d8fa952d16906bf9fde753301b3ca6a385a9ad9a9eefb25d73494e12ca765da6f858a9e54cec8cf26234539098dca0e88451c8631e27ebbc4c6b2d139e73e51737323022e2568f1f5cd6250871ed8b0111fc8f57854378c2403a492a9c6ad9caab4af5b430e3d8af8da1114c02b8083c9db93400d588ab139bd0ce20cfa2809ccbbacc283dbc37f4eb4c86de665eee29e1cd08969ade094bd9d892111e92cff0a34acb52b4515553edd39605faac2520b2a4bb8b3b676e549675e0ea02372ed467dfb06eae5f86fee76f36fd0e7b469a3e4d4ce94d30483e81eddebe1dac88a36ccdf6d3888e879862f8799c1448fd89664b3881744a14b066776a782bedde4de614875cf15a73b588f4cab2ac8a4fbc27ff79b82bf7a46f1db5465670747ac5070be0648367481400fc12d02d1c3d6c750090e329ce07e532d36190be3c0619ebe1be5fad0c5109f182cddfb135c4198a6275e62404a2f3da1edbc73948f46845f2f5196acf9064d53608cf20cccc860e87590ec35c9b5f35d532f10a81a979478a32422e3c4af26201b007c1fd65bb2650aaa107059f067e2c326f0763028577a7f74ea44fa3541707bdc5ddfaf563fb2a7202712b8dd69e8fa2c4eea780b8829584cd73e5d8a05344adf4b50c401a63216f898c5d89c69da0574fe39285c6269b6e0b5972da0f0f6bccb4c7160941e15bee5d76d8099535ea09fb49403a303065e882b9599c32b2d18c2deee00610130077249d0badfcb5bbe63d7840f2706953ec345a242fcb587447fc3f9a790cb2bdfff66e3507b565b2f16ef6a245c74c8c805ab048fecc052c591f5a47e697f34ec20d03de657042845b0bfa6c1d3ce110193485b79708bdaa8dd5f398c90b6566a035ce323c08e4b9831b705b10581985642160e39413ce218a158ac8eddcf8d8c55e844af0e1bbfa23a84a4350fe12f805797ea1217ac98f406ada1199044b6dad790d3986abe4aa5fad7a720d6a0641a96fe97b05d207052da64ea3e5c80e9332fd6588f24a54b2f142d4040f883d7a644fbbdb8dac447c2e8a49c7d05e8601f1ba4edfa0b7264331f29660806f5908ea50dc9fbac5c80d64cf6f222b741401aeb7c805803b2a5b2d581ed936c8450df440bb7b51bdf5f7d1609ac6996763b712abd1c057cc9e72b587cbb3ddb9efa63baa47e5d437d06d76818b922803df37754b7e3ac0e2dbe40c6fd251c1a22b8357407435159a306ecccc68b63477b1933cf8dc7cf14bc05ed34a5cd4f5757ac7c826d54c86ba01271f2cbd786c199710e0d1513c8c881e78faa382a0b95e3ba23af8192de3bce700720c1c5f2680e1a4072f316868f3f8d32865674d0defca42adbaead41059aa1a215ecb8159a8db5ccf275d60e858089c85af440269e7cc877ad0c15da2d2bd7b37f7a92940f93beb9a5dfac6b00589cd0938d0d48279aa84f1940ac29baf0c392864be527653689723c26f0297af90da58a561a88fd758f6b0842bf3588fbd7194092e762843dbfb86c522545d0c399ac285e42301d670606a48890f47be42308e769d7d9bb16f8686b7ab813707adf8780a4172b2442e8e4c06141270853f2b84324034555c6088cee99f9ab2223428937502a1a4156596edc6d5e1181cd2ae2113627fc8c1e47829e2bb9de42bb1c6a48c08e3bb129372db9f8fd5df37f3fcb8bc26366bc68e403becf7cf7a95f761fcfb7fb137b70fb25c89f881276511be40ea635843df35a6c9dab369874aa1f8cc3458cefb6bcee25f53aa8ecf3e694909c669d3258ead5484006e4adbecfba28867d7a98850399e8f7a2527aac0394879348ecde32ca4e07bbeeb0c379e9abf1c9cc6935ae93ef44bf37de5987ac707ac6c50c3a478ea9d5543c11c571c84aab0785257efcc3c4e1cfd367e8bab581365b4598577ab7f823f5550e7e09cd368fab8b559337ade4aebc8fda994e77c86a32359957fb9c42f03c92d239a188e65779b10079f0308e7086b4e1503fb2b0003c3e5c4abb529175cde533f9387c6a314808819c373499a039c0e2f262fe288e753df125f95f15396d852639cb8a85a9667e2761ff5a24f3a2ad69963092019fe258351f0a39d9c54aef0e59f92e5e67b71168b2699fc3479df148c8786f8c767512c6e03b4bb491c7792ef4f6bf14760c0dba04961e253d10a8d8635c46e79f9c9c12739f7065ac37884b3884e6a5599424136355df11eb40a336be189e23bd5f8866ae91a61bb6ac1c956d25ee687edd28a766e015792ee9990f428de2507e9d6d31a23ef0836a44591cca3781c54394c174d7509dd7a5daae2f27cec14301c133331d7532df5171f4855d64fed274e1236885ce70220448a158de33a24de9c1447783de5b38f8a452f3fc72fd889e45d18de8832d10a5303cef1de536397162826f2bbec2a291c1c53a3b1bb4ad5876441c963bda18919e40153571742d7ab499cf9119a15f1059498b735b641f52d8cdcfffd2f0f55fb6252925b072f1b6feb7cc4850e7c3d7050add86b91c99ee483d5a43c0a58bbb0745363ee4fe80b09b6b58a9725df3b7cbb131f8049be4e449d7df90a6ec4c94dc288074c58d06f46ae5a2915c750a167f7e33e77b02fb3db72d88840f8c286176d06603b4f71eaf3d3eae559fe20e8668b38cc242d948208e7563d53f5f94c87a3a226e1a1cf02c003db7271762c2e3e3e6a44bfef02fa1467c5978d7b4d0ba73a64e499c51ce5e96f23832b4f769113b25869536b20c45fac6e324e366ba67879a42a39d183fe359d40ac18e9b90ea45ad38bbac1ba6396a4fc869767cfffd0c9bb4e8a8b4c3b5a18d2f28b77116376b8b7cf65374eb1ceeda6563bda0948533f0b203a97e76ead201817e99e294c8a55ca051e0d50537ad3817e47eae8b417dc446c2a9b9283f1fe253060729093487c393d5afe4fccd85833092b45fb00dccea556d47ff5fddbae32df6085a91a5f55aa4b820bdc79f5412e76c67edff97c45d266c6b4439c2c8c89df2b6ab09dfdfdb679d723b2909e8a7625129ed2a8d0d3ac198ea24372d5db428304c07205ec1c8b628721029d78a93047c4391c771610446a5466ba9db4516c9641bdc90eca4d8ce44693c3ddf010be9468d4c306ba4f02717e3f6cf15e7e0b2bdf467f92a0ec74f40f0842ea97020d47e414580ede02b6c4a501f88975670ae2d7e6318a0bef931b42693def84974f1f8719ebcae4541d74ed1611281df8c33904e08f50d1bf06dcc6049d091b3362f547dce672c762367a38c45bb1d8687f9373d763d84dc03fca7fcfcd01a13d8b788ffc6a3aa6288f3670c52fbed5a04a8ba77abbd2d5f9a7e0408ef92482fdb35e39c074e163359e47aac0f141e2d152b866511667ef376454e3d743fd05f5f050480aa72665c0c181a659c76a4c9b1c57083c0bee803aa72ee49b1fc9aaa9bbadcef3b1df61a27004912b497553360aba653edbc54a26b004974b680e2d3431ee364bf0c8fee65cca95091b7dc1d5711e5cfea40d45ee527b8d694f204cfc079e67fc798f0d77aa0811a7bfcec229fb56311ac42f71a56f03fb2a797862ec182568f7989c4d46059e46c1bf8c0ea2ecdb4f3731c7ada096f633acd2075e171ccd70c27190794d8cfd635bc00bae4fbe74aeed80cef40663315925fd3c1a7b6922bdc5bacff9af285d95a50b1317c051bf83145217068595751006f9c44948d7281daea2b4cc7d0c0bdf5fd3d7806b90db8fbe649cdfe3aec8bfc1e054e3b75c63502c377764e7ed18e148dc973c2f181b5da7e4f5f6a512d13df87bd9234453a88502ed053f4e33d8dddfcbb4e6ed994ff4a7354f181489db3ef2a3901eaaf965f88e5bfba79599529978b1eaf15ff90ad158857bd279bd68bf71157cea43d889ffa2c4884238504b37a9d154622a08d81cebd5c4322cb1e67ec02be0b26b8c00a21ada6f993a07b152d5ed56f55563f794ed70c532df42f80add4bb3335a7709b98fbcc90ce1bf3287d6708ff5a51818db8c2f8962d09bbbb0ae6288fc450e067b0eb753c9907de80a26523da0b151c3f574ad81ed099624a1537894327e0016971c7c6648a94d165f97cc857fc6a4ae96c188c02475bdd151a49b40b259f35e908d4c5f90b34cb18dd99afd1901494a0652b41ea2fe9d5a9dac4de1690fd87c8be4b629b674ca3ea758bee8c5057df9bf700be30667abb5094ccc33141c32afd0c86fea50c565df117b56b35808962a189125329e7504b8d102658420698d2382eb69afdf9fae7adad75da1faf5de37d7aca32525cdeedf7ccb0c6840003bb45ad00cef9b1ae0f9746a34f7e6ea2e49bc2516d259f4c7c6e7a24a94c48e1d01343c8555329a3b5219b9ffc12bc761d2319e5fbf35f380317ff6d732453f59ef5223554f3a9cec766bacdbd263de8e1ee16d5da3f7e43669734614281935cad96000011bda05c08ac27d08a459627521f88ec73a6c61f2753d820031fe7370c8b074b994bd546eb7673130fbef3f90a60f9f4398dc015bde83367fa2ec5610790040f39768db9cbca97e655562a4d2b1dd42e16e8dea1ea061f8ece52ed780ef1886073a8780cba3bcabc4a5456616f663312866dd39dbe40708ced318f1b63552acf7761f7653dce1d7bc1b5a81ed5bbafc229bfa7ef646dd08973605d3f26080a08d0d0099307e1466a8a1c7dccb2989b66a982c5c5ee3908a2721213b517878325be69411a997114459a176d83c5ceb18c7a3fc9573c055039833eb3a3c82210faa9b107f27c73e6b09a69c78ba9eac8a169976959fd926e9d5de2d90f2601262db2b341709303b2e75329d5f5ef562f565ad9ba9f491026b394ee03f7fb4e41243dea3819c68dc75756e06a49e720a216d7eb14c08095eca3d245471cf9c04af96a8a19a12fcafb30c4f0fba78d665bbb0a20437d25642044fa30ea3c29efda031bf801fd33b1024e15ee90d5991174a2010030f5ec4ce1a9e01f34cab0c445de756c90706210606e6637c89eda5362f4d5d4fcfce276b6637582a5eb30e3d6aca247623ba427e27bcf4909fd6ef311a4948fe1d09cceafd69efd80ac3ce2a94c47d4b65121be4b4719fe8a58e468b224efdf2c60487361e73937ad2aac95382fc46077aeae12f498757e22bfc8cd8a8173702b40723105a6cd99b04592483d5222d0623e8659691fc616e57670f82dc52bf56fe0f15756718a63fbc91374b070b7cc1650f9dcff9522e28026dae105dad5cd1c51f4c72faff06592970053b64f28f5b2facd80e49074bbecf4149a42a6c825b1beffd2b1d36345f52bb3ebb53c33a230f1ba5ec387bd0c48c7ad040fbc564263534fa8ee7de71509ac7e0cdaed289ec6abd04eb76257cb3deef6907664871e043cfbcc05e64b3bdb4200260584aef25dd5a981b9bbd5ee982611949ad1c76637937bb2656815743c346d716469fe77dc46cca0d24ff4751ec9a907c0d4c171a44fdadd3e822d7dc90bd4cd22a421ca21861cd7662cacdced347c8ebef067aa4409535db03fa1da2d081dd3f10bf420277e5fef41b13ac13c4a9362bb35fce26d3d47bc34119e479fbb5dc4f1fc41804397ad54e11fe32f5878758109762c95c7527efd01113d4f8332bd4aea07e2ba4dc300a38cfc7911caec562ec80bddc3463e97a487b49e0478816bca719c46f883869051d39204f08cc05eae9d224bfe47183d5a2cdef94f69ba87221294970001ce1ca491a6adf7cdda94dd014182a66de23384e96206260b0c481c7f65ec2a73203c0fa2a72ff01d026e959971050c6a0a83d0cb5428d8b452da44748bfd93bbab5f262e21f37672d6864d00cc004367dade31d094d22276e5bde5a6c253eda3fb15ca5018ca2e2315673510091a3d6eae3094014a34e9907d118b06b64e58a078b8cc95432e8bdb20db39386fd7950297da69ce97f6db8a954ae5dcdf15df6fa88bb45cc1c5d19506519f3afd88ee9c9468691498106bac49a81d4e89953180b13ad96990732313dbdd884e2afeedff5c1e821b1199494aca2ff016127213776c37b6a758acea65313ec87ce997b05bb49a6702ebcd0b05130dd3130bcbf7eaf6c5ab95751eb0bc7f1ee36cf7bc885ca121a80620729a926a1348ad9f5d8a33e1c8956c8f83eadacc47a3d9fed229811c666feb6695bdb1a2e9655d5504b7fdcf9546e5b2fabcb706f8261fad38ed796d06e077d662595782c5400d98b9fa58f40a1b0493d3cb099f11d0bf8b2bb452606704e2945c0a38098a90a3e95db2e844cc046b0959d03e673868dd978f6ee4c1353cf0bfc9ae8603e97f46f903dd4ea58874baabadf6a49b9ca1d05b4fc65eaf09d7ca86efeb5d53a1d64259836deb203794ff21c67ae6ca44472b4ec11de692a41c7e1f8dd8333b58dc40662e3748fb6409088c65097549c06d72301dc18f58d2d55e893fb809bf9526cb7bec52e0121f8ed09dd82621b3950263f13609c3424892caa974d22e481b7462c9ec186dcd7b69c93fa738052144b46639b8014cc7cb4befdff948af857b65ff13f4d70fc889763ade18ed46fd2b9ba896503be6bca82363964b6280d243d9596fc778e0945a84d633aa02fd74d3c4dac2f9f1da8a657cb8145d2179ee5ea402615857d78804e80def16d9c5165e3b000009e457d0f36763a6a60fcbd8c18dc18b5b26d61c32017ff42868dbf25831b0b5732308962c02414dc100a668ac3d0ece4f14acdc43c5d70b4d0255283ccf7697c9943313c12bf10ff9c54ec50d2aff2e0b8a9b06c3bf861bbd8d7406e69d3c21f458f584fce5325e7c731834f41e5f6847b7785efd0cd5b2672f2b9433d5b40db3719b1e0e69111c5797d2d152ec4e2e632b4c7cbec2b2c6815bd19c6df0674bfe2daecfac0dc27460f4abfd2d7e669cb0d9041fe4aa59eb830bf304dff5298c4553d33479fbacfb3b0846418b0373251dc381d015db9bcb8483a76f2c680b2c62a9491f51bf9f21f4fdb79f5ca30a9a35f370d4528f9462cc1d53662c769457f185a3cc31517fc7f681b8c5516ac8c8c84faa464cac0e9a7df7372134548ac9b62dc622ba5878ac1df0e612ca359745b24a3553ef8958965a557af1a112506503adc1bacb0b7db7727a2dcaca498d348a7fcb755ea2e4043421796cd922c4fbeff92ecb3fffebc6004bcd85a7dfa021ebbe4932a509448aea65a815f7d95e5ee6521258801f05800e4447277095655eec601ec08da89418efa9ac5b38405b3e1445c0503fce9210476d1dc04f52c6a96ad9a346526fe7ed54603ac8828e408767e9d6b8884d0501e78ebc4f26354cd78fe638e49f64fc562f5eb5a9cab205291c395e09ae05c7da01f291bae23f94e8d66cb1477471c68217a4bd7bae60ca74f41f0cfb7b8f80f5cb3c51286c74b0d482df8aa0504b710eecb8858a21b29b84c772722bcc87666f0bfc36b9039ccddc0562cfd7ce720555cd6eaf559dfefe87d03d2f1b519333f3c717103da871d4c4b0c37366d0767bae3f709d3c66abf93e29a60cf4e930fa725e819d9ef8405ed4f0c68965a8bc6a8bf8ae1a7b4df93307ce3a8240cfe35edd858c35835b586d25debb12513b4692261acc4d240e22fc7ffc77821b5560c792ae9eb3ba3315916da4c4e51e348f326c7fc7833db07b733e5adb43146d3223462f494bc72fc34ef7fe60c71f0a97cc765e8b4458e7d27c9a1e30c34a8d010c7cf5e74df5f80f04d3b54703eb37eaaa9ce2d9e1285dc485590bf54aa9dcf4e574560969853843d020ee84bb7ca59281cb49a269a1d49fc16173e54dc6724426219c58bc49a3be061373c0ebdcc4e731d78f7dfe6a1e2c911851b13e15a8db3d1d8b012803191b727a5a66f4e8893394b50c52bb7797adec13cf2193444c0d587adffa32d802b82c41c06ab622744aa25ee5f6e79a4eb81ddb83efd204d807e4da76c78dae9fd197383fa1a1eaeb112e7c4736f9ce0176c9122694cbe1b400fd635a2497b8471c42d18cbc5dc4e635b3e7bb80e22b13086f2810d51bb2250b8afed499ec60e56d63cdc8d558dbf4f0019c2ee3ae8dc7b148de67a23c93e5b0a258686447861758618a46ce34f5af32bcf0603c9debde058bacc78c8d50c68ae3d696d69b7cb23262018f509ee2f8c7ebafc3eb572961e7c3f739a8b9ac6731161abc87da68368004cce1ead3fda90d21a98dbc3a3c8113d5eacc8c3f137fdbc1e5a51b999baa88d0a401ba7b203ef51e150003532e193d53fac60e240f592564318c67d75b22cf70c690aa96974b776532c01b5c9e087979b7c5dd805f78c565cc994478c7ffb5567d18769f327c788c9e65141dee295d282bf4bc273c89291657ab27d735611bccd3848ef69b4aba2bf1dc888fd07410def12a57de0bbab7ed93dec4fa6794ae0add2c52dc82d541a849b3fe5cf4716f1aa537c8f71407d2ee28cac2f7c6cdb6f8c59b6748b544c40f78474b5693dec47072e8704f3b9f3fe619a29ce33c74de23608266a74fc4f1cf69b43be1ca5fc1b9621c4b20b3d18f61546945b7d4f0b6eb83696136bd6d82ba6293ed73b0e95d1dafcf5a921bc8108d5f3ff298263b2b2a80de524379d78f27f36f0716a5c87128d4a526e26c0a89fc0a7309d6f18020e9f8c2cd5e7f453e6dfdc220d3fdbd1d2ada0d672be361c649e04e8bde225e6688cae8bab1e759dead970946bb7a2b1a2b4a68994d5d6e31b712237043441f4fbe3825e18494e7b84690269b9cb545b2ad9e90cc208093bcba0e2bcf08bfb4bbd2b886c8344e58104f71cfc6501db7dda65ca6583040924af98d2210c06e80da5e20e51a1c98e26cdfa472baa94cf74feab09b071c5d5afdbec75ae26fb3c64c988851862580412358545eacf98a061bf19ae6513e59b108d751ebd45b2318383213e41ffe40027684484069b0a05594673afe9d08ca639ed5f4879f7f2c7590086767db6f58b9b37de58597c1cc763441de430b6a55253cd934c2c82f44de3a6cce39c1e247632c3769a477d482ac3870f8ca0fbc79cce93ff5c557f6afff719b97ba595a070ddbaf6c1bfc3bbee4cc9db99654849bf8253412ea57ac8e08a94cbcdcd01f45e56b909f1e30da97b1b5227135c1091cf7ce0e643028cbd013d62d59efb3a3c20a54c194defa275da68fd2163638c0cf375f57712aeaa9a128fe168603be0add31d85c88ebd7eed7078b8e811b592e1e78e7d3733a490e13d1ae93f3932df9015fda83cfa18d8366dec22cb3b658950c8e44206b81153138d03dfcf03b11b57081822f46bdcc610a6b66d2f2d01b57ccbbd2241e40ba5154044f254a007cd1b8f2a5f891a88ba6eb637f007f521469e4ea6eef52cd7705c928a08bee859da1522c04f10f231d4601347b0c23101ead2ca54c7887d79cc3c52f89a3a701873e0c3c29d568d590b2a711b01f792c62807417e67de07e2a9bd185bb7dbce104dde58bf57655458b27acfa3de699cc785fb31d58a8c85dbcd68b0dd49ed781c567b8f52eea329f25631dee72551438db3741fb254e82cbd7f400e69421afc4406cfbeb2dcf8ce4eae3d91be7031e90f7eb0c18d1b0101681f911553cfad8eeb7f2f7f148301c87ec390c158b4eac037df9aa92c22a7f325fb29b3e02fda88cbafc2d024e159d3e7a5d7cbc2f0ec211cf7bf1c2b2ddc3ec45eb330022f8c229a2485692f4126675a527f78834d85aa578071ebebe0618a4fbda4851d9329c74badff997cbd8ab4096ae111b01df981fbc3b8d12e7aa80ff7bfa48738d6a722c60f39e6f900d5187a94b3b82f7b143a5a8bf18fc9ec788e8e092da66f68765564f1adf66a0f5d0fff69ac0aec6acea466471613a3db091a056fb8b5243f531636db3d8260c3810713865a80da80e06d7d948dd4c24f0eba5b1d5aee20dcfbbdfa66838ed63142943992748d09942fa7a5efd570b44d3a239e1322bb73b30a0538708ce23f6a28bfb134242104b423b8018568be2dec4e900e8921bd2026e17c638eae35fef51024b7929afad4508c6c54010a280ea41fb6dddf3081eacf9fe805c2227fc5096f890e279650938bfe29710b05bdd3593061082ac07f3da7d2ea7f1ee0c05aa152a9a919157a281279e6d71a2f84a16907db0e767891f49cd58cc6394fc7d549864d76a139b51f5984e91fc9f788eff63b796d6b62f69adc1d4535999b10b1bb49310c151c0b966e4eb837fcc55396b086770358806211323d391239ffcc6cf8deaa8549d60264dbe763b332936fc33fd7a9de463abd7cd0efe6e306219c5aeabe425a7de39af6a6fd5ab4b618c7f2fac8bb66d3db651f28070e38683fa560973a8d73ad5edfea96e6052383da9cb8c467900d20e94e3f929e99dac97d9de0b414634e140933dbf2162f94b634b8ab19065152e8983094e722f889cdaa3c894b8ffeea37974cc0c8c0e5b98d9f565027586b3be3f1da35717014ec9696698ea4ab273ce731db1ebb18b3d3684153dcf56653337a973a687701016c43e3aacc9f35c71a2f61a9d979376bd9eeeeb264f5c2131f13115077de90771f928a86eabdedfaba25b58bca3e0e735c1562f1bc06cb668b7e462f0e7bb887993419d5cc31e7307d5d5db391a0cc1f78453f861ebc0845f88fa0d6c1ec53292998e3325b621a1ff9eb89ac2bb35f97ba81fd94f4f9525824474eb5c8683c1fd00fe809c23bd370adbf461010b2d5ed71698390a431135d74a7d1d41d78cbafd4ad0a758b4271d704614811d7f3cf9c9b8017304c2724df795ed8aee9207d9651feb87ed7cf34535ff063f6fa739535501d8d40b3ca92e0bf9ce0f0fb18444cccb0bd87dce495f0eb759a2027e97017921b6eb67f1d4fa746bb17d2d412d9754bc22857db5ff9993d1852d6b8820c04265f83005c3e8ed07d7ff1251a93bdd34c937e91b3bb0a9a44a89b72f72f91f0fa804be7b36194c66617503066fdce6625d5be2c7f377fab7d096df5965016d2100534ba145b07e30421d50ba001ca2874f7ef7e3bab72a6a3fcb6d2ed55f4c6968dca024a6fe56bc3b811955c57ba03966956121e31dbce9ba70b20f6cbe7b24068963de667c19bca4684fec0498e78172a471fa43ea7ac7290a2e456a8849901bcebf3d6db043e03ec946d719617fcb9c38f48388d92f00c4aa2df13ceb278be0edfb85ada031f95ca02a96e99d9839cf6f2f95014a97be8263d29e79718c5fdc6274c768892d25f60df93bcba174d9b7c9c05c9e51cc8f289d008ef5fd919f2f1a928f4b22b484533e1634b08c31da9ea2d2d2c6fea46d93941dea523d940b1a568c6486ee86ce0d623bd3e83c86d3a27b6c035ffb736df1b34751ff2dafc79ea6de70c6da993f21c9b914e655ef1720105a506eeee600d0e91cb2ef68ba11b4d8b5a5ed29b5ee7f462846c75c1632bb79526cb7a6de725824a629a78ea89f27c3b4a739a7645c847ab03580dd0893b8aeb523a33471267a689573ab8a1a9f8628591cc6af7c7beb8fc0861f1376a23b92353e10ffa1f92905c7541b4ae138f334c03d3bdd432a4fff69baa9b11dd7b51163e7e389e78360e5a9063cbc6b278927e1e32da09100be4ffa63901185fa4874c928ad62a907a9e619854b63cdfa9fc23954c49d8c110b2c31c5065f573369b9530734ec90e5d4578114b49a6a956cd502fe98f88cbb50ef3ea00a39dd3220c0ee66be2c4533adacdeb536ffb121582d9116fb7e0082051fa21cf9caa27007d95f37e52087f13aa94b80ffd70007214d886c7f9f1448cde04b0b42baffc3ad99dbf451a4d912aef20df1c725a0b073cfb76929b1e58","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
