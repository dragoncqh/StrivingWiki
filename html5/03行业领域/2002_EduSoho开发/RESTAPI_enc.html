<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"95d0dc707a242a74bd7c1f1bea20bc38a85d0aabb4afbfc3b631607f13bc4c77faee702366e38d135eb213f7d0acbab6a229496bba9995d271793d1699ef329958e200b56b371ef9754c7aaf798a5f3b083d90180f7554d8a5d393a8d531a96c3fb09d662389f3dd5f89f43f64159159ce112122967a670c70c0044a16cc4747de2a768435328687720d7c895dd5e60f4abc4073e7ac63d5be2c0135bc7327a6546ebbc7e915372c559a9bc919f8adab4d2310d71f2c1793162d28e041c955af05c68e3c9d1c385bbd2c22237ebf505cab35bfa18b7d15dc55ac5f74efc45671b3e60d1f1344e778912dc8feeba8adbc3fbf330643b67e878f44b051fbd6a96cca2023e6ae8d5292a351f3827a584857a7ca671eb20e64ceb9a6b0bcb56549a0fe6d620811d1c56b8cca0d0e8ebfd657dd6bf1c8b7e566f1816259792f2013e900ab6a3aebfa26898d7e5c61020d88c0d797ffa5e11eddc07fdd533f2866826709341c1f237232c09ad89ed652609da347660f26a8bbe5e15ca338bda5aa60cc57f72b0ce91ef42c34548ecfcbd1122ac9286fc424ea7ebb765b0022938b275591360ba5f38a22a8dfae588ded08a678177a636f7571741184ff50c139759ea06b29648f355ae1d76d11f99db56ebd3a71b5e5944c860a9a47a39d751c63ff6a7f69f0435d4128cc4e7a91f4c296849fa7625b66674a13cf5945be5243166f07bb68d203b632d8c17a6b8f603078ba0933345304a868b2bb5670453cba96ebb4192a23976f02ac6d79ce75dd69c939e77d5ef09fba920d868c58935ea74a7fb52ac8152c6c6dad7fe17242decd32c147d1ae8ef67abd03a70111eec5bb35423d63759fe7fdea1cf5d424530b32201eb8cbbee9f9f910628e854583689f2c677a213674cfb3253b8010a0916b2bd5db98eb1497c6870c25cf7a56106c593c1bbb90c9a9d8f22615bab701f0355b8166316b43f1c394ec0ce1fc886dd10eec3ecec941af11596448fd5e7bb2def15218d9033f8e140463fde43d94f7514e475827bb8dcce9da49a663c9cda48318db26154fdb30d93d5d30822939d619a8a0e2f50f45119612e429387943ecea39ddefb6b362520ad06a3bda28334d0dbed1577dfe7f10a347bd78f1978d679f907a4f4cb8266753e82bca4f2632d1755d785a2bb0f7eefc5b8c3d05a61c834a2512c9cceb90d903000fe63d47f89aaf693dbc6ee7c4fdec2cb224b38a48ed7fd71b4c77ad7483d6c8a5205e7c3fcf238cd932c525153c5c6c1f77a326c4099faf9e97cfc83dc675f7a80b403af5ccf7b30206634cb97906ad84875bb724c279cb280baf430912d94066fee4c910360d57395068689568b9a51761dba82dff06750a7b9dd092b5ff72fcd414c60bbcd077ec46213a66a6ff76f3d509f5ee326b1136d348cee5aba38868cbae0bb236f6e1a7e1d1bc470e0d8857505ea899ad3043cfdb5b450d44e8ec793e7b4f56991dcf6ae4697c511416090cd04168cf3671d4db8d82c177b0710feeec80c5aaa4f526171f5456d75d17e7cc75b5ba2ce30d8558b23498b9c279ca951067a962a1518a1577398ed7be6f76ed07a9b2f703eabbebd4fff300bc1e77afca14753fdcac52c32c7f2b4084a5ae069bfc8ce06811311f4bfc944371ea8f76e7b5d7ecc18e6936555585b5129c9765af328b7e1e83aac2ac84fcb865982c85af0ce47954068a04ca4528b22e4bb88d2271de4e2d3cba75d908012276371b834b7591ac132bd82484e3f88c071ecb7f91b86724537e255eb7254d3ddcf46871f5b1d795a9629dcbf0c8c82195a903816647d7cb6ae3725cc8c78119f244503e7bde1b26c3af820cdc94570c4bd985e223ef3b98c6fed23127fd831b4e3f0e26f6e5de973c009dd6e8442330d650a032891c538151f6e1df3a062aaa8ac5d064b0bf557a5c3719e335e9ad0a036add38240abd1b0059ed15d279f4678000d3b38c49569c53cc41b32dd9bb2b9cc0b37dbf87d93577a5d70e0402a7cdd9c6d503141ef302493974b954f5c0b8d89ebf1219cdb3c3f6862db29fbe8cc75076e9ce8b010bb0b6dee0961c9173ed8c10a5097d11913081c21b9355b4460eb32c8eb43ca3e6c2e84604747f37d6d39f5efec4c92b2fe099a9ca17d9cbda289265d4d0a929f51d4934818f4dc92eba9017d21aeaa52891795011b4004e52f776ae1c49f722877db84eb8e3c900e9bd1e124f8e06fbf5fe103380001da9c175045b0dc20a79e2e52d5b3dd91aa7896ff19c55cadaef8304a0633a753bd3d4290bd724ecb07f7b033f2549574ae84dbec92253fcc1c5491f01fca02957ce405876cf160d954c03c76a6c227822c8bbf78918754b548d0bc94c590bb18959beec3d2fe76c144768b040280b4511594993239dc39e2b5fa9d39ffaf93c74e7faf331eb1d35357fac35ae44a9c9b239aa6dba0b223070cbec77b8b588562df447f8368913323beb55c4a2aceffdafc13a63724c821ae76073a4ed3d9525907dc749d4d605cb7b9c4f0a4cdc6666e3bc6e28933315712489c1372b1a3eb56363764f9383e25343577530205cd9681cd7514a8a34a3fad569d9e663a4328c3fa605656d40bb48613e24922d43d9defa5f014cda885ea8a6565aa46a001825a0888e0fbb83793fc039289709108d2b3f729c972594584c9ea68520a43b9a9da13956760158e70fb24cbd164052dd80c000b35db5182b56dbdfd431977b090e6b4d88532fc66f0f514519de463669ff4a8825e6bc6d9b72f0bbbd8189bd87c2bb761981c734a509ce6f6789ab8e67f3f057da3da45cd659dc7320566cf148205dcdcfa0c013397b3619a0220c9a4fc551dfce0cc42e59b560843e59d40f934f3621ca792ffac7c1148c361676137cf1b5d6541983ce3acfd52996e86fde566b8f5fc6bb5294d8942a5e877f86fd0835a367372dc8744895ec573b75c9660e52e4c17940c8ee08b2c377992463182678f52d00ee73e80ab2938d867c3e88887a33b197aac75287b3df76412e2c22dcdd548956e50f325c61a81cf827a535f91a0a24019af54253c29c14fe637a5c614f62dec3aa9163d43fd1837e3683e5eaadbbf08f5ca12733146373a442103d3cdae74d37badbb64050df1bee65f89720ca1b670182e40483f07ba59bee97f07712a216a2d6d2fe66ca279cb6d3ea48a7e18cf6248d79a28f7b0b51235b509e2637bfa099c6a2f3326f0d676cca0f7347eb419791e5b37ad25d597c509d82a4c5f5e7ae9218f37ae0d87c6cdd3ccffa46f087b07f31c3bb5fab0004f6407f684c21da75315c5ad87826747301b6118ec1e626e60c80c508adfe526708e0b586a2d89cb1b30035482bd5504795194ec6a4e814bc0812615dbdc269f7843a1efe2ebfc2b8d92be83c8d9a932330ed8f81704b848b3a3409f9b01c73247bb7dc2641c40b8ecd2b7f48e0d877fbba0842bb2d70fd9b3e099650cc24d487b18f1264be0b21dbdac69a84aab617e31e15ac8f4cf7dcbf6713b89524500f1b19dde9c50c9e637ab9a4275a71b724a3fe7c7736d81fa40dac58b4648fd2813fb1ecc28f14b27754278069fa8c477d40c772f6f8f5c5416a18673fb93b4de4d98f5fe3cf4733078e58ceaa280fd40cb64351f84b302b8a10798443da0974e3951cbe32004cbe5573080ab05d6b19f352e8dc389d2caf65ae703f1853ab19fa060c4760c33b7d5cf14ad054a5c6ccdb8da8313b9554055bce4336b140029103360fea56e396cb1a3d39f1874df12c1bef63f6e51f66eda3952b0bf318f44064dad6afe37adfea1eff3115cfeb9182eba9009e0802292116b4101fd3f60f589735aa0be02218c466d302306449a7fd1a02eb18a9c5e5628cee91a575d680d95ffe765b289dd81579555b459162539d597cf6e07bfa5b2b6ac5b11742ebc3d4dfb6df45f200c1cb2826c30ad06e9e38e088fcc00ebc830c0217bfb383087cf13e8eb3abd6a2c9a6f717a54f397dceca949539758e47a6388efbda81c413401de3ddf1dcfe866ea1147bd16e9bea9911b4ffc687a2bbe0c9bd1546950f23c1a0577e35f03d220b9c8524eed4a761b38407fef3f6760746cd7938abfc57554c0c317c456b43b515717e7fab3dba94cf57fa7fcc59ac287163894fdb665ae7910700bbaafd3c7b7d531ed47a39e777be0573c2ff18e08a87ccf51fc03fd9c077400ecb704b4d549b5955852b7d54037dbb2159dfb4e2ad20a4d927bbe2003cc69301d70c85b68a74403a07b8e037ed7d9905df34b642c307545790f15498116456e99459ac9477e37a192b008fe78721c9c43ca60f987ff7fb7be742cd3599faf0a2bfeda7e212f5fd057cc26771c353080c6d0b958f902de67bf5e3e0a896d1af66caf45b841786d3bfb3c5cea3d1974f9284a47b9452fb2edf62a162e5d56bdbc9eab3fda931e1f6a538eb35932a66c32ec5e3b22c4fbca59273af5a7b8a545d404723d2f2fa611e15cd4585e7261a7bb3c00a6af803d6d8be411d5c42946cc2c4a8fd67ac61da12da9ee0236e66c63d7b4c95cf232281890cf855dc7badfead5d51bdc7ea8e41a55fd6e71b4908d3f175bff3c75adf51c39cfa060aba8e7bc4405d5986fef0fe9ade35cb072add88c66746a93db0b1501ce78e07e07be8eb2543d15589957af2f3f30daded0e4227c62cb1b06a2c9428c787e674596b8f9a3e07d60df56e052d04442c128cdd5857be148de43b6fb9085132f574c8e2813449197cf265e4ebd372277b2c9c70776112b9def1f740b54b2ae2169fa9b9aa4719a94657fc7b533e4bb5ecc538b5cd97b01b40fe20d982213f2ed80988cc566c935c83a47a1da57fc581cf5dd99322cba9440cad0e7358632d583dc03439745d48ce142bafd9df376bc30b5dbda3d48efe3865a76c084e8fabb286f33655db3995b41bc8373f1bab435cedfc15401df586431d2be6be9291ff293a992b0d71764c9ca9366499d75da653961539e3f0410b12b566433f707fa796ff83d9c11ca5f3748dccb6b7903f904982402a09b42e996173c7f2b0fdd7468167407535237d5f0009dd81b50404ea71dc718c574ada160c369e61e27c0316a7004df87ed4704fdce9ca26881f03847554cf38b041f5a0aeb7808dcb8e1c1afad259d7680a8d8e765c3cfeea37120a39de40816a9d7e5120280a043f1005ffcae3ce36accb119e7c0e9405613c57b960a1e5ef5782137b15dfa81e5ec461d4126fde66e5765036e324982433d4c4100820f1ee90d26fd06404314807d47181c7d22cde2f9321630df7e0d211b533ab81882a255607ef678081bf9954e48e85d6f6f468bc7c5812fc5027d74f508ea6b98f1f61efe89b580e89c1671cb082a44ef623bad8bc4019cd5077ddff6f6d1fde48a45b0ce3eb1f048fb00c644583ab247c6baba37ed5dd2658d150f071bd510263e58dd118ae212579bb5a82b0b1ce95b6f137e60c719f220ea3a022b73c5eb5cd5d77dd026e838ed27e8eb23add61eb6a67539e01ef74eab9f971cb6740382ba29bf82df9c464b778b0993649c96b6a7e923f6c7eebfbf7b931ccbcf5de44c9158c8ebf1fdf77f51a18029d8c37a34dffae79a21ee432e1e4678d05d5c8a91f86db133efe3c0704af6f3277003e360a1d2f6cd020f056df288552b6c18bc2e2cda6216fddff479abb14df9a5e3b5d4941a48b4e67e9e94684ee133fa664c1d396feabebbdfbe7b5924a916e93fa3bf81f460819f4e5628b1705481135ea549ad117664b8e50df415d56d190f7f360514768b9a765060bb5b9beb7cbcf9fdfa94e320ba0381eeb6900d04dd4db77c0adf30138743f66ff11926cbfd68e40bc17ef54d6ca884b107ea8a54027176bce47afbc8813720e79aae005256b1b244647b59b30173928c249e8335a6612ee79d5745cabfade2c42738b965c071cf3b9ce8876624ba6fd078b6797e2e39992490047288d41cb49c5a871c10ac7b4a509db168cdc29d3b3cec6377eaca438f7d70a8b3c222163e4c2ad6514bdef9412132cae6608917a12865b4f7953fab0568a1ef756122fbffcccaf4711e3e583876f37b50b2ae8ccb66702b716d2c412d6bfba622fc27a7d3632767e7a3648d4d66e39ad466d43f27daf75733325ccf64fcb44c4b054901e7e55619b1b54c4ba908b788b935e5ab4cb71b49f6aa8c01fadd289c7a8f267770d0a274a06f49e06a51749fe9ad6750ae577fb5bcfd86d23c0da236c8de72bfa80b1490d9368ac056f32aabcbd59b3afc34bc7e67be61a587d2deeeec8a9f4fbfab3b27c52c6b20d13e9d7af5f4c940aeec2402102945f5e9bf2e529236543a980f6f513cecc6bac269d430f5af4f454664bcd831822f6f017dc2df289ff4f6e769d3799fd558a54cd891a30ace5a96048a5a480c60701d56f141dbf04744f837db1f0153b4bdb05e529e7e35a2b20721dc9ff441b5e09e4579df4c01b56cc81dea313b3f1691634716099b26c62d96ef5e459db1b64bc6aeaf615aacfbdc1eeca3d1eacfd889d3a24025e752c1a31b21b2c115c0bf7394ef0ad6c10922c826a7c296739c2efbd9ac77bf176c37a12788d5aa7430bbbed7de13e08b6e20353c799b2219d9d897fa81b22a67fc3529ef549ac8765021e9cfde4662ba4bbc68b5d0dc8cf99830e2f11eeb5d291e987a12c1c7e992f182ad111ff842f814579a8ce3cef912fa109168d839d3a166799ed8cf5ebc7fbe53881b255946dcd41a1949c17f0f00c658e56e31b897f3eb918cb3470f12dc1525a475c4d585d4ad804589fbcc00dd853f1a2f8765e63257e97a41bef492b5628497d197a631b7f7e9845cccb324b97e12d20070d0b50dd30d7718bceb7d9a0df0246151ce6e0230c74ec3be87718a88106f949e88c9a76a3f019ceafaeea480d5253b0c03fe22f97f80bc4d4a204a988eeec9ba13b8b974790e1d029b14d8ad6f19b49d22c4a2109bd77392f76fd9c8d444a4cc2d8f89b495f395ac28ae6a4b1bf010b8ea5834555edebd05a7c235a8ac1b62d6f62040140928b408f2d937d8266ab33d7806892d39c1fcdad7248ecc28c7928139f7b74907d7ad15008cb904a5d298adc68e5cd85991f2c732b44c513f48b0c1c2e9f198d3836ed418bf6e2facf2c3defd8249de31b6a490b0a357483ceebc7c01ba3607b9026180bb717cba00d0e518982f8b45dd36552822e204ddf45a66d033675bee1082d492bf2086736c5759d27922de18b61c6696d49821b23eaee2f362f9c78ea6fa858055bb589ea5ca40afa4c91a1a5f3ae619553caab4cbe6b6945515fe2791abd7aea80becd827184be759c0c68538c08c454b0e9a88a5e6042a52bfc5baa29bfe9a4a3b7b60719386f9988f27274dd73dbe3ed3840dcefc06b8e6b8fa41d261d10fa4d4ea6d162369cbab74838e769cb0fafaa9502843b8e027f4100c2470988e3f1558f285e9b7c3cc9df0609a678e4d3b5c429276b558d8dd40aad0d9280fcbb8cb8ff7b3b63729c932323d6c6023165494a8d2f2681e9a2b50863686c74a2a03741e18d5cd1d2d15b8029da2c1e9e54398defba278d09694edb501e0e90c80176adfdf44e309ccf82ce6fc5b774e182546998f97aca3bad6f3f2fffa316b5f38c3c44c14cd47354b1a365409e46209c86f566e4aa567b64ef04b6cb8c25e25319b41b73adeeda82ea52965ff5225bb6b2db4a917cf2961450bb1ab6e2605a43b23487b71965ab88e1ab5d290346ff8b840576673e7f3b9941c2c22318d702f26981114d75c9458939be11aed3e09d647c0d020f6d39d19b38fda84626d7ea949377ec50a8a7b6b361026c27a215c7b4b75aa63ed7547c95fa939914235c6e227b2c0490c4ed6685550620c244b231a2cee3845ae1bb71a8bd20bb30b477e29b54079d9e8d1fb9332050a8bff377d14508c0b51809207096315db7227cc9047b87b1174e9f59b131262ea234368cbb3c75e76737cd1862d3c032ae4ff544d960f071acc094ef11c65034105c3493b3c4cf433ba9fd0b024e307d134c1a91a4d8945637d466794c1b2e7b0efe3e3905c689ceb1c207b078cd44e09f03bae8db7ab108aa32acf7c92a3f8020fad1499361382f6c6c48eaa2691544ef3b386fe97ba95242bf27df685f2fc0f8d28589bc7bf466d35cc2484ef2d3ed513051c919d77af56dafd273edeb2e490aa2e33d422647304a6ecd95cd152358d0a0aa1797f2dc01acf36f66ee008eb6231f9ff27f01fec228be32b270717a3f0695d485ed320ede0cd2e7f588f763d3bc6d3ba27e5c478e869a0d123a3da8844f22c9e3b106ea5d394ade98b3e86cbcb2bef40d775694246f122f3920dd558b38c2731f61c4ef9f67717c943723add9155b553e04b5f08e7d00f33aa143a933ed6a7ddaefb3009566dcb229368e5805e870de6426c5143dce121e96fa5d530f2306114f18fc99526ae80afe6cb41708e1607f0c58e7d38b8c18551df32357a0f5c4e95d66d127e8de2fe5b7ab300f46a09a18bee10a2286ea035325312d5bfaab17bffb9267efaecb41b20b0a93e72fdba98ba9c894f8c420e2a46b75c0a7e46c7167d2b884b5241d49ffa60792f42ee7872acb34db5587f9071ce2e0ea613a2ee7351737e3f7784596657289678659f2b2ad169ce3e9ada131aa02e53bb3c52f7aece299ec4625d8beeea74d5320f5cca487ec82f7e78eabf28fb804133fac3dd1c8f9492119ec6ba20b9e02afeab8beac94dc082cf89610bf305023fb3bee1029013475570beab5cd8b539af724cc1d95ca91081c8615a94fbf0153f64711c9094c993760f55561902dfb35ecb7affb8bf9c8c20deb8fdfcea551e604add24317257c95c9c2f60bd1565e5993889bdaa5ab3545c5eb7d87192c69d9117ffe13c8b8c401ed3282e34eb266a153245a390a25d679ffc248060280d5237073e6bfee3322d7fb5de81961f372a1f4a740df0d96c26de710b2589cbc4eecf7ec9b477c34bc2d799506c32ef4533c579f47d098d0cea104fd6919a8732bd7512c5308d37573b486dd407feae7b630d22e637718b8cafd7194038fc25ad5be86aba44f507339797b0a210a324d9f5633451c6ffaad38571438dd89935139656636cc2a59aac336d5f23b66162ef70601cfd43f7d7a95db01acba58c2439b82d358dde8afab8878221ce5681ec00ce7338eb2ad598d99369accfb461df5e0d84db6c79d3da58462cbe58c9e513f885c878689045a9fdb22c0b8ddcec1a8c5f66c3ffb72229e6985eb5f5dfc09d7bfbcd02d925e38493e66965ce9ca70523851a8244667102e0a4f3db80abd6c9b54579fe36fcfe22315ba7725ca6467939d2715aa4819c9eaf6867dcf2c2c30f2947d0962607b829c62d5aa5219aca5084e977f8405831961eeac70359418a46699cbd746e70bee6a5147c3d78abb58b893855c629480c6b259a501ba9919dee37f18eaec494f0abbcc530f38e97caffa7817ef8984b90c8ff16ebf176c990d0d6a7599829d12e442b0290a66a858a96acd686d6cb519da1d64d4872a96e01f635cbf41c3d8bb1fb601571e267ca5cf422cbe2ea4bca410b2fb2a9febb14215893be7d038b59920a66532c72fbc7196d0265514f077797b6f5d0b96083c54517dcbcd4bb35bf8e40d756b79f6df8e4daab4a291312cc100fafe98117f192feda01e98c3ffaa7313e84ce53565b01e1e1bb77f6f49daa017d7a9ce029c50120cb496ed8e0205461508de339d4ef4f630f1761090a03c438f73e9dcc748f53b882e87540d0231e1b4ecbf598e3236f67c86576a215e3679de1bc94c26799f63869aaa527fe6875f33460b6be1d1356ee6f9232491961f399fcfb5c473b752d9162c437e057acc82b56572d0ff85334e69ba4bbf53140b420489d7f41ecd9afbe615af8fd6063a451045c0318f734fcbab8ab85526de37b2341aad620e0480afaecc3abdd3337aafa09710553ef412248461ad4313ee2a039d96a2ab1150b1df64cf4269c4187b34442895dfeb29945913d4c752fbc8893b3f1840c1efad9d6ad22eaf5cba27ec1b64fe4b423d5e613cffc1df3182409fb18d0b2361377f9eb7146a3bfb0fd12a9824b47749b87ca334e6be19cc81d490b036a0774e72c60ffe814b4ba58332a92a4eaeb49ccf13fecee1893ea029bf709a0e7acea4a1c1ac3280cd4db611f15a4a6607050a5dbb6869c7619b30d0ee99d1b4d775cc534a041e1a77aa75a351a87fd0c9a337e1ae8833059266f3e5280a60f55452c0480af229c98fdc4406060592f221cfb3c8bed8934dc18394020b8e8c83ed5fb9448efc7b91ed8ce9e2486ed30d67cfc7cf939ebd9ead949bd6f2f41a78d33a93ddb78d7b3437e3b16a3bcf81393847d73d5b0326416c901e0399333e89a7b5e30c8e3018fbc9a26fdc815ae79c11e2ccd1806d87b4616ded9698d96c360fa6a615b0631fdf6f3b1ffd65ffabc4c357958dca235b7aeb7f7482295b057bb58d707cac173854add930e60d0b8f6276d3432f092b451962aec4e4560663c99bf4d6f9bf3ac85237ee25bd4f9bed01222165f9d6f87c987640984b1f04c4ae92256d119790fd7e1df7c07b402c4c34a877fc6e68661c74aac1cdd9d108cb979711c89469f673fe193973eae6e6fbed571c0877960b3cd9018ab744183344614e3de08186148f9ba7a04777db2d54ee5e4249fd173a7b655235e38d99d5ed4768db2f7d65c15a7b2b8c45767259f6752ff7f40879154f448da34a3ec593fa55e5565eb98eca3b06d9ea35f2d6be3663e95da1da5d8fe4765da08cfc34c5c50fd84062f6c823f47cd7c8919a5a4386f3029b1da049fb55eafa7cdba3824c906f06a74c4e2ec115c03624e97e5997dc131b546a5c4bc474ce4c1af377a86765564f12bf6b29c73873c73f3ca646964b7489d2620b160fb6e913e9ebfb5f60bd5daf16da4336a1e408e761a8e7c4c95ce49180164613e4ec7b6516364e9cd494aa36932512ed4facab5ac05d89d3454fcf3df94b0a310a8fb1e92bcdf7270ef8bb137f2523737bf4112e02c86927ec198a1d286a57b2ca3809dbd6ab36100d224894ccba58c1e1b8dfeb10b9f4978de18b52a880960222ad92e4933d8f692e6c63c9c94a777678fec8ebb2c6a57c19d93d234fe1373b8fe3b77ff91521a71517c84d94f91a316a914873c6ca1aa9500a19edb8e15029f3273ac4b170590f2b1e2aca3194d11d816fb777af66e7810663ab70bdcfd57a21edbd584d68ce9f2dd15ca9dbc4e9429e260003e033a3d25e7257dfd365b7b37ca6302dbf4a921d99d97ce4e31b9f39a3b811062b00f5c8fdf71557fa985f75c0e8af9be802de8726b8f4d520950690ed1127cf00d03a5bd76112af2eebc8e430f000744d9493256f0ac3817789f9a1188f7ecaaedf8febcb5adea809d528f5d5e2d5c0e2f9fd5a693e77e97e562ed403a9ff3a4bb5d6eee1e8bbd32e5e5d05e7bbfb43c900779833d1661563024b81b64261fd9e784d60282157d559ff4ed089f7ffee5850d6003280fb818825ff93624fbc779c3cb1c6c009c8080d7765851ae52db93246afe804c0baf203bfcbdcc59644da4162dbe8c1adad8ac2e3abfb5c1bd2a0307daa10e67826ef62a51605260161271ff2b5b0e30fa3e2a5257a9ab8791cd18b5a1638b89ab7743215b960507d40b591fdc020c9334163ea201fa496fd330550ee261b3c124d10023e1dd5af7fa79df7956f5c3f0699997fb7261180034f3e184af5d81d9bd6b20bae6ab273995a79ba25bb8a52341e2fb6ced8175e586ec2ad52004ba69a0ac5fe849d91c5ab3e9df20a1907fd929c7e254fae9998cefbe0cba6e948fab742ce8540524e896294be86fc5e660c866bcdfc7c67c82ebb306856a9e24652c8eb026448e6de94a8649bf85acedaf0684c948b2382ac091136f5fd5212c750b4bd0ca3f8a13d181a636a245e616720d72558551b80b0f20db265ec32e02ac37efa1afaae98910fdd85fb02d4b2507f25d0b4cd8172ebf9c43f81416068f70c38b1a0e46f4f02177374835ec34784541e6d36d1a39918a7ab095bb5e2c5cbbf23a8954cc0f2955aef7f8ff5f6d6f6570658cabd4876a6908f5abe470139801a2c6e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
