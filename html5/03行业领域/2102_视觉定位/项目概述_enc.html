<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2efb8526391c03401a856c6018fea8c89d66136a641afe7b1f3520cf9737ce593d712246976673fdec7bccb7d090047bf1789480ababd6e0517f650500ed21357edd1d29e7fb6e733a54d96587333ad2fb65256b7b65500645bcc9baaff6f2c8aa85e3370e2839052cac30627eb5359f494d75d3e6bc5580338408512ec5cc0e7c7b8ef22efa60807e536b3d1688eaf23fd3c3ed085fb29208d45918561ab34fefdcf69922e750fd246bb68c0f7216e2c625178dcd2301bbc853c6d82f5027bc1cf20947763faa273a2cb67612e0b2f9f31c031e25b80a3db0ef280f15ec74d8a884a11f7915372d84ac1df0ede0936dde28b667794ea1c85cae97c8ae62fa072d84e9febd2bb6c4f9b1303c2fb2c2f12bc709cf46fa23ca0530a6de51550a404ef14af0e4700c3f4059b119ae07f3803f19e6b816d912ebe17dcb3d917ab5b349c1b9861eead364aed5f8419fee56bb04b77943f507d1ae145ab743bd9db26a0ac9d2320deb4cd50726b45a23bc9e2b856d658758a9201c335839c0b877aa187d739388b9f851ede5b69e4936c7aa43aee7ca43559897fb86c50bf2792e7fa26488540513761f45544c2ea1dd8704cd9fe0bfc8283a732c483e18a48f213b381d61e395033109a1e1b000c58c58e5000a6629d67fefb8fb59800f56354e3b259ef3aae70557c141ae8944adab085b6693ec8ff9aa727d947bd16603012753affb08981c08b7b885b6d4d53025a227bb3785e7cda22269f246a9a5f525de5ba9f56d4dc3d588c6e96bb47b3925f9ef16786ac4093b86bb16293783ed73733600c118e9d0520cdaad3a151862961fe92a31f1b5235d465d557a41d04097d10282445ab8ff70c7fdf9196349e7dcec353a83d21e5bc0799a5d0cf0da3bc22643d8585a74854664cc9ff141e7688f809140aa29a480e7334fd18ae7ecdcc3836c93570d5c3ea598f1fb41c8c17d2ccdb9c51d4acac079f49c05ce0354a2ce8708574de258484359a23297bce2d0a233ea3089fd1d3eb1c9b06ad1da8a9dc5ad6e9b4e4c3a5ada48478d5c5e197a733d8177cb1e2540373b01f44c34581630b09ce02352f731c326725fda3d326aefa158f77710a2ea17c1800af4afa0fff9ae2051b4a41ef470ddc2e3e630c3f38da18637565c8cab5537930c51160869bb171b0d1460dbd34e0b4d2374730f230876c8a501ba59b88d244e624602bbcb48b03d5d807d222cba1d3362a88579d072f42bacbdd0ca90332b4382795a94d931ef61adc36dedd04877f6f59802bec25fc8171fc20d2f0db087ffc2549024a456cf434004f8f2e54d4c667c6d3f77cc2d43ae68559c8c5737f107e6910518fdc4a34a8ea1e375e4b2017c5d2e97e1fa2a83a6374cc8b55bf1fbd8b1a87f1f25a9441b319b92f98be49b0c7d773e478a6c85139b10883f176380122c8d58eacd03b28ce94aa255fed1da2249c38b162d5a183543824f680e0644a30fd006bc2d7e1413c53f26d201f2dd7e28ae325f9a7d5b9d2ae68b5529fc05833b4585a906d64dfdbe8cec53b531d20226df6b373f3b3ba1460b0a34e65cb532670c3d83b1e5e08c577310a6e9b462ad2942a7537dc8572fa40b2c59b7c09f3ed0185d6c367095d8d29f496f0af9c6ae95397269ec80ffd66f30c81841c99d40c7c00794e1fa23d853c1fb4c932e88b0da064de1c8482e743fa033ff8fcc1f1efca2552efbf4a126f49a302a7efc761680ef6913ea23cadf0e95d5acde5449c9e9818fe6cacd108ae8c553b3b7c587b0f2d39efd0e7ccaaee376241fcee8ccc35a41edf01e9a90ba01b94eab8b8aa81b320b23875f51f70d7123d2cd296fe513401be08521380517a0848430a80ff8eac74279f3a48bcee847b79cb32407dd52b555acdcadcc71da2cf84b4a5558febd2883b9d8f15fcf7010fc35e01a166f8c103503b0a7a9bed2a7f78f1a1a2fb158a4b2ff39f67f3f618ea1029e66e6e475dd001531dea2f8f8edd5016895e5a60a766b8fcf9b0ddf0fc5e7bd9746929b40fd4bf838b465d175158c902c52c7afd63eab189df9d5c07df33bdc7f0a10aa1a52698a5687070c7d5568fbfeb0a86781aefa7d8efcd1bd9520725588204b929ec000017cbe3ae37c49cbcbe3c139e6654585253ea67dff0f7e6e89c4eb66f95565bbf7131cfea3fa106db5408fcaf2cb010427ca4e125b46a35b5ac44bc3bf7c5d39dd2e68f10e3b16ce8688d89fc2e1d58a1232dc076ca088ed9d93dfa69259e4c43e20d6e209af7ff5f5e5d2964d292b62bfd851b767c1273236adca471aac02dc89b53ba6190d3112af75e60cbe5f8add8e816337f673b53c4886183e590f73139de414952b784c11bbab0712f914b8f257c03596eeee944e200e03306687c9bd52d16364aa9d77fd992f45ad10b09e3445bd3c71436205d70edd32d1c03891c92ef35e15ad59cc409e3095e7b1337915e50e163f555caafa0905b3a0dc005958c07d4d816fbe445f7ec5c7e6b64194b25dae4384dd05bc298e2d82a5c880b127a04e29f92bd2084b66ac13fb9da67106d7e34bd602743738ed4fbbf138c043c29ca23246b8bfa895b47e52ab52859c18acb3d393dd8eaeebd414280b767cfdf112d0a5946be64a1cc7fa3c8f744e4f3895dd16de55bd3cbd370d70d5d2bec190561a654addd8e28691a475f0676d1b84a297c5e4777f4c827c1339db2b9aee9eb0d452b5007ac54cb1afacdddb31ce0a2aacd7f9f4c9d8422629a7896ba49df2167439264b26d180fb185dab569336ec8763fcb23be400652ec7d3a6a758c773807949940bb04763edfe7a5352de984400b7ef73659bc8d4c796c1cc823be8d14ffe2e379db429a65eac38be94879ce96c60bce266f09dd7e4cf6b84fbe3fa1f228d9617a1fd534c61fb1f17d0373bd1c785af047e75182fabff61dcbe7c47445a5d775a277a3844669cb0e756ff75b65965ab291d48ff4ff84e3562f4462b4578c3ab568beef50718f022d2dd801510de4d226ddd95fc319d1c4e8f866475b353deed616147ac465cb9bc603407a348973e801a316770eb4f79567bfa8e103e34c8838a6863f02bf95ccbe210aa32074a541dfdaeaebdd4deaaa93820c973240c69c30bf7dc68cc73d27d4ae302d699c803de8bedc1ca31a9b7cb47664c7382b52ee3a72476f9f49bcfc8cf161f45d3d3ee7b5ebd3c5582108c94f57cb42cd4fbd3e3ea49588d7a768bd45c168edafa57eb7f6cc975049c67ccd74852282abb91a98d3ac64bdeabeac2242c5ce552c78cfc532a18273dda6683e8a0041dc68842065eb15c959179d1ab9c82cd10b1397e149814b2d6a136d87cc9f680e0cab6fc05c148a471da5671c243c083d828ffce0a51fe5e5a0d48da456a3aab08bfa5c335c9cfcac89450103c7ced82f4490e8eb260dc3bdd926a5e1fff7f3fe820a28a7c57773016e1c33ad9677e259b960df8a5cb08edeb15ca18a1e51072d3105c4223eef256f0ab505f77c44f1f68f1b119f2d7e4d85454c5739da2c0e0e3a4f816b374fadcf6b8b8a0752118c91fd8a87c3db17ed5ae677193f159ae6dc5d2330112c718bc5ae0c4680e5a1cf000477a3e8d1608a92c0abd4ee0a3da7683e54529c6f3e631cab4b266772af2f6ae1420565f37462ff0188d0961a99794c27be15f2bcbc38ba161763681e726081113a6e44107227e84c564f7a2a15b35fb556fb372a8793db199f541e9373aa09c2c800b82ed61d385785db9f96724039dee915e8a960cc3ecd5f466dfd5e19fe39ebfb4a6b739edfc9b1a44423862f645c35e40e8921e853ce27baa3efcb177266dcad95f9c5f705b49432ec441a444c0cecf0962f6097ce80769e8ed01eda5bc7357a21a0c1d20e99db91817054abfee68d10b75781328092474df28e6e8abe8a55be7d7e22351787841e2384cd61cafb55a089bb7f377d309b010a3df18a09d591d5ac4e61ba67ca01bdee97cfc88e636a2269ae22ec4f40740c40978037052ee1ec4f632eda6bc2717196e842cd5ffa1ffdc6d6b7d1bb7966a3a6c218c0fc4e615d2d530a9035d2cb097a91f2edce34550200c9234c0ce6cd6dbca80af1419f66e5d4625b059ab57add6d5975d5d010f8a3dc367d641051c68db594580c9fd398b522100453069015ebaa594849209179cfd5d39f0027f0dba6bd8c2fef459411c3cc8676a320f00c6135f868525e75789271b3a637ff9e120cf627cb2bbff027c545613135b71bba865708bef69afe76a09f8a90c5cf88fc860198c31b3ac4335e605c518c3106b470378c8e6570a25dcd5d03485480262a72b47ecd1e0908b4a37df97be5963aeabc75023f0dbff1473bf73d123b0d04e2865e13c070ad02866eb244f60241f4b9a9509fe2cacf142ef55116c4e97161977d65e4622f3292a6af1f1e413d4786c5e63da9bb7be7651588547bb4e4f93ee6a8e3fa8b1cd371afed831d6ac089027a32f467f3a5f5c7a2c39d95929f5220e7bfda6f82cb11ac6bbf2d3bf9ca7e5db840c5649507c6480af146e96a300314015542aa50b946fb3a7ee4991395f48d8071abfe4280934fdf26603b9782df0f2b9ed5446ad76d136b45ad927664b31fb949b7e3177514f96ce3b361f59012bfd5dc49be01e6bfc49f4a013902f86d8025d9359b7de79d9013384fe7efeae9b01c1892aa2e09ecf62d4607ea5cdfad694116b06cdd65820affb816fe0081fcf13c459482d99147575178f8f255f5d0271ea7d06ebcc5bbf75e3f812f5b4e607298009c5aaabb2e7d57737621895c6b4d542213baa0baba826387bf27def6249b3edd427689af743424239c3cafbcc9658c0bc27e4bec29d91abd6aa3796c0445e7da2b3c2f579c2c6138df1c413acd6ec7092a11d2fcdd88472414268a76350fad14bebd90a8a6685af2c453eee1d60e12604881b5773b61113828bdb3859b2a5fe6f01f731a4cf33fdb0deec3c451cd717c20ffbb2df5d65e9dad81644a05fce06f57e994809cad622d7538d85dbb8af88ee2524963b739cf59870b65519483083dc4e9323314519a5d36a6e92f0ca3399a3e35bce02deb6d71bedea47d209a797e455405e68ac96488f6bbf06071f918c8e5aad491988f63a5aaa32dd31285ac292eaafc255ac77b844bf228666fd9f40f2bf1002853af3bd8942da58ae048439fd0fab85d9ba0425a74b80754991cc7bbaacb358066d662c32120d6b139aee6e76fc2b41a1ab0ba5d4622f53fec216899678e55319e8c6321f7121723d8306d17f9decf8c4e5a4c9f0642311c6538167de543fd59dce664d79508770b83ca55e5216a7e6dfe112da00dc5025d21267b2f4921e544f215a3ffb201a48f0d3439cc98536b61277901ba03fb41d75cd50f83894186be321c09d3197d90c6ee74b27c551f9bc1dc91acba3d3654e36f79717ba6f3026ad7e0cb7452ded8d53ab97166c528765b803c71c2a3083095d26619320c3c06580017dcbbb7697b415c6bb8c10107343b1f448d94c818c74c04f546a069689a3af86038bd685f0209b50d5e70f5e78cdad2ba5e6b58d54bbc883c75feb1d7f185f54dd11ccd55d270e635b4ffb059be29c969817d1a0093311fedad36b4675a8ebd0a09703068414c651da37e177798b23314fbbd4317a7480c94b0d89fa26302da583b1ee61ae370594747fb83871c71b57f7901f85ad6874305b95bf5921a2472878d686613a7155d156419267168022fdfd7c10b416ac83e6d08dcf3902700506e84e731f2e339acd82c6aa76a8f61f34621bd4226b67c7e827c93cc3d2f0e0217ccfac130c94ae0c6ceb7b6a7f2baa0e99fe37045bf05c24d8d6a1205248e930158c33befbcc98c1223b660a8ce48994d44e0a2ce99b1ee47e078ccec7e63887f2c2128f43725d257d91f05f297e952dec9ca6d7c7a8025c5505dc07d7f135b1adff3df3bf70f0619a35695b3807a94f5ce31ba282323742797fee33b8e5c6e566cd84327f44e32ea2430b0277c475c2d0d90cc2f51e15522453269ce409300f79087dcffeac892b5f52095e3afcf32fca2dc624d99c9cf63282249488847652055c9d84e20f423e43d12f320980af6dd0eadfbfb661e13e0e63f2bd696a11f87de652cbdc4d3caabab170eda2bbbeb1cc5d3b844423fbed5452c34fc8d191952c2d8502f6da41e973a3d41696f4ba95b1843506b2c3801ea7435ee3f70dd39d8744a4f4942463c48fd44931b99183dd7ef92982c838310b1d835053af3b5e45b29b6b73b7e9d73a457b09233ebb952935976f872b84108c478d2e42e204efaf4dd3cb23ab4ae2d38f40f1a724caa1557a9c35092a50d1269378df72bc056a59fff1235511e7bc2a81d995b84759a21e2303d64f3693307d2b15a1b08b09d8fb4bfd276f6d56317f14e8c733da8084f59f73934cd0b3431fe49c7e9b1680d5c1ee844069015c243407303ce6a00b9cbbd7a91e1818e61f7a1d841dbd64f140b5d2e831d2e4480fd8fdafa438fdeee173072ae584773dedbc72972fb0f14d8d61b64148d2e4a565e4a17a31c474c7c9761b67c1c637151e52a61c2e8ae339af7d834cd3b0bc74f227699599fba72fb5b675c311b7ca88fb866c6b7c41566361fba794613152ee01b64ac4cc61c207509f28e7db68197756e30a996dd7834a0ed506e5e115d6f3b432c18e1f72ab421bdac52e0a3f9fe226610c2a04f3cf213f4732a585fa71e70e94816f00fc10fcb9212dedad13954d519e676693138e9fd4c6458ebe9a5d6e151e9e426957bb2479342f1bcfbead2e49869db1db6228e13191491f6aff0c778d6447b112b9c43ec1f47580b52855d23841a427e274726563648ae362ae0fbeffab807cd5d69c58cad081a05739d4443373184f6e947b594fcdd5b2e1e9ee0727e1aeeed79c09ecb76594c50695c7926f66d87b5354d77b419f0769c45188b5413998b752433879e4b0cffacffb20658cbe68d2816cbf094f7787f537b00c886ef5ec3bd119e13e91f6ae0a308406f9bdbd0d57215158bc7d4435e4a0efc388e50f8a721a35ab88bb8c965c6cc06702cfc3ebdadd899fc2d9c84caa96d537c50b7f3010e748f6342c6bf70fa067107346e1b55f4a2451083e2b470578cdb707b9d640912164ce50a67f3c2812d2b36bc334690680e2afdf78f8de5eb11f89b4c37f429ff3f895c9a1b5f1697d78f0f402d2f09b3f7baff3d4cea3c81328650b58f13c48371d0702b33f413441b0d9731f5633a8f9d903ad4a647bb73b9193bd69b0661cf392300e77788cfd446b7fc0f822ee7b15774aa0a73791a4f6856a07443eb61e2494f8d9197616addb930ad36a6489334087d073894943ec6f60fc4c6ffcd80636cff547db701e855d3ded0e60101acbf4b3c19b5767cbdb44f69f87c93ab92e76a6963367b01a468fc00cb84c0b19b957f90db87bf9ac98346cb7242645f922e094126e0a7d004c755e2207cda85016e54ca284303e095703b6f6c4729e4e42f1f6185682de1075a0c209f3049a75e158dc9b5b476ee60943f246314325284151859f10cc245bc40a48524bd86d79e9cc0bd2b20382ec682fb73fcac5adb489460b3165570a44b528494315dd6d2c7c64561f2d3c49f99a95712aa99307eee80fdfc67f4e6b6a659d8712c909e843bc4feb3d64a35dcaef69bbac2b7c4eb9eb5734b133f986c8b04d432d7e9dc5c779ab213ebe1758c34bbc4c0befa8421c171e7820c15e6636a963ed04736f524e4f56b71257d0967c0697fa6a8a2c5507852e398b484f8ea6f42acc1e68a364815ab72ba47f77e3808b87a097e7340e05f950a700f6f84349a6bd05cba7c8e6c9567def99b97122fbed002a8195159a30a80100bf20bee1cca2a601b8726243df186feb4d45293050a8b4cb1f5f33d2a0680b88ae24291ec329f52614760a116be81b3c2038f494ea93d22ea06976978d00499ec61c1f445392e768764bad8c81b1747f08f98ac7e312a9976afc0cbc37f9606d60cee2042ff2ac269502afd447e668b9da70570623233e38f8c66c962f800d129281d4484b863cc4cd0561303fceb6e57313141a280c6cbeaeaec440ee633de5bc3947e8af9322756898e88985086f9a4563b49187b122f7fb9bbf0f97ca2eb885e59e39280d977593aae01115406be405f634ed31b863c8fc6eb8525fd91d7cb6951dd3a24e0127a6bf211919a77b63a98620d1a519da8acc7ea22c1b74aca67945d64ef7ff2067ce695a5242e278e57ed480791166154b5879261fd32898f45b285ce787938b5ee5e08b844323797e853f6cad2582c5a872249802cb9453246c3a24e71f6441598e4bb92936f15187385e7221bc3b38262dfcb9361e089285800fd23038c4b5d5f435cfa5924e2c0e8e2ae4aedc22d48f40547a59b4bb3f376a010066f50565358796642faf1e59a84a9b024a468fb90b7e9f24284e2cd682c6c357bf15d21fad97f4420605b945a5261fc574b6d3f515f9ff8fd0969f7bb4c0a0519fca0c36cc783661a4ecf39ebe47eb4a75d62ea1068347109cee0c5e411e860cd4f19f63c99fd618a0d5b1e9944c5df70d29ca74360e26e66a252d536757c0f8b37d6f98ef16e8030a501740d05d01f86706b8d457ca08b1842c267c01dd50de195101cac292a29ec4366c7e2d6016871adfab0cfc53ffc1a3c743e0da22411dddaf2c778800951b99016760031897ddbff79b4c1b3dff889460bdd5cf035c54261913af32b33b917c4e070fa11e8fdf8bf5a22642ae7097dc9da916a8a6b32124689f164e4ca430268960361eb8881fd90129d7a02437f4b4415881faf0ba928b04dd4ef86801094f7f95e27f4d1d759748e8f8195bba3b6be43aab6b3a7e22fc6f071ca6da6a74cfab042b3aba9c675cda7e2b9b7bc85a5a5da8316090be57fe880c5cef8bc69e46ba54d45cc03bb459da9f8d1958b99106f723588b2c7a53201961749cbea264d1d9f995e9cdc03a8e1b3c89753573680c41cbd86378781dc90d7571f826c70a9e421068c614aed392a870e0ab545b0ada29486b5a908bd2a4eed5b26cfab340a1fe9f3c269eeb05305be7e23a16812d3acb032e8d022c65e702970e1fd5129026e248f1aef7297f9c6fead98173815457b7d7a0dc33bbfb64e999739cedbbad51c22b2ccb47b1cffd855f66ae902250cfa138eb1462b2cb715cfed63b8815492320cd7825540f43e8ded6761fe0de13e8e3731e995307a1bea16ef651eb4129b982eae2ca40ff7f03100f263fb6debee0d075430c68b4804e4228f70d103e9d3e7b22508d96f147617a3d74a03c8429f5fb646e64b2641b7febe0b9bc2f7d4c5c612a7c0fe8a6698f8286c0770037f8588a1f5995dc94cf1ce06749bad4d89a309c4b19b38c244a73106e5bd25eaa38ad150068f1aa35580b23976acb3e5053df56f51234e1b2c12f0131d83f8a8ee90b4d69c3c1ee251bc5462751093eb602273fec4f8312ce987ca656968eabce4d1a8a90f86eba820dd36e0776bb33d4f207eef709a782cf783e4f009cd84c6dd3a89e7950dcdb48346900519aaebd3bb9b9081c60708bf5ea5e4c8b85a6b53a8af2860dfa7b995f67d64284b37c8a48ae11a3b88e55e66f2b960a8893fb4934a5a656943e403cf09eaddf7b8615658368c60471008833790daa2b653b1651053ce639690354a6e4faffe624673f31ee7003f57c5949d2bcff5904d468beb6eb7055e9a553a5f465b8a599e712edee3556fd0b76ba41857162777b745056077cc7f4c539cd0635db70e08d0ce95e3aa1ca57f46108e1bd31d8bd9dc7a11ff6a310846fe65a99e0825fd12e0adb0d6baf4dee8cbb29cc2757b9feca9ed0f61049a3c61c8ded59b4b5a2d7ef436e11ce6ffe06ad3c3ff56f5fb8b5e2e8482bdb37650198a5cc12428140855ffcdfe1dede3bd611402323b2782b7c8ad2c8904b2459d86e64c2609e9a9511972404dee0603489f9a4668cad3f8281aa063aefe381fa3ea52b7865190f3e5203acb58a8af86118452ffaf2744c546883e2ce2003c24f9b87eed1681d335fa559bd60c221038b23eb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
