<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fd4a87b183c197f8442930d5647b1503c6d125daf2263680f98d2a730c3f83678c412b5c209cf77fcfe67203dccccb3f291484b8ce8133a2adfbc9d183593a980ded7004726c659629231f698afed56b932fad8893c72142774fdfc580b983b2972b49eee3a74af460dcc095b9766633b63f25bb8c00d2eb781a95e8ba5339641cbea3117f5a70618b7f3c9831c595598173366c818ac8c38955e2500392e5d9dd792caf751eade3eeed0a4c8c84d6d496549031fc3689d630271b299865e9133097bbb24d327ca3d15eedaed169c117ba9c29b9006b870a17c413f270918bd68e32f3daf4fce499a25b79cdfa2fb8f86104756fe3d007ba88b61792bf33ec98c519272fa6e11ea392f09a839aad6435fab741448cc097b1b316f79f3ce32de1aba1710dd2253d19596bed9085a3a805af8b7537312a0b2353c88004300c42292f069030468279534c8eb52d447fcecf2ea3bdd9e2cab01abce779aa32e5bd7e34c0cb861fca8e0bb4e7299b573c5b1925f728609faff1c1ba96922464f7dee043330160a3001191c7ba984dafedbd0e68e2ca7836e87933cabed246dfcfb58e2761c6e7c767e2ca3abae8961e8bcbc077ffad58759455e489c6290fe4d7ae3f66ffe8f5680e71563426a96dee950235f57b75785be36897fb8bda2fc9ecda68719e3a4af8b011d6ad602aa7246d51a8ee3c614a25c457cbe9414afb965ae5bdd3308ff5911422b9d12a257b413f484133b91c6844b5af2f37fedd03cb9e3ef87e9777a21e3d3a35d43e2dfbcd3ebe6228e5a9caffeda583660c8c5e05b76b7354679049468db2a0a273847291539876eb911a229a07a802b8fc09dab9a5da22e3e59e48e408f504f139ceb5519c038488c9e4d4a4c219d24bd9fb2f08d2c44214bfd9c8c26919b325a814cf399ec1c5cbcb9a678b2c691f7b68e5696eff7933b7e37a2b17933f820a9aeaccf42b47a2a89c0aef821ac7f59254b1d6584158cec4b8bfecb3f2d7bb998c861c31d17c569a6ba62484c8612221d3985ca47c455ed717592f1d17ae07ee20a56a618e19d01106087bdfa5c506ac6ca6d0d265c11420d99e7288b6dfc2a03e2f66bda0bde337e389b7f42dffd786061ffb69159fb0656167892ddbf815b9981188a10a97ed303d52286604de53015eddf8053497e13445b2503e2be53ff5423d58eac6f7b6387afb18f1165955f3636b18b2a1f3da0efb29dd3013453908cc7a5a98bde6438b129907bb8a2f1c464a9693e9ac9745b15b0711d19c87e382b6ec498cdab59b812730da49ae498ec5c5516fb09f093cdd967e56308840272be47e5a73161327ed2d9fca4e1424eaada869f1d6ebe4f68d76eddeacdcc6738f6c752b293e804fa58f4961bd6c2c686d4b26a407297ad716bd3965e000d11abd4036853b486a22393dac9ae83351c01743cc809d14d901d82f85c4d1dcf70c7d574fc9517939671302b49ba3605bdee1d8f1df3eca2fbde6a47025c7193146b2f35b8714bacbd5ead2a8890949b902920fe6d0a6599c88974164e05f7b256b681abb88599438a13f64b923c3de2cf9584bb4e5fe0c755d0ed030507eab09f31a946cec8cc6a5f92e9a4a7b79ab2cc41cac874759a4eea7b3559b80c9e55733201579f8da1491fe3335207a1ef9a8cd10d950036d0f24c2831d0a997b333e03865c417d24f64e4d07f5147b377ed7f1483f0e7f98540d474982c5dd47574758c388d62ca73de77bd5e6780c28d6147dc539f5685cc2b7709d4eeaefdd8407c7709b0fd7bf6bc3b950b69867437ac6f6ea01bc3378b1a7f352034a1714ac042f760187720d4230130f116519ada7191d781b30284c990ec73480b8a2f38258679621408ed5baa2ce434b3f6988cf9995bf40130e94153445a7244ba47d1d270973e0ca8b29000216b5a7579928b396376e7f4e77dc54c1569651398a96f5b1e1b2232bb790364b201489faf49ccf629caa6e20cc1192221faf675d8d70bae319c4f91df4ace350f35eebb5fa9d0eb2d3bce0fb934f01db0b34b73d2875200e4b19a60dfba9b69890d3ec817bdb923d9a9762cf732c10926770575cbd855c48d8f84a24f1ef22afa529c3892c040744eaa513c4e8e73cf5e47cd8c6a098e5a6dfc854d6c41037a31f03dded8945b7560e95b7852e79bc5a2eeb7fb3bb378d4e2ea4b7b8332299be4a7c11454eab5b64dd1f5ad80261aea21eed891fffe904c68644a86b6202ef090c267aad13b4bc31a99c7106880bf0ab4edb549b2726002d705e1e14e3b9045d5cc240eb697cfdb6e00f0bbf55a11e6b98f956b1716c23f19f5126be729f6505f272a7f264ea404910b1073aaa024878dac180de35243b378d6ad48987505b780b532c732cdccc95bf528992a1e5b00204017dead4fca950392ac153a7024ce9bb371ae924e92cc0fa186e1008b12204d9aae4f9c473f6617b206bc34fa617225188e3f66b509c61ea2e9f17c27a174335523a39a67735527fcbf52c872d8bb96c63a00bec5d2aa9b3e20b2c027dfa9c86adc2096ccd3882f0d5c372820bd29136310c1e371f7182fb832a5b21f9ab3836ab9ee7b6dcc4741e6b34efb6602b258515645c6f525f994748e6760fd8ffc5764b30b205eb022cc54f34ee8a8964696c7566c0892481965da5b0e4ea44c1df1cd43bd8e57df1ba75c8a312c02b23c75185a108c94967f6d91955bbfa6baeae60786f2c0569f81f8c3ae35bd8b8d92aec33a352291c241837b495a02a7e935821db16508fbb6bfff87aa22448b854885eddbc29cc901bd1b2de8f7f53f3e66c77cc6d28078820af8491c77c41b462ec6def57cc2d7358cdc35104abfab82841b6fac1e8ec49ad308b75db1dd45c9e9610537af6d5e99a79355d890cb2290e2c7f605ec3878ed22807fcf285d0492322e6298ab58d1b9d17b86fc756031fe635c5745fe5d0485ef1783cccc8b2a3efbff7679f1c521dc3adfef1a288d5aed73df27cc711fa5fd80553c1aa774548776ff404dc87815420799cdffe5eb1d8a37195cbe37af85af6fa4e1574b5ff12a1195be82bbfed005d4220629e709bb693aacf9c7270713ac9733423d38ffca87449aaa2533b8d0eb14fd2f3e9444d7287e264969e8c2a76dd924f3bc83d95660aa43c67d70fa1705a0ebe3d55586d16d1f9d329e013ea29c8f3a981d81ae1232e58d59bfffcff6b66a4e673a547c2d1425c6fa3937672e019eedb40e5cb706951b7c4e48f372021eace5ca625096cd8f0d7740780b8ee776f669347d8f314b9953694e9045f58cf456761f56ecb83db71237839b51706703a637178e612b1591f92980ec6f652782d816d1360e8a6bbcf2116d1ca3f0661c57e1ffdfbd3ed7b897e077742cae207daccb2f1b087b4dbcf6b27e4a69772b1c1055f01b8435f4853dcc2defe5f53972d78241dcd9bb0a47db5f59b04acccd49689e18926bb71f4ea49fbd80b9bde945c765fafef00bfcefe4a9f92f14bccc8f1e97986a362fc0dccff79fee7d6114d4962a8f05e6992b46ce5c9b212e086e6f086a73f55751e58d6732a8115a98f1bbfac85969c7da1755bcddefccde89ce0030d05ed5b6d0716cdcf73f4e4d357ef16b0050f41d5928d85daa38d1100cee4c1da6f084edf3e0a5bed5a0486640d237eeba05887a0ff5514361ef039c2eff3869a61b8e5f1b1d0e0124748f346c9b494685144135f575e09883c92855a66bd0dd71e903f37b3ec1aefefb5bc19c990a9324d4b965dcca5be26e5e65893f37bb4a0791709bebd9c9b5d55a060bdce3587da58a029114f4d8f913425df249427acd4ad3379f7290943ef9aee8bad7df74d6c3268a7d93dc7de79198a24f5401c96f58f44b078c6f5ef6573260b31184bcb4b74a9b5b7e554c950a9ee77383bf6ae851d7c30704935c81554867ca3ef0963d99338d9cc6d8b64e1f6b2b0cc0b7917bab4880be4e7dce6d8ccfe86469989ce4acd5730720c43231b8ae6d31792cc5b5755b7ddf3a2486c7093cb03bb350f1f117ec0e95ae0297481b3567e9ede83220f0f8d37be4cf6ad91ed5753665fc72e1e18ed28e968365eb16e00ca47f3ead2d1a4a48c318b5f538abb6c2c14bc395cbcdc4bfc6b7818cdfab6df77abeb4d41541733c47cd509d6b3709081c5d1d30027ced7fdf6c0ec31cbd035c492e8fbd0577420188c879ae4086e4addd7310c144afeafb738a6643ac05c317aee6b5cc8b4a7a9aab8d65ff4b273350415fcf39da862613bdeab4e648235753595d0b7a129fd3f680ef18a8b14ac9e606da532273fcc57da3d626d7c8e91eaef41db3f522639ef4cea5c6605272ac95d7b89b4b3674cad4257dcb76df6ef7f660a14bbe90305cbb0e89f389288dcdaa985b3853fba71aa8dcbd80badb94d128207faf27d55bb6b95fb01eef9388ee756ddd7fd5c8332d78713aaae54aafa4853dea6532098dc8036c56e15138d1b966636abf558be71b0eef13d76e197ceef30b669048f8c640359b7afce1531bee92eb9f486ba57d83febebbcc9b3630248ac811581610276ce05b63a7ee47d3313cd03a8f8ac886b96fb2b5fce602db144dec888dba464597c02977ac8a72246c8f699d35c5c01451a02fd06afa3e988c60d2c77b1fe8b04909a6b25b63cb622c0b20ec8f5835180ee7e2b78006fa37bcf4e07cffec6c9e3df1ef74a55c6c382c48b81ff3e9150156d3768e2b942fa19acf7cd897a2e22fff38f7c269d75625eda996523d41a021807625e70865e81f21d17ec64911a8ec501f0664541761733d44c0f944cecd0cbb514e1b725013a84f85c5f6f47ec819275cdb7ada0c36b12af3c1f63a027fa2d16938f52fd8dd70390fb60cface64b71f848c3bacffac65c2b6fe855d8a8e12fe1858ceddab50e5ec2a4a23883b43b9b1540a951338a971e7c8a2048bf38ffbac72578e7dc5dc407431ab9a04eb5f9bb2644d8a7672044c65bcba6c38845aeb0a59b3d0988bfb6826112fabf156a8be97bd5c1fd42fbf8d01e76c8d3a22349508429cf7ab35de8fe73dfe48aa5df09b6de1a9fa2dec062a586c89001e234ace91755b3b26060255a5d90221eee2360d0ce4c7b555eb277ea9734fcbf005ffd614b6ddd28587ea432cc553f6874f136abfa0625198cf1760e49861648c62219c2f92fdb822f6199518a25f1fa6b86d2b45dfc8def6da13e20171cae8a781bbddcac4834a51f5bd9598e1c11e9913461e61fd277b635b03c22b00ccd4c787d36f3a8165cc07402ab467b7d61daa03ef2b8de56a004aebeff954e1d1e58697446a2147207f3a03b7a6aeac5b472a115fa8a7ec46140c68445601a7cfbe9cfb84c344d5b9ff19684c8643d78fc316d016aec5d7ecc5c3911784181385a732dabce3765df1d63a8fac6dfa1f74b68e4e376680175593d63a3d6c88fffd54279a395545519c041230a967fdee98204b905a08291d35d4931f8fb17c5b17fdce5c31542bc559926dc69297cad346a1a191d2f4143ebeb87b6d8000d1554eee943b35a03f4e3ad5ecb495be1f7c8b0a9e0f46fd0976b10c3637ddb605fb5b965a53e34a04423d31717925283315cefc23ca5c3d298d69e8c47f354343144832f95babf2a532dc16bb9827c584de6f3cbf38d1f005e9afe6acebac1533d584d75352db2d938936b6aabdd2e7c663f04997750b4f697b66efb6985044a1af7829d4a67243876d53ea6917d31b122600754533a253aa942861504ca990eeb903c87153f2da6d98ec30b0b0ffafef87a60c28e01935b4d674309b893d8dc1b652b2d478975ea53529f6a30c136a69e57879914505b74a585c0fbfdf0cc96206d0f04f29d3c6d792503e13a615e64f2ae7693bb9be938303a97c1e783c4a9d5fccfb12e2a610e4dd71ca280967cb02f6ef7be629a0901cf1b8fbfdbea276e6d0ddbcaffea592e2f81b4c5f9bea802e55f88dcac50bfa9dad8c07ed7f6795dc5e3be29cf7a501e95634aaf1bd5fcf01b0491a837dd8ca87a4c27badc6de32570e8399e309585b2421d59c55e6af6825fb374b16dc1edd1967d7c619ef80d8f4d5a29c06ced3d6c301d8fc8236f79208d25fd36797346ade5919f468e715aff05be5f62a88b48e57590af1e36bafad64cd33396532760f7e3cb0d4b542a081b948968b73567f17ca04757cf927867fb21ff5ea311daff951af02f639008a38b6cd97fcdaa9ce4fba0dda324d4d2465ceb614e212d3f3f738553d04c53370a7f8dee473610a4e334aa8ccfcb7c17328b854261c0c18b97d2b8be90caf47a3790c2f6798ba09b99e8addb38697f667092dbfe16997bab1b363acf522c2b2a708cecb6c20a9b549d371750cc83e5a8a2fc16da72abf027d77d864f34f0d5a5ce03161636fba78a30ff8840f5d967efe11414e9b8b0776c8e1ca10f411d4529ee51221d4cd58eefc835ee8b2a24f2e3d4053b23180fb346468430d61fed3da7908df4a9c51993d9980958bf46f56dca90dd96875340fdf08a56acc723eefe3f23a4f449907ab6b06a328232af1dc6c4baa828ce07a2a1d9190f1b610efb00c5d885d0d241ca8ee4ae76717c1a8941a7dd86a6c65650b4b5be4b26804593c6742e286357f91d88441fabb250852aa7cd06c78e5af6a2b02a79634f487b13a1e0d576b79ce991bcdd6bbb49a68726a1f332487ab500d2a43086b6d38cd24736f0638e2f6368d4e61d2d6185d91818e3990668bdebfd1eb80ddadf9820e17479d3f6cc28afbc197ff29d6097bb8549da3aa8d3541a9e7582e11c6d7407df153624d98e6da08dffa1e3c42e67e29f37ed7b1a8745efc779e7eb82ccd95ed9278e774b732b9933723ffc46ca0ec640982a1c416f43f41b393646f71928e41063409419886593de9de3a7c3c93a64fea28f2ffcb82b6eb6e7edea8d4b565c50528cf0a4c1621dbe061084f5c6f848ffbcca43228c70704aebafc6cdffc75e54b0838f8da24168c5e608262003865cd30d82483902bc2997b49a84253f729aae0bfe286fb793753ea3b05df86bf49aa22e12a1016aa12f46bc70131c89c58ce57bdc21fe2a182b7780cd1db604ca064d4bba87692b07894dbc8d55f4189651a2ed57b7e5fb3f3a606cbbbc85c8818ba71e2d20e8aa242e7839273af520e5276f5471e44b26f4ec27381f14ba31cb21d7a44840db60cc4170d8b1b4b7f2f9bd4e5480c096acf036c1ef952570157d55d6ad2fe988caf2683ef529bfd18066cdb527d3bfb8c2f4b990c3c1112894c143d39f4d3f3d4e5df672280ed280e8f31a490b124799f38bf8ee03b4068de69bfe5b436b6abba55a7955af7d6d40ca2a62f0861009cb9b1b2cce037c2be2a349351cdd8de10f5239d5c8daddefc688d308f8bc3f2f1b197744d7688a229b7df314ca3c49859a2a37c2494448d3ff8c05faa39defeb9e28bb2fc31389e7bd9bfa8d920e69d1f1c163dbb3750be460dfc91dfe283657dc1dbfcba80fb08dfb7c806dc4bbe18cd672a147f5f74453450bc302773df71dd0462ef25a1c4d91d4d9529283e9701a71bc46a3a4b57ed39b20009468f0dca50590fd6d9411045165cb83e9c2fdd32ca8fdda73c853f49daa396d7d90c0f704b9f0d1e1bc7c322c94511d523eb8b5c426a244f0039ec8191b40189b80f90f03e7565cf4916eacd8753576be48cb8a4cceeb1fa5566b1531e391509d027a6ab8f5c80879e39ebb0eac4a00acb593e50156a345746414e6f2d05fa23e7d5d7bc7260965cfe2b77019491b433155126bba42639604ea4c20f5ab54f6866870f563056a5c049f820375486105a3bc926a8b1181b6293b2b01f5cb7145e088f2683e1d608df35c4da621f16eb4fb5dbb21270f86e5af198b50e72adff35b879f9e64172e0a5cd3101943759b15b25161367b6a3025cae7d59be192c8e4c5710ef0c60cf858ffa5ede7ced68be6bcfa97a411e9b151fb1d817ba2400b3bfaf8707c407787463485ea7b04dd450583359f5c8aa80d8e7d417058e7e06c0a25d58b7db1e9fca5bfeda2997e30d7e8e81005d4dbda7792a43917e5621604fc0e647ec2f739e6dec0f562aca2af387ba220df107385a6c756e58f6702f6e865325975a60bd9d7a482929666c18e7b8166b93c16539757343cc8a343f0ca5d11fd7f81ecae2b1515f582a46dac349b0cdcd2fe4500de9c0b4a28699c45a08d5099eb4d2bc79760475aac17600fbb4991a441fd6ec012de0149d1e8c042a690a53593add01562b416a70eacdd706335d48e7d09901cfb041c3bca8310d90473d9e64d7dcd9f9034f8b499a754b398e157b358003e75194bba464af4a4cf65693366fcb8db29a9f46d419fe9310f8e42130888bea02810bb1e681569b53c139dc9655a5a1c44782d1a9aa6b17d755fe6e0912b73ef720d28383c3a8f1f0e3a85d788f3fbdb9d9df2280e1edafe3ad7fff0f8d5789c446b6112cb87e6ae745a4be58b723bf566951c0e26be0204d0e299e586290a1cdd46c61353ff31bd5109ba2fc98011508665809e79126eec0670a5dda472d039ddb5c98e9a588958ec64e705e211aafdc6707dc013c53ffea8eb94a43530a5b10f90cebc4a1575485a5bc91103b62fb2060fc9e80a39c2ec4e0fcda91ff303ec3e4c3504fc0d632aa550ec5faeeb4cd528adc847fe6ab545097c28a7e8b861cafe7266fe64055b1d88eb4b8ea9311a4cf19d3042940654534538f60b2bbd3cc215643b9abcbc8cb1884abc4ef2c8f8e77587b122a98466b96584efe3e21591194d84dd9c7cab47a6260f011a8e0e6b4330b46da5d819beed0ddab8d150ba8d88a859fbb541d0d7a3c62b146f1c9e731ba6cc2dd1d6b0b02b17b8ee46a87c8aa656bf0753f6fce90237d6cb3920bb306d908f1d4dc124841e0b9b1d9494c128f5af6f1a8511d34f3d961d87eea6110a1db82924749129c5fc6e5d9e46f810e351ffe22a8e8a6ee64de4134c3b440e17e78677eec21ea05f97c8ca4eb9fae421c273d7254bc3920e7489097d1038dc0e2d31aee02815f73a904c976bacbbb06b27221113572338b2bbc4e6f0e4c28fc936fc6b8338d96b829d8d892c7a168dd983df219b3ad2fa5a66e11fd102ba5b1b039357df8a4aa2264e2e348cfe40ad68a40a8874a205fa5fc3ddb7cba4ebe8789e289c575ce1b01098c8cfcff765404b7b053c8b7722b1ef91427d84e48a750af4d72018a66368dc5cf15006999503cd36154599457b0aa6528274a742e2e4fe7dc0af14fac02efe672a8b271c9b000093a2677ffb958a5fd253f4a2cde1fb38bc24a459643a1ec065a010bad49c921a9a6c961ff7d4df3798e5bb3e10811857f2827593782d4ac36d48e5ea6021494ab0b5be114b2c160c0a1fc3cb11a2a054571c55f1269122e02c9e59f7d1d9dba0ec6cc21131b71d64c9d6eb219a05ac7c50b3af9078d41ac893330b1cc317340ec0af7b1d4eb96a3e355e48c802fc467276ff36536d1e46a20ce6b08f86472e7d0a3cca591f742eaee45a053a3a088958734e0a6e4ff3710ea29f5235dfd319762d5ac998176815e7f2e75d6d251dd2b39fb2b10e37f8b066d73ccb128ee61a9e06ed8d68548485674c9e8fc20479e595596f86ae363188a506cfb8487ec21ee53afe4bdb46319228a271d9a177b5a7cb2fdf50c882a813ef66ff6443937c8de90f10582dc1e76654d739020e52ec7ddd1a422c49e1334c10c05a96a2e5d95980ca40d23908afc24e8d67f73cb1d2873304438914810098bd0f94dd49d1a668bb83181fc142e4f6af9914e3182b8a783e99a17a155c570d9c7638a217a04df48bd45132915bbcc2f9eafb1e2b37ab1fd645fe4afe8adbe793af8993ab5d1128d99f0c7bd58ee0fb6568446536e6cda18531295665ba08859868519214500de6c05808bcbff20877c83da99d27dd6768b16e6bbcfbc93a618747190224c2f97515ed5aaf13ef4d64e044123eb1f8bd937da99a74cbf2c30a0205367b52c1b85cc6ad31f5501aef0ce4dc5c1c354e3e445dcb746b8772a09e3945b6eb2f56cbcac1b71eb283bf611d466f6230fa2be9143dce90a16e461c48f5bda62cb0c3a1396f3246773302d512863517fa2742884a9454a201fde3e22cd4d14c60a7a91d6886b48c29fd03a0f300adb82b599a725c0d9fd57dd8b5b0cb5eb3c15ac620115ccb2efa9224a7097044f18156eaebf15a0f54e3ee94d3663a141e912163679d1695edf17d0dfab48781442eed0a36ca4c83e7c908463cf06f280b2b90d9264c1e0099dffe504bfa24343fd428e5e9afb430050c0516641cd41e4707f8dfdd1df847d964d28e5866284c47d33762de73ad58488d6f1a9f0b3cf6950a277dca9dba770a195abe83a150716f58d0a362fac624362f29e0625411b69285d78469f3cc51d931ee964bd78c16676b2c5d2f52233772d83e5139de6ee75029be6aa94a21b101c27b8ffc4d1668fe089de0a43669be32bcaadd1fc4d07db769cf4986cc7f5abdec814a0c91a930483892228654b01ad1787a98d895e9a32b4018c30e46ffb950816adbb42f0b54b149e1eb8c36f5172b349130e03f402cd0c185b785415f925dcc7fb082308e2bbd6062eb9286c861cd7be9274b286b91f17376cf6f26da6d384687aeadb9d4b6229fdf743bfd01993369fb93bf847a598df500c63af210236bc8fca439f306af0e983e3ec2a7e48078d281cd253c4379ce40a302ce2f8e2121d92b094699700a48bce5150c10066792d2a2a0e65ec81287cb0d49d3a176f1613aba2dc3d52e5c7d6b7b71e8e8c3cc3304a0c2107abab7b0749a36aa3d886b1d8469570f27f73878ceb5b62c22e933913455677675417c84e4cfe9dde10974d49d7ba262b7e9cfd9c0bc69b5a6b991ef1f61fdca7cc015ce29d70860ef5822d356f5d12289e7afdae3bbedc7f4377f7e41cb501711ff13f00da20b1f20c5b02330d5d35eb8948b602f750d105bfe114a3f09304d4745f85c4275f356913f765eafc7fbc81da07a08fb75d7bb1cb371078d84804b9cfe53ad02bb50e32fd4085338ecc2a2e229d7088bac3d81862e1547fd22c0ee4500301e0e323c6253370ab8044370270d2ce72cf787bcbc959b8664122c2cf77555e7f56cbd0f2a35bfac17b34a23ed402ba2979ff8df20863cd3e7158df2e2166d318a05394e5ce2bbfce54ae9415dd79a73b3bb228edcb6664ebc01afc8944a05210fa1cfe770f1245ea708470823d3ab400a68c4ddd13cb92c3be2dc94d5eb647b61de628bc11d5a6bd2b27f0d94a503ff4292ca3711c74eaff355fcad89d840c98ad2ea2f1558b57579cea6ef0ff676d413a7ba18a2d6e53234124c98d7e3ef0e67e1a45f79023e17398d2a37086f92d07a53e48afa94081be561dd9fe45d04cee7a9e3ae5ce034ba8638081c95f5610e8258ed907426734acba9b3dab0dfcb3aedd3590156442244e12a5e045ce5e80e889bfacb2a90ecaa8e94ecc2e3e535716ac8533b371a161f47f3fa9150c2509fde0ea1ff3cb65329276488ba8d99a87ebe641b5fc96d2e0680c393e0095c5489d4182c8e979f1a66da6eb0139db4950bb025c6c368773474f25e98a68d44aafeeed6e6686deaf48e1dd4e8ea81695649643f7486b26c6447b1b59be346413a31944297453688655bbf65c629662dd04698d4ad2d9499d45aa83725d921eeb0d4e432ef094315d79d91f84a4f618be4e577956f5c6c9f66b49e700debb25d74a9467ec74bed2c8f331d7858bc2673e8fb78be2f602675f464fa5e71d5ffd5a9ea7b430bf98fb4714f1b3e3cc016f67ead34b88ef3913d762a437db37f5e54c7d6315d72de7ed598b9762f0377a31759cc653b49bcd8386360b8faaedc53be1b6646c2f3d32462f22c0a4b2d736979053b387f91a1d38fae831203ac64cdcb08321381810e2adcee7ffbb2a0c579c754737d09ca40a6775d9114e5bedaafbc15e2b0178a98eef65fd1e489035e2206875e1cee54cd693040412033f326587c77e84eeb720b7b91f437de323af15cf8aca8d0d6e284aef295e4fec3c28eccbfae6d6d7f58b9687e9455860a0bb03d85ab576b51e01e1ceb56973a86c2e11a8a3789d437fbbf8bff73e51d51b3fe9d176bc5552b8e4f9e738b949471558e8957ecd83b0b1a0fab85b2ff25482589b9536c1099334a5215e758dcb97a89ce631a0289a9317c03e8291648fe1402e8eb37f7d9e817873422786dfc5d4e6a22d6aec7e55184892a6596826d160a025c8e5b8969b6783fb9bacd6c88d77eaf93ff39865325db7d3e049690190d762580475302c2990c0ff1d2e94efb8ddbe4a8ddd44d34d219d6fae83feee4ae76e5344163212625e8a2ad16f7f912fdf348fd0b3891b693e4b26ca1221a690eb2a5890a7747c727f9b2d8177ab74fec58d601608997ca7a617c5f5ccf6300a875b68d8cb8e8b8e88f6c99f99f44a5de790743a2cc9512103609c9d01adf73deed5905dca1d543504029889a44d4289883cd8b1f09d2bcd212c8fa6a1b012b93b4be9da3d282a1882b5cb887bcbbbd80a7e55f8bb7d5622e4cb58666e2b2f9fb66abc7cf68817267d7e29b076bfba4a17d1fffffa8ee0dc1884b70fa6fe223f2c80446ced8175f2fc6ab54f9a0e2887ae5b79d7b3e52fb5472aa0b787eceb07b2dfb33b8176de41e8ec7bcb224321f15e96eaf6bf909ede02b3b96fa8a1f3645011af70ef5a3ef8894c0f13a6d079c69d79d3586d98b8da51af20fffd56938493028e27aea2041b77315bdf9fcf05be1c2a33ccd2b91551dc5349a2bea78ebce1f28c706881f7c3a4815c39f25f8cd1f8b457ebd809145589a94b548dc7b82692bbcb1b2cd77ba1c91851e3cb652119ce81fc37fafaab3a4e227772e1301a62f71f894c140e131d24894331ad1f9a8693e001135ba736475b6b40aac7d393fd05e1caa84c12663d19f25a03a3fe323eaee099e5fd383af99a93f7fb205b3ea13375edda72b1b8d4e2a92d457e6e43f8c3d99c4a59e38bc2c2ff18a9d5ff400596b31a4a8da2a55a0c6673d5ab2e9929976ad8bbb22ef75c5f77ae288c2062f3ffe847a1720b924055a3eb69c509c2fbe7389d2203c2fb178dea7bca18b49c56f81dd9bd5cbf3445f46a06b744c027b85cdddf68632d5a41f32a8cee106b56d7192b698013d4ea0e5ac347fe58beae12cd4055b76168e349a6f7f13df230bcff2ecf1e1f7e70eadca57d4f3e7f289f75fd2babe239c08c4a73a868c88c65f8e10bef00b3db1f8ffaff8f8c75e256781f487c2e29cd576365ee9dd4f046e56faef620a790b8d7fac0ef5427f0ee0c2bc3cc3ab179e6610d995db81104a61ae41feabe850690d5327f5cd80156f571078dc9ab60b94a9a1965f5b7aa8dfd477265eef21f230115976c7b221eb84292520e220148d12d5b08a47a47921320ba899d05e9fa230597b687f6ed994e6e8c65ecd7e0a83f956a186284c6134db922436c32352ab1abe9c68d3fc91487291a889719b7b04e6c0337579ac02f7debead4fed7cdbb6e7ea3c4f72cf94731040b109c9162ea11cb7562083a840a944aec49568a7d2cc9f74f9c4a85df06dfbba74d7220ffc44b523b081810e4dd83fe1baba75643bfd2ef519fb6c2ba850446b2bfb884b580ecfc8644e35df30b61007dd9bdd2697be872eb1cf9ea9d86c4845565e51987f11f4fffa2546e04392b27c610ef06820690d82e04a4191371bbbc0f29904897cfc78bf75cfeae1e7eb3bafa3e6226df6907f4bc86dfebea83d36d3345e37742b2f2f1f9d979450cd225a9211cda3adc27cb642544d78b024c190f9dd2bd872d0e62994876ff7b5304b32b68f88d3a3007abeb0171831b4b1e84fef03800dd200de488edb79f4e9156eb77a21dc7d0d318bc2a6ea88dc3811d74edcedc49c69dc3a8e271398924d31fd5b8ffebf17c4c213edda2ec91a01de6fb09be2949f4f35d2186c2705fb0d3bbf0f0d4b4093abcf8cd0c0f5c95c7f2c4c1bb4303846cf48aaa7a59056808af7d9231abedbf6a61d41f22c51dc8fc17207ae529756769f4637a3529c2227155a4171db6ec0b23e3eec8c4caf20f9a30a95bc223d234a1360561df1baa38d0fd5c359d0795a0b8ea483add2d1ee6b41c5d7391568d0c57876c908489cc85ab3a7de89314949053f6bc596c9cde051e686f4d7632c4e910f376d33693008e2df479ab84ddbe2342e85273539f89b889b98f5d9d50b94c569dfd6a8e1a15f0a81f2a1a66c68fe7e011176e3f0d99926002478a4a836c53ab9382f58ab68bd086ea05e243783d3253328082748498f9be5959ca341fe87f89d2bbaedd174fc780f09f92294df78def93d7a96054d292d9db026d4484372a00d1fec65f29b205cd42709820632c9ffe15afb2b9e7cf6ef37c03b7f0ddaa6a85aed4979cf149ed1672587c3d761704fdf88d5946e064d1996b0a4d59ece02dfce9ff7053b474f47f30681a2b1a41ee7a180c759e25c1f12e3ad6b45e7035855dbdadfbcd81d66ddee3713068a1ac34ff3d34e6df69060fc0511e4c7d03f7bf98e9fde58afd7a22dcbffc1b8993b5780976e66d3e4ea5d15850f2890a7b5dd59b2700e01fc9076284a628c9a442cdb01787457fa7be097522c86970b802653b3baf382d1c56c6034032de8256c9a988a6bc57cb05240374266caab26a1a80a6095d694d09a0f7aacfffcd67d1c0a41e665e4e224c7b6466fe1f76ec80acef3b4a86397307e339391c5bd98fe9895d16a1a34e07df35e633d51409b13c82cffae24977be803a5b6b9ed2ffc85f8a4ec81233bf9df39847decf5e91a5ca0620f4ce25cb17096fa8c3a76ae3732010080404bd50d7505c547f7f40e94c59c2518d94436a60431f612208d5c7b756eb6890a160832d04af9c776d36fab9c3369a7b265f0493335bc83ad600eea5e652c61d6c0633a128ee025a513acf6153dd2bf04c388fff90fa99fbdfa3fe341770325bbc19c4b42d88bd8abed8cc6fab24c0d9dac97ace31227d3f84c588cb0cf6ffeb4b7ee597cb19b675e99c3a46ab8696439b690fd271f8795a01405896f88c072ffa760fe27470098fd12c6e375aee355c3100c21cb7d3a8cb98770b2c434d88de94a2825b33e442ae5fae414cad26a037217becd58cc5ed90b48fb66fc014585c1b533addb61beab280a9aab406471dd2518a14c08b5af58f33865f51e1ce2ab5f86c4a38c05f43c549dbc3ba72e3a4253dd22e97a6a52aca4fb67709012d15205a067bda8633c26057ae695fdd9d98ba6e21f1344f747347acc64d88a99b63d76580fd5b12a7f3a508129bcb85b1795c69a2f39a4a10cbe4d14c1a2b5308e4d8715d1e263e0e1c9fdfb0aa30f925e21fc9da9125627b77e51cafbd89f1099559b33bb02fe34252f4c56f472affaca2d4f4771e5c80cde3ed5c53e81dbce6d4175c44991e1901e05272cf2efb09ede185580ab86a1148dba21aec07688d1429dd1c823d615f7b015b323c4155cc85feae5a843e72ab194c48403cc8473922b38cca0c0e13f420bfe30bf3ac2383f9d341475e7eeac192f9e1d50a35c7c893edf4c226d422b8079f077b9be3fdd8bfcd1533af850b12e78cb1497d2c47b1e0a1a2ab7ce72eb8095222f67f65b14d3471cf7c24c53688ce4e19d47f6076c22c1eb30b743ed202a7e9d2327bac22d6c7b86f2f6ef37ceb8d95b7e187b2439cd98b54aa9fd10a27a40d4b5c7288b64acf9e20d15688887781e8673395813e8c3f319214cce00ab9fa37990d9806d4df3439d567e317e72dee9d02604bc5b95a36cce417e455cae8e7e9831b82747455261af1787492bd72a7143d2d5694982e1bf197559365a2dbac6830c7f81a85bc3e1ee7e3e0fadcb4fddf3744c45956357b7eca58c1868eb36b70396ce7c6fda1c6ec4a985abf7254551bbef0e022c6d24095e2a8eb6f2f899dcb5e0528b30aa940bf47f432eb135eb18ca1ba7abc748089a37befc47fb92d4640dd5bcc0ca3967e173ef40decb87af775d9ff4f2f11c5a10355e413f8f5eed2efe68c8be061adb1e9da4d4f6fb342eba1b135ea72aeda02efba3c3df67fd5c39ecf922e003db1f088fbe267d242c2806006834e5e4e082dd6659085d3bc7f011f3f2e5c5549173679175d51a544acd1f95d432d704648e4795e12d4b566d5d00ef370876c68ed477b6d37e17595cdc9e98ca240c099fa6db4b5a58849689a0065cf0dd944c43c70b7d46f77405b7f4ee2635764d1a386143f232232a17050988c3e274c632fb9ae44f80a2f409f0915ba129e36f0901d3f6a803ed694ee41bf9aacc06dc0b61fa021ce39bc3c503b70ddda195f4c0dee3091c2e5da518d5d4e0251e68e069f49e2c40b92210587b70208d97e8c48998237aa8e8dddcbe4729e4b784a0934377562dd7f2ce597caffc6275dd6b1ffe3f3ce3730839497d2dfe8af8d3037a53cacc3df09ffa864c6f2f1dd5d1fc69965123d7c15c92289975c13e9a524b5801e451e9a136eff873dde3a6730240b5015e7c53b4c5b210ab53c9523ba5ebe0aa60191aa0ded145ea22b15db2a73de25a6c5755a9a340e51c3d632be33fb2c60a17abab4c3f7f2e111b4909d1440e69b36c772b28f549fb06abba9226eeb0d182633edae544a0d6cde4f1032d75beefcdf93970b8c84229c3fc37d08a9141b7c5c9cd1c652ed588bbcdfa0978322ab1e8c52ea6e65091e7e89ca35259706440feb5867210ff2687e1a4a689ff105d995e901a99b00c11d93d57d63b6d0090805443367c80a9cd9ece8866859eae785f1eb3d50bb23624b1df5bcb6f28e3cf92f22e54b189817aa099ba3cb4db26e34274107b7f6ce140619de467d9dc4f9088a3453125d57dabf94963204e7f78e7d917b74bc3d621702a71b25e16ad8a920fa9128ceb141931d773eeb09ab1e9d9e2969ddcb34de5714f8c184c194eec874d730c222a6914db4b956f042f72113b46b70f5a404dcfa643e257375b20060984809ed88524bdf653fa10e44896ab6e03ce054a96cc957e13dcba04d54b0f15e52e48f13885a446c99f8aff184085b08dcb6d37c1efc3d136984c05bc1eff373c7a80155bbe5e58a246a23b1257f311e44cbb77e43a3e878f7c5beca251bd70fd0e38eb15f785b64f219532cb066228d7ccd388f6210e708659284657e81836451153b2728a6d032d118818b781b51140f0c982a5420403f8f393311dc19e0f7884b3dcd8be2aa741dd2bc851044f7c7098b770f0251c8444e0c4191da2d248cf43c70d86e3dcc5cfd461963af28e7022f56681162ce9322124b78292bdefa6548721bf2076885b7d4e3aeed356e0b15ad9917b56b061574f456af1d2a39be2e032e47d851aefad74042dcfbd200d932b275e24e702a50bbcd3efe8ee9a9873c9771c79e11c066061dcfce65bfb71e547b4c0a57c7dcc92da0619d9aa626b2498a0649fcdd8eaac76ba17df6ab742b1b16bfa282934ccd6ff415c7b90a237dae6963d2eee5f832b3790ead74e0d00c7088088281e5edd9abbccc20dce0f282b41bd280aab31dff832c030d0e0cda4ec71be76d754abaca1b4a8ae100c23cb463884012fb4941f5ea143894c4bfa6f201fd125255b1fb84ffc0be8f11fc85d07abfd272ae2234a4497668c68f3bb257e953f13ffbdb9657f21c072ee93439e7164fef15177d591d94c42672ac302f4adb25d9851570d484c080e8c6c49bcb9873fa699c872f989f82ec60c5a6f1e6253ce9f9cd330791ebfe37fcb90afe1aeeab6b730b60d2241d2f962f0db9579443e74bda25ab5f5196aaa93afa2a27bca830ef7796c1a65a8482a1529f23be63944bbd062df97608930f3386c58ee00bf07c7d17ca59fbb6c52836b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
