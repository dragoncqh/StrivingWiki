<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c764f7586134cd70d71c248b7e16229ada9d66a08759cdb1987947d9e5be2dc5f41788998408a40dfe44923a3f8c03ebcaf7e5a0592bc075825f1e0e3e3631248b08ad369e29b0d259bd4a3915a7afa748aac0cbbe3d0d8ec0111bc6f3b5f4092a648fdfab8219ea7788cd5fc46137c5b7522e0ce2fe8c566408fda539c8b56b99d1e9b090b7c338051a6d4a28b646697638700bb13fb94d282027ce2de7215fceebe6fbb46c0de04a0d9c07e71d6049f0169de4be7fcb604bbf72f55eee14a5cfff3f9d49ee2d1bdbb4eb40582930aa39d9b778aeaecc622dcc380905cd97b872801900db1f149ccfa5978e8ee4ea904810089c83c16f210feb6f460be24e70c86c9dcfe2ecfb1d5b82a336663dfc54f8c47bb2111b9e0256fc78c3d698ea372a04cc7108a9997a140e592fc99ae2d1d1835c9e096c3f2c6e7397506e2685863a9e694f997a76a4a1ada6c60bc8fded1532b3042dcf4526210b4ef2cc821193de49f5c314075d3390bd585888e453ee7d926437869c26c930d15b25a2f7725e7b46113e4452958982a131eedb9d3143d3bcd06069a4f697c4152eadfbe3eef684ba4304472f11f9c1c42b1e34bb156eeaba0f1744c5d5c8cd3f5fb1e3814b241d9756c3d0e7dbbd2c361c3ad03f3f3f473844c758f514c44f8e7cde57988616d82abebba175bae90c3e97e0ea26b60ff03ed230df06e8b1a186c57f0e476c5f064aebde845b2aabcdcc3d2d17eb160cd97f14c4eb63b845d2e4f4dbb256dd5a559daf204d88f71dc6401ee01dd55c51011eb8af51b070518e7093e37c0c404338fc63b59600ddffa566ef289c9e02d00623bd65834314e4b10b6ab55a6d84a12c79de387725c13de03c3287e845f05e2992141ce32b5cb6d35bbe8c42aec1d2049bea8eb04369da5c2462e62da82059db46fdac6db5e34e0bd09117039195c8ca5a0114a2b30251b89af0fca15116be27baf560804557939b8d1e2a3af9ac9523f902ba5e9b6f6ca96ac738a1e555781753fded2789b43dbdf325e34f2d845a61987c115792d12823e02ea899bba00a1caaa3c9b2a0e6e614f073bf37b24cf183dc6a8fe431ea72c30e33dec5f284636cb02bd04658231cee9d1b07d21cbc4004387dd51aeeab160b45a4837e0c657060fccc651087adbafd8bc068a68a1e9118631b3111b2f78a1a45033f3ecaf6eb716a0b1aee84fedbf2bdb11e683adbfe3a132b67b3f708ab8772e4800ad4b5099f6cb80e770275c068ea2709ea6bc8ffea838db91e681042deaa73ae03d3d7a9e4f29cfb4b66767831c3cd1b303cb9110a7b4112b36c481093eaccd2d327a987ef1dded66c9e6a7fe516fb42de1f512d9f136f79e349a3dd2484127c8e4a027cca26fb7e6b530b689cf886f23d7b2cbc5fc060089fbd2fdbf10e6f66d5785f7c841d4ded4c175ab1b1318a17394ce79b12ecb1e5da5b0f8eb4bc0a01570433f41f4f9902033c9b14eb1d78417f3d3c6ecd4a23fb11bdc18508ce748232175f629b187206a6277a273506f13e68b96eda67727c767b8dbcc8313b8ce50dc96bf0da427ca72902f896ce827a3a4a6221b3d48abc30b2bdcb19d96631bfe3c62b3e325dc188ea9747b30dead2b566ebaa5655cce93a497a19156b2f604b568892131f78cb0ea8798f355ea3dd1933e5f701a627fbe889728c0c7daa93a78a1b97c95a2706dc6035f256c06243723cd2161782bb309883f77f24136dc4ddc144c284bf5a7deca60a3b88d296fa47bf05b05fa5c49e191b0649e0ef17aad8c47cae819c88aa85462a5c43591385673bec9dbf0a578d99bfd8548ae29573047c609afeebeff7ca63ef37e7731c411673ff6b50ab357f60e942436645bd31053d8f67754c0b49095d549788ebc409884ceb9ec48093fa4d7ce58402d949535aecb1973bd64629afee10955d971575c5ba3e8b4041448e376bc496df316bb23758eeeaab462dbaf23f09920b3c69c1a20eb8e4b1e48c726b8affa562d50b5aa20d8f6e9b83b240612cf8983ca4d339c9ddc34e7517faadeb3144913ebf6e3ed2257a8eb5520cf7316fc44810b6eeb2d4d1f42a31d5e76cf5bad744e6c722e558b66810e52d2ff74a12eec4ed79c1e1c153abdef3d7476ebcb97e7de4b92519626220005ddaa2c41bbe15447f588d6d174a7024d6db6985c129437b209041de05d60865f23384bca775d954d85a28ec847c2238b6fb3903caea0f4b74765b4b755a4016f59a5cc6016d90bb7564b1f23d75347253bee49545dbd0081ec6e328230d29e1301a9e114e7c7abe3bdba5e4cf1daee754add1ec55f47b4c46de586e58329db3934917907874abb95b8e0eb9ad7af8989e6018b04effcbeaf3cfcc9a18d7bd13a3fea34202b276315b84fadb1feebcb7792bfc8bddbf0d1864c151ff78bdb36e8593ff7ba00b33b2f9d07abdec23c5a15a33d34849ad9651fb4be46ccaa2529f0e7aed82f716dc9b42e97b188cc79f8c40c7d40a98be2ea2035140d17e9d465fed45358d12853ebce761591e3909db6256a601fad18312a4ad78932171ac43d89b707cc0923f7c577edaf11e52c9eeb496e83432f2dade36e4d66d416da476ed746a07e0d5bdabf061741408df9235cd658d1eaf2776a6557e61749a3cb34d395eb5bbbe7dd5661b012a305e96f7eecff29538383e876dcd11dec408ebc1cbcb3bb7dbc3da3aacd5dd022b402bee64917d38f5b36253ee73dc05a9ea0754c9f43873d9cef0f94019ee9f8b1409ded4022f839b2d3c2f08139590dc43339252489808842bc97995917a75b5c06facbe670e4130358f8d7fbbb296c8f0f615b5c8a5d45ba3d111916dad2c9e2f2cd59b5a046d4aa2080f1c353d99cefe42b90590d86ef895967946969955f4114f9975e6be6001fdbaccb7ce2947c7d4435cee65ac1a3fb085a439c39f990a3a2b859dd3ba1a65bd966330b71b24b795785cb41ab27119b41dd33b04e2fffdbe18158b6159cd5d3edeaddc3ef8f43be6a39e8197314145a9306a9625d7f5d2bdddd6d2e0557cc12dbf2a4f1f44f518c6becb0531d96678fd0efa91d11073f153694fcbf88775fd6d5d841df5239a3abf276c2cbb5c10e1d83dac40e1468aa83e59930930ae511c4cdb61f72c03b50d7612d0bccf2c3f421c6e3fecf2edd18e980ef0c3edf38496cb534f679ba939a7405820f04602360feddf1962c4af3f7c59e4b5cf453203672b1f69e72c998a0fe4169e980553f69f6492cd6476cee7ec5edbca1d635b8407e079df263e9f13079b7c5546fb42ac1086decf63742aabc5704572b70f8eb282098443e49673c8191deb3074c1fce06e6e0cc4cd05916a8d9bb8a24c4fbfa4728c532d58d138f3ccf9bb7d618d770a05a24dabb256341eac5ba4e2f30bc275bbb39a2b09afe649f77d94b3557cc26723f0fd8b0aaf925160983c5f7b74daeafab5de2980a8ba678a0639ad003d45736f48786fa8f0c10e5c7aa7f76a811a5e45b68e63a8b8dfb244f2da53fc6e32651df8833867e25bbe4d76855722711b6ba4fdf6f3310580ae7c749c62be2949950e5125ad1c70ba85cdf4add52ea433d1d3008c34a67a420b342a05b89629f72fd10eee070143f311c2be7f6f981acbb3ffb60b78d5503ff665844b7757e0cc599dae2dbd0604e52970551693f27bd7145d2ffe58b12c2eae5c8dfe7eaa677d88631a7f126568031166cea46a6fd0c0f56a171be45fea8db7a8cb9f4b759bd7a3e61b8e686f868babe31e4267076fe7e8637209c2fc8cd446556dc0f45c904780efc3ecce60b772cb1a585340129239b71a0b2f50fe293e5664c2de514f7d3c6d57a06336f5c4e4d054cfef061b4b5bbfcfefadfe2c7d55a5bc33186cf6bd4bb73bc0ff5801591c39885bf73029329fce32d60e0f4106cf1f474ec67e3cccc5f91faeac7545a340202ce438b0d408227abc6fef07a26c33e6b87df68e8c562c5643e61d3a701d93693403ad946e737cc36429823b842553257d59d2dea807e2455633b4d456087e990eadee53f6343ccd2cb9f4e287633e2e41f84f987f1fd9dd5cb90e0aea3bd988f6f7e177a751718dfc4fbdf9fa4eb89dc1583ce2bd90100adab1defab67bd138880f8246ab9944a88a505ec60a8bfb6d550f3caf72eae048c4860344766e51c3e4bd3750c744e548723f4156e0b25b2d98bde17dd80691ba55a1cc126b4e6c14121db016a0d3018a773b004fa3405e2305c2e142117bca31488c61c69b7757639b874c5b25f15674f9e79b7aca3a7ffe3514c20c9b9d2a4fc31ddb90ba3a305b0fe274d9a1e1044736dc831a6a47715dfcba8716b6756cacdf943522f8cd7830155e4a49d1709803f9b0975d6b5b61ea78dcbbc107dfb472ef13462ce6aaf164cbb77b957dff91890732e603138f8a5f79522b3c38c4fe72113bdb00a5c44b74a44897f423aba0930b9ecd3fde080792a4a00394c8ea719f88173c1ae8d424f383657616400698eb580ccaec24d649ea9e6ebadc3479347502dc8e62ae499b541a322a5ae2c6b55580c03750678bf5870aa89cd904e298ab562b351d2dde9f502ce33d3bbd6dbb432c3f8ca44bc335b246029d4428789fde1fec873ab383c89c00f1b59ab3f806741334b4fd0da354ed328bbd0a49730b56eb217514661229fb2b550332e97e8293fb67b37aec03af49e048ec4c482afe4a8bc4ec456513c81ed78b55306b6f33941133763717eebe2074eb83de0395aecacce8635dfef173984c9413c85cd8cbc7e94ad7c93df95c307beafa7b9df0cac3c4361748ca78f08e0c35bbb093e9ad4998735f9ac1a3b618b77dceb47c9f602eb3638a843322f20777b85396307d4766ad9bd0da0db67c1cfeaf4aec32e45058db285d921b4cf523b2978e387fb0581ed4c793dd6b115c7497d76c7b2b805b9d214d261e741afacf3ffa3db8766edbe3c3fa6dfffac6815d2712cdb2910930eed81f34dcbba092b1276630c4777efad7a3b92799c1d783518349159beefd1526eab1d3e7bcd6065c8c6a66374a967bc884b1f685f437ce6f8e4b235107009aca49ba22e0fb9d091374ab8b444f686c22ca34a3bd8b930fcd0909e3bf708e3af1e249960c966560df62ee1c167bee32a1fc930366ab8f2800b29c5171c5404102f936f18eff73d646e54a1269da82b0e8d5ae5d3b38e9ed7b9eae5d602df6c7400063966a15a31430722732155220c90359c71133811bac0d496d50358be7865fc02ec38bfa47eddb74cbb9dad062bdaa837ad05aec6c4f361206351380a7df9aa90fc5bf21a8e87f6a3b588d174520b86b980c5a83d697733a1aea1f3a85d446143be982e8c50777a7b27e1e9ddf4b5892ba5c9d9a75098d990abf91fc7dd2968d03135bc143d259171852b700a5ade840ab45ca8fe521e80a861e3bc64b6d6051bf2af4e703cae1ef575f887ddb325ca861740df781001b0025317627c725ee9ce31ef8ee45ad2631e7a429e97789a749866843f08b7b58895977310eae2c5f63012fb7721aa0cb2c2b993c5d1f0f4226580a8551c7f41b967b8f6c3bbfd795c7f21658ea9743beb67832f84ceb0c6f425432fa3ef0907e3ef6cc5bf99f30e368c6c74389d51c94a46093d97d0819ec21cb66434c048b6f17e2a9abf67874460779f831c522f61c58f6da41a4b4d40f896028bfeb82b622eec4569e3df1110617e0984a581c939244b18ea68937a8aed86b229d5a851181e7f5733f3b7c931b5133b1fdb91a395a6f6e704e282fab2adf747a1ddf91a1c6e435af77505008757779c1c135079d09a5b3271ccc437641224362a237e6d73a3f2f0480f0497c02a63d897ed15f7ae9895aa73f08fd0106e51e60797a6c3d98bb0ce19c3e08640922c81d55d4ba31802d3f3bc1778853bb4a5f1e64cc26b0551415699b404629f113dd01878dfddd9323b7299e51beefadb88c8521f5bf710a16b769fc1f897a9fc6efdfba64c790237493f8550e86187e9df83d04394fe58894b462c0a77f3093b134dba98a2350e88db6a6a060bb472130b1804fcfd27cb47fa4907f9d677f11ed0addcd96b94eaae4b343d77e38579656eb6584cf8f9b815ed90072c945ecda35cb0865d7cb954e2ae152f0d68a0b78ffce1b89827983046a29fcf3376512be16efd244a69bb200410ccac11c448c27cdbb5e979fd1778200c54aeb67446d8a5fa6a9b6420ccda27e3e09d554171475b9fba22968249e394e15e15c44c6307e0314b5d24b8caeb6a0dcaf9f5d886ddeb29bf3f181993fe7d350c4e55ee88eb50d24fa91c57fd0e11f7570be8e589eeafcd96275acb91f5d74dc5f39daa23ba23792837ea10ea2be49547290787bca6496609e71874b490e4075cc8eb2d4b00fd1b4ccd838b8124d8acea0ad69455c1d95162ae1f94a1dbcdb0e682ede32275a11c5371361c84ebcb554feae936dc3a7159f28e65482be0769fd7d3a82d0943a06eecaab5f4e38c1c882b9534156f41011e757d4c5b09d3f7d49a8b8a22e2a6a32f25390b62f393fe925e0297d9b19966407bb14fedc48fb583d2d3d6996f539980915632d0cbade44d62350ebd5cc76373a4de6a7959b12bb26b72986fa009b96203d3bd19286364c785570382947c7d4aaf9ff9f26190dcce38043ee30a11b09e6e4714e4b0f4c1a1117a57acdb28031c693313d7ecd0837148caee99da8775ec9867e9c401f4fef9c71198fae743cbf0949611461c24a1f7f8273ffdd84e4023df5a9b066b76b525f79db2c5cb0b327cc3be1a8b409f1e343bc3edeeb5d6a43d80d94d66abb31958f5bdd683c5fe91275777592d65b03f9b7a54d4cfaf6c37e0224b61085161f22c5afabaff0604b2b01d64ad749097b81be46afa4a1214a5d01c3336efc69c01ea46c159915105b0195e1632bfa9e0d60a0c1fd749e347ac1327a8cab9d16f50a69be97c2717187ee77cb60903e48a718ce376081710f0fb911c1b2dcd766554b38f631f7f882b489fe17568351a6b4182e7e8ce572696307e2dc352a5c52871ec57ad081290e068f38a05671cda97bdf0e19fcf99e78851429f9d9abb4428eec56258c79e0741487f9112ebb6c91c6fb844c909af408d41657e832a62babfd54c0d5ac67252f9a45369c4b29d6df21e5c4dd6c7216237f07a52db1b0fa9d6d3dc3acd09faacab32788baedcf08268cd659bdd11559563791b64a3cc0765807e872ce1c02d5f8afde31d76f8b4959e201293d281a4f8130e03e87fc023e96e5eaa10ddca4ff134bb7eb368e8046d6a6479bbbca7c86e81778185bbf1b2e04e7de7cdefd5281a01d6d8fe72007401247fb24ee24a8044b096a897ccf2767b4ec1457243ff9f5b31f1d6acf7ab4d79e06056be3d9341136227629336133dbed18330901195775fa8e30c3c5cfebc36b5f8ee63677661ab745504ff59773ab3127789ea177dda65edf21644fa3ca4b7d87ba1e0f02890614e9c9fb746722c95105be14ab54081b35a8c7ee28b2d164303c776372aa3f7374e3a918b153366a599a9227ebed99df15e98d7811b73bdb5e2f03872cbb7167c94306f304ce4b38684bcfa3249e50a8c971a3c5a37e404e99c928c84e8d0ad6bfa94401ecb62dd27cb0e7e2946ab7587a9614c6c53b6008572d7669432ae15b5491d634114cbf086546358f38481aa57126aa196a3cb3fe3d5b3598b972f45c664360411da2b1aca5cba8b16bda89b83c15e0cca62b9d6ae487a492250d4748eb976e2092e0b2ec1030a5ccf64fa91e1cd823cbbbf004d60472c973138640a49c5c7d5ca5f8122c469f76efca85ab4a0e8300a9341263d05520cc2a27ab9e82d0b75b9690535f1f061dfd0437c90c0f94bd585d1bc0f15a8fa2c60401066e2c856cdf9d6064873672f9674f5b40312e3d6e1d8398c2b615b9d28b5546130abdf7d4f1b16524d650f4d7e843c843cda4fe411f28f45ddcb5d02d5a1b597eaca26799603566f34db2e8f758f5ddfab94db01ca125136dce74075bd5b0283b0c9b4c2e73a3d64a430b146f26a35075f3c83da8700a6a54164bc3fd45319b44a3b313b66ae8c2a4a9c22b249990ba2abe74f80be70485f691f2e14d2e45e6884d8d957fb5c5add89536776ac25d2e499ce0b8c725c4f78890962267e89fb8498f50ddd525f133c500618ed04f22f50d77097f452cc2a4870852292d4219ee4ac4a0fc2eb34b6909ebbf26477e3f2020c4e53b622f47656f4e5139b581d3e0c129e9f05f3ad35a620197380e8e7e74676f9b70a9de4cd8176b1512efe2588ed692a1aa535c83948268563ed0e63b7df4b837a816019006bf977890c25326ee6c1131f28011407564ba72796394ddffadf1f7d0fd20a2744d5391360601d5c87059f1ca21bdbe9338aa27ab1438170b80bfad3c76870dfaaba0fe800f9feef6d4960ae1002168c4774b48ec7cb274b6931c69de3ed1c1a2c5641e74bba0b1fc52c180b5c5f6663ffa312f75527170e4d5dee0405ea6e97e124dec6fa8f23465cf459a2f3e07101e438ab18c5deca83ff2e55cfdfc18595226162fb39e341469544ce761af4e2fc3af50a12439b53b2b6255a99ae336b5161ca5fdc8036c73c9fd4a785d96479a94e6ff736aee32abcfbc47998ce874eb7d9feffe30cd51eadad2455cbc6d34c276695502727420ca95bdf5e245cb065609490620158f5e9a94fcb2e0cd8c202f95e12ac6683d7e1788d25f8b71941ace2bd5ab2e629268c6ba4a3f3829329ba49eb3664a7bfec0f198e3bfe269abebb52eb0fc122c6ee217c4807a0ae1feda0b9f34172bdc6b4fec5606eaf8f202ad9ec24f8aacab60df5d14519ea137648e65f5aba4114a3cd94d2b4b43d3083f00673ba7b0e443d4ba6bc10c4b03d0a99ed27f9909e98b2630a2ad8f71c93577f1f720dddab992a20e494c1f790d3d3fc8a5f5e39498154128761d95f25cd9f609188e9749ae31c6bc2c4b84bcbcc16f2723905aa754a11516394397400ba1a6d46149537d0feb0dd7df93da07a5f11d874827c73bfc8ad7c68fa2e170b14c4b79590957199a58b8d62b7dc88b88d2c16de48e86c263902ef251a983f4b8f1b0295f059c6c868de7e3a90ca6b575130c61fe001cb92d75a3a766988703e3a7dd347eab142bb5aa50c6bfbaf158b774763425050b7b127a7a14ed4d610f51d58db6bd6a5cb5a59b39dda3f7062949f8a41c6aa945044d3fc12b602bb40a962987439d96c47db5fff8048262c06a31e1e97eb1ce3fb934e447eb8782c65013866e50b9de486f629e5d452a1f0b357a270e84a2bdf6d816ca2506e5eb0b25249dfed11fbfe0f27a7b4dfbc02983478d90d225ecba21cd3219f0d19513e22c8339fae63a1c68124d3c0fe34af1e17c48f71c974725595b1a56213000dc830ca5b72f4ec546e8cc2d78d8cb4ae5bc942bcd4eb0440b1e1e2b702dacd8687c569280d8e4d0be509f2d4ab94abcc0dad1436cd2db18fc2a5c1ec46fd5d0dc6ae49aa3679e464a938a9852d97f7fe03d486df1b2442d05f99bbacc3be8a73acb83fb3545b737e2f32de9a9104821cb13bb27be5172a720f20da0a15162784f79c18fdcfc931f54fedbb8215d2801485ba441184b4d737cf491e2d9bc3ece3f8c6223412963a5c6ad613fc893f30207fbf7545774d7d3339f806027406889348c346f848937ccd95a0ad6e12722d57f8f888112d0b7acefd6a02084a12d802f80a57665f2aefd0ea953abcd50fb51c421405984ec9e994c0156e08beed0ad7911ce03718bbc266d8ec90d6d0a35c87756376f15b9a7cf1541af5c18df4d90253675fc50c69b426582b2948026c9deff647d2245719c729f65c7313aad13ad253cd6a2e1329b99f44a3e4b2a01e9bc2aff39c3d69895b68ef2c764ec460a50be443ec6c5d0e16884c757e3b65cf5cdcaae3c91e53031d2b2e96f041a91ed2a458d3c38b10fe04d2f86b2accd41b3c673be8dacdd87f14129cf12599d9e3400e7e2192b6a84ebfa2726603f805da90d0dfd5e8d56320ee07ce7f222584f454d80284122081ce096e03553b3681b8ddc1598440772239ca35eddbc1e5fe5bcd498ef6bcaad9c83fcc1e8c7843f0c35c6e6fdcd2ed56e487541a0c5e2c5391485aa26320616cdd8f56cee6c7761165e70989fe3f558372f14a267381e54cb40211b432d7c55082e3580656eded56a17a1b61fb790db1b37cd8ea8228684d184d032c9f6f28ae7e6063b091e75cf7a6882b9213d5e2437b7be61088777f5c1b1e041f72ba63de28d6650ec5615e2cadee35462d2d18d0520f04a43deaacf248432966de9c2d66ca9753b020db2ce8bc0cc915d98a40e0d7e3a5f7278173a10c18a417eda0d1295401722b08bf246e49a86295162bec6ba5de7f7153927345ef0eba94b49ba8e6c97a45622061eafa254f2ea68c8e8b973b93dfde2ae02dcaccb593e50cb7531011106f468631bcbff1a4286e54067a257e289841fe2f5f5b328049b393bf14b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
