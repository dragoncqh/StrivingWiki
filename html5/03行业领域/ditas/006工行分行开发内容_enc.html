<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"74589dd2ccef4997ae28bd3c164b3c349b919643917a381216abcfd93b3b4d3e050e423a5cfa3c6663496e8ef87c04dcf63bd1d7382904f28496bb0b3d17804973246e7a787609a348f9432ed455cf4fdc3a50e7a64c398e15ac0506686cd2cd9b5f189b257c09e88dd76efc01bb4b51915280f143141ef124e2f7af6cfe2b4304a65b2eb47ba81b6cb0dedadc2f804472fcd7e20358c3155f50c01480978e8f9932e57e74fe6c0ef060079be71cc9d50ca13bfc5b582855151111e5c3235b907ac227944026d060f1b6e439ee159f790f4ea3bb2757753d9ebeafc1e87c23a28e78b3611ea4ee7c7a08a7800def2fd1dec62187f1bbe0dfe30f831bcede62e24f61db60f0bcb4111fb7c8813f4dbb9d9141186563d582ca58f6734492879264f9836bfa37c9a967224f773342a6abdfdd3d6cfc5501c422ec98d24b7521343eb43d5941e8a6829d8948ecf16908293fc4d68c38c2471090a14df9183d45e0a8a6c877e1b8741b9204fb86cfe0940a345089e91b2a7cfb37737fcbc9118a81e516cd9dc2b47df8741b1873b371cc2d5fd3033e47f5e46fadf8a92a30077a119fdd67f354e332510cbb0cf0a9d141fb7b071b3fbc1571cb71f4c71954aa57f817ee1c558bbd87e03eab28fe1b507b8a9eb0c886852b06804b070e442939ff603ce586b16aa73b2acb46ed6f12e6eb03e7c15afe9d67aab7b3886460ce8fc2424c21dd46dedc77aa37b376c4f0ca6912305eb5880b081b9b267b1df9701043fd6d0b813c5f52996e3ca967b89e083ab1e62ed4ec0e5982dad2cb41b52b08bd3962725f08196d17051d4da9d5da0b6b2eeb735c204c369473c614924bf9706164b3930759811d2097b81db37c65c972f6757d97b78cf31945b3d855bfb9ba1a90119c154ab4d0cfbddb67ecbd68a88a9634f604a0359982bc85bfbada17cb653031200159e7f348b6b1374cd7e6439dbd6a5da4b585e12c68c35820d19ac8ccca3af17cf1bcd482b4a957b0c9dbaeaf03216657efbd5a533f5d42babc045753c18a3da4ce153b1771ccb232526f6cdca3c7eb8675290b20967b3d15576f90c84670aea6d62085c1e3b54d8f41fab5fd92922e2665a89475b6067666e1118396723c86ba613bd596f388a247e1a574e52ce7ec72c993eeaaccac4beb25223392b5222b6c84b9a54c2abffe94e06e9e44639713f94c9bc5c4547d4249641bc914750ba4ea261ce08748c5cb5ca7ac5263c4e62cfbf5dc587ded853fe39a9410b1093a99708da7123630e09e11f045786fb81368382b170bfbdea4cdad654f8431fd56ceb6e8f441da8dce3ef82ccca9c5e5e8c1091017bf429b364c8e1e0d16c29da1ff9405d6e23436f1ac27c65dc46abb96c33da2b7d4b7a9aa345ffefbb7efaacf43e64094603ef00842b9592d30617e07ff881f320efb138b793d8b5789b346e8e682b6aa7a070c4c4c65b060a7e1b7e444558ef06412788116b5483e9cba0e85b4d0890ff69ca5c00b58a3cb477cc17eb561dc93d5d00c8bce49a6a5be2c9de33dd6bf7daf7199bdf368bc346d4b61dea4bf2821422123fec1eaf818ed532522e7dca6dd504578306357088c7104fe643ea287989f4c9db10dc93143ec96095aacc68c94432750529d373b1ac07fe3bdfbeaeee693edff1d579371b1d72703f6a2955d933b8634404996fdc6886d8afef469ff6e767a70095dd61ccabf0bebb4d0567149a791a7bd3cdb400e6146249029b0b6ff338493cb6dc30bab4804e2269438a3322bedf96b73910a613635c77783b8f5b7a46a877a6eaf314df7b5917973ebf0a7d508bc8fdbab5985cc2af25cbce52186ecfc50a2c30ec9df4b8c1d774e29f1d54c7ad3900d31c21532e7afb9d352034cb91ac1e1a89e4b950370a25e988aa5b98100630fd83b56c5592a965b5be71f46ba32d6a11591b826de4d547e48ffe94cf3242604558632d950cd188b7852af5dd9b5280c26c0f77538b2d5853f24882d3377764a680e9b40e21ec5190eb174b0ce9b30b3f0b88aa422a4aca91c8b6c79aeeb400ce7662faf109a19a8fea8078b48ea38793cff753b4c79d271605aadd59e69df250dceac19c05259422d744d808007aee77aa8c1b173298fd83e758a24cc8c15ade682293d5e8a9ffe69257c0b7a64ac1c516ff2e01eefd63bef7c8a4a35ed1d368adb6b219aa8d5c9b90175cdafa0a7c65cc71a3fbbbf7c79e17be3525af4426f91b41e5622ae04f5fd50a4da77dd2d0cd1f424b22de3c07b6a16daa6c71d1a4ad6e155f07ebb3ee2ecffc19dac878eb922217cd7bfb727e4021d7bd939614836e6198b2b34c0bbf6a94c0e3282f40c7ec71baa76eb24814f94bfb03ce97049e6ee44ed28552e06945bdd9e2f61b94074ff1ad38ba2eacc76074ec3d72fafd0ae64d4f2621bb4fc4e50ad1c4af8268196c80ba10754eb4086d35c4c4107b7963640373c94b6354d5a8d2fe81b8013d2a834476cb530aa7cbe50060990f804f5b3b83267c64fe61d9a32f664f9c03be362a0fdee379e2973b6b3b0324b65254ca51105ee5d1844897c111ca9fc4c717c42a6fa51723400bdd5a6180178b55f62d6804fbc7ba7fa563f787a6479a31d896540928bb06d1b8e0de5a2537eb4fde90d8da28f68897ef776ecbd337b33a43d9ba2a9af7465526b372eadb5637811afbd39ec5b076a8bf5e255a622aae38858f1a2fef1a138e5778cdc9b16797bf17e72d919143e6aa944e61a102926c227562540c0ac6a9f4afd71df9daf922d7943490d61a849ad5feceb9d2604a5c8c1a9c5f1cd9530fa486cd911eacad27790a119ba311ab867f89c8eeed5354f68f95a3583771f0f0407df6c2c7a590b02da3c53b55801e291324ff6c32fd30c6f451436eafa59eb4fb8574f53f7a5090407923dfebd1888c6aeb6f2fb3459358db7b53926ababe939278ee2d6d4523ff99830a57dd2e58fcc56678200500c4db32a42949c5b5e9b636ea445bf590faece21a106ea5bb277312abfc6487f1dbad0c877b11cda980a300e2e0f6cba3db01d6fda22cb62fabfd7ecad09339d147c32a7a7eb1bf9e61316922e28a846a63292856509551fcfa8704392e29b5cff29168674248f064860c06c07c9ddf4d37b25ec674a29be8ffff47012247afec2f77170cb736f6330eef99e432983b67418aebe92779111f40659cdb403754af778fd568c119506dd791ad89b0f63cfa2d91e8410e7f3b9387ca14f8621dbea14b47c9dc57f24556233c5dc45387afc7e3aad3de7be057a93806a494c4a877484e0754347145cb6f853fff98e2787a9b3dba8f4413440c44adf58c9e59544979e62df399e2738f3c2aa1de903863fb4af1b55cbd4ccb692436b616f553f870c2539af9ee3fe2d96b6ab4fc0dc3ee300838590bbc56bbfeff3329145fe2f51f75bfcd973d0dd7bbc715bd8a08899609c4b3252fff6e9409c6a72ed653a344a204759dcf13c9f774ff48eebd326254700516e6d83625ded863961faa0b47fcb098c20fdd79de2ca545966388061fe84181ff855d750eb21da070387f3272e3ecc40b72a4adb85764ca2c132dc8969d051e3b3198a32aa3826edc491be9fa5f9e93b487b09003d150b253866ac0c49d5f48a47d919adb4439db221ad416d2804b260121b245ebe865a956014f6bf9a6f3e937961f32fd1581dd0a6a2e391edef34bf6171dfbb867e1dfc5c02dc4786131ad01b9ac7c9db30d6f7b4ec842105d37099132f433e58240eb8f632624f6f8a723cb30ff553357593444d3f2f2118f4771916aafd196716236441645c8c4640642d1dd10c2bb699711714ae4c2b03c07a0e7e4e447135117015729e810800c82d9da17260c582906de0c61e1fa13b0a3d84a00a87785c32b2d54c0bb80a277f433303dd623353e5f8c67ee5670f2b5c79ce21819341d22ff36ec3178e16ab312cb1f4ae64a8f94cb92f20bb7fad81520f8582eb8bca52c5283678383b0b5ef0edefe957d9c8bfcb61aed0c53d27f248a2f95d9fa46ec54a1a060bef3d6c08725638f05cf9ce41183245ffa8cf34645e347fe4cbce5c115cd74363cc0492cdcd4841b1aab380830a308fe19c60d5f303a2d47c4fdaabb0a7b88d9feb480ba595fa0c7818a44d97ba7c8c9598763002047b6f3f9fd0dbe9cd4eef8d559a9332540e6f666f7b10520d2b8d94daaaa074e73548afcd8270477499fc633401e5e21dabe0787faab98d13855180199af0b46b0bb375ed06e74100564db9e8b2371fbc229a984f5f329871af30f77a75c5cc9ae0cede786d79f8333bdee32b2dbcaf6d9a819b3be0e75a082176fde4af6cd67acd6e07708b0fb117396a7a009db46dd8998100be979a325ca9316aff25d557afce9dd1e9e81770b176d279c75f80ac8675ca29634b9452e2d4b237e530f7260b8036fbb9dd9214f7d994d3dc178afe525707b3bba3a3893f8d35529aea4a6fce7953576a7e76848697ef5c395ae9b3603950635ec15fea44560aa88f9c9022ac2caffc61c73c705ca8c770727aadfa88ce923dbcaf05fb5fe6e18108d204e787c3f4a8a6f491ab5f97d80739afd27c58cb0a28aabc09eeb627cb7cff360dfbdd5e529324ec2b2d971381ec7fb5a3fdd70119fc738940ce6f7a38292659e6fadddda2788b875b98279595082f732bd378e895354372d49a5b34318cd9d71fd1997b751d16a3117958a6ca9a11cc7bb023b8dcb6ca4ab987915b11204d1f20e7df2b8add4b53ba645dbb8fb72c32958117cbeb267b1203f365c21a4a7c8a9f3b5dab5c782d5dfcf89b0e54a65f08792d08b85c7c4f15505e151b7db3bf97c4e18506300c76bb7fb26d56f00b3426e3f9b5f45fc6b23460fff1a9d50ca27d0a1d0638935a232193239021c42347f9f7887f64c528a4f4c1841be2c67c4083fac7ba15b5d85d2930ecf6d1a2c74450d54e6ed85a7809ccc1fd172bd471f11867e49710960866b5a752ed59bbfcc65273769dc670ebac0fa0535551c9ed703d8967ccd6220928b9ed152cb1d7b44c77e76188f54437f8451fe2b330b01caf1aa907259e3f65f4bd5a69764086abfb93c9827775b9b78a514e4f1c1f1e6153f8a2ff9c38fcf5b69cf8ac334297c912b61e51d2bd5010911c215f7ac435831cf118ae80779c9758469093706642b5cee9109195cd40b92c4b5d6884b4e171fbc5a00c49c4e5a324f962fe094588b40ebe18522f1a313b84c30b12f3990dd3873e397e072f83273261b6abb696bd75d310dcc5d7d1d87c1f8910b428794d1450004f23014311c3e8b1f0a792f795f0df00ddcc2f6930cc937b98f45240b17afee277533a5003af8ae3c275392a13aab48696be54f12be2de25c6449985b63c348ff717411c3b98f9226e881bf689ed22d7b16e1b0eec2bdc69110ca1a31d10c71705cbaaca5f447a9f0f1f1268fdb867e47beebd46e3a98a3123ed723b2500d90196c663e797dcdf25f2536f55cd803a44e0ddbfc9e5fa1bc17c1425be2a6e9341a1819432f75df6a5ee46a0d1cafaec7cdaabf0d9366ab5f184afa1c8fd7351307ecce83a973b164c4b0b160b7f8e60491c79cd151f9564088c7ff0b55327792df1a59b5c0b540fff98e8dc087e2fbff83512595a5fb19ccda47d3eabea25cd5756b6cef112277fd5147f3020465b380bd04ccf00172cd0cd451e0f36b4cd4328eed40a1cc0641969a06df87d3cf91c367cb12d2c65b91c02efbcc3400d2bff4fa63788eb450699368f6216849a0e39c7058ce9f48f6879b08f5c210b97b32b8409f0640c29fe0100db9d0320779039dbaebfb5b98712b45b84f37ee8fedf2c420bf26012bc43f4d1c1eb6f6fc70d1d58a3e4cadab6b26d10291a959744675679e0cd35141f60d63ed107c5fb767915f3a0a2813dbcccdf835ec0c2b1caca1407b698cfb6223b2dad153a997586e30f99a78e19b366b5d809c574a61d109e6dd49ad0922d21c8dd2ecc413c6b3c7deb673978bb6d4893d88d5125a5fea211074aad0353166417e5bd1aa1e098994f88606445f3a2dd0b49ae9c1066ceef1761328779befcfc8aa8d3b021618cd7c8f7081463c35b631e532a12102694c1e44af2f5c8ea74f0669b5da02239ebf48570c71942b8e4e287b7cc8317a67099f8590dbf1529c6a79a203c7a97cb9068b5a9c3b33cc42b022588112d6fbcadce7433fa9ef06165f783337721d00c362681b343701289d9b9e01ec81e64f6549120ff977e7417d9f971cdcbaedb86e3d33eb9044f3b2b4e1a696ed37a3d5c969735c6c0cb6d6f81c0919570bff3f5e51d625d5159ae0011da936c9d7efb3a92e1b427270b4305f8f162d1bbc03580b65c6e4a43e2fe7c525fd0b4a32942d4a6cea5266df9ffbddb8d12973533c1c739830142982daf6b5c685edb99c6a5c4628ecda5dd4da0b990f84c310eba8d7ca2e64a586bd3b5610ac1015a419d3d07d60ff1fb4a89284d383add59e8249bdc94f889eb955a18fcf2215bc4196026a5d200f954a9227c9695986431967c79da048599ef3304c712fba62e997c1b975ae3bdb052403942a86b0d4789869b61bd6b0c11e944e34de9d19e8e9f3891d35746937e1435e5264701b78522547de185f06b9d528163de","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
