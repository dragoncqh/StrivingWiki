<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b54c25a8071c8f7904551b2736e3f8bcf6bbddc8e120256868681beddb738b3549dd0301ae012181f2fa5544c7a31ac35e93392958a7f722999cfd7bd7ae57961a55f745c019d90a95a974506c01b8d91bdc7c62f2954c1efae5cd1a2110fb50ad564f5c7826c410e3e7ab9439e5ea96423b199600789e4d1573f08f3cbe261fc62270d801c71892631047b385bf6d7fbd13955c7b61f19d2da8f64321e1aa978f0d098929c68886e1d4aeed8f10544d1fd96280cf6719e8a9d2a2983c3cab73dfa71ad03b3ad97c36906d8b99400b41be623a6f4ef425a017683312a87d913d4a61bd724bc3233c2e62970538c533f51195feba73b4027f73f840593edfbaf3f47c89abedf55b2f3a73a96d367362c74dc022b708c1baa007c5bf4209ba48cfdcb5df103d0a278a849e302d4cfff77583a3871445f0a416bf0b8530cab672209e92175d7a2fcd51b6e11a7c4dbc4f70b03c83b1ce27bca92d73018fd2846bf0a545b44a2f1af91e4aa4c9c13c12c7d33939d78fdf10452ae5969b71dcb894219e669ec6ca575f981801ad01da0787efd3a39826bc0ae2e48671cc2347c53fba703161745052afc9ab22d698d2ae5831113232f9cb725171b4a26a7cd19309f27a5fc017adf55478501e0db197a8f1959bc04224d2001f1e0891f106b2f49d3a69ba12d1f2d527e9dc4133e16651d43e4a87a75c3bc2241565729289fdebe05eec148e52846f3a7022983ad11a9ae7e1da9dbc40e683af267e1ed3c3d5c5338652cf43d53344ed737e5357119cbc4c7d232c7d70e35e060fb5d6acad0a1ae39f7361cf580a4836292c1e14ef49745a684a67c119a265d2416a83f93cf7cdd3725734535b4cdee31456c0d62a15580f1771bf3316d89851c0ca555db14462b9e1d6e67c0ef10da1d4806f34bb4751a6fbabdd1a04cc5139e5fff3610a06675692dd4bf12527753c1aa82ae2ff2894a0e24c1a23f981c64e65c4b273744edbade46c873fc0158c3f4025ffc70ef041215b1e168bba478bb7a8479f0566db9523a8640138f2745f981d99511e35ff305a30b1f01f06d00b1f7f2e41cc9bf3d795de665803bc12c5a6605a7a575c1ccefde871679beb0b79199d131e58103ed14d478c8a5d38becb2b5f55f38a50a0cb2a1369a0451aed934e36a58d7f2fe280e50b3db41e110a7810419729716060109b41237c7b184fc0fdd31a2edf2c6ab76728696d276e3177c7e43d94bce023f57ff7812578e5c3478779a2b1864cacb54967b85999c211028296d9e6453553865f075632d561dfc4f01e8d34991a081e33153238168ee1483b8fb1e463bbdb7fc666a327f0849331a7406b524eab3ff35aa4fd84d52e20e2a386a5ec446682ea9b39518117dbced90654cbdb93a2b9aa064fd77d6d944f0ff3e7ab0dbb00a833f8ddb0422f27d88527aaf4c01c0adb997c91a51c14060fe9b98118d8cf7ef04d3e052bffcc3b14bc86935218852969633baf3f81951b5c5e8d1891208756ae2142e225650349fb98c6a9a50bec3ebbe3d7e8164d2b336216f06b1c701367177a2846bcad43821319dc9d025106f01868158d9de8df60f8510dea5726ecda4bf21dac9b9373f0dda9f479f31b450805b3d145b9b0c0db7aeff52afe3b15d9a95c787879d953f029ddbc3d4a12f051b7f94e3f258eedb485f10070259809b65a738e539da696540bceb70a4387eb85f67a1ef7357857fd09355b7d1e6e9beab8cd28ea91ffbde27c7cc54701b5784f807f28f3b1743c24b23152ff2b7b49d539d415f0a2e356371bec3e605d28aaca76a51aa231a4a3100205220aef5a846909968f8847ccc0c6ad0a76a05f8064e5e5dcb5c6c2dafa7b23ad12217aaf0698123590b24d473ba2a45d45b04e0651440a81d07f613fe74328f8c85340f5ead666fb75ffc92d502deaee10a71cba132d448c38d36e9ebc5b54231fec0e074ebd6e78bf10fdf5a42e3703094e40f292991e8af7ae43f3f7c6965927af18a68225f758499c9cce6de749189f0d1abaea165e7cdb8d57a9787fa80b22467bd2e39fb033438fd2b8be8f780c7229c1f08857d157fa935722a4fdfa95265b0792117147e66641ef52889aabe708a35a3ed1c4a3501d4f97fcd3f8cb7c5f4f4ca8487b0a3cdad85437417412ada1574c639fb2c783d7d91fc0670e362d3aa8b17834e842eca5e35cd5b7cb0b74ef8530e214a6df534416967c0e4ad431a1711dd0c74fb190982890ec7ccb10b89c1021d283cf6adfdd2655b60fe21fb6ff2ffc84d29def7493172296ba3ed4aea2bef8220c9ec4cfe415fed52290c73233f620731da2b3882089ba49ca9bbfd1187fc55cf1355ce0662abd26917995ac70a9fb123de707659744f404e954377e86cf0b26177fe6ead1779bc1f6f3a54c52c1335f7c4b34fd558f0bb2fbce333b27ed9bf6d30b62b22f494af6bf2bb2ebe0ad3f1da93f85f0215b76bf09a9f7da7994ae40d2b1eb52f103e4beed960e6b126ee32be91066fe27853af04b7dfe1ddd6263432c1cf248dc013a82beac60efdaa48314e9ec83419bc6b0ddf23888c0d55424d40590d1c3d5eb9a7fb749de82ba2fdd149e5c40290e4452574e7fc2939af14850bd3836611e84d65ffdc35fd2de9068b44b4bc040d853a99da2a3754d8e5a42c1fc9de80466480e9f686fb02d99331eabe3ea8b4aaca9c865af29a360d5786c412b07f016ff648cbf14a59d3c27a633586ec164557f19292b3db4e345e0d20c719465eeff455bd2ac9b1721ab7fab150bfabb3d7911a3376fdc193fb76e156a18f1126e193b654869b8475b8948a86676c39749b516bfc37a6c7e29c4979e6787181438580b0430c6ea3af6c485049e6447171c510776102390a682d0ca636db59e850213807b8df87d59c25800f52122c96f031ef5ca542f889d5355da173baea260f33874458a2e4fc2e25d368a8a70dcad13a2bd00d88245bf7be9e78bb151a4a9ec508c2380f3e77a037d842958497f6494e03c6acd888edc9d784c77d68febaae4a591a1bd4e29911bed075fc72cf689b16bb50c1acfc3f75517012af1aa9bf83b885b62f973cf5a545f05768a1aec6ab3f2d1b840a452f22a4668d9a09aef3c971c0496cdab2cf8f36a9e53d69472a38ea616e47f5ced71cfb7be7e8619d9151e47164379f19155a36483652b304d9c9d80f86665cb669de3119277fbf64ecdb2a1987b76709d7b074250a4c9a3a01a9b7109505d5a47a86dadfcc2f8a265ae5e7f6015e67e695b019fa04162f44c6aa06d8090254fd18835ec0d402d3b9a45d531829218a3a0054e9f121d0f94edd83714d8a255d818e315b622613aec7a0661b1d7b1f8ba7000413a4f8d8ff3ef813a5b4edcfc55bb3856c64e7831ba6aaf228a5e448e9287d0b7705d91a55f79996f380168c2ae6b57d39afd82732729f122e8df4c970bd0beb577ab49ae0a751af491a3cf7c5ffa9790a9720c05b2c945e1107b61bf39471df3cd0812ca01442a17a9e706d195a7d18c998963e170a4dc19adba9cc5678b5d495b4e52b5bf0ae7be47918cd7e9d15326f917da4dec2227c3c4683d489a969291d1e71dce41d6414a45bbb747997ecba680e0e932f37ca56b1f8245cc6287c353a3bb1cafe3a3284ebdaa8d74a82df6736b26429e86939fd7b8573ef3dc9e93515337f525bf4f3e85c1ad45213cecbbc84342082044f0a9b291a2ff988be7dccdf51a8c08f12aa25b6205a3decf7118e55cadc07fa139c9f103ec5d826bd72dae354ebc6483564709f25c50b9c6dc5f733d78ecec54999e95433ef4d69a62bacf5db14382d3c306942b9411a36abf7fe35ef0e34604bb71fc5d250cf615e3a4636a0197c12745c40030494ac74d54166ae0d3ecca42bc823b1b3ef3b3eae9f9719f2f3492fd0889f95011a0b64bc5831d0a06db77c2fc56b92e79633ac4df3d594c08dcdd013625128baca39490eea7a0aada51c0a2a6d1ade13c4210c2254eda698979b372ff5cb9a88943dbde103a80d4500c84208505417d329335fa34a7bc85205e6b937d24e33ed6047e7ca8d1809ebe4aae2bb62b8c821fc52525116848b900dc22a4534ae9421224da45e1621eb706f6dcecc642ff8a1a9e32b9dc46af46e03b919b0a2dd330e5dd41ee454960aa5dd79cb0c447b2ed78be2e5831696898792da6fdd19ee7e8721eeb3119e3a13979da3c03a065c71c567f66f0ffdeae76d437fb17ef9ae9558f5e3e6ef1f5cabe216c53532e035c8c8ebd86589b883103a39664d07f326b8b5c8c59c3560648f0443170c2a34096c7dd428cae67dad7e696145cef4520c43dc0b735a34b0c9145186ee1de3851fbaa870d103fa94eb1f1d01a8e55d52b1b4bfc5dc7438e48b4889a40ca5dc0c1f994bec51f57dda188ff11ffa4c7fe92c6a258f20fcce0076edb9310fbeac53d061ce5f00faf16f8ffcfda241c07fb722ccca654ab14321065e3f02117471975365eb9cafa463a8e1b39e2d922aaaf48ef81000ef503fd3ba8a427d604d49755768066b33ea785602c4e6964941ef3908e4afd2e1b3f06136949b557c6ee0686a46231b03bbb198a4e6d0f398d180465ec7df2d56f3a973378bb54478b3f2818d53b6912c72212c2a21b37c7e6fe8d66683779ed43752cc8d79d1def07a0f9fe36dc9d4e308fd1887d618cb350a4b0000e76df7b0afb98006df2b6f5060352c8367fa9e90b50f74cd8b397223c5581ef0a28b7ab6839f31a34f3ceb67f9e36e11913e6fbeb11e3ce3fe5b293041c3b93ebad5475105881a0c55ce102f860aa73612a422542c97cf1844121056ec85f404b51f4ad9ef71380ecda051158ca5c81dd4b6141dec31aee91b1411f96105456e86287b863e21ea2d982aaa1fb70935ef6793fd48670a65e6e3a04b38c3c5667b902127538978ef43f51096f8748b7b8045df4d9ef0c31805735bef77f9d8865d301e5e89ec6aa729d56e69663e4d138f55889be95df7a27ac0da7bd2973ca8d735fd151f403cbe2ca9005d18fd83edfb54f20201f36bf95b8786def24fddf92b33d637b58a98bcea0f945e54e6862eab9dc8ac5e16701489f7eb6d2e2ad91a740b4a957049a92a01291eb5fc11f017835b93ccbf2525a50b97709498e1a6b6c5ea5e7bcc4e4868b3afb86e9db52272fd8551555fc16829aaff26d14d8e98075d344e161551145dc986155ec24e4e19fa7378e26cc59759100d0694b6cd428185d3be170052dc40103583289be27a93bed7514b32e90e680ffd1bcb00ebcc55b6ca4f306f9c8291f46c91460913eaf159b1982a47e72d3c265d3511389f98e70d86bc0eafea98aee4e8e25eab705a4ec825691e8a414553d873fc35e35335d77dc472bf37fda496ac3374c89f26cd1d797fb965a541260d5f5b93d12b3061f735c87f8de7472c3714ca52d0df0b401b9b5eca98971ca2dead27caaa4486f6464797d460be2add249c4b7351d6c8dcc59dade25b616149591663c965e3dc69ddb9e27bc23eb248caab18dca7ab69cc1fab95309cb373dd4bccf857dcf2440a3ecba7adb9e010c25367d272b6c7f7b1a6328eb8aac7b732528590365c3bcbc2a8cec5a8658593515d6124e42d8ab9252a3677117b3ad3725ebef2fa02c020227e38b242c770a7058b729295a33c4ab0e3dc60c8c301dc6b066d82e7440f8dbedee877e65b533791418d97087051fbe9083cf0ffa2c3fd483fcc285d54c6da8ac8aa8d214825639c8593fbfeaa985dc34c19b4f245e10e88d3104a163ab5f4a066280b518ed72a7660936cf1c3bcbed6e5772fee52050f8619949962eaef089e2b7b3b3fbbf8b6f1e5d79a91e40b05e7c48fc66ee0492d7ada553312d87d0e6e49fd892ca74cbf7e7f8b1b30ac777ffdd39daeb3bdee7510ade5238eea8f734d765d9814cefccc9f346460cf879c60067bae47ee9c834225e97b4930e89f5a6824e8d41107293659a4ca5f3118137852c74792112d939610c23a5e78d2bdfa2edc495387063d65ca5d7049901d31cae6550a05e9ef4747285f0a763f9fdfa6e29595d56cb3579a58e926768924faa2ac9cfb4175422413281adb0e33024423dfeecf797467b46a739f120e60f5bd1b6443c886511730b2b224bf38ffcf34a9b39bf1935591bbeca0567e8162c4d36e5294200b4135c5def9941a3dc51e4342ed695f62e92d324e73163e6da8cb9b6c828cc800d6aa06d5816a8e8a2aa17ac6bbf153e788ca1dd4e1b8a0897bdddac4531bc1e395140ac07c39f5ca097a32138b632e11c61ef0b24e504239c8d2ac9676f11c45a559e56b487af2301cadb6a69e28f32f778276323414158c2375d98af4ff0ebd1e5890b7950c5a71320fb2870e129665238e57bc0fe8fb744a8b18c818f71bd2a287a9c6d15582435628e9198424ff070c3d648461e9131fae9e48344612bb3953c44370b3b4c9e1dbec378afa9ae356337c5b0af1e1ed66e542fc736aa3953412266f5ee9e36b9599e3008bab2ceea0a3fe1af56ec1e72f82aa2f021bff358a11f481d0e8e17d1c88a9af28588e9e6de9896811dc5d4ada4025ad571d51337a14ac41cfe267a888ffd276cbe3388f175a60c01c3e907d5e21ca5e8827dbf1c9169922e66ae40e85ba2d814c4aab5fcdd4c298c1db2fa27ae0fe1b74c733f4cf686c6c7cb032645ecd3db7f2e7478afb00dbf3e5b4ae9738181bba02590b6a2490e58a53141623e508c81378346f76f204ca830650cf3754c6036b3a95b68e2f97a4eed20e861eb78ac200f64d7e7e35448919ca664fdf70d4eb9c99b3ebcfd11343c465ecf2eff892f881326b3d90f89d7c78107a01b3b177ecd8e735113419befa83d91d13510a556b854a5256537c42cad9470991638a74772bb5a69aced45adb102c139d4d84f72427ea4d253fc92e6296cb74486ebd4b2deb689d4bbf8f7589ea13dc43466ac768321b1b2279a7d3c6c91c6f20c160a612053cc99d550b5af1f66067b27b0eaf0559699accc0cc5092e33235e71efaf55993878ae22457c1e90512a44c8df87805fcf43ce34b1a8835e6ac993677c8ebc42d5953225bb7d5b672ced68ed989830d00caa2826ac66575ac2e10f42f7adebdb1609763483e3ec4cbc8df8641983863c85c3558edbd35efeff1357a608dc53d6fa55f92e1fca14d148afe3ffbac84eb50d643792fca3fb88e06cdb979587700282f264d68bcee7a657eea0f13fea1d819d9e30d34dfbe55c4ac998bc0517b405aee0a35340393c113369df50c6a17aa33e99ce247e62ebae2acd465a860a39f215ab22395412f66381a8b67d3e197db74b78ca6fad19625aeaa75c7c750adb5c4afc95d9dc3db08db4dca1a44ec180c77a66cacdf85f903cf5ba5c7be1c3b552cf736b38eb6b2a2fd37e7ebaf8e9d53ce8e660553f982905009ca0c7aa954fb54af5c6c5e669a9e1e821107ccc7533029cd820aeb801ef97de5eca5fe4125b3f2cbb1c75aa5c4b07afa6d0c8f2d2717c5fcabac8dea0048138e3604904b6fb9e01a2ff07c0eaf26248944df19e573abb48ffb5b6b5edff40a06216d62c61ca4e2a1b20094caf296f8099f89ec3e9e0520d064daee284c4397abef0d2a7d28aacbb1a5b748d829fe0e52b7613114088bde4abc41ed1efda9916cf7b71911bcca94c57d5548bd62a1d6e87e285521069f252e6cda327c689142a91c4e6d707acfa1f55d58e643b9bed68fb06a40ec36dcac58b94877659919ff07a8ac193f18eb50bf29084870d43dd647d9b320447eb6a9e0c994eb3eae55ddf408769c3ff04a78d9ef472ab0ab89eb6baaaea97a8379c2af7b7ddf008a6940d6e20ac4abd4646745bc8b86cff52900379d26a6fd035b91850778dc22a0c2b060f8b7b40ca47ebe2042fb184b4eb523b5c3d1aa5f81282b239384854850de83dca5d8ca61cb792a9a501ef22f80f9bec9bf7b2303567984c732e9a6146133ad754050ed506579edd005657f78814c13ee5089c02773d505be8b201429a81524694fb050b84be1a09134d0fb3c2048b49fbe06ce539ba684abbaa4700551cb811d5336a4934b18ad61a30825ad615c7f39f03747155f953f0b91d99777d9e570d232f08a2ae4042b6535121f02b37f73350fdb017b24b4b71d9e1f797ae05152bbb7aa13190bab5d7177b8935592ffdc145499b7fb382e5672299d2ee11cce236bc6c2537a78a5dafaba213cf9098ffe67df6f76c1cedd50d5025e8fc835f9ec80e9bb3d8f80e622b13f9d1bc27706ccd206d642329381f72fa740ce069d7c058a58aeab56714dde58e58d833d5710fd000e60731595bfc8cc591f9456fc68b0270e9ea8f1d78e2f9a7dcd20d32a75e5464cb94aeb450183636211ddb55d38d900b7e200ec831808f2d838f2b29afd8844963e3e13321c556f5949bc7a587f2ec598005580ce9ea442b39d6518c0de1bc1b7103cdefe7fb9383f25278d154916cb76c8909044f60ea8b780c38afa3e23143c0457a558a79e3a856c956f810ff0a6aed2c63f674528535b2538d8216f24423c766bea6b4d25bf329dc57d704b9bef4e67a2117cf5a8c4fe6c2420c727aeaf55657361b26a2affc9b37ceefdd7026486762134463960f8382ce24b81ff962c3e34224e9c6d00393417dc4106388fb28d6a1b74a3282fd93454c843537862287976889f49803dbd77316ea348f57dad965bd1f17517e78c27bdca1dfd23af7a0d8ea7a8bc3001b75624db278900c0b81cb7752dcc284f533ccf6167529823995ef00df089a5ab50d02558b0e50185cbf59e7c3cd07846244365e8ca10e921d501145d42d5f63b0c960d93341a6c16ceb79542c59a973594012ea04e7797dc0b9fadb6a40c0d3906b28786fcb675ad47c76a68ea5f4cc2e82ab2bd1704b48788d65cd979508d0eb98e306841cec35736c50a42124b587df2ecebe37dcee5b0c4ca564173581d9bb16880413c550c2de86f9a939060daf61dfd3e5d20c77bc8592394f9c1cc62ab653e38655845ec75aa859b112631ea77c2ae8cc6fbd8e9b00d4080f77cc38fa4b136f7149550add6b28744da69f5632a4e67e7f720a670582832725f6f4c6d5adb41024da7a9db10e5087368b5942259e3649d47aae97b145f184d2171f539f47ab386f7fcd59767bc9ea2b70fb6a3650c60b5220e3d5732aab51f504cd808ac291d738c5ed5974a0c05a8db91153edc0c7dd59dd26da4103511ca9963960ee82a38d57c5193ce66937d46e48889af1ae1813e9388a676bb458523c7ec14d1b58f3d28cec149060b606a24ce30c0c1e10005af228aaea6e886397078d776488855ac55d5ac37965235b7f7b3fe2162f1eb6ab4903f9807abdcb9ab43bbdb0a2e910be48e75694826b7e726de388b7959dabb8e294fb8aa5e53149d786b4e1fb601de8a03fad106d1899ab5ea3e14c4467bcc2b079860ae633efbe7ee280646510a538143c63443324f1b493001f836cb197e04437fc33792f141ffd92e19d22bdf68455ed6eb8114d242663ef0ad30fb8d966c6245013869e3b60d4841039520c7215e9d72567fb58efe34d9b854f6b546fd2a573408cfb61d4d2ec544124830aee9840e685167e95df7df734225f7913b86e63d5e5589a471976a6c03040942b85ef0944a0dbe30d07effc06b4e2bc5e7cf64c770e5f573172528da0f3c7367e3f96b55f86d59bcdfbf88bebbbe71850a344cdcfe3b07671ac21850c5345f22b289b43905d741ed25f1a0bf7b2a43976554b786f3624bbc1579e2e7bcab9058d6960e012ce7f8c114c2f2834c27256d66ab701ce0e74f206ca333998444265cca69488d144878cdbc723f2365781cd25d3bc7622bdc43b957b53b7d78ac44d355dd0ba758a4e742b2678e27b194d6412401acc0747b8a5bfc1fc8a3840f0b38c9137ca2dd261a62ecd22b558f43346e31c36575d3caa49361108c8b15d1020ff5ccfbc3b9078c33648db5e02163c9cabc23ea5c16d11353fcc13b250aa383a0e8940f1c14aa2580d02545281ab26700957e0358274a35749d5de94908512a2ab2969db5f46a80f21e205ea4b3a28ac19767d186ab3e154e84647f778f73c4ed78504d26a83ba00fd5cbe759206e6af1b59c91c3a89569d66d3a445e262491835159ed595b7d24229a2c588d30e8fef93a29cb5b368249ec75c0ca4e74f81e8c53435c1e27a60f20e5a1c967be25c021a1fe157362d31fa6cf4f1bb093eeb79b385d3d57781a35b65f3b13eb964ffce58fe2c9bad3bcac3f80f5a8bfb6ba08a76231934821ad61df97fc61e3571788016da9c6b82a4d05b0edc354400f4a9dd60fe041a388088166de30993c6ae672c10c226f3c3d8667a6e4af45b0e786b6f1c4daf3cf414917cb70ef9ee950a3810cc2e65b4b6d3c8c78bcc74d22556ace729a914a71c405446a42db3b6ae330a17962cdf88e66636bfd6a2ae503f43f926fb4e447e731b22648577ec45d435f0c914952d081d1ec7c17a490dfb7ea009402fa577b26f1a0693972a7222d36231a322b320ad7c2aa4e62a9d669f8e72113064bc6f65e82e05dcdd224cea3db400283f7300901e6a80a84c513c59c7be37299f4bcc47cadcb414fc232b1f395e48d91fd23bbe9518f6767b00900373172128fcaecdf584df5087d586cdecd074d5a0a1f029f32af87e26e5b8070f3f42b4b8d0598685b984913d051b49cfacf3b09e9bc3e7f54f2009144d410d147be472ebb1df8c89f545bad78c3ccbf3837a8cea89e257d6fca7763dbf88f70e0bc8d7bd7bb8ae0e45f7b963005ab29acd14fa8a25b7a8fd08d7a9290cab5e90482dd70c2f470c3b1d11d7af606138c77b48ac765418fd7a472b9bf8508acc20e3bdc31f8e0e94d6cc5bf5a305dcc1b3041304838685f1d1b62614a2a62365d5ed838824c3aca7afc9ea616a068ac486cad0c1193223fa0a60f279328bcdd6b671f7eced9c0f94fb0ede5d2f6202635bba3d0c1bf803f8458a600a0ecd1c1f539e629fee4f8a991a7fe225d07a53b26716329653622831f35ebabcb82faa696c679c630f239e7f36ca1e6c80b10aa045b6a2bd87115e9e4ef36b65d09f810a9d8be06b64ebf257cd880bbd055d6ef3432b205f0b039deb077bc76ad79807372bf0b492a4c599581a42838fccfb9ed43854c821dcb5cea005766461669afa7e90a199fb3f8a0533504f6faed8f3b17986c660200f3fc4bcc44be41328511d16a71c2542a482b55ff03f785ea083510ce48c776da1e2da36d181441f97e62d3801df155fa60e1395a854308bf3ed552f7c3beb8d248d0113760bc337138f1cabcda70ba18e99fcc65493650220512eeab98ee40892e7b21bad7a68d42afe6ef0ac94998fb7b7bb6c8c80e8907a9b9fafac9633cbe5a290f9c19f0b913946eb20cf4320f36024ca58a227c60af8ae8378aea0385867409c4af00ef6994826e0373814fecb9587e236260b3287acc5b1a9f393f5edd8c7688e2a3935ec728d713c46f94983fa8c3e4b1b96cef143957733c78a9003458a5a7d5a9352b673e1e6dbf07c10dc070c3a67bb4f36a6f383bdd23436c0025203db4efc454f640932939c2d3b72b3224f7441061b6641b5ba83b75a4270e2c82679a97514fdecaab0cd2f72cb0dfb0b6b7f1429ca7c5907a6f7c230a6807102d49adeba500f7fa4c9f30efecc294fe64eaa6f70e90491ba292129c0915560add51749e4b56a72590b67257b6be9352fdb63d7a74cfa60b52f19ff3411a99ceee846b8133513bf5d2e9944fd9560e15f493f26bebaae61d3cd7c1d7bd6ea7017eae1a7d0195c52a40d6041006d946df78b1175e05ead6f34f7797a8e1c4397369609e32d3cd0ffe4ce1c90ac93c2de6df5da835de917e36e11589c9e78eab9e052ff2515d9fa330557de594a9a353370d62409e181c7377873df11cff4a68cf7c2953b7583084031f98effe18d3628b2f6e48eebf3aad4737d5444d31531211a25a9713ff8853cf86a9b9225fb076d0c8905393c93de59037a12fb4d1e9fe4188bad0d092ad85fcc364d8b52ebd6cde33475862772ecddb5b7d9784415faac9f748153af22fec28c37091a12f5a64ff25a6e6e55e7eed398a658425efa44ecef8329bb181bfc30abd855601f061ab238473bd6beb80aea5857a76fd810ebbe91e460a21a04deeabfb353537d92dc8e31ca60e50373c2a90ff57020f8e852a188dce4fd27d2b7eb0f15214bfa2c902dc83dc76c9950148e43751b7dfa164bd51c2f70ae51e974778dc421224b4fa369198a3f5543c51a8f8b8a3edee74da11e37b3f01399a276aac3e5caf98634edf46d2b3a307651037e2bb5d2d8552ff5fce895014872f904415f7707f050a49eb6d8fe07b4f09f619a69f6f543ad6323e7dd0cf387456ee71cc9ecd1bc24d984a1fe2b779dbbbf5c6a35d9ea541435e586e1cdb07db3e93983c287ed42d7dab638672e21d19f340356c485d63032eaedd4a2d252ea746b93b17035e8e6e0aada534d06a242f20ca6cec90e1081740206ad893f087c59c502636e084f60c3a59fb874e296325283fbb1a016595026de72177a43225a0439aef69535fdfcd88e3ec2fde8c731712191ce7fd83cd55217c78d077a269ce7c1283b76dae0e5aa32b9518693119738450058824211dcc2489e88a794d9a0fbc9649f32564749ffb9026e646be9b4a036aa33db45f0f1a185fb01b7f54e41a2cd6b2a21fc7bed96bd419fa4af77354443d4956f2bd8dd064764ecffa060698a2928449f22e5a98574cdcf4b85d7f3a0df11d31a94906c82321e104010ac4ec012418ab8ad213a5bc2ae7f3755a098ce49df15a8ad678ff0c0e6eff15d04143584144c6e7fb0095c04c82b1efebcea879f98534352f567b2db7f4fd71da3a39cb1dae90e4a3dc3a108ed23201cf915f9cf242e942483c1b81b1b6badde8bd02aed9091f2c2ddddcf03737cd187b0b8667e1f55389f3269233130fa728db38e4eb44e827932c8e684f196018030c803812294ba202e37db642907aaa9c21604dad5158627daa9e7c4a820dad65a5e33664db473eb63e58e11949fc39bbf2818bfc90af3d5fac4f42592b25d10d2618c01f486bd05764a902845cc9e9deca74a0606ab1a040f908612e8f4541c6a1bdd933d513bc2e65437cec8e2716c311864af3d12ddef2d17a25cbbd0cef8cf1056c7b7b05af117027193ae3baad6ea97cf7949b8452af0df4f77f7a510d984d868a17fd71c72b848d83b83ef78d5e1e2627f800cbf22a23c25d7edc8a9b2109ef99546e76ee505ad8eca37cca03249e84f409391ee6bab6d6d9073bc4a3825fa6f59aac07ca0a79c8d1ce6d91b1d402cf637f0ebf42dfd843f2c08af84502a2d1f4c2ac54f0f6db8fe5d655914d7bbaeef2a5a126b0757ad8abffaffb54d6b43b4b1ba646e89d859f6135e242acdee320d926f49a694fbc6dc87e1dcea4163de26c0398078b1ba3b78d0e81909bdb22de115b19ae4f6baaf723321ecefade348befcbf9f73c55de556db083c0c6ebe6c90d221bf72553349f01a2197719cfb5d168c52a70112d4fcc053863aa774ef7bf7572fe951f08cbaedcfab9c77a79596b8b679fdde5cd814edd4fa4729b9598210b2952c54db2e9ed37cc0b4d30baa987c27738b0d0207b5db11f4cdcd23e05acd5377779a2aea0b468276026033ede773d18d1ad103cb23ed1c11be17b34a5c08b46f4845d116e442c72beae433ffdabab4a693cf10747e6779347c68ff44ee16ff2931cfe51170db0e8cbc151710348984d3d9fd106ad34e33013da73ef35cd8ddd05c1cc78cbe2a80f51ca5cceb75a224570997f9713af30ab63cee2f64ae890c9a75dd50479a65a61e5e0f0365390948115f1074b712a1166354c9480b7b746ad355e1a59107ad54a0a9d5a50af03db6b0bc027e2a6cc3861981df5a39249d54b4bd045666707b6d1f02694c006355fedcf32b0b65b8687b71d24b87d1616bbff6623a8390265daf9b606b2d39dfc0e2a6ae3f469a7ca6fee60aa2fca18e35e81d03bc12c5e457af3f8c3d82383c33e53449dda28027d549b764f3879704c8fdd136207b3071a1755afcc635ef963c40c27aa19a11d1b11a40f5f52bd887d6270920ebc0cf528b78281f01f442d0f29f947309d77d146b256cc387ae8a2f6b4b683db0eb0b0bc6d0aa07c9d175e8866ee2b15b15df44399ca772019728aeb14e58cc8afd5402a76ab3f34851be315ce0c409e7ddf62e6ef2d2868d2c0ad3b600d3f06e0439de0b5b28ea4d0b9d390d7e57583f708f240a5559fd8ffb6856a62091e4d3269d5c52a19400beecac178ac3df57208c30f5cd3ba7c23b66c080a7b279d12abee0e7960e51c4bef4798f1f0b548252a241d4707b5167e071772e41b85097798108122851ef7a840d2bb899efd6a38eeef848ec92b63d0e1da14717afe1d9b5c9d5b85940c50eaf5a405b51df65c0ebab36ba9e14726e64a6535abfa9d91d6dcccb4fc94e7aaf3adc04f44b7f075e5fca9afb9292560607530d567ca4840a981ed0d8ad4983c4d13497e6209280704f294cba63efac0d44b36f808d26735de775a877b03e1d54b1c61fe9a5f5518deea1a42fc2be057d09fe232430c1f19a59b62a00daf42c8e5312437e7356e4dbb9c8a2ca5e7541f5860aeb00634637ced3acdc7e71fd8b2a5af38bdfb6af4e21db392684b77162fcc77f8dc08d350adeef166eb904cb006d00ab1eec500958d769200a1ffb5e187d51ed94985616e25e0a0d1d60fdfdb279784a11238e5b831287ea3c40a2bda88080db5b4a59363d85eb3b479202edb8e13708c83dfc670b16f458f373708c3771824e7e1ab9607b69b9778a43293566da34cf8e7173d32ebc6de61a449af700c8fa29bcd936745a1677050ade48cc33e9ba3ba0de5b7e492229e26c799e4def486c43e0836e88f1a62b86649635fbc650a5cbe3e1f5fd3a48e215561579635465b7ad74ee5abb296ac2790a7bba0ef89840d33d85dcb75c755067ac8877916267d2a12ee28a5a895553e5f414ebaf111ee932a159fad622a09d30d0b8c8435b278b6afe69096b3f7e284bf4400e043cc2be2092153652336bada6fce9eb5c9dcb4eaab70e9760f19bcd1656036c249429dadd781631c050e9d124f093cc55a7bf688faa5222a07e94058d025d1bb2dcdeb8a17d72ab7786d0f5dfc28ca60612cde09eba54f443a20243d75cec4896db82c3076f508a63c0b362e31dbfebbd2f73874790f2541d5a4350b612d0a6c768670ac80d9e61c3f5ce93af75559ef794338bb7e980bb2ab770740803d7be93036d82667ef59816a0eaf1607e630a611b79ed76e57d7c0c8b1a0e5d8f73ab508308f58de750bf43dccf46286d18b06eee2c865176c9f8db77ad3d9cfad8dc2e878acbb5fb19fbceb26e1bc28c9ccae743a6205340695d3a61477bc2dccf1c94e73d2b192afce0a8e49f3b3de59de47e16af724d1b672f00d656394225870ea96fa1f3d028d39f6662b331d893ff63cecdc85189bf8654faaa5d94aaf27553f849af85c17855c6bf150d29531a7c4380b477657cd663f6f4b21216aa0a9ea0063a950b1d09047d7ee4cb5bf1733fcf6e59cb0909361f60c4e82c1744d987260220f075a9136c026c43a7c2bf49febdfeab2cda584e540920cf0ac898f208d4dcf03a433d4ab95a4d7d3954a9d6a26cb4fbfc64bdcddb7d196438e415170f44bb913cb22686c90f519fb0db5a8a4471d4fa6a704b704a24e711d2e03f4f6a06bfda83ff462074ae86a11018007a00969d050b7b097db6feffaec30060c0ce17975621bca2e9ca77d06c19a8c364af7394378eb0b17db460b9c4240532e2efc7cd920132f39a100261640f624b58a03165cef4741b393dcbe0cbc1c8815e2f999d583444dc910f8fbb7a1749f25dbf5fae2f207f0504c28a01e440f0d213c4b2ed2539b6152b5a63e93a768f85198693f94a0df9e92076a49fba88b5ccf726551daf70470ad44fbe3e3f11e6a689b9ac7821844d363ab715c2f8119b429b99922cae73e84f4b495af982e8cb899693fdec694447525ac60e21263c0a464071eeb1bf17f9cdd6baa6dbf5fb505665f58c0fce7634090563a4fc9763dcecaade2d801bae58d884e666b9b39a1d29382142f43bcf41654f4fa42e1c22d16d460a527c90c3844e5659bea7d8037866b442b3c7dc1d19623864479a5f6a8e615e6bef63b381150760924869cccecb99669f2a709bc1d9b8e79873d1f9cc7f9482e2648bfce458ca03a947be9ae1116be0c4166b8542841727535866eb5698cbf8b8d0d28e46c0183c05d6634bc1780055a0a59f2fd75ab954c7e9f0488f44893c95aa3778fa63ebf90a861e13bdad78a2c05460df43a535c7bf578bcb7223472cdb8e25211053d8a91e0c0da9dc2e6db81a101dea75ce59367e3434587baa2d18be2244c90f9b0ae7de1906c34578ad7c942d1e9b9caad0cb09153bc5a45a1df92879529cce3c5a24718d77e73399435771783c2e9f5d21ca85b8bb6914848fd1666b3badf13248a88c09d135dfb5a30bdfc29e1e6defa3d9ef81ebfd313014d18d5581b6453bffcc378d231999c66b26da0c2f81aad4dbb7115ae43e45fc47b4f5685f25186f598d0313d4a7f70f3015a8fdf2368a8eadb367cfe10f64dac15c6456f5fe310b9ac03a32aa5189ee8bfa0769fedf8b79b2682ae67cea4f948e7757795015671fc465d855318a57c3b2da2adf8b81bab45eb101bec6090ac6c9d4705e34bb8ffa7232fa4198e880e32821fb88a456c64a15ebe4ad3e228fe759e0a810b566bb23c85982f6174a4767d786abbb63f5c010dcff4af731bad667f7d7ecb72e2d39757c5095242cfe0794128adfaa909509466aeffc5f9dd390287c50d0853ec6a422af1279188e4208a66a9ea072212c6b60742dedeb3582d7bac311baec85f278b4d429c312bc0c02bab79de337c499f0a9fc4b27b33d114ba3426a9936167a0d6b0e5bb4cbf8888c2dbc9e5b9f22c70f1cdd262b4492c917781f54feab6c2e728ef16ad7c32ac747fe9a4a0e542e7368aedd43df7a91f74dd9641bc9b58916fbd3bb61279fdf238e2db0548252c842da2ef5e48ab8a6b8b7e5d23cd02b506e90d9c6a87dbbe61a8611d1402fbca89001db35bbe1164395fbe4e60f03e924443075815a86917953c4a17a89223f9e9a6e67478173fd2965d97826abb18068338babbf762745bb458fae7e44c72fb4a1e3a8f4358ec368e50b9e5f81a6ef63a45ddc4c9e1fb70b1b35bd46ae21e1498f33809c70fca6e2bcaf342a2712fa260852cda1e4987a5dd057a139a03446818f807583889ec2a5916351b302a51a5c4e5c44f900ddb79997903d7e6cd4f4859a6a68025c1878956b27ea956a0033dbd58950c50ddc5313da4210b3a35432c8c375b502f5587e268025e497921df6c1fc881ba8084d3582a2b673db96d57081e30572a650fcccbdb4ecc41255054201588ce8220207a16497731fb982c13bf5f3cddef45366082afaafaad88835353abe45b45cb702e501a0584a94960a9bcbc54f8d11bc27f67a8e752ec797b3c7b3385916a772879d294681c02574c39f108c890058ca3b75663e2a03cdb3d6c1bf0b9addb244e74cfb19fe05627d6c170fc3d5c4b39044c59162e25177bfdc0b0f4ee1afbf5f0df37169c51921913d3bc99703906ecf000e353bed6c7516e0cf4ce7abba4d54d3c945b058e7afd636b53ab2157024ec8381566e89db9a957e881c3fb3b4c412451a5e535acc4663ff04334a086655a6a27432aacdf917196fcb1be0737b41de126120cf4495dfa34d806c8abb35630a8283fed7e93f8aef0b1f520a9a8a208def13fe0ae7e2a8a7b4db9f3264ace88eb9060fa22157917ee076da64d187bc140f032669bdc1df669a95c60cc63354cb56226b1c9b4adf85bd13ce1a481ac4b4c6740c468371ce9cd14916f61ed7dea8e8956047a5cbbff7884586906be42b74da02dc4a2cf744171ff4e000f4844fd464057541398485f16439b5d40a3460aa3cb169609b9d9b97235a0cdf804800c479436d581873d930b01c1fdd5d63c60a60853f243b2a0f491d229a8543bd224a387dd27a439496ec698afeada24bc80dc9d61cbab53bc801579a794e3107eb3eeb9e1e564e24728984e8183af2e427234d48e004dec344171a071998beba04a5891825ea292180dec321bb1019ab2e869fd31ca4fd42dedee658f932bee47533bb15436d2746b8c6c862d31c4129ee16a4a17ef2906b6547c21fbe3408eab9f40c7692941af1af008f3a570f6b68bb0e0edaf0db568786419ccff5b1b7d397ea53768c4d493fe6858c50992b215ab9a1dfb77f49d9157db71a15c292bd7fe88d4eabe93400c66f08da135c1b586b80eaadc841b58e3fa92b543ebc2f41c6aa0a59cf69547d86d5fc5249e11d087071892a5a3ce2a980ac23ce24ad90d40cd592fd88382b9edd8839e20d0fc0a2a11dda946c2cd2891b2e482265f778e1f0c58650c8e62a086f00ed77db7fd0dd7b543368ef7cfe10d03144384d480c508f7c2fe9c08deb375eb6b60014598113ee55b1e539ca8a276515bb59468938c366a8f759195141964d05451cfd22c1a4b356ad16552a800cc44be9910ea90a22b7bb8205b4678e214a66ecb6301682457187f48871915715aa843dd919304caf6fb1f2e7f2d4d88dc65db70cfb9e298aa4dc50681e9b9f6792e655f24b87d2f895daccca8fba159083fafeb2cdc99cb13b4f296ff7df890e59732cc63603a5f4f041f05491d8e38f19f1f12cb17e7a5237ad127a2733ab3512bb21f6dab0045eddd9a7bf51604663dfdd9dfdc6e51cdd496bae480e29db0e879bd3ee12bf40d16d0037db7418ba5fa083836d527b1435c935fee9544d08eb2e06d627da3131c360a6076576ad794738891bf843f30881c57817d98b5c64e858f763c996ef2b2d4bd5de8bb8d275c49f9296b5793cbd60d36e6b60284139ab2e55375b3b4424a030df04c152d649fe0a0f806d12eb847cdd5f50419cedc0f717c6e79365a80449c248381a67521f405e2931a491d8f52ea2f14fd756395ea20526f95327110169c8ba87eae95f431d5e44514b08df43e4445cd85f7f9aab4a13d40b80817e59a0cf29e24ffbbe0671b976f4504450fe3dd015d4277c81643f9d6651087528fdd221ffb78676c7cb171beb961ee3c377ce9eb8bcd085804297c7372cc3a6fb5f0a788b0412b59e15fb68ba3901ab47ddd76b21e4180f76e8c18d1bf3b14a00062e3beddae9c108256b2f734ab3a62b65f08577d459f09d38bd9b4e4a54e340999ace58c5d0084589ea8666fce9e5d436a4e38ac695b57147728031a4017c30f940eaa34cfea849dd194e4e3a94ac1cc31d9b1954cae9bb93f3a8a02ce38bb9ce59f50eabd069d7c4c50899322432996b659e5a20eae9fd17aeede81f79f8fd3a7cb5f63d39e70a4ae103b4c82e0b441791cb8f1f4c31fb21d1c846b81b63190136a5469292703eb9796fd6f9ed59d091a9390426607617b7570312d38a3ddabad95ab6d4de9c5b832cab029f83bdb4f2e241989c2cf2bd1b5e66c92e43244726b98b47e90c7ac2ea2a0684a48ae273636ef6f28913e967ddddda4e81296bd1ddbfb43b719a79354cec5f794335cf68bc792839bb3b259c6e45054b87f7620a613c73cdbb54fd067ea901e62122cf13abc7e9853f65e49438c16f041a1b0b13570dc26f99bc24c8119505ca5a05e8faffcf2f3e8e7f8a7756490e402662bcc6620a8e922c91b52c410d355e8b2b1b6eac5c7ac086f55001f266833aacad019b734da1711dc0af1789b2468ab3ea5b13f7c97c84e376eb8dcd56576b298599bd2a50eba89d123c33f273965884b824a37246b10adc9dce647e4ca52e3b533fa712c02477102af1f3bb7ea65d974fcb475c111dba62d1c60278bcaa79","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
