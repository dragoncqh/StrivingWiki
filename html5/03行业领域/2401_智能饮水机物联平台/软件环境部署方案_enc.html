<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5c61ae96fbcb732fcf27580f23bd407ec52f335f70b11cefafdf058dca1c4b968287118b224ac4b4267dbcb3a66343b00a0845a7dbf6dc59ca51603c3d2bce1bfbe5c9c51b6ac2555351e2701271992d35900d985d01a2a643e930e70dbb3c018979c54b1e08b13e8512b6b20f0316cebc3adf178eb779a51b660f394fa757518c36790212337cbc046866f04f151f5e3549845b99db621858ef6a7c8b674b74541b0b055196b76e9bf603bdd5d27ad6f499506dc3b9a76fab3f4a9f5b9b34307b2da893abd951e17bf86dd0ff9d44cc01d58f2c9515c975d17d9841fce91d3638f27d5c6bfaa1ef1514e480f77280b7c658c6dc3dca23a4658456a14c4a5c0a32c989e0f67d1e322fb15586942119e44e940ddba4fd313ba74ac27b98c3906d959ee164af40f4be15288a30f677b69dbb3569d6157e0ee10c41cf0df141a5f06b311be1a986516864541b83e5ca51e82bfe98b6cf709a2aa41eb8056662979892ec9042bac3edd8fd142f254a391f0e882de022c408ea1a8681e13bef7dbd7acfc94434d9baa323e798a64bf6c31261e75b10ba0f205acc7b5eaef4b4d78c151b4170306c80d318919ec6c354cc447e1cbf68523a336ee1a93bcc27d3a41355a70c39f46e1cd373b85d1733a8ff2e8c01adf7fa7d9c7633704fdc11331a8506081581fb56067b20726233fc5b40eaa61fac3f12ce49f1f88e58ccaf612e7c1fae05047c392e41422ac92920e092ce22f2adcb7b4aa1ff722456678c4f211e442edfee1024ab7fc262b715758981163e20eef53fe2b65ec7da6050aa1050825752a35888f00d1918f44f6bdba09fb0a547663bd34e7c415bc664160809eea0e93ee1e0fbae78a9bcdb8a8f58e0c2b2bd8c4408d2d93d351248b7e2efe5491fee0cbace7b7389305e033c79e6d958a21de1ce3683f3425fb7efaf0f817fba453e5f4cf30514cdfedf6f5da1a6f2b5c4bed8d898eb0bd4af5e8f675207a6b885947a7d3f7da7cffb5ad601f4c3177770ea1aa2c07da8c07934b096ebc75b2c954b9ac1c2f08f03206eb3c39fff542da3221c4e54f913c945fcdccb1d03205dfad8743d0e3a711960a4425a84877ce6cef5d9f83daae6c06381ebaeee4b01eaa298b3d9cd29cc157ce37c2966fa2e329f28f4a5043398063e5e34524166df306a4ad9c576c4e42926d8d0764d49d3cb78495518f969b863d6638661db3c39ec87c73a5db40bf2d5deaa595325972c282fe792c91bca547925fe35cc33beafb2ebf680040fa103a445b59c7621014e5eb18dbb99e111042ddd74c71e078a4cd813c461445684d90232b7164ab6970fbbe1d30f38504a125ef4a5b95a9daacb343fd76e5421d9e24c5aa9c431abe6ad6985e038b6ec97a30794e6c20507e4eca3029e8621b7124800c025adf6debac87c05ef987fb5934bac7ed28040a1e244214476645c162a3860083feea923a20b7bc8c20c720471335464034e9b353e91dde3ca7d3a63267292723ec4acae1540ac4b0a28596c7e0a17899f51798e34170cb720b59b9ed79f9c743d9839cff3a7e52d4ce0236821457613dcfaad62a09999d32ce846ead5edef9c4fe23b200732a38d3b4200cd74d67d9519ad812fdfaa7ada107c4a4a0efbe611f18ecd08320abd209f52f52d667270f7581f85e8c5e14eb3ecf54ab1163932b854d32c58bbb0d7544ca79e23b76526fa3384a687ebf15c75f02ee56115392cac656c38d76ea52cce528db14f86605ee4b2a84cb27f449cdfd60399df09e8a3af93c673ba344cd52d58b03500402d1f47a418a5929e68781f81ea3a4f3997038ee0d32ba0b220836efdb42d59429b1e0309ebb73a7d0904e70040a9179238c198558d463ec6f5048a78256a894c11c3bb5dbf5b5b19f65e325a7866e65cf02386100e31d50d13a7cf85edd9d1b64319d6bcc1a253bb79ddd317c74d5ad5fa35c040bf9f031567b72b6693756a47e58f13f3621ab7f85359507a5cdb5f7ea569a729915203c31f6df28ecc9a3af26f6fdade005025c9b8fb9ac6249f006b0cfb5eef3d58e417ca4d92d0e23df9b5d65fd165a656a1d3508e2ec7316c9dabb7a506582d9e420202cee2a618537e2d944dbbb1c1512bc59e729f255f9da61eafb911cdfa7a575486e55f92a29eaa594a10a0946e40456edbeeafe0423643fc5daf7ab1492ecec1a1c643d512e5ddc5318e2b3fdacd2d4ba7d86060ab7f14c61d636da426ea1848595ca541a882730b658c6e8e823fe3e7aa2a4353f47eb6002a03db21913aaecd8a6c72c59db41eeed1682bb845894cefd158665474b965b5f3ff2c98a11482fe69876a923e8fe66948f0848cebc6ab906e455f429b05907bf8157d71ac42e3ead01c04be64047c972acdd199e4d2a5198b8704d8b0eee2574d760c74a6d33c399d36cf166a17e96edbd0634a86d0c7309e0c689db1bbb40fbe4d64f57e67eb8aed75e05561852ffdab85c90a81977a65199d7220ff572cfdc8270d09068122a4341baeb68e7e257a111a917c19caebde837e12d5052c00ed8b5c6e58a3424aca42694365d6e2b36989f479c32d59f7cb4d8ea3347794817ddd8d4c5cd1221f920695a3b90fc3582fa0f7e1b5b49407d57dc2719d7a09a08358f1cd552fff8d36753a38eefa4f8124a73f7caa90580de587411a166d9e00249aa838889437d8dd7b19a0ba32feaad1c75a6757a19a65bcea68e2233b97c4b51922c72498febd9473e5622ce0521ad1645f2d09ed6a3e8bb806ffdd77d8bdac9ee5a88bfe6a0e3648caa01cd3988fda30b12fe6d49202253be363da6529d89f874a039a18ebb5350eb47b34338436fa5c71fabf197317483ee4be65bde674982257ee72c2517c1d8be99babc88d24981536f6680e6404d153c6d83baa9f0aa83e3c70dae3eb1b64daee895b21a652e299c46f229d9d0ae1a31c90233f266af45f2bbc17a67be71ef18f271167f6012dcf189a199df4730dd803b2ff02b1b14c2baf195519c1cceecdecd78adb0f567fc37b70a1c7ddb06131e93d20b15fb2d58cc29439e436e3164b792cbc7db566ea47334940f77469a986b0518b7b6f6a3fd4f5e12dc37e9b426ca8793b30a9b7c20af1c70c778bb263df831a859be7d0e6f64973024456d7c4d2b1cae5c3c6a0b21ff34e4275e430d7ad06d59f001d912d81c9ff711343eb0c067530eee9d7c8da2294a55398d14f1e24eebb5c3426495d4faf214506a65e6661c8ee285c5343173b406b84218bd212e1b05690afa9b175894ef3da76a03b77f2d70256a756e68862f873540b8ad315222907b17aa39a856524e67f9ec468cacc17e51bac5a2191b561d02c670734dd9e19f73369bc36ae43eca25e0855ed6ae2c57ee07f38863ff1164d42feea89fb159b8bc480d4c6944617e7fe500f058326f6dff2e76398ec22beecc8f9ceb3c2741da247b59162c0a1c41a2ab57fdeec8a44f9cce559928299d1fca7e56d36ff034cef26c9c636a8f662e8e4da41ffde9ef445129617f1f974d0c11bd792b5141c224e5d72fb8d162594308fd12aa660d24c9ce503bb817f68de2e2ddebf1aeb71e78c535486d0b633cb3cad4eef75eaa1314a4af73616c5ff0701c302fbb51d6b92ff30e89dabab463c13ca199f2ac4274ab83705ac7717c3cbd3166905e146ffe86735b27b04fca592e7398c17c3962cdb361634a708e5a19d40a505cbd1a2869d3ffabc82a791c8abcd1a5d2aa8d7eeab6fe3c0d76de89dc1545e394404f8ba0209d0b2fc764f0bd6e9476e16154604570657985f465df86024ded4ee7327445d2564751dcd892c51126ac74488e65b77376e0afe536b3ff730994985164830fdd31397aa74daa8059408ff195846cd1718fb659f8622338ba67ce96433e7e530c34c434736c3bfbc8662ede032f17615655e9a581cce19d5f935708f7dfd6da2f8a9965505de2e99c0e5fe492d8c37270baa59f4706e4ae5a7bf14213309c95190fef74c7bcecebf899f80634be18c3a8cd43955a35a3a22f7fb6a2153f28fc730f3b00ba5326b6d2cf277a48b17d0c66d212df178078302004bb3c64333019ba7f54bf5387150f1c3046e14f80abdb3095e0fdc28310851c182674cbf044561449030176770dc4af4acf845706ffdb700f9582661d1750a6a4c005b9018e98f591b44976a2b324936ee8d42f4da5a7c71e15c473217ead24e5e09236b35e2d8f48f71275203ff1896efda26ac1f2333777bd040b32bd8f2b07ddfe290f2c19472dd17b940d26545cdb3b55b2ab350aaa59771097eb830450e8b4851b93527e8f4f1bb6233c3ec9a82164539cd6a75a83fcb3fac75614209607c060732148f28009d803a2f60b0d8fb36c6591d4d6e788e4f92c9b19390a4488030cc271ca790137006254bc24e14c8b155dac9f91fe1dd3f374438be7e2bb7b69ab92fd681384d0cf9ad6b472bde925ee572d2c3e3c2976b0f925d569a9c1015483ba6fa40b1bc23cd9fae62a655c7e9e2e5a52e70570d2f553ea1a11813eb0fcc64b65596f61556e11e789bb0428c395cdb5aafab039a53daccc5f80fcc6a81a8afb706e11b7bf4e766e5f78a077e6a55a55e6dfc8f05877ab9fdbcb2e81c8338869686a49522bbebb6cec5cff76465d5beddbf8428271fc835352c8788f0cf87be960632441bce27b98f2e0b1ca7ccacd00899b5bbeb26ef87198fd2b0a15955f043fd8212bdb0d1d748be95e76b12aca9868ddeb31dbacf51c35f25c2794f0b0174a9376c2cb770154a68e7e258270d0da7b6810d737b15f6904b5596322aa187e75ce4218d8d8b91e125646a9f9601ec9a06722a1e41b5e9011618a4a027f80fb8db7d3a405d109c84f94b9ef1ef22cf1ffc17f8f08e85802e9a1e6ee0b2aafd8f8e0d4e52f85a56aa58efb68222217f450bb14b4d026d8394c091b54c6e519b024dac77f64bef4ff80f66deb24a8c9df77abeb9d0410620852161b3e0cb7eb72b3a8d454d49ee62bca347afb6b2fe6b36837a72398a62801803f3f0eb99b27d4ed86665b491083663256489aec85431962dcb486691fc15c5f11fec6fe41fe2fca58b3df71bf62d517dd37205bd31088fe2e82ac8ec1118d3bfdceef7d1a362290201aa72c9ca30e642f80a9ddcc24a6988b91bc899ce1810e84a9ee531533de65ba83e48780d37231df9c6fe35f30aadfeec5301155ca97c88f068884ded5ccd510028833163307f51adcc77e29a2478740c9883191de44592a0fd6d7b8f78526a35943455d4dae9f1cf22f23024b9e4210f27cb82381ea068eb67be17920d234ad247f61b230f572d0b53012052f868234dbd97dc5d92b11908b7ac500a4dfc88224e42b5147a79766be7558c4d677aeb47261f1a22a1ef0e655c31a3948705d9224f8193523aaa9e73061ddf2c1de8ea5fd1d4a5f696d0b5691629eedba2af078a1c51e15dc789d7e57ca3b63ed2734032c3fd12616fa8148eac304b0d355a8438525ff48f142f937aaf8a089b68ed247973c8888c2ef79cf09ad2822864e6092a6b5025656c511b4d6596db0615a5d4de44ec90d46e9d8c12e4d55bc07c33404b86a98dfe0d8564a2cee46ec4dc79a34a8aae57a4219e7013b53a61069eb69eaa86b622539ddaf388319492a058b23c9bd9167ac65f9aacbd01def03792e6c98591035706f230e70a2c287593dea47d389458a1fce86d2cb3b19544835314618d2826cca8d244f33df7a5082f4f03d397aab18309d3b1fe9482a4ba2a20afc1211356b8fdb366cf38d10a5a04f8c1e19477760932b8a8d31717b6b82da8c616f2877b4141b27444f9b9cd9964f0e1e0485b8b97b9224eec58ac3621e6a62e6d671e2d9989917f982d7378eca09969428068715280a85f31a1c5d4fe70beb94ab0dce3df84f75320722db2d18dcd6f7336c38c8a3e20568cc6eb50e1c0106e6d07cb79b29b2be433cfb2b85e092358382fdf2ac7cb74da6ea1eb28e1aaf8c86c59308cd60e21bdceb42ee3517fd9ae8346cde81b20a1230802eba6a7053c258eea0b7072020120f78c04080a85fc3e1c0cb5b7b45bab65fee618f47c6d657c16ad67bb9e7fc3bfe92078fc7600fb238e9f7e1d783995c3535334b9df3e7c5644969c1e34eafbca3c61276d4e43359cb8c9f4b61c8cc47be3f96e2d54ca1bdbc725cd9c390b04e7f14335899241e11a6b0490670c70ed32ddfd9327ee7caf8701e2ab234454a75ca84fba514b4a907ec94b95acb0dba74c386e4fbe64f43431de3d54afa63ac1c3d3150cf6afd7d60369e2f5a77c0f653b0e6b3ea2743c3ea3c21fd49b141ee7151e446be0df1532a6908aa81250cfbf36d23c128ea5b088722a76d52554e5b7327554d4d427ee775f6744754c0e5e3d557f264702477905dbbba582683cdfd397fa83cac86959afe0882bfadd540c3560f5b1116b6401a93a508448fddf6e0ce8cab681c8d7214f5b59200edb52ef6a9d819ac713a1272e981266195f97324e255952c06072bc8255d9628a77d1f47e2de9af614de07e2a217f40d9155240a2240fdf3d01eedc59a80fed4ec3b446d393a479c4c7a78e45d9bf227fe0f67a8bf465036697c0ff36016aaafe8fd6a94dec9d0419b5648962992f3beccfb608419e9f5f820a0da5a878db7b3e5a4d5582044de8d29e0e2073dcc67cb5e1972fdeadb55cd3cba7335fb62a367a50b41068642b5ee8f8d30d84afd83c44ac5e9d8b29ad73b33d59079cf94fa6ccf3d9011531de00c63acb1adebb2326a563ba257d2bb05e0786868545b96721ce0d698462d7eba3e74f7a708083b32148daf7fe98923f3f0dfeefcda42b3b0e356d41be28dd4df2f55dbc1789c7a30f79c44b41c218b2309c39849b9b5b3216152ba28bc713415574cbad2eadb0e2ecf993182e8da9d141a6c13b86bbef35bbcedf0f3095a80cd2d13bec81d1452bed94670f3877ead49f320fd2aee6edae69a30ec244ae185aeecc531e73032e3c60fab82d6d75e02cd4143afa3e6ae940ea872dabb41e00dad1d02b9423ca4e3fbcd680e500a2e35e38ede24463f2a4c51afa4016cd45620d298ba48503793aab7308fcf3600a84431e4d5bfd0e96475c93977a7f277ece2f0c9c0f392f36cdace2f5ab3a9a783370dd55f217b028a9b930545c451b7ea993cd9f82f3cfc50087ed028508bb502f1badc8aa48ecacc1a78417174f2e833aa1c3897c0001ec392118c8390259474681c545c30d9cc6767ba604f16bd1bfd22e0ed5e0d1946bef7e30fcac812cfe4250cf51a61da523da19ab567bc19bb040709f2a073bb05c820812cb7c60c8a90a15c432abaabd758a2c16a4245d25a8ac3899bd0a06e9d4f859357efa994413ac86f25847c64b0cb63f2458d667fb24435c49493fc4569d1174c77bd92f66d316f8cde1394bd81f22fdbb1cd019d7cec7806ee764036b074eaf4f52a91cd8fcab0146e8eae38fa9b84156886df5011e0d34884d0451612471b67212357f632e958e967d99a2b7f3705b9e0c1e60580c37f77ceca8d2a169881222b4cac732dec3d39389b7519712d3f10f34ebbe8ab7dda2c7b039d8032731b42242ba1a4c46bf268cda4e0a5908e5b0b35e2987c8997894c1c9605cacd08a2c2657d68d25002f28bf67b8455e77620cc9bfd270a4bc7f4c6690fb09032dc37ca7899ed7c5313faa58bc204dac2fbda8610bf618bef1f402f539ab71cd113ba0185d28851a115bbda3fbcf3a73763b102c3164b8987574c292adc13e610824b16c09c732398becc5f9b92aa31bc8bd2f2882872766099d2baa3e195700ffc450741a493048d9c4f64eefe958e419ad7cec56d03ed8361a1b473529fee3173c58d9cc43baef9e8a3c152069c99f6007b4e40df760ef63bc9e26602a659c033f6e63a5a24dcd2b198801acd450bdb241f4973e92c1b41cbb222da93fec67480ee3a4ba876862cd4c33f5d896c920480b55428455d48a247d31a885723c09522fea027ed625bf09142407eb486edc762b443936569a940d16ca221885b5e553e225dd8cb75c415e7b506fe0ae46117239206ceaf746ed3844b2c4b3c4c97988fccb74e636f732169fa612c4bf9c78956e143a42c8da9771bc52a443ba8b6c739c75153fb933c89c7c1d06a782d3cff68036aec0329d3fffa09269fd72e43ae65ed787bb19644d3fd22595748f7e702ab91b972f80794f74c625b5f095977e936d8e5c08c91e7abd3e9c58f4d61a9c80e33ffa33a21d3c44ab2eae53db3719cf77deef57d167c64a84fc077051dd9765ba4fb6f3a005b21057141f319f813f5176e9b6ca21e1056f2151168aab8ca31b4900366d7ad230c59ae83f74c45f9b89ca6ef6710a5a8bdc530431efa57cf9c1d6717ab7042ffcfba686b4fc336459cb51f9f340f860a74f2b6353c55205cc422b289f7c9cf04ec1533b0bb1e539fa2215a875a9017eac4d4296590fac132a3e3022c0e6c9b4cc4a1e54d3d7187e4b7c7f6237c6027a6029a02df75367aff25ee1acb07f81104199c9d32369f7aa130732583e1f10afe989d2fb7cffb6a208357224546a271e1e130f509f793474c5e5747abc8b8a86955488e3e8a6003c91b6de9261a8cc44b72a39316d42f1f89625d95da687693c392b0d95e2e7da589606e0aeb3cbc759c051307f93982add0e4e7208df641772d4b7c027f97c0227ce925c55d27528a2237c5b53efe6cca272c6e97ca2c27bb15b84d9be888829250b552ed299c2e7581788dbc1e12164c014b66d4b5b9b50eff241d705dd5544cf107c7dac4d80cd9c6a685660f80f49800e55ffe42f0c9f14d02f3b85b2588f7d0a623b26e4ab1b4b88d4b4ed22e8118f12d3a7d7e0e8e6b3fbff03c31ee79fbdf9d6baf17e4c17534d4fa5cd54cebdab16a8eea79c679e7f096e31b2a6985668b210979ade6d432674956757d6a8a4ebc507ff9412e5fb91a57cd4f33959444c760340add76cd96497fb9fe99d84c5ae024cae6135065cbc4c3d37f0b5b4cde37a41e4446cb72ff97643d0b61a81688c6b86d7c78159f268b9b4e0e1598aa8997432b14bddbed1dbc6e4cd3072f599f070554c36cf16a930141eaeef66c8f0cc46744c5fea878df89acd53e8ceec3d34f641c407c1323c10423fcdc6430f08ad0282ff299d04199ef3698fa6d0a2c35f1883daacb07a35bf8f4c2bb0679e1fd21ba653c957a0b076349fbba6c5c9b497f4bb86f83c8a39b3d4aadd250b03a9b6f0b321aaa995ac3d2b59b04a8132f41c2ae27c128a7c51a8f519b51775f05768cd53322429fde34f31ec879c3e4a1f885bd8f1e9f6ab5a201405f43aa2c494c19e3996da701a2e7dc06bbb52580b6697dedd4b2785c11871e2fe4bf849d5102657f9d825195e9e9086cdc1dbadd1d7f8a65f2fe103a745a862a9678b385d94b78094f5c3ae7ef662d7f27617bc3b17e166193a0dcad37cb99d15dd902c654a74fc092bc676850394f35cee551ea48939413c92684cd8c3977cc761d767cfa40f7de49e882c39d518210ca415e5c65f29a75b58fa04feaec4ad472287bbf9f90845c22f821979f5e69273025c7c8a30e339fb10b4612c99c3616234891796aa315ac0ef9ae801c72fc009044f5ba6af042e08f9e8291ce21b979ef309af7784129f8fee37cc2f5a77ba3d70bb5178bfdb6571849dab696eb3aa6a02932437f5f48c44dce3ceaa890c74e6e1227ac13b070855cb2202934bbc4932bfee25f7c3f04d044d949b6e50e6d90ca06c82ee65dc33714f0948becb4ebefa9ac00e156e4dbde06496c6ab29a2de60aa3339be23a872a1db1ea59503651115a9e2c4eafe64df71c2e0a7dedef81e1006f8a952d2b8b8e503a075f6f30210f851191553a6b0ab062d9380af15f519c331ba02e523779740586e715df601648ec9bde0bfe668770762775dc684b220f388986f98052a71a5e77724be8ea62533283efa46c1863302f3273ca6cb4df715ed96b124b65c565cab4c588b88627eb52e9cb8d550c83ab060d4e512a45d15a44e223968a1f193a5e1f55fc4dfd7361435869040190a7690a9d8cab5df27acc7d40d85248c56951a752091e89e69042023872b638435f40cc17511b95e0d739be4b987b885ada0fc4bd2b7d37f15368d3bea9c1017cfe7fa98812364f6a8a88ab148b09a228147616fc97d9b5ecaaf0638ad5944a935e429445a5c9d8db7e60769c21235d325d8bc61d2a7efd6c0f9b3cf0a959a1d71d1662c9651ecc5a932fbb9a228597f9aa629751c2fb454886247dc8d271be9a7159aa59e94c478cccbe7044b83e472f41d2d90d3e8a308b28cfaadf5cffcb1233927bdf479a986fe29e629cdff2b366733552022020a2298bfac1dcee635479c23cd1328e6a44f7445848fc56b7a72a1422c4ec9c7663ebe117afc8c82651dde2bb61567a13a376b5cfead35296293612fadff8cb68142c5c3c0ceffa8f91da523b73d75c582022be00fd30a27349cbc74af9e19c45c638a54d0f2fd820bed0fde3634395048a82698ea007b1919a00ed37f6a177966b94ce2df4e67a3144dbce067a340ec9ce6a9c633e3fdfceeba093997f5165cb44dc7aadbe8ff4d86237e3da6d2dbadc5ad609cc0c1d4897d7a71e8f9cd5e51191ddc83d26caad81b4be0718fc572e195207ae38171d380a345629cc32584f91d1b86bb98098ecdbc5a573440dacf6173ef5bd3baaf97a81915c031fedd6e9fe509f6af642b4e273cf519b77577a53c7c90b555f765eaf2634936050944a5ac396ed9660156fd6e548507966d359e00ec5d5e292ea14484240daaa4ca70e7cb0bfa0d6502e01b4d4457ad59200d2f3517fc9536bd518bcec6721342eecc98d436659e3d5e4ade64f151ef43ed59533850994a6dd39c0d8ac57b4dd2cc1bf76a07fc3eaf6b1dbbdd68d80da356256b806fe8b1e99f5c874684e8cd57d939d46a33db29672a420fc3d2988143862117a375bbd3850cc6a5680ceea7e84cac087815e06793b077e4593b9f506e479a0a0ad0ab7d1a11c35177d50ded446e9760946a952552e9141e29b5531dba208be04eae5d0934b55bad5a3e0d3e40d7315e8a7133c6cd266c28c2ad16f4c686e42acb24745f2d3eaa2c2f13a38d6236fc06fb4fbe93dc5295c657424f1c9636cf9a34eb29e2c559b1e96e502dcff70445be7fbb2ddc7d34e4296e89b4ac180aba2734030989960e8b57dd21c070293dd15b7abb608460ea55c30ab0375028280951ebe8768810752fafbec9c6be4e08f655d06d63a4c74e55956d8ebdd9d46e18471f30db415b195a148a815097b5c88ff516ba350e4a7ffe01cbc029275c9ed787177482ddbd17bbe41b1b7bfd612be7d16fc23550d9a523bc726ceeffff77f1418c31601070850d31541a9aaa987d4736456968ac69731562a5d4dbd770362a5f13e0cd35f0f71a64d862e541dd7d8b3a74236b9dfae34c6a437db68a60f9b00494a4e860f1dc57140743787432b514d4736e896a1c883fca053ecb485930d10f05eb3822265ac69e20672dd043a86b8f1ced2a9f05f361ce418c0c74ba0295febd9d1068859b9a8f1d9d61feab21769d52889c3832ed992efb95b82b2e1bf67b196e125540d13cf5a1e162d7af4b30db896f92b28419f606a70a4f68e0a21ddaf50c6484bc0f2d21b91012452d071edbeb7951eff090843a7f4e7f5a7c8c0ec8ceb2207deab94a534c3eea6cdfe04df52f2614ced2d4fc66922fe1df96957e51bbce7d12cefccbfc48bc2bb9be2b66625ed8a65ab110a0a3e5d2513e855f3a1031fd2247e98cef0c2b8643a6de20fa583ad2e3cd458d12ba4f2eec4d7fe7689c9f139500c32f57550337026e27c1ffce15c16174d0b1739e9ba324abc86235648ce99d957e2d6fedd00776777d2eec2bc854ee2765359f6acf3d29d98ce161b1da97dcf9cc4e43a8c3739654d1fe4bc007ac42518adc0d3d222e68444f0ed55f7a7c2dbe970cebbadf038e6b1784c687a4128f11203ad6ddb0d8b360eaf3a0a3de00aabf93a7f03a14e6e51b2a5ea4a4d7c78b8a4b6cc238ca02991aa20775a17ec45917ccbe535241ba0d0eb2ac47746c51909d567507742b82f3d5974e89d894e12c32db4d08f9a1c246f2be152edf453b3964601bda3a24c60bae99acd7093c8a05927bfbe82867770bffe186a48fa9a59eca32bcdce812a89fa1fbb72e2e0283594716e704fd692979540f16c009500b64336b5d360c217a51a341fcf568cf3ca6c7b3571d4a2d7bb361c78181ceecaf151fbf4b6f36d1e8e7f77e3edb3b2b33d38b4d817abdbcc012e4dfb6d27dfaa637af578ccd47329f47391001fe5839f0257498872614547edad4a4933d9456c4f2db54d5c0cad1070613e05dadcb211f47e83fb465642f4f7e63cbd5d640fb9dbb4794f4193f79727f1b1b5ec936827c61862630a72d18f0912966732c81c90f7b23891fc4cc7396e29fa0f751e865eb07a7650967ec721e1fcbcf57ad9fa49c1db4f355d9803c3986eafcbefdfb31a1dd2fd9c5b2917a38ac49807d6a68c0b7ef173fc8219cc4fe57798853b7245fcb6c010875bc252c4cf225a31cafcc6e41e710e6943ca46e6ba9bfe6d2481133078a3eae020b99b54ab37cc430ad1163fb3b9bb6dacdc112e067aee39260b7db235a8b86cfc581edd1c954b2af6536b250147f988f931126337a189e276ee527ddf6769f4074626400e414bf7ccce83757f45e1bc6a45ebb95f1cfbfcb2c2ed7fc9566db16c47865f31b60414276e6e6b0bb74f0a92434b42f8a13846ce850160b6cd1136698f1aadc5aa196ed63f2216bbe88391dd3e1d7748254f70f03867c9abe78eb899219f3dc241f678336f78befb6b7c10e3ff34bcb7aef315672f5614ee1e94f450841fc5a2b0085b99efcf55910bdbe8c31fe344286bea0ba5ef1a16d56a23193a344a371251b20d5f3b07e6da54124afd053af49ab7678b0beac7b0d625423c9c418080262d37761fb4803aae36d10d7abd66600e77cba0c0de31a56a9fe604c6274eaa64ebe59e5063103d9d5e890a180c590776db396bef3754f3f94917b5538448df3a5e7ad45fb47f3a4c441ea7d7033e11ff6f85a4322e2f2fa57d360857d1609fb8db0e85200f649248139ffca4f8edf8cd53afee330e2bc23953d32cd0c59e2a23efe0120e781341726b1f42765d98928e8c206e85cf2845ff62b202684e028d3e6023ab32cf1ad2003353704cf7afcf889a571a556b5e50762ede72356e7b07317e7bf811b665479331c6bd508b2d00f76d2d6f30dd4a00004ecb9ecea03bb9953eb0c3b5f461ed46dd0405eaa855e17344124986523839406d6ae1714d40524589fd3fe75aea39b316673ef8b27e427f96ac35eb1e37532ce9faca9605fc7a1b9d02f1303adde25fd115868bd5ffb079d15edcb9726a1ed13e32937b13e7b0aed76c75bba27a20a6b21c8b47a78746d5f2d9bfd24255ce14bbefe38a3edf044c8f6241aa0dbfde4569da57940d646e45f02f0af58999406fefcbde5f4af371a8e440bec40f58974657fca524e72afbe05cb6c647f62dd42e683185e615cb9dc845dbce07266b97438f9336c152a8169508b19126b719e17d7edf7ef823cb23978edaa76ea352f6585142e8a605f5f9980e038904caf6178681fa8d0a24cde1349fc21b4de4ce554b09ce2692622091790e1f05e29ae3230f55bd9c48f0d364ee57eb018b77e5912fc6a9e23ac533f4c1268d7d7c723525bdcb2e716fdc877c9c9de704e5a23d3bda54987f1f39b1745c4d5fccffc838165755b65bda5ce63ec9bc6caf3e74918070f1309164c54243d677dca9cd9d6c7e0050ae12052eeb85854cd0b295f09f62c4f3aa76ac0129e4a48ea89393bdde2adfb358766debce5b94cb38ca0286a54025958f430b02ec75ed118dd7be6cd3df8ba61e170625300044b28b87f9adab848594835ade7e1351141c7bb3634df149e4112d960d2988a91a8e3aaf4278f16cbbeb4247820311a49b61e77994e8e0f59d8fc79b01e8094120eaecbf680c5ab128e18268990ba2d1c765aa3b931fcefa698929a3fdb77fb16bce5276c16e655609ead954b7fa1c5c36edccebf092060a691a46eb148db4b4888e19611db0a69cc94a16088fa8a74af06f4bbfe9f86bb1fc4eca8cdb4fc6eaeb0ac31dbc398f372891f3833d881f1091564726fa0818c88e6a99486433226d44df6cc0843949959a633360af86bcd59095c0ba7d69a45aa948be4bafd23d0c53bcc598b2f7fba63e5ff591dd207dfc80bd92f09a71266ef3e24c8ebcbd45dbca512d34ce8d282513948e4aec5c1830496748abc3e05cfbba5f884e1277912704f9cc796aa8d8860fe24d0547d8c60e5f63c8ec27caebf899862d9629846c0a65e99d82082f9a1484733f44d8c6f599961b55a4f5a8b2709660a9a06e645ec6a3a044d4f50d2c75071e867c13dc3818e8fe3782296490b1a510b23f45422aff58bf0be19c53c66db1b02d22f6d12ff8bbcf26d179e2abfa31d1307d8ae3da0c028988b00fdf11bc76b7d78866272fa3553c632c307f47c45f28d491553b53d075b3a488c775b5b13a9ca9626c552b437c4e26678caa6d1cbee4d9cfaca1972271087dd639dbdcd906f430ccd3ca0e954dabb70e815a2638ec49e1502fcf4178dc109e78043d365922b0e24dcd029441160c3641d5a75c61761f18e969f262d1909a526beb659b80b3c8f1ad0e5ad6be4d0e0e53629612fae5dfffc68115dddcc0cc49e413548dcfa755c72055cc26135d774bc5ab2b6ab04815793e6f2bfd017b9324d1b8c47f750ff3cd75bed192c7c506efc256a7396ed359106856f2df389c1829efc48c89b087e33986a739275cbc1b7b30a83221afbeb3c123e18361692ddee845f950e6672df3160c07cfdf88a33eb36229fc00c98124b1864abcaef560603e45de0494e9f1e2d9e4f085806f6915a412cfecb8fd3782b0743b9896f73420d98e1d036a6ef0b9b9ebecef38ccdce8e0449651806671c6b91a9501e6543eaa6ca878ac08d243e225f8c3eca090017409738620883224e6b67bbf2504743a2ede1977ec5433fbf4dca8d4f86ff536113cb1a1969839f029f7d8f1496e0071d4605e1ef412f6b46048ba150a707ba59ca0a700e268b22c1b94a471b2aa90a67b7ab7841dac850a8709e06f817b4d9556dac8936f5d2b94f3d91649471b2ab0005215551345c62b4ce9299867f2490ad9add932a8aef9e98948f2c0cf4121d6cffa4313994ddd588050418d3ecad50d10c9b29fc45e6db036761d890ce34d4cc4604f152faa91e5350000bd3afb618492a57c30ac2ba8073dbb09bb66076d03c505117fe85c2ad0801c1b0fe8305c63b0d902a87a23eb289d337ab835bdcf7338af79ae67c6bb53a4caf83955803c35d0d293a1fde3862cb235f2b2af480e52d9b92c1e21090c73a3b6e2976c341b8ebe2be4996dd61438d0fe7eba4a2b25097e5abe5b88cbeb5514704f8b2c646906b2093e587c6bc4da3e6d661ad22cfaa5fe0640aba97b09140eb107cc3f00533000d3a50c86f5c630a2c00b1e8f815da56baa65d2044c459a36859a6aa09b99a6e43ef46ced539454fa637168466a18631f04276a02062f660a58aa0fb2cd37a69988592af7444240dad24a352aad73e531ab6de0a6f236963bcd6b974337d94544d55affe055a10a59444f6829465019759e2c24fec1544fe029044241bb1994dedc1a1367d2cbdb5b8154174cf6911d75432f9c514291a61bfe420a21e85f770e8a2719643c55fd589eb4b961fe318139d881e8f6096176e2a4056c24955c21c2351a0d66d4bacd170cfff2dce0a3b15c30ef555def1632eb0ffc1258c2b5d02565636a7c886401be1a37a68ce5092a133d1e5ca0ea2cdc5b13092ff774011c7d14ebe2ffc7c19c602d636d7cd5c7dad99f8e9ac49648713b0b0d57d80fa53d87ab7289d17441919d0a0e231f446063c5d72a4fc16016c76f11deaa4d0d3a3ef550a2ad4e12ef12a9b0eec4f3efd77cedd1d878e3a2b47b23f1c4a62a703ae30ee097038ffd00a5130ed69b38582f644cb641b5f9ce46e659f8e7acbca4164d8fc8813c758b25e340777f1d9055ac1abe66c1c169c746a6422269b8ca19fc74efea9d02f6cc428c1be65e860ab3628ef6f7978968aa3d9f2fcdd54bb537cfeaf377b367e2fc051076f4fe9366cf378988e95fa9b68698fa4aff2cc33e77afeae8adc5c234c7da6ce88d47e4d1bc47c27a4c971a149ad1b8029f7f5115169c372a38a3d6efcffd4d233da308e99aac0ecd143f3a9833e72022e56adba95bf53060081bd2511c93c9e3fa423f7ddc7cf2692906f229f74a4b3ddf9f530ad04168e262aab56f50865b20452675ebdf7df42714cb290a88e1f72a893dfd0f07ddbc1bd538daa8b543da3c2a75d9398197e6ac750584cedf374a153c3cb5cb34202f563ffcc2ce0030ed2794037443c777b2ccf88b51b03628b2d3167988d56b405cd5dd58e2a40fd97f747678e2c43f0856b8bca7bac4009ec5b8ac2d4bbdc1a681e5124da97ff19285d515dd52263db011ba0ec5da84a9a6124acefb0459124b5db64f04ece985296ce0206736d5cf3c6529a4e774ef068b2a02b09f44ce9e5bd81f3a80c26a8313ecc2f61a2dad9c41af5b8eba34d72d0f8f7e5b20ec4e6461a3143afea6c51cc02b554df7fb6972437a5a2bd56d50c56329fc5dec80a08db8856398c54f89a2d1e893122f7718e42b46ec108d1193d6293a89f585992bd77db86528b2723e3b30fa98e24ef7517462183ba924f0b3a20ceb7e9c302e9d16dae0367e192727b9486d50066ef3e359a3b43f594c9e05af9fc22183d5674c58340c1426d3db9b06a0ef4ac07f10df8ed38f0e26048c0946532a6af89d0be94e522efd49af7586f89123735243e7c829ffe34adc3b7f6ecc37cd696ce955a5901f2eed5fb3becd1109e0e46cdb60142f48763feba7e45df17e45c19e01e61eafca20d642bff0fb5e236e8e18443f702d3e96250107ef952c786ca356db1bd7dba03e8f259ae5ca9f2b92abf27a2c44f364fada94048434e5096344e761cf1f84267721240de8ca1c53ec61dc6d5c1d653c6baf0163926be2d2d3721bcfe1e82ca75eedd9fa773f0e1dc8fbde08897a9c8b087143cf444cae1f67d96809cfa42586c2128fdca5d4c253c83181b074a4870df1bf2fb21358faaa052ac62c8ba5d89316201eb9542d80a948b695dc88ec0296be4234defad7d33b5a9a4f252e62e303607f0211d48a3629f09ca209c6133f84466a6c1fe2ea2810178ddd8d95dbe61c4c9f781cf515fd59e9a04a06df1ae05b84ca73c93f76047fd4143d05c250e8ab315283afc05d02ef60932caf038ae80b0b8f9df3a0d44a7fb473ed0318fdd01218841197584ed7bd63897f6f27e673762d2c94fe097c90b6d5283891d0c90985044d9f87f600ffb6603720cdc6de8993702e92d19154e1a12e7824c6df5cdb3e3f0d3881db2a9faa033167b05476de68ac2a96f0ad0d1d3ac82dbcafd1ad6effbb18171535edd8b8e054db8307a5eef3e4a03406e9ab59e8f73ba67082125fc7e5f65a70838fbd4362357d31692191089b370a46d491d84db43c1d45a4c409ca09ff500c385ce6adf369f80fdfd5365d410476e0f04676b31054bd7be9bd1acd7180622aaceb446ad16e0ad980e04af15ce334aa784c1c4755dfcb8bad4423d2f1fba347852f49d0bab4a6f78f83ebae86e5e0b0376f2a028c7141d2b9990599e069f455df45dce3f71172ec9ec1c64a3b8f92594a968dfe5e55120195e9002402fea336afc06bcf39b77663eede074c3eccf3052b179e19b8ddf1acd4131a558a2c59712ecc094307fc21a08e8951da71795eeb5bdae4da825fb385147e4eb09d32366b8db8ba72cd36e593bd403824eb74be7b08ff9aaad6c0294172d02b9396903215595ce1f29d3748dcf78770f9c95ba20c8ed3f38ed90438d6a3e355159a1862f239540b49e30700aea7074da4277b767c6677d266a97222504b515a5e0fbbbf036eb6e8f41c6117f0c603a821e192488eed0697b2a2f5c62681b1bf7bfbc328d631830b4e94f3c9570f779e7ac74654d2e6a0549603695c00f0fbb17c098a299c587045871f762d67a1a5578e28013d0d1457e2a0997d8e65501a5a9464c3b0e089af9c4d320cc19da7ffa71233d6885c261eeaedceaba60a7e8f6bddce4dbbd4c9d28322d80b7790761453a559f9fb3600c95626a199dfe5d9d63864e29e9ae1ee6e33c4b16fcd846e563b533952a7be1a34f033083f04a38419952ebca334fa99c6a35dc5d91d447d03fff18e833f6fcb96d6ce9bf0cf186ab4a354f5c9b30dc0a7b0d88ead68c7f0f00eaf5e8bbce1350b4de05ad2572c9f2f6dc859b36dde27976832fe1b03be1bd2db39ba1d43c46b48a0fc041baa2c5e8819529928c9c0f46aa818de8bbe3f38f5e5ac2deeecc2c1ef5d044e9bfdb209c5be06f8c1606c974946900cf2c630bfd5b4f0c3225c60c7efff7009a132deddfdeeb95f1cd0929f2e3f0168d93e73b95499993dd49d6affea58f30aa65970f2bc8af1ebd5a7049ea030fa85615be5f002c5a2363fedfaa7b39e87bae5cc0a567adf9e60aa88ff25296f17c6f2516f03129d7fc28120928bc4db35975e936467c47cb4b01abc26065a7edbb155781bf57b5e7af17abc7948707e64b9604bf839b763999d8bc81300dff374c2ab0d66e20f0a063dc8d6825ed291ea0e577dbb20db7f68b1eeb830ff061be236bf56819ab82c3a9ac645d20e7e5fca3d4a60d23f9f14e5c630c5ece64eb6f42fedc4d78c61a12141da30379b040b50a6a067b2e7cc9aec1e847b1a5d1254323245d5d45f72a394028edf63cbf2c3071ff572c2434ee5f1ad475989ba2a88f81bb6492eab791ca57f974081f38037c5331f7f0aad0c91b5cb2e42d3eebaebdc6fb26978e14690aeee3d8e21d5ae64a0a5a2c8c9e5b19378394e514727d7f0e3921ef2dc9cb002f41000a5b52ca404784e58ec0cea028f4cdcf0559bae7108fa86f489359466fc6d782e2a30061889976bda59d223f36de73ba6aef34b9fdedcbff916bfcb69b5b40acedf3f5295a507c4c677cb98e7bf0c6d78a7e7fef520f5bc0e07e210d3bfefabde81f8c0d811796813e97a4eec0a8bb75a953f77607c2287da4f19caf495d27d469b038d4b7f0101f77e1deb81e703f54993693f68f70fa4524010f9035f419d5005feb179e383acc57adae4e01f8b03e1a377d2150a2e0043ade2018242d57ae4bb5b21ac08dc301f52a4cff4e656f9d3fbbf16f56f76b4028b35b27f4e711884c1cb61136e7cd55f0ed30511fbb726d01c71c94d4bb277baa3086d82c67180e9d4b82ddcbca490010c05d5f64e28f02ca28c4c57bdef61fdbe2b52a9a20e47d4c79f6ecf6585932cdf755ed92320786f26b1206e8ecac37f2d0d750ddf8ce1fba2e30a17137a9d9fc2cb63b7ee72a145d7bdfeaa08d381c1b9f72a4132aca7491f73246d6221864dd5bfc34b933384d131720a01f2840a709a82f47e359024e083086e2e1bca9134cd286eb994a74d133499a2c5a31f3a30fa65ad3663b8096ecceaad946754430da3f453a308ae28df03a619707bfdef12878e1524b96aeac3553273a501dc933e32379b41a751d2b6cc34b484f3b04417cdf0fa9e3b1f3c68a49b189519a944846352b1be422e24e15992251e8def3ab05b6299e21f6ea9aa1d4fed69d197236a92a0ec5345eee09da384e02e57fae9d06c4f2815c4f21baf1a06ccd41b82f932ed1323151b848bdd6753cc73589a95b02465af4c52872146c0d69cfc83004f34c6d40f88724fcc75f43d4db2938ba2b4c7fcbe8c39a32b451e700667f46aa02b68a3d969b7b40b8dd57197c6ad2727c83b3a314da1e852524093b22bbdca78dc95d6d0fb20881cb601bf75475bcbc84c078ff554ba51745e72d34297f154da71fd81969aed28e738e7673bcd4bb51b3ad592a87a85829b5cbd1ade9d2cb950904a3032b3c45430bbfcff0b49284e101d9db0eaab580f4993ac8ec809b429c23acae7ef6796845547db638994514dc83fc0cd4ea5a01c5449a4956eb5eb6147dd6efd0e33bd3ece88d4b557a856c2b90ba53150947da9d681fc3cbd3c9a36460027a8bab600a54fd9c9026fca1627fb658e9a6d2651b70e53b2a011d16297565ca2229b30cfe156bc6478eb0d871e213c4f0f1189a03a0a116ec3399c29e058a10bbb88ca51e4c9a6e25f48759f701e1375b8f5e75f3ef6065841ff82328dc42b4ffd0c3ebad71c79ad2976ab014af3bcfac558513b806d2d68875c2f2ed8ca44e02d4b53bfc617afd4d2aa64329f562a94d25f7bd3ff7e69daa4e990fb00382c6eff6b87ddd9e6661bb945b4041ffad2601c1c6f8c55612f430817cee618468943a43d9ba0a23fa5ac2e8a9e12bc5de6a327ecc08698797e32b4554a9f50a3ff0e74c7e5936a878fcd52bc7309be2f96d583eb8e5e0c465cfaa2d9f7576a24179c95aa6c3a0f54700614fd99c8ed5a4e6d7b21bf78aa252fe4e0929fc3c38074640887b1612b1f2b45497380b0c325b44b48ba20a1a993dcad67f2a10e399fe959223d68c20e8d38e11b61fd46605692cf81303a962b8e0b0d2e64668601ad317c2b65493b557a53eb1cd5ee74edcd8f9748e03495a8644b15d3b4420d18548bed5e7a4424af6454a9091d54bf4967e584bff53193f3f8ceac9f42c03d00012a36f89f1c375719a135568fbb0a378ed1df8432ed9d0f9cfa105c0f595764be8a1a5da70cfb9e30291fd7ea1a88d463a4270d373c970c94a3f664ac84a33ac2e5364514037f6d820dc553219ab76e36b0ad75c9485d755e3cc9bb7cbd0b9a6310e2600027d7db3b769a1f5934725d21f90632c0732296976ae04fe0a3076f137dd7320143838cdf0eda3861d0d3f789868b421a0e4e8c79f3d78b3ffe125e28f9c50f31f4e35128d006cab6f849a050fcc530cab15cbbb56c6d6b3d9038072300f42450a2a7e8a0693a239b3d66548bfd961d9456e985ba1419c7d51d5c13ce805ac1860c1b3cf5a5bd1bb38937b90c73c217121fbffc440ea76762cc00598ef923e0b0a1890cf61b1f035cea970b0040d0ec4aec64a6da4bd8035cb1a8593d325ec5eb40e28f84c259c6edca005dffec90175f3b3bd677b01ad8c0e522c89ed09b23305609d51cc2d1e44f600720026354f8e6a06f028337facd5f3dc1ea4fa3425692c5d54fd280cecefaa1402e97a36c50ef7d44cef09e11ce8ec4e769ee6a9e93403234b5e361c3fca16b1a3a9449f3f7b425cdeac1581d493c028960ce7a7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
