<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"93e0d76fe42e3e8ba21e0c5cc2d6198d45e94947187f08d4063fb313ab84c77482dddd07fbf07219e9b2c7fcd55c7c9dcfa3e5f16ddc71f9008c054f6b4c459b1706a1a0653c55817643154bf67b161bb027cf2e7c7eaa33c8916ae9d2ccc71da97b43e25877101f96f740caaacb664484958684c591676cb6a1bf3993a5c698418b26ffec792fe0fc5528f64dd3d0e081813e68b6c7529390a8ab83828f2aa38871532e8e20b1d559b278eadd75643c45c72d8ac719e81ee5e7278a5db382a9ff7af35f2ba46cd90c8d6255b360c4511359095a8c97e22887435205a1cc015cfa5ebd6a1ea803330452cbb608b508599f79ad7b07ed882d63bf703f7297f887ad03b4a3eb681151770d7e1b39149e64fd9ab081e4a8cf4c079be106915a870267d8ff998fa871576b704be6c6058b3dd5b45b467d49d5736fa0e39f8ed68433faf5e6847ab7faa5ad118a71c6b2f224737a32a7801069c84d948f26d3b1487adf14b60f6623d973640ec38973bbb3a2e21d3ff75bc5365b39fab4c8b09ad7c986a1e5b29968da1bf0302bd352b8f6e1a11248925ecf490fd1098e5f73b290df04d2252abb92233c43d66267c2faa7aa62249e5c2f5f1b2317715bc7813b2e6b97742f26881a5a0a4c66c169df2e86f0484c582e7d65be27a73b3ef501a48079b19ee3c76f3ea2c3994fd9f814f8aa2feba39b6e569733903f1ee1f5a104c1e76b8c67d31cbd640cef00d347addfdf7d9bd33e0883bd807dd8de44021f6bf6ea26b08ef1aefc90cd7f5295dc26111b48f7594fa65bf5a618b346c640a55191497a1105f7fcdb65c21ce94ae6a3fed8aa72a73be5d56721d1df6b38e44f0078a420f88b4bc7992599ae1bc8cc023d029a84dc10dd5e8a997d3fb0714787a164f74e3bc56896524bd3835d8bd6d7c0106bbc7b3585647f855fcb808e9eec3fee9e57df3a0f7857ce49c841d436ddac4864f39c38ecb5a72a8108f20778625aa9decac09dd7a33af85dc5bc24aa7dd352dab10b10c1d26be1a0d8d56ca3b01df1fb87b87bd404ebe706262e6a9f02470f0b75236a97646a8b95b753bcb080ff70c21f08e59225453228508107ec337cda80754d082d1cf53307962604d5d2fc4c1a066642981c68a65ffc74c9e8c79927284fed077ebc1303985f51233b2544fb3302f9916f36eb7c71af2742096b52f000a151fd259bb24e8162011a5204c6515f7ae36b495dbb239e6a9b14c3588de58460504f4fb34c3fe2163f71605726cce08441cfad886acbac08323babc1eb515e1d790b71a2d423b5f9ba197afec3c05d995bac7f3309e74aec1e6c0e41c266dc9ba82a959938277261a5573d7a6938b5fbb5c56ce337b83efc259fb1a2325cdee19df4673f1177ef7160927971f6bac3227e69efa67329fa12bddc7f7b2e8a4b90ba51467967b8a974973ed297cfebf3b1d567df431e3859c02d65a7c5897b568b9a929d7921d2daa93bf82cf01df92d050712d86c8de5237b3d3df1dc7c10555f456d29602fadf5baa50342ca68be79dac2e46c44a603264cb2d4a932ec237cf884779d34f8fcc07055a0af5bd0d4ef943c25eca427a1b89a84fb02f9bf8a51c1c05a7ba0aae2f9e9e0f93b1b4c3b55425d7cee545ad3e38e5cfb51ba3b943a80adc3dbaf522ac6d87519728482830a97acafa85a1652a43d68bd8e16d5a73e01594f3435590123d871a0f0a001dc15f2aade5ddd9c7bb3c53b5640d2f243c5d7590745ad13c8f4e06f7416b1f865759732e7d9bf95adf4a41ba1e83c11ac93538557d6498f70ac943b4414e06f7ce9ca63e0b90959064c474a57d29b914699a2f623ba3412ac2745ec6b01afdb0f34f1b7d05f44e9c1f77a6a841925ea6b3bd485f583d965cda03da08cc849009f4d32c04c710f8fa21e88e66c0e7345da545c43f091b4dfd26d3216efc6d6b7fa4118f89908896b52d0da59fd9e6518e0b8375ead1db736946ea8f225b541d80c18ff589589f34ca4d579a749c1d2713ef9e0b9164a5b341781f5a3fb9cd8164f7c3f3a4f9f97dc85c4a07fe8a47e97c5140ebb13b453481875326bc6e6b6525123c697db620eee229ba2d375c39806bde30eba33d9ef138c4308d9f9c44cb7b7f6a24c1c180f44a22749260d78c69fbbaa2f5d0b07d929d2fd769bef820f70193b55092c3189213f6d00075f58f4e78de7d3b1d6307834ee3c9f7bb82c3b84788d08d132dbdd4f0b95b011c3bb62e8da8832f7a39c4d7385cae10cd9ce549c271b015b6bb012eb1500fcf53c7bac6922b7875f30d2795a8c27deeb1f15c5f9fbc4ac2b3e2e5453bc9fac5efd36a278b6f34669e72de4b7936205cd2b7e0913b6e81e43361a67d5490e528b86d5f71adfa9e39bf599955c78779a50bb86f4df55575cae9f1b0216be7ffdc1a4401a660dfc73a17d4b734f0dcdd60c2203b32d3371e95716be57087880f16a111ef8f0da499e93c57a9bf0b824d52f756da8183501126e0d959d4914ffb2fcb6498a7a394681b7d859b4a7c3007d16a37e5207296f7ffe2152220cdfea409428deb1b18bd2f3344285c729427a2a02c99b3fd2339d0494bd0028fc95c52f1273530681a61dceaa78754004bb36f69ac66a0dd7344027cc8d0625b9e82df66dc001180f8c41cf001c09195c72504987747a4728b2b257391f81dbe65dd2c5d5a4ff59565b3add7914ce6228b259110b9f0d517dd369e388c1015a786db211d3f93610c3c42b52e1ac1da10b105f63d5d6f3e68ca8661e941a334edadbacd4b6ac921e58234374f04073642dbd6277122c87a9d78332b44c9185eeece8f2d80296dffc9206f4e170214ada8c3b95f65e3c3937f9d85526e5305240cff4c6ab8fe91b3fa3f0e86ca0619bb980c190a70fdfff5141f9d9bcbf239ec7a2114a68ab2594dd0396cea9e14f0cc50b8fdc5025a147a8c3540fd389760fbd37afadcea5f010081ecd5cc35908432bc61485904e58b6cdb0ed82cc512c9293d1d2064ae4539037b2e5e61cac32688079679ae00ff11308e1e7e0f04dcbe406e8f2a227e7b4eb45ecb584baa42780c1865b748904fbc342788295806314c2dc6477857e7334053d9fab09be4746c403688f3cb518db5af82d742f56fb12f71496342b7320495fe660b3edfa5b682bf5e1cc207258070f788ce0c0e0db72733a9940a43173976c960bc6a504f991e31dcbc2bbc1a4815a711256097d26bb3ca351c49e91ea0463da6fbc722c182e37ecc41a4b797e82534c98d380ba1b1a9272e33578b63956c9305e72a447d4032182087dbda4423aa702e0251b7e4b79bff671b511eecbdc8ea95122ab40d66875efd320ebe9892f5b1dd0e9561f553cfa7ecc28770e20904c2c058b06e663695762a233d0e841ab0b8b2d6afd34f1c2c5b731ac725793159880607b5103b46706cd04d450c00a2f3e1697b9ec47f5e0ebd737cdb837265c830052016b91c70565288a3e4129457cf88714895ed487ddd787df10d72d877fb3359dba6d3b284f5e1c3a078d0d106804b2aa16707655bfd4dc04647b80201317c6765ce4fee50d3a3553c36f3411711d406015f60aae5098342ca9d00f01df65feb9d51245dcb8d53c0de7992e1660c84fc5ed5bed2f131538c55270a7e8698f771890bf5751f1c750269aa2b789fea459a63f9bf63455076ef44c409cddd46999da02deb1adba7d183c05d408bf021959a23989bc5a77020a502e055d69c251c9a0a006571fd0935db46a28aa4b9b6aceb30e653808d3e90a2ca477f06bc0fd78284696bf44aa317c61b5968c7de8d13f8ab3b5cbcf72a1d09f5293c5bbaf3fc2fc3ebf56740c680fc228acb6aa6a2a8f2f42d3fafb5284dfe8f16665a0c0b9f850354544a4adf144aeeae5da75966728f97113839aecd6f42f57d70397087d049e99bda2b1593eeb6373bd199bf3e673006924a6a27016a323525d3daf45adbfff614bcdff24847da58887195663f031cc946cfa382d495d8762799e718965c563c7bd41a4fabc6d5a26392b100ba78b06f39f0a86946ccee7a225c3264ac61263dfd2ed1f9c6be1a9eb8785f22df92b89ff7bdf30360c306ab64c06e16b02bafba0750837cb977b1681d7ea1a3965d66c02713b00c33b7a1cae0656824c1eb3b03f90110b6f67bf997258f0e999ff74b5f8634ff9adf67fc9c60b24c58057730695229821d835fbc84a28f18bb9cb231c889d06f35cce12c4a8b1ae9e85427cbf698b9ee9e66ce7313f34f377848112d507b5e2fcf4039e52b8dbcb89cbd989639b390ae7b3021652be78525ca4885380639a3bc5dbc0e6d46c64e5f161b2795d6733733aeea056886509cfc47a9b7e81bd09d70374dacab76d1e731acfd2fe789b415b6af132a420b0c058bceab7736c30e71139f39fc37710af4e45f6adfc03336fc3ce0084d8cb1f4f3cc642b894c24f3236902c83d9178331ff16c5d940eb0b5470000ef4dd4038916ebac748bfca8bfe55b8473ead28034d0895a228dfc24f6bc4aeb24a5a36176ce22d8c8c9fa3acbc2fc43a140a967e0514b825a0b66c576b266c40528223c0de478ade183b42e22e230b5091f887c49ad579ac580effb1cb09fa941697d74f7bceaa6af040aaa46f36e6648b238504b0a9259ccec194ea31002f64ffb8c7d6b9c5ce7e98920d388a6a1b536a9456f9ccfb3098ba90e504d9e451d4d15a544643ba1a4242b45d5626f9180e490805db85641c0c2daf08016a22e6559be40c48ebedadbf384074f049b6eafe907b85519a9134c67d1c11ebc1fb7675033215310d4629830e56c1f19c50a2fed7961282f1a0478fa89c29e08762a492faef4ec7438920e56d0b7a0d2ae4bf8b9bca313695b31a72d744b733a6edcb03a901ee5cc0ae27c8c761de9bb8a7efc802e9d1f342d323a295582ad27db874337d79fcf75b926624d4310cf015c97287dbebc026cbe53dd4749b511d3d07b011e209b9503d87241e5563386255712dffe09d6eb73bde9619b3c9aa97b12c07399cd54c500d7cfa1f3681dd7f62d51211e653b84b409b0d3dcc17165793b38fe4c0016714b60564666fb35aa2dedf2c0d2938b20a283d575f9b7034de57055c3de61f77c6fdb8f38bf013634c1d8f1fc7b9ec9787b82dec3fd32f5abb493260cf0c1553d5a1f4abd7f37c539c0519435d01075270759fa3bd955838c8c02ab5fbc4b0cf4ce0fb1c0a88165085775d3c8a209abed7f7e745f840897e5b1ade2045621fc9e075a06e2a96485927ffc1165267563a723dd0f9122689aa9cf97093c47497a669f29d3a532e3dd0aff7e73e97ee8b13ab73e275f5bda830fa2b735fa629bd6c797048c8c6d14631addc6f94c3acf0c5fc2d4f0329f4acb65a52215f41773a72438ede8910414e961d2ddd302314e8228d34a39773c2b2797c02993a9437d5c5ed0c4c28ba17aec87ca21dcaf16720e64c3bebda6a573c2fc688","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
