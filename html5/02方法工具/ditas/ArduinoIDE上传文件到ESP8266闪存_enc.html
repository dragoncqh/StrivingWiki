<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"addbf9fe4586ef0cab355173a32c2c54d05aac90bdf3ae91483faf11843e770afe35cf7aed28b301f4a5d1280841a5edad1106ca6fb3999348eb4042575d56f3aa978108bf553e7d5a2ecfde7d5df476793a25834f3e895b9030f8f0797698aace56eafc6042bce21c79c34ea101a82dc9068a170b60b821415d298d66d7713c4767aeecd20341b11196d7f74f8bd40f7a246e423c44920937e4c9889e004489b55ddcb234ad6da4c083f540bc5cbe798cf4f41e28c137911da6a1631bc955ffc2cb902003a44e8ce96fd2caa11f33998dd1059fc885b6935ccf929f569a390e327d36b0477b587daa57892e82ecfdee495a39bf7980292e6d2a3dfa0440f6e59de3390132cd1698e4c74911fd3ed7bb16b61708298a78af1d509292b819dda1cdec94223cfc6f0f41b160f287edd9e0f79847108695108b16189f1a92f6abc3233c70839fc71498726128cc2dbaf176cbc250c0f5ff64d93f6dbc042afaa5970be1804326c72d39bb42058d8920b771ed1b9a8cb142b7d02257706e3a03866d10239363605242fc56445fd636241e9603a60297bf69a44aef17caf082e5794af7cb0e231b0e9ee7da2011a8fc2cbd35823b358ccb809eafd04b9ac6c1d6c701f7e0c54091fc784ce2a120896573182bb40639c495eef5760a464bc2538d3092f512454efe8b6bdfe57a8856df5456e6c3c6b354d1ec7420ad6173a13e3ac82717c3b1a7a6284149f3d317ea3f36c144ba1470652aac845fdf8ae742a0287c898f67ebf7c737c6237a06257e9079016812f413dfb2a66854ed97cc7683df3f7894c2e3962f2e0d3f70695f88b69dcec1f5e0aba8df3755d66ece57ca6c17c2bf7cbe0939fb33afe34558a652cd189609f63f8b8a5e9fc329b1fbdd58e0d37ca76bfc04dd74ad01c9371c3dc1143bbad6580708267a4625a02250d0818df7b1c86e1659904041b0ceed716fd6723e3612d7cc6fe37d9cf9c1c56b15b93ace9dac0532471203510a63e295d3583186066977a9f076ac14dfd74a7ba4b6052a9862f62c21b4399c11b04dce3608b8e256bb629b30d261c63c5c73770af8657bbdc9f46337c55f15b5d956016a545e444afa5bc08f948551b876ec524a3018eacc2964074d69aa7c374abbd177cc458aa393934db823fc9346bb7e18f7e3cc454bbe3f260e7686b2eb672978a4f2b58f102c864d5a50a4db268cf7a6cb23e1786c57655ff11dae7094dd0b731e4404c1e23999f99b98aad422ffd273b06c8e961f8b12d89de93da79f1cdcf3127e36b8f34733e80636df2f69dcfc666e1a29f7841dda99996b1c9263d21baeb96c2c9c33248060163495cb21c49e97c9c3f62e9aeed271377c64ae19b22e0e1e0a7b57a988f96d13a1f2f34d8813907d938059f7b7b12e2079405fa4507104e6b389cbe0b36439ddf1c82d2df14d8f913f3573cde124a1f73a49ac5e8fd061d76a24c5b05dc4f4e9857609d31853e9497cfaeaf442652d287d224d6b260f28087694302f51a188c61e6334f569cca2e80ddd1fac4801e78cd385e350517d230b8bf3da6b252a242e109dbc80d0ae9f584b97f9f2273f74689f0133a098167ea977bcc151040ea6d55a10e87f37c6751a38a2b84c76b54926a77b57687a62495a4c75274357f11dfb687f8f1e4ce5bdd37cfbc3436de36f1878d5592f8a8908e62fddea1111660bc58bccbdcb6b85673d3a3764c636d71134576473e1c4323bcb5fd8b40c0be03f0a6b58d6e77349e4ecc323c4977eea1350606522ca45cd33bf40c9294f756bc95e601962d1a4d82a1767229365985bf12283f3a219ff49b60bf64e6d8d23a761ec1a7d7d4cb667bbcbfd5ff2aab9278257f4ee6ab844ac08e5c3e94d04a340bda013a04858b13bb1e21e5893106816eb327bd1f000fbee8c89bef4b25929bf00a2ad619b823a2a6c8d8d7cc0958e589c4a41e459d4e36e1ad0274237e2e174f2fea7563d178674cb5a66f8606c2bbf2741e1b855cee568d58b83b5e22169d59f07124687c28d3af7ca050aad69333e6516ef587991e8af55fd8220383de0a2e2e03405497e5cb6b91132b0c53f38100d04423beb4e026294a8ddbeb0140577df360a0bddd2f9091bc37ff09e0d492147dbd63f41d8ba333d3cac8d266407b1a2a6b1997ac23cc6ae15ad1e0587fc36ccd3b2cb200494d1c7b50e82de84a95a028a7f819190375548ab32f8f228fb7f60cc66200c3b324cb87b8066e3d1fad4ff8dded5937893ae3480a4b4ba3a7849188925d633de8d6a61b43a140d0a208de79b439596b389bc9bf850aee2a2f0ff44bd0083931c5f3102bcf273ce7d39bebad9c267ff7eb64a57d9318e97ee3ad4929d72f9ad30b28ba4356df5848d31cf8dc3cb49d44335eca18746a773cf33222f39f94f30d52d8488e6cca7dd782b967800f2d875d478d25b1735229b8a0f319b0d391a1de7c058da421c415274cbb4223d3f362218677e5c5c3a8d5ae378187072b0c7bd1f1f6c2f0c105ab2c38f28ca597c276a79115a5b52caf16927634362e18ee22b9226d7a13f795f84c15cc2abf42c04b41cd8088437c4f01d3a5081d9626239b623c55c7c0352b07e964e18ad756068f6a92fce554ba992c61adb2c14b94da28c1c1e60bad1e26cab458a171d2ca4f3dc922da426b120c3370089cad811c432b1c3f86668162fcba8f6e2a90154a9211f19fef9fc4992b545920220d625449cec70c9041ca6638c99381d03276dd0a7357defa158d9e1587896ac0719a0aa38fb271c21a1304f6991fd2b9023f3d1e0ea34745414ca97444da42a5e23588cce2a6dde1e54e8620ff7a7b6369551df5ffa87dd52dce82513b99ff57317bad74c6440b857ee63730090c872b8d3ee105978d4b4926402cbbb499ff7332c06211e9f6497417664872e449d8c751805d2c60a1ac2f9c01cd1f9873f04366df4f8029183b31db093751cf7ab703feebe3e6804ab33b77f2811af73a62ad3b5a44f3efe8f2495deb5beca04faba32e6940a227bd5116e63cb931015a4625b89b385d2af86a1d9f5541aa28116ae14099cb0eebc3ccbd99e2364fc7365fbdcaef05492170ceadef15b121da7ae076dac41fd44881f87d9b526916ee56c601fe6b86cf5598ed43951552c12a23733523c9077381e42d6ffc1c13f6d69e9b5f255357078456c2a838e6b2e37f7d0f78e93262de8ff64fe3cf005ca0c5312aff9daa44638961548f1d54be2ae52b735273238b6fd6c1b2c6777da923db5b1278664142099df4813b65df97034ff91aaa78943b9b7bf1a97e72937edd4c9d2ee5225ac57621105ac35aedee1559c9614ff8ba2c3b3c65b5a8cc2c83f0c4032e042b55fedd9d5a233b24794d56f4fff233af6f88bfe71d06b724a0ff8f6732dfb2736852a44d997637da84d633a95d1ba2be5eac183133210d945f3a213725001a58e0d1282fa0730713ded4459b82b492f7e212fb7b07c6874e544aded7fabc25ccca227e3fdce89f8e997cee6eb3d3f7ade34691a50501fa0b92b2bed67c0e2a56f25cfb1fe1400eaa1dadbf3f634f5aafae1dca73580b5d3da3fe20a9aa9bceba692954978ed60b9e40a0d37c8f4040eefa400cce2fb076d3432a3f95b14250c81e673fa3565f9c3b0f25a98010cb82d6bef4ad4873ad400e6f5dbba9700e402198bf1d40281af79fca4dca80d71a7aef6903be80a6dc72692fa28d8a5832b087fb6d014169317dc8c1d010fc0ee3fc45d9d9673f8b834530225fb17d71d8f2c64467d9dd824c6971f14f879de2aa21e7d3cb3acbf4653694433f4687b6ee1cdf169d825278a79076c0e793a7d64f787b505ddbaef5528d5e4e84de043d321579b96fa136f5ed83dd9e14fc2bc9af6883e5baece5870e95704e714d3662e91aa1bd1c99d270f9d321117a5dba57dabc8799e2c230e17ebc24e5347d38bbcc7851877053059e69009f57530bb8049770272896205a4d52e268e990925eb1e14f51f0cd90e6b54880a682697e2eb518370e769f361112b6540976faa59d7117f585fb4953660345aff1a83984e4b9dc8b04da2383a52264eedbe05c62d10c3ed77477e33fb6c29e1e10a010f8b8036a305b4a7ff784be83a8c430f27c47cd3f4ff880be2178e0137f9a4112f8a151e7b2f0b7fb52b1bcd99bead1668c81720e644a471a8a633e8f7be0a07be7dd9c57004441635e1579211c5d89aff697a77bb81c40a5c17ad8d36443b183c2beedcd2926761b01f03cd7ef16738bfa91226dc14060c9eb08ebe9e1ed1b119fb3d48ddd5a92548dae508a82a6f159c0f1f8da8c8b795ea5a2689d1a3f07811642b7deef38036d60071b74be1c1d3de2135cb406ef17ffe8920846c4d08074b71aab77777a33373fccb344f4bb73071e766f6c6286c03cf6cd598587248eb461c3e4c67d3444d71ab74318675c334a50cfb3cb644bf6dbc269d57261c5a3f78384f7b189116d1529247c7880c22fd979619de9321d7f4974a4c497b674187b0cb6e677a97c78480cb2d2e36c080cbadc3401ee33202b7386ae7c6cd607148a0597a094776db894d3e0ba3920a551fce29e89ce8b9ac5a375eeaa655dfabf78b1f01626c4b2931cb6b6760f3c7e94ca3ca6d5ac38840d4930f8716fa6f463abf1c31f716dbfd84d5642a6a7d1eae95c77f44d0c78442ced00349e2c85f1ebe97089b884460a7d329de83bfa9adf8699cd85120494bd04d43b2f71e3ef0575afe4d12f8df41bc71e53658e7245188f966c9edc9b623ad57fa91b21f4a1e7cbd4bf8a29f2d56929e2c68cf161dac5ceafc510f0da6e2d79de4c3fe85c66dcd1733d176e25c0f9954f444227250f2eb213db1e9a6e4aa70eedf40d0128eeca81da540796473033ecf01c2e2b1974abf26e281bd701c262d7bdd106a174f7aeb5d76e9036a93e379243337b2c26053766256ae3a111b4d78a61a96d5128d632cae18b800e39ef8f3c5b268a4c673d8b46f71105e07bace12e444e2e9796e2966b99997e371c4f4c351a108fb4730b5522a14ae50103d7733c9e068d5b730ee2c3dd85f785d49f1f23112121cbb9a790a4d8f9c34746f86a0eebb6222a50b63e9e58b5db4c6df28026b57579bfe528eebc8d48862c02574e8d0b1cf18dd80f268b47e81e01296201490e45d0f7f18521627be4bee428af7a6df57ea9a8f71140e10a4278fa2a573bb233484efd61c3eb0a3bf96698d730d89c33ceb3eb0b6890fb420c26b9900ad0244243c9ed0a26d5d5119a6f873a5ef2417173f80ed1ee9fac1689816e0922cb703dd54106388cb563a3ed45f374fd694f857b6aa36febccdef3f98effe02486e585b131d34e30a54e9fd8646a775d8487fbcb73448843948c9d1fa5344582b771adab5f27b43b8827a75cbfb3f334b6f55ab0929ef765d8d9712e2645986da386330ca0a5542a9558d7e7fe35f4b39adb68a0ba68507bb1655d5153eea702dfeb529741fc947cc5abaa2ca1bd1c5eb104764149a1a423fb7e2cd88d6bd68d9f7f732648328b54483c259e826749535912beac375a8c7ce3eb215d36c1d0d8619694f27d7d4b48a4269f139f2d0c389f5fcdef4c84d94ee3362f6a8a96be43d808470dbba1c093ff441f0b84570336cd9c53c4ff3bd5591e70c59de0934ee68b5af78d90c0e45be5758b299d7f2d701e89891f0be3e6ce9e57379f359848e398970638b5471cf7eb8727a695105b3b7f12e9d271341a1cf6e3cd6de75ce6ceb1f413ef18dfeeafbfaf3afe3920e43256d50f2840a8aedca3b61b9e0af9489140fef3177ad95f0d5eaba882082c37a27d9925f8826d018d73154fae87ece5b0011632a3853d71ec1361352c6c20862ac6dfd10ad342553e2faff142602cf98522cb2aa0c20245461fff5c226132a3661eba02027a8cf1ea4e5d4b57e76950f692cf34331e07be4dd18a010821a6ee649c68d1f43cc10c328837ac399cba07f06255955384fb2ef80dc4e6bd818735a428d7eb41c42f851682f01f84c073ed5dc0e6bfb61e851869a60a180c13c6017b9cfa752623a4bda5de33ef095ea87b95911c3d26cd52c346e5f5308c23b378e1f8cc2a468142e86341347103e86eb22bc22d02b1a63017f53652a67ca078212b3f63cd13c88123951e91cacfec31f36acc291c10b34acd60207f1e1d57a819ab23c750972e567434859b1762c338f9f4037c735a89714f47e9f648aef771db2fda5ddc4e7d8232fbd5048e720b430bdd23728dfdc3e5a4a68e36682ffc5ce822985587099dd23db70e13b36976e85c444bc662fbf9c2657833b318c969cc94e9de021a2deaba2126d372d85494adf65728a56c432d69539c60004316c91bc6541f8cae450d3206f80169aeb918a41d63f49d1ddd88dd1ce4601862c6f193f567a0bffb024765de578efd03fee50cccb269baa2d1fd62ed0fe1db4965a4146587f3f4a40c34377c40b938285dfb607a2a7b6c98a6f992d326333dfb3363fed5703eeccd97e79ab52432f084d5d3373246e6c1c2b4b109051985d3337b0153ee3d987e359b5d02b567bb5fc7f2c94d9ff14a4f62d5ae1eb27c9b6db192c719ac9a6e076c056608ac4fe2d21822f5b79b2bd67d9aef77c7cbc6ca61317b42070354f3bca813fa439554ae7aad08bf43cd4065e779105901445c59981a4e4be843c5d28314cbefd86ac231fc45312052bbf7dd27993497f4bdf254b052bcefb516d557a116e5b9b745aab8b82dbdb28254fc480ff83850b47ea3eab860fed537c23e708a85ea598af6a2efa0622d5e0d353e6ff71d239a35fd0e141b41719b00d37be541615cb810e5e781424f7cc66577d71be6dc982012002226b6455620cf93c3de65dbcf2df665095866f0cecb2e4359714d8386946a038a477c1aca37030da04a16fd360a409ef62b92602d12a1274240b38d3244a1767b3ccb50a96c53166e76487fa7d0c1bf01e6100e6a9d8e4ada37e2c005666b4b838cf5008c0f2b01a847237dc12a7487bad429f8ba306cd720faf4eb44f2e3dcb35ca859d9110f926fa6ac691321fa9797b026ff95dda2aeae8d55330655fc8545371ead8ff773318f1cf671424a1d998b5193ad76f88c66b45d6b7074e0a867fe16e3b34414a0c8d1c65678ef9137b0d1c82a568b9da5e1a9315573dac1e1007658ccd0fe8c6616e165a4a5569760ca166db57089aad05700ba1c7681ded955b02bcb42a0b83e1710fe591ca34aae6c0476748774b70afd1d2a74ebaf23d4c97b47c8a65aa23d0e65308a3a95415f89d33eaefe52bec0ad8f7f93e9664e255450e8137cd8ebc219885acc3fb1de30750172ed17ade0e2c5a0579794065cd23a8be23fae1366f14ba193299d288bf6b751c555e17d343e4219f088dee52a1e856d12bf1714f069ceb7c36a9a23faa24ae7a2cca4d32c6564c399cf5a587d6d196ccaf6614326efae3741cb3cead1f08e38b939f203e8300e8909818ea6a69f2f2f10ff5ef41dfed382c3b82f9192358b8b244129a949faf0ba88898baba30c57c39f6c27327c1a9c38cedf24184f1c77d76f0a544037ff0576f4e44db43a6d6f2a7a9c958a4566d92bd13bbe32b4fd47453e5839e7ed5614822ba564dbd13a7cabd8be7347fa97146cb4a6d1c8c97dcf258f8983e23723cac25e57062b0c2bedecd36c6004c95a2cd7d6f46753c37b4ba79b93569171aadb409bb9c20f856d0f7ab2e859cd9db747da6b5c2ab8183f76dd1e3af809d13b4cf824a62874f9812ce9506656438e13224bb169e31c1e7ccd5ad725f534907abf84d843aaf51b917e43a44f60214449202d6daff748024efa929a3218d6ba882edc9ac1a9a9662a268d8911d4dcfa44e02b0da2edbf15fda7d642624296e8ba24ad0116d9f44fc31378de426b96e869ee7f59077aa1ba15de44fc332bdf064f22bc9e0f38a5ac7dd40b5505707550f0a2e87e42e3ff8221a7ed3d6838c34e19af6923e1c50af76cead977d5506bf8cdb04c0db844490bd447f454b3fef7133ab0e5bb508b219224833f9a4253985fbe912dabee2e9807d98e171690852bf30561b86c6f33293b9e80e932609a71ea6acfb65d40fb93b4e882c7257601207c77c6b53632f919c5b2aeeedcc999a02b345fc7a5c6b7ababf16574bbca49a1e0bfe557b87e0caff97f0108fa146b3b94ed5287fd0522df9100157bc2277702215040770dd98a33bfc645e4734c6ee67b8f3a0946efe2a6bf972d8fc716aa745f9a4497a87abcec1fb43af56f0dd55775e2cbab55187fac28e32464f31e942dfb9017b5807cc057caf85e811826cc7d87cf68fd165d5f961277acfd8fb5c6f917cda210c97fb5e307b9ca0dc92eb1efbc35d483fd00eb35e75a6e8aae9371b50b53bf456c3f53be18041c271e94d0900930f4c71030d48c52a1b4f2b4f7f7fffefa36e6633e7ecc9e30d701c06e211c7679c8e999d0183b0ef9f2b70a9c8b6571eaf951802fb6bbbee42f4daacb627ab9444c4a705d58292b7a3878f200bbf30e4917916b4bbf099b380b20f11f441652fb5a605c475c8cca0247c46a423492a2ccb205de99397eb904808fbc6793774ad1d5ff17406f4a5bedf037d243eca115ffd1ab9e958282dc27e2b26387efd040a0dfb0a96d09ffa8188ffc03767bd45d57c39c88d5320b3359f2563736847226359639ee8f2336190374c12d604ea0acad46509bdb7a63d8f05ba66ebc6c6a8dd803a37365ef315deeaed2c046b68f8953096c31215c4a3748f5c9484c3eb3abc16c2e8220a90d985c4a59ade6a5443b1109c8ec51e22bfc5ae5e2ca9e441e72df24429932d17297c8f31c73fddbfe94dac8704b17375a579cb3629a4bad9612e271776c7936dfc00c15067ecfb5c43c93562f4aa7633c9c4e474d65540b4177256eac65dffacbc02403cb2cb9f53613a580f144bfa7c3d991f9332ea296995b52089559fbe4757b92801dfc95fcc4a9e3630f0f1b96fdf6c4b8be53b59f3ebd8e6a6375b3365e79e4042c084da8c41c76b2a2ee40f672e9d287153094481ab7cbf9f54a64a23e79e83489ac05c2e38fb408b72874edba75b70418454606f7cdff5f96650c61308b20e123da45975258113994d1597093400577f0ed033114d564cdcf3d2d18a7ded40b36d963c75d23246ed960a559177e458ea64715d2bff1c02249b53c59d6613b6dc07266f891699871a3e972c056d60fbf0dd866cc208092af14571253ae835d0caa324c6bc368ca8efe6e99ad3a336974e31c0461ca3c1c06683bee3f0467661174b1842ba008243ff27ab516e48f0305bbf9d9b2f31cc5277be3c29a941155387b0ffde19f8776e672578dc2a88f8948da65609333d681256413f9d643c5e775569be196211e838f355c69b91b80de99e9552ae96300a8aa86cfff78cf44f981cf5cab8a107fba786ed4784acb107aac5769c1bc340d6dd601c310647d4ece582580b823bfd46f7f25deaaa5edcfadf0e27a6cdd241709811623c0910553b3fac9b9c96503faec5a8d0d1c523da4b575c46cd9b9067e82fbc57b8589514ef369196985384b6932c81fe4cec73e1944e607910c79e30ed5ac09ce6be9f859cb6280abe11531c6e67855c1b52bff051b40f3fa1b88c062de6c244e969e339f6bcb0198da3ba866f7674df4c84a700ff1ad7a40daa49d3da94e7781b03db90ae09c2367e62de0b37dbba8f410b644e1ee5c6b9bc43c877ca96d1ebf49cff3aad5407a3a215267dcee6de5e106c29eb4435bf3dc3aed24ab5e283e0634cd1e665cf27762edfe0ac790590fae0e752235c6d6a81f7cf49fb32d81819a062eb567dc80fff3f2d1fc92c3e25dc580958f74b6626b99e951456b23491a2809e32fe5ebd8ee6367321511f5ea886084eaa9b06c8cc1a08f17671d8eee58021d8ced97a50ca586764bc3de7bfa0ac5456cd415d07f8f61648ac71ed4f02a476c04cfbd2084f538e2dfc279bd0f53c8389acf632f3b9c04636041fa0e4fb7a5f5546330d9ebeaf10040322223f9eaa7f9650ca30d5f372ae49911e9dd46348516c98ba108677390ec13c1c50655135381d32e714b87d0dfcc61f39c5f71a336692cc54a149753b7ce31e70b568a9b705309124b0963ed0ae4c7a78b736a7944d6715160f7e2f8c0dae3513fd255931f5d48e35e9a85eee6cf5d39cc1fc3b3979e58c6247bdff705733090d9a430857ae0bea77b5a892acb274164d5293af5976fd9e5bfd9c2d96bc8af15f19892d9baf677a6f2dc4f0b4445d911b3286d8b40bdfa5b41cb1136ccf9daa16e0edb827fc4fe762b2712cd6740d543618be008e714615474f4548703e1384ce5f874b0a6ee4dffcdce11f11af7ac7e1592e58320b3b208fef737a24e2ae9aba1b85b5318af2cee7edd0f06a22319387a47097bbdd10bf2ef1b5c95db188047d26e7d5dd7b99cfd72a55ffa19f0563c471a1e7fa7652d023e6b16dba443f122137986fd41b37a1eaebc3a0c7f1d38c5757d0e71b224ab3187da8a291f734819ee8b94c23d6d73a91d0fc6ac8432d7b592876007f4ae87f925af04355d997d345c3a137dd2ddd7c4882c165be86acc447a0ea2c94c95f0ad3e573e967256b6c4394bc182845c946e4e78e77a13ec16d977ac61c13e662a61859f4a741913988b89fa79ac878ff49ae8c1a7ead7eed01755ac020a77e22580d9f54695cf20aae067bfab88aab943e780a447cad241da7fa380c1db5f6b446738584b5878e9c0b592f9ec6ccaf061a362a64da6d0b9a1a4913077f8fa6c2a92a42f14baf058596c15725fe909394203f9419b0a8c0b2be543f81e7820dfae3197b5003e35035f76a8b7e82831c2fec601ac1d902aa10678a1fbf8f2b7169999d741e64d8bed57eb858e23cd2ea303e7cb7d22e4dfe2a65fe3c9def86a4eb503c9fb66c0e78fed6bedf7f0de5c905f0fae46be66224ffea9287613455e6e183e0ef114880bfe6e6264ead3feec410dbe8d08a4f9dffcb33cd3f442eab1eb05409e9bd670cd03e6a67a1d65b1f48dc8ec88bb729e5b2a6139c40d193dcc6e245cf88c3981c2cae925aa3e7760b185af9e1bc07faf4222eee917a37b8f421931da71a539f69ba3330948f8ed7aa997d91d6c405857809df14a9b8888a3f2bf9f9809100c01581027042b2cd796fa4e47b932f65dadc04ac77aaaba78d9d36eb3c1e15454acfd335536c07b98db99602fe695200934cf36e8d971a9e11a5c73e82865e41a2e132df66c4d25de00c4d7478ecbb5c96c658713202b35efda7c84d4f98e9ea452ff5fef7b252bcea407acd12f5daf6a2c6ac3526776840c9a126b1eac6d7d83c7961ff637d5f36bbae4bc2cab54ba2419b6489527f3c7220e187f00f0b645e17a39e56ad9a5e19d1277418d5058e910e3ecf90ec53ec47c1c6ba4dc496bdd24c8c588b2ae56d276b09c0cc389162db630bd2d781764c09b09d936fc7e312090f49236d30d239d35959dca9a3bb82db47cca42daf1a135b7f459755721167bd5ed916ada142331265b3ff2de6db71b91ccbbdd796110dc5a503564d01e4dc6466c16145980c0a816935578562f5ce0e5cd50c6af0847a8e35fc4c619d0de6f590be7ecb8dbcce81aa4a0a623431cab6028b1d13f92264709f1906c538844fb08b538e9c896562234426395d5b7184a53f63eeb5a4b973aacb0f15df47cd46894c6cb8814ceefde1376fd8e701d53ca9be25d48e5852e83290859dad0c28456345413e8eb460ddb562d781d8c052af838f06a3656e205c9137b895bad168988634649515d135caecb024da1f49c2f6699e81a254ddd78d3dd413207e9781bfdebb7d47d118357b780f98f7d72744c342a410ec2a3f66fafc6a66ce89e9a11034041d391dbcda727dcd131daccf3a54ded8110551db013e02e37c5a90f5c40dfb04c03aa21f6fb4cb39b9c482a947d834da1cd755e68bca4e520f235a7d9b9556e6d54f5471abf7d25c657f85e481c2b7addd2bf3be61db67565dc2ab52fa8b7ea7dde54e5ebbc0c8d877f6a35b22331cd4fe8b2d568920237067d760245dfd31c1048ea1100698c164140f24ee3fc9b8c9fbd4808e09c841e44a2cd0bf44edf34fd407919ac9916caa5819dc93f24d884bcb983dac1a2b4104a16350e4e449e3a70298e7b30d806f13a89afcfaaf47882de3e97799e0702caf2c0e2954c266e5b93bcee06bc00af4cee8c15b31d1af3e9d226fba876daa150b2705f3e444cd8e28215b13faa079f153b05ab75e9c2cc91c96af64b51c9834eaa93574190cd6794f858ec690fb4a0965c374f6a4d547e50305c498133666dc09ec1574172749c1fc58e3eb291bce4c737ba16b15d0f8b85b28a83db2d8bf8beae65ae34f328466c4316560d3447a658dd2113c10e6a9e8afd39a47950b8e55305657265549c18529587f910c574ff93f805db2ac18642dc5c3567e0953d1c20c7d09b20461684f525fa48b4ba131f2893e96a40b80d4abb00287c7f3ad68d912eb2c7029f5738fb0dfbd71e96d33b012f9b4d012a867b36c52e99b6c32403c9bedd280509fb34b910bbc926379638991","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
