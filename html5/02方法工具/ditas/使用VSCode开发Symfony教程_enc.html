<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4206d0f28bcc07cb6501419efa61679648f2c86ec6a7c5c07aa116d353b90271e0fdd1db0bb976aab2c5a780e3cc8d1c6c8c57383c3ef490eea813a8a1fb111d993a16b0171ca4aabb995b98d096aede1785af1a9c02d81f4d3c1f196597f9bcedee422c0b70bdda9481b0aae6cc892d2dd7d0ca17ec3d3f32fdeaf20f74d6b9988c7b1bb189204871db95f4e9aa56144a3f182e1124789f0b8eaf64240d42da20d64203eccf9ec78d7b40ca8652e30527b53b2b9cf5cbabeb6de5c4f9f7d5407c87b47895f0380bd9b769d5e4e3e9592b483ac2e5b2a37c8a2996f8acc3e75231eb15e1f4692fdb8f29ee386338b73f3548c962c938d5323f85a0a251ab8c3ad40a4997439ab7b6dfad4b0a1448521941f96d9898fbb474a4adbfe56d53704d44ab466f77f1a144229e5ccfbdef5d3610bd4245f70ecfc5d534c32505e3388c3e3cacd7ea726a31c84c1c1a79b50980f213a1610f3bb880c7941df96a19ea45e35497fe1d1f18e71df668ae52f64f2377e82f4fa0d0e34040e14a2a9a69e1ea477cdfb014677786a770a70b89751d4dc2399aae39fa7d017e93143d861f1aec98b7975dc6d03d41670d37e82ecfb9863764059951e5aa9033cb3b740d728c565edb1aa06a79ade7b33a8250ff839cc384d69efbb3b7c62028c687b853b515a0044b2592c647e714e5df14f0a4d5c5532595994139f60019b7d5dda522ca1f743aa325ce8a39b3330e4064236e6445140d055110babc45adb9354d7bb086e3af4b5d75c39efe82412d049ec7a3ef8528d1569254617b23ac44eb032c94ae84995ebf06ede38035b10726f4c73fbd00615a22d9388de96e4d7f3f85d579b54a86f7786aa8c8d24afba83e2797133f4fc597bce051f4a37868d2cffd6ade249296adad028f32324b2a8736a10d35bb3801d471a2c71d14f929c3357f5979de89eb6fe25c0160dcb19fd4538ebf49e3576948f4b930603b25e1b1a36d5c57fd039d9249fa655c568623f123d2baef82e6e877e945b65dc35ccb7d23493d9964894f6a0b2886653ee452396e27ad690303155e57486b3ce709addcb6cbda07394719e0101d8877b5586574d3d4fbd8d3b3fdce031b4a141e67f4202eacb313c5cc4b3f6e588a741e3a1b414ad5263d57eee8b41aec6115ed65db59d0b2075154919d6d8faec0fc0bc091c537434c5910a24f5a529618ca8efeaf7b80695d49e81cad94be3dcd95a6534848c01f4579a19225a92ce86ebd298a48328516e43c7d028dedc40ca200a729d52a4827f06e2587fb742a8b1d05e3132b592636c8f387dfc272de1ca5e4768f51897afd76407abd074f5c02a6a89135f761e17764d030fe5ee05893dc020f78319c0001b4bf2b3aae10817b25a177880fef26669da9edbdff4a8bd24d540ba0d79e5e37946fd3dad38c61089d5010d6559203de7823f635ade97c871dacfe304ae3a36170fa927d0aa5005613c5448e9e319a292d72210093026948004677fd124679cb8f5c605b58bd24bfb5fbd1b73982391435544fa6e48815ca6bafeaefb53cd97ec30526ada300bcd706c9ad026ffaf2a3d16f48a7dc4b94aa40bc981c847cb6d5dee62b29dd62cd405d1050f552b33475dcb4b714e2fbf0a39b9c2219a74c1c70ad8ee65c0f68e0e7e929a71a73e0ef197d6050a3e672509d978e4daf1b87da67f8fd099eaf36e7600eb3c31e79b2b3d4fc995a6127efec4d03ca0feccaad2ec59f3f9845e0771337e21f781a088d16f52fd90b8eeac7c51b740557063f05927c6269322c3e5d9dea6e259f761e7bc7345f695fd0da02888bb810cec10558f8e617f819ce742007e8ad98f1230d550150b6fd89afc8d224dcb0c39208730fb0a979fa4647f8dab8a661490bd2adfd798f1ee12bc0d6b603ed7bf24d4e65e3ddb7defed8c866fe33461395bb9b871c7e5f729a513939ad441acb84bb732a966bd479153c1d06d75cb79009fc1a33b0c1a1c0e4dbd5edf230f2f2af48481e5ca0056ddfe57c82cddb7275b43d4ebab7eb49720e5c2c35376bad726b60dab3c2f6522d1ceb100149a77e2bad5aacd625c157d59dd4dd6e00d61f39a6a037aaf99890be22cf63d9634fa7bf79ec2a81f7392bf514505638393639916de15ce536e113e121b8f501ad41d60cb62bc08788347d1dd50f38bfa8710c77caae54025fdae3f6d88ab06c40588f2289497b7d9280a74ed3edcd266b8765744b4e4e4a72ee4526aa447ebd6715f925673b7ae44553078cf2d98f95a49343420564005c33bf1e98a25c4b9cfcd7e127fab5ba86df45addf007c11ed12635254e7bf3ca90c1f813688909fa5126b0587b5ebf7745881779aee7076668a39d720490131fa475662cba4dd99df6cdbcb267abeeb53563db3f50da27f47e680f06328acd7470d1824cb3d485260732fd3e5481c952a8f68e057656888113cbcc62414e60e58d67394b5b1fefed21361acc619853249c254bec6863c8141e0af5caea59c1e4cf30b633c81e75b18475d4a2bf970b14574f80f86c2f3a8315ee2053eff59ae1c53f763eb1d17a47dab7217a5f0c5cb6fb6eda61cea86cc5e7107b942e27f54c8cb342077d1de9f2c4a94b55f1c24bc0ec32be346d313b3f24b8f35c2868241ef876a7cdbe060e647c5ce3b034c0f5e128a8ece8c6bdb5a5262fa91c2abb75debd6e49f01fa4559f6a77501f1e5fa763c4a09dc4d881873ab6b3187034dac5ac78d8390e47f345d97e1f36a877ef7a7ef862e4d08dbdd2843d7fa9e847f7d52174861d4a0d70ca832d746f34da7eab653a5fb8c3cd0633ba9425d6ef6b80759f7e387da11d20d0329841b6fdce528b8976cce59e2ccf2453595260b6b311cfcec2304eb65e173beaf9c77d25a3a17743fd68216924f7fc328b6a8b06609b03cf5753c71936f61ebd3be2837a0390a84197e21196a298af72a2a4feda106faa444095c71391a53751e7083e460f63e53fcd0f5d055ef15b5f3504f7b90af135ce101a8605f2408642588c9c48f79f9efcdcb75301341aa505d1e184da6dac060690cf63fdfb5e437f776b8ed1ece948c3dc806c0344dfe6cee2eda55aa8f646ddd9bae8e4fd44873cb8c52defefc0e32bda6cc989bb4cfddd078e521035022d2868c61e6debd09e3ac67ae922b207bd16ebf1aea16382bc7408d07ffa4971a917cd7fe8f22ac6d46d404ea5b6b7f35b74ca72bfc0646755647e1e9a73b5764b25223c715ead7d69aaf84efb7db7a4d91e77553391589c6fbe6f8a1ffa2966457300a4737e7f56845679dd43a0841b95ad5e6d8e49c3b454a0d246ca6fd541f416cafba49cd30197a3aed1f4ebdcaa481cace3025d59e53247631a09028c892aefcb8c4e5db21d6a629d1ed2a321237c433e5426c21f33a55f86afc7e4940260475b7f431c57383f2968d835513568c43fe0d762181e18a6adac177e20c352202faaa9089d61b77896eee4793dfa3a81f1b291998d2f11aa61d3866c963b46bff61a1161409059623b1a6e52e32b2f16baa542657fa3e057a175a3aa4ddae061298453bbc7496f47a146a4ec7a6d4d3dcf77a2b4c796eda93e881b7f6f1f9c842ff21c1b35756eb43770053c95cbb58a8af43d4a0fa75c56713408b6ef4b3f0d93c437012ff8cd82443c250f27b1310ef71837cd058aac12cf4bccefd3632a65e01659de7fdc743f622f2aca3f08faa06b8560d56fbc862a56a04afa5a18fc0f82fad8164b3fcf3ef54674a9173dbe313532efaf72c0c1233a2a4e44cca0cbc979d8d5dc81e5d018f48e8a7ec4efab12fb62d04e9ae98b19572865b7c97998b5296eca079a7a0f6ed3247a2de532ab9607035ca248e7d779d36fac9c97055b3d10a912131bf2f92a2b48f8743a9afc5036042a7c2a4766b07c81e2a92b75dd71ea5bd5a3df31612c273a23856636601b48dfe699ae4809dba05475f7d4774965c834c6e39e59c08d8ec484726d8f99d301f2a572081a6ef8046c9791edd92bb7046176d24cefb25ba77e79c4ffd62707e3eb50ecb30efdfb0c585db157827952cc3bf063bda36e4519bd813a2e548c39cc6f0e17c1d0c76dd4090e6adcae03c11100c7330f54dd9bf5552a7a19e941a665e73174039ea6cef5c4f30de8d1b0df8db7d76146418f5068f6ab9d493c0f6f720975628feaaeb5ccda52b9ef65aa9f10887dba6b5ab810516e73ea5a50cdb75fe336f35dadb724c2ea4891e989e04774a4a299fd30b5e8e1ab4894e328c5946fd8bf9f6c66373a98087bc6c37846843b1018240402dbe1a2ccf72d0c5b17f2e78e5466935be96b3505de36f4191723e6383e6f4e6dfa3e76f298b782b70cd02aba1602c182d466126729baaa08f6e05e0fab7d6e22c1c0280e57935ec446759483a78cf5fa24038785402f1c67240e5743699a34407a394310a5a66c8c1912eb7e61cc4f23855778952d9f146ac3b8c1d3e9bb56bff37c02514f91949e974741a0dc535a8261319ab2bfdb1eb503842acab266d1d2f00f5957b24e3a6201e4029f08f3861ce87d6663742a29d8cc93a3cc059a7dec5199de67a35ccbee55adc32c97c4a241e0d3e19d9525334719cdce94ed0bba52b049ef14f1d2b7d58ca63edec9dff7f723100979f20870a3a44787a88a7013e4d48896c2671dbe870cacc16ec8aabe7d81a35f39db11f814e974e5703e443b94105d41a7580b3d5a093a3f05aa90a40ee6f8c7536490a7caee4a422bd3314c04e6493170b35b1ca3d25cbcf7069495dc7727b86a7b8cfff5eac2d48c3f9b23444ef3eac39043e55287ab2ff4c6ea01805f6b5728f0aebdbb0a45fce7f80e8f9c27509709e191c62841a25253c851615ac3c935c2024066864afcddd781c97f7f0186cbd6f7b8b00fbd2c352df8ef56c602eb86f61a03d25ccfd4e20e5b1e6b047a3020e8bdd6586d679f337c08f61e842b3b557057f64cf8ea6151ca3fe4ab594d0dd12240b783721224594ba724dbf1c2de24524adfc0fe2da868b93e595c3abfdf2b71850646363d837a4987a2b71cb2f78b35e13a84c0e1c31c873d7d2d7f5ff271609f38d819381fc2c9f3ec2c8bd4234f07609cc1ef68e7818bb32647a3b8de334cffbcc8323ef5ea4313b2a9b278f92369fb99b170cfa272ad3981a019b9174b81cf8ed9de381342c3e720f9c8a7e1b2ceb1966f382716e04d01917c06facfd49e5e19bb7f4ccc3fec4705628d377818b91eda2cdc6cbd43827765f251cd112bde32c4b399adc647541ee68581ef3c1317eaa4d5445bf15e438ec04d9a42033e912741d6c33a7df19786d1e817f50b155cb723607b23b2bb877cbc14cc731483db91a3d21997136aa9d7416339713173240afe1b594e2448803c93124378e44adfd28456ae2fbfec35ad9c7045fd4a14c7a0768d28f567b70576ccdc6029220d51baa11f1beb89cf39e6f3f3673ffd5a7f20c418dcf113325e67a5d13cc945ccd39b72c2b0574d8bf7fb9cbc19924f52bc9092193c7841f9892d3dec4e51dd406612782b7fd45413220b21915260f6236bc7cabe1a721c6246a810bd95887b90928a533a4ec6c8d740b6a60a4d6b2f4aaa8ff46898f1bc27c185675343702b208ddc7fe756c4995754527165e66931896f1131c2a518ffc4726ba23764ea7af643bff939a9ce718555b497fefeb16b52bb2efdb775aef9ac9c15f44441f34d3860ecba495e25882617ed4ecf98e4ba323c5b122946dd38cf9ab0ebcba31987fee7a72595e5e8306ebe0aee7fe1b62732084c887a2fe14470d2e4726172cf1359d5c0899ea3ac5a727eb7014089c40703b50fe505be5ba0dc003b6374949a28c2351f00a1db3d90e933da45120a4ee7d224872720aaf7aa91a43d6e96ecbe88077cc78836db1456e7f3ac7a89283a2d286487bf7da02ffbc8b5c80a0736b2a5d61b5d7d115c06ce11930c5a03497e1a5a6b8000b477ae5cc6fc76e4ffb9e8152ea8d389744b542bee9a26d90b41e08a320a79e9c44c92d570d79b97c1d1d35689522bc577af5d9dc9f9d048e2c9ab307e40f3a3e4496a74227e4d64a3ef1d6a4d85fe73fe013330fad36049d60f95a16dcb0331fae90fd8d0e295e018ddff01a7a9d14a196a2d9cebe27a2337272ebfb8c3a2f1ef2baa5ee34fafe2ed0227737e299552c9f2beb8103756af533c7f7a02094e6bdc3717e686c51bec951fb6b0104cc7f34c1680bba4d14c03b0bc9ab90d7e24c41737711562e639a0278f449f1ed68dcda83dd5eb48dd607e4dd00a6add468b476f1210fab25cd2da24931f2a9deb0303399a73e2ce72356112b180eefea4c608154dae51f29e967c96b4d228d9c49822f92d38999a76b4b42adb449aa3086e33da64a85cf31ab5986a580837fbcf9d54be0a58216d9287e4b715cde25340d95e66257c00b047675b7fbe6458f05ad2c7dabea6c3c1977ecd1c28498098dc0f286fc187a269bd3c23419b73fc074f14616910f7a28138a4835bfbc41f363ee4d35153131065c411c745d948cee25c0266175fcd33a95e6402fc7c5243ab5f37a54192b6fd05df988ff870aa1d13ba71591264d62235bc981cfd827934065be1e8b7002182186f526cf2ea7ee13b0bdb4a6f4929770e7e9edcc5db4ada9e43c9d724fe1ced9f5aca8b4640e434412d4a2a02ae1aabcc2f94cbd0043d09651613f84e8346361802ee525b2dff8921b359cdee166a8c92d11d3384ee2aa3dddedbafd4097e61b843140279d854b4b6a4c32ae3b63931b7fa93cea015be64855753b2c3ccf6d0ad2d6ff2f1ee8f91ea66ab53d3f4acb57abe39b11b47bec4a4c40f99ec8c082df7d0223007bd52b9a7a00cd56ffb1fc51b92d49d9d3f52a48cb710ee8ed59770a72c3087611895cb538b00af7ed17766a6a95f7852db2257774c2ffec4120a9c5a46166eaf36b620771b6e17b19b9cef83ebc5714f124d7c04ee59fb840c6ce7e2fb60af878811f79183f0df09c54eb317dfaca4882f1a2f2ab676aba8c377e0288c433b5c885cab7a65adc90aa5fdbd16b80dbd26e2b197a208b0533aee48f58cc5dce1932cf36726fe845c673c69734ca705b56130dd8b5e48dc5481bc093135f823718f87bf32b532f1c9baec2155c8302e6a80dc85b1894e357a3be5ad6a61b98210f66803d5a1a3ff517d84f68bca65f8fee3c04b9d6e218e9dab9a257e53d4a6ea1044331af9fe59d2a13bbcede59bc956434718068e2462146dabc3faca01d4a49d3a532ce5cbb369fcf09fab1d049aa5380681bec78a30d9ab46ecadf10815abe466008857eba79f43d9d16b0db4988be8075263b4873ee476031e7c5a6a142d15b050ea06fcdc16422637ba63a2ed4d7b2e19b964870ad6db4514a566481fcf36baac5eb160552d860e48dd7539509fb64aec2860449877210ed7d30b8df8f79c5f5a00fe27623e09daf1dc9d42ee7b23ed3e5b6c25c26dfe0059fe098181e0b5b70360423e8071b7526fc28a50cc6e344f657d7467807d68cbe7e0494b483f5126df122511441635581e797efb34a8562271b8f3bf16f95f5d504ee15b07890ca96f86b4882673f12f453190e18263d0fde3e3382b2ba01a8f1fd4d5c16eb535143ecf77cce786af1f3e39ae9281185d5af5b8bed1d387202948020a14bc3962113e98084000590e7011cf96e2b7495bd3d6c0bedaa6d1d4178454605b2a13d4269f5f40e7c3abfd244d24f27e0b223daa01ac45962b28a403d30b9d49a7c33c41228965a701ff74dfc2878fd7efc54107a617de78d7e34aa97a79a29285ee1bebaa49690f93000fc1b8dc1586030dbfb094b2a017c9c070fc00306808bf420c7ec8d64ec65b67e6bcc995a280defc632eaaa20df7b926099bf1dd7672f0190b95b40d10a8384b60091b5aca76ef3ce6a2697ed01628f4a7690c3dbc1a722f71993fb6afd3483cfc5dcad2477e5a7ead68c632211ed718e86db5890087a23d686152910ea3ac63bddfcf46ca4c15efecab51e5c3720c3c2b9bbf18ce8a06a9e423fd65a3b3d41f516f7581d3fb6b7db048aa71a97d0e7e4652b017e15fa1d4ce5ed18a300133db8c97a82d3fcc3644dee1a9a5da0d77687e86aebf1a4f0b2ff4552d85cd54303d274505886458361b96c0f5fff51354847e5e8100a99afa7a5b6d703f3c297869b48b1e18b7309b809a26be5c147cce0b6d3a9e4ef8b94724ef7595da319544d95bf19c08cfa09f29cade702e8ad7160ea47871d55a9386ee2aad4a3ba0a4630eeca1e4d5c045ab1b228dafda9a4dcaeca7cea9533c78a627c517b6f0b1c2194da1a043bd3f36fb7931b07e58bc7eb01f73a26bf50495b6489264a2cc2efed593035db3c9f21b873c675adff64db7bf36f8df0f3708886076520ca920a1b69bb07c27878c29b0ca770632936d99a90d0db6dc58b45403018028c3116f641e6e7b667b2d3f4984c19afc203eb54ee6fd690247365e28b38ba6d9192ce970ff7d410656c64e093a582ee756cb75960c76305def91f37090d3a8a5415a26f4f8e26303c16080dcd0f23ba99561cef8a064ce6162008b4b2d7176584cd68283998103883028737c57b9dfc8556209a069595e1428f7f3ad0e197557050f3ec4621a225ff451e28a8ce6be4f9eff3aeaa55ea5731b4aea1edc48e06cbdc2cb94943ce4ffe712d19baf0028bdb20a4d7fd88e0dfed12d8516bea7496bfc9a879b75c8ebfed3ce3a38435feb49096a081f08ed9a7700d10a3c01c2f6d68af9952f38710479931b93307e0554dbbb645df0d9dec85aae73d83f5404e3d0a12e5fc449aaaf001489ce3400334222784ec301766071b7b99adb6994021c2c464025111af1cd1de33b9bf5a65d377562e0059ec","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
