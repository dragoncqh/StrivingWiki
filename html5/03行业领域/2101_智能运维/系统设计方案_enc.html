<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a68625ac5a11c3f19c7c663ae32f7051db5ce7d5b214ed2ee57c7e8ab26a43e1a9495a9a33a3fcdc876afd8f6596ef51696f405127f9017bdcfaf57ef14c92116df847ca0209db5f9c9155e9f32b49f7f45338aed5a427ee01ba68fb3ab6b769dfa397b48e5c890f9b0dcee539b5b9338d49949646f39634f27435544c0db4eca7181a2bdd19121f2456b01dbee6548aa7bf560a52fe507ae052e437191306db346d39730f24185cda57b85231331e69aee0b8cf2eeeef97a12b5a1628eff5d94230c3eaa0803cfad77d834805aab3543bc819de6411aa1476ae4adc6b488c7b26f7d72afeb9e4455615c22890600a6b8e649993dec6d488be9faa6dfa5a668b7df298daa49e265deef649ec59c4e562431c0b2356baf11d4354882706dda7d0a4670701bea0d1eb037073c7681fb4d4c770b920b756d47c73a9909b69975a53bfbb2fc3fde5db4ffafc2998ef9a5c5e1e553f1acf8c1573959900b53f66d58c83605340c06b508c47d47ba80cdabef557914e3dcc49c0a76d4d2176736b30c64eb17f4f3fa5a86d5d97f11cd887581e2613f42d2747d322515835d726ceeb37997240c3c535bb66483d93ffc80fb1d3748dc70f452dc3f0ecfe144987bf325c9d788893fe44a3d4aaf137741bdd7cd437e01de1c552d07db5dbb904847590988b1212967b6c12d06680c4790daf60a533e0615961a1970e80df54d44e9fc9d5ecc92d02155410b8f7ac407061a036c102c2efc34ebfbb19ee2962c9d77225a99a9a2a23cac40df23294d080338ea4ae8c72e268f33123d87526fb1d60dae0c71d8be9e2ee1a99e007175b93842741c7cb03f042e1fd06433a3896aa31a26a188101f6c0aa3365d6e84135e78b4c8f10d992cd3b9acd5ee7dd51dff339d4ebc8b9212176eddc6c1714076ddcdfc2be3891defaef15ef9261a79f8243a576dadcb4414ff31b7dfbaef58c0a5f5978cf990e06817a91616fcdd2df9cb5f7220065a52f08b83990cc196d6e116c8d919de342d428fa28297bbc0bd2d1cb3cb84a48905315916947a4cee7486b9fd1a78c681bd2a62b28c2e32cd2a108be05f77bb863ff62cc087cf66b1dba13605a3423b774a657dbfd68bbaa1f063382e215662157891f9b18b3166b5f8b01155d2382e08fc5b7cd31c67037c34c8d7d02e029b13d7541c6790a49f1a281e6beea638fa0a8797d974694eee16b99e55061f578b7e109098ad7df7dd8407e078b9e5a96a5ce2843cb8b8e6d66099e08dd180db35d6a1d469548ae7506ecfb27d79a6074e7d8646a28467a71011c25e7e59c15339adc134077fb26627d8ac4a9d9f2cb20d6f5f8e5367552ad979dd784ab332b8159535b55003949c9ea187a605b20eebaf320eb781fc8d3b92919907e21bcd2828c3f2e78a8f4781f01f93bbd9e58edc062ed324398933eac206b036f190ea62284ce6cae3fab5121dde530440be2dd9a5904da7ac3849df0172b0757a35d5aa5899ac962e734438f1d14011573178f1063b48b234cb13d1c6de1c2b59949127ac515c4497426bdeb754a098770c660e645c58e05ce0313a59d1f1189ebd2a20cb334e7605145336ec8d8076f9e67c4f2da20d94ece293b442916ad43bb59a08b5e5577800e3691e3188649f5bb1033b37873d7110e0e7d989be8055583e33b026305553ede4c25a23f47565ebdb8ef483bf911145bc23f264da2c67d09664f79ddb3feefe4a115a365c3d01e67f51c688cc2080dd9b9d0dc3d67364936e66f04f172e9713a40b85432c73d3ffc86c6eb5354bd123bfadee8acab2aec79c2c9f5e5a5639b58c9bea12a7c0b8df2c52b7eb7d974256090fdccfa8b54bb1db26992158260e7a3d5a8a25c1918a29f49414d84b0740a105ff32b1e8ff8c625f642c395d8b2c98daec9a2215cc3c2a805616bca19036ceb63e09f68b3354597c2d3059e096e1594320aa7fb88f00b3c9cbf0b6ab1f7cacf2e3e5840ca7616be30c40cebb43e3967b2a0b173b89dc45c079f99fddb5499812267c796b29c9b91002fa5b6c403c0f63c64f019a98ff6046a9b0cb99bea6c8e1cb0dad1a968d10a2fc5b151edc0e377fa7ecb4fc5450b4c3c12f6d64933684cb6822130e3194344d54ff1705499964025e235e241fc7eae454aec23fdc2b98ac2e01dc05b2e5a3d01a1fa74800ea559886e31ef2a028cb8364e7252e78d262d94a375a5ab32e921d1eb1939867eb74f6eade1b6d166a885179e120e450e83778e8009b4867273cd5e17caff7936b53f42f8def6d8468050529a57e74b293f0afb4146e88ea8f10486168b1bda2f04070215069432a338a789d5e22ebc21ec7a20a966e433035e2a3e4dde29f5ec221cc5c453b16c1e6feb92c4ce8152801585c2cecf04d9d6b10b6ad0d18e6d44b6fc6da415b614dededfe04a9c918d5afdbb92a253b13717de383acafe9708156e5f9b688f920ebea09cb5aaa6121518f1f28d15fc7df2857ae30e258abd044421786f741dc82db594a849f27887e12b68435d24b7a65e9febbdaccb31f694998377499324323b3c9768960e37474872d17846fe30ff53c6ce500ccde684df34da895fdef7d461ef60acfa2a5046f1cebd8b3cda58a0f30f34fc1191383b8536b29e218151c076535603bc6218332599a1a4bcc4ee7cabb0ed0d48123dec77438fe390ad61571ef8039d8575c63fff7702dde22de0968788dc5922bfc87f6a11c7b3c9ed5884d107999cac07cc0b1ab7dad1cdcceea4e281e8695591b01ac71b7b7b4f2a2b2115ee89a3a701335957e5ddd324b627c46e0ed407546773ff2f053076f9d3fded8f40aafab9c6210886f16bc43a9c83ad53ac5c63e9293c8280fa26d761bfe39a66afae2856e8b55b981d4931d87da1ff5b5698c3586f2d2c4494c0c2ab87132a5c6232f40173bc8e5e5c13fccf7b760179002edab92b8b915f6a4eb97d30767cf7de6f48c85462b08972b5a98a8778b1cbaef916e8cd39e410fc772d4fde475c33f9c0dfc956c5326f79ad90cc6f5a14ddd11896de707a9a6a35cc9aacb44ab2cb09cd17f284729baadaaeefda61c13c5432f6280dab4961314b0a15d40f496409ad120dc233f2d33268213c477effbc3c37b09b240b3718fa7b8c162f8254def9e1ac7a1ce6edeac82caa7c88357e61ce6df69cb8c614674187c097cfa6be548f6729cb6b7f7163db28861e385d8b230b5dec6b599417310b37176208e84872a396039df0afc2beed52f824c8cd874034760d0fb0f2d2020467ff9fdc7ee8f04819349462d070aa61c07d3a32e2b5d1d93e60b4d657fc844edb21ab4b42a9f9b4a4839b232a17eb7e9b1feca8d598ce71b6240f409a2a4706881fb7640f8a357672317d8e82c0da5a6442bffd9dfaa22d51a473663a9e9443729de47e764c34fe84d61afc731c188a3f8f3b3c32f458b7c186954aa6b83f5fcbc67f49d6e482d9cc82c2c908900767347e3c681ff8d562ed7caee83dbcb6fca52802d6ec2e1f05a55d7f3e20f93e16cfc9ab55ff5ca88d31c6408ff7186bcdb006e7508f49abd6eb1c708371700515306e752dadd17416e11e7e6b604616276aa7da8fdc165b712e8705ac364bfd593edf89128701ba0661100023dc660c4815486a267ce962636e7e899e79638bdd1fa1eeb24dcfcf5813f2cd31d9ab2482948fb5878623fc199b6e5e432ecf8de82974011ed6833318efeaaaa267f0f7667d4bbaf15058afdd7f6ae0699b57fe982183c5b132d6010f2365b1613a6396b0b7b09fd4524aad185cf48eaf86d03db1e0d0056dbdea579ccf85a3b61b803bfee013aa2b77bedbea11683ef1b4eda8bdb489aeb23b8b2ff0268670a551703aec999b5600ecd38b358491838aae7332666fb8ef2dcf70ab9692ba8ca857266af09b81284a8e7b8e2996766f5f0bbeb21d24fa5411038276018f5d7f44aca81cda359e75f6dd3af67a43fe4ffddf0e3c2c50bc0fee4caeae607662daebec1d1baceee4ba08ae95ca61d57f01d99f5b6ec6f2bcce5155fa190c54f9b1dfc7493b99bef635e732555aa0f7e317ad74d695013b9451d6195586b547dca152e8528c3d6506808a27bfd86024b564459a68927ad4a236f9d84312968ef8861ce3ef4419d9817f561943754e5171b71c840e0b512aa1a2a9104618b282dadef48e23a9328d2dadd8142bdff738d76e2715e16ef38c6f9a6fdeb13d291ee4fb0273768c3cee3a0d966fd970e4276167f8575aba904f3b3d89389f4905878981da5e9e66e64f1a7947e7c51af384b1c4d5c90bd18b3b2ff45589bc8c1b21418c8e380981cbc6aa4eaf824f50ca8a1e2d755764143a7ac496c8dc4fe322c955312bbe01ef82c721733e140b3e9e9bae8cf6930210d1ee0cd29b535ef905b2be1fe504df38a30f6d7c52dec763bccc77d80e1285d54ff71bd5ab831b71073a29c7b1d8a88035593aafe1afb44b204187d2ab873781b2664ac24a8b6bbe5ec6186333a46aa16c341fd00a9ffbfb42d3ce5823c930f42bb136d8550c8bc364697cef1e5021887823279e8873ef629a4f07ffa02440693b917b6cce060e3d04c73c37b25eeea643e487ee32b70ad1374f7d803b3d7e070e3afce0c389f2fb148df02accd065a1a156c3c428c1612ddc25f07706cd88941b2eb95582df22c6134f4bbac1441b8b13110970753436b1badf5bb527b2ddb4f5fbc0ce11fdd8f5f3a6c106ae686bcf225e9606f7d2a78ab2c74b1e6ca10f0e897b5236e276cecf91ee1cdfb89117c50d14dbe85bc14f1e5463ce53aaee47a2c20849f282e8145c49dd4202b76c630cb58147516464301e52887f34bb5700f6179ddd83165e222a5159165b96aee6b49f803f53670afb38470a420a755aa0a05cfc3b0aaf94224493597956c705fa8583b732c38ca02f39edb59ad303671d831fccf09c436fb239883dba92e4cb534d75072ee6f2a5c9203068c787e2f1ecb21c9a1365a44f8cb4ed4fb62a0433cdf8a321591c2f4afd4854e813cbe0a186da9a90c43f81f466e5100e6721180668f4136fa570e9dcdeda8e978f88ed18d01a829dc65ce83291a4fad5f02d8acd21248d72823853beb6e4198ff335339e8b7bb18b9aa64dcc200eb371cf88b3eae62134ffbfc1db57532476ef927759f806e279a73e1748363cea91923fd74c08c363e14cd5e1e43e0d9352dd73d2d56143cbb783d34e69b1fe0431ee73ee128895b32ade3d8080f9364d1e14602151f2765d6a587d98f285a887edadb34e565843f4afb304e6f01ba861445e3302870d9f4ae2b8caff1f352ab4556132720d24923ad72928feb3c80650c78cd88a2f3818b28cad5bf19abdf1e3e648c298411df84ba9be7d3bdfe67b2fa643132234e916140406f6719db0d0b147263321880acdd3c8c37db5bc19d85c25cbbbfa3abe031e937d3d07fa73be8b3b8395d295d04558688a90239ca96e609acf043c51121ee31d6f1d2fa2a9e61cedd02cecea6fbb93fe028cf9ead297e719b4ee1d8d1c11ebfe7324595beb08ac4261792d8b193b5bbbecc4082463c03771f914f68d4a07476be2c16bf2ffc264d2b80b4bf0cac08a0bf6933cce0979e6a62cbd8b0e59e291e675664a26827e81a3003fdf9ba8c2f96c82fa9f3576f61112a10db4b6eb03bf3bcf10765ff1792b701dea2ed1189284e12195f95ad4ecc319858445d7e8dcaf3b20f27d5a3a98fbe04e6fef8adb1d1af0dc28b741c520c39d0caca4b93ca5c51e140ace8a4d3771fed8f38b627d3b95ea23704b3b7c288fd7d349190353d792e519b37ac44f21d56d3e6a73bd3e8bfb1ccbc97f529fbe00d96f77d781426960cf2b16036999d6aa2c3374cce6db24921ecc752145d435b3a91e7797ddb2e09bcbef44f5606e2636010ffd2dc1a6d5c998939881703ede88b6ca6b4f31b3025c383e2c9b8879b498fec8cd3116e5df4ea541603d73b4eb6d72da832373ffb0cc104a2909868b04ed2de1a5dc7dda33ca7cb9b477bf977c4f0e0e79f7f8489d4022029020461576202d9cc5bfa97e7ad28f500fadd7ea3bc1f30d3d42d21cc70aabbf6c5ed8139de486e3b984397705b004d38cbaaad482f56509671395227efe63dec92c6513f8b4479e6b9bc1797a1fb8b473b307c01735e0ee2c01787514fd1685c6e42c0377772c2546ff72d52efd08d03c05cc51ae340c3e644b054508e02af7cb6c6d8451adf4408d2dd5fe049689d607393a4dffacb75c42df87d51eb525fbe1d57ab8a08f37c5767f4f5db9ce78f72d76a893795746e141a3ea897464a9d4c8e666194324bb1790aa332b950a94fd10718929e028a6c18d27f89eef45a2e17ffc770fac646aa65010acb82da6539dba966a2df0abcf71e4058f8ecf6c798b4220df17ab433428b83136849d096a52e44ee3911f3937b63ddbe494084fb29bf24b9cec1f68b785bc4798f7388634ce6abd0cbfbb8972db96a052b81a9f4eca6359046aca5e95bc8480baefca2229c4ab8815c8d7397251730104d70bc57d29b4b4ec8f0815f5e620dc892b87c9a6cdd67644706a499e5d4071d479ca1894315e878b2bbe994bbc0e0184b33be4361d1b6c2337dc461a7ce9d8bd1bde0946f66c42b67b6731f505b1cf81d8dd8b1a5407fa118cbcde9dcbf7f5374b2494eb1fff121b056d285ef2e42eedd99fac2e942fafb642db9510d03fba2fd30aaee8b631d6d89f0acb741a1c92d8c85cde8ee95af448e32c45eb417fc3bb4a36c9deafb4c675c40c0c90fde000184731df6fb7e77f0515df6229f5349d51a590d5ff114cf1a9f084b52b906bcc05ef2b6e850db8736f38e677a3d5d1ed5bc26e54bb0e2cf7c881c1146c5eb5de7d53b9e5849fd1b6c89c30a19f912fcb645992806cdffde95ba2c87eb1615774a99cbf4574e5c25fa9e2e28b04773c600da743a129a36b2538f2323150c901aa34905de7201aa5655e4a043ffb9422eb4f1ac385b56736381c182dbbaf1cf221aa973e6df51e49dadeb88ad7c1213771fecfd095374ee81ae7ef9fd9b656e6b286819b74bff3c9a0eca2d8b55edcccba857853d9c918ee911dccf2fe73ca3068c579358a9f3454740aa297f06bef5e1b8ea8e3748de4c7faa91a9fe54024af99cd0072c35f5a1a83b9e1977339b1a0199acffcdbf9a88966b1bd221f8bad0c647caf7a91eab14ac40ceb7b8b7e8b9caee8140d4494b386957bad08f6d5c94f6fa64e6c3c6c74c783dc7b73a8a1de32faf99eee0f0b081f284a833a4efdfdd4e357ed7de6cc3fe7e47e514fc752027f753e66c2d3fc66e193aaaf4d0974ce0817ae9409b60fea8e9dc0fbc9caeea05275f51da721a19faaf7f97c28df474f53383c30ad7e995070a9294c93f1ab65fdcbb1894083b6afdfac2f684f83f4977f33687195ddca891196a5b99cb3b3c5ab8e2e6f487c20338aaf8cf8809a7b641f7db977fd898255fade53555e99a9f9bb1e6fe7d5004fb9066711090123c779342b88abcff988613da104947e2ecadea92066e860e74e94d8b67fa5d08e003a2154550735e186d62929caf9253d111e0cf3f9884b1d8f4fe1778ef93732e829b1c8fc21cfad79eb7de27e65257817e116af49d8d2fa7cf772e67a072a9531feb1f97644cff127c934dbb6bcff51e2009f9e8dccc7d394d9ea7660b650a2be4c7fe3ffc3c39bf3befc2dae96560e11efcd791ccb6063e2132ac489a47861511cc5fb4e8f25c702c556326f4eafab06f1c6cfd0fb9d1ee6b235074e83c7380ceac3b891b9c08c167137b400f3acb5b19f40923323cdf177071aa49ee887d84d64d78cba64f2d91c2ca033155af0ba762da1156b13d0a461379d715c684aa0975a5eb099084bdd750c452dd4c1fb46eb30c0f18ed7512b880883a0e02467b346974eae073738f53bc587ea900058a7a388e707f9bcd6ed6502c80b6875e31c68862ca5695763f79f68927f057b54de6c439c38159bb4b1a21f532112ba9eed805e05c2be5a18aeb2029b377100cb6389241dbb189cc6703f12cacf7d08e403b5dfc9cd48cdd215c498a8f70cd37ff2fba7c5727375f0b49a7fe13de8eaeabca90470bb3dda83bab0c58035ec1f692281d437ff623f9a2fde48f5767abca22557610d879733a2218ed4c6dc02ab9e6f590cd64736a74ed41d1860017c38f8a4545a07a7c3b600a7495de736e6575f7e0e2c1d2c175cc1a9c2d9cfab3f99248191947b3c58338aefdfce8f87894d2c1ba275b5ae7c6fde845bcc0d40b991645c6d76515c497009cdafaddea449f32e667fc717f505283898b519d140d9b42edaff5184f27137f3e83795d6798cc9617640e26e730c7be425dc684927106e11550b579a9cad5c9647eaaf99ab75834450db72fc12aff1f7703615b9a9d1de39d52d1b8d022d31f4bbd33108f37f9bc493c26d44d7db8904afddd3ae2254e874993689f1276e2a264f3404216c4ae9866214d055c37b511e8aa7408c3a8de00646e2a647e69379e0d46883f8a8cc6ecff40059a200cadbed5b8f4a365210b2604ef50dacbfd1c55d340844f62132bd1389d423eb57c92b4c3899e9af544d3e69a2ae7d0d35f5ef7a9eca2b2e58093ee49003f9eff741faaca28042d966fd3c84894ec1fec2d22293b1b53715831eba754e895d478c20c39bfab05f207fcebfcff720acd32c9dd38ea7f9860961f2d027e51e7a041afaffd28c7ec1a0ec1ab9213863ad1a87e72761d16479e5b1348832ca2d12a6b4c4303eb9c9624c89b9d768ed9697c1e597043bf048e4594205f2a23c7a639b85b86f523cffb66c08b94e60c4d7efab0aa8815716cb3e01484c9bb0330c81d1ea0f4cc928edfbf0afab9e23bf505f87b30dffc97e7c45d8f9f81c2a8b0e0a81d15f77116df3f27017305068d9baa1df153f0b31d823ce71c32dda6824ca0fcb82f6ea829c77cfc74df866327df998c252116eba83c905feb8c6602dfa6efcaec645afb4288a7bbc407e99df3dc99320e91b8d80ffbe5211c7d46e2c024fd676eb3003a2d0bbbf987903b86192ecccf995208189a8c516c32a5f1c03060ae741c1896750c41dd88e8fbbbf6d9c6192a470b22ba73b7e420f64297bddc94212973d56c118bd30e9c00f30adcfdb76c050e8af7f15f94007c239e118d603c1fb89761a1bb1bed56617c431cac8552a44b6a51f0adc0333cb7a14cd9a0d01cf82ef98e8e4e5a8e3ab261c82fa92575f918bd4131fd4e9f41a9696c4cdb4e172be25030f7d20519a1f9387f864d26041320c75204af594cc116cdc7f8481b95feea38df7a49e7d58536c124b948a86af5c09569b04489d8c2074068e831e3128875de3b9e2de30d097ed7ae5c2b3e8a95080bfb283deabe6ff6a0eeccceb0f41f016aa7aa23ffd100ca3f3af9ed6bd8b9bd0505142d43e5aff06ae1e22a90bfeff46f14f430227874c42873201d4294680e3da727e4c7ac5a24ad69624dc312ccd9a52e7deac82676f3dc5bcb268ed49314f0aa7c444750258f959d5054b6e389d227d91030d05dac0e7cf6c8ddb2aa8d94d7b18c8082dcd87d80a0dfd5ef49f8ace23a9d0f6da3d8fc516ed7481b49a3a5a96e5501da486abf9a56cedd704e6a658a62a389411bf77e973cc6b954e099a57178ce0f580ca5f43f09d80ebbf6996a05f33d0974359a7b58975173ca4c3a6f12b038612509290857190c71a21a975c3b555f755bc552b1dde7109480a379e257b00d56ea3f2937bb9210f8d1cee5616e6c6e8ca80722a3554b379383ba31b1e4c4124e5fdc017c0dc7b45951d04d6806a1be7a7e97bf21c478f79dea9f4bc6578251699ab86a1fbda395c572bcf9f1c72398fb746fcbeab63f2bdde9867172d2a7b01f9b49f777f7294cf512747c99c309ec28d678ad7bee77ca484c0bc0adbd9d47c03dec58ca4e10fb7b071fea0093f6fc4fdc759e79d2c759eb26f2dfedb3a67f4b1b7c04fb7d532bfb8f9587167ec8ea136a2e1d9832d6fdfe7a14680becdcde5f59f667be068674231b836c76b190648c98bc574b807519f0286327963856f86991fcc5f35d13d07d6bcb4cfb0124bca3c65fb95c3e77413ebcc1fb30499dbabd4981718732fea4f09a33a177ee31a0d76ee95730d9da3826dda521facb49d58fdc1b3229230935f394e417bdcaca75a87c9051e00ab43ea2cf5c76b19fb024be6347334b01ad83a3b232f49c09f80a61a213bfbde9656d122463687aaf10e9aeeed7ab2f8177d6223414ce3c4d661d0aa36b9045cbe0d547da1aebf936bbc04dc1f519f395a900e0f8abf1703ebf7599da094a74c9c966aae4a25ae062541b95d9236b3c78846dfa42b7641886dcc80476b42385ab0d17287d422bf8a92e57e2fd2f19044b9c4634ef158b41b94ef82e076b33b145c28befbc2d9cb131d17866a40695346369919032904b0f7a3c4199b222247e10de3192cfd4b3d76b9e3d3253a6395f448338930c319110bb25c213d8a5a447fa19a042020121e458a5e9a46fd016c0adf630da2d7da21dabc55e44b277e36918f775e74b0815a9632b1ff72cc25b9aa6b55c42c77b4553770da7898fbc68753bc476a3c556df8053fea60edf224efd482597f0b267d920984d6839b68b9ef2ed1bb5007a5dc0434c2a78d8b598658b1a4353c7ce59c7aad38193451755e09f0b6d7a936a381db1916650da4bfbcf10120ed8b48350d6314a2a8a85723d7672c25c3e776b8396a1da6c60677a02eaad5f8b60239b6c972c5044814a7ebd2b695a2f823feda2af867d39c81b1cdfbb5dc8cd9e09bd0d30dcadde304d403a2a10bff5cbd914ce846dab31f3c2f1ba54ca2777e9520ceb393ef55175ce8392df69aa4f1edff1d3c2e9cd98ce8800595af5c96551abfd4aef48650420019e1b8f528fa5cf7c7f0b6bff9803286318c531961a894de06c85efb8a02a1b87f6da6920ebfead1e9f8777bf1522c1b7bea84b59583241bb6856a0c078b0be13cfd55f041f99f8f9fc6b774e8535de447f41ad008fa6e73fcb7a041bb011fed741726057aad3645bc743731c618cfc1f78147ccc685fd8256c0ac9dd2d28b321c02e0049e8a7323cc141215c40c707b306db7da7a8f5dd4b7c3072875e3ed02860882986b74bdd662937abb54e9ecd0a192038f72dc438062c2640babf9f4c824d50103fc04e05b444e8d0c3e8e0ad447474a8ecadfe3a2cf5e58adda69305396cc7224f11b70fd4eb954c9719e5461803dc64914ebc4cdf020d5aad7ee4d78f0e7733eca1de420f3207e5207cc28d11be8bb838404e89dba7c5318a64a52a9e87cb09950c89caf2b73700a207362d482142f2329b5f3f5a7f155dd138efe3dc2931fac628f8fd7b3806f63da856ec5cfb2c2f40128297bd03593b3f5d6b2aeeab391ccf8e9f78540f212165cc72b38e680e7e3b2b145fe59a31f1f4c4bf05b5a6f31dd68a28b00060bf33525d1554d361558bd4e322a67a5c98e0990317fba22dcea875889d784926855465184c29135fa2dc1b92e22bf283cbf4ac20f459b0df1668a16f966cf70866fcc1aed19f529ba79afe303dd0168925a57571bba6e5ecf2344493bf0d0c91bd5643c7928a5d488fbaa0c2613de2f9e86cf773259342945b19a861ac81c5eaf4d066f775f8e57d93d18cc2f3eaf09328d5483ce75d8bb7ea48af3ce54022dd7e161c56fe41341b179ae64cab1482c4ce3caeb0862ea271b704dc3304491e1c7e8729f29d0632a7924bccee6d181b253bbe79f237285121c9b8a9cc838cf496b8590893b6fef1582e6879ffec85b0d9f7e225722438fe21fafd167b56de5485c22d285365c0678a69688f1f204e5d0ff6314942261c0b54b0c19f989927a68b73a44c3ac520dd728e55bd3b48c2169d0b345e3e64f8040b6636dfd656cb80348d5a3db47c375ec6e22aa0f3ea53eb42c6cdddd91b67a0fed9a5885a07c1c835af3f8b025bdfcb76ff4a9ceb65b17280bf0e58ec8858a00c26026c5ba20d0ee5f7d1a97080cacb4edae720551ba5705b6806d9cf576318f2089e9cc6f8443de498f700250fc8a22385b4313707323291a79f6fc6da72670f3306ff0b72637ea3628e11fee48910fb1d097979e95201f77fef2a1cfc0f52bfa9e206c3e64c4f17fac6c044e69eda9c5d8ffff187d89d8a78230b09db49b5c3c26efe624361cf51c3d310113fd75d71b7afe41049d79537fd8441415052e09c956d6d560e533ab71d75d079b6091b033997c8ff7d1b04bcae0915181e47b539edb4c569a9a07be4d422ae57c01592f494fde68984cbe507e31fb9283295da99eaf021c6fef9093e99332d5759b9d25d9aa4a6a3c6a2e9c9029b702064ac863fc24b78fa4318ac0d077fd8d99a85085bd0fd0dba0aadd65a3ea190296d01ad2f524e72b7e46fa1eeb335b7c162838795415c5e3fe57003807d2939037c9625af39c6dfabb94944dfcbf272f5ad23ce2e68f2efd4a7419ec2da1709f67743ab15030ef2080857d206b4b23dcbab78db5f93962efd3482f0f847cb37907763e8c40fe3e58ad8506e60db489c2008262f49b2f14033348503af697770a57be9bac072b6c16d311353e03789ba248ac8a2f6bc07e152097cb77e29c5d75aaad375f4814e74a60bcaa61d7de855adc76a1983e8ad251a2f25f7ae646cfd4ad9996ad0db2bac1bd2982c5eaee10bc5ab3ce0c7caa36ce46f171c3a5dffcd9c1b1ac98de7cf46c2c57606f76fc8f7fd532345d3837edcc9c2755313ff0eacd7353a148f30f384fb49d8311ca10b21a4ffcfaf69331b8ab50c58b9708077f5b4f3a8865c3d79b235221b92ac31406a714cbdde79800a18542e35042055fb70b5e48fcb3f3d33a10bfc8329162febb126362d8590eeedcbd59734c3c441eb9ac410ff390babfdfb8ffe3eadf965c61b7cfaa97a0d4e33ba54d481af2aac930107bf343151d07883a927dd72e9ad6928c86fb786909a8e1c7a4a7c81a3d65535184107b16cff8fd686b57b998218f00f84c75d60c7f5209468af96bd6a3013c471aab7ad7ec83241de6f6e5d5dc1af87b1900774fe467a35baa5734e47b9a57221f719f7bc81dc2a9c9f003b503ba5aae9398579805764fd1665fe0b03d1146bef9c903c5a61145f2ed3d9a6a0b6ac15ad2448d9aa85069affa4bce41495bd6ddea76747d3e65ae1ddaed8e985e451cfeb8fdb68c416661bf16da07b4f1803a186d729cf9f5dec6e13332acfdf4565faa0b1d8ee61ddd68b2f85d846bca3d222fc48bae1ae0c2f143c6714ab437e05f563d96e0b99c352fb07bc46e8989cfb088169ec6c31a98d3f3991249adb081bfe5b008ba58a0f79b4f55c5b1deb4d3112635222c0893a44f4f145f5b32e4f43037d2fb801dfd5929daa51853e8a5508ce5b33ee9975bd79b15bdbeae6738d3db2990914e0ddb9712e5a3adc8d1d83fd63e2b06a692b5c987359c19c076d96534c0f75d9562ad0a6de8129eb5d8fb15165240fe0b78c6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
