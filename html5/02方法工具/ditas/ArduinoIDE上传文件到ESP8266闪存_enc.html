<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9412d02e0a691559c6097ae88371f900503e34ac4db8df8e19f7766f212ae62c4339023f8df3d27110469fc38e7e43e4232619365bf019a8ed5de86722f72100d0631502cbc7373422b95d14db17c4abae0186e8d79199a471fa59b1e4a0b801ce3693bb42886af29475237880ebd380b7a142ce3f92727d05a13508a29141f62be8fe63f665ba527f30e823a5811a01947e8a4ef962cf1f400474be13250cfc0e74ba6ae79e73f08f80799870092f29746b66493ab9e90201059f1a999209eecca324434fabbcb42f8c076a91122c3198ffd8f4b5fd46c011d25cf388575473c9027cecbf9972d34c6fbb933abc54c15aeddc1061767c6ef862c7cda6c7d8193041e06eb2d893e632be8d265f5472e135962c753889d5b1b11dbb20187a3f6a239f3ae16e8a73cc6dc4aa1f790d188cee11f8024723b60243fd37ceb77e4917ce3505db1770c821801ae9bff7ce67d2f98dc3ff14948cbd7e7fb7cc944e4a08a26ca81bbedc7f91165d85be7699f9b937c28e6f38200965fb512750670904bd881c435961e239a70e2280d5e7866aa2be4251420c8425cc2b9f63d00db06fddd813294cd56cd39a26f6eb8b16cd4c8a7e1465e15c28b45bfa62a22baae104eff3ecc20e0fdb0a13b7548184162f14c8a61a1a0a5f2a366f1cb2b882d05e0324ee32095878bb1d3730724b9c210a702d7ce72b1b120b18b5f20cbaf838ffa0da98f6fd1e75bb5ba95062723c6aa276c7399a749eef61a7693815c786fd94bf1f07c42e12e1be737e8ee85cee533f5667c7fb5cbeff7b24dbaf95135a20518d163e466cbce4409fcdba74484f47df174d04cff3395ed0538e2d5c8f68f6354854d7540144df22ec42f2f8a7016848dd192acbfe1ad1d3e80b4fac2c76a0ad4801d07378009d5e9b1d243031a10308d46f24086a6752d7ad199c754ab0bd1d369987d4b8055d0f5e1ea2008f375f1412102611fa0692c907eed1fe6974dff8604af11b49b7953f1aa570608c4f9c07851aec3c63612ffe16025f7f6e02410c60661703a769db1d3302732c6c5f64c769949cfd1a922aacfc1fb88b0cf88f0edc1ae130fad3f2bcf67cd78a02c524b732ae840f02370c5b8330340825f52e97ea369b9c44da18f8eed6675dbc7b68c32539e29b78a43824e32d57bd8b4d041e962dd5180bca74092bc09898d6729eea88d2d080583e88d1542ef5407809d610978afb7918174a7dbbee4cebb06838c7504e2be349366ecb8589afceede88673a5a3e25a6a7aa716479232894f988ca7f244353808b21b30d715d8724e1b209b59de430bbd27cc552adf1e61e0dbce0cd71f1594835ddbfbfc388389b253a7765ac801f439f98cb715df6cafb2c6e579c887b2e8065b7f6a61678514341a43196b04393ce0cff1b2412746f376798e66bebc59a0e451d096305caa079977d8ce01ceec6d2249f937b9db6a5b655ae76b9f9503e2e6088184b645942f8718c1b715e1efa2311c2269b558f39d0fafa76662cc23edd0914e387064f5b51386389f0db07d6cf06b6dbd646365e74a1e31dc221986c2326835d8e21583df1c629f17a7e805e9bd5493e2c0e2d9d1319a724d08cb632cba890c177b653c8842e1c8a3d1c115f7b5c0e4c333c774d18f9575216208b8e56bc973fa5542d067a3f3c53464a747d6e128d8082510d736cd8bf83b073af5557b1daed6d3d294b8004edd5a80137b5fec487fddf85d9b75a5e4af8c6f1ddce725345a9c4a08f9669bae1d2b1de0f4f753438e976c27e81bfc9e653f3a433ccccdee88ca16ec13e7d2cfb8ca99faa84c5879ae50e3035a94450f52cb613ef252b3e43c1bd262bf7ca56f58f4c08f41115547a998020a891475f12770b83cabdd2ea459b99c6c01af5b79bd8d406ed24436f6c4e6e2f74259a5983cb4ce1dcbec65e563ba317a5e34c5b2078cb994dd95cf08f88f56bead456e9a425fd3f38721f55ab3c285f75a4c3cd743fdcf4eff64aaaf7b9d2ecdfbc08db89eba55522516d02b8f831309ac8b9861cad7d43d498f8327c67542e93f5848631a6520736f087c5261ba43065ee0b92316e550aa93579c9deee16a4fa83ce7189f9ae05610028f35f33f98e945dd2a3623c845213700dfc0784faf8e407a8a5b2bdf29e9c80645b7c907aff4824b6f292bc65f78f52222341bcb7d135d27c1d4ff4998755f7d460f077507124885b187e177a1066dd9d04bde486ce3010133d6a19c6c741503343b347e1f87e44a3b4e63e0d59cd6723dc79d1cb1bad69bc7eafa60d2d9c7ea96a3e3a6590b3e5bb8c96f71ce1c75d93135fd36814eeba8c95427cf7dc60310a8cc7dacde46a6d97ad9fcb09784e72d73ffccf83ad51073bd371442c3d97d7e2383858dbf878f66cb9a69ecb642d6ab05f87fff8b24825f06af49da1283f7aee2cf6a027d304a06595d24fd348fb9898dabc27096067cd1002204b35665b0fe5aa609fbb36ffd1319d9173752181e5271f58ecd5f7909f62f8fb3c58505ed5a4b31a2c09abdd575650c80c1d6db8d241b0bdf2f8d0ac5fdbdb9de75e7a593c483ac697c76313ed8cb9ec4aa9c5c1aad61ccde3bb1c9bb45915b47c92e3ad8095e117ce4cd7a00d6ba646fc1e78b24b0388ded755a848cba8520a22428b15788c041828f1fc9cbe5ddbaf85a00653f5e2a047cebdd42f551b805bb5e25b0a6e149e15e30efc0d012cb91a75d5867c03a35b66ca642d1db5692349c9d8e8606f1993caa2fc198c90fd89c2d814c31f1cdecf7c6721867397a5eb02bcd72b1ad11b9444e1643183864099a7cd813a38666e0380c882cb88526982e01b4b313e6840ce7adfa255ae747af820fbcc308dadc6ff74d278b4b87c94c5370210542f7e0b6ab0a5cafa50af3049e14e4d48ce8ce76c686114e1ce1561ceee338af26cb721c3898fbaf974bd84be285d366956d4038311079b50c8dced3efd6772902bc8783342fadfedc158e47aef447e0010debc5786f2d69df34b7a1ada4d49c85359b7b202477b88ffa963b1d9b3e876d56cf39624e809ffa226d967dd1b9227c2c84865eca046c2e0f239ccd1baabe5ffabf4ddb6638d7f5983a5a18f57b8c1b7a7754ff14ee3a03b2bc467d065d7ab2ac1df664234f7d9bb71ffb29fb8639d0e0153ba4d6feee62d882229ca93a92e77d2e9535463741d12d96ed976e34dc63c1625d5754c4b4335349c27aefa43c7c1495c052eb9bff9b2f23588a16f9a06bc9dd0abac3e5936550f3e8fbe4cf22c22c169a4f126a139d40fecbf9a28728c29d865499cbd9f6a09b5ada0e0e6312ea9215df876bd7d961ae127645967e1135db8526e37d7ee4f5fcd975afacbc2ca39f09022740ca848ee60f0c7c90a097959ef29776f18647bb9744a7941ab3ab1e9e2bdc9d604306b574194db622048c600115719125ad32c76ccce8d37f3d271f390eae43ddf130cf8b699b4e2a696f5cbd9880a362cfbf4a8f99070af496ebf01bbf2c51f392daa4dde49882542d8b3bff4dc3746b864dd9e21e82483999072eca845587b2e9bb5c811b041811e2f1c638f8e12e33d29a0fd298dcaeb81a78e0dcc382efbb4c0e9630cbf77481e3460ed719d5de43c54b7062eae1fc2104575f2f5a7737b96f3d0ce89456c3202014709935a4071a2bf66376dec6c7b910b9db1d2bd3a79753c137db087ffffb4745b9436b6b46c51a0014e18b45a9b579f5b1b2edb4cf9fbff39672b671212f0639c32b0f6177dd0467abf70c9b4e37902ed2743928525ac6335907ecfe86d873751f71228538651e421b2ac08f70b9ab0fd900aaf5c3e4ee33aa094a1b46f92fed18b7159e0b644857035d07bec88f27ec082bcb0d8a3591df64b811c0f863c985427c3d50933336d9d11085b25105260aa432aa3e04e87822c723854ec16ae7329d98fb5d747d85f32a228f1d5e70af5644b15b25837c145067dcf6e81008b45e0a41881109023e683ddb8c49bedb0e8817160de17cbcba0e39e582003b17f124a3bfc707a2bb9d7b4603e88222f85a3b57da9491a02de7c65d87a630833568b5d345f642ada1e5f192e1922862838a9ff2b5cb42125dcccb35c6f1afcec4e1619708f610f7f3316f60a122d3275f972908339ed12396c08516986c4eeb0dab38f96a012c2fd946c312e246366aa0d77c9e27fa9967a8cdde1144eb998501169d6dc3e0f1744a708ce5862f01b2ee445b985b3e72e8de79886c55c06c6d17a83dc57c8ac4fbf2a13131a2d4c61b6839841f0f6543bac3d97f3b0674e9b3d447621274d248644eea6bd38bde845d6a685c7bc42d7bb4c1d88551d46008f1c61251a863387e7dca9faef5017c0d6c1bf42f5d5a117e2f1fc107f8cce6a0b21c4eba72de5b380255375fb244ea94ab29d11ef38c109d1a2c00796935bfbc96812389af954fb93e25385eec8858a6bb827f24924deeadb0742f01cdba8203919ef6bba9074249ce0e97bd0befacdfb1946f8a33740f0a8b3dd8c160b5a1c87fd79bf2eb7392e84a8c0efa04667a67c226820f7857b5ea34c8c202721cfb57423488b7d19ba8e906b7d3452a36ec6371fca6df59c2ae0caf07b93cf4dbf84a895dfa8017109390a72d7ead7772d44a0fc7023685cddd99b16d43bd06a4329fd1cddde319e2561d48a641431cd54a606bb024e93af07e74e9666c8c9995a838d2cce0ee69df9e188b54f02ea7905bbf4ab5190d08a9f1e1e4e00c2fbc4800bff9770a88936791ecbcf3f4e8e87a23e0a231f1d0973db5702d7df1032ba0446d516460d2231474a4e076073a9f7399bb67bb90e32d58bc5bd50290230a2c594775931483aded275629dadc1445ab08c46c02428141a7ece45c7b448d5e7080aa10bc5171fd1b66e1ff3ca3864ea106508db6dd0556136ce9a564bf778c9674bf10ac2366a07ea5d476a988473bfbe9cfbb33098c9b2f3efd5868924b9fec56d70f0f92cbd5d3267647b77e97fb61c21ab926cd0b5c5c5fa018f815d2d94c67baede1a250f1cd954879a0b559f288133e44109f3c89007c8d95098569fc522470f571c8fa953ca505fd19e962f1f15ac25b3f8a66cbb99095bcb318219e4be7ca3e64d815cb4bc3136aa25e39be6fca641821264c774de1ad85541bc1d58eaac7f4a59a1b9b6e4fe847289215fa21a96e9dd7059348bdc7a09c86a71401bd9669a5386bc623dd052ad088c5a93f350fec8fcf71b0cc5cb9c629ab3231ae82b1e97f86cdf7c60e49cfe1165dda72b10e2cea4874ccf3825e661f3f04ac1cf15d3f25aa765ef32a5d89c1e4dd0de71b2229e59bdf84016880276faa15f0c9d90e3d66a364198237bc6864c269cadc733cd43421f022ac2179b2b7c8d45d9448db32638f6aa7a58c3970ba98650f1cd67d6c98b55e4b50e805e22b0c0e5dad275da14cab1806a8e1898bdfa2111b02aa89634541326b2631c577b5c2067b895251166daea612a740fc3dc2e7b17625bf660ebe4c7d2d5e7140ff19cbc5f3a3b865731657e0ea62feef8a4a1295f41156a13392aa065b453b682bd083dab36b051a91279609e58e1d8126f6f241074373ae7b71b61dfb247fc516daa02590c191a9cb99139c870b172cdc03fbe34a29853acc701a38295a336ff0b110bdda1006461dacc98f63686db4558c78f9be316ec4781ed828cbf804e25eeadae86c346fa4c90422bb5c0eda386826fd02b75c8ba676a7da0e9c32aff9a38f1926f0d60838dc2464b7559ff2df4ab4907bd6b3b03beb687affd3fba527329ce24f7bd85cdc589382d5e1b8ee73f2795c8ebe92c3de153a4243e77707a1de27b2b2d94f8dee6b2e2eae15a3fbd0e3f019481cae8b144530348a74236b0b4b945dca649e909b0c2fb274713d5d60c56ec68945d647dd05f47b4c7cbd64394c34f3af0c111c72caefc452512a2e9577c4611a3a0188a78286f42fedd45f3d20c97f3c971c2fcfdf3b85db4e0e099046789114768431a436ef49cd7db6fb437912e5d30cac293d2c3860ae116131b248d14043a086188fc0e16e5aefcc0ded6a180b0dd903a351fec24ee51dfc712c34f0f5cb56f614be3338cc3f7e79e2b05435992e5c91ecd344139bece419af4572c3aa73cfc1ff6f4f38a8bceab4be48c4f5c80e1511fbf526dbc3ae4e4e0b187f2954fc80f2e22279a8590230b9a663a100c875f8dc1ac1f156e872d9f552a7fc17341e291f2ca4f09894230676080b4b251df388c3feba98df26d05d95eb7cde7cc4c888a90b269d989758c4e7f6dc3f760348183c655b463eebd3e7b2ad6c2342890a6977edcef2ac40afdeaaa024905c8d2f8f822c04e13e3601888b366c6fb6cb6b26a25df13497799e88c764123ee016652a97e78d2f18b3161fa53774358e7f7c9f1e0941edc42eeab62626de2ed6ed1a0facd782dc4c6051015e202bb47fde67ed8da0c3fe77111be28d6583baad1ea70dd5e971b926619adfe1a69037f55e780f57206fbbd7d5da9f3646d6327eac8871a9df902c09a24db3c6e06c309da2bfb5a541a90c8fa8cf24bef8eda98b7ba6e251d7bca8bb8c10e6a4fd77bc9e21e356bef05c3fb921cd503e0c32dd1aa0dd2d59fde0f613bac2c6ec99c21838364ad992de67ec5c4f9ac1c6baa907c4b0b7b27f4b3b144095486c0d55428a0ac980648633119d6085811af39eeeb7c6f89e2ae2d65b4be3e1b0978733ad72e6458f890abf4d082ea40a576bd898d064d989686e5632130140174bfc56c5997a51606a429062b6b1e4dc4c8dce951ab9f14f01884d29a9931ace3f83c862867b2a4f64d10e51fd4e168e4cb358c73a448436cb1db1522b1969743b40300dd0f61174d2a2d55d6aa8c11449acacda300d7441b19fd2354f96076f4e8ee9af26a1d15bd7c6c7b0f4c9be2c1869d46725ff213e8b27b8a3d96d762bc7dc99590959d0cb4502bb7856a152b7e9a1e30463992c179b141d8efa0cad12030e04a9445678d4069b0437b445f6186c391ec6d221379813e0ac2b3a605e6da93e17018a6347a1e7ed1a93dffd14a5e681ad093d0bb029d800faecff0d4327c03523f5c757f7909ea4c64d693ca6cc6d28ec3eeab0885ddb5c2590964b08f4a68ae7b2be474f0daace4d513ec173c4d63e2bb5f51d3fcf949b58591926334eb6fcfce59c10acd41c464626f31fe1aaeeb8619295068a46852ff5b4ba63f349f305d6b799411b6fab034481658b6bdc2a29a24ec100d806b96404ef0a37f6996fb8229e12339bce39f8d4c4a171653fb6334e7717d5c59b7aea3b9939e7f53fff22ebc741f6e1c0b6c5a656ccbf5aab4bb354f7dc7366e3ee2e57a237bbf253663be4900b8f9246fc98ae1340f7dfae3520574eb9c47c0b530c6cf13745e89cc69539a3515c4605f1eb151ef018ae43a0fd5b9ef31ac67ec6511598cdad913adf5c12fc9188fdab9a0d1972df10a4ba8be630f3d8faf6d7e1ad95dfc47ddfd4cf6b8adbcd55a67807376dce7d51c1d86cf824964ae62728d68b247b26f9542f92b65b73e60dbca557b15d62f8dbce256afe1268311852d4a59df782512b87f808e154def42aa15cb74124bee7941dcdf76ac91f3c3348d907a8eda537bbdcd9659f07a5074a4362338719db0e3c278eee8b3eaa32fdc9e1e40a802fac5b65968f4565b2b8c1a98d34ef71cfea14537507fb3ce997aeb7da315efafcc873f714250239db13d1e7416539fc144890593bd8c40cfbd859bee13d97a80dab1273b52d1bb45bcd44dfa0cb7003e0369bfba3c5b95d508ba434e59c6c11a971acc9865c0e41ad8f7936bf2e67449e3809752cb405939bbbd792b4428f21ef109862b92ae3cc650721d8d1fa54e9ed34239762e4efa1ec7f572841902fdab7c368d3250d876ed5b58ac50d27a32a95b370e35d5918128386ec5a50930d190d012ae5c5e76d808044fad20a0df72fca40f4310ef2a7641062b43ee0b9ea3c24d35e6472c392e4b17c02b3cce68fa4edeaed817656c5e8058e16dbaa804872c40f8412fdc329ee0d8153a267d1382902e4adb88950ac90ea26161237484b6ff1a4db37f3e0e17382909610d14a275fbbdc061f82c9ed90629c21ecd3289b4bb478068cadc809bd103da73a21a28d7c3fb56a624d09c06dd342bde07aaec51888baf131de42b68a6fb435823c153919bca594b5a7c7928b3c1c1be93509553791c75ea09f5ee5fef25a6844038fc26cfa34dfa1407c805933f67a9fcd779f6d2c802e322d0b3aa6f7a0965eb3b0ef14a1077f974e0a0a80856c38e9b1adda79457c81e8234f73fdac27d50fcfd1e09163146b31259e8979a6c0a24ef955f0f805e0890c77cd96c58e3b46be9396d46293fdf265794262cd66bf63cecb279b3cc67614458384321ff6e938e5e7556ccf335cce487d8698267b34c185d3e81b89fae944ddd9a19655224de746f18136db62f3e71ecb6b207163ccb489fd361d13a85bc52d3dda87ca705e53f3d81fd3e19279f7a977e489518512000c8d7d27d6b20d0bc9ea0bb2bccf8335e170aa2282375f40a61c94fa5e081d70b40d29fa46c1fb8331faa359ef76fa7a2259ce3099d09b892618a3ec71cd4289bd2e0ab9bcc674775df35d874a434793ade5f4ce57ae0f3a6f092ec0c25c3c3eaa1caef8a4f3a2ae91d6386e70bb988faa5349f67c682e2f67b0308fe58705ffaf738d22c97d75bf9b4ca7c05f009f10e5c4040aef44f86c728ffe95100c9d79f11972bba8af6773411bab34a4b024fa883ba5ff260fca5be34e2e4f04d1f072af3173655e93b3ac1ea5eccaad38ea279cbb0ffab0569c670462fa0803110dd415b0a2d325ade4b166023792f17b28ca7fee1e450497cb158e63618a2530bfd2731c967344f89aadc04145f4e1f421c4fdd71024a2ef0d04ab4af41327b646870c4db03b2a9ac9055241d606010eaddf4e7898774c33a4e0d34803312405168b125d0a9c4bbe9d44c633e4e2b721e91f1a3097c2a98614d2c1ded986cfe0751473430784c482b5f94488efa2d69915955f6495dca769ae11a12ed44defd2df7d84c06ee832cb5fd05e56502f1ac41d6026f233830f107fa3d0e15cad8d90fa2f52350734e2f847ff9b2e5f4f2440c9d3431c7cfd61dde2e0bbfe0a3bbb119768b164d721b4a536d4b75175b7c03971162e7d32b7851ad3b1550dfc93fd76a05832a0acd144ac4386a49cb1a52769eab2fad10bda0b787e8a82962e14d5951300349cc0d071fc6d8df3ecaafa55b825b6807ae0e03d4ad5a7566b7472fc6fbea11868cbaadb497d47a2e030c64b6ec39d7f9b2a3e0249589208bd4f3ffe78493415895a4e050b43a365d6595f5ace09497cb2249a34ab4cd5a8c938404829078ad6d3f1ed9ba298f80e9883eda56efb4275e4b8a307483e34fbe7a4f45e2b4eb08ebc81f6bad65c7b00fc9c4251fef9bf23c7554af16ff604dcd081191bbc3e59f32c70d9152fef3336008277b5397e04dbdd753bd21188343f249ee7443783ec383ca8c8884fb37f175c5f3aa2e14ef13705d297e67ca61ff9feae84b6c77715b8babd8f60cce936f301c3ffb6c10bbb7a14d0d8ccab4ec9175609cddc27cade6a554363eb21de16678f34fc83095559664906a0afd46d726c8dd0ec304c12c442aa20fa04ac89eec51fb05d075d7c0cd54b48d58994c9194308781f87582c60b040c87ba1aea211e892befc85db500c092522833f0511699915c28cdbf8567a3b54ad164a3bbbf6d415472b2c3c4cc4dda2694bf72af1b2bed3fe8152902e6e0b59fd3c767034f9a7338498733a46ec06593b36fcadd968e71a306e926e530391443c19ee3448942e999a7861b2d77c5588f366d27b7ca3c30fef5f8591247aa329f566bf0a2263c2e0541ca257b37cbc508bbda699e977e59ccba58687456e865ee1284b83fba35818122ba621831b3142ce1721f6d3c93616ee374bb5ed42790f95bad9f71a0d96b50bccb06181a08fd5a3cd3f198ff06d1217e87cc9a44c4e2123b88974d4286dff3710125436d6125521c09a82056c2f75543eb300d096e0fc05ebd0efe88ed2cfd5b7f9b3c2515e7f7a0ba005c1e0bd861299bfaaefa37259023fa241e5f60cf7f594f334b705084192278f652649cd77e180f22d488031d0022fe9d254848d8b1507e712a3e7aaeb0b0457d50abd93b8be74503453ea530992a260caa258e7c58950dddb95daf18dc4c3ededbd19565907b377e4a5e93eb8a9489dd8b1edf4875a29ed4f7e16cf8715d5c5c16ee38d162884eddf76892a7f65601ac634611bf0127809dc0fd176586469018a24c89e3f83f361c53613c4d5526dcf23a176b95df5413202ecb5fc1bc3969ac594f64ccceed47fa9f8f52ba0ea70ae66f6f02525b8b6533c0db2d0fd44c0988f6b2fe2925fb1ed55033d199846f59c56aa7752fa8c7ac57fda9b6de0375b896d7137495771bc18a3b1d6fbac7025511c7b0dabc66d1c1d836d0148fb0178e410537957fb46abc358a17577899ceaa44dce823e52525e9466e9ac4a096600dd376429873c3f6333783e72c2770905f562d2f7fc0b6535fbb159d239e5d8e4ec14c22b2590da4f86dac291d019873055337bb0145fe7d74228284f322edebba7618cd77c524067c83dcec39b7f75ef81217661d0ce6a1bc3498a0ee736fe7b296b8e3832ae5708fd1ceca626c4bdce6b758926edb18e112ff4e3b54e97c93056245949c9c127f5dec0920f6e0e528121f7731ef03a5dec4d1688099356d73b9435a2af64c7b777074b4b20180befbe653eb5d04e95fc1a584febec9e5107b032be750e4d5ac795dc91bbccbef8aeadbd3547d3093fa8d71fe0fcc1a6f91ab170a5b80385eaab0d16b4422105fd65a043b4a6970ad453ed0be43f5bfa8b9e58e9edc07470576f7cbeb5d118083ceb2e6ac0b25ca3943d2ccfca46e3a8e50624313c9367ecbd320b98a74426e524cebd0455eb55d99c77437a4bf874ec44708151370be894f98291a3908eacbb5d8c5539fbed26cb73f7ab9baaea000b65273878fe92d7b6bb6b54014dfe54e88096091e60a2b7c740ecdb96096fe579664ffe03e40fbb9791b93554cdf5c394471296eb49a84be1ba133f7e010f0c5e6407676faccf8462ed77d1d3a2b422dd8e48318fca936c32cf70c0e1368a5115c63031ff2ea1dc9d520e70585a9d331b1da799879344bc69ee0b6de97904a5dbefbf97cfb111a4ce09dedda2e63e5cff35527f7dafbef29e7fb12141b2b6c33c531513710c96444dbae0419cfcb8ea8d00b1106d5f89721ecbdca73edf7b48757d78e04632ff0132fe2579b15051839500e62139acbd47a62756a69185b521059882252be74529c89a85e6f65d2a33af314dfe3babe4ad776f80a30b9efc9e3000171676c70dce12312da9352c8b29225108571c12eb4332d5f0ef96da7f53882b6a8d3fc2c65567c4b504dd049edc6e2236c141bfc75cd76e7be74f0c64662ae9c36e66b85221c945a0b32d57ccdcdb626ced802645ad1e4cc0467547070a35bc35cfb9d4ea8046ee202f067d4e9c337b2f774ac4533b1e13acaa94c4001dcabab831ac4114b4265c27771dca0259cb5ad37ad9acbac21b58838775dd243d39975d706777fcb5053efc463acbc6978d06d152593fa87eceb9eb13c0cf1426a8261dd4533e0508bb78dd71180dd32b1cf45c9dfddd18df8d2aa16a8244173849ab5463f4eec4ac158ad97a4bc2bb59e9b2345791c7fc73e7cf6736c60b715b9e6bc3f302c66382614a95366351ff4c0cc47b9657c40bde23a0fdf4e000be75fe67fd1080d146f7c86bc276b666fa4150845643e490639a2688fdd25bd24c1d47030b970798db2ed78fa5c1c2acadc5fbf9da2b59cb53aa00d6f20522d792e9f51baed5041429872c0e0f361afe39283f86490350862a6e7b4b6de884123b3abe027ed84a5d6bea45e873327d701a015917a2c5c0f170d22de075cf87a91aecdb8bf0d84bc6f3999dcd7e9ef36c42011a1f42a19c4772dbb704ff075e97545a83f6d54b22e50b8f8f47b23d6ddf4625b5aed2fd1209324e17e3b0eb61127fcdb5cc749d918d5bf8c1d0e53dd901500d991d0283f4c8bfe30943aff7f52c526fdb5aeb698801013af9af6d488edb22c10f098f7c27e1de6c7ee0b7c66a0870c849be8435849c5228447e595480ffaf6ccaf0b761265f08f5f903c97d0362ab3b66d6eac13758472b166d85e53ccbed30ed30762778b567d7c33e5e238f9657ea884ec08f37e1f265db56fa83c0e6b56274e5daee532427467d9a77bcd47a45bc1ddd9188e3ea50d3db8a1f4cf6d80a2621a94b19306c0b2a9e362962aa81613e64b2cfa72e89be26fe5d85d8b04c590a59fa5723c238ff8c838209cda54f9704f483465d87cbc7444e9fd0da4e26c29fd2a8b82a3accc2e04a5e347f01557e05254ae7d9de032ca0074c9e9385aaa25829d8e08880008167d37d37cb974c218a222b168877b2699d3c7b88135c5cf6e409ea682de6a9865879da72a914266ff0156ac73ab3601a3b8760d4e2e8426734781381a8595990ee0f089157","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
