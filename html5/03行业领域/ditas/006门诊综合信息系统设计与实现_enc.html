<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1c8d3f71817ca3dd2757e28950623653c5f92fa28739c964c1e82898c5cd00f795483eace97ece68137e035227aaa9004f3d14cf773b8bb5d495164ce42c878172f91ca52a198ac6ee5aef8e84379f506df013ef81c36f611cc9355235cac658cd14efcf4927893e347443bc0ad40e96804a0b9bd9b769489741bf6456a975a51cba46450ae28120aa9ec4301173399fd50d6f86b7822e47d9fb22931172158e50c7049a9f4ec003d98370742fd9ccd506f00d9b473ebc3efbca3e2eb80807c1c06a1ed4786816556ecbad87181b024ef23e58741ba8c967d7e2ab1969d3f8c00d06b3a646b66470db460513d425ba04ae50c05c77d48f293e84b1cfde4836447e283da1befbea3ca60adcb8496d61aa9d490b210ce5f919834b53add81dff5aa24fdb542f05e693fb3f422f0c5a7228e52f0098d290633bab9f3c8ca4b36251f489ff48f379cf4bbb91f6b8eaecb17d5cd410e60da78c73c9089c77828dd70705d0856793329fbeb52dd763608a6f40e70f6b51eb2d06247745b18542361def5d8c097c2a0046dd29b68adaa87d71ff9510b49d4571568a8193a4dda7556d15d73a9fa9d8834097c162dac550cbd894f8ac1a5effe2b1d21e8ec4ad1089ed57dfe322598ad7dd536a1e89ee1818e1a6abd535e33d8e619c1d4e0f998ef8e0b542d822b275ea0c94c2d100c3a6180792388899a434cd87f99ceffaaf0961cb57429c9e904616b6cfa3ebe80c4007274e61bca98505bfd772cc2e3d8393e75aecc5d79815f5f6418f6fad64b0998b4c431a793b2a080a6f60f428e78ddbd10ace5f2fe5aa05758b0cc56328bfb04b6f5379bc01b10170ae28ae4b0d2fc41024f3b482ef610dc32e83e550d4a956981ab3a53d3427a4cf053e94009874c521a5f3cd8f545e907dd215a10851208e9331fc42512766c0ef25cf24ab9e78f746426c88c1623b2a68bd8dbb6a2d61863a24c0ec9a21e4df9623de41608660614746ad992c76eb6a7899940ba9d866aab24c0aee5b44207d498ee4deb1f6f491fe63273776828ec56b2188ceb57f48958aea24171c60c85b63c45a50363a09b8d7487e3db97dba940eceb90323f12edc76940bcb6c734a48d42cf1a0f6c5934621ab44d7505eabe50106b776edf420532e0b1680a4396fddf66ccf2a7e28930fb80e3693d14f9ca3f015abdd124a792f2ef1337aaf6b7cce67f2ae1946fffa58587fdf137ac8881a90eaee4e644c5a6e973bfc4ae022542f6eb92a233283e99d96de0f86ff0ee7cfdf6c5c6497a9b668455e928481a111ae55b4fd43fbf4a978846fc02e61fec9e0e6d633def9e59a50cda3a115e405dcc4d9c4e0b387e70c4488a272421f26f8351ca2499f260fa0f5843f66af7c862672e9c2c7b9a660f915d129f2c078e0a528a6e02cf680549351548a53ddeeef5d2af474093d188491c1eb46efe39cce965f8038cbb4cfe216712424468c6ad53e5eecdb5a6047e577fe834f7cf41262356e313da9389941f4e18b0172c9207c82932773a72a53f9778adbc8334790d65adc858f5d1fa41ddfa7e93c7e03f29a484c4c820e30d4fcc3fcc9329521b9e5522c321dcc27156adf65014251568ea327e0ba89767edc03e52c9aa96324baffaa563dbf61a698d94ef053c28cbcaea3c2f5a0289498e111b08fdcc4b646e8fa9413c3d6f40ec170b2073f6e990af4d8953ffe165b9f33d4d9d4337a07b91d675694e3c73c911fde16522315affb5b91c4a2e2afa4b9e0d771ba046567474bbe52c2d619256299626709edbc217b46df11650b5e1e03b255bc7f27796655b1af1591614f8fe0cc31eaadb9d314ce893e3ee29fca96cb648758ecacc306abb95e305a3baf085370f0b01e049c5c10188f28dafc0c584085c45ddbf2b4aeb5449f6cb97ff60000841eea5563ed07c8ca04adea53f0722818785164b835706ec54828ccb520eb3cd259e3ed012d5e962b61b6df7115e1546b64e1911b5b3ade844ff3e889276af4f7f19209ff080c0e47ba7ebd36cba925e600d3388bf7251743976c67bbdce8c20501e878fc1b52f22bcbc7ebf0ea75d855b78c2e6d3fbfdaf3ccbfd1ae5d0962d30cf3bd744ef28d5a117aa93a04b6e3d6c146b1a42069544cb7ae714744907a02318ed95b8ef529ead512895e195497bb9303bbe72c98508650384f5702b82f8a39421013a81757d4a4bf4f5b57293052853a60a66de523bc29df0ec8c2eb24ce3de99542b30b24165662ea93d0969bf90f0d7f5761a5693ce212b782a4c94dc5c39e8d820fc227940f2e8734d7e1600f3250d21dd86c45c32f4f7c2e9d26deca3cae1415a60d56ccf07031165689845c6fde28a607dbe52dda23e9b1805d68f7befe915a1c724b516d9d1c54f3aa1c63d57b3e214ed1c7bec861d8522652f6a14e46ba2694aa7eba7772882dd295e25f2c3ee4fb3dc4a77087bcf417ca5fc7739242fc0245a70e9e70342be7d85a6ef0d7d77e892bccd58c6c70652ff487401ba20cb1554da967372072af68198455c2c924814a6da27617ac5ed671bd3b96afdbe8581b4c6553eafab64a06bf8afc6244559521fab2ded018313915f0138aea73aea3723e8740404832aec9004cf37a3959d11c2cdbb39f66314c010fa3bef89d5e91bf1bda9a8d231fb514888826b8c563aa904e60fc5f3904cf607e9fecb1c03910a3dcb321170b87714999d26c431e935d505d2a5a086997c10eed4d083bf9de611736550727b66e6a56a2dbf6639ad143f225003550c2e8765cf445e8f7a6464b45bd260391be868483617b3a65c6d6eefe24e0e7da4d50dbfd0f433511d0e279217ea55bebf969f4d3c244c7aa4c598c942cbd16f0ff3fe7811e7b888de986fb348facadf2147baca1d5162b16d282886dac58faf63dce80af56445e4c064f3d249dac5ed562ebe9c63e1bcc9b5a257a43414deb1aa1c613ea3861182ebd5b446e39d770b55ba509034b1a2384427eee8221805106273b3b0e643af666ca2d709740b8a193f443783b344409c4c20e1b8d23888a274d6773f85fa217c49a0f650d337167cac6dbf27dbb9902a7784fca35b131ba8bfcf32c6278746e4705311b127b6b8d815e7d3c7a6fc00211cf9feb6e0eaef805e302172229415ec857a24cd759dda585295e54ddbce3b0694ecf573c685d9f7b2eca52e495728b237a50eeeb5d4018200907408b01b032bb09d0def0b98991a8f77b0849a130c6b84581085b8972b50b57162c500f504041d76a24931c1c09c3c7eb99333d9b13ecad4286ca10e62cea585bc8212764e6a2ed454110f06e226e8d3a48a97086242a99b537da558dcbbf7a54628368cbaee3f617e5c439b555470fbe7cf2ec7a57a2bcb4932afd2ab8eb5c8b3dad7f57b748340b81cc2772998f94c193243cf1563c9c82e6dab757e117e66537c26f7b5956f5a59558607bd629a025293309e7c01700586f7ba31436ab321de91d01d91902338173734758722d0b6d1cb2232d96952f058d800f262534be0d21eca8d1f5f6820ac476ee9bfd902037f60b9c3ed3225682e26d12166ca91735b0be2e3a5d3f63cedc38b764ab29ce4ec9d58b14569e9631536238f1fd3265ee1bbf17edb68984fe68ebc95cf19598c071d84bad50b66cabe72372c55fb009cff8500a8b5f79c7269e3c2b2bb77d738513a34f1b43a51af3b40dc9f153a53fe4ef64f7f5d9b29195241a29805ec1d36edaad971be1ec5a3005f3380769a53c76ea4b27f262f76c66baef3d9a0e9e1105986fa833a06d921c4a356122dea26ee412878877e3a41f4d315e66e0452d1fb37a7800676defe095687d0f6b9d7703b2d1eac93ac7a550fd19415cdecd19f059c8de1b003653b997f0baaf7a324c2dc517773dfee28f8ce3199946f467523f2c96f642a4f6c1bb596877f1c92989c6e23253498cc6327ab323300253fc548bf046d87aa7ca9356cab29fb7a35d29fc2c3e4a44f1a3fce56f1c62a9a121085783bdd75d6c5943626a455add596c1ceb64d6f119944ba31dd4f86e05c4a2b998ff4e417fbdb29244cd6b8e1b408f3063d809090eb1ab0a49f5b384d042b480ec4ed131b6c7150405572e9324ff7b60b59edc08bb66c081d1b73fec5c1f011e860f6d43e0cb188925d4cb17285f90d3bf5afdbfd81919547887871a8a4a7b428babf45afa36d7886c14313cc20cce0c862ea6c7eda8691ebe2164c8036dae501cae795b903544efe32cec202d34491f56c1eed3bce6f4e55324c67827b9edc7880448da21836026ff2e5603640131fe34b2bf216f421d5b5e33d2a433e851e9a4dffecd373165c4e36d677f3b51a9380e4f41967ee233706ce8d0bb71bbde4f8d98652d079409f6de7044e4d7a6d87bed1adb2b96537653f9d3ad57a513f3d869e341caa63421a722de68eb38223ef8c26ead57cb9b933ce49f082dd0e7d60203d8ad13ff57cc07090c835e58f60e0382df8872aa1273b9256a8d190ce027b7ebe839b47dd7afbb75850bb9f9d3b87ef4692116a77dcb7dc999c276e9b6a821aee1711a6c7fa4c44883dd0df1d5e8c6236b1cd6318c2d56b4f81314883840773300ea087cc8351b5241f84a9961acd89467c1da28467de28a89b6cffc4487cd3c3a39f55102860f77e892a38b6361256526b86b50154537e7baae36351fc07a276966816d0c49c57f11106db2b20ce92870f56cd7f6da4081de8b6505fed1f8420ce28ef6e135c3eb384f19e388920666cfa68adda4664ee0609ea47b2f25c1adc85276bd4e59b2a0bb47c959a6a5193dc6e4b0980661fdf7f3be2349d022a71961284fd9202e57f2b93e48c6748d3bd440b7271b23f5b5f296fbe7db8f4eadbecfd8671e9b26bd3b3f20ac3f14937dbc457a1f1af13852a75f7f1591b2d383fd6241862107ee0b1f80cf5f3c4b8f07a40d1bc92d491d2d5c2c919a05ee258795ed538deca4da7097b1dc8c721533c4007f2cc5f551720559814f03d394c1d0a96375d0aa9e98723ab02ffd68eb24880748792fc4cd7501e050b50f950af34e94f012a6b9aeabe9618ef0749af59107fdba7977970776fe18f5ef5a08908af1c9c0334738c3814f0503869d99c7c24520c62ca485c10e0136df6d2d5e42a6956a31fc8117714fe9cde683b31012123484b15e5386cfa2405c572e7ac71aeb28ba7b3fd84975732dd3890212ad7c4a542bf0330fe7984e75080e730ca294d4d0a1cdb50b8f913d51a69860ee02382eed547883f193c18f5068a8d325fe40fae6ccfd76a9debd567cf858a010373fad397e535065504b6cf8a96a5aae327091e99fee5d202ff6aa07a180445989cb583d725fd85bac4d4424b0ff66aea3c2a6650635b52ac2d743264c0b442f613adc71c06879cf48e8bbd8a9cc19cee014d199dd01289ede3e5a7e786f3516c6f0b249f4c60411e9d66855d59c3de6c180b403618489b4e77f608fe4e658b33d7473f06c0cd374e060327f765e0d351501062270d9dae82f0061dba1ab3ac77c7ae8154816db9eaa8c93adb54e4d9424d95c342268965f0e2f92018de801b4a9570a13ffb9a2e0ace2ca06cfe5a48480065dadba8d559c64443ba59a694910212abb1603f199b169af8ab698977c57fa248060bf96bb0d595b2b45bc23ae0108102dd97356ecabdd0638f1516293b67e54753f54a2d8fbb1b59bdf310b708601d137ce63db07b003816c6423c042dc4b1ee8ca37de81bdc21882a598606a736910c84804bcd98a6b91ae7aec0b8c69f352d1e070bd77ab84534d28004b424fed5dc89702e2be5870597d6d6d1485996c8148ff4f0807ec86fe4836e2d1fd3bc0b2c1998e042ce72d72f56677095854a83b4d0bfa27a57a4173a30980263ade571c841934f92ac886e298e67dd7f1c8441af9ceb9d700d52c391c7a34b024df12f615ed3f144904ff9e28d489485339a44fe84175650a4a721565087d29bf67421a7a14b364c7c79765455f3d56ad36b37e2db9e0ff072152877adf24b6ac0f37c0d9d539a1a1ed7f59724855c9888153451eadcb50e44fcd54e91075ecbdd8ad66b38efdbec7cfbe7bba1f4f230c01576cfbc944c48ec90b1d5fbbab0113acc4df34bb40dec2e7c5172350abbad162bcb04a3a6e7c3389ca21fb865238e6639494a67c5ba52fa255fc8fbfa1613b3a2682543bee7659470d974ba07db70b98a7165b65e780a0b528ee38abce406418d8a5d177eaa770ee70b7bf70b7e2eb7848e7fe8f757e59134aa6a81de78494482de641adf8222f598e4c150798a0bfe4a47500d0fe0653677696833d4e9705384bbe35a9637d82bd1514de951c598045ad391b8fa21374d9c119fb166815d70f60538ccc27956cbb3be3b064a738c712874c8419a87d41908b29786fd3c3dacfd2232c595b5f26b4bc9280cdf7773e21cb71a03e5d61d364672055eae123edad7584d350ab40c10bc741a37cc74811a4d2f3e410e5db22adb6237e62c4d23947dc4898a003aa504a96355847e413f500487f1ecb49a3d009ce91fd1cd60df6624c60db95360e7f329928eb26f667c7e73e15580bcd7174185f734b3f22a5d18882cb3bbc89f60f3c9f3627e332d87e13f78b25615d319d72bb902233974f7e130b0c68f7fc600c92994563be93a8bfe681db4d7773f4d6c525022335555689822f70f4a827bfb31380fe64ed12cee1bc9e83c8bf59504ddebd56bcfaaa25617d8f900b2bef19310cbd0c73a7df86f9ab27bc4e6aeee0641b1cc8c94fc3b479375e998789d224ee62287e8e34d00ff4b1bc86ccc6f658a3d491dfaece3526c17ef6d85602d61f8b6d20275b6674c80d7450afa419cf75732fa11af64667e0b8ba3edb5d4ca69c00e91440fd010e753291d3193d683bf35a03959b488def38d1f6dcbe4ad278cad781fa3786b0d57ff2fa3142015f1aa9baa90fb70766e7a8c96829a79beb3eef1304497a6c61dc73c3752d7cbe28cc7699aa9beece5decc0f0be340888c3b27e9553d389433d2ee401084dcd34e61b2e48913800467ef570b518f8353146efa52b5d9a49abe03506c43f518fbe11280f5aabf214767095a0d34ae159512ebd0767553bc92b0d07d8598cbbf80c749cc532a4b4c6b16b1450f1c396977355303dd3f23db3e678e9d60cca762ce8de218fced829e808b37d13f73f083d40348fbad5dc5c699c7e1b2b8fb957b9ff712766f060d36b093caa8ca7ead33acfa8c5e32b2442cf884102fb7bf7694250454e50277fede11a527606d9f04562f8cc6f69ecfa84192184ee85f0350324157443e130b391e7a0a2f57d41ec1de63ddd7f6e081fc91bcc4331ddb8d7235336e9d00dacaee0ff5f9fca439108f3285dd7c429ea4fa25dd09026da3b488972fbb9f06ccf721eced200323fb2c0a0801e5af06f3ea00d1a7d6d533e496c4520e5a7b2fb8dbe95e7b6a3fe326f98a4a3c5eca46f1ec6be48b19cc6446bead71ea033c1ce2678e96225bd741e013dce55ea94159edb59300938b7fe34171d084d719f6c0698b6259f5cfe1f5399a729a789d5fc81e5faa277e841b8d76c57b8fd7b6188cb31def42dd2b634427bc81336b22013d9a01e327ebde42ef2437aee43b3d1f34e3c4d1eb2d8011efbadf7aa54ab053c969416b1eb9af2d2b49261c389b16c2159343146a60e067ee7eb107e987a9858b70eeb520360a189c5a7d3b08499cb3b3c0ae615b3440835a5dbfdb4270ae139c47d06f57e82ce4ad94d810c705c8bcb2288da364cb8df4debb642462ab7abc3b262e781cffc7f8c78f6b4dd6cc817b40ecf3306d870a9416b6acc8c9b4df7ef696b5a141d3145e3b17588294519aea4d6ccb0a5e083d7ef6592b6b3bb85c82e86ebbcf65ffa25511f8394d1f77ee0e32bd946e5474e8319ea44504cecad4596dca70d8d2e69c3ad0961edfed63a1d517874757e20c64a255fc77c4cc42aad79a7e66e876cb3bd1088dfbc2767572f4b15938432b02aa4e811c73620d7dbbf89e4ef6f91f7f2f91b29c858f0210f2d8ffdec5ef29a4afd44257a31cb51701ab02aeff858c61a99965e5e455f9bd1f10b295f90e4c7de0fbcb72c9794d71876c74876ac58ca08aaac6ed3238423b172cde5e07d5b2d40023d2e1f3347b5e6bfaa1baddd60d5af498775061aeec5affd6752c03677597a2bfbcdf31af4be6fbe4b0cf619893fb73d805632e92f3c95366fa4c6604ec457e59e8c8a17c180259f42700684830ff31ece45a8f108ff00006d6b92499d6b75df901d6a3ebd11d0285a17348d844c876a1998bdb6ffc68e7f62beed6a70b7e6b931a6eb03079e63857188c783e26ca0437a601c8a0a8064d1eca3a859ea7856ed2074bf382b523128a8a0772c24be34447f57ab661e90f7f6344ee01cd2d42ed9711ba144ff6c976bc43b4c299b2a0b4694fdecc1d40417db0bc0188c658e8cef87069d8ee855f0ec1aec25af8cb203d602f49e707d22decf1bd22fde41292c2d14f9f8a73df4f13319b9e0fbec41301a5ef4d2434b7aba53f022f9aeb3de3071f9afbbca635380a9c7c7a09b57e77dbebad4e1136d14031d8075be1e12bec6e9d604699fd6b8a5bf3c9922cf780dd34a5238a2eddecbdfe8800263650d2cf5963cd7cacfd2e554877740dde984d0aecd7af29c6528609cd1e444486beb374e2c44c5a6a9ef5e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
