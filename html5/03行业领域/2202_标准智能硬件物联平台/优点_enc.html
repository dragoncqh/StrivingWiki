<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0127f30151049edd94a3d74c98bdd0b4759e2dfc88596a7dd6549a3276341c479efbdb2c40696468317493a828e3a06835db2aa14ba240c5b1aaf11b41ad142b7c9108adcc7bfce14a6f14142db2dd962b89b3f3af31ce8e53d3589a060ba2fdaf483d0a8b661a54517f71422ce0f18197adee00dae50dfd52a0e8614854c89f2107627211607b6264983f929117fe436b90b2f2396a3519916bb276c419c94bedc48e11782717159b173365c9191e4f8c02178d62019527537f9f687e20aa9e0754ebc1a3c96facb44e95519c7daad14c14e330f7f2d61c5276b816a23c289cd1ec99613b6dcc7902d205e898018f3bfc1e4f4df65d689185eebe38e3d39deefefd563eb3b9fffb0325401abb345af96065d32e665745e13a09b19eb7af7b4820d4373e2c719841f695460195760d4f0f846bf9cf8d3ba80bd0b5dee21db5cdd0bd0a2cad9d91d6da34e6cc243f3fd98da08066a73ccbe57c302d9c9d33f4956480b8469bf8daf4d9ae923cbed010df671e558c8784f479286421c4c07e69380cee86977d950499a775101a972adb140634ea499c9dd1fc0a21cf91207bdc6fb819ac364ec567d5e3215f11a38881d19d185bde3b6e896ee4d8b563a5a37f56029a05b4fb05d26247c7f50e9fcb22ed7c1a901a858150f09d9fee8f52c6a4dcea626222285bca12b555b3b0d1cdd802cccb029d0433345a29900ed379b6b40ef21f5a6f53243e4444342bec9373bb028a2ed012942858af3303eacff53675747f538128249a114d687dc412454b44c69ce6a9f1ed6b238077a5d4bcd4a1c7a5d01912fa12569abd53fdba253db67df654d4fc03d44d80ff43806a4c8038454551fca9a152c8ab747593d384f4a829014249d562d5819771bcc9fd0ec28a6ce636ea62a240082ac3b49ff155e224468a5178dc3557d4351441fb7f725e48fe2a0b299aa1cc4f5e4c5af7a802228f892fa32a69f1970331d32fa970c74d35558b9674ea4fc8be6fcf8807a082a69388397954bc1d283f2d5de88ae45e6daabfaa4b715e55aec4cdd7db687c1157bc66145b94feb8337fdfd94de77b5f33ee8eeebd382f3ac02e506e7d67d761bf2aef19e00d99e03abb1435f6e98c79f7cffb6fee384032211f0646c9a4b79f361512400fdf90b9b4bc5c0cde1fb1b6724d88810ca1e0974ee274add71727a476d0e96ec6b813c3df9921d25f0d35ba44a24c96aa2290a1744474f3179c2e2ba06ddf7dd8ce9eab7cadbc0d052b7590c628c166147927c63c15274c1ac69ff8b5ef0d8a887ded4c453b2e1c2dda799afcbc410a89f81efa19dd77f3a2b493ce86e4bccb8e0a7aa7c100fd67e070a536bbb3d3f723972f293bfb711481cd7fa8930595d5b7126f727c3c5cb772192d40025ea427c78d631603d553ce7c40257af833ce50ec743caddbe0db7fbc9b52c27e5749286d53fb8d202a3d759713cd6e10c7c07b24a46d681b19f8ef17233008c2b06cd8c176c7283b9d2add9dbcc17fd47e00f733ff329876762f5b6c3269f7b8c8aed53a9b9dad8f13d15612f6c5d4c698b46b9896bc51e1cb26c575dbd9a5d4738e4c0389f9af2fd3cf07e35f9ec3274562e69b4aecaa8c7279ef04aad6b7a486dabbd40da0d51eb509e0bf66e01396c1320a0d7996a28a3f8782121f971a986e4b4846d90499235c4b7502c846e1c6d0aeef05006944e2e1fad4158d8750b7ad4f6345152d662eb13e0100497260a46d5e61cd93c79ea116dc0ba37c7522af62460b4a82884b11c2e051587ba916ba55f41a54d3f1b6312995b9d22975dbc16e4c914e94b88f96d196ad79ab4a5507bd6a3796e215e1566cafc620a320664670caf26591056890bffa9115bdacb6997145588b8d3995e4da5070949cafe64a57a96d8e42c3420535f2e4b0a6446a44919356bed3e108ba24b4af6383899acee3ff528f43e9bdaf267ac4c80ec50773e5ab97ae967395b67654e0083a0cabac60cd8a47660426bee9925afe2abb3d0c9495854df45ae37edeaec0a74a327f906fc7ca776b02c33ba8dc7d0d3ce32ccd0935bdec20d30831713dc870dd0bc7bdd82d2cc2bb2e1fd3f28b09b242d14fd3d885bd399cfe9141bd6ae14b4f57dcf978b2bcb68ff1c5f0f480196591450d027df3f94f0348ecc3b631398615bc8ebce11ded7763a99cfaf09f4124e61dcff29f45afb9a4323c43162a18fbf4bca49325d24cb3b4b54f62f3828b8e5998b222b74e7aa064db9608b2a5a977bba614a8931da25acd6997ec6a3fb9f902ec2d8f9af6bd7ffb963db65fc0cff4f8c04b5130ae33b9da1f3d7432c8fe2e30b2b293164379985acb66523c825b7a2e95ef56d0a47f70f0df9946adaf7ea3b81caa20299152447e8e3b3436229244c7fa61e46a22960bbbf904f7239f3142e2fe1690bed8aed32e357f622d775d3a4a618d15eee06701e58308a3f2380a9a8d5167e0809c80360cfa584498aaea7d503705873a931bb5e121639a8d530a650b0264ce352782f95864a095b139f442f50a2358e2e9df52f9b2dcb5ef4c6caf3f0fe5c9360993985782e75efd9d125a5c60d50932be1957ffdeb44e2542301889fecdad2cb694a6557cb35108ca77708dbec9e0268c4f8ff3c294ae44990196c6f55d4b8c48fd1fb88cb9fc6caa5468879fd0219928be2c5530a00dc0431aa01236fe5365a01e0b80a0cfa1409a5b32b888782d5a8a794dcb00f2ee997d649d0ced55fdf30f199c49b0cccc026c067458eb88ec6791c950c1de09167840a54c1a31596a0be7253279d9d53e7826d5e086dde2b715875d85a6438d67860a8b490bbc22df16e61029799c4bef0592afb04bd713c494c6f937778c633a2d8ffed7842eb39781997dddf1ce811af8b5bdd439a42fea51f322fd30c8b18a41af93ae55ccc83878ce52c25c83c4528dd9ec56a4a290a2427f365f719e3151c40e32f7579045107e3d3d58c6dba1bb2db0e1b76712395485aef3fde5b3f1d9ab09ea3f782d3889486ce12e794e7fe64552558d7680417d3b3226f49909ee81a5a9649e8c187ddcce82865c1d243459d2912a337e9fec2dbca6c5941f19abcdd7bd2306ce00cf61befcb167783aafc3f441ff3986f97326108f067ca22dcd86171c6d10a8d34524c17da901a534932571f5821c0e12713f90394641cd09d63618843d0a0c0beafaaab25c027147642f3d753808c79c4ca2c143d9dc8563a27b84af6401cd063516e26aa5d20d649e6a2aae93b57c81af77e2c72031d8c63a9b80aac90259f1fa570834c64809da5c02533e8368b54f7697f74f27a50df16656ba9d8563f9cb57ac6f551b97f610cd1ba350bcd4330d64976cf6eb6a554a7389004d82b4dcfd07fc36d8eda2b1a1776dff3ee60e884f21013824fcb5282ccbda8b0b0b52f3651168f27ffeed025b3fe44ed80239234fe63b5f0998999b3412eeb778a9bf61706775ac862a1b1ea411d2ab0d5ceb774fd87751b9a06c8d88dfbae9e13de709e341bf2058e3dfc9ab131beaac147bb4eb081f8b239e42e7b17b58babc2122443eaa129aed69a1699800d93d5418e0f4fbc929933fd7e563dd069769ce762b74336b01d3e256a38b8832cb0cdb13546a1628fce9f7cbc9d0fef36474d36738b4b4dfdfe8b523cf907f7497ff3c33e0001a4718c5b744b26149a7c6e6e2bbe8f0bc564f2ca6eeb38f6c3faba365421d9633ea19d29e84d2b8f924332d6f96d4cfe92605bfbf5c416d56b121eebf04b4c09351815e2b304056a72d9f1904d983f804519fd1de713983e3b9678a2269c6d2465cc977567f6e8c73950cdfdca66e3587ab71cd4521c3ae1ae324bdf46c8a12577ab066882c5fc5114a99a15f80de4670e4fcde0080fad5c0ea88605253e2414013876f9f4257c6d946f1ebd51b4135982bfb414c75d6a66a736f75a43622fc78949f79086c1d2413396c4729b8b339b4042bf08390e937788511404b5c39be9165ac0c0f45b946f374898c862895420fcd4d95fbc87d65d487931c33ce05e218fa2c2e3ebd0bab69f86898c68cf71817bf3f79b409a7576848b109acb4e67e1923f4d079783ca1b68c09163c50b13fc52f1e66d56e0e6471beabb2422a796c432268a3c6c980ef4d8b1be601ffdc57f869fe75fb83f394b496585184a304dd508c1ca229b7ecdf9f4064915bcfd98cca8ea651887bb9c8256f526bc463b1d9967a18148c5f7df374d7eaa0eaefb6704078596182d03353fc0e7860dccf7626dfb722b7b49b42a57724eea7b6a03a24f03bd96ddb491e547f1aab523f412f0e30fd94b15d345f15ffaa97a3bc29984865f5da4f9fcd3b5a446d40fd7a9ad57d686b0a6868f4cd623b424470d57608630268a0fcd7f410e6a9f1a6b86b3df18a5d87007861d113e5286ee297248f28b198012483e16f48b71ea76f0b5b6d5b7059002f69e19111aa70f7520f2f77444e31bee0c24623b81b32222a968aa744aa08087d74ae2f2447cb1f291e63d219aa53511f841284ca03ad1d06e4a3e2079f81a7c92b115cf3127f93fd9ecd260bccb34219cb01ee653e642fb5217d83dd2e82c14fd247a06cded4189c10b13867dafb4df664d1e2317f8c4fcdb8e8a1d8400c128ab538f9332d9f6b646cc19b3a48122a405758bb9b5bcc5563d4e1ffe64cafe31d29027aeb2fdba7ed41cc71e3949fb015e9eed322699c640880cc3d60f9e4d70d5737b1ddc284063e322a75626b39f0e28bf1039b856aa163fb1a00387d5361de6d1bab5b6bae533434118f5f35ef4e168502572cd8e2a9119166314f6fc1d34763813498c0a53ef004f59498d8b38251a20df7635d22d3c02b5e242f4c6348f9cfcdb897f8ee7887707d120dc55dac433b544a94d699b2b266a28a077918aef3f8dab329d6840cfd895a63e198f4e3b363974c38efb01a51fad9f410a3fd52079ba49f2db6b770217f2e3d24f5fb9fa05395a9018db4333f37dc11d752a81b582aaab7956a1e47df35a13c9712cefd39f4fd478c1ee151a650c3d8a1fec3adaa40bd96e2103b234c10a62315b59a4d58fcf3c2be1f2a86c08cad80199f1fe1e20ccf6d59808e1c5ce23b8339b1704c505457b45f2783fcf50106b8c4bf520c6b09ef3d8a78bab415b85b54566cbef7b8d49b684bdd8594e7b40cf607d8b925543bb453cbd55dc16afd3ee9e955ba5c62f5a32fb07450bb9e2eb2e6e4a448b66b9ec21fd0d59c32ebb34ec207887e0807317c51e023cee8e74df4095b6742e227f4bdc3cca7474b7c942fd6681e0c4863cbdca61246c78bebc3606a57a8b0a05caeb114c8b5adcda9a5b7ea38e42bd58e076a1f751412f0fb4011824135581b5add1f2d6ef3a7e42ef2da9a64ff449ca64c12e0e3a1f95353fa1eb166877714d2247c6bb645314a6a74fa4d8798d1955f45043a1bf8a7738875a536684784c595f93f09190663b67a6e68c10c395c25d92db262b3df9656bb772bfae4d13fa7b283636a8642acf98bced064b7a577e82fa04bc1b8e8bf36e64d562dd11b249a2254f59448183c42ffa824afe8c456e3db45c761fdbe829744e22447f41ee5ca59b2153cbdb8b20156a221464fc6d7d4c9368e9914481d5817389ad418371eb86eda855a405a374c29ae066a47cf82748617432133f7ff4404adc7493b89e7285e316425026d91b0c1021f756c1b99f485588124f2e86ed0ef551e85413e6b315a8ecffda8b3b6d5de452b2aff4f9c1b2b68f1a9985b3b9a35cd976a9577f85707f2e2029bd42545c9631a23f8db880fd9a40834b443ce1113db40917006b491b123b8140aebe44eeba97a890fde840404016ef0fc6273586c245c306f3d753e2d4eac5e878e6337de91c06911b4700194a40e7b6cda935f72124bef850e5abfd4f310fc23031f25717fbadc1a74da3cf075e33acecf0a0eae77eccaeb12f4de37e27865d9d5aeb53854765aad048a608a7d6188b243d6c06968ca6aff444e8adc908cb5d03384d3cf3c0688798ff9c2b527581aaf4b43919920cdc63d57d2d592e40459266edbe8657a4e92ef21ca0fc72f41b69aa094a724a5cacb81ee116dc98303a45e81e683235e9ad05af536159c089942fb18ed874968345889d4b9905fec2aa8d0fb0a38a9f9762e7ed7bfb131257b1978dafe75acf32e000c051b67ecf8f361000a190b246cd42d037df9ebde849cb0a49875788145e939002b13bbd5525d196d99b53b9213d3c31f1929b9b4c5a64d4417391742782cd5b575ed257edebc10e71bf11b99ad32c8f7632c895b09a74e60e540eac16ac9e56507ce412ebaeb14d93e3a06d6901b7172ec18e616f5db80da09aeb8fc3603c53dec106997e1df30a166df8bdda580255b3891b4eade6387635c8fdbe4b9614b76fd58e1f06d73d80da66034d53f2d390f138d22773717145ea9213cc33eedf5bc4d6a2257efebd8bb6566c7c701414a0bb9eb813a9bcc481212ad9d2de14f2d8012e89fc09532ccaec874c96bcb6117cb13369a76249a07cdabe7b2c352bc82884517d42b22cad7f3d371569464a60247d2278b29ab4e9ee977fe0b3dba4193a259ca8deb2b282977020b8a4b1c85877bd4f8c3f2cafb8e838d55b971de0c4fbc3e789d4fca07d803df92c962643228e40b06c641166a1c76843d9a6daa54c29fa13f01a30abf999b2c6ce3ce47b5784a6eb40de4efbe4400d2442113b8199a7c35b84afa0ff1855d47ca99748b6878d76c108f988b96dd63d193a5933a9705bbe0c65f502bba3252b77c5b95aa9448dcb53198cdfd11956de002faf8c95b9ef153b173bf61d521363709ca4b55e1af71cfe93984ae5a577f6fe560b72545080df947a06a1086391c4d1d151ff7d168b7e6b0ef603ec6a618828be9611d11f3c8a3b938c14969a9897f911aeeafd2ae2be493f4f54dbdb004c9c5fadac54e9573ced0ccdcdc0c41dbab7158727382e2955b030b6b28f26b26523ddcf7aba18fa664681ba4d61e059a23a936e7a4b975ba5d8ae073bf36f93855f11d7a22826c018e679c8cc826278925f852a5844d15d65a98e986d046cb55fd75a334b29c22321869e5f30105d0c76bbc7a1527be2d0594d847568d72660c2be8f6ce751b02f0dbd4d1f701a60af7990ac0840da94da5213e577f596bef9178101c7f1ac6d97e094bb38ea7565a1c5b0d91c056408e2eee9ad1e07771fde3dd8a27f673bda7576339671e9a6b9c8bbe58544c116661766da6683ba53e5e50d26d1135bd58bf18f6c15550e4dae8a5e1e9c825889f394e123e65736e38de99f5fc0120137b33609938b3e6a938ebded021f91db614f898ec83a99140db0a46065f9f576d6e85c0a7788a348294501b3f4d154f7c18b2401e5b10f77e8fad13e5c6d62f4ed3a832986c8a3ab272950012c3575d734c9d66e0ebfcdb994c0765afb18100f8f8617e5ceab8c1dcee1d8cfee4db420c2b9c63b7a8d344fc55f5321ee43a5d00350db703ef92f1b706065ec6c829bf04734df8a4104a856b6ce66bc6d1423c3958524b14afa165e69afbf510d9fa4493019cd4d419ba1b344af827846075d091a6a564463c8e74a3f92412ef4dc228ab8a7e0483e65540112b1e63dc9dd181e0d4ec934bd740eca12150b4ef82b51d051aa05d6f28834cf598dacc4a72a8336d891255fd0b03c98db03c723316ea134fbd53280b3aba1e6ea00047e4a7ccc94d1abecd8d6ac9808e0c2482f65f0083c4becda097d75a55196ef2bdb81d7d4960680f3b3124558acf4d9fd966e0a81a9d312e68c83c05a81a08f67b84c6d4ea4980215b6ac88986bfc73a47871621af485899344d3ae27350b63628e883fdad321ccf647dd729c1d9e7fa1721f22001808cbe760466f7be12c973028b26f0e76a58791c6336a4cdd812098b95233e31f11903bcf49242f21fcd80ecb06e7d8208e56aa0b49acd5079b430aef08158c9225432faefa14924c220f01a249dd23ab4eca8e417a3b23240b2e18d2daec95e918ac66f45aabd1a414c8346b4d966b50f87c2f957684d7625e8090cbdaab9a97a1a65b5dcc6a262d505ebebff7b957ebed22c8b7c4edc27b7950e1267231a4a3051657598096b614f5e08ecbc11b376b67156bdce3db7a84806973070e55d15d11462c46d8ccbd43f17fae7da792c7ede714a77ed1d6e215a8fcec8490d8a96d787567f665b6b7e62bd7421782f3a5589aa140d9f323f703d5b7a4e03fb400fb09e9bc8c892b46c75b3dceb336ecc7165913f3d33ecc58c90cef11a15ec9f3e37af4b2e0ada314acabf2cb330c8f1898801c21ebf015f75d5a25bc6c8f8f336195de167d7afeadaaa9a9392ee3649e65642fe6f812b738bb3e4b1c0bf0f8975416c427fef1cd9c05a46d170d0f5ec9a51ceb8d1691790dd83b3f6293b5bb46014db3c33b87aadddc3322bbaa8ff46a45025d30cb6bafe620061ff0fca1b83bd0b2dd060f8d14a29b0cb390f7996b7379b7a318f0ae5014f9556cfa413a4379178eed2a6ddea9674f6377a6b6c0fadc5b2bf599ce77e5f604d5ac62922b5c1737f1267d417dd23697486337941cf375f0a2f1a07e68a210facd71d2a5a95e808c33722861f69626c4ccd59b793507de73d8f983a83e0925ee9a00e364ff440ff723c9003a84f2913bdba946a388b81eee369e533c9570d34b6eb1cf33b6fba3f4bfe12e17424f8c2345a9cc4e4a1eb4d1a969854c2ef6ae93d79a0f3b17a094d2dd4f0c18e9be0594c2d63543145efcbaa424d08f316bda3a21c64472cb2ec1aaada84321cfe433b81cf1751d3137f1be0ffd6047bf65f64d4d03210a8907bcca6709f8f273597387bb9d40f0c1beead17006078b9dada007078c3c01852bc143120dae91d14d3cbb9fd14c6c7e68f2bbe66b86961db24eda98fb2f39868fe54c5a3e51109ba268f5b3a0dbdf48d3281bb6224911f0f05fa5e9469b073c5d938d44298ceafb9e770af0bc61e0f1c1fb69b2ee47c2618bcddd5d4bab95b4dbb45b2bad166062dc185c4a60f00e0195321cfbc48deac485e33f207f5a3992a3264314967c11f9338ae7e3d64319ab989a80ced524295b8bd266524bc153d14fd2457115f49c4254467f0f6ec51a1501774cd586ce3f62abd5bd4a81712b4bac885d3de25ef6361c9f83bdc0d4805e5f56d61fd703fd7d0e0f1e2d536bee004df14ad36af514431de94d17ec4b6c47c57cc081ea419aa9c6ce14908538e3200245ca89521bdff4ff81f6246e4f595d764cdf3d253258523874f7b91876246269f4dfa501ac4311babb23134069fd327f4276e3087cd3cb26899a0e5af24db4ab49d21d5dce9b0b12595d3862b6e7f0d1bdfd08ee07cfcfc35ffe4263caed2cc768fe92274204548aac407dd4370919871a6e366bfc4e507212ae11d11501411dcf7c81bb106e03c397fb579a3bb54b006eb66cbe5f53068ebf935e18ec6443c9f69c943dae56179e94f30c15ae5e626aebec07ba436d0c7e9fdd71cb0caa59c3c9f6301b3898e08cc82c5d7579f511853f9fa44ff55817b47389077a05ce215ee58aef612993f2c61e4d3c432f738b77ac25fa80c192465550aee13aefa575a3edf95c9e6eb9e90276e0aa53780ca6da1ea0aa84e5402c1b4e3431974e46fbd709816f182ead70aeb49469e2b58e01d59dde1bfacdbbff0799b66c3446fc6d53899f70d540f6b80cbf69a881064c8a1fead5468a57ca92e7e57931472adf58c1c229efae4d00706602baad0b52ea6b747e7c1577c700eb6d72da97fb6bf84bb65359aea8a41866b7a6ca7665c9bbbbf314c85b9d7151ce2305c8f0a46b864a5540c1da95ff8e0f401362aaf26d074e9e7a26fb508606c42a07cba2842995f16e51bff68f34d593b71af294f01c1e986d556616bb41ada05a4e53f96515eaf5fd25cb5c2421bcb6304993b895926757d54a51c4f89f44f5bfc878a154257759c79e2eb2031a928b34e7560741ae40d6ace480caf0073dd6c0ffbeebfc4ba67ab93e538cf9a6e6d0a0e00a6afcf854edc01a513362302cb5f8abb1849b2bfe62e699b6f3eab0bc74efc4af7fbf9c865eaa1dc2bf17d36df14e5bb1baae52b7027df31874a9405b0a529a4ebddcb5fbba991ca030ec87f2d1a8d01b4c5016ff79ebb481b5b2b7b982dd90e618e32b9bc0d3ce8b53866bf0b45fbe0170d79e4ad191552bb6c51f9712a3dfc0f59e87187c4dcdd24074b3be03f6b50c22611791cb1e5b2a7a566585509fa8e1bba8b0de98f93cd379fd0930c4ef27e9b1f3689c7450404038039eafcaaf079d2665e5a0a52f63945bf66d42e7b805488dbaac49f9034d5e6d583c8024f761820c29f58715124f55c805a838c31b1ec34019b0383cc60b25ce777bdcb97ef052605242744e75b24894c8a7bedb7cbfeef984b44f9dc2e24ce432586cdfa72ece230266262783295aca989b7d00af366e237d3b5ec9d13499909347165307d97ee64856c8219e77aa194bceb5cb9ad907a33fc39e49d8252dfc772780a2ab20cd244b4f1ac627460f3db1bd0bb7aa831ad70300975e988f9e5314d1c5b88ca6e992f28510d40fb10436b7b0345f1a7e2820a3cba50fb5c631b60ec325d58827847923bb6ae9feac4861e169f220c00a0549f4cbb20ad14242ad85bfd7b6b03b6c62a498dc6d9e7c0f138029a7a45274206e25a159756e46e82880718e42cc8cd14f890866561de07d9b2825632af1b64029b103792baee39504433f6d3c9b159a5a00b6c1532e39044796c589da13930607018b20beda5a37675273fc563cecc58debdabfa06e771c705dbe162fbba88526091c3bfc36bf3e76f46810da7e1e6474bbf4def662a7e6228a78ef195e02e43ef41021f624776a6f6b5b1e559791c14a033e2d1e2f63dce157f98a8d092e4e2ccb8f3d118a858173367fa37d734ccd50fdbf6381353d92544be5789f4cc784e8f581011d9b52dd51d747917f32f72a9660dca04bc064108643fe5e9802e6427f6ed1e18a8e829271220b125aea21908870128265acd8733ecaf154b70076d5ece9c116a452d05a458b91269d22b6129da33ada9856eaa85060db23ba7d71f775fcf8033f8a509b79d67408d3293cfc25aff6615869db66943ad6f1b8eac4d5a4717c0ba40933ad43c96babed34812f3b3ed26745fc4332a8a80ad8b7de2b8b1eac68ba3b3ddbc3c2723d7f64228787c9e79ccf5789825c496934bd9287c914631df69e33bde2329bb66d5aab11ba094603da8a4ad9d4c47d6dc2545c9bb6f6a241e2bf5e867e0db07fbd0ee5de4f1f9a955fe051c21847b67a4a54b998d3d9bfe8d0cca514bbe15f0eee9b161655e07bc2759197a0bcf8bd90e4a3db6ea335ee4eb9870511ba667ff9be77cb0838daf1feb50d0fa3685399493c0cc93dc1c3fa151584817210de2629d16e641dd0e5aed7f7a918e150b767efb64bdbee8eea8150fc962a34887dadf2637133f2d706044cacc5f999922c8ed3d16b7ea9b6900c00b6f94309daa24a187047536ead593cbc945d795436dd049405f2101de9c4623bca1d00c72e2bfdefdc6fe32c4a9dc37609e321536ff253a7981cb94cdb39d3abdefbb6bdd3b88dd68bd89051642276329e9c1940a137b25a4506e5268f31639d396383102c7785ce202fae247e7fd33df98b9e58ac8425de0f67edbb1932eadb1f2960a4c82a81fed748682e7aabc8e073744ab651bf7cd9b26ee04692f64d906dfe5ebd2ba1f20997de1eb1bc9defc33b1d4b4005964834487f474d898184d2df9ee7a23ba88b3300aa93529c39b79450346405afe770ed57daf65f4ef6c198016f6e564d47f71ad32363395e0ccb452f9bae2ff75402c2b45af9e5ff40dcbda4219413cfd0e1fc58da8ca27af4cc8e3cd4059de599c13bca9c713e82542bebf3887c597ca4277d61291137ad3de9aa1f0b4e7a0e4edc8c5d1fca38e3a7588a5940aea19b8468c4b6e48c2f788f61bbe9b64bcec2bc0c3dbb07b614346af4455fec84ee7ee3f7bef855c1d585cf123d5cfa2600ff7be7c3d1d2aae490db60caf0d63bd5d3787a1b078a9a3679a4ce368e8a7ffc4e343da68f0f674f2ca28dcd1a8f145540e9260a755136fe915426c45d866f0c27d4d2d8bd9879fe77b823802f9311cd3720f3298530c1a3b098d9397e020598843e5111d71f67da2fbb714dbe30da1ca25805d83adabe58dcdd544839a7ed21225fa3a41ea8739b449b0014ae63e896d757741554240b8d2bc43598341c15fc681d398b8e91967d8ca651afa2cab5ce491b71a238873808d839fdf1d059f386f0b0736a0f90ba3dac63cfb0a22e11557003244a3c3e57ebba829cab52c77513c8d73f523e7721540bc670c98701a61937e2e4dc8eacd53359589915fe8ab3f1db223b88f052eff6d84c65158e4f8ebe06f59ad51b87aa3e45e4f9b4b79c692847ba93d6f42e1b9d53b8050b120af0890da661f073c9009f4ddd4d92acdd30fc136e9e862bfc9bec6b6e9c223db463c4bdbdc9f72df0dc60c4bd877eb93986096fe616b7db8ef59c19f7249197e7c1980e964e425062a7479e2a195edd87c1177ee7c23023fdf65c552dfbf5d06aac0474c0978d4c40602caacb3439210b5d2967cb39b2ea0881077789fd3695cad677e93df9c05adc936c6301401c8759a1e8c274a3e7aa61086b8995ebcdbfdf0e4e26efc9d215e57726d1bf48ab4e7fce2d9bec662255c8c0b7d4d95b449dfd7ccced54657bc2a357b2f8a3f08f3ca7b7dedcefaef4e810bb8cc09557c51aae60efc7676801ce6e467f5ae369b75f1a03696d7b46d0dee10c98babfef4f54775ab5593c657708b4219df1f14cc12370049aa13016162c3a255e770c0baf896de30d037951c620576c11906ff0d695b853137be834b5052e341b3ed4c385b479464b3d93f896996000ba1529330805841721df983ad64933f0ff1ce1b665c76f0cf0f3984308b457e85ac6210324dd25557f0b322c5a693d1cd3f8b641ab96e5afa59fa1de248ad59bd3dcde070b2bb0645cf517c7d6d4e84f54f468ec5c278be0176b4015aaa7fba894254e643f66ee26eb20b0c44252f5ca27479b9c81408117993a7830701455bda29b5897df30f018ed249fcc42d48dcb7784c613e0714a0d50bed719990f99bed84eaf5b99480137f9e2cbb959fdcb6fc633b7f4560419252c35e0bec5b88f087c99d609d22d5448a93b7d52807ef19e712945b661c0c9a67a9761ef093890b7c05183c14a516c3ecbcad54701d67a4da1d83f18b0450c7c82a5cdd3d52160e64e3ca0fe12ea9623ef57b9cc045e74a8a28710177c639282aa332d2088a67089bd51c75f1968c0c2719b048ed32efc8d2c975a0aefe784a16cf3017ab9076bbe37897f5414a649b3346aaf129d8d97000612dff59243037a6306eef5994b185cb2aa17df48bff01fe56c7ffc4d8f565b8d63abcf735eabf30520f1c6aa31341d23155adbd7748b04172fda05d0a47a5fbac70eb2075394b234df2d37e86c303a578a1755ff2934d022889aba2a5f31c7b7ccfb0aa28dc214e3ca521e9ae77ead81db8da8f61c0a60b1e89067b677217337195bf4bf662eeb33af9bb2f7eb0249fb0bdb778c94271166b554a56f3f43dd52c1e5f451325855f654f89d819755ded836d74febf9dd62b044d691573953b51a414032ddbfcc511e2d1902e8a10e133f5e6271553a304a6a26c5c2d8cca82518238e3d981b7a2ed16df317892290ef1e7b08198def1807e6f9c3cba2e0d8edd454ba516421423d1279697831d5a79bc5881df6fb54b2f05ce264ef64c73a52835ede784886fa7227d0365246bacef3fb74059e61fc9b865a74acaae27d9f3d9249a1abbd7df02435f73adfbb01858095ce45017faa6f8b951da8375a85e4a1b4b7341941c4aac9aa10c8cee91c48b947aad2c9b8e2a7adb7cd410fd772762c19096eb6dc232e127bceb0a5d20d3dd43eede7ea05bd403d74976877a38c78d28d9ceb367590cea8325e86f97aa2a2c22c388e67eddf15c18d1eeb04f9eb9bee547f57c61e6ac1eb77e9af488410285c3504f3cef3ad052a8dd3bf7fc1c61a0adabf0f2ad713585e612a146ea6b6ca5f0f1aa56ab938a776f8cc573ff84bf4f9b59b70bebe462030084f9bdf3e1bec3fd7680277789f4222d783687721d131c4c6af68c409105a03d97d650bdc7b773e2aed914b1447d03da2e80873fb488ad9d3cbb5dbe05409528f5bfaa80963e6ef69299f5895c1968f2ddb61e976a821584b77b0d0aa9f79911563a9cb707ef9a9b41f01f0e1329c7152d4c597082717f9c687a9cc2b8b1bf97ec40adc8745efed94c3aff397e0a745faa1e24181cacc67c2086b9fd8f79d86ab03f5ad7406a38bdcd877658f8f7fa590084195a1d8006e797e6a88b1a8fbcbab4f074d64681c48030f84603c46b6018aa2db13aec777d958764981cbfcdd7e7a02c62833ce86d7a037ef8da94f55afde18435a549205c230107fdf96ff13852f71f6c36a1a6bacd668676fd14647e8a91d0521e7ad570c2f8410df4cb21680dfe81f0c1ceea53704435afc9b42873e137c34237d89dc1052979ef0e3507feb29acb0b44a9c322aaf2e1e02e1cc0bf4855939c3b957fc2419a9fea59dd5ed74e335041d38837dc689b59f1018da1a4203b3249a9fea563865470b3791edd8c3c9a5da0f88cbb624471e68a1b2cb6a44598de17f7c950c262e0cf8440f2b2627539b9e49b7197037fb59c026b3648d7dad6c48907dee70b915044f18cd12b64d2517f9abfb1c0e5951c5332cabd82587b9d55ce8b41073e7ad2bc83b8ec338f5259592d47fe7847d943736f48c2daabefb779b1eb618f49cc3d6e51c71cf78f47dfeff4c313f206586bc9db968c73267535d2929cb6a97c23ee50ee99ad6b7da4600f72c54d1882df1142cc78b422a0f3cc6fd4f21eeff696991595dc8b9a7bea33115111d05d97a8302efdf774678b13a37f0d4863858abd5d65d4ecab39ca4520a8c2003bc7512f1da7bedc79d930efc98078dfad900d77e475b291b4d252c01cd37afeeaf2323597747a74b3179fcf98fd8c38cfdc097cf45f4edce4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
