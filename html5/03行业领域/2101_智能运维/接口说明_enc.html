<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"04457c03024ccc429c5de697ddcd15cc81c40f1910c899111143729427008f9ded089ec44ce94e23f2c083d1f9cf36b94ac23d6f8db3fce3df595f56e97fab73e0dbc99021b0679a827edc3d9ac0f7d1e98285fb062631a63806c44cc5834912cd44dc30e2ca91decc58da2c11445313997293185f213d205a351f5a47f7fc4910f8a418754efc10c438dad6dfef8b5a2b794550d108a820a9a27732d84f673a69d4931a21f9af090dc95e9fab3b4cd54635eba6236093c8145ef8acf0f304535769d6354847df36b42bedcf9d5866fc52477d5130aaf2983b6b645d0c14ed5f93a317a35568e0ef00dd1be87faa89436d5e2d6131b77770cb269566b3d48e5191d55ad0526fa9e69932056de485040de3d210653bda1c27d7d825dc996be048dba06645f2718b259151eb205bf74627d7772f180000b300868c3693459323c31b063ffa374fdc8e1e1e32cb39f335fb09fa7b1af3a3c3bd704900bc6b3382f4fb8a957dbb95ff7b315d4b761953739a3f6d74c0719abaf0d622c60afaadb6c0cee2f7fa67754a97a8cc7b91d725f71283c9099be0491dc508d09b4c1140e72099b82423d680e4d9e9263ceae261be9f790b94a988edfdb2acd320791a292d7281b5bdd32cc545dead38ca0047f8f30df132e84cfc52e82e14709b6f96d50f6c81a0ad4ddd6b0ea2f5baa266623dc6d8bdf26ed1299a2151f7e0e71743a5ca73547e6b0edcb68a2c16e1c25870f284697ec75b82f18fb4bfa5a039c7f031a109c54d39b7cc1f605700f566751ce4a54d5cb056677998a9340665fbbd7c2091b79ca4b8b329dcffe26d3d6e45f12d79a3cbc5cd1a9cea0b0c1d78c885684537e54cf9a5d2b21177f676753801bbd71779b0248dd22ff917c1993d561ee116c8db8b7737fc2fe7a1eb8d2a4ef9dc166826fda0a9cdc24d161dd38a1d89b125d16f9a7bd93b985e8cc8611390e141eaf4fa4997a801d5b3edbac991b0315af5e0a89262dff3f67da6344d1e09bad1ee90c0911196beabb98e57626a91d522871e9995cc266815c70d314bd948b7c08565932f6c5a2325cb115657488fd7b7f0c12307679c1e4b29d225b3c0750a504e59b2d65891ea63a02271847395d05b0af41723a08d46bfaf217d7fc697eb034fc42aacba8b0316002805bc6919d8609f5047ff7abde0af4b6147893913ba0365b0eb091b2f139b6e13f641bfaa0c61539ba2d7ff02e0714bcd4c16648a979f0a0aa20b79255148797704b726de78d47c0de8c548b55873216c620f906ef8aca67358d9a34e2b0a5fdfbe905aaa6a3f38691cd0e570f6ac0c0095ccd5a0c26654b8be9b080487d34134017b570291da81c04883a6775fc5374205668a111b8ed9a174f5309b12afedc02c458abcc6de18ebaec0f198595356a6544c2fe6371417dc94d2f84d1a23b2ee82100cdeecb605195e43f1beddcc4745ed157a3d791ed03bf04532630a68c5b4cc0e0be739d5e823dec9e2eb4284f08966801f1b3b447cbfcd63284ac9bdb7a00ee076917e2e450000ac0c0e2a302f4f96c9d86ae9d397551f7ac17f513b7c2f43aaafc6eab16ed4e1d8fc1e46a200dd407149e0caf04c7860e84d7c2be0724451f44c84e5395c818c0453d3a29a78a532b9b9b6b8926687e5015d3c84c1ffcfee322a79825d0b951e9aa60783fe8106de093691a1e50174dc3fc50e0e1b16e20b7fce02720c3332c6e75a24f5e30d2e7c6c0c58de13cb16c1fd5bf4495041684ee5529211a5e9e8895938948150b07deb020059298b16bf9f5c5ca075cefa67250ebef2267055e6b59d37481a54e7260b52d014647656beee697937554ad0e325c2a7d3cce49f2d3bc38209b2fde99b29e948b0b033c084851baf9896dce81e9477b94f0c1d1bd29657622b5b4e665b142ea435d53adec7ff055cffcc6ba7a1989393716745f0592e36d00d76f42e3911adf91e172f74a8c44ec455491f61567dcc101fb38a62fc7910c36819abeccf9172caa4ba498c8bd55e11393357a65eb486b5d7071a9bf29ec343faf416fc319cfa7bf4690bc50f5b7f31201e8f1fafe55638bf2b08a859a091def98d45e3491db7e723883732fc5b5463f007f26458be1dd39a42d81fb2be6d2bdafe5d33cc7f97d717def7790471b99e334a9eb554aafee6ca4257819b34842a4328072ac6800160c388dc7a491d7528e3d77c047f1f4ca569191c341463b912356ef7b8eaf81fc9f30f6e07392a6ad55bb154fc71b7a468533fc5471a19f19ff265e452681e92d40eeac141b082ab0edbafddbbe898a2e91e1c62ce409b0960eb1fa8665eabedc8208dc6999c53eb095fada0bd493029aa40d088e4606335aa156acb4698b7619e51d158371e3148d372c2a15c2e5d24ae58f4c900c7ff73fdef0370a04f97c6cfb5ce75bb103a2cc8e28206734c026b0fe69367cf0339541d8bc46b40fe60d52f32e976b01baf480f8e7f2d4b5c48c61a0396177cdbd1178414dbaae5f9ff90705e6d1146ff57208839496a791c9c19e8847828b7dc357a898e8524b255a4d68a5d534a339b16b544177580950d2f6c0d9cd1aac8ddfc8b63b9296f65aa655ee158b1ddbd4fe15edc8e2965bce3e6b9e9cc741853e4aa5c521c23db8d4a077eac8527aa2a158886f6497a5c5639e3e97f367281cd7eb020838cfc5e12a8df50ddd732a7be0be12de557eef7474e59330f08fa576920cffd783270c3cc1b2b2caf9fe36fbebd66caaeb5dcc7440a05f5996bc24f6c97411352e99d1bd61754750cc8fff59498aa2ecfdc672f014ac0de69fcf81380c0ae09095504da6bb3ea1780965ce0a799cbaedecdfd3a7b4f5d1a48ff475b76e5542cefa4fc31653f1ae70af10bfab711720c61beb5f66fedc6ed52f997c3e3ea240e0096d4d1d89e1b5ea9a76bd02441b3699d64a2661b6cddf6974a3bf20d1193aae4c29c8d402ec2e9d20d83b75e75a111721ca2cf14ed215f3098c1249b3ace4f7b65777ecadb2856abd1be81319a713b160677d235aab5eec33f6973bf0496411a0d17698b1b92ead947c62f367bb78485c50710ab9868ce50b5d1f4f4391fabe9967bb6277c77a4fd7cdb75d6b4dabf8083a6c8bc5f4663302128d1d1104a9ea8c92855a48ea131730078e3efd1b4be3ed7da4f4febc3639aa198143f0514931e4d86921f7ef1e2d4530249258d381a36ddc77f8d49513f98b2ca705b8b9ea57b76f8b035dcc889547b06ad20ec4314a18bf6323a6c0364dbe56fb912ab78397c57791b75d379a0a2c096a7b101990d3c3e143d110c1a034ddbdcdd0c4f4e119ea9828771aa60d627c8805295580b4dda0570b1bb1147213dad2dedcff6d710b96847c12cb6bfc0a3a111d1e9df0dfd06ce89566688554dc4e0076a564fddfec7aa123bb82b6914d258ef0e53345ae92fd73a48a954fa126a048b9f779cb2df0140ce7ead65598826bff3122359cb5a28b9e79500e094a846d5b62f2821b33062ba7bc46f3a3485ef9cc0efd0878eca0a1098c620a9b400823708b3ff3b49973bb2a2e69ae92af8a92d5028d7f834a35a1286b23736a4b537184af80ef7bf2377266f25b09c64669d01ae526c4993cb70a57fddd6174379d4ba5caca9dd4535c8b73adec01fd56320656e7c5d5d6384f7a12073361d7a17a0338c10b2ba6581685aeceb458984017e8a97115a0c8e060e27c793feff8101d36f5555dc1cd66e29e1ea92f90f7d96b2892d509cb7e9435aa2629bbfbdced4aff67c4e663ec191d5c612cd524054ae8fa7cb1aea75614a453f99f05fde2c4034cb9acf020ccc8d74dd1526b8bebd325665297639cdbcbd656d109fb94eac8c61b2ab602d3add183f135d2d838d1a03ebccdf587f26ae6d7c5a94e5dad3781e93952f69221ea0165aed8201be9a5036fc635d8492a57e951f55d8276ae0058074bf3dbd9eb4d44a124e5c00367d0c2ca3c42d872dc98ff17211ec1b023014a7e104af503fc1d5ae797b687d8800722df6aa64ad62f545e2ba925c647a66f7fffb77d6698a62557cc69e81835c637d0419759c2d5898ccab9cff5770fe6322ed657e2977fc21aa92a309f57c6b069e8649fe9b079e92ca4246ec6773bf7f0fc9c87977e46dc463f2bf406cbeb8ba72d1539a5730723f7205a38dc04fa2aa95688f050ceaf68727fbc0e19953d11114896c609388441d42d71d459988b74d293952821903933fe9ddf2b21719bde3b6590ce17cd2fc5f7bdd90c3e8779ffdb8e6072456d6585c210dafcf9aa527e111ff4802f01e384e4d51ec5fb3118ed6951abf7882d915b5af9fc12fc692b9e79063d6d6e4435a6777594d30ce97d3f49f3d4e0d7a262e3d0f5f8c487b6487bdd160712e5b04e85cad2b57bd3c6727d87ac03e8d8012abe9bb5e984f52c6e6a0b5289f6b0e75d565f768d810aa9d85ccdca8f3824f513f4d3c4415b232480106e9b91d2a00794e16162e0f3b16284a66c994b02ce4a7d0519f91009fe6da63a11e3448bef391082edee223b90d754522642b5cccf3b10083a83c4c7f433af4efb0f28d5da038034e3f163c12ede09f37e64cd46819b107607db72470a44be5a41452b8d50e0ec65f048c59f2ad8c92c366173ebd161c0d8d90ef62134f0f65062018af6263e3181a76245c821ebc7927b3c2b081b3865924acda11e9a7d7f20f6da37956822a3f1dfd415978fcb4bb011533e318823b7fb1d47f2095694b21f28950f2fcda7feeb14c1a33b12adaf1ed46e031240807f6999b8ede574ec6b8c0c49d0e7b314c85efae024b5fed4233ceea7fe6e90204aad80b5e8f26933734daacde19081f736b685b7ee4470144c92b6ab2e201465a79081875ceba7c20d7d8baea32965f80d7b0a43d83c146d925f97f245509d4bcab642b3cb6e338e85bb0db29e4d445f32e3a2bc6dce2b150a8454ceb517180dc728bb23a11abc87777d3aab24be0492a0d6600267dd10730061fdcbcef9dd70ff5790bbc09e3091fb7802c882616e1f4eb0e7c177e76204edec91e86b1cbce49f7ed1c270a5546ecdca652a3cfc64589d1a50b58e8ed0d3b724e5549ddfcaa6834ba475c45bbb05ca28a25236e14f060a4e966be465a300a4489526e48beccd79c85f7048a2e812d07e98942e7e0b94c7d96b58159f96e4e67f5410c225513c82d2a3e5fefb18263adea7e2fd2683fe4a0978473c1f4cef940b07ebe2f15a14b3f56dcf0c986ec7252fbba1d5be97e87180ff94d3681588ebb46acd1e1a9de427e4ad6fcacde55fca995b330aa612ea0ef74ebb1d9562229490206852e35306ccc0e872333a0e6ae869a9a95a8ec3f4cd6b52a7b6530d5661d18e98d5ab79d8054ba4ae925c90ae244f056c048861ba804771c328c63466f6403f1646f7ad65bbeecb4603f2a3c9f13c030a0b6893efb36c0f565b218fb84429ab51c2d1209660922c1e5c143f36d1b0a1e31bfb563403e307a9380075a5e8fe48f16ac4a9249613299c726aeaa5daf2a0f56fbeb54119b382b42123a6b8dbfaca331eb21e115f7d0a822bddccabf57d4fce4be9f08c237f369e47df0f9b69456aca8dae08ed7072e2f93a5171fa489719d5798ffa50a1d3e3a38cd2b223596e5949c73a393bcbc1e10c4de15565411aa42085048b66a809a5b914b59de623767930cf454aff7fb629028ceb59450b7eb890e4b89069c7f7e2d79d76c894a3b382b1197472b257ccee679508ff2513d86df7fa166bd1d4e49f5927c52a33a340b9b38cf5c12a223a61224cb8d5e9ef8725c617041326fc99cf5a6b8a9cae155023838c47b88f9871b20d444ebcb529510bfc5280cb61a877c62a4e2b264925b37df488b0c88533e68c7162181766bffd6021cba26c7273aefa76c8be219cc2ef6eab86c5ff2a9fcff909f83030a9e8b5dd6f64f977caa9d0a6b12a34fbe0558c9161b44b26d192f00a39fb56a89f3616247c629c3aab570bb8d16408c56f4e0f6a8e8168d9aa621cfeb2542395a4362bc16590c4563b2cd4fdfbe7709fdb26aad84e3ff83ea43e89948433df886734e8fca119d896346f34180dbacf3308aefc7cb81dad5f5c2b9c5c3b6ff32a4da986325a1ce16a76eca6a60c9ee37d7f01ec24c520f7530ff721b502ab900c7f3e69b4d83acf2766983a0fe6e25c200a05267e85712e80a986b3df4b5320bd76ddb89a67088159f5e93bec3de775c9631b5e0a09a0d878e59eca1d9a33dfb23f944286e93dbeec86915daf85f7bf7aa688a37fab484ff21498cac78b301ca651798cffa43983284fab98f530b7069053cc5bc8c4239a60c3d36a68b755ee633c25a6238294712c93895a8cadf8cda65e9b3edd9eb897ed0c6740833dac6e43fc76c669ef5f0e995732f921778819121af76a8c9d8a0dcc6698d1f08ebe63da140f0ea04735723b2f7c1d8c53dbd1192a196ba7a59000016009f4833bf5db3b9cf5e398a810a3e3d459acad31c1a99300d0e7784ca182208358d3e50119a484fdbfa8f679b1bc8d91c78328249a3012960da2a12e778b7e45b988c0c1a6f6498776a9147782b1c37ae5e703ed64650e90ed28e4f02b7e6e892b1f21a3465887ce297a315d34114be3eee961ac2ad06371c4893a787f5be629d1c9a06ddbbd48f2a5febc5dc2ea38c27af6e1d673d80113149a0804d9880aed1882c1dbeac5c36147dd91c30f8ac92c1096180a4d07276124d5ff91db1ef9dde368ede601d5dcacd483222bcbef192cb377745b50b3d059a43734b9cabca37011ce5323eee49d1b3babb08aa21a9a9b8546e20af600cb56a2fb22066ac31bfe37c6cc34c7cd4b97c011f74cde0f1e2238a584510114c739af2c62e3a3915bf5494a6260807cf6cb9c42df7719007c844e449046aa7315490023f1b1985a2422fdcff1cc6d9b4e837d919e768af9a747d996f08d2e6ece0a8c55eccce92a2f7864de89679de1cda256bb31813430744aa56c8364f1ebabe9500b0baef9f309ae7721fdabf732e3aea7eee3cb8663fea7d8e07651703d2023d54ba0bc5f1028132a649f57ec60490de2e3227516d8a34925a352e2660164929367007ce748017a1591768f84c6eeaae8a53512f631ff979a076b0acaf3557a69ae21de13b4eed653336b8be8088b20f1e8816752b6c18368ca1245bf4faf75e1e667213542854278cf92288f23efbef8379012e25404f6286ed4b2f551719dde3d0a4e9e302281d79dca367b067137e5d24923431fd9544ed7e66d4e7c3042ebf1d2bc94bc58fc63128ef5ee1d5a343e1ef0c852e6d659949520a8361a05b37b51ed66bcc65e34e8a6ef34b87dd78e40574161e53c7d7b1c287e9ac3a57a81f3c57dc658d32ed14fd419c12c1ae65c20b89501046b27c829ae071586c49a79c8c53141efd7508a30432b4b623ab4f890cbee8240e21dc28db624e0ae9eab3397c5a6a8ab06808e96b041272a6b55919454b9c6f88536b5a45dbfcb2e963dd3aaf011b7e0cc5e59bf6dd0227ae54ba9e6c6c93aff96cbb174753be84ab0ce89d8f83238fd37bbe25dee97b772ff9905928996ea2d627816041a63bea33aff8662ad6927f78ce45e2b17e21d4fe8655dd2525731a678d90d5382f18d8fd47fcc028b52b040e79f01ccb84e98bf2733fc2da2c4ef60062e0ba47ed625d52f42325dde3c7f43ba3461846a68d39abb5acd3daf54717b721589a2a5df954ae28d21819fa3bfb719d5a799cffe3ba5431749d16b7c8db3a7566e72e4f73e86edd389ea5cf44db46e45f36ce3058267bd453ce8dd5bb5fa203f88bd09131d28cb0ab142fbe390df88f378406b58f1ac086b0339924da17620cbb33d135266109dfa9474f044cafbd97182dd924f600f6b311eb8a66da3d10d7b112eb6274364d228d654908314f7d32c1f3da77b90668de586a4dabe48c79fca94b28e2f7140e7b36c407981c1250fee62e1d5f7e05a67e2d6945f292d43679f797fc9382321df1cebe7130f8e6be88b5f7fc79d59f49e81419cadad1a9ad9caa8899ac067fbf99118f62c2529a1514c8ff22f3208a96269792f03054390c96926d2851ce76bd227d3ca8cd186e15b8c50ad0bb434746ff888c0b9f752a95a383d900b47277d8d7198b8d15f62a16207c7fae1fbc8b912013eaca08efed37b4fc0f7e61b90762f721027eb41eae5d2caae42e7f983254a098e31fb86d7619b017597bc06532d3c59f1b9d4b5155b2b0bf96057b00aabd5f7721f6e5ebb6ad2bcb7b0a9b6bf7ca44cdef28d9d8493aa3460a4407261a7f36a10e3a8877f5971d41d66a69075b89ebcd0f512cf06fb743560ef89849a6caeb6f36321131337ae8c38959bd43682b9d1b35fcd3b024ba55b930bfdc30ff0ef21253e2a273d327fcb0ecc37100be1da463ed50d3d87ed2f2b5a6a8fb743963c24f00c157c5addb87dc453bd5a8e2c12531905dbb9db58696d86b6b95e7a0cdee5fb83e0e4cfccd66c4a8c93d7cab6b579fccbc049bab215e85a463e669e11063e43868a0de32b84cd50435692aaf934ba4449d5490eb7142fa3de33df27b165e0813f8f87650a91f58c2ca5d02356ed5f1ba799127a3671b78df382b91dfb2a83bbebe5bdd1c48fb9d9e6f0f2981a97624c7863b79f489d951522d05c05cd27cc9b7d384a17251ae2031f4958abfbc6ad2c08d5503bf95ef094c36df3e46ee62bc4914d3b80f4aac9086d046bf6ece8f32bcd054edfd2f3f736f6970178b8e92de07ab603d7ba9426bd5bb5aec8496e8b57a8c4751df77db9254820346656d5785917afe5b2a8aa813023e16829f80f65f970511cf62f6486c8816dac4472345b3b2bf1a19de70369c7a91c9908a878bf77b78b8fac1d6aa97b96b3f5ea15a69f43dac5f1dbaa9d60c810d20baf5eb09abf13d9f2268b6a034d5ebdc5ba4391cfc64f8cd5632b3750c6f79e01dae5f9fa4be77befcd43910bcce447b808a30a6c26935a2f497c06eece5d590fa3757687d33dd17df42b35d91843058228d809d5f17b7ba701f6fee19fcbe79fc6065b610e5a1b1068cc72ee2de77d2131d8678f2764efc4b1f575a76cda9e42870ea5e8645544fa3d61f342bcdce85731b14c90b2f02fe0c67aa69169281513617a79b8d9740f1c5136aa49dc34fd39b972db2cd0832202fd626d36b380284ac07698787aee687c71c7235c4406e620b877425f0c09e7aff0b8028c3eb04c90b08c3ffce8859af5dab2ca2204ca2cf57f9a814e168c8c2ad3bfd32343365b49e0fb7aa197f51aa2b191c9082d898b9f2c1aa1d470f3076c3d7bfb845d9a9547b35cadfa798bac2a768682695b41ab0666ef5011e51ab29a27f25640df3d9a54e60999b7ad2082248c660d6a65a6893aaf1442f03c31218e66775baac62c983825f58632248bdef85d92691d439535aad2de173e5dd6adaea52f85b86550bac308afd889eb935f124f5e21f120ee1f1e034edf2ecebe4c9b7361b117cb4400a614398c545c8bf723b317bca0fda93a0a0419e80044ae7e6a2654a9d5eaf53933d53793a9fc90f9bf67e771cb40697e595cf11f467417dc90ed914dacc6267c1d915dac10ea8d89094e48b5426a9d8f5d7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
