<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"95bea8a2b1faaa136a2f6fe81880de280cfd488466a3e670974312c6e19bca3c187352a8ea6730ae285984e5ef84672311a1a204b20f10e0d70cf964163ca1c8429f46936a3a4816cb23cf18fe9e22ae00fa68f340b0f6b3b482f317a8c82fff2dec3d92ba245cad5a68a1978a6c101d7b32abe2054d8989ef43b8594c211825626850de557f066d12f9cb5c25f64b0f9288018bfcfa930982be7f498f1019df2498240203eef7d4af2e56b931585991baee67839758f08012b88c6e2665538178330f7ca0d165898024e8daceeb28a62d84aae9fe4e794274088af15bd11ed7cc3070a40c0fbe613e497fedc3bb598aea4222af1b10efd8ee95b345502da4b355417ec482161b9aaaba5a11b62a721ede83d9cc9e5a5cddc6c065d45087cd002c14bbda36aaa7147e854c61abd8d8433103131b3df90c6aeb188fe0a3af9a2669d91b7b4de9496aa3f0aabeb5bf373f0b1426adad226c1499c2baed16a9959bc04a9a80aa860fc2a62ccd6bec182266a94e84ae297b10a1857f1dc81791933044ca81b4d2be64d7d178a59e05a44e59f12904af7d96a69a0cafb722dce6c63934be2126ec1ecf368a73ad0169562e339f2e139111733892df36c29fd677cad5abc09c264dd246358dfae4ef3fda4371b0425d10685839b1e56428147adb3984c52d4691ad452878018d49ba2238bdc56e7e32ab4d2bf18ad5fb12c53b5e82001809c76c96ba983ecc9a538cff92f77e456145701cfcb820ddf2c03f3cccdf392aa2fd41fa54014e757845a15eea2c925d1dd47652b8c331d38497fb03d83bd1964c7550ddfe542b60ecc11a4efa9ddb6e96a3a5f44f08b5b4115590bede9492544fad7b33cac3652e50144c1dd982f1ef87a5622aee3c1f5f2ebb3faf5abdb224967464dca9e7131667cc0268b27c65b5ff66fe3c21f89b659fd72f6d83aafd971bc08d89a627205db15179cb7e38a890d180868d03fc25cc87fb489899f35dbdcdface2d35d17d68e3f3ba92a8d7136b9e76815207959a06d19376ec9600b7894e1c1dce8d9f97b36ca542003d11c7d15ac19d54565b0a3f0c363189dd1ccdb44449639ad741b01582b6bd60133ba47f11feac93cfe474e25cc5e80db62e41110a69f43c792e2dfcc6b6f91d53f8d1bf4877a7904142e771c25bad7e433a6b912651b7626a5ad43b78219b325ba2412e7d3fc0513cc5ce072249453448cda54cccbc09d663035bf34ae1d05809b30ce04d0a8ce6b934eda175935050ea0ae76bff40ed0d35ed9079d5fc735efb488f688575df83aee2daa86d888732b155bb6c0b5773612c9afbe32967c3f19c9657a7baa67e45bb9a6b00f55d86b7af798773d72fedc5d947cbed0549c898d42f4813144289a10eb41b9759595d5f9b1d8f8036843da9e8814e327fa41cf4bff059637b4a63f840d3cec9fff1132304252a02e4792c7e0110399b027b00234669721dd6c867ee119c12e97ed610025a2b19ec18e358bcd0c00e09c357afd2e525be2c1c26695ca995f5550b22d086e53cf9ebbb56eea7cc7ad4ca691570059caa2139136d4809115145acb4d2db9ea5d27ba576f5e039514b633672e743200d95b34534d0f8608388b6d73a5b4c86190396affadb28486824529c5a677a374dd590e6cdb78fbdddc138c70ef2f32776b928b9eae01399bcc1fed2a5643eb013740c97c8bba7a1416dca84509fc4035dcd85a9f3b3d369af8b0549a9b19b4351bcdbda38d5b769f7a5b4066912191982e719529f33f7f42ae382554605c0ae50d344732633beeb18226732e8d69f41b10db0db03bbf9ca19013a21132b0eb6a859baf19739443baaa3df9aa45d07a21a824fa16374ad596a65552e92be1a9d83e63d152036e350ea7382ef9812d99c55046cf0d9aaadbc956d6da6bcb4a7f27c216e6dcf653c6c7773f435c3f4e8004fefc81ddfdb9fa3e3a8157006fd9e8b0bffb2d6255649e98a3e55b646b64dd32ad1fd5e100adb3918c79caa8e9bdb3837a02eaf7d794b473ec39647a89f091f1698811e879822834203017710b79eef8e9bcf91185ba2d01fc3b2bf48ac4147b7c22208c8f5db2ddc7edafa092cd705a6cd87ec6259f94a7f9903716b9f26c69ece574dbc67602f0420ea0088b4ee84abc0ad27a2d300e6ed498d4bfc39a38a8e53554abe2bef54610525e15a5fa9fcae2eaacbdc0fad762bf89daf1fa2b023c1a5ea811c21c31f059ab3e51aa6b2dedf11ed207b07ba472dc4571afc19c96aec56c58a64b2a9a3e907d9417ac1d77ed0131361d94dc15ca9bbf00cff32ec5a5984026364fea46ae0161b771301f6c201957eb613f0530e207f806835b1e2761c92ecd5917a69bfa62929a9f0760a34b3914152a6a791683891a91c128e6e6c33d052c34c208c021fc4d91f95098538a335cb5fb052220ee9e1288f2e51ee3b9dc2d734ebce0d3c17106e643ec1b985fcf49f31a0903d74a0057658bca1b2f82a9e684cecc0952342d5e6318973128541d961b2e484c346650a167a4db5c673334cd5c913a13dc137ee76531fef599daf286e3f116b9d800a50827d33bdd59e71c4bdc7c7b330b1b03f304d5766356104a6b9527313b962ecb11b2457633c086b84b5d792be1f28d91564a3272db8cefd99aeea2248d7384d71cdcb65df431853b8dbc929d657ee92915ebb34e9c05bccafd98dbabc8c1e5f740bba90c2de7c14fe1302d14151be342a84a7d921adeb107cffcf01f63cab37d9444593be63043350e811aac041fea41a08a6a498fa1cc1c07168c01434c434e6f3336d2b19d06fca97cba4ecd8d9019b0dd8946f7c647d4f23e6795f8b87d89702aa20a6b5b2782257f2067398735210aead9828282e4e0e699b60bec62e2de74d043829e5c3b825461118f95b46c2de6d1c419b82072b75f493e267530133a88d590535e839436b3d182a6fed2d23b6c4e69a9c0c590e19b58b8228619b90af5c8e4f157573cf02ab72a0dd141edb0887928361c769790a47f93c9523481bfa079990b8a2b766aad09ff6057e4221fda82f9ed0459c76676d61e3254c9fe0f9c2a57572188d1b440c1417125d18d5907e351d6a7c96c4d34faa2976701f9c165b62a3f731fbbd5ae6e1d5a4a25cbdb81659101c8b16dd785f1f3b3831e9a9cb6fb529aafd2023dca3f1b735d5357be782cb0c3a4914f700830a6cce5857340db20b35a7c8226c3fdfd86df91f2bd5295683406df41bd33d5aecf1360dc1829ff15ab8718586e92938d5662aa050ac1122b3c2c8d3eeeb29afdd3a7c247be3352b157925604e15df3149f7c95425ba60aeb71353b941db9ea88f86ff4dfb3c818044ba32091f208c48930ebf75139d31188dc5f885443908f43ed13a2ce1720a78c2bf88e801498d44b14915304c13c0e79f7ef39e5e082b0c490da55451793fcc416e42bcce60411a0d2546ef2946eac57de74b55bd8c4ce99afd5dfa2f7e98a16e2a5d2c5ae560c9d24dbdd2030d909d94ac54868abfdbc1a82ef845856c608150c495362b516881b510aaa9e7a6a1b46eb0b1d1106a96b7e42e85b2357d362191659daa0a641ad27ea13f3b6681c6823114c6511c736cbfedf471b2ec1cc6f1747901c465ebdd5e8b15769f83ef9ed5727f1fe122b98d6a1cf512b890e897c1dd0e1ab5d4b46cdf03b44b3c3062d6138c2aa491b8a10e33a03537ec9e2199003ef944a87045a1ccd5c4c5bf319f2ab0852c9b581a57ac08ebc54ddd2c6abd1008253a1d58c0b686192a842c4b667b2800693e895c532814b5919ba7342a317f1a6b7fc726f6a3700a69edb04637dc24cf84100386497f6fac3382fc5017f0e9d735849d4c0544ea7dd424e9a12c64b9ace152bcf484832f4a8c0e42db6497e12249dba067765061aed7861aa60a6748b54d74264c34726f40aab8df1852ffa4c72dc89a814d6aace7761a9505f4018c0098c95da98c5fee233d5d9b251568c72f4d544a715b2e0cf3e80d7e0073a6eaa010d19c40d12fe6bf81636fed9dfcaf165785d4322ebc62603a2ba57c8cd83590cd0c2d3318d9f2e3101178dfdcab281fded6d8e175d71cfff018aa6904ce9e57fc03bcf935a56447214f339894bc52d4b4fb7dd75b3e15561b8f32f69ee928465cd2b47b20d72d1395a422e4814dbe2907aec9973d7bffff35c8680864ab10bdb3fc7b752e0bdf93fb75f30b778ad3a299557fdb11756ff53d1df40cd314402c13337247954361a168285b79060954731faca0c68d7d22484e0d4109fc88aba9662d697027418a3b44329cfe9bd4935e9ba1a6f928c1e69d5377bd01122b683aff2b456e0262b7b0b4d865317c02f4275912d12d05d3b1532d0b8c8b0ca3ae2541d1fa08f1cf4d7a6f686a88966f9a55e8c3412bb09c8c524eef585070741d421b56d6da8fd03d7e6cc7574881c0df7a5bbff4c32b73145e0d494bc4eaa53509e5ec973e02b122c46dfb9ef23b38f17759195cddd02bf886e168e983e72020ee5172a36415a44e9f56c5221729d73a6fc0b0b28e162ab059c5c61ec6fa80f19d9ad0f61a99bb7e67709088b775bc6b02e0e1947c40bb3d5cd176d60dab235ec35e5945a098de790dd054b3ea9249faf2f8560b8485fe36aea61d89f43e6cd345503de5ffeccb6d3330611885624e76cc1233e1e405ae43ea90a6e66262398a3097fc6b441eab7636812be2b118733b49a4378f81241188909e5dec2ca545b680553f45529442ddefa6b927253f60690685399c0894284604f86c3de5904f298ad95e2ecd05aa6afb4473b0ab05ffd282e0977af742737511268cba6483ebbc0b21ded771fc428be29b0e1dbb1a52dcf65288b2483da80d566d55676b4edc9e2627a47347ba91ebc406b6a9e5b7810c19cf10944e7155d89ba416aed647375da26a27975ee6f034bd5aaee0526390a4310b74a2dcbcd0bfbd3bc48de77f913a2c60db9c71260b15ba542247467854953c27548685f73c9a277f476f8737a0a305f70aa84746eaeb7c67e99f6275046d0402725d6bb25c3823b8c3ce07d4ea7a113c59132e54672bf1fe45422bf1a75744456c1e47249261d7a0e0494602ad200c0bc4ece8d4817a1404deb6df3bc475680246e775d837694d1986b225ee87ced040b88eb6357e59c20f1c47a53cccb243d068d63eecd2c73c412d640d7d506bbaf6fb8377aca84419d45ef8f52aadb3ad9ae23d9bcdb4bae95b2dc4e1bb8fc95df7ba07ada64dfbb3b46b29fd8dd8a8f8efd5722eb64c202f40ca416dc43dba2e6087ba7431dcb49da191d5cb80f59d515951471597267b9dd196ec22a6521b5560f2d3a8146574f3951d87f38a0d90c9d282ca4ed469b678cec0a401ade67fa8aea223d9c4a2090d16285d72f57836c7590a4c0300b94418a9183deba6a6c74d2b3b2298a119370e3561f4fb1302d5f08608327315c64bd63e659126120fde74977ab979418d04f5d4ce9d4a14c128dafed735bdc2c67b8d5e561282388625076713b7df5218dbd13932787704e070414593be2a33496f6c456b1b6c2fbf306bc64559e84611bfc13f3c4424ccea6e414b0042d439239865df5f1d1c07ce236f52029e046f12d8d61eecc38a7d283d954642696cf02f1f54edd94e17441a081a67df7790e7e95aca64d1c399edc6eb215cc7c67b8b48439e73b4ceb773362af0b2770b9d377c46d24e607821652892b5f1ffa8a550111e6eafee1cad8e915012d44732e63991937b402c45a135430895582069484dce61b492d8df9680f3ae7d0f0506b63b10abdfea66ec49928b2adf6a151966502316bec68ee987ee34e7d55558906d6e4bbc2846f573c74245f5e8c06c8a5cd86c26335aaff4f8d95b3d870c575b5c4e214ffe57cac5522b3db9b985758b4b7b2bc5284c5db5572ef595bf1bfd2effd68e6adc779a26d0c27a9d446b20977415398f3602003b87f27e9ddd6ec225fd6f91be1ed229145ae33093a17ad26311adad250890d99efea1e393672375b33193e727c13b516baa5f6b38460746692a183ba040d4b0ddb366e20cbe13a3eec98134016f2c08bc091157e047b9241a028736fc2b3f002722b4339c02ca83bbef92d50f42dd3c3727ee517bdc11c3235fd8957c75c0cbde98c05ac2cfb0029d4188d9d22af619bbf926103ca7833df119ef5ba7d63eb018a64bf36f5304c3809f586f554afba2670437c06aa5b32c57f5f6a75c54bb6f162a24bc67ef196b8d05011cc7aad750440bc5b83869333966b19f233930d760f8990cd231e76c1e209ea4c94f095013e97b9cb88ba3219c4e67a40077a25b519810d78ca86dbdf254317808dcb4c9632876b3dbf6a383e48e0eb63bf7bc56479610365c157fd97f4245d1c1e9c4b61d797937bf55cf3e9aa5097615ea8461b8ba056d08aeff50d6dbc1117616fceff9fc9c0af3b39f3742787514a2623bc47e7c55c6ec1500503aec856c020a0f9b90d1d9a706a2ba57c8e49bbb6910024937edc1153ffeda2e088b23a4d08bbd996062df70ed1b8f70e34635b1a7706c2486e5d46fe7d9b727fb08e439f562a811de0094a4082aec23be186c7e8fef954494e050e7c981527bb62dd9ad98b0c65229bea94c93f8826b14ea6ad17563876069201d345cfa4f3fa2af49bc273b72710f6a3edf7a62470d0ba937ab52cbf8517837809bb549d1e951a5a48e83d2d126003089432a2ef6964f970cb440d0ba56192602f6ec029c99dbaafef61c1a8d30bea758e2204d03b47769b6532e47d666c758c5bb98c8f11cc65af606659baad0e8c421d00cf4982167613bd2b394bff744c475ec5d9768991faeffe842344f90ecd0e311b1f132d7c764c9bd4bd1cc789b3ba1baaf43dcc88dc9715767c9d5c9e776073f5d907a8e5e2ec98f048da7292677a675b4f3291fbc0211e39fea5d39665fe65d1c2ecb772fcb6dd7359e01980279c39d654d5e50c2b5403765dd19c08d7885466aa8a077afb0f1ffd15f6f8c48abedf15305b2040c9e37351531f95fbfa12e19706e8591cde039aaa62d80e0a9a2ff02e1e7693973b0b702193653f0effe59590eef33ed4af317f97d76c084d5488910a14731dc8a990e300d61c9dcf670b2b647ec725d6802d735812ccb261db6995cee9cbdacec98b5e0a95f1d08994796df66d8eea9fb6ecc5cd4f0704429c75057e0328ae31ff49213aebc8401ae9fd74ab385acc12b9f51d99100030762e2d9a5dfce91f0571f1a263a081d33b706aedf12f183a1b085242e816283e778dcb38478d9e513bf071ef2f63f4e7f127d82d2cbaaa1cbdca8268886b65fa803eb029212ebd64fdf138972b7cd96a7d529c395c1c5a1c21817f2bae549683475a67c01fd4d7a6fa24605597901d86b2f5b9f0f4f9d15d481871b2dbe83750f552c37313ae98266d46b4633163e12a21cd8bedd8f6e5e7197712df0c3e506f7a12fd010b84d04067006b914c4271b2afac02602ce2d9c29b8c2d62e3e27bef111d609902a080e44f359d97abb5e00b5724cd0bb650fccb82fd81a8eed299ecc463f97fd7e989b9f64457f2f27cef4c1b81e476e5a2de073817016a459b7aa78b4d62765fbd602212bcf5846960923d968f5a7f577947d4eb5aa8215b36541d116abdfde8074fa5df88e5a7a2a9db9988029e56fee0d905a6160b6ba466187728a7d4f5adb1e3cd3734070cb06ac62bace8079ae66312e20e553836d2dea569790394f3322f0968955918f5737596d1b460040f95d79f25cf60292b7c19f6d29a0c8a35a8304859edb80fe0f52d17774df661f3c9366955e954d126b24fc741e5c00c4c3e8668d6fbcd4494700d63a7fe38cb00a55e19a5c34d5def2f50629363cc98c1754ad797145e43fe5d8393cf81c5e494bb1f19fe1437d0629966f61d1dbaad162178404e9ce5de775c7ede8a245628765ce008a2189775f3502304e1ff2c990e9aa4ce71b4a1ce7b6ce7a27a3cbf1c5d3bc025ba38fac147550dd318b9bfa2213df21eb2144d3a6460672b1d109c42d3ea8a9728da02411595a9d38e7a9fd0b3ff364346b96d39a9d024c63d871c055a7c0e251c1bf8e2e30502a25e154284a451edcccf1a8e6243b6a00c0d926bbb6c6d1cc4bae57bd4c68edd365bc6ea1779a0d7c910201b871e1ac301a5d5e997daa9895ab2830cdb7f387a0cb31db71da25df029a632ad303f00345a0e305aa04060751d772531d0d7414790dad02f3dfb0dc0b6e5e348eef19e1a14f58ea6fb2dd390c3b0ca5b85ee6441ed27fd8c12e069a9d1890d512ab20f4c9aba0a640bb98836e567d2145eb715d19de001de4e4fc0ec428749ba38d393f25143381e7c2d21184a2c52abb6c2a9f5f99b8807a0d3528cead342290912b441c76fc0fbf9df6dc7d7bef876b74512aa53d588b2bc8fdb08e8b7736751f6e62b01c61117eb05071d5c194e227b6ae17533942dc22e67b03d65d43a914d24f2ad398730dc9881a407054ddba685d90b3e66e2b14c50045f78b019b36da7cacd00e9d7b301d540387634356b7f109d2be18457523e27e66ef9881f25f72e2317f72e0c6e8fbe0ce0282b687dfca561263c1476c2d0b75fdbfb2c44e92d24f76cc4f9e200d8f1657b5a48b4ff6f905da8916de17feea4142c65c207f96fd77b7b79bcb66a79f0b73cc9c585e3e77d136543dcff1ab22cbf223457c708b0c75644db4ea7cda9910259627234dca125b9383253594a4f1e722856f3ae8f23baed662455a6b69de29d407bb4d9735ed4685e09b27074682fe785001815e60fa0628d166a33ed4a45da8c00cba6a8fd46aa6ee5f8047d28fd9ec22ad2dc4339919397bb8adfbfa822c278094d222aab7d218c20300857685b992c04e073b1ac32d141d2f7e3d43409f6f2291e9d5cb02eb0b176cd87dccdfc739ad5592b54676979cb150b0d61008a8eb17c484ff52141df15d2824889de2c5ccd3add45566ad55886e466de470b6f3d29eda4b14d317e79d0377dc93280a68593b1cf79a8941e4447d0603934cae2cff5abf5090d6cfd17054f8b172d5b7eca3a7a5e1e214b289d675ec853df1d49d77a7f231dcb721914e9f2a5eb4bf8c34f6c9e1a1f9b78cd2d758fe5d7d1c87b45741aa17293b0d677cb0191c5194862f04744e221504851c417491af1066c81a52bd341b95d747e3dea287f47a98f473ea53c14982b6748836d95ca4db9da1cd3bbca7b3c4edfe51edf3cc6490373229e28af95e8ac477c4547e36a64437fb485dd94e0516bb090c693b29720b11b3fc9c59a3dedd06a1e0d924300a8c501a525a19dfdaf7dd021e56b3d5ba0d962509171ce59778b25e495877c64d3fdf9f96f2d94f80f50fb8dcf79f90b71a964e0649d56b3e8f56c4ff3c61cf1450f62cf5bfbe95b0d903a6c79b6ccdfa921713319eb653467ca12d553be18a2821c5538ce9e55c5cc1f34c08bf35fcf6f65a66a7b0f0a9bfd943afb4a02c5f8197e161ce01d3e6b2169e20dbaac807b09a3c86b8b04bf01aac68a07a47b17d0216ebc834ab73320f398966a9ee413885f337a14c8255fae417b2ac13e49e8108e5674ee003759fafbf87c87feade41f3e2cdeff18d16680a8e491d8efe5a78ff2532e1c6933f5dd8ab5d8e684bda02e3bfd1766feb0e95b30afae74cd0e1644b520343c844ba282af562145b4ea02d1c3d8da60e0b271a59e31be07579c6f807e593b6f42bd6ef9bb737a00f80220604ace3c1648257025a95f07ca34a093acb9d9ef3950abc9888ebdc29022cf999412fde8a6860ee1be8fa46f2554274b733c1b066e2046064e20d45b70f48cc1d7774833b44f203cbd9e608ac38cc8389c3e1d9e45a135c7a57f561263517b3aa0f650edbe96be458a945635481c16540a96070c1852c0bf29099382b3bc5d9efa54f698b658b22deca919cae78a6341b323f3725040d8c108f8c22da34bb4a344b7c107cec113ec9d236c76e5f74a56a76926d0b1f2a980eadbe9d907838a13837f90fe8e8f6c9aaa78a8b08e61eaeba367315f0a65cda4c83d071e8c0067882207f4bc326b71f9410d783e50b053f6e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
