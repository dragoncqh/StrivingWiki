<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6bdce06cbb2f5d8645f467437668d507bd02a420acfc65944c02b6b759da3548812f3a62aa10550f35975a46e29d2e532611702a080c1681fa5e14e1f3e2f3ae47eeceb55ec875cf6aa059fb168d057c56796c019f0f7a450d24536cb8938a362069f4b3de8cc7fded26b5af08c0af336e5bd6f753883907d1ae218d68a1b7dde1d033548fea9db50cb48e96c97f2f63b0d1e19e2ebe7fc967f2f63d054ce1f021010b03fee70308f4d9557feacb045d254391f39a083701da83f463e28c690e299666f92b799c7348563ae2dbf5f081fe02fd3fc2f9f1561264d280f204faaee0bdb219572db71df78026abd6d5f01d174654604520a3ed0f7a1ff5d820b7b0e35db277c3d31e13d849c618a7432e646e678fe4f70c1088e5ea3475f9afb2a14069afd84134401ead7624ee24e4bdb7ff357c15664105b208281c4e089975e3d1c0cbc879e4ad5f4e9d3e01ff53791dd350ca6aa96d88d094bed866d2f9bb2f1d269bb27c1aa262c09fae5dda6a74d699fd64e2de6c4d1185e8c7656fa28400646f617bd63dfa395064e562d466a50af9c08cb08ada2f554212232f9e9de5f110ddd988986acc0c88d057c2a2908b186e6d06e1c9ca28a11b478c4a7f2ccd078992829c70f4658f9495aebec94226e10d5cbf31dd653093e732466c89897dee1008f9b2e060c20572dc59d3ba82f0aa422a3be86e4c91774d402218060d7b02440927005a998234d2b574c427a35d9edcec62d64c6feb05fe4f10d49e8cfe3430ec80239acf97acdf9ce4245c580d1ea032afd888f585451b58a7069735bae8abe3ed8a056b51ffe44415dbd80fd34db908b0cfd9e872ca779efc46e05b7b4abf3b9061bc8940eab06bd4c356c32f40716449bbecc98c2aa4f74263f247f4171b8211bf1edf9fa9b51c06cab26026773112741af5270b74499f6974d8630c29bb4bb829557a86401d0446426aa2c503d246e487e7229bb7ae4e1c1cdc9064ce199dcc4bb499792b668cb7cdc3704c760ae23e7454e03cff8a750441c11260ccd8e32835608336ddd90889103e2f130e46a868ed38866f86d0f4bfd839dd371cdf893a86122ca88aec729cf1b4d55715367b50879dbf7a0b75a8f31d3d36428aee8526e784b057dc4a695bb61d25d2c455cd14f2345c737b72a653f04258503872ef8757e026bdbdbe883d7a804cf0769911736268aeddffa8c083bafcae867eaf1602c88df91e736c84ff39f40eb71004447427a443f36b4e54080cf58b16ab84a56258896cb5179c9494135513f6ede3565416980fa3a2ac2e089c7377b7157b78338f044b447b49ca68bc809c35a39068c089939ca66b9663582a8d5c5f5da85ec36992fd3a08d279f8e29a8b6eb65cd0a64c82d541ce9737af39b9cf7e1a188fe81cdc8560e59b93fbf8a52045c776e990e746da29046b4f54bf2b0b18a87fc01ba1553b061687b72afeefdd42415a372e3c8f5097048b7076c8e6dafc78585d87acec59c9976f26f479a740336d57f68a91619b3959f6ce8bce44d8085884f5274d21de189adb5ea1841b874cedcd58cea7b9da351f868ab4a44cfe97d58823099847cb2e5326acf67ef4ca89a0b6ca25c5c0b7c2e7e77b861518a9735578c04de0ce721c32c617aac3e94cec77b4b017921abb192427567b68c03493f31cc562624af252b041a0278b8b403afcc0b54e796e2e4b63ef7e236fb3a915a0010cf25e2777bcfdffec0a6db1737cc2edfa104f02a5aa34a2a9cab76a1acbae9493a116038ffdad38792b5fa2de3dac3b79857d556a6e2fc117b4254f590cf75591d75084addac9e7803464db262fe284814ecb5d6df826ca1828ad98d81495e22a997897849d2e7d003ae603c82ec08fd82252c13c054dec3150a1630ce902dcad371e7be6e7f15c90ac7034f5d64676adfd29227f82e98637f5ee486b7e2bf3fb8b530b463983c092da2c9f4822af1b2945d5294080e1cbd8846aebee44aa37bd7c45fab50ae28565a1f7a8f35190d1ada66a6d5fd09d8734323549bb745ae858b7bea53891074335f67ac4e8ee3d0d614b3fc5530fbb24a5e40a0320c336f9934056d2b79d25b21e24d53c784058a66fd43d8727975673cf685a7b1f1a2648698f045e2c2c9ad2f2bf600ce14c0dd7e6ea16d448b0c94a6c450bf1613c886eef54194e7ddcff04d97b7de4a587410c8588f129ea905dabdc1056528f18fa98215f79c35110892816f370b68efca4a1a5dbdec4b5c4c18dc0d639ed7c78625ff19e43673e2fb9d036996fb3752d8ea270215ff5cc9d77da26e7b9f59c492f413e15d436a7cb8196173292656c2fb21ccfd492700fa4f4b18e576d7c9be68a3cc1ac9c7e2d5a12a38967be814da1a2b9ff56a35f6644a0f51a9eae746655426dee89ea86ce323aefdcbad957e7b92ebf7c1a71a1a0bf9fada6ab234b0e218a2283565b771cda621934502172d35233bfecea1ca699fe2dea7c36dc7b908546448d4075ca7a7d764a47fe9d80464eae68419fe142a6f42c9edc1e885af79380e9ae5dddd6fb27e6cfa50050f6a0782597b4ecdf620f7a9b33318b383b5a72e0039d91274d06cbaaaef2da4914c70c2c144ebcaa194f6a3f7bb5396aebf774881b7e9adbf578695116a79e7b014431bd54d7a5f03dc843945d2b9565695c008c12275017969cb317abd77ac4d5f2a1ebdc838a070d87bf13f4672254adcd17b8d32d77fc6b6b2da3c3c2878270cb54e68614d8db65b0835684b926ec9a736de915bf1bbd04759abca9b5df53cfeddbca7c21dd9eeb5e306936097848a543dd8fb6b324cdd6ae08e09126ac5a0a231d413546fe362a683b135e3c772cbad242f898e68537034d52d572656facbae90c66c5305821f36f8e9c6bd215f6240943665680d0125881ad1a68f7e40215c940b7c5ab6c0df570502476b65f42e8e6dbcfed5d2b90cb66c4e87329f2b2f69db48fae884c3653c1ddfd01a112047038799eef73a2cc1bc27e726608b7ea64f02e22e45868efd359dac788e1d287be706f5dc2c9ada26620faa2fc8d48d8f660d1b461ec34e3f2a29e7b107b2086b9f24a869e78cc15d1367a62d8b82e2b657ac17c050530d44d31780be7e72506aa8249be0e48711903b0930b878dda65b648553885a80e17d24ec6641d8de4fce06dfb73cfd3c0165accc68c49f2a5741ecdc23e29dfed9311ad6f7b25a6201b34f0076105db720af2c2f9745485cab64ac375f0fb30e69d85f2a8779638934895a2680d3b889756a73e18084aacae72e48850b8e562be8fd01d69cc568d14111fa9983bb4f77064d7bf62de489fcda9abd5308e193261201ba148741bbbdc851553ef1cc7c3f04a5b9c2fcc1f1ab61ee396b4e5ee2bc66662c10943c1f00bd87fc6311852a84d58338bc9e4aa4c4470271519bd5a97db36a4c446895223e777295e55f94ee51c879c17624548164fd7bd2d39af67ecdf659e6eb1f355396ee360e8074277a43b574bd3360047598ab161f8ae872c0f15494174bd7af193a743d6862b658e97b4c0e12b035f85276db819101cc7d33556742749c19144ed18221bbcb74f27a31e27390825b37a4611f8202711edfd2463f6cae9392f200a031433a54e6c823c2d4b7b87b33fb769acd63d6c3cad10ce8b113b372f63b615838d874afcda2df690c0ecd47de05814f0d90f30c57627ea29454f577a7f019a93cd3f3c6c1568c7c345480c0309d80b3ea7a5962eabb0926bc2bca498858c554fe8f2d19ce4d5b14fba2561d0f28203221f40eef02a91ed72377022c31552703f976a91eeb1049e14b9e5c5d1865fd7e13f835cea0e0ae645a122d935cbd7ea0b44cfd9ea33d3d5fd05fc16f2c8b7a50c693db1ecd21db7aa1c8db296d2bc56efbfea5fd681dad52b381a31def23150d9f1464d11133cf0de322d82d8edbfec1f19d5e824e041a8acef8a29ba2bd9af4d28e51972c3055accf7ce63a15cbc425b4865671aed3c868622fee6a69edc4eabf8d41557c49864bc34fbc3e46a0d4e85ae81a147d3f3237586a5146fb8f8cdb952895b8cec4836f2db2d5fadfc02883995cfa490420452782f9b8f763f5ff08544770c4a5713abe3d9343ad7ad34ff3a79307882b51ace111f4f5ee82aca749100f9f06b6dfdada046799c9b3529a2e3e42f53516109776633fe0def440fc87781c10e755b76bfbf5ee7bcde99c8c566131c1b1b8f71bef62b291aed0968ec4d5793e5012ad0ea4d1cf32b1f2d26dd5d94c5ffa180708342d32872280584fc24ac2b234ce2e66f67b96a4dd01daf9877407c36ebbd08bf32ef3689c1f26aa51bcc75da060f6f066d6e49b9b491854227fa2ed6b6f65c0c8e44dc6ebb15ed4806e74339a5243880fbf25734b12e8337953856369a12c1f56bd23ee5fcbad1749015312081d736862e18ba40a01ab8da4719d59538830db6df516005eaa42b6e1fdb84ab997528967319b66a3bb2a34cdf1973a2fd8fda7aa50e95a3a8f3b43522ee50f1ccc3cc32440104b617f5a75d3c6ec5d511e806a3d8e85f754048e8a016f1bd7cdfffec9982ccc07e8dfb8a260bc19b269894bb7d4fdc02f023b9e45a9b359a2f92e02ddac3099f5ddf55bb3b62d9039eef495020f1f791e04bff184ce4225d85af1a1602995cb428fbdca2ed98d02886a2d839f95b36978dd35cb8eaab5837940430ee27d22f33cf23abc61e482a84c1341bd3e2599afaf53534158617e0d26c128b76bbda603343c6405dbbd58fb9bb3de32f0c032191b38fc1571b408dd9ccfa6508fa989dfbcbed3623cbe04cad9442e8248b7ef1b413d12758385d73edf95a34ebfcf0199927ba67b023a835b6d1a572c56479fa0d3af1e0494ebdcc9f05cd1e913f201d3db40f13517ef3f4f098b3467ba586829c996e12f6ba4b67c9f3d348afe810ca06eb246922e58454f79327c9de92e4ce44ff9a308b621a4524e8c3f6f940905e096112434d191251183a5835818afc031b6c5da793c28b5aa6fb0c379877b3be70b5a831692d89472e5e786f0a46245dd016933ad2792cb34f6a9ba41724ac6e9a6fec2b63a19c9b561139ed20d026d75669cd1485cb554baa8b771e5e0c3d639de2e368a2a67d7964fc442501e37d9fd93c790ad70759e3d8b903bcee6288b4f7d576b62fb1ba2da53790742e9855288f665e2ab25d35e3b60d993e314e91f5f0c2da391d2920096f4bcd7a6200b85247fdd0b1b018a5a5b036d5eb165a1a3557e639ecec4d2d1321c86a415ab27d300fa21fca03163ebace9dcad32ccf1bab30378e54390020c9b47170ffe439e1b5f08ac320589603d51f530b1dbc8630a09d1130695bcf37002449b498669e12ad6ef9a1a7dc18add1e514589e07e4286b97f3b8819d4681dde8ce03e7e1101c71aa2f0dea58144447d7d22c6a3d3545718bfd641960a20b29e9b4ace92820cfdc799366261673b0f8a5c4efbd6c8d6918f9836252734d65521c4c854bf1d29190e3d97d54fe6446d63017929be7bc91986c24ba563d5b41aac925489da3eb7e816560c260094a3bf9dbff4a790a484b0d317cda7ce62287a328432ba6016140c2612209000745bdfec1466cb4b42af73e529a4b4347e966904043bd38013381a942bfa205bc3b999a6c248281c47056aab150c3deeadb14c21e0f3d402dbb6a595b7b453ebc817825cf2c9cf944d3d04cec3b632895c92079972b5a936d7fb83e636d7fbd1604c596ea34eb63c3f42052630721bc8cbabbae68c1c2a58de4ec9b46d051f3a29023c8b2dd9f515ce558a8b185b0badcc5a669bb621c0f7bfaf4c078ca21745defd6a5f5c8bee6524fb70f1ce47311269f201170a531dc7a0b9d8fc301af0884d74cacb44f52fdc235e05402a21330d542e25eb5804f5fa95690b150dcad868ac382919245863b31ee2f395e6299d36d31ac8f317c7d8f509c04ce66061d0e1d3bdaffd50866499815a91857f9bda734a26069c42fbdd1b2ff4f6eab10444f6803967ff36a037bca974cbc92b5460422beeb51b1b8131b49db797546dd2ff5a016c725c2d3434bc2f52dac95d687d748c367d0f84e1af0c3e2855c07b7ef08a9f6ed26eaa667332ae67fd8eecd91cd81b51a3dd3ccbae3ead62a79782aac478b017969ebc97f9e61ad348007b91001e1906f33c6cf00bb007314bfff9fd1b1a344601060327306c721a4e28ff9eee4a44a19163a5f61e4a834a1ae72c1c6ac1187fa81f22e7a886f0cc3f65b6dcadac303c0aa5d5deab2274de9cf694dca032329fa6cfa261f49f065a1c14a1e65360e151cbfaefb155d680d76637171606fd2c3df7dd227ea280ce88cb007423fcfcaa8d3137a60a403acad259730d0b5632af7f4b25a6100ac0d1c9d99eb111857faa26ae7342c24b4ef6dd0522aaac60b6bab700b677fcda690adc8d7f7be08f9745c146898f81618fb06b8e4e79a499ef39bb24962084d94d1df666760526d1f9bee4c87c049aede9703f32ac66f1367b8c9b84f20c62bada3671f5c7046a0816999e412ac20e168a034c044b228554387d5138a5777b630a5493ab19b5344dbf3a8e145754e7d8c4220935381ac99d75617ba4c7d48ad38e11aea3945e44f98ed5c65e8db6f06883308b2760d59736ad517899950eca074289961126362393bd5dd4ec5ab277f96ec5b379859dbd9d3bb7176cb03ef7b41a0495f4efaf93d4fec920ae6cc14c32f047555f07d302f9860a0d3c0c102b0091e312fd31a0967f77026671cdbbd9e74c2e4b9b9ca11dceb141ec9437c1b9f6c7e7bb61567483590300cd6f48bd6e4c66650fd387306d417aa48c177312853a93144b97bfd20d5b7926b24de47db8d49897d9df792c6c237103e4cd960a45c93a67a2bc9dfb64c618adf6741b09e37236488dffd42c95f447f8e3f696068ed9a9407f4ab96554d3d29f878dd61f6abcabdd0e06ac9736e8df35371d1755486f0a798e3d44963a1b81dc1e1721e2571618299107c9cedadc861c87ffeb9a07b68e92a02eb2aa6cca4db450c471fc194cd9748d8e448eb11dd3e137fc4da3f9594db43a5c242387f93484907688dd04cc11c0a64db5531640b0119a0a997ee30cf32986b91e780eb91060a68b0f63357a94484833346df4bab8bc629bd547e1b5519fec0f8e10a5b45dc5f318b3a2d4afab32773149438669679c537cd921fb5196ff7e2be5dd53c28c75d0c978f5ea3189ee610f8a8e06aa62707613ac8759730ebac11d78d1cddb7459efd3db8646cada9079508fcdda3ac6c497202e5e560c040010dad84c21dd2c74121f829f6d00d1016ebe38f9565e8d03f0a3b4e38f42ad6a953922715dd9760827e4fb9c5d314b7029c02801a4e47baac2c92dc16b0e780cc37da4b1e4a1104ee2b2ccd6336c6af0625cbcc1a82a221e0efcfdbe0520e33e1f56d1f35e5218e5061b427162dd31e85dc35b43301e420116cbf22d427ec3f60c3c85f0f6680ef6521a07813ab157460d4ecff64d078e46c72469b0bab6fd49dd2ad95192d02e5187fa876881937b64d639547b0d6cdb8df05487aee233c31e65f1d1fa7236f75e67d2a9de8b4ff108a8993aab1ef246b2051a0c7cb44cde4f4839fde10b2fe6b559ef929aef876d292e26e4042fcf313795f54db5a0e7766083c1108d401f998d370d2d5a81c386bdd12ea31004eb6d26dba74f7e0352d34b56a337e23529fb6fbfad4715f3a13e60b3fbbe5549c787ebf574cb30000b9b870adb9e4dad6d3b8cd5c3e000c13c326ecea27268c64597b32888ee8b54c2b198f0c3212853851f81052462c3ba56d5f5082b510bfe269565b58bd43c93a788868e72cccf0e040132beede494fbac4e8dd92a92dfab1e58420e43bb559ccd5e08d5c9da3679fdf262c9a27e419b4ee96aaaad427264b5994d3528c8596387ef0a9bd991c150eae774b7bed42ca996f27c76a2f4caa21ea7563d2467c31c3e809e39f4d3dab77671efe2ac872e9d1b9ad979824a077834e834d1b50f78b7e2e55361fe2870ad751642c01f1287acb6699c80eb1b39ee5711533cdf51dec8a8da8cd77e24ff3189fbe852cbe58687b9676fcd6091cd5bc87065d792ab43530b307b30597addd3ab5bbf6c8026ef298f8e7e9252d7f7d24fa3d6b5c7bf21f7b741754f4aeec60db2a590fbe4c51e0a4eae4a5bea8482560fa6831eaadb6acb1eb2ce4243ac4394fd83c18b6ecf5a1302cbbb8acdc5f5f782f74a0795bf51e3e5b120350467651117e920140a5d2ca82e37dcc330c4a7fad757ff2876f1226e74e05ab26b5874eef50f89ec88de37c56c4560fffaff1f536df50de2e19f54f17638fcb6b606f6296c84b2846581aa9820decd14b8e122b0279bf0cdf319180258d12c54205cfc449269f3062b244679cd67a9e08e69c546a0955d6e3a73c2acc53340742d871afdb18a9a6c8b473c5ce16a193214ae677093705af2aa56bf09bc743d3eb83cc2f02b6b2f8cefaf34b28d668e947baa00ee32b0435b13241bb91eaf451401b6b04a57e73cd540be8ef88e5f0c44200e3e9375d9efca60c7dfe80a3179f8350da4f967d9e6c68ee333a4244487574e6c012a1679765acc914231d0170e6d013aca19d0b36c1b7a10254e5c555b38cb74443f15ea05bea4df96b18b1a35be5bf32164aeefc3abe96c4ac5d06395dd3bf753ed5d0ffeb771c6227f14f1bede03a4b14a86d308dc0c0ea89e1ca8a7411f8acd324ba1e9ad0821d13b3b910841b61ff25ec18ab7d608773a76d477e33b0502254e7d4587078059a8ef11681d68cc4916e74a334ce011efafcc2abeb578d9e98ed09ce022291ea52a46c87d3559a6cb306f0fd66c44b97283f2c89e098d99df52633bb1bb589e72866d99d37c1546215212d647eb1d1dd857636353f25027da2171c893bbeefe75f6039a772bf5aabdef8cc100be7adede0dac640b9c7340898045fdcd35bf1c8de7352c17aa1b28e7c57e41094a5393cc5ae458d694e36ddf2fba6f90a17ff29cc39f7e12cc76d22df77366b7cec93f7298dddabd5a84836da65a7e30be08a24d57235651d4e3d6872b59b0f1a231560299044fadd589de90276cf51424e73d006d471385552891cb1accdfe4126fb37438e726d919f47f2e1258655f988eb61d2a20824632ac403b44dc7c39d5d1226c1d5ff8ea7254b8f64c02b9483cce9067e4b235caaa1d6dd04aac78a67789070c3ca672ec54f3d7838155f3f5add20c3e7ac3e593faafd1b8ba42bc098324b06b56b4db813d4eb0d1f5f3475f2314b6492876608267b1dfdd996bcaacd4ab5d490acd6e573060667ec3c630b2cb1ae55130b415a33f0002e8708f0cdfb488459bd397e030bc9fe1c7e8f8275725fde1c57334d534f6915e61166184f399b75639dd3e8b3684aa56d4a25a649d0c16e508133d6f2cb9e5a5f6b4e65ca7ce35c740561af9b35198d9ccbd9b0564619ca36c54c68c6e4148433c6e95069aac321b81d8d9f6999145d72b19577954ca6a44e49e34d73c8437ec555df5f068234f97343d8700f2acaa36296c0dfb76ac5a28776bb3e7750453a5f30b8d0618e26e486526a27ba8b56c75b1fa1221ce253cb58e4f95679d6a254dca8cb6b3279eaa1d00c9b7be66cc3ba43888478f4b82049c6e5f5019b7dc2a049e0679097b9c7f9a30f8623c78f370c05ae9f56509c7a6acd63f787a0a2809356c9086868d846e413872d2173943a5b86bbaec9df8ee30873b76c5f9da3b6fab40f8f8123a8c7eea6273bb28bc6440a317aae904ab8d2e6e4d9f37176d26df0e4708fac0b1dc3b71718d68a4dc2bc49a6045db534c701b464053374bc5af5e2ee48f87589bbdb1898d2a14e0494ca4f7d7ea89768c77281d286c1a8af6a1c802080b8e59794edfbcade0872b8db1f3f1b189d2812de9f11d7f04e7609a2c177e0082c593294de02fd8cc74335dbb63f1b23fc5c06d4c21e82af4f653b43f625f9ed53d18d6e18ffd37a4ade3d543ff9a67397b807058857472b36ec91a877127377033f7b27805cb023e34ef40ae3064b46ff2e4c5305d13d586972ea54b49b7a1c67978982edef7accafa6bcde269808a63e0a0a15047a78d514cef7b84cc6fd75e6a14332cfb72e517f2d58e011eb0b8f23863c18ac3ba91270b4cddab1e9f9c060b8d35d2ea4fc88087698d5260e16d5fc6c3888408639d0d2b956ebb21df581c314cedd76664bec28468a4dd0e0539f23c8254c3e11ff056449860419609e21239c731ccb22a184778b270c8e52e474009b98f8a2bd8faf26a50bf81f62ffda35def1ea729773943bb45b7400c53681ac54ce7e6bf9c6b44a1875536dd54c54ee9fc603b12ed974652bc7525f9f002ace44df569a3db4f688703a308b23730955903879f812ace6b95d60a7d084a1f4328691476e04060e889e3481732d9925624e0f8669461537b2807cbba0fd55f2b4108fff6a89637c131d64143f6084ed0e0b8c13fbc05b662c4d8b31426613e78399cdc9245ce7f047c747c53def672253029c47c43ee401427ffc157d01bc57b6dd95d79889af78c2d9902fa6cb4eee570d89749ad0d2ba6039af17116aec57d68ef3f606e03d7b0a1ed3cea9e87fa4ad21bd630e1936723f3a0cfbe5e6fcaa8db216d8b7bc8e0fb119b2e6992c51166bec50e3b0d6a9604637b5279a5b8dc73fe093e9ad13a4a88071769b04555871db99fb58b1640c67a4389ef2efd4dddb7c81bd544347660ebe257382a0d22e412168fd54e97ed1c127d99110a05c0b3807e475dd6c93e4f6236cc9b85e9e5ff7395f076dc11a6707f3b99c2662c7fcac473b22b0a819aef1be1b77db2db46651e73c3e8063abeb1b6e605342bdf070808a92f58b2d1e561f7d44ba04aeccb4daacb26f00770eb43397b59314b75504d2182fae6c28b6d8f43236223cd30e5a3492736c4d87081d6e0f4cd8230e56dd74f39337a52f4b98cc5185cf677a7d648c9433d0651d44276f10d5411a48df1a01fdd96cd9ba3fb2f1b0eb2130b76e2fd03245cb3d98c33e9bf3bf0f146657f7896070d013ac895d6c57ac73fb0eb54af0f561c30deef834d4f7167a01199207d15435dcd9f165ce597fdeb44debe87d8391f97d593567483541b04174957ef85746574f49f20af1d4f3a842b8089f4f4776d9b4355de1abb2e44a947cef4cac6790c7fe06a6510ede9c72ca61739071c8357dd308f6b00ceb7a835a8949393f5b65c3f6d566924d908874c0a2bf63d18718536fef3787bd83ec72236f74643083e4eb79f78bd3ecefc28da471eead6307c038ead0254bc6add4a40111c6b7618ca3cbed9fc6c4b6cd204f84c6f67887315ea6320be7d8258cc7bf2b6a21bb027938ef2452d002b59cab6f9fbde672aa5d985e0b36a388fc6a006198a180f4c889300d72240c78a475c5fedc3a82539f7135f6b2fcdeaac0a54f9ca695c49bcceac60e92f28703d1f639323f7d7721beef3c7288a226224cefedd8779c243a8d529133a3a785aec2ff3a58547d93f9b77e027a75f952136e183ff5537fb30cb29c46aa4a2507d132e184c7b47a325c13d1ed9b7d996372b275fd072ebdc91af2cc6a01580937c972026ba7f138ff2db273c7fac7de12afbcbf6fd9f79d75918d7df273c2dc5a15ee5ef8560d274911683324f3b6cf043688c25ba49827016dd24dff6437aa52a0f8fa16ef4feb7b5f2803b56f64b2cd2a316ce09287d6cee96c7398f1cbf38c6aae32785bdd34d31922c6267954d831c4860b7c3d6476ee97df18abdc261f99a5edcf4a54b12550d3f0057959f52cd6d556d87901d9ac55855872cbbec899cee58323a7c96e1a4fd3dd2f82638b98b68eb4c25a9285dda835609c043c6494d7ea1d2285171708dd7317cfd48e23f2673ee762115c722df4c039f5508975294fd41025acdb78f2b627dad56c3e8a07b4da261cce2c24bb31953f5b49dadf0abaf0fa32b6cfa18c484df243df91ac544d22685f690f722761b1750be7388eb2adcf5fbfe10e22a4a4acb73d60e111a667ceb8750463610fcf46d48e7228c609b63e55751722861e8bee9b1406f68a50fa203838b3315716e2c640283a63223313f19de5b089cd55b15ef53013cd7b1bfb09f07510863495529133a776abdb69ef13f8da4c125b8460cf673a3ab210448bdc07fd4c576fe794366c3d84e8e731fe6339afe35db5840326e626b7f2a58c100936ccd2cbf0d2bc085414429c61b27a2a36de88748c91260d34341a76d0124e402362355dbd987778e3a67b88f3cf89735ea5972a4aaab32d01deb8d485665a24456cf8d447c3ff6ed3fb8147035f469e848f66b822510d8958e740b677e64e300bd75b96c19ba0dc41af14b0cd82c2888e157bc13155a20ddb28fa37a68bdca58c6d4b337c868107a000535870fec9477d0406068f17086bcd9d3c5722ce25ef5bd6f967cd5f073c4707f47f1356159e588c8b5cde620459735da8d82ac6295f7e8bd78caed5e9022e82946c3d46efd568aa2d6ae4df4502d520e1541660ffe5739fdb129b1c7c3c2fd830d391a09d73041b6d4803d25b3400be6b94de0c4da47fa30a4553590847339fd15cd8a0643cf4ea7f2ace5e68e7b1ffc2b24c670a6fec9b288a1d468207821bb95c93ff2eb137316d973e7ea14d5fe19a57f0431dbdd26e724c2c33909071116e8b87362bf9a75eff45a3f29c45830afc4122e3e4f7dc37bd8e7d4c914b9819a3df18df2c92382cdcd5ab31358ce86888ddaa6ed0fc46a00de07ca3d8785ea8d9c5c3247b9df7e36d6eff8609522394fd5d703dc43cc5c4b396e8dddf60eba3b69e456e27f387f3e508fb57cad8db1c4dca2241c9916556678a8372475c6c89032c331a0305a88dea717af7eb2de11b10174df67aba7f2dfd705a38e76b7d49ed851a9db3684cd9349e617780a9bd36b90fcc6d4b23c805695d486b4f6959d161f9d7e094a301ba33b6190e8576816e13ebd679ab1160fdc6f839132a83d7c230c5fb86966a3fe99f67cd32fbde90fc2d1f0db3f7b65836c723598fc0b13925ce6035e23e391c774a00cb943598ef85c69c3b342fbfb555b33cdb5c4795c5eebd728de2106849607d05e6c9d180b9956c126642d0ad8ee80eac1a181cd5d5610cfb4aec46e53b99d54f33bd302df31ecb1977bb268250c6a63d4ecf2a82b557180b72d626bb68a3a8aa4bf603a1bf308db5b7245441aecd50322f326ba0bb7c2edca4121707569ca49d1eb1ee72e2025373afb8cce86ac0249105103f3ca5f1a52377c1af2325eddfe8ed2e35b2f397c18f8af9618db3348c3cd25df5cd801162f630445be0bae07095a62f58b4087a952b6ff5609cb333baa1774bbfc74e55c339debf42a676943ea21cdfece4e95ba198e6caee26ad9a99aa4f9f0b8393c7af61aa675ee8b09c8178a339d374c0363a47a4e9fd2f6e8821148da1fa66387929fbcf734074acc9fa523458c7be7f0534d784fb81ae4178370e32","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
