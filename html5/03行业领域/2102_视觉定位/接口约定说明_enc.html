<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a193417f8a417467cd2249b6d356f811a2395d9428b9b682fca99126c1dc1addf3b8ac600c4b8995e8948e550c802a5b5a8e3ef9be3b9e14be3203b3c640518eafbcceb51097a5d3c6a2d2e761dbda4ef4cf9db9b1b1d6662611b7b232077c02e111d7b524b83bfdb3fab9b8a961d6fa4c4efce28df2d602c522708ab73d19c64ea4b774da47643cb754d39964c9cdbc86ebd97a70791303ff5a9cb751cd2b5a3b927f8a9e51cf674f87656f7fc64beb82a2358cee47fe4b6cc32d3e226796a4fcbdf930c697c8602376756154c9ad8bccb1761a1b4cf91c3b81e0c3ef61057ad7ee24d29e7d1f3d8f607349e21bea29818ffc897985641e5d31dd1176fed095df08bde06f04496e98d0a9202288ab3d90dda3b1c8d021223f0450a57b79e14a981980eec2d3d162f45a075e84d439f6be121f630b07aecf8d19e3a61db04eda975bcdf0ff65bb63ecf9bb37ad710e8d40b955ee6202a6443ddda19a84251dcbda418841d61976bc88b27c7b3fec9083a5e49f6e4eeac3f108362e57d4539ee6f17dda33a64fa31816cfbc73a66bca8d76d653b6cd4e8ce09d987d512e047290d3679b01f52dd28f78ae6742386b21876ceeb0fe1e295ff393e25ba1d532b249d8b01b99515074af5304666a5f94f0512989ff7b65a3a48ee6c9a834fa1cb43285b76db51d4e9b4272fe75189259c96b3537106f4fbae9e256870210c21949af7f15c6215793e51346474d75ae869dfa1718d04e1b336b2d4465933946edae0a0b4a32e18cbf6699b380914dc220cc541c1fcc1182879cf8d10aa128688031ec741bc817e7e3225fee974a783c2b5b5aceead79229e4f30f054c141d662e8c5f1e04e8813bd6b356288c8eced37fe45c51380c7889d81cb6b9a2cc729b7f10768a2c666a3f6f815a8cc7b6e8900c5d416cf3f735997c6bb28108f27035e54a1709d7a635efdbbf98f3c8bf710e4d82a6563068ab938d6ea92431facb659cdecaedade5deafa54ead0f92319c53f99929985f7feebdbe118716269140376732a3987bf6c76fbe537bef5d0ec497225f2a6b1a4ea962dfce511166dde235b4aa7b1762765cf6054b9be30f3300ddba4d2e8ed50e5b9edbea6c820b268a6f545b2dbc96bb98331ddb38e6e59206ebf500d67b15803fd2b564d899e3f2ebfed785649f4cecd46127dbae92db7eaf5fbfa98626a29f23587ce23a13a7c23efbb78c95bfb8933ce2b6139161a7a33afbe20ebb38ab727f5d403730620c04da6df4770f9083c9880fac878abc72d364044570aea21254f232df9e5e5a264095c6f6beacf31cdf71fc72acbc9295aabc140e4443f4ed02eba5e8329aa07eaca96f8cbea0934c753003b0c77e9a9a7ca6b9b2ee95dc05b2677b3baac0ba754940026fedfdba008d5e183f7893899c7ed5214efa49727c972bcf17f05f96aa6467153699473a15aad56ca6682324c826e8ae905ea592a7adb9f46f8e26b1774f320c23f182e35ceccfb9c4c8d7024f17ea4fb2611319ee825db3f08850b81fd9b8889ebde3c6c2af5a189ccb930aabb9667f619cd98d44baeb2dca8c7375c3dfeefdaa6accee67fa0224f19ff06a5496afcc5f811708325eedbfc5015663494dd352b0c952c621a11fe9a5460f2f2635d66d51e7aeef2d2db29debd2800ffb57f4542f705807ed60041fb36bc8ed3f0af6df5fb2ede53b49070f2ef4ddd6c76117e8ab9ab57995d62736ff8e57b73b94c5baa914068ae9ccef5e2dec79677df7ba8217752bb43a65173c249c677a03ccff4b025aa185aee68e3ee63f078904eb60bf5eb1937e6c818771afa925696e19cf685ffd5958cffed19b1757a774743fb15d48e462025c8b6a67d1a96382cc01b7e38b9cfda73b44376adddc0927c70fce04b2bc9474b3f6d18cf3f924f9a2b474528025e9a66722f1bd977b3eadf3a511e37c9419ea40d052e163038d35c51be7c7bb7663c50da1872343bba76029263e15aaa9a21e2eb1639747905f0a5ee84e2b3657ab0c9d1376dbdddd85b392fc318babd3bd09581a6d107fe3907337f0d76152c56caaa4e517d85e5ad11a8a07cd908fd1153cf94d220d3ddfede6c50fc4c1fb9fb47d8d54f0db9cd6908db85c61aec84381cb18d7b86d6f0914f39258cd45fb54a3269b5a8f29a20098c66e8437aa7dfc4e8597eb837bd61b7d9f260ac28cf21ce7d4253351ef280c7c8330e11d1609fda2f10bc3832ceb3932af41f6be4bcc3a2f44cfd743b1a527164e79a577ce620e4920ffa25e44a495d35dbbb3691abee00bf3777ab7cd44876b4eccd522c29095f1584c8131ed899a50d83d08d2cd1a251e78540952e01573a7840be809531c3a8bb349d64eefc6293f33ee6fd77a95dba824aeb60f37933b5e7e8ff3b559d817bc5b84687b79a2e30204fdf598fcafaee1a5284960bdda92c6edfe855c9a4757c5f3232bcf9efababe43cfaaa637268d1f0bc498acf9bfab1ca4eea2381e17e2f9464b7e6cdcb27012399a2f8badec6c72355ca2cef859af0608d573f69d3fa32f2e4b17c74e617a39b9b0ba583ea52365edd34ea82db6ac9fafbed9d5c10719e8135e696c616d9467aba91431a20ddf385af3cee3708ae3dc6014a92c52c5312467d933c039900f1da966e324d07dff504b26b418fa026be33d44135ff4f6a1703a15a26138431d15bfabecfac89a29c9139d6bd055ed59c19dbda1c69ba413690c34de47707641778ac1070fca226e444aa041db308d3884db261b9a5c26559e807b84307a3d2171bfc49937395b1475e8c60e1d028d55f0d163135968cbd890e574babca93ab69ac4d0be586d84793d0f8d3cc49b03deafd6f425f78453c88a6401a271c7a5cc9da23f6e83d5aab1fdb8bf9dbea375f46d43287cd30f3951759694f2aed32eed600b6e12adfdb90b513a826f640af4cb1cb3f2fd41c1aefadeef5d2b79788bb0f7a4a2a26346fd944693acf10dd2a52ff57762711eb10c3602ec01d43a1d899cc0173822b1738c9ab94d8d440325e8c481875086214338d8c9a4b1874459a17342db0fd6a85236d00d7f0c5d94a2d17866698db9262ad62c817b2b41c6c6f009f0f3195eaa022ebe5c13b970f2ff686870996f573816c8d77e7cf5c44da1d2af918f32c2c168176c89d95fa3422443c51be63f1d3a083fc5732badd47d8a00555b283faea51758c1d1c82c3cc95610d01aefb64ef7e3a7d0b86cdf24e913521fa57b7d51516669cd0a057ed94c4115c5650dfc16569c11d4c43a2acd2deca5d3e0af7e99f4b9d8ab136b45a8b2242fb4c2f58fca5520dbdf75c9714cfdbb6024121e95a527d29562876b40b1f2f935c87551477cb2d3bfac5b0cae738538c61aaf7422a0c06030bf1e875a78844a6be3dbe3bf1520301cc1d7a7bd26b0a963a8566eaec071246913a3c17db9dda432fd089668d2fdfb3fb08f6de6255bcd84b09845c1080266417165ffbabb60ba2004f2d185d5a61fcbe9841b73b4839fdd508ae982626f36ebe1ab4473b2ca6cd19df157073d9b15a0d9222ff0bebf0e372fa2ed224cb659b461b9d9c241f49e4e2e6ebf6c8e75b17d1ce563f13d8be1ea68f46986b251cc40a75afe7063877003e7eb2640cd68f3da14a8e92d8b50fe8c9900b988aed64e12004f0996b6fb2db17aec4f99420d13a62fb318e93f477af730a5962b1f58cd56f8ea2e4cab1fa5891a3d36c10d0ad31012559ec38dd77d3bf736380c76f342503451b4c9a57a625339e16d15f040e8df4e8674c03a4efd8645a81b0128b6971bbbcdeb636ddc79fc097ea37b302a07b34183de3e5874d382745600f4938ee11ac160d32831ed7a4cb1c39293cf760e87ace4462211f0dd1ee9309ecf04a24705674bd87fc470ecfc839893c640a3053c131d49d1c3a0db090e9a9a3bf0f5fa1fecd708e21755011b23fd34ae1a20d0da99e25e855c4a66d9e4e22d55ccb71422e79dde031879a96d8b7d8cf5cb9735ce847d659331874c3b1a1363ebe0a4a3e38be73278b0c165a6fa332927bc42dc49b6935640a88860217cc740e534ca13a057782b500334afff75462f0020402ca23ed8da3c7b72946009ac4da2ada352b292da4a80e19cd5ce48124f0b9134dba6b6114e222b988e950ac605a8c8e7f91ca32bc2e665c3215eecb08143995ae3247ac4ddbcbaf4b7bb35baa705ed5d3bbee435b6ed6f86f2a701769ccfe7f7d5bc3eff54a2ac76c13d876ab277399932411a8453afdac22a9a85e70aa45f55fbcb77ec94e83a2b09fb1e62785fefec92d8491f0fb344ebc6ef568650bc51222e8d1c25953a28e16189db090184189958158dd9064334ae6d3b8df1dcb143caa49fb60029f37be85de663e8062e91ccc63ba82c22a237ed9265a12697d79f624dc4b637693b47e1c5caee9a165daf9a19a1723c115ac248a352f401eaf36d1de30d14c5b511cc584d1fc98e847ff7f66d02747056c6e33796d0581b1a42b3121b67c2b6ffe23bdc100ed8fa11ea3e2d45a703c3187b9b1a2143548746d8d7708f5079b7280da092093a315d96040c976e9d27485b2013302cc2a71b9b97e448f4a6a4080b156551fd6cd12e3af387a05d7056bb8b3f3cf8424bc193c4577dc8bab9ea5c5846b141146407b71dfecadbc505e9e8f86bdbf2e3ff21b01db6d9fe57d7062bb2daa4296500a4e6afe102a81b87525a0e3c4528c52e76e579a7f74d507c81c272c20ccb4fef82604ba113f002699b48a8e5ddaa5273fc2fa867a75fd662618e6259d6c9cde463cd09fe746a3c84846e243d71bae1940378cbe808b826d077a530f54aeee05a3005773eb2772d0df1fe688ee0b74f1188ab892df140154f8524b11ab8e4e224c82751af2537963631b98c31686d7e4e55e273424ee848f7c26e95a5ba177e9fee25713ff223c276b867e9306bd0b3ad7c9ccc19cf19f41c7fde11d7480635386f681d39f7e00641b5f8a717d4d9b3a8fc7b400a358d8e77b2378748d258af8bb2ebc4576c6f6d40730f38c675c00ed97cd2c9b4aa7d69c9640573afa125d5343bdef3d7d739d5f00e92e50b1df9245fd61a74fe95abded6906a96e9ddf6580cbb0b3aada9421ece96e904d2a56f52f156d81a120f9c0b726c19dc07cfabd5f4b1ff689298bf26bb1215668026968eda36ae7f2c91ab591516949b7e6bf90eb802c4165603ad4eabb32aa3d3bf2f46545308e5128e825673480cd57aeab707cf1c822418d4c69fdf40158a92d3c596a4625295bb532718b11b11513acef0bf57916ab2631ad8031ac716b5b2844a3f1c8506c2de6be4ed21fff3f5f2e50647769157b558d66b11ac659dc6f8118c509b8b8ec21d03646d5f45f5e41e1526bccad9bc9c8e0bd1e01798b88493b6fe1e61f0b9d934a550c095ed7c17c4eb6f27da07296e9a9b829c19a67f3aded295891150a7eb2e195b67c0b8e2f59ec6261d630ce95240fec005736d173280509a763dc3880996cd5979377a8a96e262f1ec090eaa8263ca6f36a86139ce7427ae9343ab5d3cb6fdcf8887d4e5411efec39b15b02baf684d575d69b125ae6a4ae61220ef6322c676c8d17920feb9f61741cbed3b3cdd74ce48ddd3378c60c150ace1c398211fd89622329f325cb2bde26447fc98815c277b80192214bee21a6466672ebdc80192d10438051ef5fc8bde6f24010896094e63785f2982759ff28f9735c56961a4426d5ec5d0c063cb51c9acb114b7d2da84b3feac6315de73113dd4ab0a042c153ada0f67e99764702655d82e25f0f924cd86228ba033acb4c5c28d0ed6b71ef7840273d02eaed4a855ac612ddd7492b6d8416c35ae9b98248b98b27b6d80cbd1500e2ab5bddc45c07dc8dcd21cafbcf831efab7035592046f065b4576b86d1829c26dd05b589abf5853b9c479fefd0390fa1fc7b81e4dd10bfd2ab161f08b6f4b59ef25a2c8e34b61c83e4ca8e87002ef6ccbd1ae1d01b1003c286c0aa3d11e40c5bebb8b93a27d9dc365f0f714fbca60da848d841da007b594cc7340a31eaee0fe26c17967018679f14d5a6de7e14ef50a158256617a99066691c6ed7582b8e211d9bf2b5ee5cada69f1f5617a45b7e8127884fefc82ef44d5012ea8e37a1ef27dceea0893d1e8105042c0c158b7195f05868a0e196fe9ddec6a69b769a652a0d2a962220d054559a49d9facc2ac78e3f99d31f2fb1ea5b9bd78c726866fcfbb9033a4c4e2cd8e715179509cbd4e3cad707b57af3d2b19f6c344a66ca56dc5bdbeee740628f55c73d8ca6a9e287375e3c71bd3563923c7dc279f0f0f508ff01a6820c55523c9391026ca9588383c256fcf5b81ba5eb937f9a50f5b0dcd0f998828140c05b5f551fa4af8c844da1a8361468ae2041bdb254ae1b448650e3ba40ce68686aa5f33dae0320285f9a6a6bbd979ebb4771d964ad260483c09c3ba54489ec1de2211b038871ec1d191104745ca9e08b3556514f955e8692bf0db5818922207781cc06c93d933e4d01bfd79c4f74c5d9e70a6e44a57c3c23ae2ce711b71b93cdd0d48f743c3ac009fc25979c29743a6ca9bdb6c666310b704ba5c5dd52fd7b53a89458811f9cdb15216de62cb810b6816646e09c358a683b23e25c0b297321ace26e37447505020bb713eb7563f938c6f562b67a3cdd8c2afc8d8af619e4644d45c506fbbee44fba58a849ac6cc4d314b7f25c90808c829cdc5d0b3df3c6dd2d94f7e11e396340698004c0a4c1d2a2b1ebcc6a3eae25e8e274c4876186b69cd1f5799873535558534098bc731225a4e4b0c8987d00aa876e522d7e2679e88c8668d9df5ff737a9de5fb87e46b537edf0d088144e0442ba1be9e2aad300ce25681babd432166c4ba00cf00bc406b330f03f9611655e3ec54109bc30b344eb0f1e0781aa8a2d68a7e41ca4466a7db9ab883a7bc8e8cf40e63ea223a3b5de338724b218b09ef64441ec638541be801f7db7a3b63ce713dc884ff03feb48fd6d44a1212efca64a918add4688ed0bef094f507af920ec5298c3f577953ab135420b55d316681e2a460c66be3e8bc413b89e78cd93479cbf34653d884211e9af4a595c93014932ace885c5cfbe601e2cba0e4c8792e8cd216be42ab63f48f481ac499e555e3da646860dfd1dfffc35f99612a611ca0b22a49b271667f130b85d53be62e07c717aeb312e2abe78b67591d2a73f37c48286b3867df1773a66cf3e73470023bc4c4a48cc845b937cd644dd4275f2d446c73aeb106e5262345fe6260e7231ea955446f320df123ff78466c6b0480acc90a88f79fb4035215aa5f8b0f85421d6826513beff25e9cd98619bad6d16047d9c3d602be7e741cbdd712085125ff58fcd5755c22ab927230f301835a89e4c3c111a2ad6b8e6120f66a926d96af600e1d6d739d9fd30671568b684c18b31f3874b63bc48491cdedfef402e718b0a0fb3bd3cf584da7a9c53a7086d20ebd2dee2f3533fb650d5e949aa00ba10d3a4cfd4be98fb22afc933f97e3d73fd7915f531fbb9bb06523457a4ec0e0aab05834fdee5bfbdf4cc71ec9c9cec2acaeaca71948473567c071cdcd64ae185f026245af1d9f06fc8cf8ca36eceb1991a6c153b725d198b9e6380786cbb6cb4828e0bb639fda54e43f5c27252a22b922d439d42cbaafec37aa716d74295d7e25f5c3fdc42ede98422cd9ae5f90b24446a528b35e29207d303dc7f46edf9fa785f6320e7377ed39ddcd54cb5af382afa1152e150bc109e8b45b4e03952b2585332f98245f687c2aaadf6883e36df3309b5227b88411ea91bcea9df56fac75929b0d52d0b33d8bd545ce3e1f33116913f694d1a253bfd092d15ad84505fc607c43192de294b86f636e7102ab2f74d1e8be703739454b76abcdc1ac32d69e77649ecc769c9186f903abecdedcd3b45522b2667d61ca5d5f25446dcac04e4f63546e6ef16b5f3fc512d6e33efc978c3f2a3ce651c9f7337d84f8350da613a4ab2be2f9348fe00e748a8ad973cb7f686a6699edd8c385a5b6c169c40a451dc53fb5afb0b209a2a0aab1900c85569a97c980d19fee50cff434f629501a525eecef1d00859c5656533fe8713e3c7b43691ea0fcb3bc948aab92810be23b5abb874b33c6af2960561bcb5d6f6e36aebf4f7980c33817a24f072f0618ece91ed6dc21f98df7a9a3f2764e1351b6b7775e22740066e810d5434c4c68365dff7ca288ab914ec52987dd175396a1bd0ba76fe6e81be853958fd5adae3a0457ac4a48ecb5ea5198bad5b6736b1a4e4575b29ce2ddaff89e4606bf75a53307db2858dc52d4eef88577527ee609aab509aec013c8900f35065d56128316cc68e0ec87cb571da4a0efa38dd37b505a29fe4decd374469eea658ca708890e11a4d3a93f945a40040f82214950e0b6e3ed3e7cba97a0be4847e4b37b4fae3d3b9148796f9e5ce97665adf82474aaded6c595aec71f05ef0dc4645f34ed098424418a79883477e4f2bba6a5331ba55401907ddf96d9ab7c3e624eda31738ecf108c56a11be5b422d681142d95cebadf98040fb5eab8ea4197beea7db41c240b56ce4c3bfffb35435f628139d5c6e0d03e98ce0e2ed43c95db851a9b914060839cf8b9bc279cff2d33d2661971cb624a96cd64d6e804a68c4d1b235b01fd2253207f930b4264b81fc2d19dddd675a129f1d189b7322685231746cf7497012fe994b53d4a1caf57b68565ec8352925c3d5d404cbd7a5e8b5b754c11ff94f72fd98286087cf952d738f9385da7b554c207f97b23e8f04f04220977a536cf351b3e1535c70ce860a21e9a575758c98f1831332f9a5268012d466a76101d2b0cc242a5ee7d23757e2872e2c04e872a96a15bd01bf273efa33cef678dd7fc20cf7c6714dc23a32f22d069f615e8de26bf65718d3ad4035c6b87a343cf09bf94847d05495edb8df1905233ac0c45852344553f70f3877d416948ee90fb69f63b5c5b1e56b054695bd6b382d3894aebb922cfbed87e6d94a3114461c99814a1e53b2106ee7ac55ec8429014947bde0ae5f5253fabbe43465e420df9de19a52e4d6690d454d57f6ea234a333a42db01373b350c2e7690474b5f6fb6fc361c5f9174c656ecc8f9267c189ad087d108f9388910d1025102f28f9d66b88a33a5116636a8e6c473e603fac5ec1b2de72be9f8f30cad0e9abc1c7d06468f1661a78f28dc0d81ea508b0311c6bb0c347aeb7e72e9dd083e4f4c4e6303ca6bf974d6456f68be109f9e92c25ef6f81c22a01f7098dff8201cd4828bc3c73a4c82d2a88c5246c1b7fb451a22aa129652f05790d5018c4366db59defea9c6083bc6754ba38da67ed255451edb9dbec5377b33efab2046306e0ccc4cf0ecb47eb9a7efe7d5aab57cf4bff2b08262267d79ef24f66a5f8c9dbf0dd262c5cb890dd86164582a1f3575cfe8909ee007464578513d62d3fbe7e75a3db3717c39c4b8ba554bc722a1e07195221d8347096ad85760523706e74e30b9880512e785be735256bf799a06ab84a7e346a18c53ab0773c84fb4fa0e9faa0e78a3a2a7d7889c3f44779b4fb47e5346cb8cdeebfdbdb4a4e09a2539073cb584865719719a014685a547538929a1c3de733036e27c1ba901155f29fd20e41daff52b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
