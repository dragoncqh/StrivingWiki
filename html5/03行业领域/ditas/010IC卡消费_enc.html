<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e8a8b663586490eafbac27a702286696393438ec10a744543e452af5d44c73a1249a89fe0704ad7be45e2ee215517453b861397c2072c1519a7f825464b485e82b1a8f8964c7c567b84fc7eefba6c75e4375a8f3859c08fcaa79bf1984b6caf5a75fe4399e38f7c519b2666bb3c3d51d9093f7e19ce8a2592b617abeeee4a614a9eb7e7dca65789e65d97a5f236fd702921a0340af12360176f84aa23cf890e49b0c19f889df5473c04d82359d6bf41b2f025c965e3b824f648409e4869a13bd2ffa2e90d6319759a2cda75a9ee4965b6a39de7ed1bcc7df036d9d04979b6176131510d0ab9383a41d3572c6c474dd17797cb6d0909ebff34eff4d90f305dc8c4142df94f18bb05e85dafb77f667e7dc44867dae02b9c08fdf08d920e037e69b15d140ad3b3ad33b4925e6df09e6347ea7a6c1e5b3e9f495bdc714527a73c11e46cf90e0873d1fdefc1f2794526e72a54a1222739aa843401c91a85b6b33f23d675ac5944cf7499ea25d621f6c57a14ef22c1decd55771c438c542515b70a9ec6fa5e4a91319132f3922df99d8ae6d16931b89e35d46ca2c9794ac1c12ee7ab9fd192ae0e4d21ac36667f97753ebc25b1ffed754f2b0439bf3c091d181fb7f8ff56ec39d77f3a5c576879e45b18e058b2f28fc1bc776bf83d42958d5ca6c3d831996627ba8fc653241e6162e0163aeab254a379c03c8bcfd2b9bb8f6373764cc1dd4d8e56a067e54454ee372624c8dd9dd74e1c4ed81327c1e0d02fa0a9165383ece0f2feeb2046a6af3871c8cf7126a2e823eab42f7d1eeedd970dd425c3fc7fce24d9689558b4c522876fe8b3cbf2b1cf69dd5b231661129848b64b9f17bc93a9240ada2fc38b9019b65ed56f598945f9881c8b33093bd1077068a83a760f7ca8c6dee5e623602cdfca27f872cabc0d4294fc595bc4a8281e858f4104626f4568e19b886cf6318055f62fe5cc29cbf5060d60ea8886cce486d23fef61df2b1da12526eeb1f6248ac4f0b09dbe8d49e29b09c96fab82ae10029250611acc17700711321aabf77a20bb2cfb7d5dd42834a5a07ae79a5d36fe1d311bbd0bcf0b14a473289c11522827cbd4a39e83a110f1fc96efb3363e821dd7ae0ac5ad825bfdd7ed4230f71105369f7ae85d02875096be07513df42df59de5a80c743707660df6eafa2cc41f9b144bd2ea5d944e09d370193328a204060da7b99f0daa11c817198bbaf12280114441b5363545d26929e7799897bcf4fa2607a626ce0c179388c21a43bc36ef449371ee4979645b7d1c636407092da7a8bb5ca839cc46f7381c173d89cf9861fd3d74aa4162816b5cbc5f80e92e2147e1756de97af179c6d16348d5f9387ffb88e3e2bec97a3a18946875eabdb05823e4bfc1c46a209e5ea7038a14b55472fbb0170dcdbdfdc87cace2c5bd9a42a9892508420a9a81341b40f5069584d2fa8ff1f49f5a3ed114f1c98586fd53835c95f24ff28825733fd8e17a21037736b0737fd9f27a8b20db4a4f4218e5c5a78125167a3fbb3baf52537ad69bf0848122a916f453691c16342651a3707f7fe5e88bfd01e5afeab65f834652b2954ebd0ddb5ae37266fa53a5bbc1fdcbf03184021975c39bd6c3814e2703422db0ae0d31062323f80022ed2d69f7949f5f1ea15eeb69c61e3f7477e56611fd534f10424cdef797ea772966ebf2176aa75c2e1a4e7d81aee5b7383e39037874e72ccb9592990faddfa028fac2e1a818a56f29fd0edc35f2c06be80ad90cc6a80578611a915b7500e9c4f26a7582db1d9f090a842dd35f743d4d8f1dd34e31436f7c5366536bf01ecdfd61d099b48b195fd72f33f79c6db52e70a6a207a0a7d85ac831e06418b5f0418f7467d1d3cfc346281155ac682ad3f849288fae38ddc3a3e448e5de4e9ad941c4ad6d704ec52a2f76c9bfd342d54a21caa1624df5b44fdb078f630f35594f8b262c4af1bdb2e4e9f76b40c06e0aac787b4ca791fb8edac3b0d539784201406ae1e3d89f701b3981ea9686bd729bd5505703529e8cc2c1a01b12b348eba8f37b91964f9ac60eebcb8cdff6262a646f4c388ac90b3df5df6513d37a3b4a4b2b79b283bc92cbde3db2de415a12eaaf4a6dc0c7eb0f9c06adae3b1f2eca8b5bad8b8c50a348941c2c46d863f3369828bcfe1e3f959e1a818613fc9ecb2063c1314a2d057a5a9de514de0849bae81bed0f7d14babe72b5ec482fe74f3a17501649c6a93660d897f9f3b151015c39bb6629d61677ae43ae01dde55434c90cfb406fa0a1195e900ccea3bee16b3fc1bf661ddce6e4d3b150aa58c932ded563b11441a3cda08654370c3f798a998c9b6020099408af4c9e42717c718df2feb3e4cc3e8743789ed4558aaac52483e3619e0101460fee9ac59984c1d6c7e9feb4aad312656561fc89878997a752905474b29c5c483c7e2e5f3c32df92a33f74517695d81cc2669f8df0ebe32b80fc344b60b01bb0ee4d0186c81de5d1c6abc69bcc95a668399c38f9304cf9ed892b6f7b267e2e2b11fb6401cd0c289410900df686fa4aea485edc4f619c353e1035f88e8fba7d2bb3ac11af91094ddc69fdbc67513399b37946a330ba2e8786f13f1f48cc60b5dc3e3b851b7fb0fb4bd6ff4f064abf0e92b75f188603ddedf6c7659ac095bfbabd929e24217b3326455a817e3785beacc94c67b632f0281d932a4c69514b19d00658cec30ffa01ab7c41933914f98b52be53982e25e3694e6cd3439cad8f2f0dab27066a53e5091bac50ca18d3781792f846646464b059394d368a298fecc36f2bc143ca63bf304a311a7dece8af6788fbf58f9b8af044042a8387a0c7992bb9ae21ffa81195c1a047a4ce94f988cb6c237d91836a3b08c340ff6bd0a527a7bd31e6cce1dcf912e48f5593f69356410d3fe26df914bedf4feb8748b653734042db6129350b7487731b367ba0acab04b45a41d39a99e5b0a67e9a5afc47227e0ff93c5755d2bbcad2e2f3ab512a017fbed9bedc6ef2b03eaceba2061bc33bc3cb9ea962f4bd61b896817deb58227c028273cb862ee762c5aada10a74b181ed78ffd48cb13e40f35f95642fdeebe6145437e32cb43864b63f70e267ca26fea95f29986a7e3e22a574079a3ac6500422c84e890c5e63790bde9afde5c491e3fe3da8f090c8570a36865e2d241640f836f5621e9701fcba516789ba65ea8e70ccae6bc93af3246e9060ef0cb5761f784e989d5b30047af5f7db171f6f4cf612b4972dcee6c5fed1cb416a472261ef12fedd3e89a280a90457998322a4346639d3f595a35d7e8309d6d4aef68ec1b2fa255202e7d01945101f4d5c6dcc691dfdb162386b23e8fd3711ba43774eac3e2b9b55555bfbb76bc8e25bcbed31b68fa8bf4661d39a49680f5a74e68f69b175aaa5ebf078673a8da72438c31f62696b5a9d75e1ff59f4817c479d28010a8117a631f3be71019e968a8eeb0f3aa7d5932434b6526b1ea1fb4c3cab8cc71c83cc4724e3ce274e899753b94aeb23b296e3fb49b5a2a1da36b87da0ac685895d5bb35b8c7a45513df4b53e73d9fa89552dde53780b9754c9dec53dc00915fabcc2c9802b38265cebe0b561f693304a4f9709c89cc4b637c01c07ad0a03427b143d39416f9948dbd32bbfd5e39762ac8799b97c46b4a98321a250eb6c430f3f24e72ca7d5b7ee100542316bcb0d2c19b84ee15789439bf50024c9036ba9cf86436f71864be88ce5489dacd43e91e05344c56802f97fef20e433e8a2e8fba0148d7d78dac56618f1d3453fe5f406e002a58a455b690fa1e82a2d0d88ca9d4352d75c9cedc664354ee80f77212c1276077c0d341fe91625f1d245fbaf98010a4abd3f149ccab1f4bb92c440995c4395d7a632a568a16da250a54c610732ced641746e18d70b0197766c30b43ad2b0c4a8bdd1fe443ad4693930dfd61db5a9df325f4e1a27ed3e5c03608b613f9dc58e7d0e6f585fb36799c170a269a1d4f8710954548c10443e3fcfbe825f44faf227952c0022c3d6b31c62c7ff97b224f25467af9d21a65730dac6d66c5b200b0b0e4e6f7a51f279363c4457d10f35379a4649d37550b6d807c84d4911f3a32e8db34e9639509bb5c38161bee52978e760b78627dbb442c77127e6ad764a29084ffcdfadf4bdd4982de1b3fe7ac72ea61a067a9df9aec1ea0caa8246317a1351d60104f10b5adcc0ab3d3b2da8e4f35bd25909f5f278661274f2b1c41926acabb625e742fe805c1656f68c151a2903967122d3bb38006a2de37722c4820fc4d127e2cdaf8202505aa6258ec230212dc39a65ed7163ac9893a6488ad42950e3b67e9f7199cdd309bdea39e16f453d2f137d676ad910d6337705a6989cb93846ae880f356fd3f14ce9f0630c9cdac08e797a06b60e85b2e66fc6353f42229f14bbb128ac68ad5097baa04284cfefa5ad4692ff57bcb41315be38286f9d57b9e4416a70cd60f1b0b37369c0e70e00965b92e80f758052e8121779e6bd5a1368b1cdc8931997a9d32eddfa166ca0f629bd65d29b1cd00fb354b02aaaf3d5f9335aeaef551255103b44d38f264c33e911671c68273968a3f5cc158960fecda240d60829c225865ed2191c62c7a83f6d91c8235538f0d56da63233fcc8a98346f87521444b98e71f7600cea5fe31c20813f7a9d84930a088277db717c94a18435e776a4b55fcf843ac310132cb2aa5056ee68af45114d6a0e9be4aa2bf76dbeb0dbf9af6a364731efb6d184ee43eca5f0c00deb6352d92a7d14f48ca1c34260706e72eef69da729970ed29655202eb53fc1ac9e8ac4195faa448f4d69e68addda2fefeb587a174bb540a57816611129e41764044a31d53926f76be3f36aa87824ade02e7bf3aae13abc48796f715dc6548aea10eec562d17681ae9c1fb7280cf7eaab870c4de33c06a68f11579956c83f7e391b17f31ccf934a8331bb694884b010528ec29d2da9ea917910e80b5c6993c64f58a69150df1788e5a25dbcb45d3fabd1fc8c8d5be1ecf251c34ee393bd90b8663884c2e95bc41250ef75bfb45e674038bc35d515e83ccf52664f65f3e183afa1c974e5c5bf514db2644acf01f1e8836642904762b78ec5db0c69ed5b4e5d5b2d879d6258bb34ac3f84046720e06f7c1d3004de1e3cf26288021806617505568d99520553d0d506afed15bcdd567039efa593647b7092e95048dfd1859bb18044c7c27c3898d3357e4765c60b619701146e6d1d202956051d6ef37b83bd0ec4fb91954e66c05ad4fa6769238a942769666e5fa4d86c16a75f11a84747b59f388b189ac36aadc75971c128adfefe410ee049bfcc8dff23920aa0256538754cd1e7201a5946e8e66d1b7346fd57441f665c67b26c65be49bec55ce686bcc133cd6999dd28d510c104b6d4d5b384bb1f85698a7d8396d84ad4475a4dfd2295bce695ce846c39b057b728dd3793027a023a2808c18218e9bfcd4191794078a92349b0d1a540ddab6eb4d8728c075449229afc1657954f11834b6be454b0fcf1a21b96200cf176d078a4144c9b19e3646806cb19830ea2cbb983cc9f405113be913a23fc2b51035b8b2e3f705c99af1eeb4f203fb805cdd2931cca940c128edbf97f608639d7f3b7ce6d924835f7f72dfad0433bcbbe9ab13f9762941d1a448de595f1c39d7e3c45e44e35256db34664dfa045c2abd7f65244c9622fc278d83f29d3a6284e91e48775c55ed0072e7c2c9e2ae6abcc9d483651dc4db228130a692b1d66e0bd838b6655d73a80a99b4b2e0c41bdf77a262aa9a472ebdb720a98975296d205eec4f8b35a25c1ec37f0501515e6603045397e9f11e921bb9a7ae8e2ae6f29e1745c234260624905c3c43039fcfdeebe8b10744af983355ee55a7c5184c0d18dbe7887c9b5e70909a459a2b529a422a8c66e6e29d18d6d33a1f88c090818d4083eb637870e23758a6184a789aff5029688f56ddca2730c83c36e1b76311df000fc35cdd33b9f4f886cd846359bebb06a81cc5b0c92216a79fcb3fc2c162d37e3b9cfa1ab1ec356551396f8baf00d4cd161c9e1b53cdd27c965a280eff43444b8481b211ae1b96c9d6d9cbb67e081552e9d72505b1b3ae376ab97baed92274a8a7834f5c2000edcc4b57d244bd141a3dc3a54b77c7457d28ff562f93d64577a59b62844695ce024e9a5e2832217f08b10f4c1ee623c673e8dc9a736ff56c8c9091c80dc98fc9baf4163521f36a63054a124b7c4f46105bb0eb4bc9746c6998b8118f1d14f49752273a8c864e52784472a0f0b195c17560906dde94130fb747fde9a40ca8fbd69c20a9b60bf203d5f789e2618458241099299e11714a91659ac2a4bfd6887f0c1f5b043a3cb7c287b9de22b46c04626130475cc74a8067144397db1b6449de84d1acdff94dcd64d1bb26ef68cc8ba24f188c9383509e2d86eefa0e7df10d5e987c60cc92de292909e021755079e89aa853d8372b9bd93ec68ed5119898c72c153156bcad76f9d02da875f982f4184667e23b20529627d97f6aab2f251a027b53f8893ba557a45401a58d13977f549ae0ac65dc81f20d69c10427ac50432055f494cea094ba8d16d5852dc24643de769757e5c66e4568a316c27c7c287e068f1dd55fb4fa9841be7f408feb039e2552c8a731adb7bbb52877acedd3834f6bb29e3737ce36794e19468fe4777f961ae9926893b4600a6142017cf22a326932c461ddff9c9aa6a674baee3bc4c95cc66485332607ec8133a69e4460128ada4932161668fa85167271e980aaeb180f3cc2f8bf6c1aa7e592dd03d79417c02cc0b79d7b4c7673365666e9cb7ccb01ade878ccea1ba280ee9fa51eacead536b602b8ab6ff9ccd7c6a807b5a1c3ca0ab0f60a35e3b587a34c6b278301a5b7c08d9e394da663c0b02f95cb074bade04f7b80eed448d7920a08c4a011399647d1200d49ba8d3c0653fd30b99eaa6f4c9482672d32e481a2a936a8194b28f350e88a2d05b24ef4e7c897bf6e98f363c09884dbf0a9ca6bbd6e92eb5b2ddeafdbb39a98ad4f6bbb6f78866a26f4895e395e6a9e762245c13cc5c38dbb6a37058e734ecaaf77d04c8f8ba0888c9bc55033539faf089ea9c5cb0918d62fc21e504f93947cc4b4019970a5c8f1a8b245aaa5fe1d1706ce059ae444cfcf1622170bb2e6f1398ea230c5c8af6f035cdb78f26d8c0da3ba4dec956b2664cd44087c2a9733bc3ad8474cdbdecb031c6e82859bf1c4b3f07ec6ef7498418efa3c598c3e915063c94f5adede7ee2e6f2f4c429963a5d92f17b3146c666301429a5651a96c61d9d405238e00010c32bab9f2b4d3282901bdfb16ffc5198c78a2cc090886007121b9151054224734bd4cf3b8c5efe1e28594f097e179ce3915abc86e89b3a5a0d0df4909c388cd201fc01ef0a8c4046014bc453f9d27ae45d163f301094d575c3f12c32535a1ab5557231005d4a21f91bf4dd671b8d1e0523521eff59e02fc4934257d7b784ca3921bb6c66e6cc35e00641afc72618a6f4a28647d04ecf1062d489a6a1ccdf474d1c7ed5981a4758854d2a730ff4c2151a5f6d0335f3b7491f36cffd34cd021fdc268b3ae8d1b0623f1f05f2234f4aede23dd0bc4e272e90c8de175c7393820d2bf85cfc87d3670ca025f8d6eac1b7a179787f7f3559dbe7f17e654bd2dab3e810341e2e52d5c7e79280d833aad9ededed679ea64b0b24705a1e2e6a4a11044576536baf5f51e0c6c606b3eee01992afd0de6280181cf76ecf62c108b8aa05f56aef32b81d54a249cb4b4e1a5e89a8a6655038ed9b4a232a080dc4bec91a5c1e553549b20ed2ada311f4d117bb90ba88f32c1284660a536efb40be740038069d2f114789668e0da825f713eb71e227d75f86d6f0f318f5042b2e58286bc1595002a65ed48e4294c1960203b731efabd0f2d4cb37bf4b7b6a07b65a3214644b6959266f6f97c3c5aa2e99bfccf8690b6b462918ac227bb64db5ca649dde1cece7dbfe18d206705d0449f986d997485d665b168156a7215467471e6846a93806c568d7711a46faf3c74d9fee6b2cd853a0d87209e3c43f05e573d8582c5256237f7ea7166aa6555d6e427d42ed3fee70f3c8fdbed99fcbc5b01b6931af4af95d7344ee43cba2d870f13565926de871c43c2ca710af751970aa8028a88fc0f2244080f7ac13be6c08654325159fcc22fb53da029c11fa61fca0e7c4bfec341b6b29e69006e724c0c91576441c17af1f606a4d6834083b8eea7746a1265381144b824b82814850fe582afea2bf4b32cd6eb8074b73ab7bf177c5c32d40d9f5098cf925cad92e0fe4622f0781c362363e973e4a747826a90577a2aa9c0ffb4edf68b693560f02eda5808eedca117777d50d035a5fe2519997c8ba76d55a3f7a14ae2b3f91a5e9d8230ebf31183c784e70f335f402136291fc2aca43173412a721a8192f620b348e7ac880c60f36d6b7bca08af5276ed5205747e499ca4dce50561ccd8ccb5e3d0069a5b95c0437581d3cb00385460d741ba617a9cc70d887ff1db0d61fc2971bb77e53140d972e828c3c16016dc0e921d294bd1f84fa77da79361142c009e7819bd4b859220eabf6b938396a996140ab5d88b3d59cdf21ce142531e181a8d857749b09349b7a7c3cbeddb581e2201c288f636b55724e9c7b5bac396a564cdb58950f45697dd1d0c41c92ccf7cdbdbe4bb948b10c5741ee2d7ca1304ab33a0e69f2eb370fd83662430d40eb31404009b1bf74da2f39f3c9803a4d7eab55265adaef721580c6c2717f9f8b98a805e84a14f5dd81bb72c8f933c63523534711988840963bbd4a8c1110cd8c69ae06a423e4fa99c37ebdd996caef58ea02be2c90059e9d2fc47510e1df6bc6000432b9d2c578b8015191d228ae36f2fc288f7e12dc487c564afe873d070a2a6d668b79ad2c5a162327b4afb6ab00821b74b24e2a21587c2991675a41b07f806693756d58744f52735637c6a446b48e6914cd10480ded6f86269ff2dbe4d60456afc83243a7a6154b75c6d384c3dea5f0086b44c12ed4abf2a8889b68873fc7ed8012d1869611b3461f505ce5911acae15fca650253aef1612151ddc6d69a40992a0f25428793813fd66d615fe41450cfde936142dfc51cfd94e459ad244120534735b512fb3b35c75a51e7d03cad86fc22d83a6ec1c6d500ae6be7545174398d89f459c7be896f4b407eb33bb228fa3ec9ebd8d852d0e9840f11880fd2bdde1a29203a794cf3941e0778296ec2e68ec401171c3695508c442a1f0e34ceca230551da25b3e9b90119fef8a37a9b2e9caf5ba0c0db21a02309f90e6630c15d6940d6b433430b5554b362dc654e372225d2d47abe297cb29ddbc9e2341417699ff765f2099f490efd4e56d5f656cbf9f8c1f59d4e8c2204429a7134aadb97713863da7dcb7de280b66a090ea1b1e3b69d0af97e7f9aa433dfbf3c4eb837c22b7b0673a28f4ab9a3950700c9b5c31bac3091adc2ed9fe0d900f632ce44d598b2b4e81e335f6bccaf8cc1ba63ae451a25657da6612c89569facff8de45a2c63bd48edcd7552a0b788239b1e86da32129c030a4c82814be9fe8d3d94d79226e4bbe939c6dba64ee9206a8e9e104165b8e83c535ac2e4b1119ca6843159f6963f811a80b717376add6a17918abe972947aa624f9441473e99aa46f244b39be85055e40b9d6cb8bb74b6b1e8c109061d5ca6a4fe4df6ea6fd39e9e0a293e9fa7c8041a1ade90a2afe67d45cb5e7349097f44b8c5d4aacd697c68726c8d7b9e49d542665692d6458eab77a6e0e9755ae9583ddcb022bf0aeebc0900dc520ec17b0ed69b24bc2366e38745ee978d007f4fa1443c3ab6ac560cce4226f011b808b04f5fd2cfcc116d41cc6ed1bfa9ec50d936518bbb4d0b7980e4b1bf7f3acf1fb7688dc8349c783fed1f97065cf79bbc9f837555171225c0bb6ec94e875570c51894726802b2c7fe4acea4479c5aa8b5be2f66355a74ff3715ea270e43af7dc374775816d18783d6ea9ea4dcc9e54342a536a7d034f0d5a466f7b87794e6e0ac36c921fa288e2f582ce760147ab1bdc68eb9390df01cd4439c110b33f72cf2294b46b2b5be36e879d8bc500b1bd972ed744d86b02381d456fcd9e3e8d6ff9a15f61d45b081153ff16c1d4356670be41b811bc9a2cd4eae4190d9ee20eef0556daa5bd50e762f0861b5de47101313a8731d00ae01f2ffd42c32d41d3146d4dc3aa953a4496ce3accde0d28253875168aae5d6d8ed43349553d871ed106df14dae7307737a9b0a17458be53da92efe9419689506843ffd70d5098d49a48ab32b36bf87f3fc9e793211b1b9c37e08717f8768c3781d8e9cb4d377f9ff25d628f461b51c3863c6ab616b21cdf1844a871b7f4b2e8e1cb3e0c15496ce1b16e9b16eb84946614c017d407951b21fa186d919e287b82ef0124ceb8986dd889ae235042fbaef39090c38eda74651af4a077af9078806634dbb0eddb5862416280554176ca36e015b77d1237d0080a1d999f759712c59a10f5e83eeb03ed0e51bb9c45ef01e8eb8ed8126b35a1589bda2ae7a1afd561474a66eb5d675ff8a1a62adce33606f7cfd6c8cbcf5b55f678977517865889edefd017e51d6424bee72e7656a940dd6d6b7fe9d0e973065b5a67eb8754ba7787a86e1856a2505d0be4b77f10397e9f34afddaa47982964cf4e92c9c0ac3c2c7dd3bbfea6b977d0884b718dd5967a36b3aa31f987d81adcd9d12f14a6ca137cdf6e05c0ca0ce44ed19aab5aa240a480835e4186e21edb2a1bcf484b7eac1e15aa16b91ff89af50f59f797523cb3bb32e35886d761de47d8ab00c8d8f90aee50686d42f6eb5321c1f9865cd25a049a902715cd62109b0be90be4dcca2cc4e63a28cdc64d4917c9631ccd5cfeff76f10203dcc1f7cfec64fced8d3f54a07942d3bc9f9b453e0a3ea6c8df0b8b1fcce99213fbea16b87b56a5e3f75269fc7d688d4c0f16acb8dd3b717a1236a9f4815f38ea576debe4f0a1c1323f6fb6f8170e665ed0ba7fea9ecf016b7ea81dde79c2b8bbd60a84fe54a2e16c24df74c97ae33c5bf08b7c9e4dfce604f7b55af693174e265e6ec5bcf96efa7fb615f5139a6d6bce94d3398a0065912fb239cb966f800fe6f4936f1c7b47a7db7b2fdf64028dba600727ab170e04447a4cf16ad5b74a4db818794f77515e58e157abe923fbb7ffd508b0625af511355bb48b81c5000165121083cb9238d363f04f30677561dbf6da4d05daad4971fc63555010002f1663ff2c3fc0efa8f27f480642bb9bafebc786c8350255e8da56cd73e0a3ef9b16956d285c8a77e5733d2000215e2246e0f512840c9c6922d588f2e168ebbf86062aa5e8964a24c83ecf98b8f02896d17c17275d9b674c488328c7d98406a27780dc9dc6494c4064d9a9af802e3d41577e146712e16523265b9710cb5d628d6c997f133fef7684dee1a5e5cda5123d9b15712d6ccf09e4779615bf11fc1c4caf19036ad0117c7992960da797fb633085797c01a021eb3998c31bdc4986cb529b94a2e293c323cba46c8c016c55a706d73de364a484a4a0764da5248eec969805152773b99f8a2f403be7a97b4aa14b87ca50665bfc0e587715f555501f27e346af20742d3fceac9c2a577db52689e6227293dc7a73695adb5c484b72175ed35aaa009b3b8f7c374eb280e5d53e774205df9f66bc9ea3d0bbe953ae5933de2cc9e8fe8186c9273bc95c6175aa3f3fa64611ae8d39d7eecab6733db853ef649a21b9da56b6106d649f2a3b37a128e0938954163e90072549e07b00bc2e1c3704f922d72617e670f3c01b277e6379f4fc96af16618e6052c678840b89b4ae126fe918b2a36af9f846e4b4b010dfbce8c60f3cd93ca1ef673e3781a22457ba5985ffe97456cb8cccdfec71331fc1b77ed18aba0a5e16fb3ee738935584e6cd200ea588da4961d851b8d8f721c4d03b02fb590479d08f1fec277c813804a45eea04d195ea6fa261ce4cc245a9081cc53f14cf726bfeaf47931ff0e873fe37f4287802474f0d3f36f877d06e6f07baae14edff434f7861f12045f85a5d0e15be8e209f763067035e8a805d011e8d1321400392e0fc99e8d9e9af6fe8d232fded8804a84eb43cefc53be20979af1b0a2a6b4c50ef2be2390595a0d7217a53b7a083efa121b0b0c9832787c1305d5650006c5a6224efa80d959126049cc59d68c6611a2a2e7c281472a32300871b95c6e53755a895a7a29499e45fd933adabe54eee6ac9bde921f7de8bed71aceea9edc5fd1d72d3f45a692762dae5a41a9a227870de62861b6ada85e93534559f651729d2f919e698d82b45d14c747ebdd8360d923521cabefcddd7d56bcff0899702997d9ac14e14ab33d1f4a58bb4ebf67bdde55b4046f154579709eb311410aa8163fc3913d750cc71ace6cee924f005eec658bb4a0c945315abc239da7dcdcc7779081dfe0f25ece16e43ac9a2c82541e4847f433f14f103ded52fe0a14fabe2e4337a63a610ac030ef35a788afba6534225abb0d9c06a353c629939f13ecd4d9a77b6e321aedb0e30b938072faff3cf3efd00afb205e8c8f530666fbaf2debecf8efccf10228a9b57d768d0e33d579f84fdee7c98e370f4c0cb6fcf23fbf09bc0feaaa92eb4caf52a6c81a5a64a3e13a5897d9fa2c241f89d3b8b90aacdeebeb2ecf698e8d7d2751aacd7171801c4f22da98ba7a16dd800a1f7191de67bbdf00feda1577121659ceb06494c5ec75a1ea08530a23ca8f387df955f921d3d820cdf7706018712c245d34b9147fc88a86d02a0b5dab72cdf7aabc6024c73630da6e03fc5e077b4bb7fc67ddc658724556b5bca86438295ee095ace7cd23aa537472e0761f3021eeb5a04a317668fbdfd6adbc62b9e31559adb720dd64885906801e1f90c45e4ef67ece44e1751154560e84aa77d04575baf0d6f685665731e3372a7ccbcc0c70e46e3783e46232cdce09cc19aec6a952fccccffb7a6b1249f5e8affd8dfc70d22b04b8f09e87347e702726a66a62cfee0d002a550fe064af94e811cf6c296ee699f207e4061791eba0f58ee079358320db7e7cd5e3dce99d3b2c088fbfc4f08ab9ae8259d0671cea7f1594cfc42b8a66350fb1b2270c08eb9683d33bbde25e742965f8de57652e7e7dda101db8432617955cac33971520785a82e3b787f39e13202b1a784333f5e7b834947414f5cb7a37941ffdb0cb4db09c427fae17008aa6e3a864f215aa5aaa5b186ab544316c6e3142e1281fe652ef1eaebd1ecf8409b6f60bc6751c22eed02be6e03df568d5f1dd50c6c52516a235978d8a282d39c5cdba59d3056532f9fe56cb944d94402fda8515f67f64a6d5ba3eba1381f2bdb4ec20362664e4fb94fbf22f12d78cbef357a7406705c86bdb0fe943d3ea435eea82bea6cd5906fc18da9e6d2ecc27ff56afbcc3b323d845f3765fcc33e1f953b2d6353440929e4372aca467f3f8aba2f468a385cb801574985e134178ab10ebec5498288d2b127267316d8c87d501c3a9804bbc996fa08c20737067e6a68eccc939a0f1a95ced7f0039a7ff10268082df47a76a0607d1338c28a8fc447a95524a470b54d553dd16f297178135f7b66d1558b7c7ff1ce06889991b7e36d5294a74e69a9b67b1ed5aaf291d14c0f1143a4b342eceb7d3a8443b0a5ec993b21d6c4976305f1a6da59664bab377f99b41bfe10d422d2ee8997d5be00337f85dcb0d55f98da7200d3e2ab019641fa6f757737f212706b8002df6221b37718e865200fba14155d16e2c7f1966ee1e31a48807f9bf04db544b7501cd12b75b8e1f15d2ffc6608796a08607f8aaff106a853501fb5c9511485825504df3f6dafb6892f407ad1196cad2d1039c01a0904a7b47867804b96257d8a3085dc27a4cef93f2111ebeb28316474ce41934e27f24926bff7ca66282a0521c5e2155d0ad603a827d855f72de5e4d4a1aa4bfa5c327be62999b4fec382cd8d022d87cd90de1e9feb2aa0bda22e3e5ef8ef6b076a1b18ae09be6cfef4c98631bf6298cd7767bc942b35b453c8685c25bb51734a052f5270e0220ac0739cc7f607e7b4bc2606c37b4d1a2c20c8017a943cdbd9081eaa8ef5bd0afcc45f07794ac20edf215cdda59d39b8c041d05d14a53e1657f322ad3ce6bb62d11e6c8af79e15ad56dad969e2406b3fe8a468c2a151b2f5a507bbee9b2644ff1f9827f8c318e4dd0760c6f43d7ec1f7c382f348dfc7536e67f40690a7cdff53022d391362625e1c7aac677f94a32e39ccba548afa0c70d38a1f6458137e28151","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
