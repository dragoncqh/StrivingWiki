<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e9d4d2e52c56c06f0067a257b74767afc7d5f62fadf4a926ab50c64c3701dd1296a182d4a13f1b625138ac3e25b4f9cc785f060747fb4a208f521e3769ad830455d75eb4febbba74c9f1140c306244099e8a16152addd757de02788207f7532611ee477e71c06c54f22106235a823a273586d2f0f5c2c871d290fad87906cfff4783a070d24b6a7c76465ce968f994f23c26c68b03ff94e0c293d0d5fd364a09f30032a40bf9613ffad79e09e83efa0d57f517416cf09305eb0a4e43f2030a26729e03b8ce8cdeaccf41a26f36c3e04058f6875aa0e2d943b5c3682b368c3cb3cd323aed1b27abb150e5b74f8b52a9576e5eab48d351011d3bcc08f6d64cacf2488f558312832af9f9c553bf95b742c831c192a902ab0ba9775ba6a7028e820e506aea2ba55b9940b60f1fe2f098bc471c37b2f8cafc6c93d6d66f71483401c455ccb851c0ece7bd691b56bda880b4a26c57075eba1d9a97b107ea579a33475aebe0973fec5570ca258630f5bc919f8b291137edee5b61fca369e7d98933efdde9547ef20ce262b2aba88a91572ea7a9ef2ada229867f6d357975f11b849c4a590c2a541f30c1155c0ed899a8d4c103a6fdf7d564de146ace99aa3eb402e3b512f3d35e6d3dc4594a84c885551a157c33de815b007f31c6736d448495719c1a92d3f96623fc834933e91a952177ecf3604138b960c7215e38fdd48817597c0fb54f18d6ce1c3e6c1f09ba302f59406228e9d4c617453054000feab38c06b68b250d6ed4f374f3065b026c72dd3e3a218bcb6806e0c885c76126a0697a169f6ff0c04184cdad548f34f469cee2084cccbf87b29a4ce2cf5158feb50bafcd9d97c9998a2ef80241462042a47dd34e5d08d59ad1bb00c036511b8d468c19656179b3775eb2ee6893c30b762a51ec06c78ff01067564270bf93927d26881f352d006c4e14a187f2b5b9a994a5128e519375a2a77638025195611770b85a3ff207a1c896e040c8ff3c374b702fdc792e6e7dd7e89c691b7c779457bb3a3409a05ecf4f69da46bff3c8febf7c9f665602af1e77da03896f1db0b541b30cd904067e21cf1f707b3d73e7d623daaabc0d379fbb1b8bd1764b403b730c05ca09c9f3f586aecb6ffd726b93589e976dba14cf5c44478e86aebbf50d84f7e4b5c9f9dba58bf50c51558122e34323b80b8ab0213ea89bbf0f159bf7febba3946d20a142f8a543cd613bb30e2555a71f595bcc4c289499b7385415c3b6097990f921044a9831c04905affe2fb14fd734fb1c89dce80c6560001581a40ac2377dcd8843d6a995ff1f95fad8a3f3d73beb541e4cadb561514b585e667adc005592344aa85d809ca08d44a9ce102a2d85eb588403007897a9d87cd6792c78f47ee13ec93b7926a41143f97f09a5ac284a67751287837ba6fb16590d10b9ad0c784e7bbf9d53d351e1fc2ac79dea4f12505c70797b153e5cc2eca6512bd593027110267d9810d9aae38cb18b9e9c4c4d80c778b9c89c6acbf08bc12b1abeda5da2653b65dbdcbfe8d7f41ee66d1d8e7c46a137cf4776690595b12a7630b75be470368bd2668ca873a1f93f1abda77d7933cb1dd5e884f22cd0753d53b5bdac3c9363b4d1b94c37216028696153c6fce378142ac808ab6271c8d736f037808f9a2ad1ef4a1d24a681a5ab5c66ea85b850860554af334b03d2f81337f4fed44cb256318166db104872be5e0ac9b33ed6faf9e4be84ea27d2a840ffbfd9691a6e5e8fe3937510d05f4e6f7cef72ef326bb86173e676a5eface18738fa9fa504ca3d1ef46b178b37fb51937cd9cb471a1443ecb75e58c02c31bb892635da9c72be43b1a89e1c0f5d1334247040aa8a12dcc7cae44cd2623b9942b34c1397010cd69bb992c1bfd075e5a3a3056c1b82bcc2df05c351c8f83a9ec3d167c9c6ca919b474caca6db097a705d0771bd2957798559adae86af5411b2c383becd74e49c219e5e386f04374f0dd23af6c6845a613cd4ca584ee045d0ee3dd241af318c1c09129082f76150bb04e858744407f9c60b8bf6138789689bf4d1f01ce4cbf297244f8ee19282c776cf875c698399e6ef39a18a1adb9a67ef362bc649b91599792bbcc439d87d383be10ba5c16681c35340e16e562b1526bee3f8f565ee3ea0140d175a544263a6579ac615043c0522c0d27e17257b4f3163c99824dd378475b04fb7a3e6b193b29e1d24f61bb34b59c3e5e1bcfbe5abefb79c09b4547fb89fad678e4ef92c782f607d54c32b1b597515cb7510fd0e777c51d7df3bc8227ef313faeb18a4c56feb26f247d9203af84fceb0ca5619d5577c779820ed3303e0ec2fc5403efc0ca7f78a2b5efd3fee293a3c0bbc324840f8bcbce56d93cdcacb0ea43a0df328f713bed412691fe3c4c18672ea6d58151d8655d2de2ddb485fa59f320aa5bf20017eef023e413e58e56b689feaebe4753291c9332c462f893e25fd2b10018076328c96a756c0175e2303f5a60875a4845390af788f30cde572b6479ad22191751da965ff3984669b49b66c09a1367d98572706b53ff686244cbe064a2af5b90c1ccc348aee7af8a7ef4c879d47565ba1c17d228894801ca6daacde130d1a75165cdaa117e6941d44161831a7e3dc96d7a7bcec054d04d3eb91a8586a20942a82a34ee9ded778406452efe759628135c5a0b31d362162eae7458be8f3f7fbf3af92eb60b5094ad087ab67c9cd9ed2a68b1717231ae29cb71c43c2ab348251602d67e52ea90a5f59eb06ef5f6528bbb0e1aef62e521656a3d5860e5c271ad59b1ed9a652dc0e94aa124879c5fdfba9dd3a115c70656c2c6934aa4f4190eb955b9f38eb9e134ee8e230aa31ba78a618673c7f3b770afc7d67688843da58bb5675af5e9db94d65bafa40d024bd80feb74ba74e3c7d4be33a4832d9564bf52a23ce56fda9443205e204f7fd82324742430d5d3d11b133f70efd89b0bd41e680170d21e9f1d939fa178eab2e2cf8c9991a40c00e8fbc5b5d6cb82bccf3ff957e829b408c2f05c44cfff72024914ebc91abb1a079bcb4a421cf7a702cb9f972a5699f4354505bb793adf93efacb66ba2b22da83b95428256b831229cce2662091fac43fc61c2ac09fa868fcd83a6f3b9bf391fd1a07a73cc2df8ca5405e67982148df7fa1b6da28781cf11dbc50f68f3f2a8b3abbfb7f95b53f3c2ec05ceae58c6401b10f7fa386bb53bb2f707bc4a80d965bf0e9882d2941c1b1699609efd1a1310ed44647fb3b81503c50a9233941b0c8061c4064b6d73f0cfb9eb757ae35f6d0117391a26c469afeb8684706c9936a3b6a3e0bc2b66c58880e0b6edb32c39addea315b6558d876eacc1c1cd88167a93a32542ac6ce75791b72d040d0fe40cd3ee14218b77b0901c0b579911562b82b467a6041afcba225a4ce00754210414bb1711e3d33404a54a416a4a28134d8da01e15cc7288fc77d6b2daa7d5cd7c36f0948526857bc3d632c91bedc7da826f6987806eff9bb3c35953e9736a0bb338bbbc690394e1674962b75bbcc150d1471e770b73fac3f1ffd7e99088126d733d36aabdf586a554a0f0e238d6a4e6a4b83a5d59699bc81473626a6e197d2ac2a407e39585fc9c3af17e09d931e3d9c222cc2b4977e315e8c10dee14eefc40521fece3f69c7f79083f219689432ae6a706d65e1eb3efb0beae8d4b3fc2797eb5d92e32358cd6b313111e4c8473c41555ee49e8accbb942b44d5415455a147550afb42a88f1b149e5eabe51294bd39b1257ce12d6cf0b1240da177f9e9b846119129968670cb43958ed64642815e60e0e81c082edd5184bc8fe70e9afa61efed3c891ee875c11c8504cc564d928c1eac03f0c5a1316f25038e224b7a03ef7056cb0825de75bfb41e9d2d756d8ae19e48e474f34a60f49b659257189cbfa4207a0d0b91ebf02adcfa57cf515b78ab89da6d7d064b20142bf66bf6c3f4d423829a0579757e1603f4d829b041fae59044556525df600ea6230fa346d3729176dd2a36999b8bb869c0a10e9096053473f8fae5e688b8b7e335b923442be5eb6844ad60a8b00a4be97575ed73da7d4f29c2bcb5129be1da8cc04ff859956b7e9da4f90a16b81f801785edb23c99fb72d117d341ef317a2bc319266de6b36302b0561eb764c1ce5e7f92c4b623505442274740c82b9f1790a24005cdcd5b632ca7e5de23f240ec70a1c399eedc3b141832dc28241edb339fe90c2694cd23ffc330545370159bc867fbbd1d16b081578696b67bf4c15cad30bf48e4b16dcd0f8cd3245217f4e973796f8c5db0063eee5c8d34aeb47942fb1e117dbf48a8f9233e4bfba7609c5b6f953189399d186a88dd314eccf43a266550794d6c6c772f2fbae80d8d34a2031e5c42c0c45d0301ebc533abdf2445d8777c0cda8ead59f275e5f18dad9053374e58cccbd625b56041f74f26488b4e0ab7c571fe7f973f70e5ac1d33d6666c9ea0b236baa6e95f84fe47e7cdba72d5e7632bf2e193f890f1e136daf7932585c8ffc11ec02b3696e924952e6a3e9010689d5105036912fda9a2ca5a1715516a68cf88a9795574bf473d7a956d749c8152cc58d5075235086afa34ad5abcea08f4a32e43c95355a4e2157562a78ed64799f2d5febbfa6dca923db1bbd62b6d354ec3ead252a7cd71004d9e3b7f837feecdcfd00b4dccef017479adfa0ad8ffa9ba9123df0eff976f96b24166f5d62f9ad192ba41e1ce6332bd441311f080ecee3865ba4374aceb284686de2e9edb463fd54518fde677da61ee122018a87c0aecce1a85b98d20e1fb203f69c6ade4edfd169e3b215ce910bcdbbad5b718ed13a070e58090732ef7e6c7a49d3d7243b2067f9b743d18b78f151f9cbd22d381ee1fb25287758931967c4a99c447fcd21f512c59e03a5414a1ecd168edb8740ef4fd03177488b72b6c8871547cd0569b73e23310c7b73b313d87d58351c7f6b61d259cd4ae4d35e77f13e6767ed958a5dc18179bb6d288562286af22dae9bb797e070d0741e3a01239adc3d55153fb2d4a9a23cb24105fd257fd2c5b7447e7a13903e4e57be64b322385665970a8aa63234dc6a9cb77bd5115d0d349619a722cefcea323cf730d7024f4798399dba7d2c9d21d289f6084b1c6d5aa37ca289b3855571573bad5c1f997af31ddf1eb245e180831bb00765b6d0da092130d1cc47cdafc8928c3fc8d47868ba2bf1b765f5c9941b9370ad049e3e6cf43d3f83999b94fa48bac498798fbd8265d8f989cf51bd86e210bfe4cd11443184f762cc6349546064cafdc90de4f1422d8ec008588742abf1823a9437ac305b69aee800c9c1ac94e7dca47782aa0670b3ce3072f7f72e0d2ccdb066b73d73c2951f586ac3ba678b88c4cfa803850e33f27e88ed3ba86a4b450a409453e9e4c60a48e67363d72293c0c9dee53ae452de9a8e9f07e67cb7c2d248c2b485f7524f2af3f2faee6916f927418a35b269c875a45eb50ec41701c3d9554ea24304eb7b9bf42d34f986dea4a020ee841f3312298b4537b58452389911b6f95ff6f816fd8144f250a6a1e95d940751815caf430e35b0e1f1bacd7570141af63b01813428b75e8f6e3eb4fb6f5bfaef480c38cdd5873492e6e598dbb7f8854c74efdb1058ff637426f6d4c6ec46736100e927c3d1776487beba4adcaa94d4b5d380c2ee6d16baf095355fca1c3c5f5cf306ab2a797a1f130bf13c44409e127743f566eaf3f77b35f36119d812aa10cb6db474a81dd1f55963fcfbddbd8cfc1218fdce3d9a180b0b1015ea9ae2d5b7ee92bcba833b61f7249ad8e3774e5b5277ce88bf844530869cb37bc90463a0c63c8bbdff52f2a65942d24bbb6d3163937ca6e4bc27ab61eb4028bd125895d1ffd777963476fabc2ceb07b9d4cb79fe880990287cb52fe5a4c929be4933130eaa65b4294bc6d22a808d61d4e5e31e2f520a4750c2ae53583327aef4e99c9d9696527539eede01848a77e00a2d535204a7d2a4beec9059bcf6310e790a3c5cfc440a3ba6cbeb0f233e18a95c352720e23daae97b5843742e7dfa6fbe3e82c79b633fdf5ca22d5b27d9f3813c7c1f0c346111dba53d0332b9a905c73f8d9ebdb83c35e2739d271602c9211b17028640fc80b801cefadf7959601c537e95bd6de65f46ebf309b94ba697d8fe2846f8e53e6b338d3e131a6b3a7f5c3e135779f9e313bcde5b30829075d7dc3dfdc49cc726663079c53df25f0e069d5a3b72c403c8ecc6131ceedbf27b91a355b1d54fde4f0dac0e06ca36d4e817aee94ce2f7f89717564c2a7cb022290126ca1954801bcb2f379f0ddd17358d4a43af89bd938498a27f22cda91ef6e586a23de3af35e5b53963aff6ea4cb65216703ce01ee954e1286d90b488a67eb8d3673cab75f00c4048fc5314760300abd8dc01254628ef5c86e1669105fdb35d2f527aaaaed9f5a4a76b0050fe7122e19e43495dfa5ed2f66256454c3f5fa79ddd110aa1d3ad59a2c060353bd166e52a7252f1c0849b3686d6c2966ff6d21ab5564ad09f47185afc44d1dc996269048ba487f2c80b12c78b8fdcb0a89e94e202a75ddf239aed2551db250d88dde188f1fb825e9f6a14883e2da64d3de34d10f59c49692146ec833d61ee96d73d04fc9ea158fc7f8b26e405672c4e16c5ed8552077e514c67ee87653d5e1a8c3bcbc024489ce11263cca7c63df328d9c21855c5b2c17e3f1f4735a7a067d675c3705a3c8aa29a09e380d849c396b55d1648eae32261b4bb1dd584f07b238050de2449ad00d680d08f88ec4b7299e7b03a2548bac45180a86d8d6d41cbfda5da678fa00783c02f93aa51b43272d4f310fdcbfcd54ad81e09b4d5c8a79e35e526994aa80703f9b7188d703a5afab1a2d973ce521a99a6ac8d27e7a53e04e85ad6441330b1d6734404ddc0b3974a0e6b50003ace7d198ac1760fcbccab5b6965e8ad912ec48f03d6825c5d9214f0ae20352ff29cd3f51a989d99d5d96368fb760f0518a00de7dba7f7b2653f74e201f95b0702ed1249e6aff3c6f014d7060e5c328cc82295aada8bfd083293a41a45ce9a423c432d3dd96175c39f5a1cd1f63ce3f98b2b28afb81d6131f2f2fa4a337a1ccc303d958925324f1c90606c749cd362df6c048093f10871864dbf894e21af7579c0f4dbd1a7ff2eeb2b7d1216442818e4da8c87cfee6e6f6a1e55c3385a8ce28d9c4973e264d79ca1b601ea5bc0f11e16ebc4e11c0c18d8f19d7d62e5d252fa6233773969a507f0bd07544658fd460d878e505dd3ea45b35cdc67246b77c07f396f966640b695cc2cf3775c71f822301bb26bfd8e17f1c7ded9661f212eb5ac0af997e320fa4e3503b22f076d5be1f2fa19ef23eff1b199c67b46a1fadbcc5a18082b53e7f0a5fcf1d010e0e80c714cb64a2b420af0520f054176a48efe910c70fd2cfed587b2d80066278fed1c103595a9cee3846a0871278c803091419689e7607e6d52375dc5056ecb05660978bae69307084850634a6936a2cb05d224d008a6da878c23554e66f03fe4d65bd0acd0011cfb8e551e08000c4aceed5386879988e761db6724f009fa6aa26b2f634500106008d03ff50e7df7e8c2e6b455f8a2795cbe772cc2598ccb44025703e57e0e69a8719908650c3d4a5c3036d6e4c2883b572902bb762920b2ac06cf3eab9e495cc5484f24e6cf29d1bf87341ed0c520e2eebb2b556bc63d4fcbe1480f37c082714e58e65af0a8a627d1274aa9e80949fab7023adaf487c08f7d56edee7240e4da1fd2b1e7b7a50e78177bcc869245054f51721de84c3205421ad7cdc8e7ae70e6f57904387f53e80bb302324cf2a6f488296fc17fe36a294781c7c46817908c6d7d416ce67302a239d819f815365f3e4c2501c9f4feaab2cfac9abfe69598df91e26624ad560af293c335dc15e3b9090193dbf8233b72511984b4cb29dd1eb2e91b917380a1d89421cbbef19aaa2977447b9ccd6699d549cde07edcaa59668acde907554a361b11bf963361f7c6ad86e95df53001332290a7831af8709682efe99114489c554fdc7c71b589264e3469186347bac3055294f4ab92fa26ea2ed67bce224a0730360c1514d2329e3f9210de634d3b41832c5c912e19cf251dfe2777851a3d2dd6e46ae852373218a6d1b1a7634c8ab86cfa50698882e9696274aa69b188c93e66654e80ae340a0abeb12e52140d8c75864db9587d84c6dfd23c6ad04d958f55b0e622b75cc3a1e5dfe23385f2bf26a0bc0546150c60204a8c96c959074c133d7e3818ab6b4d2f440408434c2a8d59ab6204e0bf59321b0757994424659d4dc03857c06e25a5032ba8a8509dcec6912af1366e2a6b5467f073daf54410babb73604d6aae2d0fdcced817e15a7be85073c1f6fddc284fd1e70891ce3ffa985fdc16a1dc8fe5469e5be70c4d77187fdcc21b595a2408939416e94c14cb2925ff83fd539b9e52a9b3e668ee18ea19aa15ecd9861775cfcfda5906405095d44183ace43646f6211a9a7f5f9d31d1b9aa6571360fa3453474a69ad274355127ac4566d3cc7cee5c3d179bc33e3dac9db046e9903cab19fe9b7f0d3d0eefd8a3aeb30fdb75638d4a72d4e9ca4cbd939f88471278c651ab5c82dc263f7984f01b757f63d2479778791763ddb18df39c9382cd91da774ba6184901eef0a264777207194055d20c36c57fed62342bcef454d78816b5c2d66bc7bf9acabb2ee520e2d626d31a7f004d06eb19b5e8ba84624faa270aa02aeaa4f3e94c2a16c35764a31ea92f341160002f86c57a0426be1074269a27a238dd00f7cee95f0fffd4bd0ed20f165b19cefb554b00fa8d2ea42e03b5e0b86dfdf33f90e04d26ca003157db2f96798d9cc637292ed4bb561855eac46e64cbe9d244dfdea24197cfebb61171d3f0f6830a607963505890253882d4675b9c631815dfe9d5f655de5474c0612f2e1d04efd8930fa3395654aae824fc8780eb22fb8c8242816635314e9c29a1beb730de17dfabac2c66ab3be83a6b01b29c52cc42ff3d32eb4c2b9d1e827c56d35758484076108e149804303ae08d30f591bd216b8bce2070dfce9f5709c733d269da986af8a3cba20bf37ca3a84d8252643b797152dae228438508a6410a677c42b6dbee9bd67536a3312aabb30cab0e7f066ed55a5a368da0b4586ba722ebc05ae4806adf9feb4704fff04f5e8443c5e8df582e23c6abf16474db6a39eabf334ba630cfb873444af934bb49e5f6c62409e666461a021e29241dddb9411eb84f50eadb63921a12ecc6acd310b8a382d8a55aa875a943f59392ce0f4193af40305f924fa47cb027941dd65012173711e8fdc3d06a03c5bbbca2e5178e488e1d245cc080c88da0187676f23944507a33b4b65e372e93a9a62df00cdbf0d9c724ab7470cd95be4bde050e0aed2e97a58b82b70c04435c1793eba4906379e3ee7f638020061e9c5fac44ca44c710ef14fc601f28b8e13beba02def0b39edcdacec1eab6e4d181880505802d2bd421f3b8c6876df724fe6abf2f27ba71277851cc06eb89ed1eda777609c6e03bd9cfc4f31822df6e5527564e747f668d56e17f3f440831e3013740471d2214a08625d126407f94065b08932b90190d31c56e6c92b010cf49b59d527f8469288a8a27a7d7802092df0dedeec2907966f71ed4c4391300dda5b9dec91c44d8b03235316068efcc4d71215bfa429ae64870a3c49212dd1134f9b375d056aaac264c246b144fc660652edeb396dcfc9985b91e80e3aa725a3cd8c0accea3a84a06452b11eec8601a5f59e33ac6196ba6c21f1195438a6ab99a10711bd25d53e631a561c09c27bbbb73c0bbe34fed5788f292c82d55d59d3078df53d7c73aaf667167987c634e23ee4549bcc03e25aae2c86bf27eafd990a35dfde7e523a70b73571ffd4e2a18bba09a31729c6395bd6d96aef67b6109d172091ba0da1c4e7782abb6309bd394eae6ebed095f40966fef98202d54452f75829ee1aed21b1bf2fac5abc0b46758f920c6f06839532c22694c9218b772bd4e5e5b592214a732b70432501af81659dc6e2b79d89145ba80318bd5166782dbee4d9de7bf0bcff309940bcab3ac6427396c19c533325752721f2e4989c320d20415e3df013e09c5f224725aafc5282835bf075cedf8e5b60b8f4c22674c2bc3758364dd9f0c6e171615ebffe7fbc73b4b253eb844f3c72dcce7f35eaabb7a83c4741594695843677d62754383f5ba3f78e36b2443cd0477da8fc931e8225b8c5eb1f868fb64ea4e46269c80f6d0dfcb3177c29","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
