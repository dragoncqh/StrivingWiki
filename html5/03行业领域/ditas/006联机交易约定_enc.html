<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1fb42b40495fe86d75ac7065e5ae6e2c2431bb51d369da3514db9fa3be0d86f34bdbdbd1a7b3e2580ff68074d49f4360c97f1099b4f3156c4d29c6deb539694741c58f19a4e70af4d02ab894aa8318cff3ade032743edfd1e2563551dffb2db152d85f22e64575df0b10ec2402646b27e63aef8e75be5b57463ae667b2ad9b64b9502426fcaf4b1481506e98485295e76552151196d72d71a22cbbb5b4d5f9b060955556a0fdc6e1dd6b3f458a0be5d9966d51a0716c4f46c8b9042e53cb4092d384db509b2869dd55dc8e34531b97701e54e597f53bfc0f2764b2ef192330373e4752133ad7d2ab644f30522a1cf458982f369f495a56b34897a46e65f13f7791ad8bdaf0ee8d61803c3790ff261ebc43d5a30094e6e0511c5d2ffe644cc9a0b5007ef431f07ed3e398e2ee6dd69a13550d1c4c13f04ae2224a0e5f8a18acf4c437707516718faac1ad98d5ddfd7745203a258bfb760a1aa64f9fa5f8d86a34cdde0598577b78ebb3663013f17020322f2c002c3ddb5e734064f4560f70ac0467b645562f058b11694bd2f37c52c54b2805ce77717a0d3d41b44218aaa837855db712957243902f439a2f7a831c7ce56cdb2b4f5cf94bd659b7ff370f7e5fabdb9ae6f42a9b7dee46e2a04c6a145011d1d57fc1c4fe5d88d0986324988b815b54c971f315610debf4f1fe1c9714b9b14b729274cfc1632795866905adb402d4f41391125b0b0995f12924db6d9cb755fff1a5ce40b5312012f10a14c63aef4e7b50fa02e64ed7d4a4e66fb8dc174f13f16cb60468f562b3b2cb914e8e17f75f733246d29f7c1b2bccf922ae6e3a039c574fb7689c65b207ac9251d8fa4973da4627967944954ff2b48c7659b0fccd314dfde7005877dc36a8e881b56f0014034a65e7086770d7f321db8e73eb250991a1b20e200af143bcf0c8eb99080dfe0899ba7f20845a88ab7cf5127251c635e0592ca5aa9def9cf9c2bc34293643f6a15fbbd7ec6e97a2e66c60ef8328da498a4b97f993791fa9d38378704ae3c87c750ab85577d513ab5f74e56507eade11620c9027e7590a7326ec742e51fb5b82e5f85e9db71a5258f632061bd0531753c6779b8f431b078ac800176eb5ee425b15d4eb577d342728c88601527eaa11384fa239ede49db114a281dc8eb7b052ce2c52cc830711f536aec48b63755bc739bd664614df0b70255aa154a7d67404377a344f5d6063b600e659c94f7548ef9656893e72b85779230fa36b1265f622b0d0fbe71208ba301e72cb604cdfee22f7968275bbc7bd513c97b5b3aa7af642fa3fade423a8c797d755c537183cbf7cf465ec1a410d4fa37926b667201e44b2ef340bf1c5d18898af9370d64915024970a1fcfe4bdea946a1a064e4998386cdc2ecb01df4c8b2d2a72e4bb769ac90fc0025bdc26a98ae89a17f1f5d9c935dfe167889ad278018fde101b951ffe8dfa1794bcc9cbce508cebd63c950454fef47c46b7120e0d31b80ed68e8eda8479c07d7375e3454c35e3838140736adf034bb7c8ee3628ea6e6200868166b2e184aa851eae6cfd9080a0f49878ccced968392aff5eb91cb50036768cf6f00d73a5e1a0e3c9a23086d5313741a310d0c7e7545bb36ce28739d880087b071db8794d32d8f0e9951e21acb233c8cee6df806fd0a982ca79beef2c9d0134c366ff646d81219746cf620c334c247df917dc7d55f5b2cc346248412c073b1712ab0025d39471874d2677b68f8326d3ef34fe44af2dd04ccdb3246f13f8501f7fcceed4fcb818f83dad37cc1578ea543519254505ace5586e8d0bbedff216283e11c626543feebb3afb281b59def4d394546b254df8cc0c2d32e840aa4aecb37579a9eaf5c5bd6f08dbfbdaab2e83d570e4c634b6c3b097503d8232bb2ffd314a6d74b0d2180d69588689945403df45680ee3ed73f26c22490b229bfaf6d5ade708dbd25bb0710495d0da42d2174b536b64b398f40228cc5087c36f54f7552ee4792b26a53d8f72fb5863459a0078262b8453b80a615d1edf1cfc8cfc1201f3efc842e6744030f54c7784986fb935976689d182dc3c34693fd410b3c7c9dbe8a63577e3f8893e731df838cc91d43a421227948df3c40a2665fafee4f3cef92718afd8a3230e63b268c6ca54d6d31f5c60b1cc4f9a983c81bb41e4deb005efa7798868cf84095685a1c56f79582da056f2cd679e90cd473a3a69fcf57c305aca8502d4fe919306ecfd01f1106c4376bf1c97d2cc2408b7eb5088aa8327421a9366692541bd9223d35c35f3346b064a8d7a5102524cb6b76a6d3f021c3034b593e56ecacd9cfc6e9a258b841e4754380d74b8fbc6be0e8c4df2d524002d0d31da79a9139f4a26d6d4f6042c81f372531a0b4e462f225ac44b9822af692a7762f98d96a8be36f2865d1f058d1262bf21c8eb5f7147b6c5948e749939dd93636ec0a757bfb9b59da3e8223848703c50abf6fbf028ee48a759047ef2ceca31711e2933b2d774f06ccd6d7f1c3b2d8f3b4f86b11bd25e0aa468a9101285b080184079f183f36d6807ce1fdf7789f94c5a580d4bdb4470c117d4dff6030bc3c81f4a6404e710c9851a30191e1e4c277c3809e7a8f333eda885184d492465fb1cc2202f816af44ee441fad49aede9c014e834005656eb8f3649d962fd633610527b503417db7f01072e6ed9f2d7ad780cdb41d565a0a98d65bb65636e809d57ea593f402456680e7400768dadee74cd15d4d59faf5116dd908ca02c94f17ed91e6b50e43876cbaee63c8feb89273181ea1a1256fdfad1b2245077722f3c7671843050551ff051f0eff8383c6db1dec17ec7b95101d7cfa21ddd08df1ca03138c61a43bfa2763949128fd3ed72103a0082feb6ceb2672da01e32e6fd78434094c6931797b8fd7759f5b9ee2f10ab8b026635b441943ed3bad2fd355d60a20f73b84930daacdc6aeb304623c32982c2a41fdc00f4468c01bd466f712382c13eca2638c60e8b124bdedbdbedf221592d079e8c1c141d61048f0a5d1818379b79efb31fdf83f7dd96250310a4e8183662a881ecba208392978deeebbd9e7e4663931a4070d8c84972103d0a3e389c6f9772746553d7b687c4cf4b4c662f8e3914c6f30357ac1f4694a53c882a69ffd936fa96bd49abea80b749b2a875f84b4bec7e987ff2ddc131afff77902cce750fa6898e0fb4ac22722e4bce43a982462a64e8e65c0fefe02bc3dc59be3305c551a93c567f70a874a353219a202de3724713398c2002fe08eca965c03ce79ad8588175d0902496f2d1fbb515f46f76a082f0216473956652756defed336ad1617db5e1875dc9f2d19deafe28d404e4286ce9b8e6dca54e5c11195ef97782d152b81e403f3e15bba813c78449b546cacd718f95b1aeba0eeaa07649ba67d045282b5d30ed05b980e5e84b669dfd80e42f844c26a4f9a8ee7769750fc823884ee21b21009236d4ca9ac9e8917c9f0084eec501578661cbc64ce91f8a478313ddd5fe156201e31831043a2064aa64d2f70a83f9e712d6e77b648aa1a599a9c5c863a87cb2eb59db4dd9a892cfbd543eaba287d923a6c69bf983e0095130f7998908a39078c1184d4d03a3841c590904f382a18d1a02f45f740fb9862db58d47553b928ac3bcf90b99fc9f8f2c6609cd46668858e343ff6340c53c27b0f76c9ae0dcb5b1a8091f515b23430672e9782af4cfc87d74feb29fd3abcc51869b6cc3bac3607bd3bb140557c51f2df0f2372e940b51c0f32a3ba55d2360996323cfbe04a3cf7de0946eccc766e52a0fd66bb68103f8ead2ab536b5cc0aba6c194030d26648d33cbce8a47fbabc41653869262edb6ea5f47a65fc4287d27cc22bf62e0a5798166cba1116ecd49e6deda1b68d877632a81573a7d4c96ee1f4ce68dd36af516123798d601ca0ab41801c1087981d616a86ba94c28f7cc13053903991c49ee0410b33cd524c26d2e1663bb16b495073b9dbff7c10fa34309d740f46486a96f3e850f83037ff4a2b66816fea4cda45342c10ed8e97347e67dcaff9ac6c7ee6475612be54966406a3d5f6710d587b35b17243be16f5cd2855862f5246dea743e6901447bd70f2135ef91a38a53197fd8c672b711e9f215ebb79db520f9c1b6549d13e006db44f44f584af0cdf486c0c728432f4f4a23748c5aaeada551d4f6a6492714a05258bac8652396412eb1acf366281b89b902c36978dd2e46c5222c37ef8e6a303af7689352d184db73e8198e53f83ecfad83f37ce152bf336b5b50240c86e969127752a40437a287919b38b5fd3dc776cb9eeac6e56d918d8e4a424905b8c1e8b49eec45ff1ddc73a141531c10254e27608404c6640af0b43d02bc9fca5035bec6fb406feeb561c51c2927167b506dbe074648eb67f13198fc9b34413759665f63585c2d1dc588c0ddd25cea53a1f1ef8cf4375a16bafada6b97c62cd893d2aee044ce08b7efed91b1a1572035e831a7f303707bd97c59043b64fdda103fc9c8b1bc558cef5fea9696ddbce9140c34cc064dc07d82bba67041edd6ed9929f3921419bc5b86c06b69737edf3d4019d0879e589f6cdbaeeb923a3e8e6a027ae257c59c6c70ca59535bfe3d2e37c68f58a9e7caaaf741792f2e49e000e6207095e6b821306d8cc26b14028d1744088cb954668c760f342ae033f63b1f89eff112b7225aeb4b5a09e4c46efaa03eea934459ffbcc03670814926dfffc209e5123a69764aaf082e55f81547e05951a998d5499d06fd075e49662dac5253340be5cf8104419345e6f8dab13fd58a7f5fdc7262ac786ba5fbe9138e2d143ac8a90ae7d84963b0b648d124aec85865deccb500617d4d36e32fa462478978df4c6a8ae4a4c0a21eb2cffc2aa6a417fdcd0893be699c6426bc2b2aa02303aa238f5d6e8e1b8d280fa87ae01b25241fad1c7d8cfa951854ef0f50f15e9ea8ce9ec2dad8945e7635835a31973b588fb60c2b16152dec3fc46aa80984923920a12736eb4088da625a42759b8b7cf55f344cb6ea1b1598642467c51da7a04c568047735dd83557ca95acd37db3d7692e06f33c70132bbb0942b648111eb453790ce1d396e923747e4e19fe5b01c99b7636f9bdfbc4e18033c2d033fd6c53d8189cf9a154517e427c8ea4f282801c60786880ca53ab065b88d63547ddd8c1debb74ef1b56a8de760fdf243b4d3bde143c3b679a37c21cd2901ed20da2d27cec59bc3d90060c02154b0af07473643ca44fbcb17c171a7f484dd9597d5d02defc3a0e9c344edc24ba68ca6e1a192865a980b7d23b09e3165b9d17191f283b5fbebe6829550d1a461effcec9527d051ff2f0a14e183fbdcbc0a0c7720376fedc7a2d9f302b9129135ccb5d6af86f560ceccfa40fd5f6f7e0723d48ff6a780edb46ecc8fb0a26a25d8458f31d7e6505b6ab3cdee991108b189c6f42d95cb3f0cd87a533cd93d5bc468bddcc82187a2959d2fe9d77ac3dc9a074a03255875de932b9c3d56e62979188aa839545e20f69a5cd0e862df54664c21405d8fb635388cceb0ae746c2ecf1218ecb554f85fbb696283bfd565a9ceb069e9ae170e69470f432003408f3c8fcd1cbb0612ea029bae3abae3f316ec8db2ee16e9c841c703bbfd7143d80bbcab7f24f2c59c510c15f918c6ff3c14600eeffd24a8da33f099b3a7a7608f2f43f281a4b4ab9438401f4ab7fc6b77131dead6cc388c307996e47dbb07032da7a3ed6eefa9b1a3d953c35201fe1aa2a38b88f6c019633eeddd56c6624d4412630403cfbbb06612070daf8e486aac0441a623f3ee43b0c49cf4252c1ce40ef3ed2db4b3059b07319acdaf81556969455704d0b0a62c21292ac698e161025814d8f428cbc4c9cbf58a41c362bc7121580fb20f31c8dc58ef49b2f98c96eae5576100536a34f41cd6c4eab45f2a1b935a966d965780217c65b4489d5eef28bcc8eac08fed64b65f0c7118a7361774168699d8f8869b642e81b1b4db80d67d16b4046b4de07a12009718baa03c42a14fbffa59862078e5c8ec7cbc13c260d25915bbafae11ac92f632d31812ec097605d112e4bdfd925d077b25499a679780eebaa2f43c1925baf8766a216acdadb2de964f3082799f1a7ab36ab8d6bd2f4cc872948d63b17dda74b484b5c3088c75f8b6a6bf77b0f22c4a2fac1bce9ee030562f7feeaefe2c3934400593bd16b22569f5530055876c6143a99b07da29dae2d6f065896f057391fcd37593e2a63f9def098b0e801ac67ccb231cf5f57090f5f92026a87a126214873d9b1676cbdf7b8b8ad487405fa12a69d9b37c602fd828faf2e7d1382fabb59fa76d21f0960dc8fb5a332ec9619a8e8b5e79382b64f9ef181ce75bff5bbd9d3210f26423509a5947f759ea590d5ffb0a99c2a9448fb547134a0d7805aabe04983bfa433f8b8cda3bc632996651b3a26ef4a459cc118eab68c232d717c794b992d2f31289b3bdd4d05a373f8ecf20503d25ba43972e08c6b79d75b11aeb54abb189cc05cddd2d565fa02a318830124a5c57a1638644a0298c9497e0118caee41a00e43b3cf1ddbb96fb7e00de6384baefafd77d331ff3fe247ec55be3b234aae96ca0d07b2cfe1ebe9df0158cb7acb150ca2f305c80eee58c6c1729189282b5170388a5833a1f619ba12babd646c615f566a974443cbd3a4cb7acfe52e68a143790feebf07d57d332ba896357cd6700f769ae7dea0d6257178832c0b8e76e1566e705049a0e415bc222be54a7bf54f2ecbbdd34a065b70ef3554580d00ba1442a747a0c531e9c880dbd44e912dc385ff9cdd5ba1ca3f9ef0ed349235f68ad8db943a1beb9f3adaedf64a188363822844c8cd3d31b5c54c5564b1d4d6a0bb4e1642ea259332c2beb0bdab709ed32a7b4f98182719294393ef919ecbc662ae427a0490b4c80b3e487ae83b0879358a76e43d3b1d4e9235a276704b1bd20d7a89102078dd46e0c7140dd1d8ed227ca09f8b4142f157765a16ae4c2460fd34c227cd8cda693ead2a34272ff76ea51c1171cb16aad93695ce4a7b019239e7513088aaf41f8ccf561e9c0f159213089b2eac6d15ef624cedffffcc19ded01fdc29bdf0dbcd78085419fcb9f8991b98b3a0d0f2907abc1ef529291ff781eba8268957c405211598aaf8d3004dccd1440d25dc42ef0026a559ab63af03df008fdcac5a20d3c7906a40e0f54ff2517eed1058db681deabe0daca33ee0cc1902498ec09d1afb2a9a6d99cb52622fe6a9b6ec17060b83918779b274f5655a7ecc47b33b98c8d3c8c6d96b444d1f4b5d901f021f7dad61f2c6c4baf524792eab5fc7e3ef0cd9b3d8aa081defe8123eac9ff2b9b17f6138cb573ec37dc3a48bd2f871809aadc2ff31fd6de89cd28adcce66ed2bd2e0beeae4c2ec68c987d35f80f81141c980fe61de700992657e522d8b7acede5a11fd30100095e5a76a59f44cb618448bb896cf8c04eb88d2de1af5c880738a3ae1d4714a542474b7017e43359aa93521918e7f09c54a5a8615c161d75b1339d55ebaa118a5883daac2eec23ff38330e44983ecc6d0ade90c3beab36e2e0a0eae018b7419840d10761a016185d9279c17d8ac92fffec3aa82b73c64a2f28e1a86cce8027b013ecca9be5ca3002d049873a7add6c4aa51cd03279834c4b62d919999232d6f41be575e3783b68528afa3c7e7e834bf05acc9ce096bc7700128439822ca063113f0f563e016b4f0cd3fe7a97a41fad9b736db66f3edbc13da20eb35391b49637332286e4b22532f94b3d9e6af4cb561216e38840f8b830174bdcaf0acdd16c6d34bf16a3ecad83b2df4352e5e679e019fbf671b43ac7afbf299452193c52b30d285d7a90c139c07e98d3305515c77e8cdfd18530a69c119300dec374c6d6b5fa7978a9b2ddca9d442a526bcd9567c0292602c3541d5d40612646f6acf96f6c320f89f5026dc6221ba0d63f70d15957aa949402f39bda8c38d5b4888d650e6d0331b38bbc14e708a574ca677cf11bd451135c4b5af7097d300864647187dd406bc8077c8c8ddedbb1e4d8ab6ce688b184d67994a597cde17490e7fcf9525ce68ffc6529447226ca2b69fc6d10a21532c2235c440487eb3bb3b3c2f08783169716ac4b996e65ae79605286bc17d559a993b42ab9c10950492c9804bdc9796f9e5cb8ae5976f1300c184fe3e0f7ccd10db545c1882d56acb0ae35036b10dc345e37958b137e265b7ec076c1945bd5cae443e5430756fd236d19cf787a762e8e853cb6e253b07252efd6056f9b84b0a6305327fafe6064b71b046c2bd403d712cff45e1b27917bf44b224760fe7ca8c29d8aae630a56d5aff0584a40b63ee66bfa323eaab74345978215438e50833aa5a80a80405914c506f4afe643961f05067391d7274563828807b656eb3c6e69edbe700c76c87ccdd7ecd2eeb0d97159e57827229458fc32776579be4e3e55b5751734f2868226ae6ed25e4f12f33ef29e9140eb4efada9617d37a63ad2d9316566fdafbd2b0f83cca6436aea222621a66c8b90edd18b49caa2f03b76db3ee60799ca507d86fad3eca85134a1553fb2e7c63631f2e150bfc513767c6bf08877651488cf27c1c285b7b38d1c8b52420b5131f809c83f15ad89976a2f8aaa741b003d6df2a354e789c89adb032a5ef0e2aaa21dd92f74b52e7be73686e90346f01957cd40add8c700652cc91bfca731ddea6ef7574ab497d28323b36aece4f5148c83e7cadd6f9a8567f3120cd8f608afb0d011b8d844575f73c9d1b279c83924e84b9eb0d7df366fbfc056d1262a7dee610b207d4d5506ec5b3449bb4ba7df7709dfeb803223c6b5f10b5d7e40fcff112a1d0ed9b7e1ae48038784c4476f19e67a3794c527c538ab515ef4cf99ed9c9d1ae0529b730d0b99a23c6a6872ef0fd555c120e35b07bf8c9723a5d79c1310e0599011cd75fad4e99a3ec2b3f04d35e69409be3f8dc9b5a580f5e31e4d658b259b3cde6afb0b76fc8515e3dbe88907821686d19f928168608a9ff42a23c3f5bfc8798cd5f1516b90d8c3b25e6031d1cd5ba25910d075fa95503e472d0633708d8e385fb0fe98c21e0ead9148809cf5ae1ed692e291ec2f91ad6850012e93af0d35d5d13d2b4b323bb008fd858c7335d6e9fa10811d0751db51a256b0a606206ba3f0e1d8555cb3af57fea08e40c85132ccff8bc28cbcca1955701eb66c42e54019e30b68605e7409f0245f05422b0b11c1ae4e8ad79ba4cea38b3df2fbe81fca585cdd094bf6bf77a2c24242e0d71d5e6d80e67fd36791791914036abb0fc717262f315283c099c78f5640f2557d775cacf2ebc3bde15865bdfb4e5eceb7f6d6a85fa959ef81e5bf1b41d109c3711a28255cd752992984169a402aed7d23020d1eda51fa82187b8985210552b7ea89e05dc33e9bc69ad26338b55211cacc857c9004ae91f69e9562c5c9b1adeec9ca96341656dfd2ee623b4397a86df4d79da7d65943f997f40bb554ddab5e72d103d70f210c89693ca065705f2f110cb55b06de397cd897194a0f3b21339d808409e0f3ee03d076f955308f7b1f5a35db8701fe436452e4ec19c88b33254d772c0cf1bba01c5ee0c4579407fe6656913bf846d7384a76855ca1ae5dab4b0cd076309b69c031651401e5c6a079f948bfd8691d3d93d643a9be3346191c027469e3ae11704bee223a06f95d3d7c837c8ba031aa8da506f36fc9e58ea6e326d20c204a66e27d7946da6859537e096e314657f954e9531ae94e782fc40f8d8c674350e163c442c624326fe9e1d4f62b694fc2f882723f1c03bf5139c79fe62560cd05957431a0d6c02fed0641cdb7f52a0fa0f696985ec3a6c773d3bb5601278d76d6685dfaa8808deb90af5dbc0e46075df62b779c11baf559cec4f7361d21f86a5c320591e6c681a193bef21967ddc013bee66aeeb190179b342183f4569f89b257eac2e462e11804929cecff74139ff1d3969ce7d460958d77cb3f548c9e95ea23d4156c741ae4f9e42a8fa0f4e72e64526ca36f36fea9d56c709f51a191709912501024ec88335c7ebf20855ebc5c415b843d9d0925e4e93abde32c29a561962df5d03dad3738ef11ad1e11bdd8cc0241a4f143b8a64281e7f59a883cb3b880f57b1a229a5239715dd7f1eb10d94aa7936616e55c724b9c73aeeb003f4f4fc5086526c789e3f0f76238bd20d556724117f64a47114a7d8c0df9d96f306720b9e2eb9ddda280589ae09f8172c6b028acaa298db05719e51b3e8e556861b919bc9bfaf21d6abe9498b5bff021179a609194b71e69d4641656a2e3db23764ec86f62afa1216f2989b229efa9163f0c73d26ad1601f4aad78a87266ce304e41057a484c1a96ced13d6e020746292a0ff28ec3387399bb673300ed65ceaa258e980a326267997a01557d9c9a6d69c41367a182aac85c634242baae9247be66318bcc4506d2a8380044fa1657d9c043d70a98dd9a3de543134b58f69172b1b5a26b741a616a4a2988aaacb627a56a8e34cd405664d4451d10c14c76596fa1b0d83500b0374a24f16d07e6c8fae63f9180554a3df1203edbd211d029ef9170952e51fdd2fba18aec226706b1bb528bb5ecd98b9dc368fe054d213951516c26d47e66f58e81050745d9631a13b0ecd88884d07ce00906969342d7c1309c99a29e4bbec47794eda780c2caccfe310a21ec62a5071ac044daaaf6278371fec5022d5616b6dc5889bce969123a8be0c7134721fc116b650b5bde054a05e6f510697516d01be09535045bd7a691e724e843bec861c7d1f4ea384d5cd1b7b3a02ed0e07bdee0cb90162840e5735a3c16041e62621a190697bf5270b21e22ac70e8bff7d769ab621acf84ea858c1850a4b3541ee826db7d085ab1ae7f5a167f8dd1ed3f686639cdc209d0ba42fbc743ec4447d0645037a40ebef77389b310fc0a818fb9570c8a406e0522cac74d170c8b2d848ff6a289e9388e39302c78df1a4c7b42e0f9069d6ca94848ccfa80cfff375e607505a632d06158926490a509023c486fda1f6ce3e0491e91af511599f1f301777748999e9021e2b1efcaaaaf0d466322c9de78e20a1826d1e52b30aecdccb1e0ed565d7845923c785f58c2ae2efb4a5d1eacabed0da9ad33cc2a32e4c1cc9fa07321161b804d7778fdfa02167b5835bfc2a8f872adb3cc9e83b7e2f9e94a927d6340bc5a6a5387502d2b950486b050114c0c6cca98e12452016f1d027a7333a67f66aa72ce6205b659d33ad2b0c82a9871cdea5ae4e62263c6d3e849d8bee87bbd1967b8d8635d05de3658ddaffcf7d9b982cea2098ae0c29f21a60ea5bacae2bfad50bd6eff31ac7609a4142ebcf4b25319e1b3980466e2ccac0293d0135349ad31bfe87c61b0c08e2d20e07e9d01d088d515094e869491d02c4c95308cddd3b74e659d700e6d8f62c40ca7641045ae63e9696c51b494cccdee11d8b090ded94834f530fe8413b8e490228fbd28009d23a6930f07d01f1d8a143db5f6bd0172bdba797973c72e606d30c24ec8c2997e3f733d6e6fefdffd44cdbb668090c24f0158425cba979c50338038ad09dda2075df71c7fd14559495bf9a29e27fb95a338b4f41faf6374df873ce22058354f1ab7e2de2d5fe714413a0a8da6c6e9c95dd3d93d72811f57a59f91841717c06cf7769fa9b3499fe03cafb135a0e6c084a3e92b308526bc01185cf7d448b028c44451349287735d07741264b5e5e2889f24b1f503f1523f5027859c7ee2d66a67bd0730a07aeaf8cbb97a5db64669d7e00d44e348eb6e4aa1bdc0bcc8206198f336f666b3a1d737623702edcd40e07850d1189ca079ffa73b6e6f949aacc4fc23802c58f2f670572fba8165efa07b8bf37c863389a900b07f119786446271e41ff20711945261181d3d94cccea3649d9d8ed81c83463a488e796ac40c13e110c1ad6c73e9b40fc02c283c8ee2bcfa0c7d2976ea6de27e38bae4b4a57f385262a4c3126fee4e4bec995035f8647f14793a13d7c72dfc2d907778d00a402d19a4f7d6b637698727bbbb37835e1ffd284f022762b2ace4a732dea8d04ab014aa1273ca8099a3f758a8a5f83ef6bc1b6a5313d52608afeb6123b5120dc099d480fec2d53898bfde845457fa2eb3e5cd85762c94f7ed63a82155b41ec75a9cb9eb93793fa3b58a7a9c0e7e99ff96c231bd835dbe1b74d5d8bc3ae224e66fdca290438d6ac2bca1059688d9c699ea6ab2d3cd188571d8596cdecc727d42929295926ec07450778111f337c6ef1c6cfb0f091f1d9632052bf7ac85925f3fcd4abe1c45bd0e19a3093ff866575ea900ef40839e096912a5862295f8d17710817e87c0d4c3ad43043e01cde1a8060ac5ac7508ddf317aaafb5d63961e6f1e6a0ffee8df2ff0413f6d1e0d750b5ca2f4d9d77c047dd56c9327f7b1a4a872427594b834fa4f91e52c219f0409549b7613163b930db9509a3c1c3e14eaf29c50843090821b39f5cf78b44208ef4af1cf06cf024f4c50704f9a57e9d8da22232ec14a3a14f90916549f13c36d08859378fa4e814f6dbe7548baabcb3ba6f8f32a14c2c5533bc34b0ade64f99d1e9c6edff71b878a7b37faf8849f3de3aba010cbeb67036a9ab14a8e4c6bee444bde3e73d24228ec5a846fcc4dcd0d59d962b19badcfca3de27b41edd49d181b4b9745773faf53ac0ddcb77a11cb64c7809c73d56e870a508e6ba80b957acbd92fffc9cf8cfdc9733bd52dcf4e202f4f1fbf5e5092eed5e92c1e5966dff89030d0cf347ba2fb6e0a17ecbe276002783a9273d9aa6f01d367871a1317b75d3adfbe643434aac127275a875b0719bf54b9968cd23af99102d59e08656fe022c79eccb7a460cf3f55fa4b96717280f11bfeead0cca15f9c620fa80b42709b5a0d2c3f7ef3ae3588257fdf601895770c3ccbc57895590ed3a03083dd127897fa3d771bd011f984a93a28076028ff4ed92f02ffa0beab40399d15e00c922bda9b07ef5693e9abb871a3e56d9ae854f92e8fa19a8c7d0a59f2badfc049d95d1697b3a77163c1837ceec17e856a1e20ffd52a042e7c7d4d0e026e3052a03488eab5c42c0881256cd089bf58505016cc346198a2717c92083d76fb586a32858d516bfb025a7d628d745d14d9ae642e1b45d4fbd003f4da6573bc6a0d33cfd16bd743f0eaf5fc4fe59ada06e26aab972bbc41c43ccd811da9bd331ffdc859930bab6b2d05a99a763f9cf9e49903832faa72f1334a50734778daba918b89f9a5c000579a05b5239746d6b482c7d582b6d65e6496925a8ef5956308e5e123c03fc27c65f7e1bd360e1e5fccfe4355b6c1cc14359ee93519daf587511f7a823e0af610d921af5073c850d6a1bfb3d95d472966beb0a62e28e3831f9bf0f31c0634464d816cd7997a6e31b98ed83fb70ac9e6663b3c733ce17f5ecb40fa8d7dc6fc0666655d2229fd98270d2c93aa8b5e50a5b1565c9f588ed3bbce5ddc62b91878b70a80faac6f811370882f7763fcc1cea1e7578e6e72c6370492e801694d4cc0f1e937a5c4ba17b8052a4614d8d3f04e987a0045e247d7c7cfc15a320e0f7607bd9b669d722c06c38befda4404c1ac69450d913c23657dcb255715a6ab5ba2f09b43a206ddc302185e76c4be53f1188ad5599d08ca870c69ef571347b3cb66265452193195bfc3a7eb4ddbedb84f0fde1598789ac8ab87175d48b9337da527076965e15cdc6b50a5f770952847999d4063cd422b4b5f1716edb9b36af2deb7b0b100d712fa08610fc09d7bd082176aa31c780cbfb6ad5c7161a2df02b4f13fcb1805911f6d96e9d92e9b9eed51a33c7d22f05e37808c3c9fbc371b609f9b8d399fbbf9d76f59036f6c1928c28ab96ad9e8ff0ddbc8772d0cfaba0fcb31a9a73e0a328e167fb24d98ba18469feee830621e408ac49558d98424866cd823196750d2219d435d5881c4f528836f62db6eee7fffc675d2b0e8f60b84896456ad49241a95fc4e5b81aae154df43961dcfdf35cb1ae3bed06f45fefb48d3694a95bcb8b67b63d1e6440b07043482a8b8b41b70612adcf541c32f188aead66f02f5430873432e98f77083fcb149a99be5612ed9543ee9d4fa79701dfd98bf303c009a7daeb9d68483e84ff0862d02fa19c64e7a943cf3fa0980b74350d1f34f8805e2e152199f3dcdd16e7ffb3faf0211262b297b32c5adabed2d70ce2e3d95f739c180f01d06430c1e22419bcd50379a9888b69d5662eba88f4ed855eef9d41a010b52c265fea23005227e9bb92f6e9fb3d5aa3c23dd286b1e05a1600f2cc265a50a1cde9a2c6cd665f9a9819e4ce4b498a749084e1f6bbde135c5b0533dcc7f0b08dba65033ec7dd242cdff05913ce98a6c088db581ef5a1765e1c66f4c525e104ff69deb4f002d1ebc16d17eea86868c6bbf2b26729e7ca2d96bde725b66534671cfe3d8effaa3fd336f55e50f74d621e1ae73011b6a98625854c47027d4641c76bc22592688285b0720add6308a3bf8bcb091cd36730aabae438a13763f3663cbc0ab602925207c13ee4f0313b8a3392abb4d4854ef0affb8d83d28ac12f9f6d38a054ad6179c9b0136ba1e429de71b941831a314e07eb046c08274d6bdf786a6c608fd5dd3cbc923c06202fce539d4b65efd67062a0c5a9b6a1c8ad865b52dbd72be609ea50a43114f13e2826996a5b405d7d1b9afae36e58dc9115c1dd1bf5b96f5040bd2446b4be6d7f931a973acf08db3a5c352220fdc979cde358d20f241aec9d74832c77880afbbfad68aa40e90df442026ca72b6cedfa5192923519f1faa0e166ac83f85ad47cbe0250b1648c881ca8b9ca9a43e71118f095543f8e59d93dbfd68757f9d254046faec7ff9fa5558d82e2150953f751caa726f9275b01f17cc9018bfb8e4acec012abff16e4a5f2fcd36524b6d19b11cdde730220178d22f3a6966fe91e0046cb3deafc826ea9bfb51717bef19ccfcdb38d8279387b46db16cfcbc6794f8b5aa5124cfe3ffaa68661dcdc511cec58f28fc0408271a128a8c2045e1255cc89989f423280ee6bc54745b3dc25aab5f46a0f591aa76294615017f6cc2b3d50f9e8ba2de2a56367f31933352af659dd3cc8f96096c772463d73ec8347c00d6520060db82d10efd70b97c138391c940788b109fa6369736fca10f121ea3dd9865e5a5e017f915080bfc6976e0fcb361cab83166c3f13b60a092f6103602432868c490325dd35c40da6d474547f206b69bf8d0046efcbeeba060d92d35c5278bdf92af067159ca8f86d3a573cc57ec07af75718362736004a04b839e6731b13970888b7523b7125c5721922ad5accebb128b3935be7dfd9ad7626ebf25a7f1fc10d8e98632c86f03de1f582b4ea88b92fa72028f8dbff7affab3b0b1941d07241f76b72c02e7624fad7c24eac8ea7339f63da2d001ca034444bb037488ceae7c8ffaa2916b27b7181a7c172166cd35dfe89361db6d0c04cba8a6dd82e2a47545b7c6a030a77cbf255ca4b5fd49bf536294b612e41134620622c3de1eb4c0130980ee3d549d147679af50aacfcfc21cbc0d95265b68df1d221965db00d783aef389d817a4e7024c203efb323e37b57c473a37ff0a748aff5301c98fd1696aa0477d6126b86729762d3c4c33022257294e11961de7ac0369ea3d55f3c596f5e48b5f2409d194ee20f9e39c7ed9e75bd81dae698f2b9adbb24a7160343069eb4e5d6df5e8a2742a3ed0b3d46acc9d7561565e6dcbb31a4db5064752795eddc377fbeceb364b0be55da3c02554321ee68cde04ee68f5a8585e2ed4e49ea1dd659ace91d2b5ed9fdd6fd6bcda3cb760b71f9277cf8d8ef586ac9a50d6237cdd5005bfc491e2a63fd3d71023bc299dc70ff160bb39a4b8f888725a785e8c0d6fe3a27b84787528f9c6c6905b3227f1f6d43dd335a64beb24e56b01f9d0a8baa30938d84671c440c32d18420f6d52b9b50c847acfda60bf9dc12e69e3654cc555c668ea7a206b310ba7527f313c0c63423ddfc4ef02b96be31ca912f11c39be207af76ffac1f42e8d7e346937ac3cdac30a8ddd8bf07bb09e462b8fb5e52ca2d174ba923b7f4a4cbcfaf3e32376927989f0e7e0f6856216dcce8362ec114355c0350ceb785a28759eb1fa2b8e8f3df148c92932b65440afa1e4d51a9aec1f7d061f80f392a7261d6bd780bfd3c1f3e0b6e1d18fff819064023bfbfdd61c6bb57063a9486aee9c17e34a80e796dd5c11f640242a2092d7dc1cced4523c9a7348a2559416857764a1822b75219f2eccd36ac49174acc118a55a2cd37377a09ee0283e415c287a464d4cdb24bc38c06c6f68978e06ce040d54bb8ed5f6cfff183b881c4df3e6b826413204b777b5e7b3637c23f7b61f187e7832a28a19fc00b26848a85c8a93bba74d656a4f3e273cc9e44a21991be4319427d9f18d8cc1f6e852468aab8c1a56b7149d91d75715df8d2485626f7daf3557ee9a6868dc2e9aecf5bb031591eb6b0dd74a71dbe8cbbd4aaa77c5714a8b45cccfe88007f44b13abb7c62a9d5edc5f2304612f33c1fa84af775afd16614715984c82285e1133cc2bd4dd7c96b7d6cb12d32cda150cb82d1b665b9d25bb18e0a3641bc298b0d68519de760f3bac0edb1d7202d92a393a53eac61040d5428419da322d5bf86565816e6b928e0e23aa7a125e21f9727e492abc7a8a21f1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
