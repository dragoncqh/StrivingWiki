<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cd4c7c5f3d5c28a5bdcf42629d69f90d8c848ac073a438ab55c29ab2916f7427d5d3c75d12a4dcd1774fb98339a14e33eea408419fad04928991a115c2fde00fac3caae6477c1dcb6c9105c267f24fb1b8a7fb1ca886c08140f1cc0d1bd0df7b058c635ce87f6db3d5021bf4a85e133a561fe77cbbe34cb9e4d76be89db8f21cc7f1594f4f3acb150a8a0a4440030449a18c71ad7bf3bfa3f818c3dcce98ad9fa0580107e9827698951c98d3c416efec595fa01dfee2a1e03e0ab5c0c80657f43167312480d1943bba5e6a514fc31352b15e2322da5029499740b96e0aa52e204d16ac388ec6c850445ac3c67b1b1e4df8db8975c7ab31c8e532cd6baba577b7586289937a1ee76200b60d87b8ee139f15dd4bae267db8617cc1a5f0523795f4b790fd1a610face1cf251a87880ce89146c078e168e0b0bcdddb1e883a63dcc3162ae100cb8163c5e4f6c13d6634f60efd94aaa978ed1d7f0c6658fa2ddb5fb1b3de4a8cc1df111239cb2447dcdc51ab9d5a3ac098af4557a56b9cc79c6375bd9cef92752981cd918990583cb2a009c6ed4e52bcc551fdc3ba0fc347859e8083ddb5f06139bf59e9ee6ef6fa409779d14a9d5649742063bf5993b33c67d2ea1d59f2f53d8fdfd4fb73715e80c678dfdb81099b645d0ef75e46cd6b5d6e3505bec1cc3c310f4031c5c0d9d5da8a0ab220250e07d745b9a6593fe1601ee3f367a5c4efdb1ab9d52ddcb3f14c076bf7d06acd1b17f3ffd0a917d30811d01d71c5f4c63b6069d36e62d01b4ddfe4414134ee4e7a9421e02eef3c55821a8eebf9467ace1cb05178c7b7f95f8555efcd32310db45142d146a1dd69764871ad2bf5eb761fc5b1431c6d3eeb2965f5832fdc842e85fbc9b7000ebf37e19ff29d0881c35bcd69482016e316a4c893cfa24d5e062cc82a70bb82cfdbbdd6f5dbaacfff8aa0aa2ecd5874cc45769b7f2cb87766f53a526a3285a9ba64ed39082c3cf382474ffcff89e494b4035db581243a58a639a90a1726f07f486e6457c821fd2260f36704c86478bfed8dd80740f1d4aaa216e6d4c973fe9b24e5f04fbfc6fedd42f7f89e1eb551ae1891656431778e785cb717deae00bc3e38b5cad1e3c230bbea96672b86c2a8980403b4dfc9c95384c83ea1dc46e2bf0473cf9352a1bea3f517ad5a13efc4f2a97bd4fbc5a0059898204bb8c543cf708ce3b0af9ab54b0242d7a3596f78a09cbf0d1f85d38d410c5c7ed3a9ac5377d069ec80d9722788a9a88f45203c074f6c18cd3348d25eda9e7f59781d4bf9e8bd163d1796e52b4b3b72d7ee61831e6f20d0f9a3de79b728b5f40a4c2693ecc4247f8f366522fa63ac818c715925432add7ee717b9a63d35117edd212063f69a2bcf7ee906881fbd34b63545d805f529e574da20a062359c185876e1ff030d813c410e35a3342954972c2158da593311c0ce229b427183e25f7f6ccced9c63669f4811cd71391c0a0f0bca4c9059f5195eff19d2e7f5570d0033aba67f5a1a7539eba812d815d5960525aae8abdacabcbd0b445470179ce7efc60d4681274a36a7838abc9a4dcd68b9a85899c29cd791fe1080f20530734d1cf61866c6ba6023e7ed2dd2628513efc86bee0a020237c72fb0f3c09097ef1d33ea3d2b5ba3318ba1ff47a2d478ace59b22e87203e41aa09a70ea1de00ef78046fa01f6395694343e99bd12e5558838812a3506078c66e9bb9f7380a1fb163f52361994ee09be7c2dc84ceb560b7967e541fd7f3394926da9d03c0332f632cb6d176586300ea48692087b55de52388b3aecbfb9b9b3887e183f43bda77f600618ca0c21f0624fbdf285cb6a607287048fe693425aa73f87889c60a292ee74b98302c8c10902516981b19f3e657da748253138d4fe4b6084f3dfd2bff52a0ba08aab6b7a431859e74884813eed5d309f76b95a5b4788364890da03d367ab79b3aaaefb5790a987d75db7c93d64ea4bff17b7c6aeeb8b78dd76f3a5d5bbeac297f2f7adac1519ef40c8588b70d995e2b842c1ee8cea8c88380ab1028d3e06b3165ea511e61eed67341c901392d9c162d95390c56158d160fe54b1f7980f9f4edbf812deaa92428669acac6606c01d15e3dac1ae8e313b08d75c8d8332c38246a5343f6a008ff8b4d9b9d1a8456f4056ee844b12123c7a1df07b966b688ffb3dea20dc0cabd79adbbc79c84edf774f7183460d7b2252c570fcd3e6d9593ccf7de9592f2c92f7027d2d9812866403b91bd5c3628897d567e43af89b9b4cec51fc30ace0d85a7d8b8c05072ab81a3600da9676d8e624e96fecf458f2ba6f767c5497846a1c35ab7078024a1db88a1aa0471c8b721a659bd082b7c1487f8bcc49becaf5d93ec777c45d8dcfd8fbef1622d665c190e9dd213b9e7987a541ffabfe5f194033e19b43a53bdeaf3ee263cd58447a2828a7c7f57ffe7b747a8f449ccd94021cb78798da46beb647130a2679ad7d732f9a03f668c41851fbd1147a43ff61809300fc79c2a8a2f4369c862c2216c5e6d817dc889a7a9c3133dede775abda74edc4ca353dd5c3049bf62f15b9cb305659a398bd4aae9df291c7959d6e7093c78557f156304b6c0441cf885ce3b84dd68a32b49feff67cb7f04603225c74dd4010bb23320133c229188244e1585d330b5813dabad01278e463f9cc8b888af2db10eeb1ad46f070061ba5438209f9e6bff2f9d5bc96e1aceade574a7f4029ea2275ec41a81cd0e302a458b85c771f1a440f38918195d681708066c214e6872d730e1526e307fea349d376d2f4ba9aef3e97fd9ce053e1b862d80fea757d38b29b4bec0d8d985a41051dc4a3d2967ac30c0872be72edfbd197b7c03cad7f3835ebed503486e9f84a87622601f44cf0138b87a5eb0fb6607e51b677277392894cb161be39af9fcffe382c7f82c95181e3b0d2eaaf818b2b2fee65d3215fb63b6c9cfa7628160d8f1d182530c4e62b644bce1486a933cc35a59249511b6bd8945d41b16de85f873105405ee70e292e9e6861e5dbf6d31432f19fc66496868de30861f7411ed1b689f8e8330b89a834b6829a34053e815e51780c8cfb3aecd3abf2aa272168db18b77a9bd7347679c00eebfcea164c85f3167179da3a571a9b12e62a25e1345610a3dabec04a85b2c79cb726d431c830150e22eed6824edcfbe3f8778cb67f6b9609de9b7769d13b3660baf523237b5b1ffd0dc923f2753b4f1131c0e403f1b7428505156e3dadd8610d46a364b36a70ebfbb4d6ddc848c7813b904bc700b556f07b68eb5e916bff10775d6068f898a1b53f327347236336b851162f9395f2b4099b6683b5a6d2afa07d22264039b6e7e562250f7e92491aaeac78026bb2bf13d92ce162cab4263122bc5307b9fdea2d165ee182b984cd29397185130980d00339d7263a595857a93844539d2eb26638c53943f56f066443c1231b4a5431235acf8e453ba1998a300e0a98e7ac2b69386783ce3a3c7fc1cf90b8812701a48e071885d2fd6d0e192e9a9123ceaeea873c939a2dd681be2ccd34fc1baba068bfb844d1365a5f8cc27e70b3fa77960a64d2acea303c3641518185cf69f7961f7407900a4eb3cbfb4a957d7ed2a816819d121fced3b239a9b777df5c94f871ba364d1af447a4ce87862beefebd7742e089f225d655ca0cc021b3f986205df1eeb7989a8051e893b51ac0554a47108de3dd6d1205188b74691d26fe6b3f961b9a75d72c4e9e432105d7bf3992257f8e92fba15125a115a736d64eaff22072735aeb07eced1063b68c72c97345b746657d7899d2179c5e835c6e554512c49f3f3baac7adc2ecfc4b0b10690962d9d41bc7cae8cecfffaeb720baf6854ad2a2f139ca86e1281b908bb06830de29a99dd2e4b66679f28269b351f47fc72f04c1f4c7328e4d168ec67e269dfede6135de42cdad4b4e1cae30077041c7de2d46d371b64816dd4d3693dae79647ad360db0d9909eb9fc9033debc5a9b96d7b80549cd1e4c220df3bd96bc750a395ce0c96a4cf2d09da5ee752bf6b0a9537eae7048d2b0684d9f806265df003ce54aac316035dc35850e28acf117b9fd0b96c1af83fd6c189af438a9ad4946b5082951511a08bc7896018609e7cc2d0fa297cde35b8baff5cc77617e7f0e3ac448d47a7005690a84dacc8cdfb3b97deb9580fbbf70a96e064f3eb763543a522aa246adeef1d243010a7e5039e886d5018b44dd9b6f333685f2583d458cc1043503561fa023fa7546292e9a5947465dbf8b7c7972a992a4c3b38fa53c309055cde4376f105bd14f2328312ad28168356cb3f713f9cbc332c2b474f14fc5331079ff8542c633778879ac051244ade50a395b7b46343c531881247a3af5aee16ab4c326a54e866750b829dfdc509e6165c3490f07d28c739c54e37a58c4f1e563031f1d2f147e7f97b1eeaef61e12ceede9a8cb592cc6633e8024182ec30f2ab2eaa2edc7a3bc6525f9a03e99969b1d2f549d2857429ae944c307caf715579e3c1ded6365515a978786a69fb08ea0d04a66da1bac7792708fe2e047dc94f1a7874e8d110c5b354587c1cad9e8f686752129d5e7c2b621a3e66ab04968257d1f5295aa72c1745c4e3ce3c3e96f41997e3ab88bcf2ce8b7c90780db4b463acb68c839828c26739d346610fcfff7edc8362697fdfaabc8eba920d88e54ce996b533c4f43de1ac48f6cefaa9734e018b52070e96ae26843d19014d0b92d1e730ee3d1935bb493bab08524a5606d03d53f424a0751d97d4ca20d89a30f1cc2fd9d7c5f54ccd3520226374dd872d65295b0d438965fd7e163755bd3123f39b64b6f196961438efe4aca6c2c30e5adb6d389a6e7edaf888d0760c6cbf9c176a0eceff0cf5090f2bd6913b46e8fb3c100d2916bcd3cdc864c815763f2a2af4415e6e4c9f0870b44dc542d4a3cc04e607023a93bc0213be2eb9ef94e5d9c923f9d422687b52111453485b2a4f3b8c7bbc77765d62d2d2f8d674db7896692abb16460e8db302fa59ca6836d78d5e4bba07daa63edca046db7310f230d3fcf890c8bb3fa77318f500c2c9608f991ee68d946b72d03547364cddf26ebc5e390b9f1c6c93b5fb33e728c62f698a731895994e292a31d45143cd6ce59cf64f399c1d76558cb084fd63482bb42ced033c6bb4ffe9910204d0a1ffbc98464a76256a0d9852ccd16b3fadc4b65c2b160fee77f6c775e5d6e2016300f6d50522a6a48c3614f0ac18264a56b17aacb9251e5ec66878351a97e46ce3140cf522307c7d4709981897f9dd3f19b769381f5cfc0946db892729ce40d40bebe44d2abe973a1d45ac54f55b1f33861c52d4146e42ce75f33283942a1b821d3a5d8518df8c6f46bcd55a4ee2ff23f8c872e3489dc6e77cd33cd8455a5e8062b4e62be43d52f13e62c8c7f9a0ba1451060dc2e35335d2f44a1268690be4578a6b15fe754ee6b56631b96ae8c68cd2edcd81ae1d8fd3dba953b7625bb96a9863e94294ff0b969843e87f6ad18399399b40a9b0b5d217b6bbe0c64be5289a3ef16472a70b1501c6b94ccb8148e53e4cc43535fae6d153d1415da45760c2f5d1f47763ff61d698b6c099ce71a90db97bed7a7cd053207eb0b169a573e421b87c6e93d7e95fa9eb02da7b21eb97890c5d2f0f616cacf24a94662a15bd94776228e497f46750363422c2bc3bac67989801d02d0e3fa507b0e56c57d45cdee614114c8ab6d34f799d9933a61bdc87bca32c58f0de2ed363499b5cd71008168475f34604a90d1dbce230acc0f8c3f47069e2d1addc50c58535c93d5fa56c4189cceb34521d194ca633310ca21a931f3ef5ee0c9cfdbc3da40a1ecc3b938f4c172ef05a1a2e002faa7048b17236f7f3a162009015dde6a9d4510150a9522088bab58843e91971a7454756dea9f1a9f400d225a0bb0259557746c13f66fce40cd50c41f26602077795a947b37b07b1bc51a7a75a89fdd5f684caf37b468f5637eaca53849cb25e704d68d921a853faac4663ce5d14965fd93e1a8c8e2e33c55723e11cc9d934bd6257765a1b8731b975767a6eeb2dd9dfd7b592baf4a93c00c84e2dc59a61f5eda3db1596e12c2e9510206d8d6f6b3053aa58afe681d58c6d3d1748425f33367c720a41b9064222f74eaeda774bb5ea8ad87fa089d1bc4ed3c4845cc3fe1de13ce9a8ce967b1dfcc9edeec9eb7ed96965f011cb97b8c14c0a39ab5138159e3f5232b474744fec9c62f315e7860156af9e8d3b891094f854e7a63e3c58cf4edc1686c408c886a200b9c573fdcd4a4b51f152c0072ce3fee02dd87a1229a65dd01fe1f560a235be0a040497f10b86cd4d3a931c650e1f399fe49382e4fe8fc192709b541950321446c34c2976a7db416fd85ac96771bcaa6032f0458d1c17deab4728ac84ebd32cb1fec954cb64c7d9c5d71265492c85dc0a0db0ad7c7804e2f90d7f4b783e9e7cc513491bf51ed869a2ab100e8b223bb975d7e087bf75b49ad02b82cd5fb726f80d7ba3ee03a2d397ffd28aab7f66dbd20ffe71f1ee1ecf6d5248f074e68cd20edc49c473289bcdee3761e26b57ed0e5299bd27ae7dd50a09604c88c5811599b317a12797ff786d2bf63696afcdb30064d5ef1fca57cbbb3597ff35c691138816ec0360d06718dde3fd8a2ddbc51af0f9017bb1632c8d7a381954afee2cb1fe7607dbd70b28552d7e66e5ea38d7e646937478c0fab6fc90c2f72344f50580d84915dd3c2d9dd86f6f2d416a170523a1df1d73a19eb2f616c1016bb5640ba402374580772a2d83d4cecb4ed941f36dc41cbcc3fea3f613276926340152d3b4378ae30b0e5357f0db028e253657f5258af3a91202addbbf90450761976726d66c91abf2cd95284570cd24555358b52fd2f3a89c7d37f576a5e65e87035fcdacdd896edea4f1b2425a681a32a899716f06342c55565fae803b8a2b6edf946122769c72837ca152e7d0407f8a31b956477b2f6591c672cf57b079580f591a84ad82482c6a38c4958e70d74fadeb804a970deba858da3c0f33fb1305e6b8ab3f0b758e992cc2cc2ca860a80d699f174507109a1866e5c0cb2af84cf9ec6f3cf0fdc39ed5c7a09504f471bdaf62cfbb2d1d2383a3e381865a183f72f5680710c7d2ad9c633262031c108564e3bd39e955a9c31b5ff1fccab6ac529e3c4b838f974bd02dc00d0dcfdcd6ab9250e8f314bc990fc14d67a9523862f4f7efb1913f22b08a25900c35ca73ab4dc93245c0a1246920be224e030bef01ac9245e55943139c36d0ecb8ad2286dbc20cf964e6d4e5b23d6c65705102739e7de95ce4258401c5a8de6dc4362ae8bedc320fa855ef31e1536d11be699f899561dcf29b8c630299535711c6b19685e7b609bfad392dc9aec2c5405f4dc775f1b32fb8ce9ab8f8745633d723c1ea9a6fe1d8a913624c87841d907c3664a71f93d0efb0dd1c7d930168d00bd0b65b6fb0168054694e6d3b92ca92e765d206e9b08cdadd698597d4d8f1a01a864e3c7e23dd35336b308ef8cf6643d0d4b0d912e5aaef72c45779c5a2799561043bd6f0523e2a40a8ca2961f39bb5f962518c43181c527abd1bc4cc1dcb715e833ccb227bd33689979722cd8f79ed1822a6c384636b500c0acdabfec543b345147fe89462f2f5266529370872a0288c74565eb5dfaceaea766afe958f342f9485873d5a835956b052e9af4acbe25d3ba1b95a2bf6233eac969cbb1845a4b2090a9369377c4a5b009f650f8970a74c1f48694ea7d7b0a38faf776d07074dba1fd6e567084bd20ea371bc355f2d19b6d696e4a7156abd861c7e14107c1365155711b9f6586be10674558740f7ae01939e83d1eeb649f165b028b480da0976bb0328031e206053f3b30645c4f751e06bc9af0bf8cb60274d9a33016cd9725c79da51c0437d07a2609b1c3bc0d34ff92dccc55f41763cfa98a760634850fea880bdac40ed44be50bce2d3e5177ef08c187252ff8904a62d66de2ba948d62e4094b3cfdae5b832401eb39412b1068e782f5bc9e35348c324ea152ca31c39beaf8415bfde43a5c81c762247f371cca2836025c4e2cc5dbc028fee5cac17ccad6dbc9aa51c5e9e81540b909363ef2822a60edafa548505128fdd58f1a80a14aef76e0cecf8b282544eecbb76d152f88d16af906f81e40fad780fbfba58665e73c50e539b541d12e5206f636cf8d073259cbd1c78ec75133541e48ace2f0cf305e807f22d6b2338f0f4f11e6db211aee13fe4e7b6eaa4165cd2d5b9b8f54e96890eb6720d9840bffa73c05f9846c42e4e98c817f0157694e543076a7a541cb5be8c74d9e6af45a49204f3940d579b7b44f4603f0b1ab6cc4f956c87ba0f0d8e197a60b083aa1c2cd029be39c39a47b848c4522bf9bd448cece8c4b216b14b0d1201b08606007137fd9fc06364b42e7c96c6fefef751e55bee502f57c91cdae103b434ec462f50b4671da98dbbc9b1cf8f171b0fd04a34260e5b1ce861d2ad5badbf5f63b92b48fb6cf225b0565f336b8695a2fb500510dde49682f5ca42dfa5aa389e72581235421350e1c24449e4bfd460fb612772d7405b4edeebee3791d1b0365cce00f038b465a039569927004be07793b3accea01961385c3417f744080c8b517d0771bca2511c10b738d20bc55753b4f2972d34042f7dd28ba51344841c6c3b9be3c2172f70792a72ca312254379aee2374a84579edcb72858b0c6d891cdb7f30b93123785d039cd4b4726b274e9e2bf9db1c8d237267eb41809cfd431bc13683175212aa0f10d6432c0ec7fa420ac2442239af5e7f3f21c30d50a5de47a5e4372faab33d883a3c8541dff6e7488b0c1cae8230e1546cab9a17650e446719b26525bca94b598d37936b1d7922d054ebeb8f8936da2e941d24bdfea046047c9635bc1e8526b420f0dc923c3fa4c6476e04230dddc6ac9e00b12bafe28a7c76dbdb383df6b0b83348e27e34cc68c6a77d8fbbefa51eebeef7cddad88d8ed5386a509e195a24faeccc2974c92763270b7b524f1ff9c91c15977dee061d38ead69cf356b488c5da408e49738534a54c63c391f68409aad3b166c77e290ae7ccf0fc1829b3debd518c5cceb90dc7495475db751f7212cbe1c8492e1379ab973f162030ca69bcfac63e5f5e537f77a28aabd00f717521f3313fa2616d58763e049b6107bb584a4e4c841d00f4e59ce1ab7276bf629a1bbd93cc5fb3c416f492d4c88103da8157246a8a37db96cafce4855ebd4a280efba504ecd0fb1f6ceedca2b6c4a72cd9f10a1f26568ccb021b6754852751c674c525554e847cc2ab4440856fbf2bca517fff0b4bb97f1694d92fd7423be632a7c7317d657342ec6d987a5b7b9c030bcde8ca9fffd43c9e13348f4bc54ca04172972ef11d41f7d3fb46b5a0b0243f37e74695aa8b8a5c453d699f02dd1ddddb701ea7424f04a19106c3e6054856531d2d5b1164a839c6d2919594762a9b5abf30641fc0cda2e4a6e58d4c1caf32fc21e9634a67e11f554a1c466917386bd412ede25ca94307b0dfcd99ac0f2814779d732fd881e303a1d560b86022fadc1fbfca3c97f546393adace55c5d4efa44d0576e9242fd02b7bfc2b268e15d382b393d8aeb5a9647762e1643dfedc0af7266d69276a4e621aef03eb641784823edfebfe3ad54aae90e97dbdc567b83504a2de5ae73e487de4c6eca6f49d32744ad0df1ae8734ae5d2534ba78e8f071f2333690dfcc662f22a2dc23fe3f341746d99cd72b771b566f8910f3c9b927f9cca3f92ad739c149bcf14c05e4638792c9bc19371b49a3f454df51fa1e98ab4e45ecbc1fe443b8fa885a91428e3926b6d36406b300b224edcaae9b78f1f2e48dc70b3517736b33af3e27ce8a8bdff09023f9f34b3c990b8a5a3e0ea7caaf8a3af9174d9416ed61229cd020658f1d46ddef21f10acffb68e3ac3732fba873c1135e50eee8b797b7867a6153a0b90add3135596d4caedf649d659268e36bff806fb352d0c74558e4105ad51dec119f6510d609802fffae10d273c39adada3e40e568d79ea44f907b3003e762aaa083ff63197585f2732d388e9de54a451a5eea4524fc3c33d728480e0e53a46a6592a425565c02051e1c66730d3dc387e402abf4a724688d84bb6b93e9aabddbf8c85048140dffc79e758f676dee466a04b043e1ecfe68fc841ef4ddaa1317ea3166db1762c6644a0c899358e89526b8a7c5d0d3950e7596fed2ca0a81942f6dcb750facdc2ea6a4847acebafea51ddd27c0a4e9f76002ca0856410d3de183609b97b91d934d26037a92c51d769cd139561195c3207ee70d40c096094887e282665e0427878093b3ec52a9c08c4cfe949388a6d7c0304f991ed2198f8e5f0bd8d010e73dc4eb97a3e2d953b6d6450e51968b5cc6bdad0fad8f1b39609f438a3b52fb4502d7f1a3ac8f40032c7e5e60ba7b6b31b4f7232287786c16bac275408d7d1ccabe6b092083ac4e0b9a3d5f2ff857b1dcaeb59b4abb329bdeac77dd3ce992f9a0ec8d56ffbd72c5a21d907cd6e2738302da25249640f58f2addbb52d4aab318527b831e192d6c45ea944574985ba973201dd335f0c3e55d92234bd86ac91a5ea12e03d79dc912ee0e1f5c84bbfb54bf7999463317255a76a01bf16059e291e17771157c18c85522204d4f5af53d8d09ad7cc7434efd38637c98ef4c718d3b90373974ff45823144668b3d7fc69750c14d3e83f5609fe58219d42f73545fe7729410719ecc84dfa24259222f486c993ca6926f2909477f54efa3b7caa0201cfc827b47e3c137ab8a1cde3c720f782b5f65f7a809863c80787f43341145e447f3de743199e33f210ab7e7fdd0f8416907c9391dfbf782f7022feb589d969ead49cc60908b4e4b0c69a0cc5bc6314543f402b2e38ecb9c688983e996ad061a0a6f52f8846cbeb88197970b7f915220d0881fd4297a69fcde6a8f5471dde32875b90edcd784f5afcc502056b8bd2ddfec257c96ee86698d3b94ea8673be1f6d5bfb632f8c55b8869b15c2b09a2da4316067821c7408703db27bacb823eadda1323b139016c8727926f8cb3c69092792845c9536174dab938e7b08d1b825563fdd74cb26025c483c4303d2c90a5632160cf1e6c7ef8ef7cd033428cca08a37b5074b0632ea6ab3f3b0a15a1a794a27374c0f0b27939f129dfe7f421c3fe29676331fa0e9962cb7647bbe84af6864a5033ac78163d91f93ef42ff71f89ac83f024c07e85539ad0018388b9446f341737c3ddb3874886543f85fc58cd3c9fe7a90e069e3048031bd4fc8b592a27bdf9088a876cdb0e4cd76b479e96d76c18e3a22a25b5e4e029f650dfae3c4caa6d0cd506ba4de1323bb52e6075fe90bd8b1f962795ad48a1efcf38bfb2cbdbdba771d36a2a51d8d86849e56ebbfbf15e03ddf0a6317f9610de5b92174987d4389eb9d3ada81f3e64a7c49e3d15c498ea276e7dfb55a3c69baf809034ea2b00bd6660c3656d6345d5ab538db7666824125667065fcd8efc88507c4d760b900e714859eb1d13948fdaeaae1c39fa5d435a38d6cc9d11faa522981b093bc9a92af58ae7aad1a27c75a1c33db4c7ecf5c6028e1658b136aa427a3618ccad828c815fd5d94ecf42576ce5f04a8015e30da3383cca5af1601856aac44bff05c8f2271d7474d8b53037d8f1ad367e0e446b44cc93a6d10e73c7bb4789d4e239e5ebf0343a392bab5f17d94be0fa726ad0e82fbc9516387590f8a795fbd9709f9036cf2a2cde1d2dca5070b5f71b7b7bc2d61171076d36884c4a5724402ac4e82b66499e324de2f0fc61916476216a77ccb984e03ec5f7175dca321fd794ec0d653f024b5947344b73575ef7fa3c06e8fc8c8b9d78dd9dc8809f069631fa7313fed17d59960c00871d4535625a9747eeb6b7ef2c227f98d0e488ed945395ec57723eb9f7ee8d32d06bac27aee0d68136340e5d3dec515d863e62282dca20b472677b1ca245ed86a30031e83057ff65669a61d29c9067525953a18e862a0f3fa431667c8323196e2bedee893db40764dee5b4ee75fb34fe019cc2eee13a19a3a50d4f1d3368996496f2e5a58ee52c0b91d89e3e716a484e536dfb9898b5e713ba77e582af1d090e28e1b1ca57d7605f9d547cabde515a5ba634dce32ad577162cfaf972d2d2047b0fefd75a5c4e820a19be4d3af1ddb3064b13f7616313f37fd4063923150984153b7a6ddf6443db498d62dd30a58b09f1b513a5fa3f3f4a2fd73a7eb7ba2fd48f0d6f8224794d5944f0bcf106e6c3104063a4fc140573a3bbe075a6de2226e070e09720f4fef5da334982cbf427b95eb2fd8d03f0c8031df55c91ff2618a6714a284d86c1e70fe6eabe6c28aa6860ac3828262b3ab851ebc08f88f827f809adf3dab7570ef067051b35c6055d2384b72630f5eb2bfe424b4eb101946cda328fe51430f3e3d48b591aa5b804990ccd6e6de7b7b98477f48828a195241f34e36a0d9f544b066ffede8acac5dd284f50a7cc25e87f4802e7596964400a017fdf7203307471b70d3f6ba94220140868e5d2b94390219343c70c339df37ee03f1440957e4dd0a72de12289cd3f5857cf02b8624303a27b64e40e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
