<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dae78397e37c3b297ee147d1379e672271a5123d6e7b9eafaa537a64a26993038f591e26b68a7995e555b594c7f48ce5dd688955c88a8821e0e6c88c8d857991b8df2fdd9cc811e0ac8e168f56640220c0dd3609772841545d50b45fc9de34f0fd2b2ad5f3b00283957634afe3e5b7ce12acf490cabf8e1ce006d056b46ea77ded3ee652a5a3d0aff4780a9ace8cc2eff6fd11c441c07ce60eae025ec649f340e4588f6dc972c8157023bf3e68f655582475e19375be5d4f3044d898b6be34f2e661598e547b04f86a3c24347d2890f5af76bc63d8b76dfa239fee6b9337f4fb57de62a23da0def8cdae4ebd972e62ab434e872c2f58b8f9be875c594db1dbf46c4908a510caada62830148845827130856ad8cec93c5ed09a46061da798e314d6c00f06cb22098267b573b232265ef37c72b6d9084635587f20180283393bb11d96ab5d0ca8b35331e94b5f85ffe4a584a5f47edc2dc5bd9b65531cde06e6a621bd71d69401c5d5743a18befd7dfa4045142c91e13ee15d7d1843042cf3c55999414f5e881214f75ee8bd96e030b64c39ddf44ec6d92be238d3be6502be649e42d6f1e5618810f52efbb47cb26d1c261754cfaa80e2215c065a73e2bf35601cdf00cf2114bab511e29194ec40cf28e8898a5d032b268f846c90436ff9e2046014e328f4eaf4da524cdfe953a19146d3ca8f45c5040b05e4e1fc896aa78c39ab103e2fb996340cfd3f2c3597728a8e02d2f0774381b624285cb7ef088747dabd59fb4d2190b9d02bee79a6069e2754c68dba601469c016949216352e28d1ba72b9c70b14c45be805cb41639d3c67df1c633e1d3dbeeb2ea11a7c211ccd69970a951b30c10a2b1b8b420fd9270ed3dbbcc2ea6afc98e26095bf26fe3ead630df9eb4495fcc807d506939e34fa9608797b28ec6db8e62112529ed3ef55bc2f72f5c2d7e7f0f4f1660fbd8fd415ee8d1f4279947d26af1c739684c13604be3fd2d1507b8f5facd307f72891d1c5b6c4b1a5251cce896b769c912849325ff9df96d9421563fa7434822dbe778258b229cad35114600d8d71a5364404c9a36ddef6b06fab14a46c2c9833987995d7504e77718ee1c96f468c03ab840cf47c52a2bbd944be0b5c7c65ffa311db48e102a04fa4372c4c045748ce90bf228864759cd1a2c787e8eba6a9f42d5c26e0cc135301b67726b8e2f25c7fc87483f17e5ac1f2fc3cdd8b333d8bc9fb10cb43910318879380ecfeda5268e9f101a3b89d2e7c8e99eec819e7eeaed58252524ed122629f9677b727608cab5d7e9e8d7b09ef389dd29a6085e30289db74360cdc10177ec4d2c050af871c02eb8379e9e7c1aab51ac09dc8b2ddd144a9dc6cb4c7b879089a9a900f049cc7c108d9f7f2bde47b8c5706caf2a5d34785be72b664aa611b27b0a3aee1b93dd1dbb143bad21799c9188ddb356e2a1fd31ae9893d60a479b3d5b02a6fc73935afaf0ce63c1ce67b74a4c151fbdc797ae731ba2b9b1e67132d12a14f501bb19390305b0fb1e91dcd34c76e1ff3e6ba57819448107dcea658ce2dd72951f4588c12c53c2e3f828c1987f2c6a6e684790f2dac23a48c9da36ff6a3524606cd9c48c1ee94e92af49384b0d442b09b5a44bcd2d554cad9654aba587a8f4588d724c94f0ececca5344b1f62905248b1d9e8f912b81b74146247bf9ef5fb1cbc7c222db4592e5e2bc8f6c04aa80d2965852a2eb37fcef60be3ad482458cf6119af6330ce1d9742f67a0bd7d521d2ba7807ca6fc81fb8ba450b84736234bb5b8bd54be0e7fe06332ca1e03dbd0e479c3699f3f2338e531014d1a7d36494ed4f4a977d86d6db5b844e22e62e7fb2e61bffc88fa562bdfe2ff190dcdd028c3e543e3854e545b05ae90a688809c25ac37a3412f2b991457c735193c57153e7ea713fa6c932c2b8502e0a9b6b130d8b226053853618b56cb104f10e1ec818f1e242fe819f38784878a5d8ba2a02aa1b5dd3ef5ed356a5877bdc86a0db93018c5014385c8aefc65cbd157c6d7dcb61036a905efbcad5feeb8ee6d934d111c236838f670131e118031bf99d9f111f6829e5f3e03c46314450bd39a6409c181aadbb650b70be04cc42cfa7fd830cac3fa364e26d9b2f1dc20cc1422786299d12e544cac6dd8309f16dded6f18a4b2ef6ef9b5ac0447d0244c82f9e98723f8cc182ea4098a2f65707983ac5c0b84a3c1a3a1d5b76d0a3a6300bea63b58971a02dd96ae9e1e847db74e3951fc5e0f6e559e8d5798092f80c41e80118e0f2eb4699d10fe76fa830f96dc9c6b9ec6782628eb775e5e5cc12fda4a75a20b85e641bcfaa7b47907188a7bdbc20175c932f7692cf884b44b09a1b8c293f1ba66faf54b619fd8603a8b75d68e970e25a413adb44c480f929c04cdb6916bbb404376306752833a8d9c57fd5937f4d3137cbbfa9a41a19e1328e270d82cdfc3af7a616dd510349d4359bddc7db28b580142ea27141b9414cdeaab3acdb4f79dd4d1208c40be409bc9ee4a4457b5e9a97666925efd5a990708f3ad08f961e7ef9ec3b245c253e693540b24e6cf719336432564defbcb514836744651d992e76510e45e94361ba50a1f1ea84c9391689cbee2aae9170a64378de417cb523526afecbce1c0e87ed2d00e72cd84a0326b6fd3ffd15f0870997c4c42b5ffe0ded7170675307ec791a205849d1f56a323746f566c8faf8cfc23d24aac3a720a169e45c55499f74e311359a6e7f70873ee29fcdcda6ccd73cd4cb2713c668449fec1cf0a5cba97736d0c2a5056115e1dc4e36e55b323e08a57a1789cbf8ae8ef85b988fa5e381f9934ba607920ff7dd8d42460909702c7b442cec7b37609eddff6a477eec706088af0499938409b4409e174cdb6f0ae6c8fc12740da96006d28e5e81eef4b42a7745ec3f8a28a73cfb6d269d3b57e60e589502e897be2392fd05e1bd8a479c7676d8dde0df0e6b0cc55b9b6f21824045ec80fb4603efc0ce41a8e3f5675de7965d965a1714ac018ba9a26a6b91135a884d025d171997edd8493b6aca75920c55d029687727074e321294a186fcaa6ed3e3347173ff0a2a1bc96fa6fc3559bdcac62495848d1e9468b02d2fb813b275d9831c91a32fac54c452b3d1aa5dc4ce3f4a9bd9f8f8f4a629e015a08bb0d16d8b0c77e736872faeb66179f47e0875b584c0226f4df209b6d732e4bea8b6c6a24f66477d3e5e12ec8e681716e8d9936772c42da932b964a3546e419410265207faee620fe6105477de0a3fd6f3df565dc2f0fb6490bd1397602c29e0a625c26ba6536d5e458a636352f4c6a1c9f398f8bf0d7e08ddb0e959ada14cad0f2e4b5d312d30c9b30bd6dc2199cc32a746a6229c83f74b9de571c99b02b3f1489fca34c7fccd76639ab9bd56fed434864485b8861d50b7f909875e6f0cb5105d1df0a4c2d301c9c500239643c82b3ff355f85c23b53e6735a32e720da19d80769e00aff32f9ef695d499fe0e17b6dce8b0dd52bfa164677d1370393a27fdd8bf0a210a3236d0047b811a77192b6ecaf34e677bebe0c1315c41dcbbd59bdd3f69cabfbc8c55ee59cae0d7369e898addc1bcea37334562376f110b6e4093bba77869e1fe9ecc9ababd525629bb5f0940018b8bbb33cf9e440f9a47220cb84fe56caff82f069f5fbd281fb88de2744a38458fcadde31dfc690bbf4cca3129026b60c012e0a7ff2c29eda2a71a8a206551fb5ee6749d364a624b5b14e21b483f2277622dd63f39b8a53860d0bbdd0c9a08b965cce529c5c3b5e15017a0c18a3d4b2139a78923cc0590ba609e62347b4c22b8df9e78e5c7a24cf1e920ede004217120f8c0091745e8ef2b31feb379706a884bbc1c4cbfadba4069a1a30fa75bb1bd3be53e416276de3fb549d4ded8cb61b1b5286792ff9fa887d319b4bfa166528e4f424ec63300f8ba000ab06241ce04a4e0e6e9ac24f2be3a21c84bd7501fa09689b6c2b498d25d09b9726d20e6b9e2586193e64b74ac069cba75fb24bba0aa99eb53d0c3f3f60ed1963a32c886fb2b01ef10a935249947db115e0bbe292b7baae6fca2b08ccb99c72c736eae9421c30c2797d6c9b941c0db4a6b7e44989d3107e2fd251b06411d6ec6f27a69479bb348160b94496900980ea4197d33489e024ba6449e2aaa927d1721648823be582014b2de84e07a4fd12d55af9393c3f7a6bf3fe85461ec0f27adb7be2a73b7025c07bdbfef049921837a66cd44543675951d156b12dfc8b1ed1fd1930bd9246f55160ea3325773fca711183384484a05dff0beac36193b3f3ff6e4f438afbbc45dc8821ac49e6d6727d286bc4c87f6510eb02e64680099ebb285db51255b301004b2e421ad8e7c7dd30a5e008ed618938a05b183f996118f1627f07af77ca084bc9845b3fbe7f84dfb8ad363bd0534f123e15b2956da812469a52eb44a32af51dbad3b6fec8726c1eee521597bbadb41b99ab50047fe181303dbd2ceedd332c67f735b25098604503331bd52c39c612084bdffdd2e45e8a2f9c52b26e2093b14d470aeefa478aa83334aef3d360a9270b195037cb704f7531da58a5eb4e85526cb1df341bbdfd10e92b67b5586ce2ed56ed86ce604c6b66b762c58c4f1d20b331d21387cccfa78bb951dba10779c7be4f29e044a7af2b6cd8df1c16447d70a87d818dfed317f5d4381d36b0d6cb613e06b6a191eddd80cd0236ced803e78d4e977e0127131bdf15fca91ebc4eb0977ab574bc118feeb955614d26d6ef3b2941f1908b5b42c09e90145718543e06c3701cf0f8341bf2589f65f97d39699e0e7e362e5bad1a7cb8d22d085ec76b601dfba3c52369ad55dab2bfa27cb6029b8ddb57689104baf5629434455d8f9e8e81d8cac1e30eda079a69d0cb3aef4801032f4bc089bb0757bad5fbaa05eee72262d76d9231d0a998c8a738cece3fad282b5b4e7693d08b3668440254d7fca8a6130c96a47dc3351402337160b25d6a36fe685c80610ed899fd86912b418a116dd54227bdd93ceebec28e22a088d04d1c4223f6455080ee5110627d33d6c2c60b89870ff1be22c227bea38914d19bf1b0526a408ae4a44b005021a255ee9e49ee3194445c41da316f1ab902448e9bbe2ef1ade396d721250421012446529923a1d1201681b602cd07aab587e8868b9a41a28806b1d7707238483d882c9550ecc9c0e41afa18654c6fe3a801b5a2bae052a1cbc9d5d8cb690177415f812b919e6eddb7950c20c00d57e0f029527fc07c197f389efd29c6d0cb61b8621b6dbf3c7286899f079339e255873673d636e671e7ee76b62313919500c96ffeb93f7c57db5bb52cd5ae8a7c0cb9850ea5cf49d719a25053a306807c96303b14c1af86ee42fcf048f7743798f1297b2d3187f156a17fb1c5d3e53cfc39bd10800e3a5c9e8b4188968188e87c952bf290efc2e38b3816fe607778d5fff7ac2d1182e6e9c7c3c10f6af9f729fca432d929ea766d31ea793946f51642a0340aed5589913ae905865fd8ae9b23de7dd81888c3b28de8779a4a2c40b4df9c9f6e4b9e7b542a0b423191e04844028043581b86d812771ddec212d5aacd36b279e810a54e2c7ef970ee6a005cf8a26dab88355ae575c607e79d64e72168e210b0e6a42623f751266fb363ae091a309a920fdf1778f37ad23605bcde01c1ae4383dcba92ca318faf6ce55f23b806a69db59acaba6aa66aa49200113275bf2b4199b73b422d7969ea1fc12276e042e6cf88eab60c6d058381f78976ad5e462e83dd99a39500da345c2c6dc6d0b223200a3af398ca57bb400d57f76d084707112d94f191522c8337b0e9f921a1d13af503d778ff6606e284e8bc447948ab2e1b45fca4303babb3577d6d7c4278686ca24a062120d9fb6f9a3986b9dd83361aa746f70ba4a7e11a831d946b6fa7150677940f8f48584f55de5a1a25de5ab9b2a56e1362226b13e63fb7d5e8f94aa038a87f8591c40b1eff1b7f8132a82792dfa85a686435d7804d0c6dfc6cf4143848fb0ec275f77b95d284a77724ab74187d810b9d2ef198611399e76b63ffb333da7be9eef16205398ab7c239964d805196d2450716f81b4afe35ba9dea4853e6bd37bdf7cd4793a0a007bbea19045a010a4be46b3704b2db314105aa7f57566db3408a6f55c4808b325d7c41c4380bf744c3c672401e8022179509d5508cdc884b201395edb8cf403631d21352ac1c5f0e46c691d2d7fc5a86469cc41efb098324531196f675568fe47cb8a9b87880b673c19ed4534089d2355139043223e9a0ca872ea528a5ec831040a6a13055c1c91a1f9190909f0f5e3e1a6ec4e5a412142a7ad1824c659b91bbbb0d07e1680ccc90a8f5bec0041692b218237da9e3a147684b2537462e1680e5905db8a370a27c694be93de19889938f9b38a1fa31f68fdbcaf191e1fb6bf4a377aee7441434440558b9a13493708fadcb042fac405aa884d4030e6931a9f618a374292650c5db0f91fe8a1f529c08101f8ea71f0eb8c16f9116c5c70d9ef7aea8ca37236e9fa5075d703f815ad5d8211a2e06f5e32c8397cc44c82dd6ba09b404d7254d106f117d3a2f9d2cda79b4b0caec3650e3d6479776d69e400b233c0c9481d7f23eeeb109426a8f8cc9df6742e50821ed88ec5b4a64e03cf863bde7c3523ec6f00e72b64480ad15a368d503599727471ea70d631b0df66f9cf9486559f0489e2c15194253c878e8a3141bad2cbde0a03407f55e8ca3c6128c0fb91aa3767d7a3767dc318f46a504cf5d288d3f5f60ad9e5728ec2ba628bf2fc9a16f420ab88126983968352460fa3d812f3cec23803f38f93afd1da09514f4496e82c64d7660c5582604b5cac5695d77502417526c19ea467ac4fe021549b3fac3822441bec83d78912a199f312055a44de548b5d05c320e3a36264a8de52477b4bfbab95aa834ed857e71a80af0211a1a29bf1f13ac22a4f12e8aa6a83eecbf15293a4f66a672101a8b53cded34f094ee97128124e7b7fde34537dc38280badf8cb8b294862baf19284532d345c68ef805749e6c17d6bc132a373dc60359e3f3e5f57f5102569a07aeb10db8a6c0bb770e23effd14805de15ae6ef771532c511d5e96bccf242ba0f50f8690baf1ab7ae88b7898080adcd245aa6f34ef080445e90e401dd03c31bfe9e9fe8d8338acec6eb07111258cd1aad914a214bbb303c6ccc88f4c52174f9302ea84260223e8125f22bbd149c285d6f068de2b95420f8dccf2f6ac2d894defebb8794c3b16de0039093dce976f7c5f1de65e9c505d7ddc793d28b37d43a599d832e6735f4d38758931e65c0634fabbca5b7309177dbab13788fea034697413ae288ad607b90ad13891be7daa294dd312a015f4fa60c5dd04c2936cc4df58c1c95382cfd91cadcfcf06995886e27a608f0f87477e4cd46f08edb2041ec6aead728f4298ec2677712571bd267c90c026adae115155041a7e65835c4092b9c2f2929e2a162c9d51bb0fa4350fd148e3e2fbc25b82bb8e530057a364f24c746905878b284389fd19b9094783f8513ea70872b204a177df7d137b132002afbddd5c8bd0b5f5b52fe25d9245fd4acd23561c26b4863e9934cee4bb0e02eebb313eeb1cc53d827150296a954e1995be6eebe7c3bbd8f6bb6c24d46dfe1c2c82a54e425c71bc62611e326452ab3195f165c1602b929db426554648a2135524b47f23cb6d3e70b1559bed06d2dd0025ba5bcc1ab66582d27e2616b002519d9624219e4165a1268a104feea63d604352385b6b99d2efbb1b38431ca9997c07d9d3312701658ddca92a2f959229116a0b215b748703966937beb975236b68c6e806aa01707de92533b90aace223ece510bbfcbeeaa667d366c11682ca2e7322027586bf36a42e5b79435c28001b93202b328484aaed96be9a203ca3a640fa8e2a88b80fc89c4a78a9d9d930f59149f4433ea8957f841a0cfe452e58be7e38c20678cc9b5e924345167338ec82499463e1c804c25ba3fd004a54cb9b64e59ae9ccf8b9561733f9ca41fdbde5cf77ad9bfcb690744e0a34788ed93096edc60041a5063b8ef2e92b447482594d774a2a740077ba84480cba0f08a9752abc528ca8dd9de8195b57a1a17c1b43e11d6fd8231e44201a97653a8fc3944e514e993ae460c8bb971d7f70d54fcb2d0525df6fb9a7af801541d7249c9c1cf178934664258ed082526cd70f6d35a98a6b49a85e04023cf7d65a5523f7c963f1011f64f12dd3d8dc31647e99af40f58eba5f59026ebf2004cc55bfdaded85b02e72a25e7c381a8156d7d439862ab9e4aa592987891315850102a2ae2f070d5330129f20e069aee97e4edd21c5b39ed3390746bbd0ac849fe1c2f48728dd1c163be4727d575b27fc9cd7a2718859bc1ed37eb0fc1cda4152f6a9956ff3a5e50833f98c51d33cb44c9927ca530ce5b9c76675d75c1ee0a41c35ee73a06c4191cf1824bcef49c252d7461eeee90fb79821ce350d0f927778a310d8a800df018550b2bda700a8a4eb50824fd1a57f701078ea026629336bb8a9c63559639ca2a709b7440aedda491a3cf674c56de9f1da22421b8e118d3dd0893cf07a9c635e5d20ae22730b1e77cc445a6ae0c00e8e77248354d2b9ef7159d167c1573c0bb2a5764569818399c5068e137a58a49c6f3d463d875229137e41ada5267f440e573810cdc8149cd7856846aa2574d14912dd757056994a9279b26ea508da2d5cce6d2b1c50ed10e8abd788fd1f213aaddbd696bb8c2cea1b81edfd144b494bee48861ebdffb01facf60bdf45ebaa4ac229f926399b97b355c18061f6e9df80ca1bd8d8a695037c310f7cdae936a18dacc7e723eccd240a2dd3f14be566d6fdf34767ddd403d37a8e3c68627bdd281964b3900fc1d56956d9d039337710663b29322054045622588ad10af2f00adb67665820cecae9d8583432b4889113d1d04713a4671f3bc4ead134a5e408fba757d1e462717f53dd35d4effcaf33fc993e33d74284ce68d7676e2d6cc14bad1d9622f2d7e6ada55e308004cea470bef6e583f2610b2aa341d27a6db611c7d3bee32e7899a91d81ba429401578adb29cadf4dc5ccef36585ab80997036b3dfe70a4a2a3bccfa6edc7940e92bada9e8ca9286b3cf42fa5b6a68c453d364036b18178e38763f1e29f3c4c686832c3ff5be19cadc2a0d18e10cb80d1c959737b10fddac379a999c3f1692275edc7d30355318c1ce63ae5752c26c9b53f5e3109d018999215a9f7fe51f1a32da8c22ecb8ce1d6f5a387546fecc3f3e1dd15537641e4bbaff0d49b142a984d90a8b5a856e30b076e96a6be0fbb5bb95a507c144f5b4412bc48dc5b5ebd71290bcf9fce1695f3dc761079e82a8570eb6e1e09618d3a9678dfb1678b79a302f052ed6814dcdfa01e7c8dc2dd9c9841f9d04e88ab9a80b4fec242fb4bdbd57c7e120adab371ab82b2045369db8f783f6a1ef54e9d62ad187bfda0a65387d67df46fc7795654ca9f447cb2580f24b70a1f49a7d352eb85a60431029115d992f8a9df984ef71091656176aa37e987a0490a0154ab43f6b904fd568f457cf123c725727859b1f3092666a741a625b46a2a6b01da03951ddc7cdac5faa24e60f9d86dfa1e1fc398695499f70eb202282030ece814636b48fe409cbd135a5390db86af43763809e45b1d3a81c5b7838d18729273108ef222f0bdeaa39f09d8ff5787893951c15cc6718ee83cb58ddcb69b5dce66bdf9c0c265203319cbf996032f8b9553c0efd8c22bae5285f4fdf3298d9b2f55e38d1dd3ce944ac2d2d60066b56c6b9575898534e0ef79060ea8e19b4d293cafbd95cddb148aec7c9dbd808700e575072bed3614939ae0bafb96cc72b42f45ba967c58692b39be5999c97dfdff3201abeaf0f4efbabb16612f613e03f3fe8ffc40a52414b01b85d0b37a1a24cd61ad8ca3ed83ca96b9ccdf74d90f49e340e7ae9317bdd7f4ebd98a486da5a5c308284e047b788379d9b52ca1dfbfbd4322117b8947ecf9f984f15597b812dc07d6f0ec6cbc9790f2cd1f45d7c08c0ebf423d80aae6c6b64eb8937f0e66581d63d127cfdba7340d12a5db0ec416c0156e67ad0ae742778721ae1ab55c40f6344376f19050db7aa007e0743875b23253018bebea1721ea4d9d0656a082f117cbec9c5e0fc42b40ce89fb5749c5a4d2d1b448bb74f3e028f6575b795405deacdfd161badf765feb2067e9d7f915ad80b23e8a6a6c11233c605cbca41d98f49b6d45a3d38004750c60a6bce8793ce91edb87a888dd18e404c4afa15337392eb08c0a7708698a646c15d6831548f913695796213fd3c810b392ea380992344a656d88a12d3dc1d9b1d8f5747be087fb2a73d89d93e2a02479631d5acd1c57e78bca3b3935f3be2393fc8219e8ca2bdac0d813f0335f976743d1f68091a1c612267aaafeacc6c4d758adf6717dff735ff2882112d9f027dce436ab73a2471c0481f7b774c284e60375cc36f63d74f8757586f35deee50ef7b4f5d8cb2b097a26815bba2e8db3574475d1decad9ff98491b5c018b854e7ff5fa6d479d33799bc9acd56025877db524ddc177a44e3a2e2398b7c1fb96a3789f0f6424f0efe71e7e7a9ae0e2a202a065f7b43aa51150f9f7bb3820686915aa8c6f4d9227fc0962d74f510c928b62254f1a1d60a6ea6da459fe332c807e6584cdaa5f71e30cb78ee7c4b011d942e61e88224e1362e8e4f5f4e7e1f6abf1c35426c8c3298d7a3bc4094afb59307914dc10b0d13d89cda585076cbb3a68e9ddd7b0784f1005c6afb1056ffb09144424ba6d2218b24261736d95a73102abf25380ea2a7f090f9464d316327ebd263acbbf4830ba9c209c5ff908bcaf3a1887680f04bb70df9cb19df3f552146e6480aebf4e1ae3e048c71512ac8d04744cfc0175dd52fbef7c72a8600e99b14b3ddfeebc094d36a0d026e78a5c45681d5da76311932426e261288cf19fc562a371c2b93577b329c62a0deadc4996dc26b7d01af3ce5e7827a213899eb7eed58674c781ac06d4936c110142e12a634e29400f16a2bbe650768d77adf501820206ecadf4b2584c26f20ddf7ed33ff6e357a8378b5db82e10b88e7348222fa8f7c52e9b4eb7cb02281372d5607909c0adf28cbf072a77d510220ef7c749843d96f9d56bae0476c0716e0b51acf45e7ff163c5fe3a2517076750a70266370ea77164f6f8824ad7014228b051dbe32c71d3a5e8b7a04a24a9650ca0e92f234cf915663d16bb6b1fd1496f34dd812d00fa851e8badc3ccf67ab6faf4cbe09ef94547c823fcf38bcd3580e6c96ce0f947a749bfcd9df8e5f6d9cf4f45fddc61e77ae8a35b629c5d2551a882a379bd2cd528299c7092841479a37b2b85c7379bcf92d6e60de0bdbdd0d7d63f34174f362438088ab7dd8994b1cce364897224a8e3b9828ac67cc160b54352bbeab95d268893ceff085d564befb15cfa154749286d0e092e6a1b0275faf1116812c44ddf2667d68bab1d642799f68e94bfa9e6f6ec02d6fc28a5b83dc05eca8f1ffa4141ec6dbac7e00c1feed8b38869bf7f92513b0b94317679b08f2cf6c49be1c3e7e620b68e47404829a489cbd4f34fd4bddd9a9ab50ec191f9b33890305efd805b114eef48873789b60b384cd81b4f9b134ba1e77104f76e4dbd65486778be021349f458b52647a43299fe96325401bb98ac9e259f1a6081285b1c5b5ccec924f11e65041e45a800700e8bb86eb04eff0502ee1fc6d8bfc78ad4cbec7e8c1561f9a334c16a50dc99802fb57bff37b5b93195217a648717bd8a52c195986dc03389d3a2996d72171fe96487253041b26474a8399da85994e820b4c1ce21fcb6ecbd1c698038c1fd0a8fad50ae045ce49179cd3cc247c8d656625f2e070d4ea964ed6988c7a968e87d486ba1a8e8649a9a6cad42bd958f6a1601caa0b93ef26871c3508c1013d410d122adae261961fb879806d4a7ae788c0cd8b5d5ce9b210387a3dfbbf7a9725ae8c187e5c6863e1ae03b2ce0f4c6911316b3c7b22fdc8fef39547657a000542ddd7f7cd16f92af8308d07b5fcbd030dc433bbb1cbbf5119862d2d94af44669f0a0b4d2137825c79e74b5aa90eb8660fe7b0b1b5c8f648f03c081fd43805ea67c5f2403d3ef52be5395b5db808a89cba5914fef9b1a96b567038a9b9c0842c13aec4ccbda4434ea89dbea7a9c27bd673853797cc7574e869b7dec1dbb2ef1ea1fa4192773d423a238a83e8ac902a692667d1b306d2842f8883c3558690031aa49e3a52b8c9ce6506a7850524582458d93517683c5309eb0406a245df3b884761c3b7a2a6e15dac3018054f5ebd24a673d0ec5152c4fd019a1c2c2e0e737436217c61f785626d8424318ed0149e766981c7bff6f710174890d343a665d7b7a2d2f41b58e23e19c4665f81047365280b6ac87854c32e9db1f84cf675ad6e589970fb64f4523fdda4dc32b13d023782f59584dbb8c87bdf69bef8b94d8618dfab4bb3bffe25ebf225e6ea0414c28492e4ab72df06dc713d8f0b54cd2c581cf46df9e9a2db23e1085d4567024a2b8545e16e554d0bee1df9b192c041125757e79d560906755f180a10f22ac26dd1fcfad95350d779defa2115e4d46e9274f3c722cc06127b39eb6e06e8a0ac53ec6ca27c6ad69500f65b5cc1e027a99345d0e311614775d01e02fa4930c0c2eafd9311e42938c11106880592f7f0644e64c65a16b2aa26c56a0d6fed1a14f8f00b90c63a898f5fe6d3e0c14119035dcb3b46cd3db0ca680ef5064314fb1fbd2634c90408025f6c76473fc9e71ddc3f1a0ab73575c6e4108b3f7acfc50290323219278ed2cdd4f52456ea0971ac995a0fbac80bad787dc7edf4d52c79d96d47d146f37ce3532d834ac25278a24a3d368298072a50fe54d458d3bc40da5c156961c365b1b48fe3913572c8757382abae6ee5522d4a8d2309bada8f865056076bf9bbe07f3fe61d5ce39ca437143d30d51a595fd065171264a5c1f9d4065cf9ddb56ce2d14cc26a627adfa2605a14bb9ff890a6155bbc06b8496fa2081bc52c5499f997cc54573d6978f290149cecbe86cfd354fffa2ce1550c06e5c62c9c38db95830b0c5aa7cac11f1916d9f3c45d5aad3277975d3759df1364c4a7d0dc2480b784c9f1073b693706c6563221ddda1979b6cee9dd0ca82640ff3be3bb5bd41431bc80b200ee0c9d6dad7c5bed355c847f5c6967dfc4a11cdfa2d6bd601809ab98342f59d14b5a33aa52e58feb76210053fea7a2844fb0aefc045f2ee8f2db42713f2daebf56b147fc9dc3541804f2d01645c8e0ecf42fb08a16e82a6ca5954b285b9521d19f2242743079c7ef0544dc2e9f8a3607ebeba705a264432e4c32397c1286825e86ca900cec3400deb43382812f06a6cfa549d9e149e052cf34be9af17f8763c46bd82e2d924","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
