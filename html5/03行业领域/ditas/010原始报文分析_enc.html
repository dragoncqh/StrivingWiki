<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8c9e4bf5c4c27194a5cefcf4b8857ea4d5db5b00f06a62777cb3c06fe185b12ad9db0e4edc57735797660dc5d9173da879ec6dc71014fadc09d9fc5f2bf29acf8240eae549a990b3557afe5155d99775799a140645db51403b91f2cf9734e9f79c0b39e424304dd7e5ab40f2ef028b090055ca495dc865079eadb776e4c4bf40e9a2ec9c9f568bf59050ae253e43d1d6d8ee98044b1837d6802af7cd30cae9bfcc90ec363f0e28e496c44834650e446dbe4c37a20e99352a07054b48abdf0f588ea22e1da63b63e468999bb66b07a7a1425259b827cc0a0718f1589a5246d845560e726dc2c7ba5ce286562362bc4203cab6d739b2737b406a4e7eacbc41d95ecc31bc2364fbff481b019078431467700f7cfbb57c5503589b3fc505d25c7e7d79711bd5dd41fc7ca2895b5e1f389f7f2c8e17b39c74efccb158e841d92896a0c6d52052c63a04dc9abd8cb24528b2d8f1bb4c2b9e6ad7ccca7012dc65155324cf3e516a4ec4043f58c4e8690433dc578a9b9e4998bc6fd54a01cba089b8211663b7e012b676ff1dc16dce449e10b345016e8778e26e482be3becbc2289b5c07c9320b09119c3f53442510ae42bb3be3022be5e64aae6246e75f3946c02f97866ce12e5fb0a1f8ee8fa5abf185b0847fff4895e2755f835bfb6f43ed498354aee4de4e462d88739704708e66ae9af1f3b6a6f6959908aafb3ff63580d1cd7c687ac2b2d57546ff437c13eb051019be5a89aa5d0348303c16157d8ca16db4bffd1aae4d4ec1e2dd1ee35f9f427f7b1b6612aa0f4fdbc0029595b42bd695102aeb2f9aaedc570b175860967132c188fd6500006a27ccdf128b3439385e96fcd3a469dbd5bb000461e0bfaac760e51b0cd9df7821110d0b06917d32a9105efe3e0574e24256f60be5dc970a93eea56cef2d6c558f28092df95dea0c91c2d2f1e4310eaa585d2ceb2d885f6408c2cb300c4f065400fce6c78a92066f4be9a57b3f73d540c7dbe247ddd09d31233ed5a76506d3c89e2f340a2872bdeb197c879c7b731f116ecdb3155237c1930e81cde90ad08c007051518cc2236795b5c6434c4e057fed66f2a4345f530a6138f766ebe2595aa4faf94b99da2641064beb41ecc0de28abdc13bb3ac9c97575bdb1647d232759c639cf5197b65bbc32cc857282d3cc32a1378fc655a272f3ac035b3306354aa851aa39b5ce8140bef523443542c42b06badec4754c1258d92348d0d86ba9fdeaa7e448fa21b250cd2055f7f7edb7f42588b976ef1efd69e27f7b027022fd7f4494d793e4ffeff85ffaeb42d09841b568aba20f9c910e8bdbd34ebf12dbf46c3e847dad67aec06df93de7655d2e89d28096f2c43342b7e2c2ccd8b821984ed5a8accffc2e6d301a0bd4eb71cda1f20f55578aafb5b9422ea1d4487674a1d2ed208d9e9386d0c2b898d4e38e076de7c1f7121f63beb27eee8cd1679a8d1d9e40bfc3bf78a81245f6ca59a88e8eacecad8b46e6ce3ee5358d4b942ae6c072c75382948fea3062eac175a51c71492e415ef70377b6f8f683f83e13ca8d8c834c6e8be0ae66c20cf7d4eb6a6629dc7385ff29caa04855f3f2cc73c92fc6004dec7d93ca699d840444764894cc6e365acdbee3c65713a8cafc1d83cfff1eb1f39feed3322d7f5afab096bf2617911d7288a805b794fec89b40f38b5b5b4b7780590c7a81c1ee3596ca8a96fab6f8ab22f2e061afb218fb32c31222a40dd40bf47680ccd757ef9b9a19e8dd69e3e006b3cf19fd7fcf7929deba1011fe8cad9f7e1055a5170fb95b2619372fbf3d7f7f33e2e5a591f5e374ca79ce0ef56efda467bb6459fcf9a58484b0a62a8ba514360796d168fcc55e0f77fae9255dea087cb51f1c1f0a9b8f4b994e49742ea6df00cff9a80f1be9f96b1da5537c3bbd70303e8ae3da54168395f3848f32ea990f8e7cc492c70d1e1c7aebf01ef4fcd306bc9053370faf9c6ec1ccd486386d25530cc1c0baf8d03a9819f7ff69f6e198b0d9496e7efa98b067035ad740f1e7d12eccdc300e19424c1782e38ecdb63f939ae086c7a73968933c8408a2b4b735c47c7d321e1efc4a586a7cea9b76da32e16754a7c26c90fe8806939265743cf2353cbee2767c628c531ea248f34d97a4690ef64663f5413fe020c034420b87c57a231c27b7ac479314d159f23d268f10cc2ad6d7e476a769d444390e042732b9373bd71225c7d6f42240ef3bfc2a298fa4e266601b304200b47a8dc28733b85b482334b4698d11172c6348bf03764fc459a66cc2ab9917e8371b0de777e401090fce1204a5192517bd9d63620c29e116897bef55954d4e229bce8affbdda5afb2b43c2bd238fe2bcc6155c5faae01a4ae1d4e657f0948bc625b2ede20de7d8a024d34ccee634bf749e6e151ad25d669dc90f789037ab3b5bbb110dc0890d37fd4b83e4e0be9ad7480f1ac3155e36286cc205450e0148a0da4387263610dd752e9cb0f51be82e014620c0b370102d89dfb95f32b169203377dc29d68565e6c6c5f6f39ea89a6b49b3778e29c3882dadefe3d8074198f0d1be506a2df723d093335243fec7f9feec925da54c6f53dc0a80f4ad124da2b5e3cecd8510bf140abf048176e22a8fdc679b591b118bd40e315560f6c588626a6953d39ddebcb2836f05ea3e33e4809722f7fafe8803422a98d786fc5104b8dfeed1c51cddac7720b9d6a2c0058f3d929b87400524442eb8e1f2beec7dccd2db2269131ff8956e78e7f8e5a3ef572807df4221bcb2359990f5fc7c22263eda29b64ae2a4657f6df6d31eaa0d8a5744ec21728e345b372a63015e3f90ba0dcb53f3949bb951372d3d78b93414988dab74bfb16546fd5a81c744c2b50976f3403fc67e5f09cd5f1e9b746d463651b207c1e619f8a37d421e96b8767eaa767a7c97445cf1c45ff4bfe46c9b38c24cec99fef54bc03f459e28de32d70f55479966245dd8599fcd87e418d39199873f48d374ab416562f9e38aede309b973a2ed3e7426abc53ae4f656a388e8976ae89cd61d0b9bf2c5ef612e2408609881432e118599747c76b95e727317611080b342f63d98ed96f198cadf22339b3f18f2821cf37267730a5b8c959a21e529b1fcc4fab87964bbad1002146580f2b012f9207adcfe28407c71d0ac0e0589b4cca35d4c88eb310927588e05fac4699047eed38d53117ce4273c37cae9ae598c1d859136a544a39bd0ed53a296695738e10f66da6f0b6d68f1d18c4d9fbf4d36321b98a7151582b7cbd38d69c9b267cced68af5e3d2f58ff129f42f11e6898aaf34e962a6e45025bc6f751d92c76eed489206f6d02a03297a901d6e0346d4d8cfbdc03174310a34a68731400ce86045ca76864a82baa9211291036a3da6db583e909e3c32856c4bb11e19e1c26b030f91cc3cf69e3390495b86ee70f4fd257bae906c72ed0b99e8339827c6f753fabbdee0e3663b1d90aa7f44dc138912af6e22a03951a4a6e7198dac4512acc3d37398546951962128fb6d0152177348892965fbaec7ce24e21898e90ec2f7753efe375500e84a5aed820a97f852a93e64bf16b69c0b50e684bac2bf13203766cd6f7e818564ca29bdce47612f074a3076e10f541186a24109dddc11d35035a5ab840c28a8b41f152413354b0dee94cb6e3e361a1c889d85d9f105dedc7713270caca8189ea43180c03a62a62fee55bf02b5e5875312a194164b8f1b503d05d4a89abc13e590fd16272c39403f1804d0b9b27ce4cd74c8bd770bc709e64c2cf68de94456be691c9222f32fa3866ac3c656928fad6c2c503cb4ae1ff3698090e29e715b941b768163994a5b2a061eeeaa8e5251415d0ca98693c39cc6c819dc681204665b4455ceb65708a45a84d63d45cea84988f19add8c1cc8cd56b1e85150e6b92529017bc9586d8c7ddc25af8409eb2db31ecccbcac00c2ba7dab48b193f43c579dc8cf585baa558d7cae8c3c4c109317cc617f2698a92a47348f6c0604952792f6ca9bc0ca575662e4dae0451b6fbd86ff55c68e4440c357a229db4a8e9e38376267817c1d06b33c7452a23b687dfbfda0dfa69fb40dcb7490940888012f049c41c8710c8af45d7263237f0eab8008e7a6049cdf255a6252f3302f444098e05772bf2515481b583d76f1e08676508c81b57918225ab134fd3b7679409d6e3e73dfddd04450363d7db3b37f1c51eca0aeb82d2a41c6e8de65ba8c0b846a0e225dd3e56db4b5f2308410ec5a8f1d5986dcb36f5c75f6829eb5f572e4cd08ccd03be86ebebef7fe58b1d1b19840a0ab1d67864d3a27320471342ca9b8ab9dffc264f02c1c96e519c4c71dd1cac0fdb08373df635b5265f37ea2c034451027a32aad994bfe693ce5502c001680e112b5a4a4e11f4b037521c35119cc0abe8c25b9b7a76a95c7061144cbd6ed803033f499cf856c22f2156dda34e45643d004cf2dc1c5c6f9941092b3ee55fb6afc23a09aef09bca74cf9b7d656bb4c2a0aa4841bdba14ea9b9fae92e14bd0a3cd30eede7a6450c755ec33a852943c3bb4ece2e418e80c5d95d5a53d043c27fcf7218dd46d5c7f0f8790ef926161f3da467d0da430f1743e99f4d49c7f7479ed0a1726f12c48bef1f7e51207f3882931f217c80c09d51252d5c43ab5c1d8a78d7f6f103b6d607864f48eb876570c3ede5ff97f13c418dc28e6c93711dcca51019cc201857c416229dbd4309f1793444be909be3553a5fa700392b65e57cf57867947fe28c1ff09b010034c2b81a564e0deefd6155bea92417345a59f2702d5c4ddf5978f799081f54dc08af921c4203847c76afa3bf1e870aa73d4ab97d34d1802cae37f3c10d6f68b56ed484b17eeebf69afe34ae2958baa1bb27a9955e18183f7bc59aea271f9d5a7d461dbc016b50b657be84932d8470a06beebfc30d6c9e7ccec9f07710ee9ad0473","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
