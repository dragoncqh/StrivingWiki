<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"77fe2a7db2ca1e0b1be2506e208cb2768f03043f8e56a50c81c52296757167c849641f6552ae920e6e451fcfcb8641dfe5fe386f9f8c1007c34abd395ec2cc1fa2ee9b4e62fec90beb56d3298ea3be82a628db88bcdc38de17c028eb7a9e9bd86f2da36e9a3d75f75c9e08cda3c3b31193b8ace7910517291bb77aa184cc4119b7e18e9c8040b59c2967cc06419d7ce502d05b8187c9018c9d103d1e33c26d60830086ba6a7f3425c02b87288483401171634cc33c8f8a0c045e2b6f353e42c28d1423e9027a0f73391ec4e073477b369a99ebf7602495e4f2f62e6fc0ff3d5276cd9d468b5ed10c207f875cf66bcec939ec207246dc54868b8201f31082382565f9e01c223574b4f9215719ff7a13fe7291326058d10094a5bbcdf3c65644ffe85a69278068f9ff27c808ea6f10a2398a854938761d1aa1285a89b5fefded4852e4d0c4cef56580282e1c5863b83a08e47bd964cdab32154dbe8e8281ac6971670d94d3b9245c8b68dfadf4f56904d40b8f7bc770cb86138a4cf8c7ec83e29de3a09d94c46de8ec12928d56f10c6ec0b72db7a6623fe5288aa665351953e011d38b33cdc89f8efcf05350cba7b84d13fb248b86d0a477c58b27c5b6415147d909a1cb159ad538bc1bf81890039c15fd03a5412acaecd0828486fe0926aa01d894e3c0326746bae530abace91651248fb082fd544212e89944248cc22e294be8fac99c4fd0afd5a664c31fd5d48f5d83873e64159cb6b47c3897fd01bddd4d30304fff2ab6906190ed812bfd9adbb17d7fe55e0fa33f6abd163ecb8411fc92a237c82aacef2c5678c20f31540aad86d771a02fa8d0ab8b3c70e7ac02acfe54a2b32471c31a996d56be30bd790816a4814b694d8636b2d6f55a0b3b0fc7b62c9e5fbe003d671466e8d3ddddb1ebeb704dc7e83e5cc656eb88571843b9c742b83afe133a923fe86f93fc90154787faaa0b79caddc78aed8b90a487362c83a1ef90e23f5c59cc0b83c08d1f65603803feb81bcadfe5966dfbc872ed59944dcec905abf0af817cfb2172183f622a17971c3816aa938d4afdd60abfb196a51070459914ddd3cd3cdce40a6074b40fbcc52fae6694d53d87e0908faace39900b39f2dbf96a5ce02aec43d38b4061e326690b5f48c33fe2dc3679586c1be72cdcbe7735d65a9459f0276063d2c7c7ef3d113907a4a4095f334232ed53946bc5ca08e134ad11fb6399cf1f78e7b14833012d1676f7e88273072b1d50b3bc5f747a29ff6f50512a703beaaa04bf73007f791048e1590e2e1d15ef07a1c164b56b9604cb3b8ee5d2bf2b86d525e2ac9934398fc77531061a094dae4363eee9c42f15400b5f65cc844b943017654055fd951def938233dd7e09fc98ed3ea01cbbc6f24e1fc718af725c22dc1a206f9f86764de4928d8187edf7fa7c1885670e9adf2840a1f68dc5126cbc2a417ca54ec1c6052284eaa4d295d4b7a29039428d654ea42b8322b2d49f0d68b96a7a8ae0128bbaf4f7ca2c0bd169679b150954df1fa53c9b8f781bad9643e6baa1f7224343ceecae68e3c021f99a107aa1774bc685b611691cd3288ad00bba63d42e77129d6f44e94a91552d1b8eab06b4d2aff0df69084b7f7d260675ed9141ea6059f9332486d2769388f4fc2b05a9940ff1e266ea17e0ccd157d6036b2cf20a394ce53299abe28ffc98a11ff54bad79d0e43605033e874a9ee61dc7398ea384d63d3e88d754779a2cdc7056beab55edc665cf915aac3cc15bb16f40005c95c483c85fc53e09b90eeba5b9e96ec5f318c81b05903aead888cfacdf276b25d26c97af21e5a9127b742b34352c32fe214eea3a54df582b7e76f7de1e0eb906bd46aabd3de07175f5b506b5ae61cd54d2aba6310bd4cdc16c5e2847c8f82a77c942b23474c6ceabd713200e174b0f50de0508746229832367c9d16b83be5725b05b3bbca59d2eec7910c9efaff2dc38c948bb977bd44695d28da7171c4ed30e67bb4624d95915e7966d07eee3bbe0f5634ad27d1e6be9c4601a619e73ec603856d361d94bd4fa6e8873de3a2fa970c27f0c900bc06650da5a08791a8504d88ed89594ca96e1f96004d3bbcd62b3ee69870bbd0b64f760d586a802219fbc35aeacc9171dd67f1ceb55b99a48a80493acc59d466a058290e807a33879e667d5592a38d159f0bfed7dbf9c4b6369257eeb9d5f26d58de15d7a8d7362ff9f730b07befdb7aaf136803ac013fc6b469995a8be8ce65116b0340296fa1fa965aaa91790f10de397aab49df0f5d3a073e8703de58552872eaa859d2290ac8283b3dda8341fc7fed3ddb1bae14d9e0ca051c0406250bdad1faddebdef9a236fb645d31b9a0744be0592904bfa91785b5d64f5fc7a73d2bab5b14863c9119f4fd2ca5a88ae1f4a5b4d54052f43c295d69380e69b72279993f23ed5bfadf39fcdea3ddb12ff4ee1ce93cb12504e1d10298f65d4f6ec80456378a08ca51f65c2f800b4f5386338e6ba059816665ad0df7ce61bc37994bb158a70929f6bfa41a93975b8334cdfd0824fdb0d50c2eb4cbae3ff53421c6cdfbe08a1ad57de13e13551b1f2d5648ad994d1d1a13b80a6c7dff6d8d708a2c4b7c5a9cf407301abfb4b79a1226cf341c00f84e357ff089948b87f5251336eabc0befc4822a183bcaa6fa05b3c7f814c3883a2f17dd0325b275bfa75541ee14d587705671be5c7c432a92c54430930c645e837002954278c3a2375b0da0b3257b878b12f06c4347532d3b6c4c58725a7c02998b022f94f5d12da97c6661c201255907e7986453e57bc0c3a4d5d5d7a1be833e02fc3ab4f8eee27531e2b1a564a689b2b71828159039165df8e7997de3aec43008345fa2ac116006bb012cc960a18c60bcaf04f94e1395e1fc405fb50ab849db638a35e0da2c104b3e4e7abb42ccfce1efd49e13c4560deda37c806cc1e12dea17fe825d0a31d042bedc853ab62ad77cde33f3d492f19468032ef6645498838bb3bcb583cdf311659067135b20f26af8f120531f2bc41ab7c8d54f6f52573609d468ecc5a8f9ebebbbe25c6f60534e8c8b1a3af02c1dc3d5b921f4580f29a98f6aedb3eb1e8263c7da9c7fd13c52589dab948f32d4a6ec3f2207928641d5285c5052516364f392ac5a1b05d0e7a9c9968b11e1f3b294d60fba9240c5cd2a75939e6c350a25aef5d3819e1bd26e89b3555e02142d178d106bf035eb3c9f21e4d151ddc7cacd82da1c833cd3657e51f45712a0255ad3bd28891b2308953062acacba8982303f179e779c1d07cc3778990dbc83951dff961b1218257fc95e4aa0475fae3d277f341d60fac33da069e8ae01f01f3e604a023179c085b506e0077e29195420270af8b8ea41af440f364b5362c5476664f912c59a3f7fe42fa86aa888be6090d38fdc50c5f3a0fa2dbe1fffb22111026aa958768a72617795dedf383a38a1a29f8b5beeb761272c30bce37e51e3b2490ea588a2f1f88a0c3808ac62349f65a18698d3db1d53caa2c5e54d6298e24020c1294c5e0c737e00d2d70625a85cc886992e8806bb014ceec866363d0205cd732ca57eac61a0d9cbcc5900f2ce8e830f3e316545b5c56f1eb49778a600b247ec631c398acc5b4dad52d45a3fc9379613f97e6de8f170762b028b7efd99cdee27c7e0d7642838437220949b955b6b64f71fb9191ece7aa4041985d48a01b232d9231a1229ff9c892d65dac6882cc801e470a62e952801cdfeb6f918d752dea929f4e6e5af51355751eb026e946609cf507429f8045c89e7a5933663106b5ca1b2e20e867b4f3bbfbe386606d5cd41433a67c26f8114041cf2ec94f162bf66da62323a8c5fed048a3b3ae72e6fe75d882a434cda203344ef42f452f532520a19dfe78cff9b41ea8285dfb547088608e523c3f51992fb0f3c7a2dbad43c86741b144d7a122098d25ab46398ebf36ab4179a54d8a5eed5460c8a9be4e343ef9f44aa32787c258dab59959a69ce8d2edabc6447b1d81c5c269696c5f6f0f4ad8d738bfa0187489e542a77242c5ca9994ecd81e18042f60e262a954517a21f0b2cbf72955b63a44bc3674b69d590c0780e85d08e4e00416d2d4011ee3d21a30a47146862479a62176db9a8d83ef3d5df032298dfe9c2d3b1d0b23c048217cd46a2fbcc5a8d1d0fa1088870b36b1566d41909102aa01baf6f344fc3047bb0c6bdb4a737204347160bc6e8dd0550cf6071e083e6798c9cc81fadcb2cf068f57d3d822baec8a59bbdde7d4873967d6de6fb6bcdb90dc4bfb7c0552fcc88b28b9435c5132c1d88894dd205c10923d7e296f1bd83ec3371fad608f4b3587186119c87b7e7205eddae86f8d8dbc263686018ff5d4e0725635f7348297eb4dbc2569cab97d5bab264b16b5954be6137d805665a7242b5d7198eba5e8b80ba2e8fc00e4c47cab0f1956616be5dcb3d3bee7391b13f9df40dc34534fc0f7fc1ae105ba01e8fb4515ff1fb90bd189f75176594eb7567e12f2f528467112a2a2de9d766e8bee50d2adb05284667aebecd934c6badf50c3b4683cbc17b8ea53be9cb63fd561a88c9fef3ebac04cdad57642f3c05b7b20a215b539d7278132a9603ba6aeabca32cee875c5f4aec2bf144178a2a371248cceb22769510aa2a5a703d60fcf04246f3481755113efa175bae05c59201cc6758a1e2566aa3d9be719635087a2c36ec81b70a424b681a8ac10d0609c3cfca55fc2aeb2ef4646a48771a5539ef6d2e5b58d7d9a4c79d3d979d8c704992275610762695cca4b816eed7e340c7821de7c318e625ab6550176472591fa685d2bddce599f12a1f3d710f8bcd28ac04ac3f0f904b043d69488a3f3c4847f2b486c76d935e0107036389c396a28aaf6b66dde661661a73d491065cf54cb4ccab0c560f76fdcdaee312449c40cad101e091614fbcf8e28aabeaba872b4691c33e51ef2995aae4721642789c3e7d197f5105b1d0a775e5b9e681ee5f56e565e74f60a6d441595d0ad2dd752f040493784d0dfb90d1a621a548dae5970f18638ec88b4a3080c4fdd58ce67d317d814bf22cb9a45b640bada62260845deb145d1b916a3eb32b989e24e7a3aac04d87de5a7664ba52c130cfc63d12c403a77680fb16b8d9f98c4d5f88f4f1ca1597781558a52194a2776bee54324ec080175603433cbb925829cf3ffd586284c3817667c4415d1a98afba35ff775e6875925455dac086c1349cacee643e9f779da2f16308c7d5105c868eb1f375d469e1e8f6212d6b4a177da8adc4754a2e3be38b06316340ada05a99a44343fae9b1097dbef62850d16ee9d979b35bf0adec5842af03b44993e005ea6a9e0d54b176be5e7c08b745f23a9d7f49c86440ca09052c3d5791fed0dc3f1fc16ca1aaebcd0fe3de66942e947d9685d0f3784e29b3bfb39dce053dc25ef690b70dc9df848c7793500f35685f0e9f0aa521aeebf53b2c1873c6c83f71f1152930d9e6339ccc7f0ffc13c264c393146b0a07edcc0e3a1ed5b9293380026a438dc42314ef114144ac9a5989fe06144e2f8a98e32b28b7dd5e00d7566548518c0cc95e9f6465799a0be3685be0b3d5f8906fdd136d47ae0afca2c10793b0b62e84476d0e9e2376160bf08bd1ca0afe0767239726fc8ba505829dbd583aee81f7b17bde854dfbfe3fab0d0ca99166b5f7da97018ae97e61d7d517f545bc79b916c0b84e7624201557c5ddf41347d03ff8269367400cd58ca5af7252c8d5e587370249481436e807ec5cb24eccde10b145a2b1bcccf82f47dc0d60a203860abba21851ef5bde086cc6cbbbae5794368355cd205e5f3984afc2e4d9ed00c7f31db4fa30930e18335144c608e9285cb5e4afaa485259b0e16d00e51a6f1eccb709dc396b71178269492c51223f997a7598278cfec9ba27027eaae84b1b40ce9c68368bcaccd84164124e4d842f4191c9ea1e714f92e1e9e726d71c7469fb9ccd10bfabfff62e52579da693f7d8001ab53bd3283951e852e2c270b70f9f8286b2f1ae9851683d499d565e2b3c2973f8d9dbcab17bebff4d00427f6646b52f3c645c67b0e928ddc1ab97ecdb68dc8ae4c0ddd938441c518ee3103f1882129e23f46df3d2c48d772edf3a1e1b40de98c8d400e25def05b0dea4b01e50d9529b37cbacabc1c0b79009c12df68dfd7c92e685271455f8f0f12b949d1a3f63740d79aa4942b08944b350e95cc01005bb0e7d9778608af8422f2a1a1bbf17d32e9b373b92dd523e5b79a1d10989b00d3b264edcede839968c0ec55202ba7de2c332650eecb7708050fb00267eecd2b7f2240972eaed4099e00d656c33a0f995f32aa8ffeecf629251197c366d342c9ae5482dcfcbbfd88f3c1f483cd7f6a9166a9bbbb2e7afba2d526ff70cb06812ee2e5a27882437b14ccac530360a615ddb07704634f4d3bea65760cde81a2251388f8efaa9de608ee264a3a79b592368f13c4c1e13e125d5ba294e195ddff49d261fbbffc96d87f4874486e65ccce945ac4e0106a53dde4a3496f126d7fa041b6980a00d5e9c6c15026cce95ac6a118e8ec1429db0c75bd8842101e42734c8c43d5e57d215ec0d110c0d88410d0a65e6abffb8680650bffca42e286e3d3dd1ec8aec9ad452cdb1322e0d1bd78904d0a6b42fe9aab87cbe3cf870d21ba69ac88388a3c721b4e262a2f34c8311e86bdf9617e3503b42adcc4f2db40166ddc5dd10906835b45cd04cc8bfb9871b5a2f1a1fdddb24d5e32f464a413a4ae9f260c561f6f6667bd04064d7eeb9f7aba29d02a36ea1d648413ba4a111b9da45acdef77ce18f638f8dd5c6cffc1dca1625f312f130006afda52252a79e3fa4399aed13ba3cef7452ed5fe1114c85d830e24330fae655f18b498a037e0d2e8d339264eef659891d0e90dea181ed9bc45d862631283c05bd3c10461e08ec0e36f082f049cdbf42ac0642c6bca05879027d9cd45fcd239150882bf4981daac3d962b2d93ffb3f20346ff2fc1a8498b01f9cf9ffd701477979053b2dac430746e4a7f365a1be2586b6fe3fe5dc2887d2f804cba30063a44d8221fdaed317190b501bf0b42413b1e303c2c4ff0bdf0092eb232df8a3bb158bbe1860af717d9bd9b75eaa728d45c57a62e4de7ed28c482a50b198c99a1c5c78f4095ceec5feed0e0f8e4444facd30aa1990887b637ad037dd0554f9369f11a2fc27c1a93b7898175bf275ea3ca77066304d5b8d775027c11dca7bca7642ead25ddcaccd2a5e4dde6d0ba89d49118e2b0745e87bd54534c173c6d40e3fea6430d3f8822d57226184b101676bc0de4a0e2d6b771ecb78450bdc8a0a49b74df073205f19d2183c8d8eef0166e80f3810e1258be6d002fb4ef4193ecbb0fa083a08c05c3191eedf937ffe6b4f642a8d37a3491c228055ce2cf866ab846bf4c09ea3aaf41fcd7960cb0fa319aa79c91bcf674196cd799b741c81c5702b4c254100ec0ddd3ddfbc928a3f5f5ae2f38c512d48c2eeb12a37d1ffd4e37896c55a9198961e62a22d1f60fed078e844bb73232f9eccc0099659c35e3f1adcd85fb94c6fa5af0cb5ff4008f915486ed9ae90ea257289b6c3be338aa4eda0c9283c485330ebb5d101e77e4bd31c1be2746f3dd720ae09d981c270c6d11a8452e72d34ee2ae2071bfe0b33484610e1a56dceebc2171e80c75765ae3850ea70105337f3b58d76621e7d544ee7c782478efab184ef6e8e32593e03224b08e3f109c1c4454186813c900e6e0f5ac2905cd7ba5359c36b71ef8acf940219a4791db45472847ed3de9691a55055a54c251a8c57d3ca4e0e38983548f93ed18a972e6d0977bd58bc17ea6a5e1fade64e329581f0abfb5ecd0b3a01e8eb37e74b57fe5f9e81e510dffb3dfe5a86fbe666e9e75b55b51141f7bfe7c465b17f60b4fbda7386371916ac6158f3dadb9bebd2c0ad12e9e1722ad3f5c878326e5dff6c0c6f2205a26de1d2d4f6475c170eb9527235192f06ecb369ddaa8ff61ebe06b9668d0f2c254faa4c6b66e6f1c81873b1e84e41fd814b01c8a39f0799ad245e124e170c8bd7681022da70f858e6b2de5d14f823aa0a4951f6e89bf816cb2b6f2a5b17ac5cd34fec2effbd30c5a99c4c62c5dd5c0a47d7f66a52805a920a4ca3c7edab79e1fa4db58e2ee85772a94f01346c02b871343fbb6cc98a02bfba7e4d0d5382888b58d2127fa50ef3a7cd3483d2331a0c21bf54f817b39326befc85e93f9c47bb677b0fe7c65a4115637d5723e4d999bf2b2d26b243cdd7d177924730a0e52d926712425992ced717a0e86f6895b162987814fd03ed68afc6a4ed9fee1c70cc783be899e42553c8ab5052b576de92784cd8ddadfe3c6f6579eb41ae7add8176c58e4d6db8d69bdb1bab64aa8eab07d200db3d47f7233da071325a2cb06b803d0edf001a81af78e63b460c81487a1e1533690e3bef08ed0c83c002b32bc9c4bc3b4aa222a2523b86eeb46259e1553d742d702753ea4993f1185570a1e38acc49ea88e15d728c258a322ca9e09141af2a174091327f77fafafc0d3adbcd0ff76a6e627f0deae4f6270b3a9cdb41a2dcc57ff753ee037e9197333f116e05061ffb2f800dfbc3623fa48f4dd87542e8d3f9de2ddb0c32317df28b7eb4cc643094d13e217eccb0def3670f3390087f8cb94f60c822e4670b52fc2b7089b80ff7c2ebfc109a672e7568418e5f27c8cc45ce667b37f340f3b267067fbaea30023b5b673863303f4cca7bde92e270664fb7bed12aca5c82ed0ceb844dacdfc2e68feded564beceeb2b501dc9239825762de35a9644bd762c844f3aae36c698071eaafd07e5b2f165b1d6f01b054646fc0bb4401b0de1f31c5414b152c81c8551c9e97e4528c7934c2de1b9f00e0ef817f6ebe1c2da7e5e5fc61639e1c041dea3096daa43beb89a743d3cccd61f699f9cd9177b98de43d6ca54653d09db2c4f48f9f1b1fe99704e6764055abdf04d289183a173d38dc5d5ed06340eb5db9a21b14c3de4210a571f1527f1b57626bd79674d5bcc1b58ebefc6d3eae0ecd123b3c12d4923ef9e952e0b6f9f9ec2125522c4591b338d981d9d330317f9289edda904f911b8e0dddb4192940a993d532ebdca30b46fce5ad6af56822f2a3cdc41bfdb046e09a2c57857b8caf7da5f64d67a4d6af453e15344de152589235338ed9d14bbf9ce3e7330dc20faf2ea3d3b143ad08e70fce9e5895edfe31da807f82aa283d9252f09708ae6e0c54edb2ed62cfa512d4e3709a99bcc7427a5e223283763f29ec996299203618c2304efb098752819369e283072b23064486b03479d2748cef098488bacb2801a7b720d9d4d798de82cc1b319565544f73cecb8743d576c6ef5dd7738d5ac7e8d577565588b0233b4d379c80f0c5067affe382039f62df461e6dc90416cf643bd929e098488c57401e478745cb6c5fa504dbcde65ddf95d60e0929b1ef93436a4c3945627d2ea60879a71d2edd0ed39d5b5b75848aaaadad33ff45341d7dc580936c3cba398c7b772ca1d0fa258872b50bd10b94bf9504b91e698e781dc42dcf510f4c55b685e0f6752b065312c52626c205f20c28082947efc33d815aa80fa2d88aaa69443b98c60b6c33f671f3b7f963350810ea37ae346f7cae6c58cbb09a2c08cb6831e09b7e3e36889e90aca739af6ca119d4f70fcef56adc771dfdd2c4a8262d02bc4f4152dc551c6b6dad35e512faebe525352428ba2c3f62779b391a08821704c88d8bbb7fc3997c5b5d85d730e7cb23c6c17368e9e109d7b4be750a5ac5a960efb14bd16f6ca1354c69e1a8c2bab60f1a2a204bc4c0f2d939396cc32bf02c1ea7daeaa8f10fcadd2ed4cee5652e9bab56a15e1028a2d329a05e15d4ab9981af2747b0f0ecc3dfd9930db49becd5b3a8981cb8a2002106e78b660fe4d3d648dd851f453dd3604bddf145245d6d18d8e8d3e481ce67d0aa3b055b66252852a682572aecc5441c98e7d556dd561b96a75ba7579295e2cc69bf64af453bc4933972ca4740d9f0be6778db975b23942c29b5c310a8f7f6b086c5e77bd00309a9ab42c60a8a5fca69f16cf18f2f64f9e0494780de03560e1629ac8fd084f057c440769f37dea02ce211a37a89cc66a1288b5d32c3b666f353f91d3afd57941585a21524ec2577331380828254f681fcfd45383038bba882b063fca8507676b0571069565cf8bbbde9a5a339176d349b106b4a95321beae12674c72530f76d0b82c0ef9fa38c7b07a9857949e1a6463f1c36e04b5241d3bfff0019aec2caaafc07265b331f0f1a0e5cabd9ff1deec941913500a4acba5a8faa69b1c5662b573301f9d408801e5f38b07c04f46fcb2bbfa9df72ad3fdf52708c1c258d96468b0945483136844dfb8937314484835f4e542661edab0b8a1f9a0be6d93802cfc9e9f036a4d44398d52a897e80cf17a9d30dd657bacae4f98542958a7ec4287630c1978121d303846355ff783e2e2237a5a1861c565a32d40ff5bc73b8fa5ea38ed423c86a1635e295364d3c06468435d308ff14f6ed32761771912497198ed21fe5fe4cf6f1901ab10e49c67c491210289c0eb30b15dea389ebc045394c441ae7c6d465ac30753c2389880851b2e4af6a6c288900df352154d82390ee4694fc06158ef353ec9a6647625fdadae47f35933c99cb22150ad17179fd468910cc3c47b65d1aa44d06ae0f77c6de795f137f6691b7ac764a2f9a3d565ad82cee22a9432f7cb06916895556b59e04fe4560ebadda36972d2585d0afc654d479ea20c40e9780f741077ae752a05eec645c51f3307fe7cec9d820e518febc9b3dcd70917bea9ec8650458d868005b0a2a099aa6857f4d8c5f27322e44339e21989a3958ba8bdb1d1beac57b3a6ad0eaa33ba63c3414743a52f8f3ae9734436ac92ac3ffcb73d247d833f765571dde08f7fb0a68f35bfd330d7164caa858abe21046dd2fe79a9c6c28acd31eec4b89a7ff3fcee4e0b106d08b17748afffbb255c9b83d402568f3d1928acd71895e3913f98ca65faa408f3f5c37ed48a2204a119731f6a0e0aaa5682b75cda65b36d40b864c22b7f354165c679ee4c30a158e99e184aee4033f9e468a5e580e90d262b346acf774cd359da5bae3818eab49b3efb2b755e81491593fdba3588b94c3c9f2b096b41fd56d49e356c33086b43031dce163ce124925e317dbe6c050bfc28dc95545deb96413230e5a65e65db20a5d79527a851156655c84ce74a15ebef98141204be6fad2a8c317398148952e7954da891a51355be07575f00a2747a3ad8118e87a236b665fee3df3d5fca60f7321911b9633fdb4e09ca8ad23d99bafafe1f6842e9cebcc6fdbcc360d3056d78272686af4cd7542cc417cd41abc22beb77b42faa5042b09fc2c9073144cff4a403cc1549dd6474a4b1538d2e78eeccbae0ab2e00920f40b953f477aba65860849689e55b083073b8e183eeda45b4147c7dc303fb1616b4e62becb3ad0c9182b8accc3f8098afc89e285f01fb4f112b19576730e071596b8221f4307e25df035dad18de28c47350b8b5045fbee863345e54db560b57c1149bdb3556ec1aecf2f2ad30dde817106749a9618e35df61452eb4180fcfc570db84cf55cdd62ac9aa96d681a0a719c8483d4a4664053a561f2f97e457cb345ffe1078b7afe77f327f3d0e7d5fb09e20670586a1546fb170d827f972f758daf74a69cb5f328131582212b03210e323364a09eed3a1e5cba8ddfebe4a0bec44282f0831a4a7c7db0e73660df35ffbe08926c6c0c2759beff85c6054d3ab43208bfa6bc9a64c4d4c4ff476c4a5b33e923f623d5d464cbdd7daf7598fc7595835ccdc19864f0bffcc264d99ba41d03b7a39662b0532e12e8caffc26401004bb0023af9d1c82525ded6e879372c32f934b032b7ce24e124338e30d5b4221fbaa98c56a473531f0cd57b385295f9771cb12463397274229c5884bb1e71d39276289149b9f761258230668c5a08f509ad7ed4e2d0e68bedcd9969ea4a2bb60799427518e2a1b518ff6e89e07a12fe31c065b2abf20e4e74bf31eb4e0403e73ebaa6fbeaa2e7802664021b50c56d4dc7e512f0155d88580a48e3429311b39ab268c83e6295fb2e67cfef13a30534ad6632ff22dec410ecd0645334340f0b25e2b89ae0f91efaeca3bccd491ee27be064a41a00a69f7c2a043420e9bc72a18576d11d9984143477173971e7a60193bfcc508f74ad842f459309afd799a0f45911c7f6c5806838cdd7fa3f0b9f72df9c454563a1773337528c545f08e4b3d72f427f953f2501948c46281ce2301b0c2f7dc505ba082d51f96b23a8497c7c39ed685f2ce5f5c1e268ea48e1fc3363d3bb4ba2bac21378dd2fd0e727ac17151f907c76b9410d49ddd8ec8d9be05c67b4f853b3b5dd155daf1ce5264d7873ecfb33bfe4adeb63eb61024599a91ce6e1274e11ccd92d42d8e529e8c6154272b2d9c6b0e7937c4795d7726419414b8e223085bae0769a17ba6a0ff662b11a4d4bc5cbf610cfe4580857c9d009019c6abc84d6c677be56e273269079831d400a6448c7d89d5268881617286010974d4571d08f3eb77cf103deaef45fb3e9b7ebce7b06fb0a6ec407ae3b4e74b97f1d177149ea7c5c29f48c8a6a479e8de068c493028f17e76660a3ee640ce8e27de4c80b9ceb18365878b707fa21f2d6077c28aa71bf1e04237c8fa283eb518d1e3ff20a776267fcd9339c032d2f6dc11c73ce777232ddc7fdb4f9399f11d4da4820952f76d335fa669650f7647edf418cf35d509107ee6b493ce835cc4e7f08597b34bd89825d39bfa226332ed776603d749364ab6c7c2187b0ba2b16caf1b72cbc5f8a857114a1b99aa18f256b4e3881d822b6c5d4af789d4be40767334c97da008c2ae7c48ab8f0301f1fd07ca971647551ceca03f005aa27687a12f0717619def028d6ac2f00cd20883fb1adb4bb82746a12d0d9f8ebfff30da0d6a748d0302f19f7d4d98e55c9f7b792938348edcf6726ea6ffdef764c17f09fd2573d7ae86fce4c2aca8343f657be13c33c49fd9b2d9aa40ad012746d8833102a15ae35302647bb1083aa9438aaadc6821ec0985c7e7f6172bd03b08f639c47bbf0c77742bf3fc572fe03196f5f0698d165e30e0e548105ba3e5eb1ae68d94a7f9f25f3295d27bb597433efc5f53e09c2679159144149dd5c2ffe0310ee56fe4c4bd7bcb24265153f2411dc22b77aad078a55982c529afc70cba3e506e1a2e4f96347a2b6f081062a520c3195514023bcba82bf5bc78ed2ac9c077f0a82065f6aede57c8fe90e2808edbde072d5036508a86d658f84c77fa8185db360e7cfa733850358bf508735d85e206f0e2d2f13a02e7a6f2cbfc8042452223342be93adfa7e00bda588b3dab748b202750a44c2f61d6f6d42969eeee14998c6cef7fba25dee87f12be8270b41ad9db3a73d1b1067dfecc2bf8ce49ee92d96235004b5b7cc511bb8bd93ad51521030355bb5e3cb0d5c264e433a103956c83566387ec5dcf0e625dc28d502d1d6309cb3ed7db820f81aeac721f0383aa3bf806e9fb8c92c2944a851a0c99c0172913284c623a2c2e10bb097a71f0c4cad72c2bb21ca4dfe8c9361fd7d57676113c02ef0b5aa5c30b71431f377b9028be492580fffdabf6800cd3eccfd33bbe9b69b98c4d55066b6e6eefc251d35875dcad65048113fb654773886f92482bd5bed5a09b1a110babd5f300d47b8987275bdb91f199bc137be098770a629f23937405edc543455e0ec56a00c177a564132058301055f020d16e26dcefbee05bbfb047ee268e75746e8fb744d4a13b8dbb06f01f482309314f5bd9ddea52d260a75814c58e0ea47f957bd6413663e0b823dae90a17968f04e9f7fdb06324ebabb10fc053a03b10a189161b1b2f1bb96eb40434fe079db69660c2481b4b4a57c0d349d4bf004a92329db0029e7069d2b135d93dde252924188688722e18dda95b6b26321000da8e4997430745586ca6a2dd78d5d76b1bdce61cc42bb1d2cb49908aa609bdcd055b1eba218072e7a5b05513a68a020bf708a5629ca48c173162a9499d464fc31732a5d2dadfb4f9d0ffb15ad2dc6d7bff2d274643ac4b99980910604c312ea48c083f8de5332daab24886be3824afe4e096452bc63f6ca3fc6aef9225354806b0acf1d9afd10f60a8a4899fbd073c93429fa523184c3cbdcf5fe7ff8d361b10d3cd6adbc66a5c22729ce13d92b24aec0254b203c1a1af8dc486bc358593adadd13df81b0f11c2a6672a1cc29ace1fcaa3530831329b6f3e7e0895a3e9ac108f657b7376de5b21abe8fc855fcde0e7d71a10cfae724aee2db055e765c70432f6a27b128ffed47c729822704d7483625b607e35060c071889923b4167f6b6aa33bed49f96ca1f364a7e621b30529091e0eb2679a6de9ae9b1fba6e3951ba1c0c739bf6bf6d5effa3dbcb30fdebe0e8bce6444b2106abad7acd787e36dbeaf324faeb479c40bbcbc0b48093107f3aa499e33cce62062227b1bb74402420741d5f32b6ce1d66e3abd065040239ba95068affae6356aac57fbb753395e96142d3cd2e775d57fcec8b82d23218a90d5cd486e9a6c811458d528b384242a04c52ac2178c1f3d54dddef9313d30e319b2b1a089a2246d72c71f2979fde56dc99fcdb20b1e9543d3aa12e30c8d369a3d2437ceb75f7336a7f53d1eba0368ad0c70d16ed3387c90a9a511470ab71dcee3b1e153d9c5aef92e9046ce3b631fb62743e8feed1d3caf9c0cca13a67202082c56c84514046855647f9a36b339bd88e95daeea62509918f9a6f3b7b6fc9b9072fd79bcc159db9d58ecd6f9bf1733ac68a2af090fa7c6f5e37160c11b4b6323a38b5ac63192d0c86f62e6164988e9072df952ccbee00996b6fe3724388faa806aef4a0518276fc700467a4a1867983e0fae5fa1e8bf0b71a689ec3ff99c681b3820495412d20cd62ed7da2308fb5e2cfc5cea81acfd400a76ae458e3f5bc01ca9c201f2d07b6fb1721f75b3f83e5e722d9c766650cf41b6f7b276f4df39f3af192785f4d8554cec9033a38cf75dd36c0f8f0a5f1e57963d85e3096da997fd9a18a2ed3b4651e47022c10a406ead36210135be84cd292ba0f84ba45b809780ab256a5e431983bb1ab017a42325be045ce1b1fb7f9ca31e2f58358f823d1cee0e5894e26f06354208ff47d8b99071952d122cc75906b018ae6ba9f44c685955d0314d370fb468a1c891094836a44ce9ea018adfab099cb46a2626080510cebf4d07c79c71925be3fc06a9ac51d276f925f16d50a3c1295e7ac12119e11f22e85a2595724a3f19bbfbb941055742d85ec6fa99b78bbe1c7e2dedb50967aefeae8dba3bc52707a710776c573968c17a21964d9bf33ab449f804df5d298e650eb019a5d710070848e9a821c822ea43c1f2d182ea737e80470fae3d9a49a65be5ee5b761df7a4874562182b240d410b3995c1f5e41df8e0e541563cc2709b7857bc17d8644f1313294bf0818e9209dc03384fc18529b5894ca5a441088be16e9647905f61f43c224bc914149842faeb3a82dcdb8c4ca09f7a4bd7cf9c853c4b207a8e0c42964d0a904e5d23e6d21003de753688d02043e557301e548afff67e0c00b81d5bfe0955fa38a79b4986896dae4b3845955ea037f26c8ca5dcef95a7a0d34ae7af6ef674edf6f451696c9fd932d61f8395f7c40595a57154c80bc4cb26d58698e10577f2c476a1a93948fb069efc383f85c1bd83a58a6b60d509ec9aad41887aa3de7457e5129483c7aa2fc19d5ac098985ecca33322700b530ccc0d01ed655032903ddd279cf19db59dc7d2da80f9919e2fcb890770884104529e72dff2fcdcd9ee4acfe3b32c6d71c8200fbb1bc7a5f6006941488f8e3c2d7f7bb43c57081318675d8503e77c17b600d0eac82f70450a57bfeb1d032f61a66a066a34108a2ffda0365bb8cb17c6b0bc9395ebd28747c22fa112d16967ad89c4f16f39eeae3964f693f059b28147f562cd70aacf83440ba7b26a765ff7b54991e48263bf0aaa617aab5a7fbd933ee64abc511b52915b2fe983457954541b61b248342afbd14d297cf31adaa2cc9bce4a9b968d458446ea3a321862ab1716937099526f78f36a83841193624491c71c57950c833aa8456e20710bc977e11f77e33021f0542fb25988754d4d477c3ddcacda9605fc67e5f9cd04ea99d87d4427fbabab293d4ff7e401c14dbabb72363e9ae3fb824d7a1f05ef921bdbbade8dbbaadc19d3f49767200522fd51ae266bc6861218bef85a8192e6560c5a5c0c0275dcbf9aeb6c8bab705685e3dca77cf8809fa35e0bff7c786f8d4a01136285d01b9abd53dd604087c41b115ac632764ba1d92ed106f15ecd7de5d1583a84d681bbc0f5df5ba7a9fc63367c3807342190235cb489de365fc55541c632e791f48c70554d6011c49af9997e1beb100283ddadc14fb30d85a6cdad251ddbb71c440c5db352a704801ac8f54d201b5489c720c242d6a990222a50dac480dabbb1a018f4d29ca2061e2a4647a44f366efceb73147f08f4ff0960843da23b8cc4672e31182b0d703d9b7fbfaf7216623449a27d5732e228737289e482b0e72c22e778e0a85f36992842387eabdc39fdab348afbf66a2534d6242e50997c96d53c28a8a603bcceb4c509909457d2a40b5986cdacf51334c05f172f86764e077948bc2805026e4128e6db66cf03dc8a1a8c35d9c3b0c2175a696d93b2aa4df8bdef503f572f18c2b27b37539aad7814d2b29ddada8d56fa2b7e4c48672c4d7af34746ebeb77df0b8a78fde224f2b826ac498a71424d8e9189aae3cc20038c5dae6d578223d2907e4c75a08e516c9593e63424ae93c31f20fa8be929bc8d04a19714d52296661db078219549173e9fd9c9a76cec046e889b86d7a06ea18eae22e64af44262ea2954ccac92ec9c4007f43163b14d9943aa80820e03b23d265e12c4b60b5b653af104bc9d460f8566b433a7758ade7c3b461ce08e322d770dde4474fdfde027f9296cd18a4698df744be41f94866f017b579e6a794530d7231a9158c8198abc675195a1528b11d4e8fa4633983bfe089dffa4be6ec4bd213d665457783fcc41ee29046a5ec2f6596486bdc5e37c6e068e56c52041ce05c6576bb341b9902b80a4e28c22015db04bfbc19c6a9e0ea15521bf130935b8a08bb91a804efec0653ae7cb637f7c723f3274f1909c74ba057c73ac78f616c7afc3c651a8a2057fd9d27795e55f86ad9a2c48f289d0ac5e5bfda84fa2306d45dd2d3acfd9d6dace5f8d560893d25161469a2cd3ec364906903afd221949840c15705ba1a317e560efa35eea89440f512ca1cceee86a5c6fcb1f1c2cee57fce654bd43cccbe36527040a9b2c02a08d7dac6afa0bed5e7fc77d70d0934f7a8347fccf2fcc39c363238d586bd82278850fc0cb10087f749ef4d3d9001db574df516453026df403dfde7986bd0dd1871271fbdf2432ec76204f6acfe464b9c8ca090c3104cd40457e3fceee67deb8a7477b42d947afbe97a567b808f7a4ac907f4003e1e7d30c7ff7beb023e21dae39426587154bc06f6db79ca8f42d6a749c3f8f8fe42acdf76f9e93f3bb42a6b3dbdbefc54b0c939200368ae14def2398b75281c744ff9f604ec4390dfee5a962566b1bc7bb0f8aa2fc9df9f9d42da127fad6b46169c60803181b6575a09c016b137871ed256ed49441a5e9e9e41763b3dec9b97972b32b54ca5034a4f18dfbaf8122b27d093a76afabda10d5f00ae10f8beede6f5580ba709ebf6b3f1d9ac7525bf6261fbd22ba9ff844b915bf1aae2e94387375ffad265cec4696e7c3fcaab83dcb32d9f00bfe44a29798a0e6b2b7f377ac38de56b1fe611d863373f4fd0480cae80025b3a2ade1399c720c2021014912637bb14cb71c1dfa54a9aa94d617c89a2c134a77619faa61dc0a39f961db7f1190604717074fbddca906555fc6c232af3d9861d51522b07d8f3861b6fb51a04bf9a81e5dd24211f6e193389bf6a3f05d4e471802e18461588c42341933c98e01a2b0c724f0fd8c0990bbc5bb24d40cc5e48a4479dfa0ac18064b3ef9b3541b2b919d25000d2c340340e35f02e84b1c46931ed9b5c35390497a50b724150decc2387acf771e2307d2aca12a35bb9250d48983f54205ba5fd818b1da57b1e681611dc1e807a93c483b41d5604f3c34752b758b36cc6366270f2773f15797aab3d34fee1127e5cf09259d7abe19240045e185d480adf7401f5174f0e9ca8cb9934bba84cf0fba4090a17364786e40b1abad03b91979df43ace77354300dda87e9d32cd6b7f10443173a1ce179ff88d72432b454239e386663c5b44972b29be6a454e56882cb1a7016a826282b7cf862d04feaff49dddd0a16301eba28877d59fcccd25f70d398bacffd0278a87729012f44aff4b795ee722b9f3e369b8666ef4f390eb3cbd6f83db22021ce2bdab55243014bfa3b8e000a8abb9d073c4d1b781eeee3a5fbd509328ab6a4dfbe1b90442c7005da674f3b0077bbae07a564e0fdbce5f309b513c15786d077efe66fdbad17a31f79e1d103ee789d04f22b4387731da907585169043df88ce4ac35453a3f40f7b5421f6ea367d5f588b82f0d1527b87d715915fb06b8de9e3dea34c00202d0b9557891033c141c3be5d242b216f53bdd692668354d0fb08dbd26afa886010fa9e65857ca81ecc3b119475bffcb61ee4d4528c35e6786e52c3d52c551b85ec6248e590cf4de3e1d0ff1bfd379d8c64c3a4b98dcad13aed64939cfd74b95bd7d22bf234028ba028555733eaa25a42b7ae109ca3daeace6d2f15a3a53954d2c824b2fbb9ab66bccf4137912abe3a8d737f96b2ad39d5b53f262e2a01eb664cb1680c802074994132ca816b8dbacd397a5141a064ec4991d09ae628fee23a5bfca8adab65effcfff4d6969526409e62fb14a33e007f41386f09a229a942aa175597c5adac4ab06dcc5a4bb7a7326cfbc075b833f9a5a076b9124db10f88e8d32325f723daaad6197b89122ba85ec2aacbf14161babe18973a3030bebd619a09bec7d56fc605b7fe06a0239d3a57532d751e9b75521030b658da9f23abeccd9add78c11b54f2937a1c9d888c75f26b84a73dc5b377567154647d3a660451f23eb7329ef1ec17edf78b12c4e52e6f76331e739955fe150f0fd39f2e7ab03c33f2bef6f31b953275258c3ef3d7953a0ed23a73bd5c72a66614119c67a93b62e0b42bf3cc851e12f691163d348577641505157392814c96b8b965d646d24ed1b8c7bae7683a1d0b8676e8235ca76fb984f94b19cc2dfda8716eba8e061de8216661add1c0c8a33384a4907a798c3e71a38fe763e96c8a1c18c80247b18415ac5a9aa4cf80230a851c6405b45460e61884a394d450626043b503e5b69ade8cd504043d9e1d430901f1370bc59e99b9cfdde1522c86934d10d6b3d197ec153675d8ff7929e1de05e83530397c3b92d6ddf347a8f429f2836edd2455662f17edd4d6cb6b2b10106ec56ec6346fbda046211dbb81779a22d00be3e211e69c400758d8265ce0b5225d43259d2a243d7fcf4ac1c453b1146d1d77b5f2d7ed7889304b00da0e2808dbee1395261d40da1e76fbac2bef3fe4c707ae08f174fcf1bc0ff29f6f77d1069088ebd3caadc7e1ac9959bd79553ec8af3a876e356766452307306eecbbd9e8cd81b14da129ef9bef27b81e340a4382552890bc1b1e4ae295840f6e0f838d3feed6baffa3a24558afd35273dbfd5b6309a6bf0363465a04a342c5db0dff402cd52801c52c0e44f81ce4e6adeee427672ac17ae25c685fded3b00caf626e88c155a7a96b9764118f72752a1c69cbc14ee7c58343b62f9bdd67a5dea3a3a64eb5f1a893f36f3fd5c5e93e0f5ce04d93099b04f0643973d1c6359b8603863bcdc7f58d05683c6c0940845cf19f7fe08324bd36dac8cf20ab4c242966678f11950f28c972f9d7e406920743d8c64c31baa9788ef90b8b0fba071c531cf6c2a331a51705abe77ebc6e8a6d594af9c9e69a294d53d19e45edb40323b98500c28b40f41e831781d97f148d5816caae7cbef9c7922de3e4c746720b64330ad9470c1e9593637e5bcb189cd19fabec5e9aa89a1a30a0790645db1b2bf74d60b37818ef32d73ec35665e8c0e9d53b1df2577bda6dc2c5967f1e8ac1f06b03de8c6c4d979e22bef2c51c8d58459fcd2b524c3f7ee55364c74d41d31bae1481fca87df2369b3ce0bc7f876e3d278685fae20ed885153e439418da8014c383eb690c074768aa08e99d29e6846354dea496a55fdea57875b99e8b54ff0fc1037c97c6a2d0f8ad18e68c4b58ce6874023b10e51f2299688ab15b045edb5ce2e9451cdbc7f6ae1ae298ed36349b561b236a813372062ba8b0fb0373b20103f1b4fe3c39f95b6946a0850380fa26d89d8e4bd7033c1f3fa2820dd238bba62e5e98df7994893953f44417056511a78269e2ae4682aad7ce6d65010f7595f47334fe15a6009fef2b3a972a8d2a53ff088c5c6dedb050997473f6a3bc35b35becea22689f151b76a11caa109208bdd624bc8964a9195a875052f70dbc332372c5708703653b13671efe511e38871360b991cf727ac4641ff8b9791d6280fd51b9b92f470b47dc65c1d6159a352f241325284ddec492c0432f93ee0112d41f9d87d758d42cdc65eeea7ef6ef403e41c88df0a6041379de7d54f5618a84f57e654d595b8f6cc32ba806012904630a5ab2f472373c56d9df1c25f54f312f75cb2ee975d36a67d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
