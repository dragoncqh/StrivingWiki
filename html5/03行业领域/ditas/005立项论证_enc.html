<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cb675949d7f994e62ef5cb7ad6f6175334927f3ccc0a71eb68f51970206364e3557f41f0232eb49f2ffec34ad3a9ca969de3bdd25158ff4631cedcb45ef953fd4ae895dabf04e4a764efd47260c8937d572d6281e854f3680e978ca6c601561923fd66cd568d08bcb82838728714cedfee9411048ab86f82d710b303c1e38b8aaf00a592497e29dab56f8c702dce3aa3cb06f7a5449d61de0347100d85381d1e558e9113448514640e2120e9a073aff850a0d6e291d8b7e513e1a1a31ab3f27c7d84ada03aa21a96adcb68c01e13259a41f5cfc37f05de6b9882fb5383469faa235ede2154c4f54dae289d2450c35fb3ef6acbc020f5cdfb3f3d6ef4432ab5d49943d7bb68a6db6893cc23b01abf3d9b3f4de6550378b1cb6520e483bd04888a88e2a5164b997251bc0e0112fb520d2faf6e910bd754c1ebafc1d58cd4c48fa21cb63d2efe7b8e03c7beec1edac9712b9d8bcd5b0d4c2788f2331c1c65e5fb77d56c77056a0aef59b7dae4726605e6e2785712ce6f7a946f608a03a265f618a23c2c6d8e6d2c1e54caa1b49b5253e7e8c585cdcdb705ba8e530d5e0d26f6988c535d6afeb0208f1ce32d8880056fdf4473f7ad06d40d54d4d1693b64c58d884276dbfda3a8e742df953001162d410a1678fb769de385f7294c0ab1c5ff86b65db3447862cd7bc9f31673959f8fd24fd0c274a82fb9598be93c8c8a89e6befb1c282adb64793f9d8b62a17b6ae2a1e2251c28c6fef530628993ae7023b0aceed512e2527e425bc975ef6013c5ae23e78a744062e651319ac30da109984c9eb05ce11a67fd50861feb7cea86af4a6e2022178682c5b8ed6be8ab1936979833240e7eeddf2ad9d5045d7d040e87fe5c63cb6c85efb939113427aee274bfd6f3adca8351ed4d62a6fd649241b8856644a03fa4ffde829b9a553d6c4d228db634dab9617c3d272e47820a1f15d92693ae68aab3e42f19fc4e37fca27e3c80354943529128c2ee88f6c0777e82f446f583bf09785489e18a3f0d601470646e28261881d59ac38a5ee931758aea0ac927123f4199710d14946f898ee3b1c0c2632ee5bd263756f91d879f1b0b878cf9a72db0f95031f3f80398678a1ffad949de7822564b63a0cdbcbe114624c899328ec1d1f917692b4746fb93dbc8d0aa262f5e98c29371dd0baf9c9ee11c3c9f79cef15196c0d170e272931506aa547af4286df8574fbf710eb4d8a7fde405fa853211ed7c2a2bf0b25e4dfcbbad25d3a31287934419687e7783e935d0d7155deedced375be49026dcce7811e24134c41a24d2772dc4531b348ac8a7613ffa5828dab8e27ec9773bfbccc287cb31deafb8ba1ca48d3de84527a2474c8717bf8562d6f8e7ec34fba9a8cb2654c65115d606b5ae9bc8df659cbc617d59d7b199e66240635650b95fecf7fbd98042a598b75f371daebc5ff91e1db89d412056ea1a039469072960592f124012b4a061dffd8d5758f0f8b4dfb57eaa0da8f71fe6af17c993f80902c6612b91773d50bfee8d7ab14bc487978438ae472c7c4ef20e68a1c937ad109016d0b5b7996193599ea77cefc18615d3b32c9e7317a161bdfc4a5972b9710060bbfdb887f72189e8bdecefceb62b188642b7953169fb7cf702949c6dbe58dce3afb8b123ec256133f70f18e98ca0cbcb628b15babb7151ca2fc2a6580c916a9afbc2a3bafce6f270382888d4b5d6a997a55312810cfc152c6b28ac3b2593e133640576adbf60d3bfd12a807238960e17e25ce51d6e38a7a08bd7cb551d208a5de53c7b27fdf7a44f69063c5e7e2e96085a0326df5b5d19fa7f88c547c83664958bb8092a437a42d6cb5cd3bffe0f52fc358b363490d4624589a9d53bbe14b0019bcfff6fc53a15cb44b522fd57787f691292578f01db4b01942ead0ef1c3c6378c304375ba5782236aebca11624aa0f92018a0ae175180e5ab037c85899fa5b2f5d996abf3e968907533d6b3f31f47fbaf89ff5e7ca07065a6fd168735cd9464d444f0266b310035a64dd296cb739c09c2e39eea9066afdf16f1b3c5369a399e8da12fc1ec123f44df39c2c06199025ad0a8de207af84c860a1740a5d1c62ae98595ae1984a48196e6b9fbd5ebfd11b02aa12e7941a374260d588a995092a459a3513e7a0cca6a11bcda1a197ed8687ce133a283e2135d2846138e3331bcaa1537335ba144d1d838732528ba1522c90d602181347fbdf95d618fff32f6933225c0e2b8d886fa19ee94abf71d64a117249e0ae14da71a1338230c042246ec5d3f3045560c46ade0ccc6cfa9d21f0f22191a41006684c8974f0a9cda0fa83ce78090f3f47bdd6ec3bf921d7ce9782b85533f07f781199af7bd8c501fbff84729ac037d06984629fc70f2fef988ddc7af2be95a8fc5c12a5f045ab10a5f54d2129624f59d708c23e085134734a2ebf2afc3df8e4d26fda9ff866ea9e54ab1b7df95e294bbdbaff2b12b5e908996e370b83c1785b168d318b21858d10b0aff637cecdb28a3524080832410bba9cbd4a4e01585d9cff19cc44b63ae7a7278baeb7564190852c8907ea066eb64d93f8d6b87f88893ab3458ff33424f81a8b4cdf72c23ec7b9a9d23a8e9a3f6d38ef9d3da029569cce809761c1f6570d44d68efe72b9b6bbc551af3f01c01c377229cdb542a18501c694edbb704bbde394691d997a09857ce083e36cd95e2215921d3e24cd104b2e22887b5e274f6da9520ab6d2685a2e2d3a4a332722f28c472e64be15deca772dd21dc0b1fc25ff326042729141f9013f71da00a4f60e491c5168d41e522a0b4d88618b11021a32dc9f78261feb977204d438a9e734e79f1304f8b73d31aecad3adcc5e0317448f8cba64cfe9620cbcf8fe0b500d6967ae6ec822cbc0b94429dc87a23f8980b1d10b4600dd52271d948ef7ae7b1f832a1705fe4a103f3fcb3ea39fb1f9358b152150823f58460d2b359699c82a17b091b35922dc790c231979fbb9f68dc3e5864c53d7e2cdb174d5d8412baacafc4b70846fcb47707bb6580b6e267cfa575791c27d79f62d44b7ff7f0015de9d99ff3cdb255ca94ed48c6b2d030a1401a2b205b6c92490054d9ebe7f3d8307ce498fc6cba664bbb19d2cad664ea73d59e2a014163107aef6368274d684993bb72fb4d436b46e9892342a0c7f8cce27e874e736b2e00feee5648cde13732de31d343977f2fa8594bd58435c51e0836d07a9e5707cd1fc7f313c7315862d59b8cb869c89ab20cdd499d769e6db4a90ee1addde1ad3510a8c6f321efa3df91cff53188bc343a5ff0fa26a1b17dfc7fced7062419c28fee193c4cfea38ef0583d1f1aa070a345a0e14b0bdcc103188975760c42b70c913331ec22073246159db2a3b63c432dae71703624be5274576c6cbeb1b544c2bcc583105fd1b7b9b4bba2c9449638096578622b6d67aee3a64906f03c5ea7b565b3eec14b4d819f753a62681808217ecf96c9ce67982cf33a7a6790106277cddc4efa03a0bf0466e820b3e5ca3c95bbdcaca5157f017c3e6aabc9b8e7719f9f8120cbaff5af9bc89ca54dc83b162f9b3b61c6a99b2fee771b9deef40135f0393abcdb0953ac451337983da684286bb5d9d6f24fc69d65e6d6afc7cbb3885f91ea83d1d7813555e2cd1407efc0fda62a7b6b086027a92ae3500bfc2cd7195660b267179340d5f87a7c9dba29b9178f145c87f9190ed06caa28251a0c8a32f7b8840707cd702da32ba4888b863cdec15a8b0037845bc02153022289673629a531a8b67dc3213e562a1bb8e4946d73652f5fed25350252e14c7dada706b7639722341028d24da6d7813409307bcbe7e4d52e8203887b58324c9e734509cf5396346e12e1eca19c644c306aa3d267573a9ba61f4eb85c1078164b6bed6715e2536b391c9c6a7a71c76f6636efe3e68835c2c7c5be185b05b40cc980b177a295ab600e84649225d5097dfcbcdda152109e041bda9eebc1c2b56c8f4b3198a340fbc146714c55284849f9dcdea22d5892578bcf6daa35d662e836f536b6c4523022bbf34295630cb2ecf52b5a8585c236f3a11fc6c6fcc521d7d8c51b8b879a5a5c7ea93deda0309f12a55fc80a0fd0606c9bfd4e257c71d094c591e0e35dc9d99d8ed19fcdf8daecbbde52d79e0d01b8dc1cc705f730e3e0fc9894244a421d36d424fbc516d7a0a527a4b364af087fcbc33b538062dc28a2b9375938b591988b2cd7a0a70a38a0be70cb93bd0588239c5a8a2c61cbb3c0098e81ea7ba81c84ee6ff4e4d1e0c404094f2d173bb339734c399a75f4e3d9cb047b3bd46b5479a91ada5817567d1f5b98102f282cdefe003f806d8804ac2cef1221fc3286b0b4b25963c040e5185fa1d61aedafb48e3d5b0810d31d427aa83ba8886b326615d49ac75c2e969b317ae90e436073065424e6ef2bd62292fceab748752cbcfccb5913585bd2cd1efec7c5f5c9cdbeb83c6db92b2a2d4d35b8751d746eafe935c34a324cabb8b649f225c21fb6bb076c1fc2ae511052911f1872b8ab39e9df93f788da8ee0bac80bebbb002d56d6a440675db532a2a9b7cb570ab5c026685799c8be425cb3f59b8c75c1676998d3534ca696121f223b352cdceccea76a19f8ca9fb2961afcfdbc52a4029fa5f3434554b8ec853d0f9ee5a4eceb2a2893e47dff72e2674c9861b37338cfe3254e59f1f4fda21f303006502fd7082b62a5fa6902ef74c65b70d13bd4fa2eb47d8d06855ebc3e3d25807484bfde9c3e28c2eb9913319132ad03479986ee7e5e1f7995d6682ed9adb17a6f521223c11a1de7eceaecf5cb6f5c20e1ed734fd968fdcd45208b3034208d2af48ff7226693320b1fc92fe64eb8dc9af751c4a8c726766734ce51cfa77482504c2bf608f1bf1438a2a019326dac794b5412fd2dd263216748285b6f892052d7542ff35af3adc34c7efa1590079865c64c741a35f584c709b7d95083e05969c56525a7e9f39ad92a00b9a578846ee1cf129a4036ae5e7e50f9200c8c85a9ae282949236333aefd76c6fe1fed7761ea4f92571f6e4f8d93f9556252e947ae930458dde89813776b07453a22ad3badc5792bc97c8aa1e377cd8d82f4d599b38e1a7c1220e5c5d002672411a77296d1cbc6fb72d127b0698633bfad452a2b34923229a38b045e90563185c285ab8666c2875c48d6e14a5255699f0455565bba2be187b0ccfdf43aa939e390535172c1ddf2f12beda72a2e47619e6320ed4e54d4bdd116d153b245c47d3a199e505be60cbe9b03c07432568fc3be77e663af4bb62778bbee6177ab0149e50ca5c5d7fec17994552401b7d05fbc95212fc45da3625ae48506f533d66f466f47e964e1617e0b55c89ee8af4542c767551a1502a96208e80a3a929b3b4f38caf859bda33ff2e96a3a13e41f593b8088b649e40981cb3d1d7af4e3d9c3532158427971b8971c4e235cd3cf8dbbedad77660f7edf31616c28ffcd20c2fe5d684c0b7ecdeadbd63b839d51f9b5b5f18255f4d2d0c57f361888f9db1aba0003af175964331145e33d91c7e34a7830baa6314a2f2a5d6ef1e8d0ea04ae0445e3702e86fb4a453ed65facfcfde4c5cc00e050914a9121b84a1b5086e6964d60828bde3f1ca3be7ff56cf735185413cc5587c6ba6fe371886a1d7629b8a86b0bd47956e66724626a05825391677175a2cb527f6c5ee7586a407e79c2fda6093b53104a21ce201556f4c413ae6a94aee0f6aafeb3a9b17e6fa36207ad6acb06a75cc8575fdb0efdb621c302b030b91e7ac2f3229102d6b946a8fe81f71a0735241060f7d615d9fc282ff08bedb7f4e452c6e8db657347e7296bacca33f38a7669fa47210a2ad6ac81c27464b95e08e89f5ccee8d0fffb62a326d003f6ca96aafc4c0bdca090cf0b18906f1fe3a49c8da1c5ea1e32f3624211dcb7254a3c4e4cf08656997e2b126ca7241be6c28a8cabf5359b07539d55d8dcfe9c8503782d4cf16a8ac14de6b34f512fa5e7b43e9ed25c508a0e01cbcfb2ecc4d476a19fe1d774b1b474fb87d6fb793f6987f97abb3b7c9393fab96fe52d0de7d0d1e1121323fd383629763e0338fa76dd0cc9c9aeadfc7c086da63c3fda82a5638ea2c197878e5b7638aed52d0fcb0bc828106ea1813ac5260b6cac5671a67119e039caffa31a095403e287d8ef1287ea2c317b4d2ae5de76a25058ca2ebe972be680e81421c76e79f893884beb8de6cf011bc2dae363fbfdb48662a7ce2bcea0fee7b5d7ee0a95833903a31fdba12e0b51a254be346c9d329613f2d68c3f17e7d7b501a8d6df46bbf496566662305cf888d1b4c2b15eede8f43f8589158ab6c8f4e0189d13a5179bcd2d3baa93abe8bf64ce4cdb5df9a286a71f22a9d9c986409d2b40a7824bb7d1a27b3d093e3f5462cc168d4d2c1b1d3396a6ccc7a9f9fb19e6240eccaaa1fe100b07a4053a4ff42b33dbd5aa09328f4be144eac4c7203f3bb8d7cd30abc63640ff62df649f380137e7d45d7b9e4575e474bcef387281e870824135235438151268482f6bb2e6b6faa0cb78c2c56397e2c80771a6f240d602665cf16f1e6afedea153b0a673dac7664c90f881da560d5f890f7666f81ad2d17a2525234c72abaa46994389c5738bc04429c88e5a4b8a6d6e9c9b140eac11e331e5f8ae38ed1bb006bec1041072032a8c19a209cbc4dc1af8058698e56a9eb9171e7fdedd6def85bd16b2e70df7e10b47dd8b1958348d04b9128a9e1b35714cde2905e77a8b771f4f1c597e585f047c08bb0951bf77c08155a4d514fb38ed5f65b0e7c178ad77cd24ad862cb6a2d2c69ba356bdcd6d8af65a9688d11f544f86dd6f557c3056a6a15148405b470281309a74d4190277f025aff44d48c85677556e09896089a40a860f72cffcdbe7c7834576d0f0f46e0ea25def359113597540a5f7c6b6e09e2d3a68d25bd79479bb2a8a93564951d3c11df20af45a7b78d6f9785e0a542ea58e4e9549d3aec0f8b554c5a26fa2011d1dfdfdd899f0001a0d8b455a83bbac7eb483d31c22aa66c9ea2cca7a010352338dbf46ecdea554cf85c33d629db256503a63e6ac8f2bfff6e1bc66ad4b4d4c97353e1789f793264ea142afd29730be802139a39e6bd2e7a208c795de7eb9d84d8cab2b74e6e1990312dd7174fc4107d16927b18e4d677b5b8e066d777ff7b0ddb8421adcefb66bfa81aa7c8f59da1e865cd0576d029d767a78493f63ac4c831a1e2f57fa7bddf1bf05523ba2419c4edadb9817e011bda85f917da7925e3acca2e69da338e05c36ad2ec926c2768cf3c88148c730e2a561408c4a3c71ff27516b8706984b15262823462a9a672b367823608015221dcc5b8f14f083b4f8ed426a259a2b63cc660a5ace04cf9a1737d554ca3c5afab18fa7aec45bba63d7e6625ed1f7e50f47b2cc9887d38925f81b1532f630cbbe519d1eabc21d28f070edec912640077c016cdd4efb362976f633112189aa18b7241e42d99dd9251e4cc0bc4f265935e9943c613e0bc7cbb952392955b700ad382c52dd50ed56d85cebd34b55b302f5fb8fa96032787fc02f6b01ec5ce948ed70886825ed8f097a3d9d91df9dc4f8658882908cb466d1bdc28fcae9e288b5f78898b6a1e7f40b49cecffd9a23a4fcbb0d991d6aad9c663e167208333fdc1e9af10ccc9cf13c6ca6bcdeb9eab4051db025ac451e2c9dac0e78d42571be1aaed34f9a05ebd6e7f48c388f95accf8323d58409704f4d8675c3896e18b2f085b870287026a84bdb32093557c43c33dfcddf20f2d6566f8e0b3a2f3f01e3af96c2889190b56fccc4e1991be233df263070d0317ece86e513f7ae336e8ba7c27b1bd4a2ee95e6a6f74922a56a30cf2531d253653d47cf8ec5bc8140d55419607bdaf302c4cbfb40dce058e3216c7988d6128b9ca8e5c30de009babb04448e4f0e94f695796a3a2d2c676b85020e27e85a793ae4547926ef5fe83d15f29c406b924287a63ca4b21e4c0e3b039bd4e8466c2529f4c4100cf428cf57c9c300a3997fac1902e78797b172c007334d22e16b9aac6114c11a749602b6fcd20325dcd44103af63d3c21579e5ca4e0120587e37b24e52b99c8e7a09d58f63de33510af06d72d86e1206b3fc91d08bd8d55b065d98cae2005edad76b30bea8556acf80f7ab6d0f01f519dedf951eb809f63d7f90b942dd37d47672fc1cc315e2cbd039af3ddd4d77cde60fc2ab7c7c5e55f70a56ab6ffe99de51e0250b0a6c52b596c7ce29adc10692a5a159f2cad603514c9c3bf9dba7bf8135d2f6120ecf6baa17b3156daceeca3b186060021e5e4736190ceb228212073239bb83a838c1f7d5f1dee353b8169cd73ac9e2a594f134b3b24e0b4b2dfe192d5be3d77ab8bd8a06eea381553ab503ae4d1b86d42423e322b21de462ca57c55de8f5ba4ae805c45eb24433dab868d278c56f59be11dd4c02bb6fa644dcaf98ab4b10602d2f5ca2c7ff3206a3e1acb511c032363bb3e5e6c562f9450b314d2429c65026c38ab066b21e396b05c18c170deb15907353606b0adf16061da33d6c837c5ec33d25e3b95dce2ae46045edae2cad349bf88d49610f4db4d74f1de143c3f9f0b5d8b20389857295631eb90dd4ecf8f4cc115c96504bb09ee21af7c5520f676a39de55e62ec7e5d1039c5e852355528cb2086db77f56d3ba264ba19a5e954ac7007b1c59f5206c21ee107de1787a8722100c397c8a1640cf6287d3d4f1658ac02fa545b8574454d2f9a6c2d121fa6422192a300e9cb404f409c6234a285262b9fa3ce235972d1cf972196fcdf3061ed1e19457085d90985090d49174bf5b2842022826556cd5b9bd6b82c0b494421e69cac5da64f5c3952d428b573eaab18da6b4438b67ba91d1e22f120d13bb741fa81d7acd8e845a4973762a2fefb8a64335c7e0949de0e4fba81772c65ad459d1156b7e9b9fd6f8380078168ce472375c4767258f624021e856c8af1e0812f001a079c535b8aa35233607046a6286d3cb0625f2a9aa23b1ba1011cf4e81c0fd1f2ed158a2252e6fadcfb60b92692d24f0ff0aba061de38f77dd34e26188892e0efcdc3be8f5fc9abf568027944cc760f052c2712ce196cd629b547d95f0236582acacb8a1dcbb97802d7bd3cdf77438a288c5793f7c68b39a995695c2767366e72db5dcada49982275d6203aa4076b13f453b9e29c35b6ed66245d7afdd17ed627e342b501040971f641fc744f76f72c22e7bdc799d18f1efa9ac4d081f0e68b3a112101aeb1ac98ffec90a7595336b1787ebb216efd2880a0bfce9fb41bb8a1a54c6fb40dcdc92eda4127d36b5053a4c8d2a0a98ee828845caaa4a328d44ec5324ad21c84e38d1302dc6a82277eab38e6c028ba4a1ffd87443007d293026bb2b417b0f0b0bb2057d3ec1c4fe76539709fba51ae56505348b2f8c8adb39b89421e6d139125ae43ec4b53c697fcd5db7bc4b5982328df732e021c4de6599dcf18085b3b23e486b0cf778e59db9ebcf0db4c16d52d8499823d0fc8b60fd2e492d08ab19ad38c1165fd33ab62930ea2e7a8cad3987ac93bd64541b9bf3319aa9e06eaf296938b3ddf5124e3b0bd439d53bdf0b1c56dc7167298860b06f07a65039fddcd0d7bf062b59279eb571e3b6b5000b5726f5542bc491b207524ddb1a34445c4338b046cf6ca36dc9e80d772fbdc4f14d25723dec30080c40d09f68558bfaf0c958e6674983134ea050f7577340e6ec6954e93d79cc04d7301f160b185299f4aa14a5bb8ac7f1364f8d3082aa3bf9136759ac6f524666fd6115001b2688ec251026bdda8045d6b9acbff3b0b05d92c3336318f69ffccce701df435bbb4f474a2482bbf58e896073eea81e0c6dcec4323a4e548b4e0a52127a7fc215dc594ceb28349cd1b3a67a6c451b4859de20a19f08f5f432834f64cd03a0d38bfaa99c2c4dbbd806342a2386ad0c441a967e0dc0809852b8dddedf9c2724b7795c51972f61aadc93cce34262474ae5b67c79cc43e313ae2c188df08ea867d8097eb3c24a1ce15b4342242604c43ca34055a619db19f650687de4d3010d3f67f5d06d58a960671e9a818e43e0bbdad5b256f238348c636b443cd21ed0eaafb104fbb24b3f39df5b3d320f02bcad5cecf6698a40056b9b6939efee780d173bcb0244852566c4f6eb56c1aacc244af7e530eeb5a0013896d7e57d80ae7b9cf00aec8a9547cad17700e37ce83d89f66286503823926d3612df3a64226221c044b12ed43645f63e0485ee7ab6ddec0d2bf1fab66c9e21f5ec8ee21adfb36934fc70ee221a634e6c9ccf73488f83d33bb6f3be228ef6fd6b42e80c52722751373ba2ce1e8823109e7d460624496bb4b2d2f10a5008f57bb62a022fc9524da9c82a2fb3785794068067e3f110980b4a1a7eb4a970488b6d86b38c9c248fce22c8447b99fff71649c703e9088309d5efd8d8d9f98a37098d4a2849f023f351b652fb2c59ff478ae486e316426ebf6d483b9cf22455657a1de473bc482f0e299440cf17fdfdf5a3a0b93b1e696a3f6c919c8229ac85e24204dee421d7493e76cff59d7ff1147613966658ea3f12e63ca4490bd5b66268dc049c6723f6c9c8dd49fd6b7e59c68298156287f80cbe444b8dc789f6aa99f0a8cd8808c95462cc63030d0349f1499118510e601cb3b5f018a47aecd67b76a44621bce73cae4d9ffc30147583a2d8e618a26842f4bd8a1f8447229de6700e25f26d885112f90922803282cf612fc4224a6612b06f7f9b88343fec4cc24c22a31983a440a33b3b836becd2825f704b6c1a68486153b68c80d43404f98240dca96616f2b41fea5e883b697827abf60522ba88fdcb39d185fa80b1f61c39ffb1e6d26e185376c2b8ddfaf3f8935adfaba9417962767e1009046526a1dce59034ffbbabc90b7afd036a729ed1fbc13591df44830d48517a69d7ef761e4fcf512ff1b25f9de411b4f63010e342711ffa5730aa63554582f794d57a2a091bbefd15e365e546f943d3ff51c02e7f186c19f1561ad22c15400a8fdd8ff4b9155a5043bd44f50a92984d8f0c95084c81f46eaa9d9ca3c7eeb464b5bf6c867c7c716d6bfe888b89576303110e30559da2333bcf1f61b0a849d5ba1ba8ee777452ca7428cd325377ee4c382fd4013b7e4badcb4098f249a90d8f8c5688b44b4f6e470e672c7d66acf2e373fd4f9a26ca1695c90d1adbbc62a4096e6cd5f742e5bb4816649d2b693c2fb120e789c2e94a4f9a28331b514e4e2d181ccb152032f2f7f47f3e750d40de00ec4bb3aab36dd64a208fd5cbbb4a7eef98f223fec53d560b8f00dc08325be65306f733a17ba540451981b1126b9a22f92545d07adb61a2f618a84825c24a0f64781a073e588ccc63cbfa78f1df1867e277f5b171cbc96c4ffc1049a6455ccf60b39e3b0525d3ddf65cc8e9d03f108a46bf7934800a05b641a85afe0be4963dbfd27d9e9605d51f7face390f6aaefbddab0b56782bc595727744490b0c122005243aefe01e90c7fb5e6a344f457afca3f185a37e28b00a07ed863243b717a6f147d6bb4c79f7430417f79d2d75e80359d36c8cfddc10bde5eb5c4d3ed75a9a7ba662bc95b1cdde321361cd36d355547864c974a2cf960e8702ec0378a4c7077d7843b4509e167a6333f24020444612e5d75da70ebf08453418a0c90e3e0aa69362450eeb54abe1da4c5f57b6d82f2d4239633d6b215c81d82d4daaabe6c2d8869cd9049d1f436a238ebb5d7c45c0586d8dd840ae42a1feff8c1f9fb9eca84a47962daa94281824d576eaf77e37ce8ee56fc0838b13c90b909ea78d4246817fcafbeecc2ef30ab53faaa16dc8d37549de52408cd17a37e823638e435d9fda9ea1aa24cb4369f1a46361c7bd465283f7c260521715bd30209e595f1557ed4a5995d9cfb0f69ac576051d9dfa8037af5583acc3833d07ae1c8a91c657f071e7026515b7542b7f4703632fcea0e0b57a0d5222dbf7a605fb8f100b8ef5cf62f771f96de5f99250f3a25dd144c0c0adb022eeb8ca49ebf0913fe8ae8e961c16b1bf37db783d3c48983d34d7f9bb013358f80d21a1267aa6586617d91814da2b29e94fb56d3a3606aa692ff0419eb4caec077f5747577953cb9d7b608c7cbc8f203c167cd29442400d97055916a9cc77d66e8e129add43357495edc5faab1bfa5d2258b8e4e7c79b13ee639f42dbf1f182ffc3d714c884760d133c8dd3e630ce2f42d1d5a6a80c76d0a24c75fd528394cc07531d85fdfc08c45cfbed7481ce42393da6a2e73ff35e02c9f67b32f8401c12d916df2049f3d0bdebb6111e13ff72e1ae350429a7a8244ff792c02186ec0088ac13c6e9e6f35177e1f919ea5adddbb6c5d7748c463cc8406ff756d34e5250dead7a79ff6f1ae03298ae03a72ebf24658c1f656dea3bb3d0a816bd2ea488c608afb306b7b975291e813590d5d0d49c8b531d956e2c146048edff0bfaa020afd6a6fb0cfa4c8b0bfaf43cb03933a464cc8bc4b5cb1a3e4909465d7c035b236c4fdca62ee8afa30fe555adb64e7145ceaa1a3b98119cf1bf1b74a9b21d0cbe666abfef111b21b6bf21d4788b2ccb1433cd433808a7d3d70b7c931f70a078f733b6d06ec1aae3a80901440d132bfa7a7b2532528a520c1b10bed31751f31f3b64f52a51c2aee802f3f304c78d4822448be50bf44024cf33f675c589d9142c75939acc23597d0f37d6258583fd14d36b5862c98e55f86968e09b87244aea3d6a1239f938bf2911d601d3b39df9c4727bba699d31f673ebb9a17e5ec263d8fbf2677bf3f6f3b9279208a5fe214e6e5c3bc900f4134e4a8e03810ea7e422e2d94e1bfb2c9cb9f536fd8c17d82e3bff5cbd2e063a828a24a9d846b7884d579325f0c28db88aa4f2a14a4a8567acfbde8fa7cf1de26e32de85225a5b387fb729ab2cec7cdaceb5d57a8a41d1849805eef53f9339501f2a8726d56ac97d1533bd123cffc5bf299b08ac378c061265e60e5346b29f4fdefe5dc85d631527b71b76f237a1966bcaff43fca5af498ac72ee0c38f6be7698c81e51cbfe4987269edc9ca8f44c117efff1904006f3efcb015a02b1d6a62cd1bedb538c6c6903e5943537ca25814ad67ef542e787ace8637ed5c037e485e8a54ca9396cf52faaa022acb708a5b7665684507e5da03d37fb0aa07fd1fa24e3e4a0b090c83aa0f656b52ab36a7ec328c2411b683845488feb4a8630ac0c7178f654902d3dd8d6252fe4b6b8dcf401944a4db84899fbee1d2d8c6ef7e83fb2df3c666633b5f6b7fd632de36b021133dec1dc6a6cbe89f61d4d1d9eecf6dbeaaac7040c18ba3588516e67fbabaecbd6031f52acb54fe4b298307ac2c9d9e662f7a9611875110db50880cf8ae3b722c064e743afe3e5f5c2d7aa35f06bbcab27c2c97baec79f5cb1553aeb85f78af6c97a6b23889a0ab63a3c90f31df0faf6b620a80905a3be4ebd846d77e05c481cc2b09d7dc33b23508c41000fcb9a417238bd998b968658cb823e7c6179ef293ef63ef7feb616f2b8a6cc90bf4bed867fc60e5d7550781fe9c9335cbe4ae0a2c91bb0236583fc06a7352cd057ce8c1d8aef0751fb9229b185a068e4b8515b2173e9ed954cc8a65cb7de451c01ab1527853499a0b8e2fa80c18bcb6699f0c5c289a6d771442dc05d6ee918c50f47fb43de77216e46c775ddd2aea95ebac82bc09d206822b131b8a33cc136b74403b9bc14d9a7619ba16a88818e068f347ef2aff842d23b4f2693c89cb872a468e4599b44034a3491108878f9df010fe87e38755c29f22dbbc267fcc3abd477817dae7cfad27ca3a14f52aaaf52fd38866f11de1cf8b9768a2c7af7463ad9b0dec29b862af273bbefd4d292ac7611b713498c44c44dfca763c348fe617a9933c55c3f0adca867157ae713763e1be7d25207b291b7fa7200deb2a1ec113830acf2accab7df7b735c60cf9d6ffc0f551f3cdd33735e0a28bf45674bdf53cebdb93c1988e43501498bee08c72e1f48359adb4a13112cfd390701d0d768c96e8333a0a5dcfee964de497f8bf53fdcfef79a5a9ef3b2cf93c7d9859e7a3cd04643acd675b33ac2ea28be19523d5212f4fee982947a6c08497f02c20195da355df70469db33c834bb006b2c9e18015a4eee25e1de43c713e2cf9d953b250f372144e4b38dd1efae09eca94b4f887876f08bd5c86d7113fa598509d17680eb82c2dd4200e71b1862322338f121a292da93df36abfcc986a2987b31fdc15362ee2b23765769e228264b8f7d2b03dae5f59c406a7d3e0301ecc3ba79e72e33f563d7cecd17f5938c8386b9e44debe60d35695ff51c9e5a50893ddee85147f2230f79b2305ab445b279fffff1d5a06637b32b0b3b04fc2fd35a2365ac6b804510fff09c3445fad536637c415a0ce549c7c130b0d0c54a29a2ca4853d36153486b0a6f0467624ade5156699c1884c6234a0c3e567d2d2fe248a22fadaad8976e49cbda53f7da9175c69bd631d459a9afbd3d5bc20413b9a8e49499bf9b0589b60d366e759d9bcd1af05ca8f0c754f3251767b4191b9d6662becdc5960431b5427aad09ce48e9fc89c97c38d2116118a232589b466bf4fb09ab4b9643c0a3cf72707d2733072dc85f9b4270526a423af2d5b268c1eb220150f1a88f20e661d197dde7b3e8f014d3f41d26b0ecbceba80c3ee846f3c251c80cbbc7bcb4d6ff35e26c9191561c94c052c8ffd9419084b3dc003d02695c765556114dbf021df27042797c5d6950efd742f93fb2ff27c9cf9d25af3f2150cb5928bdcaa719abedee0042f05c2089d06412107e2037f3e882479688ba8a188c15006ae4ad39eb98f1aa2eeb8fc9196163ff7e690a2483840a7c2e5d1f66c8eafa7b1a263ba88f1cfc82f55b77433912b55d8a3cbaa7805fd304fa18d6c3e04914f1db7d415c56241e8cd39a42382680e5e6f485d77bdd0f530ec36921a894b37c95650986c59d1d36e92a3f2636c69d1d8cd1821dafeea46badef52dd704387dfb7dbc210011215a6fede3f2f7fb9a3938a43593cac8d5c63b8dd1d73310bccebdf16108f55aa9d9665232e46578711d0147fcd08eaa80c1a8fd8eb6313f292a9dfdeaa47665ddc3a2b909deafe6a2c7f4e9ac2f1ef961459c129bb7cf321b3f9b7c86c776e74c3522fa19c0c276f019d965c79e69d8d843260204c0dd4149ce079d8b7408f931b253c3c7c41e1256592e1a8c3361238fc72234c8a23dd688f50123e0659bed8d33768c43a62a118e3be56c6839ff917b95a163063ee9f3c2d5d6df3217635899726ed3f9c7dd8a68fb2293d0adeb09625b90ff67e884274f6d56d633c98960b350f656cccb0cdabe0a228b9645f69339eee8f0a6a5c875311c4c6df23d242424fe6ca09dc471ffc4fe3e80fecbb5a361400506d199b5bdb27dc45288faae9d4054911fb63fab4d529f23dea0e98ecd4e66049bfefcf0e505fd4abd879f504ba83310a672e707ad3ee353e3dc14bcbd397d831b87eceebf51fd17a67da10cd3285a97540f25f69578b9577444a789334aa887c2420997306b67b3e5aaac2117628c7328e23437c8a9d903e15e0270c48f00e35447e01a66050c80014e097862b10faed7a64e22bc0cc86949aa7c479c51c777701c086b81d7624d905ae73c5f18489dcfd3b75d670a7050bd615800e797367fc34ea6d8a663f35e9f83c33552d38f0ea51f6f4bf8f93c684ba0d6915c9845323124e5c61463acc8d171178d2d2fbd9b0076508607636c9412ae6d46c73ac6b66336d30eb5cedae91c14d22408475a35e824d8651e532d03678edcc8cdaa0e5d711e4af39fa69fe3985970bea0d97ed4f0cce6e98a5efacc83563ed236252edf8f880ffaaf7752326adb21ccac90be887a0ec82c4409bcb7b047bdd6aa8ebeed3e74567785a2c7eef486287486cfd33f81ea4ae0a336124fdc611674385ca9f6b9a91552a68e4e054b76f7bc8dc0cd44c58e507376c4775d0f6351342620a85869be52968e805216f7fc7b23d606206e800923fb99df4b61e6eda0f3f9343a57c84433505ff089ff27dea81cc4d00623bc8894be00747d34a6a10a62141db195607a0e76a80d0f0754576fc873d5c91009907488b7f05cb6434294638720418a8a49378556c173f62963fda2f38d9f341763a3d7eacb7ae0a659c367e04414bf76ee477f4fb8e4042731651a39271ab75ff0d1572f1af50c0288ad7e8b91bf30403dc9f4d512ba76305b797a4ee6c27e4db9dd4de6e71adc701534939438ae04990227336e2d95c45293bee8bd841ca1d006ae10ae412af696489eaa647d79a0567e4acb9277a96fce9025b9008b16a2fe0feaccde8a1e52b3cdc632813403ee96d07fa15c8b2ea7235d0e315b966f379b284f87b4226863bd3f016d1e5370879a9e48f7c9d3b2872b5a674ae50489aaf2f0fcc348221cee9bfc9dd0b508bdb100710f2bd4e8e7651479a8a8689a010af608de8d97f11d49659c65e800b9bfd18fa8e83965f0de6791fa49c3fa710a9f7eeeddc003ff2b1c8b55861cb6d37ce2e99e31f3315de441adec669ba729637886ab8392a081b192960e694788a16ea025f5cb8ef81105a4ecf5c3b433080e94cf83e5f3d3d1e08151b5c05b0bc877b0c1393cb7ca277f8352bac624acb6c2096e372e7bd260dcf468a8696231a4d98bd1694fafb7f52c3d5224f979447cb5763fcc68063235806910c0fea6a1ef8ff874ec47e7d6dd2f64653ca8e24f31b6e2756e83c2136ec60604f7c4b0550fb7f9bac10ca1d13f77c8dffe79ea5e72297f72f2924e42466ea86a7b935b19d34e9a7766064e4982ed952f362655d4c581d32074d7de133e18f7a27d6f1f1b162bcfd5c67c56886932edcc04533f036e7628f1bc636ae00c7dd798d41c6a5d01cb47f8c208fd07b83317cda5073b4ef11367d632cd12acc9306a1ee1b6fef74e3d55133d4cbbee09900f9c360c4f5df816b840a521647cbf49e007f24614c2bdea451f3cd6cf756faff1248f33f3dd49d9d932ec74c5b456eaf15274a30219d631fab7a3669ae2214f74a2df118d2f0d37bf866145819159e6a59036c32283ea36dfb262077e5ebd6d3a2e5485f62c7e1d6ffda81f18082b0baae7f4558dceede5bc5b183920417ed22b7f00c2fbc189d8fefebc2d2b668c3c64340df7b5f16cd398722151b8b7639eff96898048496229d6109abe95bc116ccfc1fd3cfa6531c52b0d2d94aa9c49ce1f06c01be86360eda958fce28da26c692cd5733ef5de2efeb1f10724d4ea6eb2f22692c93d8682974d291bc72aefb56e9f1b92511b036cb19c62cfbd9d6da5df234453d1d781cd90aa514a597dcb7f01bf76c98e7ea3c2f5cb1840d0d33a09b6657935523e00d73f3def7c3f48cf1729998688838974363ad44c61fcca0eb6fa2afab77a63533bff847d3916fc231192677c526ae344a0c279f1cfae543fed1989cd15b652a98b76e05451fcf1c2ece313d04fb5a2c865403d69cccd9ed549b7526780cccc662fdcf7b8affd10d810bf512a16b997a410180a327aa59448e5235b503a6c0eb282a4aadcfb9ee0ef9c621133175ad87a5219a4aa10c12201f3fd42b669cd812e0be976fc93f45c0a5237d561dd43bd9191e9237b83397fd0b8d81cb7819a86b1b534c8484f04fb99fa9b76b2fe24897d99e9feef79585f72645185bf6dec77c04353d74a3b7587e5c7266ac83704a7df503ae440972c41a6c2dfb0b38f6e15f5ca6ee4a4c1ab2e796468b9cec0050a33e915521735f0aa865ba8ef11c19fd773497b93d3743fe9398d2cdfe4a3b476f66da1e060769bce36f450ac688e101bf5c5509a9fefe700a5f17f33d0ae7ba86f572deff4d861b17dce7973f7ee5fae49bda12a66d6c21926ffa6dc5d6591ed7cc8d6777804b5b34e8dac68e1893fb68628c24d29b1382d137ed2cce6a1c0dec89f0adaae947f7b19ef560a277a8d34f8a5795bdcefa0dc8aad4b25ca374792e85c9dd408ed7cbb82a0e265dfdb258d172e07aea923b6ce1388fdc9a1f6eb6796d38ff763c099791bef3f525648803c185147a2926d1314f47d4e4c3be082d44a9001f1ccf4e0a5d08a142f9e51cba503495ebf20f006119c767c4f31a5e319b16d578734789232ddab28200d83fd082ab601981ec868db85d65394fd7dd25ece0e79b870091b4b86dc8e2037fc081e81b6b3d33eaef3e5e0f9a51507e7441b3d649893b5a61cf9a9ac678bdedc2986e3b5dc10b0caf77a3e56cb02085c304252fc684a6652151102ab607cc68b5fc9687e6574938cf02989aec56abf70a0f24573249771753b6bbc099d1ae2215a6bc3b701ea6046089416ebb691ffb2255b869c80b6aee79be2d94a565d866170779836fbe029c97044cfdfbe56c2bc5ceaf86e09b8c5c5d0acffa067a56e159faad5d2e9fc916d81d2048302d12dae9f162a35ee8e5e77e69e291c10ae4614b2ae8c4d4ac17dc7bc1604b28dbd9b8e9a0d7f8e5aa8a178547e8bb502c2df093d79f6b555939ab686ea96e0d465dd8b75888b5adbccbf3ba5c8bb9954039dca14726518ca8ebfe2fc77f9d0d30c00d67e1496675bf80833991039635fe58740e9a78823bd85bc1906528a25bb142d0e467765067f8e6698f8a58f1fa224298dc7f1d47745be127b7a78074ce9d8cf8d3eb3badc3f4f43a07689ae42d20c6ee25340b86aaab8cf32f14fd0fb95fb726af91a0e16c47e5ec5d020ec582b84327c14dcece2590849ee613dfef6f253aac370c46c79f307cc08950670a816e94727f5eddc2464d9909ffc4538add52f8fe3d345e26969842593625f6e82d3bb3d6013cc989dcd85ec72ebed313b3098e451a805a1c5a9e2e3cba4915cec4f27d3b117ef1966d5be8c916f9c0050923cf45a52b9e08de643e5ac8cd9d5219f3e0db8e737d8ea2a94ef45ed473b93eaba7880fe3e8c10fb36f86e6f35b8abdf0362a2c3808f3f6f077bc03b4dbf2033b82a35f9042054805cc9d17c0cdad7efeb9223a77cfb84e6f731fce2027313ed8fa0b05828d7f342d310a59a89230336700649b1a7107e799a66e13a6e2f9d7dedbe5b359542f84ef7d67ae8e16fe9ad18b80591b0ee18d96676c027f148d5afbe42cddd89d9e689b10e1daf7a0982706752c8f8acb8a732f229bca2c328cdcf1a25bdda9acb59eef11288a8b0fc181debe7e9cca92e7bfeecfaf856fca87cf68ffe0bb68128bed738d4661c693c1fff39859bd87c6e6f4a46fbae7d6cada95bb0b5515bc704b1bbca45269167244ec725209ed3039f0cc98c299d7cc81b8209dd3a722cc231c741eb71347e2b80e73571e40f07320c88a67998d30bf8689394733a67dd59078f2167e3f82fa7284848a1564fd8ece9ec31a0f3ee4dd323e192c4138e85dcadf73e61e3071edd99ffc2d351101b075e73d1d27d9705870c77ee6c579eaccd6be76d5f12d032f0605d75dce","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
