<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"88b6265b3c0393605feb0a92ca2f3d0574dbb396de4bd2e82fbdf26f8306a9a87089ea53f95f9d6184722ccfaeef45f3498e7bb03a76daad9210207efa4a6ed7af88e7ccee3761bc7bf5d2dd83e8f2a67f821b343ef4bfed206fd3f1134ce31670c27550085992366f837989f5c92a0e1dd9be9f7c1d81bb4a1c8df9faf02272ccc544030d532691970b0eeb1bd521fe3264369d38c19fecdb2eefb1f49d855c0f24272c7ad4efc21327619e71863048bcf1fa91ba0012cc5c43b436fd3a98f763847bd9559c4279f857146de151d7a55078a67214740b091d4756aaf163dd385104e1992bb2d8a32da70e5ffbbb26c5ed44749323d5e7704b46d048244763ba57a12086633572ec99a8d13418da98beb0f1ec7660f790b1c1cf7e89ec75bab596697de70c17772bf1a37b3f8bfcc43d0de4193f2671fc18db32d4143a407c911a47385856ceb73416b61ce8f25ea676222d8dedfc6143e4c7bf88e4dee9d34b9395600d9313270f07139e9a3d22c50044d4f8cfdac435b0bbe7d91c2b9115658abaaae2f25aa843e8bb9bd0bb6ebf7efbd10832f4ccf025c63d127ae3af53bb56ddb7b36fd72c251d153fd7a555dfbadbc3efa6f586eefeb2a4c2342efd9625ae28d2bb1f7a80a5ef358cd8bc8c67326dee8d8ac5076be62755e9c586767ee07ecc7f405e23eb109d3d7c98f93b3e08359b515d52babd36b37463bac80e2095b61ef112127848ecae5ad7e8b067df195afe03704fff703567ffb0f1d4473409732b47c71bea2104c65d02ce2a5ea3418104b792659c80c14d7956d8f8db4ee52b1244679176736eb20389139e89212b7cecb22e2c5be555c9989dae2665ea87cfebe33a18666d3deeb4e4c9c82c8f77b6aae33679ee27043e85336aa5cc2724f0720a7eb85b4b25e7cf6ad40d7aa8115a9e777c86bcc295d84f387e49a4c9f83da5816481f7adc04399a0ae64df71a93a31f0277ce9e6a2d791aebe5fc1d42a109e82e58d0b3f80e49ad21bf88697ab5ea0c58db9b4efd0cc844600e194e877e0054c0d0a64be5e85e1b4109a9ec28f406f9a347c9e1fc732804e4579c4513338e3de62a3049273cd535801bc8d72177e22683e2a226229d7923e573ea63f90191a07d0bc54036a9bbb4c937541bce6a13efb331d74ea93a90806ee3a83a33ed52a8b8dbfbe554055d23d4fedcaac2fbfc57fdb4ce0f031631a4d35c978c96ccb2329daee4ea4fc7122b3b644d986a9c79c17a4d4a05b69bd223188d1ae1b857fecbedc19676099bfb7ff96975e819aa638f6318ae214c9be87927a542c8c9d7b4aa0978167ad9dd3b2c996497d1dd49e6c604b745ab6809afbf4c2dc34735bd7c6a4ba49be8360f9f98d47c3aa5b39f6f2881b81852397897bb79ed3c707592e1853392b25ed5aa70f154266419d177157f3ea106d73de4cc86c4e5abafd3d7e90842c604c2737710e2ccecf595e0fb907942c3e2fd0332f535f2f406d85b408634158e216a6ffa84dcf48bbcb756853e566374503198da429a01d152f9c3600e29291547c3268d091cbca2ebade66c208b8a8856a87ae9139a1f7d49d4ecdcd4c347cf9cd62c373968f9959b76145a2f57f2f06c58591c4ba5e5373d5c513246a51513c2be67945d19548cb4cc7bba814014ba940f4ff87a95294912e66e46500d93a6da18b8db64ea8c015d81c0ae9ddef5809adbadd10bc8ae0f3d7c3c9c0e4bb238d63ae17e19d982c7f017422387a9e9c6c1471543081240dcfc41a5e2086eb28c60141a6dacf508ad72e933efc91082a167bffac9e174c6ca9197ed571e659119685f274ba6a5b1f9453cbb61f5dcf619be8142f71d1fbe01aa4915e5fd4ad1526ed745e79906c3224c39a3f5e4c98ac893f05ad10036c2d3299cf3dc93a62be61af7357ff3ca890a986c9efc7369a26c8534ec2977c3a701b557e2390c84a54bbb93d6910b35793126d07a5c33d669741a3a7a94b068cd325856f148cb4879f18ea59ae5dd53462788b75a44d5d176360205cd1c7ee0ae42db99565bde206a38b8c907d52cca3517bac680b4b18dd78b22d49d1729b87925e03f305309089dd356b109164d8201a40c25f5f1fa3d3810859a887c6accbe73a9eb71a9f466d73f4e57d5de9ef02369988e3e7bd04f60f90b05181676757c27132cd02880b501d28bf54a4a7b290a023a55880c68a371d9d529ca4ec2e39bf1643552f89f8912a4ec2786a4aa9510a0d1c5e2d96b3e3ae066fa26ecc6425d1b1c4f9bf69e34250a7de4bd529e79db7cae4fa9c842fbcd5aef4a7c8e7d7daa7ab31b4f70d5c3d42968131e4da368ca53ffa4d02ccd71aece70b3afbd20ed6b695aa92746520014b45c3055949322a53f5f4440d4e2c3404b43344dfca90d77f9eed8c2f6e294604a8ed79416ebd06f23979e656e54b049ae9bc737f2ecfa045edd5edf7360ebf19a9b248da1d25b7d0baf49d2c3835ea98c024f981294b72fd675b4b1293852c9208cf206245575ca6259ae876cf5d7cb6ca43aad7602dfa518773cb948094147339c30753982bd87377014895c303f05ffb8c43110227b50cc20faf0e1e3d1f214c32b822b6e2f53d0604f779c553430e8cb577446009363e69e32cf15fabfd85e7793c64d459be7bff3b86dee7345e102fbe971398e79bb4185802b2f3adf70fcf382573b20753a9f181744d01d68d2d83c4771bf373775171c69f61ea079add77d2fdc10eb962c6acb540c0b86665315a446c4a760e3a59c011602a2f6c7cd2dee3287f797abdd3962bd46d608e77540398272311b937742dddc5c928e0b1a1a585fcda56b03bfd54fafdfdfa8d9b7c7b36309a180ead3b6454a709be6887ed5e6dfa9662f75064be3c45b5475d4e931e88e81231afde43a784541892b8ec9268290ddecc50f9f93b868451bfdb08d42a0dca863ec7c820a3251f94fce5d01c6e28f4429b7f1430dbfc5c81cadb05de9aaf421120075db10a31049f9e58e15bb82c7328fd9e92259a1d7655ff4f62fdbcbc30511a43b0e9a617b96daa86580df2736ef2d7ab334cc2ab01fae1cac2e54c821741a4ee45e4dd1667d5d78e15d02a338b5efdcb271fe68aca3a1e0a8184c8bf0d7aa8224c71926816b76338bdc846773df61cfa6f669005eddf037d3580d40d3c24b1039968749cf6705fa468b62df281f9d173338f4febd06019735008335a07f256941e9a9a4af4346dc8c84ba530c652d202d911216ef7c612851a29c5c046f900bfef73b80ad55f2af2d8b037b3c1c892d3eb93ce715459d39b428dfab8f7870c2910a1d6e1bbb0acfddd92acce2a08842dab52369ab79b615a7bd9507821345b554544e82a944970175dcf51e531f54b63461c1d5822203be8ddcc59064cb350608c8171aa7d7a01af29416e010bd30b583074245deb92be175b5d14cbe4ef55ca0acaedc12b81a13609896a9e4c8f72be07970d13af7224d00880f10f0d6294fb905d230d2742cbcbafd54237be3b386147eeb3ebd46d476cf63fa7df9dfccd662d461fb0a8f79d336fa8c4d637cf2ba47869f33022cd959a2260830541543e9b665fb9c564be97c599340037acc9bd5743cdab97de3242b67b444421751eea52cd45803e6abed03b637066995f8812a1eb29686ac6e4c68165d8b2b67b4b2fac5720b30e9787d2c3cea3259251f4ee703663c05019c22e1ae18cd092ae801175c41b9a1112ca3b8ea4ebe847e9436ac082f3b74d69b3007a426acc59da452982d1d31ec5860ca9f996e832d046bb55880b48d8936eebc3bea5055b82d4f2d677a11811db0a1d5347525863c542823f8bf53b79a22e08b920eaa8fae2908bce09a224516a20486ffa1363eab7010985de84eca2e68380cd0827a0d881279e1eb5acf5d783fafa8a7a5ab7fc03ef26ef9f842c092d0cb6064c8a2c1a4d2a415247016ce216864b7d85d7d2f727a44cef4c620d84f07bd0a0ebf4f682aefba8b2b3a420662b6eab826d29f5ffef80a5d091f332ac23e0c7ba4f1ba5719e69baa127a241c0415e0cfd1601843fe746142f4639389b516022c7dd0977b3fdb7ae2da686e877a8710d4ba1e0a4dc551c10da3e9cb1718e1118e0a99e173632dcd0e439d45214853314ca9c287c53645cb5559f611c11d0719fbabb304a8c88353c01e1fe8b03f90dde0acc64963090728cc54b69e195316c2c31475c6f4e0922c305cda8acea1d3ed8596f15f73ab109038531807df10ff29f3011d66529407747d7e60ecae423ae44a1d9bc155ad52566e066b3c5030e8014a778a3edab29ac433ba7095491086e64063d55ef6081c8130c32122ecf8e89510f31677954d8846ef64c28f5594cd8ab1eb127614345544ddf5a4b48c30324f21b21422c16e05dcbee4dd7e172f62567f5a217c5685560ef0c387bd4a94e2e1e778ebbf4ca2abaf865a744fd1f3e26df682649bdbd07d108dfb5cd6fe906122794e488a62a0254c2e8c0a031e6a169c7e41cb6ffe35a11b2a836c7124046815b10157f22636f07d06b0daeda82c92f245c9971b547ffb73630214a5ef0e56815960984ceeefae259514ddc7d08ac559aa3ce4be861b49a08b8c160de11828025c4b3a7211bc10681e36aba53a3b0118cfd90c6cb1cb7e423971446ad778974ab1021317663ec9f814633d7ebd9a75562319ddec04482deb95eff9b06a3c3a02a1932f33a943718383a8c86d6cac6fb41d78ec550c6ec53a6e5ade9b62bf9fe67e5cd3b7e3a903ecc4e7db128a49e092c99fd21d0810a0b14f2691cc6900b07755c2d32133376139e3e44d8516381b499c1fd3d9f613396b2a102754f329adab31743e97ebd95a55b9822e648769153382faa1e93fb9e908921d81d67f042587854f05b0b2ae3fc8488c44c9adad9e519fc015671372ad4453a90e47258658c117eb4e8822dc0ba0573176f59edef0a6e47184af0ed4eeb5e290d2095ec4d1e29025e0529f9073d3a8d0169d7c716dc374ed797f3066a8373845ccf1a193d483166e51e5e1da298fe3aa0ecadf3be123e2c95062b321b8c87e3353af35c18277ffcd86323510e69f46c4f3620b1ac2334f951f07e54612464338b25c18f3a33dc69c7b73da064b1e7d9c3ea8396363d52fd539dd76c6e017c5d5f0fd5de7a143f02755ed3bc58425e23378ba3241fcafeb83fd4dd6a99259c09c793628cb67cb93f95042edee3b35c4b69646699cf12aef93dac18fd8223e430cee1580631e02bacf00879cf35d2818f7f5cf958b155290feed5001da0928c84b84f877eb545c3c5333e9c9e4a683001a441b8f1cf0ba737391881877214b03b21b1ca5ccf91bc35ea3716d326e82febddcb3c8a61db8c3f39bb69c101f123a66bfe84ea97d77c8f5b8076c561db4c5557e8667207e91b4076ec2dedfc366bdbf1e70e4873221e0534005ea1100b4a9b30f7546cdb82cc97cde97f0dd341429e9ec7d6fe00b0e6b1e8c4a11d7257cfd8fd28a6aea2676f8902846b968071c50a882ccf635571b2a9adfaf2effc13d508c2fd901473c2c8eee9efd9b7f6fca6e3dfd69c27319db5c6164abb536f4ea8a6aa8b707080783cedd917989d4c14864862c023f38b4e562011ff22da44f189b16b7ee55de8b2b41414b832eb6653667f799b9a48e32f2b874dab67218a1071258b45cac65725c08b0b26befa2ad6a12dbabe90fb49fe62c2309b222eda456c8573fb21bc9c45a554f3bde7f0350657d1eacb92097d2682cbefe1c0fb0332b5118398dc23f232478313bee7afe876daf747be68d67cefb924f01778f4aa83ec580d2faedb8cb0788e6ca78fde7a8306c6b3797b9dfd05bade282852fb52208bd9cdbd2885127dc838250febf5698a5d6c159a364cdfb50c3dbc51cd00f194a17bb0e6fb9d75c41871b577f692e569c403473fe8c276d28b524472987df129faf585f9adc0c5b7ce6c4a6509903d096988d26ff4ddd37ad58bff95bf43a5fb52bfbff0bff86c1503a57dd9953662d5c96dbe813a886efaa3b357d217a22cf6ae43acb851020e79e2b4aa86eea001432da95cf3a2205746824c5c4d7cc03870c08f4936e863094aac781cf7209d3f30c002fed00118f102637b5f165719b286dfc78f87716fcd06de13173d89e4aed9a68222096f53894cbcdbc75222751ea58343161b94bc9710d9a9aaf157199ffb2be871aab77fff61630c33960b1f55124fa54280d62bb445299fc23d91cf804a1d4a0de12eaaf6b4053c5b485ef8f0669ccd18508999f7152e45aea3a4add6c84a8afbfa0b386b222811c416db708b8affb852408c3aa6871ecfb9a205b71a959577a9d00b04f8fbf3ebbb03bd2b732c1dcc13882010fdbbad692993cce10c2ffbd47e87147e5fa06415a097b822dcd11fa62519b0c569660394b27b3438c9affd47c645eab250331e860a0457615ac1d7f121f472d72590262e15056285f37a1cb797e29a9227f8c68f069c3cbdbe072fb35d9c884bc8c72f70a37f05be8606d09c8ffee83e8a30f1bd34b3e6a0d94ac00bac2b687fed979517b202f4f33117043db228a83b1b4d5d9ed35e5cad62512b7aac8590f5601676929266b45446ef3596aa49cbb78d0ab502b16bd210c2596713ee80b112ad41b07d8ba5b867d42a68d9757c767d958434ee10b49a85e6183f6a269749a43827accaef03d98e3ec4bf89e7b8e6fc80c01e0b475002b450cc0004fabce7f3bafd594ef485e7c68a2e696c80302123ea63614763bfba51e90d78c72916dc49a93fb7a8681e20b428857cd31ac98ec7e1adc9d9cd0ee39ab70c7a9588221e9d3de3f1e682c342fcb66befc4a310586b94eb9b8d3df7b9bebe4cadc5bb1b55ad100363ee8c8f5c918210f3e931dbd173a5f9e11251291caaa3ed267c835662e352d728dadf8ec64d6167807b737761ef1231c19672d87960c0fbbda101f74254ce9a33435807cd8f9377be9c95b4cb00af9c1bf61409116a1be54f8e0c12938579840a07d9778880a13ca8cf3f56e2b190cbf9df9011c73aae61a466cfdd9dfca0555db915528b58c882b56331ceb109f59e932ffce0b82feffbf51ddc5e5662d09874c6765d7fe3aa8575cd64bffdb14730982eb189e0c485d299d93845714164c8c7578947a4dabe621b9be44d8980bd114be0f71d852e132bde173704d39370162454aa853401c8a3a5eea7fbf10c1898463279fdc81dbe38aad138d7937cfbeac98eee5d8a0ad290114ec02a3f13a1e3b855e1e1b5888abd3885b4c066d91b162e26fb197a994157f04e33a315aa281544184f1acf7e6a6e57a0818d049c5d156c5174e6863ac8ba6cd262f2222a22e0f4395620cd257dabe621b09a6ede98e0d4ed0c7a4cde9a7f2d3c9625b292ca33ee174db5673d9d6dc6efa23f537006f222d2e5f960009ea83953c8fac9166fc3eb79bd63eb939fc74a92db19f2dd3b522d26efdf34e82aad9f5072b91238992ae5f0fe62679dda086f5793879eb794a7922454a1035f232edd2e3ba79415c3589aa56089a77a3ba8910f5cd04da78b5940f2405548af5515d4bc9e6327c3e4adbec799fc6c6887434f01c756d0ec1f19bc1f67ce5de4182a09e49ff826ae655ef39022ec5a7e5cdfdd221fc81e0890af1976b9886dba745b39398414cd7decfcfbb7de7d6b05b56afcc77b28d3227feeb453b8be32ecbf5b7f7c545ff6639cfcbdee04791bacdd07ec99d27e0a391e0fcf4e953b281b3c5fcf90364b72e8f8536fc3ac7ea77bbabfb8e4a142e7ec126fe93050e95c429dc52c5dbd095c067f0d846ada553d81e06e0ec14090db38faef047cd5c441bc0be4364a83c8e2ddbb9793e9ec2c0c17f59feb07dd68be4feb5b1d5e4cfcea6b1f471e4281e7e40b47480a0d6010f108f79e85c766a882d493734e4ab017e18049d0de2e289d1be5ef4f18446c6443e1482a4ec5cf3408b5083433d2fc0c979ac56ac233a5b5e6ceb9dfdb48f7547e0f23527832c1922f24b4274fb656fdee26df6c19faf855c5002652603356d5462e8f1c9a442a3d32f5816f41dda69fcf247bd5df39d9ee1b227967daa224211d68307037be5d37052d5c205349ca931a681116400e94fd82054ea12bbf42872f25f9f8f672fa2cb46b9e0b46952b728259fd1ed36448540169811424d68f01dc1e2177a0e542d2311437f1f63d3d9d7a778a3b5c755e67ae16d34b378ae70b2135fbea69dbe9a8a8fd9bc2791308f995c3cdc0122682eb6e2bf86667efec3137d048f5984200c4e99ec126ffc32660df3a773f4d31d03a3bfd4923fcf85566bb703eab86813cbc3128d3a949299678c5f0dba4fdc0221ec87e76a19683adc00bd0bf39d7e94adc9e2aa83b2e3b2fafb0ac78992c00937148bec621525c9d5d1f55fa68e4397a12e9c3d01ec92159afa3fbea09031bec5c52eb5da5002c8e00a837e320d8908f9dc08955735c32050626699b6cfe666198cc82ab53cb9979422b57b9524727e7a5eff13c279a47e6f3f98b7fc50cd1da867923b147030b034e2ed8d8b95e1295b7d28272f4decae4160826587696c0222b080797049f66d30452f85d204d1aa1118b4328598180900ac3572e72765aa6ff59f5c89aa8e2dc1ef329620ebc1663849a30618c17f5b601f2113e909eb113c507ae355b414dd46e59364d8fce63aca80bea9fe0a2675af9c1347d934466aaec572cb44277055cef7aa7c672d5d4344aadbbfc2e821a1fd722ca3f00e69a11d3f68823a2fdc669e36d2158542be25d8a70c58978891a140dd1780d579232b369be440b5d8bd9189732f1e8b2fb98d2f9d96fa098e5660ac5b47859f4573e426528fcd2911c3f80598f74c1bb29af527d0261050f0d3fed60d92fe324b5e039dd56cc9759ded980c56277652fab98aa4c0cdf66991467730b5ec1dc708f006f994ffbe1bb7f20fc4760b0834273a0fe418a7548a7c826ac5baa83d5afbaa406f45872b7e8c9fb1a012598a6bbf809c8554b90c59ce42bd090df3489bd3edb2effc7f47ee51d593941ed5ebb60bf50592b79ea420369da8b1bbc1a742610d226231444340bf6c7d5eae9ebbc56eac3623b50054a7e290898bfb3a2c4159d078125003d399b1fa57a91551a6812233860aae76c858e1ad69e892ab623a6748f4cc212a056e0a2d0481275ea4a1229b80f16e569115140cbbad2d010ebb2c01545d37fbc232e4fcd88a802e194fdcbfe5246faab776abbccfdc983b78e5b07a2fb51a2ee40ba7227e179dc71b6484bb4ca48f291c0d23fef0663e5c511c590b75ea4bec343b0b0c0dbbc1bcfd7e1cd822361cc21ab9e29db3e83fb2fd6085615a6d98617308354668c9bd4f22beffb00df69a5af764da818f46de4d8e56bf69825c1213347e9d41d58cb123fcd6d9e00d2009496f80f8b1d113dd7e2085db120624195db0141f4c170d67121a5c5fbd592a0e55a89e0bb7d2848d1edcf8150132866c012855a94f3c77c1a4d96cefb89531b3cea74040c45e4b139d0a35973e4ec79cc7d26a90343e8cda89b2fd0f14b8861a9249f3909428797cb0e25921db16528241c23dc6f18fc210cc311e4838fa46b18ede160b086b7fb6a3ed5dce62a23b1bd738ee3bec367de8883d4b8f2dc122122f6c82779ee90c97721f2d4bf2dbb95c7c0b54ebe36a92ce7dc4fab791347cc0186285ad841f5d488a09652330247d94ff67fed1dc5c69a5eee1104a5893c9626710c2fcd70dc96d28b222b0863af3a4b39e24a0afc9ed58a983cb4c12bd2936c9ce07ce64433a038f13824637e6824ff575ce98aa2bffff84c441058124f954276bb6c42f59de4913715a15fc98d25334462bfa347b4c4b7ba0d7bedb74a545eca5ebe03d41d480b87c0258e13df1beb5415f7571af48617a7457cd13c22592ed39183ae380b95e39f7fc36675bba0ca86499706164a6168cc03e8fac0a4b5b17388e435421954b4ce8c5b01a0c0629285b4711772c5bd310f53afd15776e2f775a2efddcd0ad2c5951f740fc3207783b2ce051d06187a1011f42b28006f246e21973fee4b573bfe970a19cfd353e84cc39fb34f89f1a1e24fca813608e82dd70d3a66e28c325d371cdf1407d47edb4e8a6bd2d521f1ce25eca7f8ddefa6ecf6f8a82ef303df7e54730b94a7d21dc56c3b122eeaceeebf2b5cb6593fa885c56d168919a6ee502bb43bce8e685fd2d229ca8b0399e8a6993cac27be30ddfddd319982d7af6f547e52f191a43066739e1ff86940b3411ab1c8e34d5262cd049db450817ddd0c6505d40890e60ef50fc8f40ba8c151b639e49b2bd27b35735839019bf30988cfe62783a43111ac54205f6f0c85e083cf817f0b100f2e2247c2abd18c9f5a39505abf10b57ebe5a4076a899620873a2d7d86df3c3f48b3cc68ecf15ed313f0f34c3764813beeda1d1fd4874e13eaa671926c2fdb9d2c348a64c832e38db69e5569d6ef57b94bd2b94e1b80ebccdae90ff0f288483b91ad842f488619fc9f0f8265b987f3e1bac49843168ef79c051d46d977b301eb0309900ea169836db10ac5cfee5a6e39a2bada6c27169973e3353399be86d326b4b2739c8bc7ab27a37ca76a6dd2e321a82679e863dd83b77189a01c3c5c8e6bd3d17941959203aa1ad1ce9832342f0117bd7d77a474ea983cdce8a0be5662d2b2c50e34c4976fc12d08c8fc7005a034b0cd1369e170eb11ca6ec9307f67b7ac3ff1b2a15b51874c8c0ff8a1d30fe45c5d2ae71d8814b2bb427cfaf83d9416f5d0ca7961da26330c126ce92f99bb7241508b55f4dcf014bf8d1c8c064c1022c40f33fd6aa2cd0a7732b816878d0f1d15a309a3ddb68c48d3e971390d4f1e5ab80cd5724cb2eb9da6c0b35417750765ff6c9eb738d16a8c8f96010efd329fc84b687dd87ff4135fd55fec82196aef35cf386d4ab630a732e7f666210569be4541d2d589457b3bedbdca0e579617d576ed60fc8d921065e6b16164c3c931f36790fe703bd04e31fcaf925b81b3a52f8a4fc5be777a35d9f5c9f03550fdc0a9aa5b1047f2cde0b332819379da8278c83f6a7105a2486cc6140b3a5d0d7d0abf6a2d6aa29085c484af7de4105bb5938d664b99ad6f0f14382bdc879eac56d9acb84358cc38694a4ca538b6c3622a8beccb639c5e4b2f22643815762d46eef27cd6f6b043764b1718c430e44fc0e3f86807ccb42ec26d093d23e28c3db8764db8d6994f756c17f31623b71889991011d0b4eda3d57e9afcf21daee18ce02b5954e90548b4c0bac1cf060305b0bc2aa6efb2cd70253f848b1e1a6051f6f157e18c40b961f9b717a4284f14c6cf8798d0431493b4969d2ef0bbf325f052541573803819df3d06fc8a637b0e788ba07bb160a3b24880bbcc6f52c58806e40df4f6110f56342d0c9fe8504ca123828c35357656e3052df1437e41965e72b9a5689cbef8fe06be8fc8b94d7d6ae39a93126a60b27a91b73361ce5b1e4120b8bfaa8f94bf79930d5e6b6ae6bd9d5ac46fccf5322f4ba3c09b3c3de912b3d86b6b56b9d4f87e89e40666b53e0b98760c027f97adf1dc256bd3a02fc51aa778cf48eaa9af80ce385cc98b9446fb7903ac618e9a93fd2fc29e229049254f368959f223f2535949b6bde1215bd901fa49164892d527ef304059f9acbde47ebc4490b686f243d8313b2b81b419226b4bd1a76eed5a612ed5b4a49f53d2c96ce431a4b7325c870dd9c2af32847783d22925655e191319ee76be7dd90508587ff9b55945294dea6787244563d7c209e01e820d0783984cbc7a07ca54006a50216d0fa1875f7589d858e152b83fc2a26aa815625eaae179fc39afb09978a31c97bc9ea8742aff95c96402eab7c2c98122108cf0d48046d73a3c7faa6917a9ee300a6d4b27a29d02d128ab1027cc73a8a7aa99be4aa5a91b1020d7580dae0d3ea187d7a6e460c39cdd2ab84908a925f133c053477d91a1162df265a9b8a4fdea53309d2d5a09c1029fd1144a00cd8de5d3a603212fdc6bee7add7e113348239b543b85c028f3377e071a8ef1216b896e49a6017a1a201e71f03620b08f598bf8aef3488b12ea8e1a287d848c66a1d8e0ec76e6ddd4827c8ec6ee69abbe22f232d3ea90ba621c9e858e6db45cd6a79a34be2804ca1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
