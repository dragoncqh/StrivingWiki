<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="zh-cn"><head><meta charset="UTF-8"><meta name="copyright" content="(C) 版权 2024"><meta name="generator" content="DITA-OT"><meta name="description" content=""><title>JSP语法基础</title><link rel="stylesheet" type="text/css" href="../../commonltr.css">
<link rel="stylesheet" type="text/css" href="../../common-extended.css"></head><body id="JSP语法基础-3508F376"><main role="main"><article role="article" aria-labelledby="ariaid-title1">
<h1 class="title topictitle1" id="ariaid-title1">JSP语法基础</h1>


<div class="body conbody"><p class="shortdesc"></p>
<p class="p">概述</p>
<p class="p">一个JSP页面可以被分为以下几部份：静态数据(如&nbsp;HTML),JSP指令,JSP脚本标记和变量,JSP 动作,用户自定义标签</p>
<p class="p">数据类型</p>
<p class="p">Java语言是一种严格的“类型化”语言。这意味着每个变量都必须有一个声明好的类型。Java语言提供了八种基本类型。四个整数型(没有小数部分的数字，负数是允许的)，两个浮点型(含有小数部分的数字)，一种字符类型，还有一种布尔型。对应的类类型是：Integer、Float、Boolean、Character、Double、Short、Byte、LongJava。另外还提供大数字对象，但它不是Java的数据类型。那么数字类型有六种,当这些数字遇到取值范围错误时，会发生（上溢Overflow）；而在遇到象被零除时，会发生下溢（Underflow）。</p>
<table class="table"><caption></caption><colgroup><col><col><col><col><col><col><col><col></colgroup><tbody class="tbody">
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">类型</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">长度</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">数值范围</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">说明</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">byte</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">1个字节</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">-128到127</p></td>
<td class="entry" rowspan="1" colspan="2"></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">short</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">2个字节</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">-32,768到32,767</p></td>
<td class="entry" rowspan="1" colspan="2"></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">int</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">4个字节</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">-2,147,483,648到2,147,483,647</p></td>
<td class="entry" rowspan="1" colspan="2"></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">long</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">8个字节</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">-9,223,372,036,854,775,808L到9,223,372,036,854,775,807L</p></td>
<td class="entry" rowspan="1" colspan="2"></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">float</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">4个字节</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">约+—3.40282347E+38F（6~7个有效的十进制数位）</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">单精度float类型的数值有个后缀F，如果没有后缀F，那么默认为double</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">double</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">8个字节</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">约+-1.79769313486231570E+308（15个有效数位）</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">双精度double类型的数值也可以使用后缀D。</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">char</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">2个字节</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">unicode字符'\u0000'到'\uFFFF'</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">单引号用来表示char常量,
双引号则表示一个字串，他是Java的一个对象，并不是数据类型。</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">boolean</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">1个字节</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">布尔类型只有两个值:false和true</p></td>
<td class="entry" rowspan="1" colspan="2"></td>
</tr>
</tbody></table>
<p class="p">1, 字符类型说明：</p>
<p class="p">A, char类型表示Unicode编码方案中的字符。 　　Unicode可同时包含65536个字符，ASCII/ANSI只包含255个字符，实际上是Unicode的一个子集。Unicode字符通常用十六进制编码方案表示，范围在'\u0000'到'\uFFFF'之间。\u0000到\u00FF表示ASCII/ANSI字符。\u表示这是一个
Unicode值。</p>
<p class="p">B, 在Java中除了用这个\u的形式来表示字符外，还可以使用换码序列来表示特殊字符。</p>
<table class="table"><caption></caption><colgroup><col><col><col><col><col><col></colgroup><tbody class="tbody">
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">\b</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">退格</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">\u0008</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">\t</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">Tab制表</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">\u0009</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">\n</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">换行</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">\u000a</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">\r</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">硬回车</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">\u000d</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">\”</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">双引号</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">\u0022</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">\'</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">单引号</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">\u0027</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">\</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">反斜杠</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">\u005c</p></td>
</tr>
</tbody></table>
<p class="p">C, 理论上在Java的应用程序和小应用程序中使用Unicode字符，但至于他们是否能真正显示出来，却要取决于使用的浏览器和操作系统，其中操作系统是最根本的。</p>
<p class="p">2, 数据类型转换：</p>
<p class="p">A, 转换原则: 从低精度向高精度转换byte 、short、int、long、float、double、char 注：两个char型运算时，自动转换为int型；当char与别的类型运算时，也会先自动转换为int型的，再做其它类型的自动转换</p>
<p class="p">B，基本类型向类类型转换</p>
<p class="p">正向转换：通过类包装器来new出一个新的类类型的变量 Integer a= new Integer(2);</p>
<p class="p">反向转换：通过类包装器来转换 int b=a.intValue();</p>
<p class="p">C，类类型向字符串转换</p>
<p class="p">正向转换：因为每个类都是object类的子类，而所有的object类都有一个toString()函数，所以通过toString()函数来转换即可</p>
<p class="p">反向转换：通过类包装器new出一个新的类类型的变量</p>
<p class="p">例1-6说明：先把该字符串转化成新的类类型对象，再调用新对象的方法返回数值。 例1: int i=Integer.valueOf(“123”).intValue()
例2: float f=Float.valueOf(“123”).floatValue() 例3: boolean b=Boolean.valueOf(“123”).booleanValue()
例4: double d=Double.valueOf(“123”).doubleValue() 例5: long l=Long.valueOf(“123”).longValue()
例6: char=Character.valueOf(“123”).charValue()</p>
<p class="p">D，基本类型向字符串的转换</p>
<p class="p">正向转换：</p>
<p class="p">如：int a=12; String b; b=a+””;</p>
<p class="p">反向转换：通过类包装器</p>
<p class="p">例1:int i=Integer.parseInt(“123”) 例1说明：此方法只能适用于字符串转化成整型变量 例2-6说明：先将字符串转化成新类类型对象，再调用该对象的方法返回其数值。
例2: float f=Float.valueOf(“123”).floatValue() 例3: boolean b=Boolean.valueOf(“123”).booleanValue()
例4:double d=Double.valueOf(“123”).doubleValue() 例5: long l=Long.valueOf(“123”).longValue()
例6: char=Character.valueOf(“123”).charValue()</p>
<p class="p">JSP基本编译指令</p>
<p class="p">Jsp的指令控制JSP编译器如何去生成 servlet</p>
<p class="p">1, page指令（&lt;%@page … %&gt; 11个属性）:</p>
<table class="table"><caption></caption><colgroup><col><col><col><col><col><col><col><col></colgroup><tbody class="tbody">
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">属性</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">格式</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">作用</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">说明</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">language</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">[language=“Java”]</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">指明脚本代码将要用到的语言</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">指明采用java语言语法</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">import</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">[import=“package.class│package.*},…”]</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">导入包,引用包中的类</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">有几个包(java.lang.*;
javax.servlet.*; javax.servlet.jsp*; javax.servlet.http.* )是默认自动导入的，不需要显式表示</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">session</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">[session=“true│false”]</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">设定这个JSP程序是否需要HTTP
session</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">缺省情况下session的值为true</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">errorPage</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">[errorPage=“relativeURL”]</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">指定程序来处理当前错误</p></td>
<td class="entry" rowspan="1" colspan="2"></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">isErrorPage</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">[isErrorPage=“true│false”]</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">指明了当前程序是否为另一程序的异常处理程序。</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">不会改变异常处理导向，但设置为否则无法使用该异常的对象exception。</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">contentType</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">[contentType=“mimeType　[;charset=characterSet]“　│”text/html;charset=ISO8859.1”]</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">指定了最先传送给客户端的MIME类型和字符编码方式</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">MIME类型默认为
text/html。字符编码方式默认为ISO8859-1</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">isThreadSafe</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">[isThreadSafe=“true│false”]</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">表示生成的servlet
是否安全线程</p></td>
<td class="entry" rowspan="1" colspan="2"></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">extends</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">[extends=“package.class”]</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">标明该JSP程序编译时所产生的Java类需要继承的class或者需要实现的interface的全名</p></td>
<td class="entry" rowspan="1" colspan="2"></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">buffer</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">[buffer=“none│8kb│size
kb”]</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">指定输出缓冲区的大小。</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">输出缓冲区被JSP内部对象－Out对象（out）用于缓存执行的JSP程序对客户浏览器的输出，缺省值式8kb，可以设置为none，也可以设置为其他的值，单位为kb</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">autoFlush</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">[autoFlush=“true│false”]</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">指定如果输出缓冲区溢出时是否需要强制输出缓冲区的内容。设为true时为正常。设置为false时，会在buffer溢出时产生一个Exception。</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">　</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">info</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">[info=“text”]</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">设置该JSP程序的说明信息</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">可以通过servletContext.getServletInfo()方法取回</p></td>
</tr>
</tbody></table>
<p class="p">mimeType: text/html ,text/plain, image/gif, image/jpeg</p>
<p class="p">&lt;%@ page import=”java.util.*,java.lang.*”%&gt;//要import载入多个包 可以用一个import指明多个包，用逗号隔开
也可用多个分号隔开的import分别指用，但不主张这样不规范的使用。 &lt;%@ page import=”java.util.*”;
@ page import=” java.lang.*”%&gt;</p>
<p class="p">&lt;%@ page session=”true”%&gt;// session属性 &lt;% if(session.getValue(“name”)==null)
session.putValue(“name”,”123456”); else session.putValue(“name”,session.getValue(“name”)+”1”);
%&gt; &lt;% out.println(session.getValue(“name”));%&gt;若session=”false”，则会出现编译错。</p>
<p class="p">test.jsp: &lt;%@page errorPage=”errorPage.jsp”@&gt; // errorPage属性
&lt;%!int i=0;%&gt; &lt;%=7/i%&gt; errorPage.jsp: &lt;%@page isErrorPage=”true”@&gt;
&lt;%=exception%&gt; //运行test.jsp, 将会产生该异常的一个可使用的对象exception,将会看到被0除的错误信息。
 //将上例isErrorPage属性的true改为false, 使用exception程序将会在编译时出错。 Error:500
Unable to compile class for JSP</p>
<p class="p">2, include指令:&lt;%@ include file=”include.inc”%&gt;,通知JSP编译器在编译时把另外一个文件(扩展名一般为.jspf,即
JSP Fragment，JSP碎片)嵌入到当前文件中。被包含文件也可能是静态html文件、jsp文件或其它文本文件。因为被包含是在编译时才插入的，所以在修改了被包含文件之后，如果不对原JSP页面做修改，JSP引擎根据原JSP页面判断未改动则直接执行已存在的字节码而不重新编译，这样就忽略了对被包含文件的修改。</p>
<p class="p">native.jsp: &lt;body&gt; native file start here.&lt;br&gt; &lt;%@ include
file=”include.inc”%&gt; native file end here.&lt;br&gt; &lt;/body&gt; include.inc:
include file start here.&lt;br&gt; &lt;%! String str=”Here is include’s
context!”;%&gt; &lt;% out.pringln(str+”&lt;br&gt;”);%&gt; include file end
here.&lt;br&gt; 运行native.jsp，结果如下： native file start here. include file
start here. Here is include’s context! include file end here. native
file end here.</p>
<p class="p">3, 标签库指令taglib:描述了要使用的JSP标签库。前缀prefix和C++的命名空间很类似,标签库的描述URI:</p>
<p class="p">&lt;%@ taglib prefix=“myprefix” uri=“taglib/mytag.tld” %&gt;</p>
<p class="p">JSP脚本标记</p>
<p class="p">JSP脚本就是用page指令language属性指定的脚本语言编写的代码块，需要用JSP完成的功 能主要在此实现。目前用的基本是Java语言。代码块里必须完全符合Java语法，但可以配合用HTML文本。其实不论是什么，都会被转换为Servlet,在Servlet中它们是一样的。有三个基本的脚本标记，作用是使JAVA代码可以直接插入servlet:</p>
<p class="p">1, 声明变量标记:在JAVA SERVLET的类体中放入一个变量的定义。静态的数据成员也可以如此定义。 &lt;%! int
serverInstanceVariable = 1; %&gt;声明一个整形变量，并赋初值1 2, 声明方法标记：&lt;%! int
show(int val){ {return val;} %&gt; 3, 脚本标记，在JAVA SERVLET的类的_jspService()方法中放入所包含的语句。
&lt;% int localStackBasedVariable = 1; out.println(localStackBasedVariable);
%&gt; 4, 输出表达式标记，在JAVA SERVLET的类中放入待赋值的表达式，表达式注意不能以分号结尾，且其中变量必须已声明。 &lt;%=
“expanded inline data ” + 1 %&gt;编译时会直接输出表达式的值，相当于asp中的&lt;%=%&gt;</p>
<p class="p">5, 注释符标记：</p>
<p class="p">&lt;%--Here are comments--%&gt;表示是Jsp注释，在服务器端将被忽略， 也不转化为HTML的注释，在客户端查看源码时是看不到的。</p>
<p class="p">普通的jsp语句： &lt;% for(int i=0,i&lt;10,i++)//jsp的正文部分 out.println(i+”&lt;br&gt;”);
%&gt;  如：先输出5个空行，再输出“hello” 正确的：&lt;% for(int i=0;i&lt;5;i++)%&gt; &lt;br&gt;
&lt;%;%&gt; hello &lt;br&gt;错误的：（一行br；一行hello）=============== &lt;% for(int
i=0;i&lt;5;i++)%&gt; &lt;br&gt; hello 错误的等价于：&lt;% for(int i=0;i&lt;5;i++){%&gt;
&lt;br&gt; hello &lt;%}%&gt;</p>
<p class="p">JSP动作</p>
<p class="p">JSP动作(JSP操作指令)是一系列可以调用内建于网络服务器中的功能的XML标签。JSP动作不同于JSP编译指令，是在客户端请求时期动态被执行的</p>
<p class="p">1, 基本动作（&lt;%jsp:…%&gt;）</p>
<table class="table"><caption></caption><colgroup><col><col><col><col><col><col><col><col><col><col><col></colgroup><tbody class="tbody">
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">动作</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">格式</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">作用</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">说明</p></td>
<td class="entry" rowspan="1" colspan="1"></td>
<td class="entry" rowspan="1" colspan="1"></td>
<td class="entry" rowspan="1" colspan="1"></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">include</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">&lt;jsp:include
page=”{relativeURL│&lt;%=expression%&gt;}” flush=“true”/&gt;</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">向当前页面加入(包含)另一文件</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">和子过程类似，处理完就把控制权交还当前页</p></td>
<td class="entry" rowspan="1" colspan="1"></td>
<td class="entry" rowspan="1" colspan="1"></td>
<td class="entry" rowspan="1" colspan="1"></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">forward</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">&lt;jsp:forward
page=”relativefileURL</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">&lt;%=expression%&gt;}”/&gt;</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">把当前页面重导到另一页面上</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">在转向之前如对客户端有任何输出则出错。控制权永不交还给当前页。</p></td>
<td class="entry" rowspan="1" colspan="1"></td>
<td class="entry" rowspan="1" colspan="1"></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">useBean</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">&lt;jsp:useBean
id=“name” scope=“page</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">request</p></td>
<td class="entry" rowspan="1" colspan="1"><p class="p">session</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">application”
typeSpec&gt; body &lt;/jsp:useBean&gt;</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">生成一个具有一定生存范围以及一个唯一id的JavaBean组件的实例</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">Id/ scope值不能重名，否则JSP引擎只取首个。Package必须在对应类中指定</p></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">getProperty</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">&lt;jsp:getProperty
name=”beanId” property=”propertyName” /&gt;</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">用来返回一个已被创建的bean组件的属性值</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">name：对应着用useBean创建bean组件时id的值,property：指明要得到哪个属性的值</p></td>
<td class="entry" rowspan="1" colspan="1"></td>
<td class="entry" rowspan="1" colspan="1"></td>
<td class="entry" rowspan="1" colspan="1"></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">setProperty</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">&lt;jsp:setProperty
name=”beanId” last_syntax /&gt;</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">用来设定一个已被创建的bean组件的属性值</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">name：对应着用useBean创建bean组件时id的值,property：指明要想设定属性值的属性名,value：为设定的属性值</p></td>
<td class="entry" rowspan="1" colspan="1"></td>
<td class="entry" rowspan="1" colspan="1"></td>
<td class="entry" rowspan="1" colspan="1"></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">param</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">jsp:param</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">指定一个将加入请求的当前参数组中的参数。</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">可以在jsp:include,
jsp:forward 或 jsp:params块之间使用。</p></td>
<td class="entry" rowspan="1" colspan="1"></td>
<td class="entry" rowspan="1" colspan="1"></td>
<td class="entry" rowspan="1" colspan="1"></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">:plugin</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">jsp:plugin</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">产生为嵌入一个APPLET所需要的指定浏览器标签。动态地下载服务器端的JavaBean或者Java
Applet程序到客户端的浏览器上执行,如果需要的话还要下载一个Java插件</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">Netscape
Navigator 的老版本和 Internet Explorer 使用不同的标签以嵌入一个applet。</p></td>
<td class="entry" rowspan="1" colspan="1"></td>
<td class="entry" rowspan="1" colspan="1"></td>
<td class="entry" rowspan="1" colspan="1"></td>
</tr>
<tr class="row">
<td class="entry" rowspan="1" colspan="2"><p class="p">fallback</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">jsp:fallback</p></td>
<td class="entry" rowspan="1" colspan="2"><p class="p">如果浏览器不支持APPLETS则会显示的内容。</p></td>
<td class="entry" rowspan="1" colspan="2"></td>
<td class="entry" rowspan="1" colspan="1"></td>
<td class="entry" rowspan="1" colspan="1"></td>
<td class="entry" rowspan="1" colspan="1"></td>
</tr>
</tbody></table>
<p class="p">//include 动作表示在当前页面插入另一个文件another.jsp的内容 flush指定是否将被包含的文件的执行结果输出到客户端，
在JSP1.1规范中flush="false"是不允许的 &lt;jsp:include page="scripts/login.jsp"
flush="True" &gt;        &lt;jsp:param name="username" value="grin"/&gt;
&lt;/jsp:include&gt;  name:&lt;%=request.getParameter("username")%&gt; 
&lt;body&gt; here is aa. &lt;jsp:forward page=”aa.jsp” /&gt; //forward动作
here is bb. &lt;/body&gt;</p>
<p class="p">2, useBean动作的说明：</p>
<p class="p">&lt;jsp:useBean id=“name” scope=“page|request|session|application”
typeSpec&gt; body &lt;/jsp:useBean&gt;</p>
<p class="p">其中，typeSpec定义如下 typeSpec ::=class=“className”</p>
<table class="table"><caption></caption><tbody class="tbody">
<tr class="row">
<td class="entry"></td>
</tr>
<tr class="row">
<td class="entry"></td>
</tr>
<tr class="row">
<td class="entry"></td>
</tr>
<tr class="row">
<td class="entry"></td>
</tr>
<tr class="row">
<td class="entry"></td>
</tr>
</tbody></table>
<p class="p">Scope说明：</p>
<p class="p">page: bean的缺省使用范围。该属性只是当前页中有效。</p>
<p class="p">request:该属性在请求的生命周期内有效，一旦请求被所有的JSP页处理完后，那么该属性就不可引用。作用于任何相同请求的JSP文件中，直到页面执行完毕向客户端发回响应或在此这之前
已通过某种方式（如重定向、链接等方式）转到另一个文件为止。还可通过使用Request对象访问 bean,如request.getAttribute(beanName)</p>
<p class="p">session:作用于整个用户会话session的生存周期内有效，在session的生存周期内，对此bean属性的任何改动，都会影响到在此session内的另一page、另一request里对此bean的调用。但必须在创建此bean的文件里事先用page指令指定了session=true。</p>
<p class="p">application:该属性在各种情况下都有效，并且永远不会被变为不可引用，和全局变量<a class="xref" href="http://www.deepcast.net/wiki/global_variable" target="_blank" rel="external noopener"><strong class="ph b">global variable</strong></a>相同。作用于整个application的生存周期内，在application周期内，对此bean属性的任何改动，都会影响到此application内另一page、另一request以及另一session里对此bean的调用。</p>
<p class="p">详细说明： &lt;jsp:useBean id=”beanIDName” //useBean动作,定义生成bean组件的名字，不能重名,
否则JSP引擎将认定最先被创建的那个。(scope的值也最好一样) 在执行过程中，首先会尝试寻找已经存在的具有相同id和scope值的JavaBean实例，
如果没有就会自动创建一个新的实例。 scope="page|request|session|application|" //定义bean的有效活动(引用)范围，即生存时间
class=”package.class” type="package.class" //用class属性指定的类示例一个bean,
其中package名必须是类里用关键字package指定的。特别注意大小写要完全一致 beanName="{package.class|&lt;%=expression%&gt;}
 //代表了Bean的名字，通常通过java.beans.Beans class的 tantiate() 方法来初始化。 type="package.class""&gt;
//Type属性指定了脚本变量定义的类型，一般采用默认其与class中的属性一致，  action for bean &lt;/jsp:useBean&gt;
 如：tt.jsp  &lt;jsp:useBean id=”student” scope=”page” class=”mime.student”
/&gt; 注： scope=”page”时，运行test.jsp文件，name的初始值为”aaaa”。 虽然在jsp文件中又重设为“wll”，但刷新后仍为“aaaa”
 scope=”session”时，运行test.jsp文件，name的初始值为”aaaa”。 虽然在jsp文件中又重设为“wll”，但刷新后仍为“wll”,
只要不关闭此窗口，任何刷新或打开一个新窗口，都输出“wll”。 直到关闭所有窗口，再运行test.jsp文件，输出才会为初始值”aaaa”。
 scope=”application”时，运行test.jsp文件，name的初始值为”aaaa”。 虽然在jsp文件中又重设为“wll”，但刷新后仍为“wll”,
只要不关闭此窗口，任何刷新或打开一个新窗口，都输出“wll”。 即使关闭所有窗口，再运行test.jsp文件，输出仍为 “wll”。
除非关闭服务后又重启，再运行test.jsp文件，name的输出为初始值”aaaa”。  scope=”request”时，新建一文件test1.jsp内容与test.jsp一样。
先在浏览器中运行test.jsp文件，输出name的值为初始值”aaaa”。 再在在浏览器中运行test1.jsp文件，此时输出为“wll”，因为它们算是相同的request。
 &lt;%=student.getName()%&gt;&lt;br&gt; &lt;% student.setName(“wll”); %&gt;
student.java package mine; public class student{ long classno; String
name; int age; Boolean sex; public student(){     classno=12345; 
   name=”aaaa”;     age=21;     sex=true; } public long getClassno(){
    return classno; } public void setClassno(long no){     this.classno=no;
} public String getName(){     return name; } public void setName(String
name){     this.name=name; } public int getAge(){     return age;
} public void setAge(int age){     this.age=age; } public boolean
getSex(){     return sex; } public void setSex(Boolean sex){     this.sex=sex;
} }</p>
<p class="p"> &lt;jsp:useBean id="myBean" class="com.foo.MyBean" scope="request"
/&gt;  &lt;jsp:getProperty name="myBean" property="lastChanged" /&gt;  &lt;jsp:setProperty
name="myBean" property="lastChanged" value="&lt;%= new Date()%&gt;" /&gt;</p>
<p class="p">上述例子将会用一个创建一个类的实例，并且把该实例存储在属性中，该属性将在该请求的生命周期内有效。它可以在所有被包含或者从主页面(最先接收请求的页面)转向到的JSP页之间共享。</p>
<p class="p">3, getProperty动作,如：得到前例中student组件的属性值：</p>
<p class="p">&lt;jsp:getProperty name=”student” property=”classno” /&gt;//等价：&lt;%=student.classno
%&gt; &lt;jsp:getProperty name=”student” property=”name” /&gt; &lt;jsp:getProperty
name=”student” property=”age” /&gt;  输出结果为： 12345 aaaa 21</p>
<p class="p">4,setProperty 动作,如：前例中student组件，在setProperty中设定的属性</p>
<p class="p">&lt;jsp:setProperty name=“beanName” last_syntax /&gt; //Name代表通过&lt;jsp:useBean&gt;
标签定义的JavaBean对象实例。  last_syntax代表的语法如下：  property=“*”  //注意，程序会反复的查找当前的ServletRequest所有参数，
并且匹配JavaBean中相同名字的属性property， 并通过JavaBean中属性的set方法赋值value给这个属性。 如果value属性为空，则不会修改Javabean中的属性值。
 这说明如果表单数据的属性名和JavaBean的属性名相同 那么JavaBean的相应属性将会被自动赋值  |property=“propertyName”
//代表了你想设置值的属性property名字。 |property=“propertyName” param=“parameterName”
  //Param属性代表了页面请求的参数名字，&lt;jsp:setProperty&gt;标签不能同时使用param和value。 
|property=“propertyName” value=“propertyValue” //Value属性代表了赋给Bean的属性property的具体值。</p>
<p class="p">property=”propertyName” value=”propertyValue”</p>
<p class="p">&lt;jsp:setProperty name=”student” property=”classno” value=”56789”
/&gt;// &lt;jsp:setProperty name=”student” property=”name” value=”bbbb”
/&gt; &lt;jsp:setProperty name=”student” property=”age” value=”33” /&gt;等价：&lt;%
student.age=33;%&gt;  输出结果为： 56789 bbbb 33</p>
<p class="p">5,plugin语法形式：</p>
<p class="p">&lt;jsp:plugin        type="bean│applet" //指定被执行的java程序的类型    
   code="classFileName" //指定被执行的文件名，该文件必须以".class"扩展名结尾        codebase="classFileDiretoryName"
//指定被执行文件所在的目录        [name="instanceName"] //给该程序取一个名字用来标志该程序   
    [archive="URLtoArchive"] //指向一些要预先载入的将要使用到的类的路径        [align="bottom│top│middle│left│right"]
       [heigh="displayPixels"]        [width="displayPixels"]    
   [hspace="leftRightPixels"] //显示时，左右的留白        [vspace="topBottomPiexels"]//显示时，上下的留白
       [jreversion="JREVersionNumber│1.2"] //能正确运行所需JRE版本，缺省是1.2 
      [nspluginurl="URLToPlugin"] //Netscape Navigator能使用的JRE的下载地址
       [iepluginurl="URLToPlugin"]&gt; //Internet Exploer能使用的JRE的下载地址
        [&lt;jsp:parames&gt;            [jsp:param name="parameterName"
value="parameterValue"/&gt;]        &lt;/jsp:params&gt;]        [&lt;jsp:fallback&gt;text
message for user that can no see the plugin        &lt;/jsp:fallback&gt;
] //用于不能显示时的说明信息        &lt;/jsp:plugin&gt; 例子 &lt;jsp:plugin type="applet"
code="MyPlugin.class" codebase="/classes"&gt;    &lt;jsp:params&gt;    
   &lt;jsp:param name="myPlugin" value="Greetings"/&gt;    &lt;/jsp:params&gt;
   &lt;jsp:fallback&gt;        &lt;p&gt;unable to load plugin&lt;/p&gt;   
&lt;/jsp:fallback&gt; &lt;/jsp:plugin&gt; 例子： &lt;jsp:plugin    type="applet"
   code="clock2.class"    codebase="/examples/jsp/plugin/applet" 
  jreversion="1.2"    width="160"    hight="150"&gt;    &lt;jsp:fallback&gt;
       plugin tag DBJECT or EMBED not supported by browser    &lt;/jsp:fallback&gt;
&lt;/jsp:plugin&gt;  例子：  &lt;jsp:plugin type=applet height="100%" width="100%"
             archive="myjarfile.jar,myotherjar.jar"              codebase="/applets"
             code="com.foo.MyApplet" &gt;      &lt;jsp:params&gt;      
   &lt;jsp:param name="enableDebug" value="true" /&gt;      &lt;/jsp:params&gt;
     &lt;jsp:fallback&gt;          Your browser does not support applets.
     &lt;/jsp:fallback&gt;  &lt;/jsp:plugin&gt;</p>
<p class="p">上述&nbsp;<a class="xref" href="http://www.deepcast.net/wiki/plugin" target="_blank" rel="external noopener"><strong class="ph b">plugin</strong></a>&nbsp;例子说明了一种在网页中嵌入<a class="xref" href="http://www.deepcast.net/wiki/applet" target="_blank" rel="external noopener"><strong class="ph b">applet</strong></a>的统一方法。在&lt;OBJECT标签出现之前，并没有一种嵌入applets的通用方法。这个标签设计得并不好，但有希望在以后加入动态属性(height=“${param.height}”,
code=“${chart}“等)和动态参数的新功能。 目前jsp:plugin标签不允许动态调用 applets。例如，你如果有一个图表applet需要数据点以参数形式被传入，除非数据点的数量是一个常量，否则你就不能使用ResultSet
循环来创建jsp:param标签，你不得不手写每个jsp:param标签的代码。而每个上述jsp:param标签可以有一个动态命名和动态值。</p>
<p class="p">Java Bean组件</p>
<p class="p">1,JavaBean的概念:JavaBean是描述Java的软件组件模型，有点类似于Microsoft的COM组件概念。通过JavaBean可以无限扩充Java程序的功能，可以快速的生成新的应用程序。可以实现代码的重复利用，可以很好地实现业务逻辑和前台程序(如jsp文件)的分离，使得系统具有更好的健壮性和灵活性。可以在任何地方(应用程序、其它组件、文档、web站点和应用程序构造器工具等)重用Java
Bean组件。它是一种独立于平台和结构的应用程序接口，它本身可以忽略内部的结构及细节问题，只需定义其外部的特征及对外功能就行,它有三种接口面可以独立对外进行开发，就是：属性、方法和事件。在JSP中创建用JavaBean编写的一个bean，实际上就是创建此类的一个对象。</p>
<p class="p">JavaBean传统的应用在于可视化（如AWT下的应用）的领域。而现在对于非可视化领域(封装事务逻辑、数据库操作等)尤其在服务器端应用方面，Jsp+Java
Bean的组合成为了一种事实上最常见的Jsp程序的标准。JavaBean通过Java虚拟机(Java Virtual Machine)可以得到正确的执行，运行JavaBean最小的需求是JDK1.1或者以上的版本。</p>
<p class="p">2,JavaBean的属性:JSP组件的属性有两种：单值属性、索引属性</p>
<p class="p">A, 单值属性：相当于平时编程中定义的一个成员变量，它只能有一个数据值，这个数据值的类型可以是Java中的任意数据类型，包括类和接口。</p>
<p class="p">如： int counter; float tax; String name; Date datetime; 注：布尔属性是一种特殊的单值属性，它只有两种允许的值：true、false</p>
<p class="p">B, 索引属性：相当于平时说的数组，当存放一批同类型的数据时，需要用到索引属性。</p>
<p class="p">如：int ID[]; String name[]; Float score[];</p>
<p class="p">3,JavaBean的方法:方法包括构造方法和访问方法。</p>
<p class="p">A, 构造方法：类似于类中的构造器（即对它及它的成员变量进行初始化），它的方法名要和此JavaBean的类相同。如：</p>
<p class="p">package student; public class student{ int counter; ind ID[]; String
name[]; float score[]; boolean whiszkid;      public student(){ ID=new
int[50]; name=new String[50]; score=new float[50]; counter=0; } }</p>
<p class="p">B, 访问方法：:就是对组件中定义的属性的访问，包括读和写（一般情况与在Java中定义和使用的方法差不多），注意如下方法的取名规则：</p>
<p class="p">读取一个属性：getXXX() 改写一个属性：setXXX()  访问单值属性：如对上面的counter单值属性，它的两个访问方法可以为：
 读取属性值： public int getCounter{ return counter; }  改写属性值： public void
setCounter(int counter){ this.counter=counter; }  访问布尔型的单值属性:对读取属性值采用isXXX()方法
如对上面的布尔型的属性whizkid的访问可以为： public boolean isWhizkid(){ return whizkid;
}  访问索引属性：有时要定义好几个访问方法，但它们的取名规则还是一样的， 如对上面的姓名属性，它的读取和改写方法需这样定义：  读取索引属性中的一个属性值：
public String getName(int index){ return name[index]; }  读取索引属性中的所有属性值：
public String[] getName(){ return name; }  改写索引属性中的一个属性值： public void
setName(int index,String str){ name[index]=str; }  改写索引属性中的所有属性值：
public void setName(String[] str){ name=str;; }</p>
<p class="p">4,JavaBeans和JSP的结合: 在JavaServer Pages中调用JavaBean有三个标准的标签，那就是&lt;jsp:useBean&gt;,
&lt;jsp:setProperty&gt;，以及&lt;jsp:getProperty&gt;。JavaServer Pages通过id.method类似的语句来操作JavaBean。</p>
<p class="p">JSP标签库</p>
<p class="p">除了JSP预定义动作之外，开发者还可以使用JSP标签扩展API添加他们自定义的动作。开发者写一种实现一个标签的界面和一个标签库的XML描述文件的JAVA类，这就能指定标签和实现标签的JAVA类</p>
<p class="p">请看如下JSP：   &lt;%@ taglib uri="mytaglib.tld" prefix="myprefix" %&gt;
  ...  &lt;myprefix:myaction&gt; &lt;%-- the start tag %&gt;   ...  &lt;/myprefix:myaction&gt;
&lt;%-- the end tag %&gt;  ...</p>
<p class="p">JSP编译器将会载入mytaglib.tld这个XML文件，然后可以看到标签myaction由JAVA类MyActionTag实现。当该标签首次在文件中使用时，将会创建一个MyActionTag的实例。然后(而且当每次该标签被使用时)，当出现开始标签时，将会调用doStartTag()方法，根据开始标签的结果，来决定如何处理标签的主体。主体是指开始标签和结束标签之间的文本。这个doStartTag()方法将会返回如下之一：</p>
<p class="p">SKIP_BODY - 标签之间不做处理。</p>
<p class="p">EVAL_BODY_INCLUDE - 对标签之内主体进行赋值。</p>
<p class="p">EVAL_BODY_TAG - 对标签之内主体进行赋值并把结果输出到流(保存在标签的主体内容属性中)。</p>
<p class="p">:'注意:' 如果标签扩展了 BodyTagSupport 类，当主体被执行时会在调用doEndTag()之前调用doAfterBody()方法。该方法用于实现循环结构。</p>
<p class="p">当结束标签出现时，它会调用doEndTag()方法，该方法会返回如下两做之一：</p>
<p class="p">EVAL_PAGE - 表示JSP文件的剩余部份将会被执行。this indicates that the rest of the
JSP file should be processed.</p>
<p class="p">SKIP_PAGE - 表示将不会再有更多执行操作。当前JSP页交出控制权。就象在转发动作中的作用一样。</p>
<p class="p">上述 myaction 标签tag 会有一个类似下面例子的用于实现的类：</p>
<p class="p"> public class MyActionTag extends  TagSupport {      //Releases
all instance variables.      public void release() {...}        public
MyActionTag() { ... }        //called for the start tag      public
int doStartTag() { ... }        //called at the end tag     }  Add
Body Tag description.</p>
<p class="p">JSP内部对象</p>
<p class="p">JSP自动定义了9个可以直接使用而不用说明的对象,可以把JSP内部对象看作是永远可用的标准脚本变量：out(JSPWriter用来写入响应流的数据
),applicatin,config,exception,page(servlet自身),pagecontext(一个PageContext?实例包括和整个页面相联系的数据，一个给定的HTML页面可以在多个JSP之间传递),request(HTTP&nbsp;request对象),response(HTTP&nbsp;response对象),session(HTTPsession对象，在多个请求之间追踪一个客户的信息)</p>
<p class="p">1, out: 一个Javax.servlet.jsp.JspWriter对象。主要用来向客户端输出各种格式的数据，并且管理服务器上的输出缓冲区,重要方法：</p>
<p class="p">out.print(类型) 或 out.println(类型)：换行输出  out.newLine()：输出一个换行符号  out.flush()：输出缓冲区的数据
 out.close()：关闭输出流  out.clearBuffer()：清除缓冲区里的数据，并把数据写到客户端  out.clear()：清除缓冲区里的数据，但不把数据写到客户端
 out.getBufferSize()：获得缓冲区的大小，缓冲区的大小可用&lt;%@page buffer=”size”%&gt;设置
 out.getRemaining()：获得缓冲区没有使用的空间的大小  out.isAutoFlush()：返回布尔值，若auto
flush则返回true，否则返回false。 是否auto fush我们可用%@page is AutoFlush=”true/false”%来设置</p>
<p class="p">2, request: javax.servlet.http.HttpServletRequest,关于输入请求的存储信息，包括表单变量。主要用于接受客户端通过http协议连接输入到服务器端的数据信息。方法：</p>
<p class="p">getCookies()：返回客户端的cookie对象，结果是一个cookie数组  getHeader(String name)：获得http协议定义的传送文件头信息，
如：request.getHeader(“User-agent”)返回客户端浏览器的版本号、类型  getAttribute(String
name)：返回name指定的属性值， 若不存在指定的属性，就返回空值(null)。  getattributeNames()：返回request对象所有属性的名字，
结果集是一个Enumeration（枚举）类的实例  getHeaderNames()：返回所有request header的名字，
结果集是一个Enumeration（枚举）类的实例  getHeaders(String name)：返回指定名字的request
header的所有值， 结果集是一个Enumeration（枚举）类的实例  getMethod()：获得客户端向服务器端传送数据的方法有GET、POST、PUT等类型
 getParameter(String name)：获得客户端传送给服务器端的参数值，该参数由name指定  get parameterNames()：获得客户端传送给服务器端的所有的参数名，
结果集是一个Enumeration（枚举）类的实例  getParameterValues(String name)：获得指定参数所有值
 getQueryString()获得查询字符串，该串由客户端以GET方法向服务器端传送  getRequestURI()：获得发出请求字符串的客户端地址
 getServletPath()：获得客户端所请求的脚本文件的文件路径  setAttribute(String name,Java.lang.Object
o)：设定名字为name的request参数值， 该值由Object类型的o指定  getServerName()：获得服务器的名字
 getServerPort()：获得服务器的端口号  getRemoteAddr()：获得客户端的IP地址  getRemoteHost()：获得客户端电脑的名字，若失败，则返回客户端电脑的IP地址
 getProtocol()：获取客户端向服务器端传送数据所依据的协议名称，如http/1.1</p>
<p class="p">3, application: javax.servlet.ServletContext,包括在特定的应用中的被所有servlet共享的数据。保存用户信息,一旦创建，除非服务器关闭，否则将一直保持下去</p>
<p class="p">application.setAttribute(“name”,val) request.setAttribute(“name”,val)
 方法： getAttribute(String name)： 返回由name指定名字的application对象属性的值，这是个Object对象
 getattributeNames()：返回所有application对象属性的名字， 结果集是一个Enumeration（枚举）类的实例
 getInitParameter(String name)：  返回application栽个属性的初始值，此属性由name指定
 getServerInfo()：获得当前版本Servlet编译器的信息  setAttribute(String name,Object
object)： 用object来初始化某个属性，该属性由name指定</p>
<p class="p">4, response:javax.servlet.http.HttpservletResponse,控制http连接关于响应的信息，方式是向客户端发送数据，如报头变量,cookies和内容类型等。方法：</p>
<p class="p">addCookie(Cookie cookie)：添加1个Cookie对象，用来保存客户端的用户信息。 用request的getcookies()方法可获得这个Cookie
如：&lt;% Cookie mycookie=new Cookie(“uname”,”wsr”); response.addCookie(mycookie);
Cookie delmycookie=new cookie(“mycookie”,null); delmycookie .setMaxAge(0);
delmycookie .setPath(/”); response.addCookie(delmycookie); %&gt;  addHeader(String
name,String value)：添加HTTP文件头，该header将会传到客户端， 若同名的header存在，原来的header会被覆盖
 containsHeader(String name)：判断指定名字的HTTP文件头是否存在并返回布尔值  sendError(int
sc)：向客户端发送错误信息， 如：505：服务器内部错误；404：网页找不到错误 如：response.sendError(response.SC_NO_CONTENT)；
 setHeader(String name,String value)： 设定指定名字的HTTP文件头的值，若该值存在，它将会被新值覆盖
 如1：让网页每隔5秒刷新一次 &lt;% response.setHeader(“Refresh”,”5”);%&gt; the current
date is:&lt;%=new Date()%&gt;  如2：利用response对象设定HTTP头 &lt;% response.setContentType(“Application/pdf”);
response.setHeader(“content-disposition”,”attachment;filename=\”syntax.pdf\””);
%&gt;  sendRedirect(“error.html”) //重定向功能</p>
<p class="p">5, exception: javax.lang.Throwable,是引起该错误页被调用的错误或者异常对象。处理JSP文件在执行时所有发生的错误和异常。注意,必须在&lt;%@
page isErrorPage=”true”%&gt;的情况下才可以使用Exception对象。有3个内建方法。</p>
<p class="p">getMessage()：返回错误信息  printStackTrace()：以标准错误的形式输出一个错误和错误的堆栈  toString()：以字符串的形式返回1个对异常的描述</p>
<p class="p">6, session:avax.servlet.http.HttpSession,包括与一个特定浏览器session相关的数据。分别保存每一个用户的信息,注意,session中保存和检索的信息不能是基本数据类型，而必须是JAVA的相应的Object对象。</p>
<p class="p">方法： session.putValue(“name”,val) session.getValue(“name”)  getAttribute(String
name)：获得指定名字的属性，若该属性不存在，将返回null  getattributeNames()：返回session对象中存储的第一个属性对象，
结果集是一个Enumeration类的实例  getCreationTime()：返回该session对象创建的时间，以毫秒计，从1970年1月1日起
 getId()：每生成一个session对象，服务器都会给其一个不会重复的编号， 此方法返回当前session的编号  getLastAccessedTime()：返回当前session对象最后1次被操作的时间，
返回自1970年1月1日起至今的毫秒数  getMaxInactiveInterval()：获得session对象的生存时间  removeAttribute(String
name)：删除指定的属性（包括属性名、属性值）  setAttribute(String name,Java.lang.Object
value)：设定指定名字的属性值， 并将其存储在session对象中</p>
<p class="p">7,config:javax.servlet.ServletConfig,该JSP的配置信息</p>
<p class="p">9, page:java.lang.object,当前的Java Server Page。在Java中，这和this变量一样。</p>
<p class="p">10, pageContext:javax.servlet.jsp.PageContext,包括了JSP可能需要的对大多数对象的引用，页有类似于include和forward的功能</p>
<p class="p">参考</p>
<p class="p"><a class="xref" href="http://bbs.blueidea.com/viewthread.php?tid=1012450&amp;page=" target="_blank" rel="external noopener">JSP-循序渐进教程</a></p>
<p class="p"><a class="xref" href="http://www.softhouse.com.cn/news/show/20202.html" target="_blank" rel="external noopener">Jsp ＋ JavaBean循序渐进教程</a></p>
<p class="p"><a class="xref" href="http://dev.csdn.net/develop/article/14/14098.shtm" target="_blank" rel="external noopener">JSP自学笔记</a></p>
</div>
<nav role="navigation" class="related-links"><div class="familylinks"><div class="parentlink"><strong>父主题：</strong> <a class="link" href="JSP.html">JSP</a></div></div></nav></article></main></body></html>