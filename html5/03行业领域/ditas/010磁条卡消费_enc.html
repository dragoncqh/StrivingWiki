<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bbaa2c4a2a039cffe257b92a51e5532205813b3f027e444b6fb783357ad1bd87d510ef12d0c5355f503333115fc69b50343367ee6f1c7c457d723c7ae6940aadd3d8c1431a04b598832190a362721399ae0b30750b4f2f7602718f01214f6f6a51b16f804d079fd5799bde3a82ccdcb1ebd6903a8bce47c55bd18f5b07877b89bb45bf97d58441e0bc2330b34b98d507ff86f028e0aa65c8283625b40aeaeb73b3120c8a16c44064b44345ccd26220f5998f805be97acee13c6a91047263121d825b80abc38c97061d9023463e7c06c9f8c9f6e198c6bc8a95260ec64394d6f917ab4927a3b6e31b98fe4d388bc3b1dc2c348be6bddb581878804dff898750dd2f89b4c8ed640c6577af46ebe130dbbb800c4618a303e962f294c2e70adf521fc2eab70e548bafb0773f39ebc6bf970322173479a94d145b2095f274cac1f985dd435cf8e2e86e8ac7d531a5eef51161a1404d9687aff2d00c8b72579e1cd4005dafbb101bb398467cb3617d8e4e652cda3f6152d979aacc1e21b178737023768e96defdc72cca1e115e23397a10904f200d3df7f1f035f5877d15c4297b1d15ccc9c069a2b66aab0c8bc7762d7a857af9c05033d06ce049786ee0934365e318a783e54e2237fa863101997d08245b9758983c1fe7e4b314965ff60bffd475576afbf0990ba458944798302596dfb873f4170e81f4850ffe578130c4a57a1c741cb2454c56e1762bb4d6b7c58882c33179a22c38408eb06dbe18cc1a42ed2d73092efa3bf3cdfe88715bfed5fd66cbf6f7bdea60db293a55ea05f0589a5121869ef00844ba07686184f4b40ace612250114251130656ea960ed960b114af2b28e63870de004d87578b97fd8dda068fe0cc8d06abb7faff766c44b6a49a5274b3eb6bb3b616166dbc3e635eb9e80c36eb9ea1bf6c19cb652a08190a9c8203627574b7f82cd34e76e1f55fbcb48f5fc72c2540502a92f73272f74c85f0a8c2e33d7c4f4f8800894d28f132b936195ae60c172dc20f9fa3ba454062f2da2bd08aa9e03ccd5daddf7a7e79beaed82adb024afc422f0d8e1d25409da164f48a1e45f204ce3646b7fe87eaac0b34f7d08b84b77017609a9d5066ffc99fc5ce71016dd38bdc293577cf14c85adf0368e314eacf1c4e3096e087bfd54d9c6cab8bbbc05b64c7f92ba229765938cdf2c282934e482f1f9ada086bc157f383b4eefd6d88bf6f65fbe90a3447e6f6508c4b9c174f6dc488c6be00bd78e044d27f95495249b11783ca4e205f453231385fe1b4e9bd8808266a7ae8f64c56b5f8a11f0d10c07e47dac8e2f9a13cf07d05d61eba76b6d8dc4f81eb96a299c01fe1fcae4ebddfb85ffbbea1dd03b7cd78153a6bc44b7e9fa972c817a88e73e42a26e37e1f3dc8185c69835358263f6683862cb7d3d593baf910e1051cd78a79f6102ce3193742f9d382dcafb53e57890fe197303a1e532eda01e3a0b6066d9aa5478baebd50dc0129e1d034dc3d0cfac061e86f3c76b9c018d6c8c84ec6c3362e67610ec112c32d6377ce1c4070534cdf05cfcff628ab0ee039d8521c6ede6d249d29f55d33cb8a1ad574b90505ffaf1f5a34af981e77ddd7b850dcf12f1e51b123b4bd082f6bff69fe134576ae0b694eba894b2b605fcb5b677ccd072a706f5125d766f80896cb801b7c1e723c9b13e151f46356e3ebce2d992dbb54c3b1675649b7f16c659a59b45244759654c31eb203fa2188ad3ea518416b843d443bbe476824c096bfe8bac06e50ccefc700c552fba1fbbb37a97511597d6e3c8b9cfaad772ba715c546e7a28d7c23dd14c3cefc3215e272131886724f655163539955c2ca29d4faa79081f1c1986610c9aa43b8036380d214cdd88e3ce7aff52a5b7985012f631550eb514360f9eabb2358cc1a321c8f20470dd00e04cd48a9b1ca5fc96fbb1bdd62f5094afaa6a73ce93ad09dde3c2d8ccdd7edf5ee39557f48400b2a53ed1d726358e85e62be85f39aa2ec29693e13a084b4646a103c996aaad23c02968b834c14a3e5005ca49f470ab3eeac4eb5c8321681ce09733ee5e77c5113867849a1016c3beeb4af7d90adabdbbe0402e32c09f770523eba4f19b391ebd0adf6a97ccbf53d01d40d233099051ac59ccb3bc33959f700e610aa5079be73b6464e5d649632352c2db1415223738a06b57d1c8d5d10887b47747fdc9ccedeacdba6dc858d6e5c1b1971689eaf5dc8f5681d5b20dc1431576bed51b9edc89d05adca535eeaf2d2e406e5ba69c26479d1ed5cfe39d2614916604b766a3b4dd6084760f34b2b9c76a57397b05988f1461ac066b668d886792387a74b61eccc21c6d6e984e12959a9a6d19ab045a9b3fc3d54feda6859ec2e14be8899d9c23a5909b229f3d15579f3985333f3fccb69026fc98b7d555d382cf5513180b25525a919f184cbfe85a76236d04561c923e5019f85217cc3624fa9540e3cdafcce537e22698be12da9a8a1762c6240a7652935e3705ae10a65ce19d2e4a6f9ee5af73390c6ccc488827b625e0621c4c29ba55fe66d469b2a9e45c50ba06ac489d77dae510b8a8957e06379b3c453cf123448e7cd22448fe3a7a56b8b96299cabdff9fc30f05ebd060ef922a1d715f6fa79b2d4f9ab1fa68c42c82b4b5567c472ecda88d9824a00b5c9281479c5a7e4a40a1635d47d52f1daac8dfdce8c8fe25f245d0bcfbf27e47ef2dfa7425c43dfb419f5c3e8a2f05b98e30bd62776a5c146c0bfa6c40bfae52f67580e056dff7da194d4127288dda6c04b466c14bd50ee3fb57d53d5ddf248d9d893befb95eb3af305cc2d9d892834fa5615e9cf4a940c046ec4e5c31581ac196a00fa9a15e7d1126e07cf6141394e45e8e4d726ff6c82d7dab8cf4669c5dc39970691e3bca7b9ad40968099c2bfc48059f9f056b911d0238521a281190b3b9d902ef6c519f009c4fd097dead7798c2a96d460fb1767ece80925bc84bd0a9ca137c3c87643ac2af9b4453d6ee95ce0d61e5c37c94c4ce93245cc2ef87273622940de4f5a04fd66951b7d8f20c01d57a9cbebf2f968e1ec3a2f9b6188a844a0ffde32dba86588cc83beee6e13800a730594a2232af09667fef4182d97c2a243cc2f39fe22cc09b182e6c876d4260a8b3541cfe2e71a6ae558503bd6fc26d315f8f6dfe0d0d39e095be263e7143674de042f3a6ce3cf77a844d8b5c13923a7486a6f817a258f500de243f57f70ff260ac96fa6021417f48b09d4e279c5df0288a390948f7e6f3df77eb0673a00b03386c445cd1b504159edc1e707cda150fd03e859ab11a85fa3a27d2ad7d3b686980978a950cb1ca93880d21cf48d83d1593984c975092d3f3ea136d1f1949a8b2f05eb4ff35da68a1e3a72e3579a18534ff22babe71d8b1fdd4050a4cd8ab71150dd4bb3453b2b96d459fb6adde0ce819231df2a0819ef9a39c6021c7587cc46968a866cea4950310e200e042d405bc3ba34590d7de1248508ab2ef4032a4066f6f16a99c3af2f7e5ed82e0b7840aacf4cdf2cf8c9b0a6288b3c37addc736ad3e22512bcc941c35c0cb21915bf0fd09510fdaba830593fe36ba00b8c2324b2fd38f8df9bae0232994e7b58b93256406cdf6116676a1af399d174370f7da794bbf779ab6564572ba48eaefb3deb46468d619a547279dc44b6c6864f8344e2ddeefda019e1cde8aaea602d63cadd519f101b2db85283eacc08f299f9f1dd7c1b800f581e0378f48f14a56e04c027fe5b84f35cb136e8090b2b695742c0db858a696e73456240073518fad5b504c606c7ff8e627c99799a214598cd9626fc38e38e6852ac7d21262432869cd63f71824d5e70d55e1e698c610cb02f0b427a05f03ce8c34fb56ac9d7170ae236c023fb8b6c57b6362bab32d3cff157134f55a2ee390a6a6829672f621ce9420dafda8df1b8160ee72b5df1ac9260c216fb9d7f13b3d207bf5f1db2e7b2dc9e7ece5d4a633821a0498f0be85cbc82bd23389f2b8b528f0e0a978739fa67022fb95abc2b51ce653ca6ed9272ce44ed9cbe6b2bb80d33d5883b5fb05d4143149aaa8a36f54639921fb288dcdb003967ac2b1e6a2469bd4c3c707418be9a4d48e5a774ef261e2f51b4b904e6350294a44e2d62acba071e91202612431953494562d6740022616f8ded286b012a75a425253a3aa49a42ddb66ecaa53eb9526b7247c1721e3ad4c65a5986721f583bfbf397f8d23f42146963d190121ccad4474098582787fcabefdafc11a9104de7f89468adbc17b2a40d97ba448fc4378d64303c2d3305f983c4fc6ad8e4e2bf2f605c08dd675720d5957a471fffaabd8cdae5b2b1f288f2e94437babd2769209b8a517491d6d7177e29cc1aecb58ec6a40b3167dcd380f906d7cef60691ba0185d65cd8d367408391b38b6731a01f7d11ebf9841c3c614c166f82e2533c6ab44ec900bb387826ad98c68e732249e1908dafde36dd36730ba44116e84952c43686bd09dac4cf484c53879f7bc70dc0d5b961feed2e4fe10aaa4d70238d8143d8c678dbb55dbfff360a48ab6cecf54abdcfc53a405f2636c1a7513c18ee4823641980838059591779f56d9177516b8ec26530381d8ff24af7c046b34d08a04030879efef5356497f75db4f67c38476182762eec0d51ae1b1d17544b8f16c0d54aa27e0e54bb55f3894ed378a258db31a551a978688de81f9ca7406d8854109f841c53b5001277150430cca86272d5a0f7debd4b519ec6f8c8e2fb9982b0966273748316865c089e62b5cecafad9a2e84300501d5d93cc28f9471ec209394d54ebfdc31b35dd6d9294afa00eaa4a3110bdc473b1ed782eec22c276a31899924df302c049e1eb7673331ac6f3cf18f6c53653d561fba19b6e1ba2e07467bb7e557907ba1e813dac4b291cf8950544dd097975a994dbff019781bb8d06596bbde49591820e32059bfa368e0e4e78885dfce553d7e868fb5685f727aa2d88f8752df289a850398cd5ab74f4abc5c91c414b81975e7692a38878af24e80a01952fcf48a10539f25d7dbe3463102d61681a16d753a5283f29ce0eb5b3635f573fd6a0365bf5a2842e3332fdc7bf4c316c4a3e4714b24fdac309b35283053bf1a6087db602cf1f360d24c5261a6955976a88b08f07ffcd87b5482223cdf60a7dc8289ba8b342230da94df3be522632178b8f12a04f29faa61e71d109e84bae731c89ec7162c46692cf3318dac79ae114019903066a05a312405c3e201c3abb7ccc9a68042078c2c43ebccf41e2dbfd5fd4df7bc4d7367f181fdea68166dcd8755057115266d02c77e370bef8eb8f4970de8ea174c7ee27e78fa98f34e44429a76a900699b0faeae5f98d05139924a345b53348bf97738715fea0eaf922f3b929684164a0d214b59eae65ad6c60b80cd856434bc6574d08da4197ccedc82fcd2b0c00aa7442f1d58d20adcfa9b9c7b5aa25b40eacbd6d299baad0704da082c678a3ce583dccf55d0d7e86de1b601d8baa3baa45c18bb0b1730eda4c9ca3d44fb326c1e1b6fcb46cd9ab6645989e69d35df9f27d0f19a0fb3d5d50738c95ff8945bb1935093da0c30efc571ac6858c209b9b2b7087c375468919a88c773733803781838e3fc775358cbc31a26ca3c0c4f1b8d9cfdfd5f95520fd4cca04fc1cd399d0564a2a47ac60a76f55594d4ae89d29b0c101dcdb4583c827fab67e5eff028134f8723e80e39841c4fbf20fa79c15d2eca4a92f136f5ff6226d0ad30c91003b275a06fcc6c4ce08cedb7c390b85c11ecf707a827eddac8ba56d2a4595a52d5504f86e052e55ea9eab31137dca6d820fadfc6322a3525b539bb9e10c9222ec9f4f514eba72539ad01d03a96f6fbc8b9e96d3fea74e5abe0001f79216cb7f57ca7345fdb17ae07fe43d137d5ee7521cdb02e23004aa4276926850273db0a996acde11a1583cb83fe906835ad1b1e46622c5ebb6f6cbc58eba8b8a913a0272d5c7a39dc79f0b11c860561bd2696c6119902bdbaf6d81db2c07333bac8dc75423f8b3080806210da3643c1ad72a6192f7e5f3e45a12a27755a39a475b45f919c6d7692d8f049f13f626acd39748e1741358a6ba621073aa37f1db39a5d56bfccf50a66bfaefbb089f20e33013fa4fc3acfb2df5ce866eaba3b2210b238e9f75b042479eff43fe64358e8402ff9d8e9cacbe3e8a0268c2f6074b64942ef0c739bdf032437b95b4c9ff27e635805e5b6181be8a16a2d7e49d2a78da94c09fc9f6000790845e7c87c5695b3d553f701e5f56be1c073b09377eb27e18b637cd083ea28960991c881edec3c56ce025acf737dfd6c2a0a7988e12bd0159d2ffa16f075b692701dee450e90b7327ed3e28971ceddd521140a71fc8c49c4c0ebbef6291949ce7cf107c18486b122083f26a3770e938f1ef071a1582f9870ba094edfcb497855bb6bec52f941ef2f59c43458072f96b997c9fd7152c35f5d7e53ac886a920ad9ce36851b4b31b813f604ffd17af9f6256c0015027ba6ff9f1dcd5f1cd0d1eda2d1328f0029dba9a8cde2851f3076d4d25413ca1d3d07e336cbcd2a1a6b5dbd1ad4b2a5560b29daf35fb574be0d17ef613700c999e39a8537034ecc933941fa81b7d886a6a2d142489f7648619edb2d8538ab1b3e23b6305d47a8e1a8aa2bcab6a19096d895fcdda0ce4ac695499de6bde340038cb2005828b1a2cfef946aa62c17221298b7e3bef7ecc36161571da604c74c5e8e337d487adb12cc6d3ab587fec07803c30692ff34ea0fdbbd360f1bef081d32f532262d1842fcfca10ebb571adcc16ca6e6de63088b1502ff0ed2cfac1b27d13297fb191d6ae4f4a4af4575b45b0cda394b7792794bf78760d819c184ed6c63abcf23a4784747a5627d7476fb5c47f8b9cdce9d75fda7d6d7723d472a3f3189e010029455096ac9440cde353dd4d38d0a037fad5a28d2b4c809ea61fb6e9145c5ab2320b70163a817ed04efb2e9dafe58d0b3d3e0d1c257eb2a5afdf1629208d2c1810127550387a6b3ac4bcd6a1c152247dd1caa3557cd92e99e99600c117dc9f6a919d2245e350d2c8de6b7ece8c72b4ad8484a7e10fd3f3f2e98733665e2b565ef3fb59f226fc80941152967073bdc47e65180bc2d82f5508a486e77408d95d43963958a4812bdc91187cc390a3468a8cac8f5b67d18a9a8b02bfba5c32925742224110f980bc55b24fe43d3e1b4650552965ddebc5f8a6543ee5008ffff224b4da4d2ff433a3203e5165d1d4473f1b65b05acbd55e9425f1994ae842106be134c37a897da036a75c7e1c87b4b2db72a1eb66548a714f2b6e440f2d42afb6bcf368310f3f8baefd6ab361469aff3dbf6ee89b994e01804247597a0ee89e3324d5f975146e332a134e87590fdd0923cc2ab8bfa3484721e1631c19c1a2c6ee2adc061188053147c2aab7d725594f1c573c725d661354674c5d23d09b3446fa61746c5e2dc0d69d3176d383920443f7f0355dc114a3d5d66ac12d7ffe3997aeb7672a521333c83db10653677cf859af5ec3e369753649ba46b12118b229e989d4105c5e1ab23ae52b156fd3f8f88722315397261c62c4d7c5eef1ca289ffbea49f1586bd09550a32aa848234cab201a329148d26c974cc4722adadc386e4deb3cdd90445d4b928bd13de785b556fcfe6a7f09ee4419cf4e3b1832bc78a480309b1b247c00665d8cbc077fe7ff1cf6f6fff75ae633cea4c75e6b031aed6ae4858f8b996cde70f0332e168daae6bac7631d20cb532f429f57030aa79c49d1634409a3f64895c3920fe8e21a696e657ec78802741b5badd52a88930302a45828339e309c0d8cf0589bad0a1f7f65633abbbc51c06f3d546c66ad515644eb2158abc8f30a7e08d422875377b43efd3d44766487b2387ed524e629c41141ff1c3a914aac50ed645081c15b7c76666d3ffbed38b65729ebfaa2585b60e1dd6b19a37520c75ae867fcdf0befc58db510d0c8f2061faf29b17712ac40c24917797e68aa30e525582fc9531c233bf74dc0fa0d2a88eba376e0be7f8b1cbcf8b11f9679ccc2e6420c620ea0a0dee21da9e0b661fc0369538a412504da32b225ab1205cc444f84327d5dc4ba39d4d41f2a6a82023816113cab5535e3dcbd5ba2d2fd117d37ecfb485c6cc923fd3b05809c5b5740bdca1a40ebf159912574990c3ccb9c882c8119d3fda9c3070933db44962b55860137003a67426f7e2a5051a8402aff23cff9d0a08141a2710474906d48c6b87019e601959f0514656c23fd6498511c8d1a596b4431ed3e1554bf3d2be6dcabde00ee03c80b9fc2ac2736011e7f679ed6c475f24901c47d5b0cf5c5920ec9285157185deaaee5ecf67495587705393015f8c9952ce38500d59ed8ecff1b2fc1d8cbcf38acf62a5e89d8c84def82da22ed19491e28121c1ccc9214db2a59b6bf47d2770b415e98ec613ea0bd112b0efaf6cc7570e758c5d8619fc26eec977a9039ba2bec2d27c5ec4e446cb68bdc92c6eeb11698022facd6fe963c9628d4f3088468ada1b9382a181a4484297765b88894561ee44be9e1e2f9569b75ce3d4654f6125bda8ce80400385cff6aed9b5a0f4fc5c65d61e116c73aae3888a4b9654f194f1b367c9ba698ac26eec20a6a648148cc7d5449004c01964ca303065aff825e82f0840fa91ff97912d0d3c3c0b3c928695194e666c8bc332b2413ac84f91883b6b1555112a8b8a1c3d7453382dc516202158b2934e863886ae3e4685689cf5a2a792d68ed28be662280651ea4d51ae4bba7ffad300afe62049cc3b7305cd773b4a524fd1710753e0f9903eb9d0d595f1a8db7cf074a7e955f8c8b1f2fd02018fee76e07bd445c4045edf31ef7dda613d3078b9b6d2159ef263e8940e84d56573cbef93055e79d0ba73c3fb29557efb54680f7b6e4cd8f2d0ee86b7d7e602edfbf0b682380823d58ccf128347d683e630422e184ce895bbff28adfd51f3cc081539446323856a4433e452d3706fdd861daaf0ccddbdb6beb596d9f4be9f7b6c709be21019da0b4ed7f0da36a9d907220f6d9e6e4be95321ac8fabba610de4b1f14f14a79bed4a70a906411d8683509c40ed44c3d1d4015369e010f4e98cdb8e8a104a3104a5d9f4c2c019c6cb5c8193e6aad7e977db55d6f5517785a57b683152560f76ee32f36744734b087802b678541aa53e6ff7983234d903c46a4f5ee2aa75bcaea180159845802d9cb1fb63fc8dcaec4ff295a064d7d23c166f69e20282db8ac360d6e8d8209ae7308efa14c141c2ac005c3d640d017c4a21e5d25bce1a713bcd001a24265d1c5a54800439347646de892306dc029bd3fcaec281f512aa0eb6e2bef0b1a1c63cb39b5c784bdf90a1ae0c2d311eb3a689326c2323d2dd69f8494d0c994da0cb2337390869f697f65e97331e1aaa0a3ac390f7ec3768a045eca6428bbcb06731b173ebfdc3fa3283b1038a91f23b1efde3a7f0344925dac4758c2ce3c91b3ff5516568c0752c1df10b44b75d1ed9b05c296a2e2d27b4c836d669b3dd9ca2cee94ae2cc4dbc3002da9fcee2bdc28fd78d2c6e398d70cbe900e2cb11804ed0c8323079c356552295fb9178bb8dfafd872a82f93fb2bc04766ebf678683edb5aee794f9061e5b6192fa9357312ff7975de705614893cd037bdf2867cbb841f65874a72a265990ae32223beff09346d155fe13f6aaa2148cdebd099c29d0be35f983ee67a36175bc8c9bbd4159765d552bf0c6ae7d6452563e4ed5710b12e827bf79bcd29fbd70111f8cb3e475ec9a87fe8106e6ba5134dda0bc2c3e9a89c39e60348d2a34c05a4f5b2a4628de7577d3fd83d55d87d668f46ba9c525d324acc0f28acbf02efe277b1b399eb889d0b5a71175d89dbb5952f01950ebbf8b747b90f9b2c3d0dc9ad5495ec803f005f8eafd9a0d434a2172d126e4819dc120449de493983b7e7c8614eb43d23ae27c94e1049dbe234ba6d850be5448e845b75eb1f61d9e31a51092062d8d61732ff6554dc9b74e15982f4abbd5f813db232890760f1d10f42b3d93370a946526d025bc9c8160ebfa229f2e56118b5643c8d413bc93fdae3b81395faac487a69903f0505f95b62f98b1cfc2c6b971d67005bc714c1cd42f70100de5a63fcf5f83c548d92227f2eec410d3e0c1f096cba5386c41331b0add72fafcc34fc4cdee08e9607101ad77863538a554a01e5c245dcaa4160e8fcd771d9ef737e85121852ebef4aba90f205c8f41f8e90b4e79ec9259357a9c17351cec199fd6e7249c4873730a5985f7aa2e4435964fc3dccf56d26805b0f25ff351ab9f266124e75f3fbc5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
