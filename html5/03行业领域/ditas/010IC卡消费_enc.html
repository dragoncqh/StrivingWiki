<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"38bfd1a48f31d5cdc4dff6b33458f7104cfa8391beb8fa9dbd0355e2641fa96c289f7bf89a373450563c16a7556d803395559f524b8b274f96a3f35db1dfbc5cfa5e7c1ef9fd7e7f9e04b9724e5d115bee5606a737ca8d1e042ff5df85c004acc804850cecbcd9c9775bfe2a6fcc65e2ffa42bb2000aa75cdda552861a5793096de4dbf5915fe480aaae95d2bdad648ed2feb43f30bbb2437685154636e21918a133d19ba076c58219551bd0b5d504344c1d525a36c21e15f14f6e1755a6c5b3d79cfeba515ca1ab2cc62be0f9eea9e26e2ae46dc678586d4560375a3b840c7403f8bff314bc54ae9396c3a96ac194221a6c3d20fc1248c831cc397e758ce64f6c675c22263c73335ae5ec0bf03b428e1245adbdb4b47ed2137612d93276629ad7b3a80d38166ebe5c0ccd24efc0b350c7d66543cc01f8435fd4586c8192667cada7b4f6daff2a20d3df2d83176ccea3ca78b591e0fe5fc6e0ea00131fbfb3baac9a0d4712ff80923545f29b812ff655b40f5016d3e6828571c65e546b3a5b790c9e57d1ceb40e4e0bd2810295bf92da8276c6a1123d5c90e046a62f4fa471d2d0da3d2ec86d6bd7d8a6ac84b88f9b12dc452f354661b18352b5bf4c5fec04e01a62c4d5a2c384ae148bdb9647136bbab87c371093d65f9b1b8d27974f202d2c1b17e40dc16faabb075406277db22b4a6912e9bc37b9c73eaf2db443f3ba9d8061cc0d9188fc038c0ae4c134b61efeccb4c7043a5bba0779a184182d2fe6f8b88ca24b57189ebedd38df3804a50d7ef3ec39a54e4529d09f5de0f0d8ede939406f1a557738fda9046e30d817440593f931044107a1cacf4977bb8701db16f56b5ea581b8ffe4e37376554561061a8d67ea1f985cbb78e7c4c28b607377498697cbdab0bafff70937fbac073dfbdc037a1666fcb5e8a3aa19108ce408bc5b816ecc87490929e54b887e9d23cee37ed0f9d65d75d1c9194b2bc43d1e3fa481a48a7875ba91807ba120cc72619a84360d7e1ffea809da95e349abd1c4de9cb9f75b6a7763454bc882e4cae90ee565c20902dacac034c8da1e436e4e3c52fe27476e34b641b8f6ee820131a8e36c1669c06633a94a984b81d10a50cf868c3b878f901f56b861da34d78e83c046f658d737f56e0adaf3ce9f6a34f7ca44304473c6d521882de041a19fef2fd6f765ea37f287a9d8bd1bc6ccf7b864fb521996da2f9769a2d1c5cfe5903eed87d44d1bcba28f00370fe2e2e8ddc002da625919038c5bdfe7c7867672539db28ccee6ec5aa72db967ffa1980e8a3006cb4370907ef1cde99b8c1cd92c84cc2c8b430a0f2be88dd0be2a814db80aeb5c12d712960cbb022115cbc2d908cd67e21463ed251360f181b64a3acf19606db75b9ad0d1d35c8894ffed95007b47c65f82cd1a8e2c3cb17b71de16cffc7897ce17efaff2dce75829af7a8f0c9f6a5c89986ca7d70d5ae0f983033df8aca16b07f5d599c81ed29e65cf31ebec0ab05d70e28b34354f1721a466fbb147b529fad82204b26453f30fcd9d03bfe961686d9cd030540990b2c867339223a90f4079673318a11264449764bac182c88af6e6b9025a825963cf00465ed111b2b306dd2b738ca70407a56b72e2d28706da3ad6cc8da9b50f4f3cc25a0d9e3427fc4d7ea282fd241ec52ec3793aa0ada87082e640bccaf6979f4925e650dbf240406c206bc21f82df371048b90bbddd7ade6f69d9c857aca78ac16ba689ebedb6ce17c2d16a0cdd1f165ad31c9135908bb4db65a381f9bb0851959ae80ecbe41e176136948020c0299bc9897b392a87ece125def66fa1a53431615a7cd7c585e2b63193e179554d5b0ff617145acf8681c0258d4849ca6b4c23b5f7175d34b165276bd9511db67e61cd0796fde54eecd54635c0d9fb034fa78d5850a58781bd9639b88d37093d71842fe60d8a8e19a2de19c61e9cf78a4a7dfbbf060dabfa5b305f3e357d35b00b36df952139ca8dccf3e2257bb3a9f871e14fa51255dc9b57624b2e95522d80148a02fca025dbdc2e60b23dd0f9bd2e8bcd221cdbb3a23eba6d971abd9cd415e3481af5e4f74341f8014b651da671311819151203904d60c2fec2c4716f5da6bee9e7bc253532bc532069efbcd80aba0915f8321d8919cedcba4a7b5d424930d55da85d6c32b4a8d867f3d5852361a4c7bac0e9896821004083a966fd89aa21619e68d405adbe2a3bddd67bdb297cb646cbe26e901fe837b2d5e252c02e4599bc0917eb63046be3c6009052fe79b515f4b92f3dc60e51a9091a589de529012ffa926a9b66b5d641ac24523cb2ee7654099cf9bd1543e2fcacbc292ed8a139ca93a55a089e43693c962e1a2a5756f4b293e07b523e6758ea0174dc519516f88d660b3f3195bf899ff88f1800d7614f10dfbdaa15de861e8248fcdbe4998f7b755adca5eb635f1866d78c63b65bc2e5b39913e526057173939ed58a50c24e580c5af99da87c79b4558177f33bb332145d2833017921c21b7cd09e3e0a786818ef583bef8ab2b2b684d549dbe69b35edc50c73ad25dd91de7ddb8c63ea283452beedc265b2360bd349953bf65a3397eed61778d423ecb1a706f3137ae3999d6203eaddf23e6e2a42bc6443e2b8bd09acd37f1e986109e4f956db33d0e5ca0266e7fdf25c17c8af872db40fd1ba8b717e9f4981c78a536c6c299098d180795beda6717587844f7e6efd5ac6b2b01d85f072442274e4763f10a7238c32697d45c9335bb8720494679afaabae996dbd020ae6304e62baca97f6b0113631f2fae325b031fc461695b2cc043eb05f981460b3d2d8b1515782fa1dc022a824049155e0b90f1c27aac9796eb553be85f139301999d1066fb95a9f39f997e54293c1825f4f77e4259b4319840105084f5444819ad09182324660d7c4577b3e0d5fe384867506ed3e6f6822edbb0f90d2d93d2203ba6dfcef63d7858a81e326006ed6cc3417cfaa88c6d0bfb10d192c779a2ae578b4af947ef4243509b3ce5ffc6dd6b90229139e62a418634bbb2e6199b69e6895a9a5e15b8ba47d0f89356fc3040c105dc49229a804d2ed31ddbd8c1ce5731f6290824e45260c4227b46d8925380874e4b5e4715bda2537c0a50e877863b2a860937efcfa5ff41d56196c312ffbe6a0cf1215e46e6ea8f789386e621629e8f2fbeb3750f2933085555afdd1fc8575f83d751c229dab6dbc8609a3eb42a7ad67d6d0d314f0bb8e0f213366070ba41aab84b3399d65f3a5b297c90e105aff48ef6d905b3347647a3c1b433f66cf41e66caebb1e7366261c40c20cc5ff9f296b671b0c14c02198f7928f4f33d9c976977c6a9e7ebfb6efa872be40d00391ee9c3a8e3f418c3e735f35835f5e5f9fa7b2f188d101df771d4cab6081777ee7d2376a077ad862dd794a1374036187dcc33b0627849450114c207c098d043b8bee7f174642d3ac8722053ea0562db3463a925a7e6065083b95995394352c9de61c107be3f6f185bd3577669eace6b4bf62d891993fb699fa8606c924b8e2e46c63f6a0f5ac5b52d86d4d821c94c7b827baf90e0e8b63fc3fbf711cb10fc256c1798f8885956c63d14f0bbb6c223de18b2a236e3afafa6ef9c50694419bddda58f6ed17717668eff3780ac0efd0e1ce8611454572d0a7b70c3bc79df34967eb2ff8949b4796db224a03bbaabf2a3a4adbb3d37504927cf7d3b7467559aa5de784015a57bbb627cfa14281cff113e5b38e73432869b725a3fc7e198baea70a5d660aafc2c4ebc89fef262389ea84320cb879367361e92f1ed39e6ba5e3462811bbc5a9261da03df3e1fa39f6997945a56ebd959c11962da7ce790e92464c2a5a0666d0f102a408c58ad7e1de26184468791b6a77b912fb7de81aa34255ade4565bdc0e94a04e8c3522e28740e80728b9956094fce905610feb1c805bb921443f162988d15ba8749593bff3be5fd56be2b2514da71bb149a46840a2a4e1aae2805d05d48a6676aaace375e5f234c45945a78791f83a6d94674e021b8d8538f38331040b7c2ac4a7d582d0a002c754c30b1f6ee3f61f7224d1c7466cafb04a321b8d52cad9f090db154feebe782cd8f7e9467507607b6fc647c14830f9c726c6e8a7c4293a87bf7a8b5852d06e54e5106178adef3a457cf6590bb3ba9e3bd223d3fae2a9ea6702910a6a6b37bcef6c835c02575cf30d4fa3c5b3d611a1390ae7ccb5ca4afc612afba9eda4d3415edb5605feede0d6d586af4547e36e95f08ea378aae30e549162530a6329a1a1447efe20c986730d12f03c44648e4f6bcd9ec584403dffd171307f370a17b18cf502c64e40f96b2f53c581b9182419b7bb93caf060efc78dbabe98733c40dfdda3231335bd2abdb7a880631c924d6b018f8041b54f5bd4079ee1fde060cde8cad71be682211c0852692d55f311e1d7a5eb818ac32b4abe0aa9919bea9b9745f35ccff2af174ee80a1d28301563b5eb92794e9a24f6398ac566b0afd6521ac503a0d9a85c467b252fbbe1db875caaf392c5f81f16da28c77d7df21b7b5541c34849831b9273708b8839da2d66e43819677dc99f6817da23ce189fb007a95acb2d6e134fed906c124c7dbee57dcc90289b4d1bc29748cd9b9feb789943ba7ecdf91d872475eceeb83cec137ebed6b6a567812cd8c3698ee0baefb232b52e387623d01b948428e29747431b07de591b62e984adb0b6e1c7d9b7a53ab29138a4dadc0849d157356477b6e6d0a08e02f0942f9a674f36081a516da20e61a03064ffa8ece0529dd5e4f1c0b9e6fd71ed94de5ae8990cd117b014f792861e98e50de57ed2c89de710e7f938568910705fef5f6c661f2110afb0588089f9216052805e33c5b0549a8f0a39580bd42afc7a99b4930ebe34bd40b1205f54497a19eaaba5d0e70d52bd594cd5264a6963cdb075bf3d51985965ab5d0224e77ee4271c540ac24db01e00dae4e848f5c7e39818aa76f2f4c2e58a26a0e3876f266460badad4dca98167c05cf7ea4dc5689c1604a6a5e40d6ad6130996f2d4b301fa1871b3dd92e742fe243d9a416332366c9c6a586e15c834e4bff379a806b4c2c2f891dc325866988ac0fd770d177931b633648377016aa35d7f382cb09f61a1a49b0c5dc305e774ee248cb8d42b773221b1a9db8e4f3ad11a0331a4d1d052d1c8ce5e386dba1da8674a74a5e7a4497f01ccb44567db1d2a6faf8b9d06a4652021631e2b5fae474db69dc7cec24a2ab60b47fe511a4308ba3a048e856fd61248366112a6acc8d3d8f4d3061279d56e001461bb5e0d83d7293cd2f7d1e8150521a2f8a6f20fa21537a51af625df0271e26af30045e90a232ac109c801bce770e2ef46ae42defbc5c38305c4ea0ff0edbdbc7118440bfc7ef29f8f1f13dfb095c63726bcd2e6981047df597a2cac6933f50663ad71941c990a9ec9696d01c692325bfb5138de2cae90aaebda085617f3d467c3b2044a9b84a554020cade4263e428e01763bab640900eb462bdee906a1757600f6a771f0dcbc151771b2d67f87431616e2218c32f7f9473c687397f0961e08f7f82dcc12fdc69ab066ebdab0d5da12805c431340c89b9a86177e2527c41bccafb66b4acfe773387c35551b360e0e08d11985db1760899a4881668f3d275229cf49b929365bd660c44ba1d0c050c0b7a8d433632175ed524f4cbbe814bc41a19552bca7771895d30e88398b1b9fe1c40c533edf77285f1c8a86bb358aced438896f6d7aa697e8832c3cac41996c62d324606da0e5c5a297d36b790847996204978aa497d806dc5d87c9abd66cbd24fb55af2c122dbed934f37e2297485030c51c9f5ff1b72c5f453748d6596dfc5a0c4a0cfcb7913748e8b7172083f02e99e45b979b36fe49883059ab2646d0c8aebcba6a28da6ca18d7b8cb4e58236e404bf5839d17faac6669091aec908731900729c41d6a1bd2c6f252d67083316409d9c8f5aa3931ce42f0a8641778df8d760d18201dee0c909baab0f128a4b2559d5572902fbe056e52cf93b2daa7e725377b0635bfaad98448649d5528d47dfd043cb8a8dbc6e8a4219252e76ecf39898eeb25d62f4c98503dd778c107dc0dbef261a945628ba1cd6f67baff758220101045cd6e9c38dd953c631d6815bff28b4a984f52c2c215e5a622898a392a004256a0a21f51efe0a5bafb424f2f5e0104fd35dfc4e6487b1b090092f28ed8132eaa4c32e3fe88d166bdfc63061d9ee65b6cef9cac72c323c45d23e197e5dee37c1cd389ed5cf94b9b389764066e7ee39975c897b8c310bfbdaa5904facf94c54a2bfe7546ead091914bc9b875cda6edd08fdb80c3d2f00a6e3fbfce594ac875d6b736dda2f89b7747d29b84095826d590b2f40011120c0871af359dd7e237bd0a19efef4cc8830ab30196d545ae0609b1671feca87eca0528f6d626512b694744e8f4952ef17ab681c12cb26f07ff9392d4c3039a764939f09ab08b67a546766b622bd6676c0bedec8304a4c9929a12e8b38569a4cb9f5950d60f5b2c8bc77ae7c4bf1a0a599adf33316cc14470605ba72b70041eba85fdab026c1b7f32a9ff9470c4458580bbc07c1ca2b38685ebe8b90fe2b2a61ba70cbfee26c9eeed654d68d021ae0832ad4a15666c46ba3c6e39f1521f174f3878db141c9e2b6e8ec4497c099e51b7f1ed97e8ab34ecf3ca13dbf1613e26eea057784185cf0f0536a48192ace49f583a66085e61a469e0d328b4b0a2639a740c235219daa5255be68c74021ddd54616fbcbd67a07b4ccbdf4b1d3c1a30860031767910e6b741cc1eaa83492990e216d7f8072eb2a82b44608a37f9b5cfccd2e5f4dae3cb17f7936aea90779cb3143b8bda17f39a3ac845e2cf10ea892f299a517c354f22595a865ee85ba5f44b94bfd666fa3cbbf8720837678c600c318a486efb255e8dae34a1b40ad9e46a63acf4e0cd9217c2d6848c0a30ef2fa1fadbac5c23afd169a460b3de32a82ebcf8d8edb37a137d440aa77d38f941182a44e467986def1b6229be16cf6ae7f16a5025982285b0e3af9e587875dce4e7affc375b58a4d1002744a4208dfdb32246c4d728fbf34932c952f152b29088c19745cd13185258ef5d78c61cc6e723a16063169c7908ed2df3718732d9dcdd4dae5f184aee2761bac71eb1a6f5747affd8f82642d9fff60ffc08503fb95d9692b4daae26313176cdd6e4204ecc3558d1fb6266482985d270f66c2b0fa500f7ee7ecf0e8f987c84e98475bcb0bf91593b6ae81711227e5c16de370832d1b46d446ad4738a2cbe9efb27e0943b5b98186263c70430316174023495fbff7b5dea532b347d4b095e39a59affc7a8c441c83646e19335df8a61ad5b059bb8fe0e53e8b5673f5b78c5cae0fd7f08bad86c3e94f8a6f51c17de484bba4eb6039407850dd700986aad1e4ef919343a7905be6cd16f02cbf63d2b15e5698782c7a95cb3d84d7af8ceb0550c16f5a320edc3b34105c2d2ddef41c72f710c6be0467426f0b46f7f99fc38dd21a93f541396dccee779da226bf28be178ef4778ec91ba2e7a9c3676e23e14f38de9c0c36ce869ff4f37da90558916f4e9ada4cef503f2ec48bdd03bb91b1da43d6333404e389296382ed74d14ec4bd56d54b0cbac8515241be880e7d9ece957904eea2e74cb228c088dc63d6ea9b6ef6387bfbcd9d2c6fd74cc02d7ea73454e77f8cff5f3c0b248469dc3c4fde9c4ee2907f8ca5ab6d816e0f1aaa362b0c57cb3102732475eb4ea8a1981eddbc79cf5745529b9767c988b344bfc04257af51f9ed0cef57feb64b55f4587d8203a3f556e07b220a4570b2c2a04a6c9d0723d6cfe8104d37861b3a7d8f63f5d4fbe27865c6ba99b81750f33b2cee077b8007e1184c95e679ceaac39013ad6a6007f5a444f73d11b268be088e50de13cdba041be5d3978637d8c7cbdb647711e988da191532e72e08256bf39e3e88f1801d1d9299e21af1d3beefe76b7a2e1d9d00d9b59e58286dd6dbe9deb0ce9ae825880e6458aedeca61a385ed82a2ba4aeb3c849094ac348cd1bc198b7f4d1fdc329278af4e5d6ae7813ceb9e25aa959c7a72c83a06e717cb4b5f4752206550d557183f1811ebbd88c48ae3083bcc3d50caa07ecb5156ccae8be7812d6546766645d4425eac8aca2693240a8a7e2ae06cbc9565bbfbc39a01e287afbfb51507624f3147a5576f0507f7efc115363abcdbfbd56f8b9a0e99e539dbe147639c6d83545a34d73a78ecd556fb9a3666bb47ff2523198da97c826813ec9bbebb9d404d655a6dbbeb4e6e9b512e531ff052d33150d309b545be3ccc3421dca64cc1d6ad9df2944cc22bb0b7807e620031df4fef5be7f8481c52e1de439d4d8ef6ee12bee524906cdb981c565f34c3713015ebf49109d71114c055b843d46ce1b08ced21ac287f797f949768ef476d0ebe61341e8fddb64a6e493e2f2637ff2f2e22f3e12b1e7789a383c2138c1df39cf2d2dcbb6d107303832af583c04579d0dfcd27d24304614ee314509ba3d30f4e426bff3f15acbeaf3d804f62e1ef9e6ad2ec629d5e22781e3589e6b461b493711316a026f5269ccc525be5700c8e96853ac99dc57dfb8991df56c876dc4edd0adb6b93af3ffa76773509762902800d922ca132cdab78f7130cf7f975ab8f16a9f24ce0d5092214ad27d70c14a7eff4bfa04dace39bdd9bdb2e3995f4103f92765e9e54ae3d7c4b8c711c0791da760ce314237d14e087de51d2f536a20742918ff263aafb8ca7e33b06ce5dee5f4dc245f05ae73c7052d0509962f5c90d1d7adadd120194003425cb1409575203eda5ceb98cf979f52a4e610ef825bfa639d1bcdc16cdfc981c403b7a2d44bdd3fa52448b3b13cd929e8a167bd4fca8336638757786c8ff53be1d9c2b539d7915c1c72933d2525919ca304af81bec2ec70a806f44524dd0fe1e769cdfd77ba08ba086c331f2bb5836f5a2a06e2b208e9d3b2d1d85ec978048990516c0436312974cb23c236cf31629d72c18d684c364cba61c732adebf65e1f81a376bf0f59c6a386c1300db49ebc9ef6eaf6c4322a6d5bb5765193fdb02b868c97422542a1e447bc5b7319031b601b8db72e46096a315cf7eb2bc11e438441a2f8644c705d3d78a3a0bb453a6bc1bb85c24849f9fd6759072f2a05eb6fc51d26ff5ca9b2185b6bf7173c5c1cf7a8240870270d7cd1c6c4cd415a31b7d1711aef293fce5662b48b9cce0084036d24448b0909cd252f494304af8b4dd11396e3c7c836c4be4a26c51f4ae51df0544eea46c04e47e9fc79faa8aaacf7707863c64582cd5fea9ab199e0c319d46a3e468d4e07d7ae0312b0b312b64a0ec2a540464044cc977b3da219773a0eca61153dbb3edb612b39b38b6a88078236320783ae565bd70d0a1ec54398e21a87c8fc9b7b1145fd3146d1dd4ac9ab47153eb4e792be9bbd5c4d5d0a60b2da30fbec034f8386de064fa9dba92f00abc479a445eb5e42b5c94ba2cd21348ab9584a86035e99277d552d8455d7c6a97255845cbb157407ec8deb4fdbe6ffd5f0871f567e3da36ba3d4a9cfecb75684ec129a7c97bc86afffa205834fd927c140a9897decd5845c2c307b9fced63facc7a437480b47ff979d345b3e4419cad576799017a1f9d9198b908774b9862d2db687c53242279011d917a047d08ce3d125e798aace03d9804334729799ce883c8071502bc5949ab36d2cf2f60a89878bbb7ac87dca0e4934dfb4bcc24fd6e8d942d6a22633914de7c36cec3387f44da0d5c43eac5e0234d314ffcfc7b7753095fc0082d9e92cdcc69ae8165393349a035fbdefe7188aba0722a5f33c61eb7f13dbf4a4d896b2629d00127683ef4c78d95b58484139b1acc026f83ee653fe43bc40122750b7ade8b6a9c5e78f586647c41a2d3f24b37267f4a8186c1eac1b37180e47d6f3bc12fa5b5f47e55fab4fca8c155bdad1cba2451dd67ee77e64fc2e2d6d05c76bde3d481bdda8757659a21a81bcea0f75b33db35efa18f1950872782ab29a9aef420334cd717f980aa67db94b4974374071d3dd7322663f00ec129f4d62851f3079e43eded9a1e9f40711c3b38104d1218a5a21bfa5f327916703ad903cf853f8daca6fc088d3ebd57d788c7767ddc552f5ab6fc044811edd1d83cbefca44a8743329aa78a82c757734cf4dd6b824f36b7de72c3b56e746b3ece52bce7979cd00ba641a0cfd4075edc1581f1896464d8e5e206faba078533f4fa09380ead7fc3e23e3ca390fc921478adcce8db0131a8865b8f90682afc34d71b50287aa483d9298dbc096b4efaa6c261028c7e3c7f3551772a80c2c3c1266397fd11ab29d1df599516c251db18a0741b03f577c2e35351e4dfdf017952cbc42555c94f104b6336c821b5f1af068a96fb39781fb5a2de7c5937b0cb3b42426cc5820c420a028c57f0e73d5ab887f3c84992251c0d397c7becca4bea7f10589853704d4cab3dfb4ef80949836f45597e0cc51b91a3d025e9c72e18e95568a469d1a97a018972fcfc13715f99885528d5c6652c013052a9a86f2d6852f09f96d56e474ba4fb6a694e89f570e2c37616c19b4eb9f5f2b89b27723807aef7684820c6e20d5da888f267bf70e12739690dfb058f3e5b73e8b9b8284a4f8e2153900a60e31cbda7e27e28900dfbe352fa620dd5c422b10211ceeef30a1bfc722f98808f616dc9b9107449561f8d4801c8ef519e7c9a8f5be6c3cf6ce8e04ff90e279f38db63cbc93f153b8d93006f736a0f39f75bd5797ac892579b992b81749aacf0fdee202a32d82755a1546c7bfe6711d191e7049bfabb27781a9ccfad8d9189cb2a3260ffb3c9fb83f87fb2818b1d85a699e9bb5c0930bbaf28614507f4e2e885fc2ccc11b128d29279572851047c573cf2572dc3cf5cb70e0b17aa222a5995aa463631b4cd37052d31940566f83747075a1630c295bf0ed0da8a87af69afb2a4f4ab8b02ebdcd1e44c1187b47ced4b93836da99d62dbb11ba6581c5e5a3d0e017feeeb2ced24eaa5ce976ec0e4432b63db50c40149183309937d26569ecb7507f5d2764c61bc71e8046a40fdf8f6392d0910f07ee5875d73d4d6f962d6f12330bf8202b1c875dd9186cdc031fbc6ac6f4e40a01203d48507b9bf078faa725c9c666974bb3b58526f779938794f10861ca96ac7884f715a002f135d555f0f013baf6564b0523693e4b085a3fda34f91bc856dc5bce2024eb15fde3a1fc0e032e50ecec142e5abffb591eda2c9f13e6eb4574d6ee86112238e80fd936c11b3534361725ca74b71b77b276100082a154cfca4048ced024081b9cbf0d34d17c044bcb51b5e16a1eddfe57517dba4a303007abad3d328df498b1f27d13b4a01df877624865c3fe6d98864dfb35bdbfcbb01248528d3262ac071d16b004772873db5a5ea07508556a04e8f9af6826d7600713e0e3974fabc955fb59582d18f8159fc46ffc46d3fcd9b7e665202346dc3576a1f2adba08bdc037247865b56a7e2aab6ea941eb90a99a6428bdc324ca6c5ace4ace55d14510729e53a824f8b89e60ead2f8d36ea3659d3531ddb6ba9b4d7b954135a86f7a9fadacb2368fa23d779821ff10966e7b4a4397a0006b46feb4451227f716f9d409b87da5c44e7087077bb94b3b991330937e4733efbd618dad9c89cf5a0b7b4acd894edbc4b3e38bd2af308ec9b539b32aa990c5697e070d0741eb8adc8958a72f9ffe65c94ba9f4730981a89f25257540bfeefb9bd497bc2ea9ff1b728b8c7e2abf43c2794a6a50336ab146adb7c24e92971a998b7ec6cf5e950676b1cb7a0a73eb5d98440d155b65c43199afb421c30e100973fefd7cbb577360c3abde730290fd6539cee51faf31ce751b90df767912defd03f3fc9c47e5d14557da57e7ea045f0323da37151ead4ecfe5e23c047516cb5bc1d9cff2027452a6fb08e3dc4a3003612806f82944d9eddccb4eb7b93a08a28ae17aa047af23e5fd60356c8bbcc88493ee91a8e499bd4b19048eba10e6fe5b6ebe3ab479720b2c9eb140e66bb14e45c6b6400278cc0f190f3c7fc449c2341ec1da7e4ac3a06dd723bd46c76d4e66b4e97e5f1ec8b74e0afa84078e1a175af68a7f41a9c4502f14f789072bcef759a173143c24d9bdf531e4bd34b9732d9bac2ef55b61c038f68658553a525f5996a0915f77e1243496e2333dc7674e5040d898045bd919a98002e2d02fd9599941e02837530169fe5b3f5e712be68f277b73d3647693f30555ab52106f502e58168d2217bbbd12388ef87ee29e5523f39faa2fd4c2e7ac5f11bda731b524f30b2076b9b9fce9ea5702885ae826eaea4582567d3e43be84b5137a31b2893b0f29d53246fe76868796fa7dc9d33a9e8451aeb14e957da8ea106d9671c3a93ffefce0d1aa9bf48e33a0df9dfcc6834c712e191e41183ffaf4cb216bef2b4ca03552a328235ca5a0a15e747a296b3d53d487cb850cf0812c8f1a358d2b4a153bbc6104ec15a4b17009d3eb0cda47a7a4c64e432e66f42b23756c381ed9a83e067233500bbec49b45b19d279347442378efdad187cea3e04d782ca42a553d3636448bca3563161350fec04524107264f19667591741ca3b7e7f05e8e23fe566bfc4b2145562425941d3abe075c154dcc39a5a10110f2133eb1a3b6a7e62d3fd364b3b5c370d9653311ca77f1317683aedbcbadda28ff8f698bb1daa943539cb7880fde4d01a9de685fc25016f60572639dcdf90ec9266755760c1f93fa8ad8fef8bab48b5baadfc5f24aa8879cfbcdae192772922bad9c68ff89938d09a02df6e27980d33f749777cac5bbf51d39307b24840b5981ce839adf477f6989eb582795961f561b3aa787a19f214742c098b7b9a0bb71fdecaeed7196088b8c767d2f963d159a62853927073be1c4cfa0830468e2e0b68ba318d06735299ed56c914d996c8e0e944e61a5f986307c5b8b0ec3054ab1380bcd132fa8461c2a8489eb3cebd5684749c8e0ea26a3c52bb2cd17bb566ca7b9b74ee93630a2c68d1d7caa459fed1edf58f8c8a203c6265dd7396a3ad05f2fb510aaf4e3fbbcd8148f2f910c9ed721bc1e4d93d5dfabb9f0043f1f800c7b86839b0a1739311d18dd3ff8c4ae792e21e4c7b62fddf9774ff7a140e67b1783ef8e5efae2cf865e91fc83299c0daf30224f6a46642a8728c7bcb4baf65052b12ba4bac17551706e96764c6750740b2f181d98a6c8fd3b31d5ce4bdabd9e1b853b36f615ffde86c63cb801f523efd8a16b8de94ced8fe5d8577ea0827dfadf146c9fa6368a5b8bd12ecb065faa0d8657456674bde393fb9aa4e429d908e99d38e2f644c823da0bfd2a872c6cce0a206a9bf3b9ddc82300c9117ee9530e5156a4ef56d9a3ebda1164384428f5141780c13e44f49dcd92b358e3b70d102aea2f0900334cfc33f0832b7a0fd9a8af5208133debab6ada999264f319ae18df8aaa896493ca4829e02aeeaf5b56595e97a3d3b599c63baf2b97d6dfa7e588b39e9857077c6ea3a75c8667b550fec1735b23630a18323b412628d8c50d52b5742260bc86de3844b2daed0ee107168e9102e743c1a4040a339d54681287b339a2240056e32b30d2e9f3ae94008d7469f27eb98ab7ac4c69e29af2bb87218d0d1d9e9e64785c7f4e9443afe8d246adeee012b17b96eb664e74e28f827858da12e44a8f994659fbd34c1a7f4131120c54598f72398478975089410f5160458236a07e0ff901cc5bfd5347a15d30d5a77daf8e1eb9f2497adb07143e25060941a92a781cc72b7c138f435c6eb1343dd22fc27f072f8f1b65edd41c67bd4d4c760119afde95e1622bcf04587204b35e0c46dd9c27c4fa9ba6b9e415393494a7e678070cd7d703e93a178a559e81a72fca80aca631c96bb6eef32f5cb9ac0eeacee466880ecf17afa139d7167c388381650046e4207c406bcba0fb1b6bed707cc81a25a1bbbc008c1ec1ff2279ab50b463dd2214f1f7d4e3526dfb9a59f478f903f72d7b48d6db9b28e2b9e595b7e50acd163581f5b6a8b61511f8d4ec9d31b6620d5144aa5935ec6d101c221d72aba9d29957613c634be3ea987bbf74ecdcee7c0ea01da9e885188a1c4526248afb671754c1f96a681e38bd4ab11e45b11e351b412b69face77034353d484a3c93c25d90a1ac419763de5d5981ecfdca01c9c0fa361b507a78a5d546cff4c0af3df711ad29c908f3cbc5b8ea3d0767d1e8b992a76140b5f026e14d447ab6ef627ee86e9fbb5e0fef305a320672af9e0e212dc23b495f4d06df2edeae510bbc0cf136605","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
