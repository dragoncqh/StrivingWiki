<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e1a3b3b8a7bee1480d9c5f35f88e0540c416f32dfb23390e48ef117cf7488e3e05da9dcfa3fc05bef147f2e44770ba2ff0df419f6a8f3c1b706605d6913392c4d9e4802d9cb7dedfe7ec545eb9086813899a099a9887835fd0d1568008507be0ec02ec98a3a42852875998d197272c12d310fa88a40e1460dea292093e15700cdaf43c5ee9022eb079692cfe2d510d9e9f70db04405575539af72c6ccbc434111e64df9bdce3e2e24ba0d85162698c196248b1f57d23e08b45008917669fd54c25c96c46a7d781dd16381b91c118c23b42d8852937eb2b0f3546a3de42448afbb77848f735eae286c7df7d5d356c3015759617f85e6630ed72c463acbd5cb8265ee54c4818b2440b9e65c962d24d1cb561d987297b8e9fc8db385e132f1c522eb23cdcf947fd48f64757f318e13c33a9d06dc3dbad9d55ae0b576b220801324ceb35d25686fb0ba0e7dc06e08d3525590d4763a1e5962dffb13159168a5c2ad0ca7af1c7233eb107651f044c84b75c23f689492e2d5bc84b005236112890a6450bede8784c139b5c4828544ea47277d3b8a6d5a8543d91d6a9c4b002df09f18b20d81ab1295525ed7041e4db86e3be404031c280daab65900e75c581690bd204abcf1d7b851b090635c8bdede026c2b99ac2ec8bcf7e48ce82262891a45abe8eb2c927804160c07e71b9303b3cc795a0ef7a38bc2d3934256e9f766d29ce105402c73d31d0e36b9845c5240a8ab5f56ddb095f8714bca0e9b14761e7a67c09b1fb96a22a8c6f93d0554712738181f796a788cdd37bfdeca69be747731391ca47c1df3e3520e05f3bb2f8d1a2e37a6db0227097334fecff0617cc9baa8b391ed9b78a9805a9639c39cb3dfa66d7733a0545e6d262d383619d108212798288850ef043fa05d1fcc58beb7f2af7592ff84da6bddda797aa884665f9ff38d34debac5466847b391612052e27ebfda4e1531ee38d9a83d3da26c7740556fe00f861b2444613d620ea3efd3995168276e4313f5887569144b028c5b2ae4e8df6f84b5192ec1c44ae02dbbb6133147ad174c15bbb9e54f84d3e7e11b551c74d58c8facd78399d6db1b89a698c0a872199fdacdb604a60ea7b188b42cc96255c4bbbc6e008436450141503c9e9bacbd416a779348052fccca473802021933d4cc4813bd93756031a08c7dfcc3e47ebd2cbe919058e55730056354b22ac49233437f0d93b19b55ef4a126dbbd8632a4c8896b2e4d80fd48fd0ee9b73f10c914124fa0c8e892434456795cf30a256aaa175c42033d5f38c5e890b9efca1efa6efbdf1e28104d6cb08365ff8e11324a6783954cd2249b5e9063c547dc3167db47f3d4ea5fcfae0de1550fd92d9ba46d679ea00dc65e7d3950b6363a296b01436d9352c487b37749e7b0db31b4e831dedf6c0f7648214b10a9b3ce10a7feefcff652682c1a692b82906d55bf2efd62a5c33f779e0ce12a04a1f2250f085fc29c897055419f3f6ca47786b3df9b0f2e5f86e581f662bdbe61c5f434086e751fb5dacad6aa0f1ef3b956372b787fc18bf7e14d15b8770c517708d0a0de03cdbbaa8b1eb482a9e2454fe4e29ea1cffa89c8d2e1a3085c35a6703688b568128a693b623829391ff197e14934f36dc243514d82d1ade0119357a1c0a322216cf2c93735e380206806e7d3293d23da38e5ee0acaf4add0575f5a7c48e340d0e7dc20a30d6c52c24e591fff949580e3b4173ffd5ab8bb27732af0fa89ae320ce7b353df2fe40d1335ac5b71bda8cd405f020f8e5300aa6b9de290ca8baad8bf023812469500d2bf7920126ebbb5f01e7f0a7d0bcf875f46d1110d319f7b53cc6d5d6f61ed5c73172d20dbed8e39600134d0432dea612c88be80e2cd08a482d38ad9a403487925998f7830047cce2d0fe9a36dba5965f2f447fee1aea80831d25a2de7f9e65d09d95586b2bde9e3a44b0b4e40b479ada1df0ce4f18a912472e27ba7668b58503ab251607b620c21eb83c8303f8e2001a6af68df39b35467725de737ff6e7874fb9dec29fda81ec6c8ccddd353859d522cf7974c97dd686a89f731076a65d74fa84c03a670c8d53e4a0a9ad581fe5ecf6858f3a5609f5688d8802df2866cb9032083196a6ed4a9584818f653deaed687b86a04197eba46c5583966bfd623ab1e5e5662b0a32327c2a2ef11df984f31ee969473ea3e1a963de7b19e4f5140847a30d6172b1debc36c19f78195a3119728c3150f07c35e7fff9bd1d417c8208d24defcccdd1a01d3c0513381943bcca556d851244de62097ec411be514c6c5a4ea14c6f748b6c570b14c25eb5cb7026e88a1ee6b3af891f9fa09ef7dcf09d5c0eb58fd68cb8b5c0ba95dd594ab1351ccc3675a36c0c6dbebbd8abc55dea6f817c277afe6aeb16a6af4cb8757a4208d6959f269ef05057f10ec10e99a4e4f8d632760308f62d73a2bfeaa2094bd36d488818531e9b39725b25ea9ea9c649a9d8b169451d88b49e6d86f4ee53af111f199007067180255be11008a8b3e0e72560911fd7f4565d8e5c59af834bf162f06e1c27950a8a88fa3c37bb70ed792caf95c6de92ae140d09a2f1f1f181cdff16f7a5dab91c19e6152dfd21342084274aefb2bbe4899123d0721292b45faa49afffe583f24a0e464dfc3962cc8aa6a770d2584366ab761fb0c10076bddc2c0299d8b5c46cc7a19fe74bc35519a10e93eb530a45e07aacc92b0f0082dc669d8359b49b3cc9ea1a3778b98f95efb2d531497a455dc6480241dd26bbb25bdb0108c5b1a3361bd94c488205e2bfa699f4dab8bedeec98999c9127618ffe319b8aa2ac54ff15804e0cff19c1a091111a315cf0823ea2330d5c807c9796e2202a75bbde9277faf41c0f1b6c0082b368a2d7a40fbd4d6757aee0979984f829516eb4944496826a36f5debb3a8bceb6be368d4c5055e2e28865bf7ddda54627bafb905bae6ffe7797f351883419f94598fd9f4697350db534ea317a98ec9fc15cf7a561c7da1e7fc3899894c39fbb6c2b5a73ef8a36d91ae838c5db344f95678f326b747381e6526329d0692279a28d2d07ba1fe894460325f97e100766fe9fb4e8bce77d5ff4bd07fafeea204342a122d3c5c43a4960cff36f860ff2122981321b3857f8d952fd8062a935fdbc18da01b2ac8c21c2e83dfd221cf28988aff506ef860ed7fb425c1b0f03571c5814672cb22bb3babbd8ddefd1997d5c4fdefb495901d43f5038325d8d5969949ae38ccc14e14094462763c2dcd7a4c0c97ca7403aa61a354ae947af64a30adc851ca208e5b8944c445f0e1238372f0b851ec2c733cf00a0a801c0a2cad169dd94025891f26157816d1fd7e29f605b1457c89450bdbb245258412bc0cbd1cac23b02ca2cbf0a9f0a2a4075a39e108dc03e0d21143c0685f1b08a956d319ac10fbe1bfd4b0fe4f0892d9c2864e95742f042b188b0e7c612919c97f23c805299528f00a733817795152044f65833f5809c1ede353ee097334d10b1bada86c25fe839ca507d1a6faf275055f9d49da20c677fbd990b9e2cdd8418eaac349156d82d8a8ef2dab91f2bb39bc96ac5f5d98457be644939bfb3e75dcdce7b12942dbd5ccef9973ab0c6e6ab8bbc1a12173af3facba62727c977b175f88cbfdf9f796a5bdea083cfb251292aa8d662d78a0221f1e3b6ce8b53efc8e9082b8a7ca566d3d18cf3f96dbfad967228105a13722a7d57662e24b511f7e33ceef034b5dc9604185ef3bddf5911d11cde14e266b49ec34a20324fbac48dc0516fab77e8b5a9b2ff997e5ecd370f08d4f2583d5d75c2374c14163d744960c645f6321de5e555e9bb5e743d97bb53948850431516c551ba950a796f1d2dcd44f74b4d068ae786792e43fc28952f38e94d129e42dd16121d710c861d5116aa1b158556cbd90ff0d7b65b453c4ed3eac7654cbfec614a817bc1af58048bbe94152ace9552a06fcaa2cac7f4c0dd93226c1d0305c01329dc7ba74726104851fd8460646720db62e07da70c7673e0dd6b9f3b573951a669af2e4b7fefe056ab59eefb3ac0b121f114c613894acc20493c281cd52c8d082a47e7bcd848004003d00de485d61669d557eb8b348cc3ef29b19f8a39e6400548158ff95d91e05b8b43894901bbd2e8a8d752aa84eb2a3e395fb83ab38171a82a2599df46a44603bc736f71c4c73d3b271c043c858f683b572809127d28a014e174f3135daf6e39cc6c8f232eed248587e8af1ed8311ed72e970b623c567a5ecd9e0e9c4b00c7e80425731858affd92c27c521e444f8d196aaed3e8679d2bbc1cc36502cbdb843b12b9ac8d4224d0a80dffb523d4c50a5090403633f6ae7d594ef7ff869ba6c254ccc55b72056947c98afcf243c83b08ddb05f6107dc6bdc0f8a15af11873638638b9e5097d53c3078d3a0233a5467e48eafb2ea93e19e2316672dda57f8aa8195ecbfb3317aa1ac8793dca74d0238f5ae629eabda805ea9db80588c988188cc8f85b63746b237eac331192785befb4f1b644ddc56a503c7107d8372d62678ef1090ab80ef79f8e04be12c95dcc7de1aa3e8ec38d34e47a40d4452bea80b9a0682bc4d93b523dd362cfe4f6e01ecbc698cbf0311444cf03b0f016a9b31b8571385b86823113a1ec9495204f67cdd9d9886a01203c52f983f21caf47e1cf5c0776014fe1ddee2259680311c3e4d52bbecbbaa6c9c3e28511946a3969897ae26eed959d364bfec0c18fca23b38d1bf4214e7c48dacf1e570d1337016bdba3ffb430c138e77526135902e3aa7a56034a44803ab798055858931ec3a600ca96f003caf8c4ad2c8623929268fcd12a945c7a1e168d3afdf587d3dc6c0ac996afe229686a3c655e4879e83ea7dee061b3c185c562748173ff292df3ad58cdbe8a4d24cf026a2179a1da6faa61e220960ef80b35ec93c328be9d5684711b90f4ac1d242b3f397ab4127c07e507266788bc1d9aa8dffa12f9a71d31fb29a49cb77aa2abac6882a7e9ad7c1f6d2946b969a0a87b7ec8f05b4b4d0c5835494dae49b2ade091a04e48ae1cf3e87f16e111d93190f4ea68906f6b8cf95512188e13c111e209e19d7ba6c78a6ef48556c2d80bdd7e8495fe42b0ffd636a9d72f27431ec84990186d245c0cfd91ff43a59fbe1c63bd70a017a4b2f7e5245119bf57bfad734cf6ca026d96998cac3e5e0df286399b3c19bac7b3ad6adb7fcfdbc1100c8767c9b1e0bb09a0e1503aa992a49356c8cf084dc118f192043810c231a5b9ca606fae11499dba1b80de2c362643b7d1752a87d3d55d6de52b49dc217c6f57ddadd43a2fb00ca342383e3f44f95a337e08e4bd3dfc8ebf590b11a9b1ccd9b01ba0153452002a506f88a084147d5334c86eae3769a0c0aa920000073ebcccaea9c46ab64e9e40e5723266d2dbf4a7ef69a85818782e742ef0e914fb8206bd4587c1c432143306863e039b7648401dbbc217c1d8e71b89613d4d2e68e4659b471f74997553c07d940c9d9802345017a0efd6795179db49d764d6a4273755c96f98c9c1159d71b1b64a8cae136d14886527ec1c47163b72a7ab195310c639f7e7173b91e04ed9c3d0eda4f6e94d5f5174389aaf18b9e8f2d75a013fa844e463bd90ad3de246f761c0e7ffef0854c8f2ba7da50ad6ea06eba93fa08e3de1b84c6b4e32e10c150659c9218245cc3fc43f3f4fb3f992f594fde84a27e087c3ab35e80758aeee92a445af011993788c6d422273c7626d535ef02cc66eb833e21c1ad6e68c99c80b74cdb8de2b8f60e19e476ca9b1aa655c64acac5bd1ce79a1814ae01453ed2fdcd097fdc47debc7721d795275090adbc84197238a7715857a49b91f93aedeb33bc1f9d951e0992288924914aca954af524054c9bc09901d35503317c890b2a643c31101df05c8e2c72f8f1f83ff91b050f199b360b4cbbd27d021ba61502390381e6c3450674e7d42b94589ace8316e0094e03db96fda4c638d5c349713c6bb08649b0ae8fcde8397f1cbf76c15fdbcf6f77315243975cbc913e1e1dfd75a473ae66c4b90fb4d92a0713fe3fc38f76b59f00603e2e4dc68073dec91c764eb2c0118f0bb9a71429d36fe41d12fb092b02970def799655cfe5ed64f9b9088d7bb4ec36d351b9e5b54379bd43de765acb68784b37504f935088aa489f60edc8bee1dc830bd9981f2ed39f3af838ae48c85b55aa51b3284d41a86584e5dc290599047a0287b7249f559d8ff41ea626148c17a79036fe4481732692393ce080dd7b82fff8c0404fd52f3c20a61aea7d2fdea2da343b04f284e5138cf9bb1a286528747fdb9652cf0d948d269d513a4430387a36b2eb2aa595067d9d7cf5f0bb3c2da5bb8e8c746e8606f881d6d3bbbd7614da07fe4760d67fadd80f00c014289ab1aee0094658ee15e5a3a45eba58d8fb8aa5accc14a3abc8c9146c719e693f2bcb561fb22277bded6bd23ad275c1c389357982e64889694994df4b12dc5a47603ca4e09cc26c1f06546db0dc8fe4a8d071a98341bde664ab8d3309702efca282cfd1a391de2c9e25342e6268678740f0ace39652787e8ab72e83f1cca761763533fe59771a15b3dd390e347480d4f66580c14c8c276f32d236264f80137be116d68b2c3b64caf2c02638d8aaa0fd422d62fd4bc0b2992dbf57104bc082d0274821d767162e16835b309613395772d4267cee683bda33c9bd9c9fe2348d7209979530dcdef9f3ed78eb665103e17abcc9b35a1f61d4faa1b4af59891e55a231b6e2beaebbb9c4aa69308a8c4a6485f7091f6c98fbd9133b022ca33eaed6b07552acabc9ad59b178fce0e1b37a5a617ac51e2beedb6f59cc4d3dff2d46854fc7b55a8214688708766b07bd863c2ad79238a1b5e146854d2283aaae1224f3663fe385d6370118cf6c61055df0e36e92e303b4a1af09d1da62c3a912b87e0b81b14162fd1b8ef5cf2a0774939c7e0ba7294e27ee39da4bc9db248b85b53c3d4b576918eb4c93a68080bb166d52341ee062c2ec10b45f4ff8bfb0441659e9e5dd20ad54cce50abf28ebef79071e958989f56fda593c1027a846787fe2339c53cce22794fa09c418294af7a5010755411004b6e4302ea417fad8eaa7e851296558950d985992b3cc6d7b95db62e8533661e9598dbfc726707b4a63106d58b5b74bf2e0df9a21333b5d02f979c59404b9031864007a03aec1b73df2051facdaf3dcc8728986c7cba3f29c183370ecd505e14b202909532d603276646a04f59d0143d5592882f39285479302557b34a427159ad1ccc65242f1f948d6cbe2ceb0e03dd2f92ca3a0eb978957dd6964aed8e3b00a850768b86bf36467d5b97172a40d21cac08c60faa235506fdfaa640224dbdcb5877cee39a8202e215b191248e215a39889ef6ac26f61682ac3f574a82de6207fe86787d070ff512a10b6184c528730aceda0a80c5292a38cbd77f2280aac009fca9a35144cce33442b1e4283fab162ce4a8295664eaaf7a89a1979ee0c22bb1d4e877cf8e77136f22af0e0a559ca309c715d80d398ece2a8c1bf0429aa94f01b37a6e96802194783b3dd211f1ccac22bbda251c39cb539c7700b1bca34b56ed0df81bc2424e69f4a7c52ff22eefe7e8442fa0ecac57adcaa7d0d3fae00686bbe4b8702059ffdfa15616d253df12463d89a2b1bb8fe39430d57d5b102fd0d9da0e4420fbc7e78b5efe0367cb2824a2fd99efe622dc746c085e1813dc201fd2042b734cb86d2129a687b1b7a2ab74ce4ecb47df4213b468febcc6a77eb384c66399b0f797c37e456fa4f56f5966c1cf268d6405de39eaa244d1401ba665aba9352ee5b95d2e9169653883fe26dabe1fe3333a86c71abd34e6d4ff099b561c3c9a0a5c6b569ae81901eba2f8ff4417a6e0703534e08b93eb4883ccb87f65b6458a24ee80b778ea981e17b5c070c51138175b8119bb2225700c8eb156620fd2a4fc7f864da8f18b5461d94d9683336974746cab27c0579696484e5eacc4680d7e47872e648fc0b6b7dac533c8d0ff7ab383c05acfae5ee4d75f89593a3eb5b246d2a851b1b33c2b35b6e7ff18731dfef36a4e369dd878dd7fdc8693d4b4dca5f6e7d2c1a355a8e0559791dcf3f3b85f85394e4e6f2d20ebfe67074aa63ffac4c43d75c2835aa25c72226d9b0cadcaab5ab1b02400a5632167ef7562f15d865808519b18b191f11c1a66ca734981438a0308a0390177dd7736c0e00efb0d848f9fca65acde281719522810b7983016b69cd34a82ce7cec3c65f406de388189858b61aeb70a68818342646131eab944406c1535c62ca025ad79043a31e6a6b9505ad43db676aacdea0e06d4677e3eee1e9b5709103e9df6c300ac9cddad9cc89e5122650f4da2e8362a5f51d9ea3caf6d0829a0f46656d9dfc2d516ccf7540d2bde7954eacb561fcdac94d49abfe8f6d13ffa67541263c3fed04fbf1d2826ac33a14088471b75e66376475a2aa97491e952db57e6e324480f7fc8818d7ce3a45adbee241daa5636e9af977112d562087cfb8674e0f887200641f16686ebb88f75517ec17a4a255d3cd1c6f3c969d73ab6a5fdff8fb3011323693a36533032cf402cb4da986836f307307b0b277557bd1d997d3e1386f0223bbbf896ad521f9ba02dc624593514f98d0c59ca3deb31bcaa9892934dfce6466df5b5b63230266c367a62a9fc4269ad3ba06dbde58d4fc70c9ff85949efee4737bb65f9aeee41328b837ddacdc4639a80b70670c1f010e1113c6a5f90f191b266941d3baffc248d71ac80b0790856cfa07fea95ddc2e34cd774e248359d91e4884d9262d56da07a1cac70936a4d56c29f904998b16f36c008d703b17d81271e421f7d0a7d03bf0d06c52e92f5c02d0d1894d3115718b46b160b58ac3b800aa7ffa3dbe8fa6e74cbb5253cbc989a8d4009db907f512b8c0d4759cacefd78b8ba01b7474dbd761ca70e5587906d83d97d1d94f0f8f7d7465b1da8c7d5a1c07e843fd639d3acb4dbdc26b31bf4e33d45e90d76a5939b0935070d520f1b2d9481775ff34177788bcbf1d7fe3312c766848f5c828a39703895cc1bc58ee6bc95621b13f09901a60e50c3a3e0c17fb060f64d55519579a29cba489b25c06066c6c7ecae4ef4822a365bd1cc3592b7ed835f1148fa5a70ce3c2099a43f56480d3f0f95fb43360b405bc2a4614b70ff04dc98093780ba15eeb51d89fab9541a13f73bfbd3dab2651fc5c65d4939dcdf19c348044b906883d039d44fda1a491da4cf4373767c317a3bdf713894b8d06b0da19446a142e7c5dbcdd7386be6bd8e125c292b1813751fa202db2ea0bd742ec257e580bcde4b588016e623b58e917b45ad750c445aeb33129bd5907c2c651d12185c31961451f881a720c03a7b1e2155ab46f2c240b7c9fff5fe40c8787774cffcc6d1ab18521f989ae67f78dc83dd3a711f70afa61dad462bda4c17c7719739060e00ac27f7227cb20a973755e1a9aa9a7df984cf255521aca7451482f858f40eb71e6b0c454c7fa9cfa92edca9eb066ac368337bd062356d56325503e0cc8145df118700e04cd7384b938e58bf26736162df7a6982a176eba026eba1b3df7770cfe0ad31015d532ae247bd49e0883b54960b76c9863d9a052291538a5854360bda9905a1005ae953284956c5e88afa3194f49688c12835f29bcd920ade89dcb494543bdaee462edc17ca821ca395bafce189a84905b7367bf4d5b26cbe0b6b7043e8eed2254351e0440d52d7486215df24ad5b9c23d78881f0d06930571fbda263c8d795814bd81bba5e0542f501d1070000fa73617b3b871623c0e0b6642cafa0d2fe497723a395ec62134b24c3b7edc682dbaaee3a2d462cda5ea1ea60f5716486cb613fa91b836017d28cf263930a19f3d5b3fdf19a458e09b7a6da498e706cef3411be7c731e12920eabf228673ea6a92ad5bbae6b94c1e7b39e3eacb8107a4dad96a13bdbce7fc170d8328fa7e42c815d38a5e0eac49b27a9056f6c2f74d44cd4e1a4f0fc7090cafe31643497edeebffc7e941190b9c843f4dd6c4b2ddf3b1e3b5417fd866075ea7228e816d70b98e4ac9f4d073917309dd1f4b744a4b953a3d5bf61e256a5118c4f5d0be8394003321bdc6fd124999a38083c4908410ba2eb3fbf3b3cd742dcbb112f615730a7921864d8df08e448bd6a4685c68fc1dc5041bfbcc9d619fb4ab681a8361d993415d1aa9aa95bbbfcce1ccac6f202655d62780c455b2dc64d442e62007f692a524ffa801cce92f9da2e6703ff938b23dd987263c952af665b8ee2e606510a2a0ba7e0f0cad807dd42160b09c1d1ffa0cfb66c503a75e10af7b6200cd39e5069b528a217965803ff06d699869cc8d331946aa23577704c2531346c8cfa082d11e6e5bf404ca1b671117605a078856c7a9bdc7189d8002c9b4e968d4bc78cc580c39fe90a70c56803a7dd8236b7a2d036e8241a23594b29abe680bc0cfff2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
