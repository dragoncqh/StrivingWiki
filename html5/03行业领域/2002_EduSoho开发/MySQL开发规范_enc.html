<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bf5732e3248560d336f3fe286c57efcb2a23c534fb9bb3d06b6eb82ba05395bf63ccd0ec2ed7c4f6970b33f92e9c1e0b0b8e0e04f3e8da0261b8c2bbe49ea5d338ae3c578c0372bf9048a2ccd58ab9015c9d777e0168d4405f7669db6ae25d5ced0438bab0dc7f235c9adddf98031ff865f2bec9ad59f786b9d91d0beb6ef5c813224a8ec625e8eeb492ae479410a987e2356d0e97fac7755f063b43740ab2d974bfbaa950013b425ee54df43a9e7fe92af45201085aa7cc0eaffe403c1f47a452359f0a6c9b0cf4ea97ec5fa72d5e4077cce68df04edf564d0ca41f272acf619b3af7f3be8b09b785a5e906a2887440c744192194d3275d032ef22df588a1a6d768203b1fd3e6b61ca6bc5023a09b2b5ac23ab49155fa89e8765df525d19fa5fe59c5c65057338a7a1e00217949f83f6903d1c475e5a2d8737c7de0c4ab416af6506275f3a2207e6bec07b03b09f85c00f60378f9042216e06295407aa0af0b09afdeec21b15732269a2e418a2d465e5a34b57c458ffae07c225bb8c2c69e23ff6a1d9c24e09755e926e055efdb95803254356fb1791f94e3e173a7d12e6bc54bc196d9e9105667dd804cfd26b5a942544ede2121c42900a1ff09ef7ec8578db0e64851f599a541b734095fc8f3b237e72c5289e157bd25edc6063f7ef8260f7302e9a29b487d2ea004c278192c098364ba147d60cb841adbc201af55c5677bcd7809366d20c78cf70864061c64f34953f869d0437e34009fea8d34f637084719086eb5434a08a656f839fb8f82a72fd23954c27083fb5161c7347cf4028e6a8ced153732dd3c1c5c564f772e1cdd8355a089e4077987dbbf58ef832fb185d497d09548604369737fc7d60bd935ee4a5dbae37f77767db496945d3eefec8ac5e03f9294d39468a22bb2deb6b4497c1c84452ae67742d2d797216fc1c05a6b1a62be602dddb349e3f98e20f4bc3474e34772925343b76617d89273747c71ff23905c863d767636f10cce4219fd0a5616432013869434d6a5236776e73f4191942c22cec85b00a1a924a1fbf50fb92989c891944042d1103397a75b1dc45b4f716fa905ca27a0f0021a6baf3d1fb1c88fb533117c823f0decfe2eba9652e77d1e6718b925682098eae862840c8ce89c83e16c87a8f514f12b68c8128140fa9b971b01904d5cd7b98e4911f4f6b60dc8377b9123de91c950949851527da453edad01bfae9b98c2bed1bb6d20a83366807df319d7e11818cbb1f4410d795bad63ff8b32858c9517e4cd94efa182988108d19be2db2784f25dd17946f3ed0da36e63ae8746ad6ba45060602e077d154fa6b7c015fa07cd2ecc2b094258fb12aefcf21a434eb57e561feb4fc55365d74eec10ff7330b784e27d1e3948164fa2799b40bb73c36e79b8b215e36da3b4df0f257997de51be22691e64ee0f1d0736885a9ecca98cdbf9837b6dd65df8eea06cd6d64e183ec3fdd17b11a3a9684d043a99e5445f5140e7676e759b242fa6c331558681289d163d2f88398ac26e36676d2c2e474fb56cccd902fae643f55b4f47afca528ee47b04a23e7219c63548efb76f47fad753d92ac52e8009c49b40a4c187df1aa3a84fed3ffcd22d710f8379ab2a0f7898b9e806619334a705ca5f07ef508a75f9aeb1db2581e660e071754c71fab66173a28a4a1e8e618e83717ad8693a7ef62d9ec957e80645dd77a9b97fcc1b452f97bfcab9d641e455bb68bd626375db1967ee9704996a56b35bd03db04d7757c1c7df8e02b9811cb61c49d684ed5325aed233d52a06a85040fe884a5631929b2bcda8650d82731069c6aff5666d99f0cc42e33d254eb0e3d18c0803a30e6c19d6aa35892a0f48597b5898b104a2e0b34aa8901613a1187255154d0cc1776d665c5c2944baab878e8c98d4d8635b927732b0895a44157508c1e86597d03c1cf94110f69786b41dc13840ce90f1d28d279db137f50a433d7d437d38e72f802711792cc62bedb504476076a2a1682ed37ad2b6108531ba69366ee22eeaa604ee6bd41eb080f5958c0e62904e7def5d389df76c91bccbfade47cf2f2f6afa39c55b76c3f16e3867432b720156985869f1bce68a9bdb427d4767dcd47d74a35ef4dabb5e363c5b64e3b782eb81bd486034a44d3fdcb5639f4e51c65c574937a508f8d7ab5714fc218963ae3420a9aae05ef5173fe6a6148727eaea24a3ba1dd2765ecd590536f1840a80d5ce696ab646503e3a0d1baf1c3480359fd619babafb1cb765bf2610eeb3f7a11b3912d3d652a0272e3f1430cab2a9c4e5842440f8cc74f62f38989cd52348fc9efe4a2b422af5a89d52f6a01acd6e954fe7a6e9bb3106de2e9b8228e3d05dfc7691ed926eb722c47de771f5e18fae78adc8a010df149d1a4287fc83e025e2b30f60056c86c447b59efa60ef30e8e55303be3114a9d32e2f124437fe85661e864b6e21ba6590139849d174978ca1316fe0d49d291f2775324fd7f06eca258e2e50bd71ac0982a7dca5fc7204e7aaf89edbf25b709ddee68a86c4117daea9a9b7aa06614fb909c4a1c9a22622a485c72b036f296a7238ed1f9d18ed76134a6137e3d00106937cc45c35bb8bf3b3e8cae3a3f6af4a1fcbcb7818b09ddd513d93654edceb1b34a7497de7253285ffe2f3cc2c197040000d516db93454e316d8ebcbc0a2c34f99d681986e59b4f432029833ca6b89cfd7e2209792adb7dde97549131dcd7288cdd209d9d2629f8bc11f371cba04330b1387b1c93a3afe3bfee88b7a28ece26a58e2f675d444dad78d007a2835a233e416ddbf4059c1829f3568482772e23bca47e21df087272a1644a6c2e0d7adb01601bb6bea781a072c71b6323edd9aed38bd7668dbb39faab4609419e4e9fa1203f41a8e4ea7855aa37b8fb9f8a08daa0c8259a10e1d8f18f416ba4fb1ebb8ea83e7d72fcd5e4aad1a35511c7973ee769f0636364dadc287550a6157c5ab593bead6ba297797001b38c65d19786757f3bc516eae9644a06f65eacdd2b856a0bf10d87469a09fcb30172bff4101b07911dd514badf1815a251f3204dffd32999f8fa13cfbb8c7d9907e6656be0ae0e5638d93732cfe82e96f1fb000c2ec8ba1a4e69ba08f06400b65ed9ff925802c7f33db564726aca338860216f51238644d494f40ea9718eb990fc412f1ffecab341b3117435949a481fe13164244db19cf697ba7f0105c2917e84a51c18df41606074a2b7ccd202d1b2f5c607b6fb73cba288f80877c5f42bf0d3edf89e4845ff567eaf2f8a75fa83ff966209c1637dfd33b72f5cef5abd8933bceaa41354087d8749f268d7ca20bfb941ebe3a958f879cb36a2bdb56f76e8d4685d8375637e071f1fcc9c0de1850e140ee8f9145e057f47174dd9cfc750eda57e2779adb62f96a6fed394610a738172bffd1cc69a686457103ee5ac3b62af755c1c74daa05fd92d86dd290c61cbc1315567e0e50870a4c6074927451f4ef75ef6148213df81cbec9888833caf8aa3657a39f8f1a3e535c2faa2cba5201e8bf2a3bd4a8a6b60b726554b044a666d1e0efb227c29496cf66836ed96e77a36c46701538efbd8adbedd7c29b3c735fdea81cd8cd5f716b2c4fbe74f445f08853beb753aba479915865e98cc0d29e2b5441ac66a036dc6918e9ea77d675723b947c77f283c5060a8aec31019fe483043af6c23df5216793ee4639c489adba7dad8e3b05e4f7febfe27d76bc9c605dc03682099e84c20aa6fd01da4f6f28d3fd20d9a4ff5862a3a1d900ebacca2dbd2a6ff7fa66ee8d1bb5f96f7b16582165529de669c3f58c88b08a400118c8fa7d996faf79ec25ce09650843df17b356675a82b282df78143b760f10001119749fc2d2c6c924d8215d4222f0acd12994b0f01ffd302ea469eb91b8390a0c45ded84279d9c94b892b7acf4891a19cda949a9a4b65ef327a55853a54a3112bb2eecbb403d586f67d69a2aeb7633836e1a44b61765c540c913ef255c44029884f40d098aa08d5aa0a9d0eda4efe4e27fd96bdbfbed22509b125d49ea1747562d6a8b1bb82a7a3565e28b39a17e3c657dce32bc502258f44818526bb1516d024486a47f5a622c0ba72a99007ccb1a1462bfe4ecb10b27ced9106d9ec12aa3e9c1ca724de3c39f3054ca66f065d944f072743f8e74cdeb2408a575b4de6980612a7010cccc073c3e2cc327bedce89c5a864009f718615ef3528fc349acee24fe25ee1d501ca7161f53c6b19d462da52d8f8c5e46133690df4562c4c9fb32c0af79f1b7fa2b4ef711d1f2f64f1fa61d9cf3452078b30b706041be20a1537a3a038d89e3219af392fce35dcd594706fb5dc6764a7fb06a5cfb946ac3f0bc64bd83eea8a38506f06ab9cf4b80b9cad5e54ea551b2d0027f89febfa78bb69e933c19bccc450e56cf2490d691f27e4efa9995a0736544e3d440c56db128e826555a864ad23f3c9943665a78dcd10142b7b0d3d358ff0705b0592ccf2573fae22fa09332ddd0eff67459637fa3f9f270101747819186e401c7ee4dcff16f98c26f67b46771133b3106eba5f6559835b7543da8745760b0638b818f2f97c8dddef9223e844cccdfa6a7dae1367590d187e122d716b45fc76c76e208cbd2d0f6bd66fa176fbecf038331e604298e329799519c280a45d8a743a5adbc2dcd5cbd0e1365680ab918362177f4a4319274ecda6f01e1b7b803980e3a87870b1cdf6a069c0bbcfc0de47bd169e20f5401337fff52ff4674f99f90b999ba604e31c3fe22a09aed92787851a215cb6881a400b51d20fa1fb812a23b93de9fbc49784311ef58746a67b2ce9677197fe38f8cbcdc8b8edef87a0de274b1ca303fbafb29ab011a545936d19344550fdca62b6dce71ff25da0a8b65c5c9cdbf221625fb5ef312db9b231faa0bb610a0a3a273a99fce59d09763ec5aa41f16acb9ca74c37ba4e7393fe6c2c8ccf8cb348ac595d131a7f9c83d2fb15271852d83c671ec9392c147091ac7a022fc8b1e3754440976f9f5cccf139bb4d7f813a7ed08d319c6bd120c273b1c57f20bf5f48873a79bb34d6a0922f188c032e8d40d7a03d269b589652b4385598448fd71bb67b63e872342ba393d14c80baf99bd1b77adb6afa9c4c28f56da176155ee410bf339a3c2c060413647f54acc816111c791d3a9ac86faa6fc5e219593e15ec397b291f416208fa726a564b63692213838b731bfc2e5f32231bea781be9dc61f21923796be139145f98eb7cfa9e3b2a34a7ecb5e56aa8f08e55413f853fb205e1e0b8fe5f6c6198be40fd4b5590afce4bc964182457ef6e35dc9c85aa6382dcc6c80d9fb46f6f6be2ca8e5b3df28d39a996900eb13e68459ba093d73bdf8cebfa6ee67c10b0192c7b774abcb852d90fa09ad54973eceea6e467f2170c9404b7e6355742177ea79bcfd60588b176b92898dbf24138aeaf0c853036737a5ee4f04c04bed0512d5cefa0ff76cda4214939851322e27de55b8d1e68fd1e60ee4a992ac949a342fbfe92d220b8038a6401cbdb82fa3b217836bf73ce66a89ad8cdbfee482ab0e49c6ff8fe663213697a552cf4128fd7d2269b1e80e75ebd6b674a6179fc88ecfdc76b950378e686373220a81ec26ae2bc51f0d48d3edc8fa56a6da74e995dfe7f3efda6126cf6d6091b7062ce4b18f07e95332180550e4a8d37e8b77e993ddd44fae0e18bf4a0b918686e28a7da2cbd299d4c267ef7e3434881481e51cc1ed61b2242e1dac162e63cbb0042dc953943522670b884c6d0cd025b6441e6acaecce575e33bba34d202af9d7e34e39a4dedfa60ea47ca15ea011abd549817ff2e6cbdbd0b666d7ab0e683a405db3a5c66435397acfff6ca9d1d32f6656ad0ee38583238d6b16683e0d511ba22afb86a1ff844cd9f55d32a2eef450cd2f183202613295bae4c2d7ff2551297f580c4a210038d1f2aa212048755ee7fed879cba382acb4ac07646325ae1f60cc5369f1c1be38e12cea1187f42bf6e1c1cc90aae7eff4cb47b4da04854c3543581792c7d07a4dc3cfbbec4096f1f21e0d23d9e04bf4424c0ca0a3a3c0f5a397aaf06d29b43e9cdee010716a6db7fa6868090595e826f48b5fa1be52d13abd91fa968fb9ef5103d77fa2b1464b9c5a3e7c4673514e14097bf21d337cfa28961a23650a6a57eb8ef6c5132c3bd57c59c6ac522f9010f37075e1b5fbfaec6c7e4cb60a92c2b10c916d3fddc7f8bd95926ea3761a2c35cf17e9a41f6294fc0651566e4116a3c18314eac4c3d58dbb5df47723dbcd43ac93121908cd0bdc3d68ae20830b6e13b47b323c5ba7589cfe304c54fe283733c1dc9d2442d7a5c3e19e3f84b914443d099d3905e9fd5d9716035fa3b2e8e12b430b86d3fa0b45ab03a0b570ece3bdfa51db65b57d12cbc6367e413641647e5dd69a6cce964ea46fdaa16f0f71c26db0ca924af97c4910075b4cc54aeff9c7ccaecc66975b4385df21d88c161b21bfb9d7c70dbcc327427a3d3b279e93fd3a09879668823074a17a6125e9df44825e8fcb87b25a137374fd28ece9fdd9c7ed36e462a9969df76801492e67ee32f231ccd4744e82df5f7e912e2461b38e40e2063bf7b6f0af2f78a57a95cbe87dfdf4de625d046a1fff1e405c3fa3372b91f713a4fcf93fbc53ec4bd85daf4beae6b6c504fadf159ded4c1a6c5a035dc38276316a5dd695fbc9271224e4f8e262b28f254922f908d9c101ad78644ecdcae08db7caecb825bd9767f6cb57eff504af3064741065e252979a74f05ce08f3f045e75f4288d9d69ec3d739b7e92bbf1d097b7663ae372dfc5eb91fc0562afed6318baa892ea61fe8e747099ceb9acba71308499a73db0c8706f0748e3f35a58f6f49af97649c673f0b9408aeae237618319dc51f589b8bb4b8d0018f27b48a59f8a10dd02325be74e6ecd954e473c88becdeb25b1b202e9711cdd0e275146dfa929a10cb3e7b61aa0156a6ecf893658c7ec8cf54c487a4e3396fdaae717764ce82d1c165345cfc445bb83ae8a1ae6c254d5ed00ab732ef0a2106132931e9e1c23a90dac8acc791fd8bb2b66949dc9c566343c1ef5137d96e3335eacda432ed24ab4a412221fa896b30ce57572867303514ba556509b79477f41cf3138d4b39a57cffa3c7272206a8b055639f0222dba8f53b2d14ed7ff9ef308e2493548ac2edd10260e065f767538494f475ec01a094d1231d8446dad508a747544b902d12fe376d01619e8f89454d09ea075b8b4832d3c723f4beacdafca6fcbf1f089004737ab93db9b9b994dd625a6d6a06fdb83f2b10da609ea2dcf18f5fe7252ce8a9622a1652f24a11e7040ae216242e060593ec2278c5d1a148bc63c0c47a18e9f505b9e3e16e42b6a65086bcd2bff4c643e55516b27c41c203e4a542f929a3f1c1dbbf86b6c8f9c08d2a1f4ae7cdd00ea9104338bead49d3db87de4addd79d6b01a4f6eff570ec21acfc251b2b9588886524dd2b2cc214c9f6892379557e835e1236629027e1428a761efc7cd961e1ec93664fe5a43574458fe454f2d74762425557f7f237238bc7c832c4ff6013f1ea36e92660a09983b7023140d076d97087abb30aed642ffd2f43cb10aa2dd49c193ce0ebc1e068f975ea18070e113a192d1e0490310a8a3bf62c649a329719e9ce4efdcdf70a6e33a6e53c35898755824559048ff96618f127de25c3287deb1d7b18451485935cd0986dd2073249aa3f350323997379d31b9a246eff60e7e07254d62c6e4513dc69679b2ac3f16693a559fcb7301cf8ed7108edcef1bd487c05196da0d340a49b9b008614bfac6b9b766d217a73a63373f10fbb0adcb5850aac3e243bf3cd89b404a48dd4bb6521a7a90c5128d1765d04f39c226c332ba6187d076cbd58b227cf3cb67a50bb4d42dcd81c2ccda8b8974f4977003c5c8d3ae8f7718496e92a8a753673c2abd931fc99c165943808a163d522db192ce92353fdf5e5a5a6e454c8cbd0f3f067f43610a35f105e22775b3b6972ef0d543c74d8c8dfd96edabb5824818e633a5a7c9ed1dc2fd290c483fc70298e8920dc277f91c8c296cb63400f98e095c998a7e46490f3ed5b7972c4691557f5c6e5acb20563813adb5a7445a4d7b1294e02217557b5f5b1efae1affe4e9fdde1b391ef151f5083bfab353c1286fac1b1bc5f2d6ba7287be74b08d95c7d3c4d4652dccaa8e4266a73db7ae5b03672e9ccaebd81797952c2ba99627d09f29dc239496ce5c821c8b328d1ee0763a910c0504ba4b1ecef541047de7c2dd6d16f06fe687f826e4a7c53bded2d7461bdb8c2bc588b89541d7a48f6672d411f5455aa61f3e156d1a518f3a81b9a010e7adf569e48de117189d1f988c014a4f66781f04b7d0f7b97915cc7b6b972c160772875761f6d0b7fadd0e46b88c65d64574897b81e4c1aa930ce2e24e6a5e395f9bd89f45c4ec272acf635e35e12959831fbcc71db5bc747481524d1928d6eeaf7253b274abac8e4eae02288e0810dc27afa7247b1849d8953da60bec5d7203e4b057f72730b5d61cbb7b8c85b573395a1c326adaa9daa5b9ee8941db5851a63532f65605425fc644431587418e427e57363a58d84de9c676ceb1e20626bfb5d43dfc1b1a6427baaceee6d14251e7528213a681e2b9d4547fcbd7f972fb123c7f98b6ac7b2d0a25e31d9456e25652ee0c3570703148de45a2e2da15abfe0d6b1c42a305e0ce80d26e7d532962608e38cccc866e9fd5f8318229989883bf4149bf16b870461fb7c36beddd3022ee85b5a3865b00105d54479ab010fb57975bd9cdc3e8f8d22b5763c78b574f3df3f39ec82aa772ee840cfe9dc07aaa8d880d04df4fc408d8ba1347d16f4ca84ff4cf069e48cdbb5b7b1b5387d0ef2ab3e0a56a965c7ceeacb787b4ca7b0fa44d0a658a1bcb17a325a4312b6c619bdcd94cc2ccf4e015f9f919782e734c55f2266113ec13d50275d9ebd5b164aea83ac79c58a79310b5a9bf2537233c231c536f7209d9e20a5777d02447f733263f65317b89b8b9cd8a43d7286475dd0f419437674a65b968085955f2eed67cb3fae4f71f55b8a5af9bb6a7abbbb464d27a176c4ee4eb40e9f66a6d0872e783151336c7828d6c4536ec787c1b747fb2679bad71c1091168767d0c73ef75ef68d64418c7e35dfc4416a80b4b17de3228ff6f2ddce754b845eab116587d128271b8a4cf24eda8890000824b9375813ece9d0b3c2340dfc5594b0d5c4402c95e93640424fff8432875992ba31c9fba84f004a538c7a6821c9afc74c88402f20c4cf993e6afc00362c81cd0939bd32da6c1565596b887d68da471bcf94da737a9c2a13c5ea87c581a680bead0e487a6daaa75e57e75d667d25d78ff2585234c502da62062d0082a0dde4140fd708de7ad1073bceb30bea335c2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
