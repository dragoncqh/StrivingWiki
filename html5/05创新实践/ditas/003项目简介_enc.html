<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f16f2b5bfc4958e59c0eb6b8beb2cc444f69b0a554a431d36a93615b3d28a61aba1cbb570681845544f7b837f8e9417064106cbdb9a56c7eda19298d9d2d60fdc0557c1ae290c40098033b155228d4bef5ec83be2681deae79c995e65ac854ffda93eb95150b01cb565ff9b2c6132eaba37cffd929ed9cfdbdeb010514bf9b29aac394d5ad975d46571832b0fa6d17cd03573755c882c90d9b1b8d88a8da73eebddf552bf91432274b88796e6e13d6a16a49829c2ebbdecc01628271445e0744948ba36d18e7fc29ea79b0ee213d660e42b03c435e8afa408bbbc624b6b46421929ac0b851fec43fc0c63183baf67768caab6095552c641679afbf8235c3d68a1ba70b4ab8808afa0c669631c4b3345aa10154b1428916bce146f0e77a1c91c5705310f00e0ce0ae076b10e9743e58fc61b267135829e7e73c8787be87467acb3f2d9d0e2f57eced7cfca322f0ff60548c3e70b7e76577011ce9796b9bf87ad555f2675ca8bc55fabd549337c0800bde886b059940dda25d69d5e9b88afa9ec30471aa0f0e049990f1b67030526763400e7cbaf267f61e7ebee3c7c56c950a97793e3b9d7805014e09fa3efecef31e2b0127a24f17bb2f38d9c9ef3ee6dd7b93d6be40af043f27f722e42eff6e21bc1e0dcf7b1137b57eb468880e421e0b58314e78d510b15678bcc6ef5d43f5570294e9c2a5c71e03c22fdb0e06e616c9dd0ae8777786951b21a85585530f8fc5037d4ef75ea0b3700600b28c6ed279320c1b846fbad3ee7971ae170eef90aaec9f4efd19faa0837a9d205779daa03e373ead8fe5df0ec8cec7f20698e7a384eef96ad5df6a1140299280adf78e7e2c706a90c082f417e8bcb613c56c003ca4458e384a90c80cabeeffd1ddb335e2ccf2df057c167db0ae408e092c292f43834d744242a97fd375d02683543ea0e3613faa6e9668d38992b48cda484b71438ad96802b9fee73239a2bb873c8b4df1e71892b11a34c077eaf28af383180797cdcfb357a055a510d6d2ba91034897e477d86f734a82d148764e9bee5f8b3944412fcee97942d9ac1a3e053ae205fdff7cbeb4a4b0a0c4a351c86b8a0abb86b6bb37d8da7d6adee1e4a5448c342e233a1b6f0e6a12a6048b7738cec7652bda368a794d9151377205135dfa35878f008c5024f970267932a8229f4ce83144e2f66e5e41c9b1afe6e4e22bf82a83a1c5deadd2d178e80554a418724c0735af7cb45a57a5e3a4a24a6f03362743bbb40175561d21358671f55e9787c4e37d33aa24d8abc0a4b8d237bd38688c56f902d6f968ad2cb3615d603eafddd2f70ba7db687d9e1d1124a2a4ec0c9735feaf8ca75b91fbf592fe59f6afc3a97d395a79fb0291e661c70d0213e089f3de9c9df40ee67a88106f273edaaca112b19e3fbc39b963ab3ec46101f3326072595ac9654ed5d2caab9a6efd01abcf5cb3370ca717482f417cb6fd2284be498a18e50696ac9af00e27af4d0c02508486a3680aab4c504b362ccc466d38fb9638c48d5811dda9f1e5241fdeb4e7b3d1645421d81322b09f7603decc128524f0981ddb829ccc04239cda1b3aab47aa901877a9e8b440b8de747c596cdfedbb7c3e6dd3b005fd3a8571d16068ac7c4549795b0a0c93b95c01b2cbb82513532724c927904172e4dd63744257057e42464ec7aafe18974969db552496e8e37c7e4a99b24ab3c3cf508e99c888ebd8a453baec418ed4b6b7691fa7cc18854ef87c57da01a1aea3d9f84812af011c3c526858738ba626752778dc8b799ecc308b0e7b40d249c7919ae65db33a04d2a28d9367ffa42433d2581a80fcc632aaa354c4243b3d3a9e4cd0c6f13ca53c8277d332cc047c5a0e1ed8753186fd8a14e2ababdfdb7afecb981920337f948620123ba2808438d16a1ba956dcf4b3d9a3145bf8c95eb69944f723f613ba920b2a94ac3e966a390804946f710713ea2f31543a0b048f1af8f04076a3351b81893f08357617bdfd7d0f01a45bf0f2b99fec241908becebfe9865df75e5aa1101735f83657f56d4260239237846410479549351362d2d9ad22b42279924cd80912328fa73745f59b1cb6b3c3d148d7a9fd26e4a796dedfc8bd2fe35fb247d2ac253aa154a11d62c2f8bfc325aa8186dee26a40c2a859899e31b99937989951f021fa4fca42a4f40dfa40c91e7cfbc593dd0c5bb5a41d2b49dec6efe5318f2bb0d3d781c31363ec92847071c8d89551fd1c2c9760d42dadda380cfc93be513be4e7aadab38307c006eb414b1a8999928af79d3d17006234d49f41cc4eb910263f1acf87829f1b735d130e592baec4507069fc28b6765f4750589eb8eeee3ea8c574679ced8811bc3e47bddb38408e4101619d96416904cd337821560c7f595e28a071028455e30929f95d9aa70306cdd9bf5142265e419935c69eefb500d7a5c24d40b0d9930f708783ffc40cc9542b44e3905eba3ca32e1c1560d34d172372ee60a5b0e75c7caba9c4bdbfd532efd5970485c5b73eb091c70af12c79e8e29bd9a6859523606f5c6053b2687d96cf294da4fa4247dab1c0ef28e74637cd8b9f075b492d0c4a295c9a9fdc672ee92976db9532d1655037463a7b48ef0810bae9bc8f0b4805a62ee5aa812907fa0256aa75ea0d5dd6e3231cce65dd47ca7bda4e93b4eda6386dd7b6eb876a448a8700dc3715a78bd154d177c3102ebdb378a66592aa397fd1b9aeb305e2df0318534639944ddb5a45fa0c25e0676c293af275c51062f0cc6754d2dd35e967a9eaf4db7ae25a62c4e919e98c9f8dfc461a30c074efcedfc8c492673c402be5da98cc8979a6ce79890f2ddb9b9411afdb84b098b00553bc89448b630fc3416565595c8f111aeb7aada358b59d3d1064d4efd76b1654b1f694f67d56a1674080b687b42084860206f98c0ebb32cfd156b189c4d1e480a7427e193498a2ce3a519c6badf233ffd5df017293fed71247ab2c42697222a2ce088ea51539d24dc59825eaf84aeaee0724e8b6350041275ca787b718bdf041d495e8d57b9582c754b6462cfa60bc76ac4dbefa6865388182993da94973a2427818a483078f59eb6995ba9669c6642265722cc6ef501008005d17ce6dd390ca29b017d663f1caee5dee435b5859cf87aecfbc21772a01ad132cb569cee27efed3184637123d78ea757856fec9e2b7a9721e310081c705b8404780e001d33c82b88d906ec53976124e7cad1c62398d7498a791164e2eeb50e6f6612eae37c66467764593f7cf3ad2f4e24dd578cc4a2ab3d86a5e7fd6d53767397a7575a5f5fab89beded0fe09e110e107880247898a2c1a9d8512cc00f881eb043ba4a3b36628de19b515a27efcd1f4ae27a1565420d4495dc1a6fbf5ae1ade98bedbbdae4237383349941becd726b531dde8024daaef64a284f7a7faabd3d51331e43148d9c561b89e8b69d990b978691185749f061bb42d093e86fc565d1a27e0c1dd642e6b1220b5237f02c1e2dbe76cd4d7719ef03db5e8e9720388089457ab36a15df4cbce4de892b205f6caaa649dd50c651e26f268a6312fc37454595cc03cb95075a59678cdbabfa2bec3298ba5392f51f091703deab3a2e06b84ed870cd6dfaff76e68c059c7b13313a148e85870cd4d5d0cdcdc8a1a07b879f12f26e0317d5aaa5af6451c9144e48150cbc6def95e9cfa83295f8b7bf36ae53724b55ef6bc78ab3cbf99a3b99db3acb71f7609a628ea3a4f85be24b84a134953603602d301d0aa0dfbd0721122dee587b72206683645ec3839efba55f9936bcab730ca5ed9d3849cefff5456190c6f00bc87b7addc1ee0426cf316216ee4912e7872f26f9b3045236f1280cf6d179a9237f8080726f7718ee480ee412ab1b3f4a1d04bda4098b2b6884882f2a5cd1fb7b8a7ef283a67549948e3c57c387c07b4669667d84afe59bf7a4e0052c4913d45fc89a29a91d524b34b43cdadb12e3353c4c9403575bae251faf045db9827679cfee3a2639c3df5d3a4d13d64d8385d778ee361f5b5d989a246da806b053c1778edfa006f9898d9f33f5f3148516b47fec89c3ac72c16b6964474b189688fe263d35b9f26c5f5bf18e10bf40dfffdee120b55e4b64578e0ae6f4f3a5d2fed648bbc4739b11939a2fbc9389d4ac823e66585298905ed5a3477e170e451b4a48ed56a1229450dbe61875b82e1ba0544cc4045981a136f499f7798250dbc97201f5cd0fb7b6e4d573c3abababb59affc00c4783e4f092509c0e91fc726e67fdbf61de7a66954f1f0cbcd5db5aaa3ab1bd59dcebbc683d718ebc1634336e142dab707aefc9e91b40a161010326d0b41b6db8f298eee1454d89b58c10ee8c867544ebc1126a4055e112f98e972313b574f5c5f729e39162644b334e27c885db3406d09edf43d54c5591d8fc1989c6cd4ed84a21febf18ea5d933af1ce7a11f9caac2c0dae9910ed0a998d22cd36828baf62d569f9ef6b99ca5bb7829b5a770be3afb1af11855b018b1b9e87ae0e697c2874cdccc88ec9ea27b6e011a643d37a0572667f1edeb16c8afd90925724286389b72035aef8c1a4ca0c1ceded8477ebeb55c0c4f3e772b55c184623191b8b6c841268e647c423377e0a0edee492908234a1a32ac07710921c1f1f14345ff8c627cbff62183bd9a57a12aafc4af3859a5131fcf562d66f3ce54190af74d3467e35e5e15805dc5f4d4bff1e08cb902fecd7657ba3328effcfc85d28997f904ef67a63cfe2729169ee2fec1bedd37d89cfb8d5678ffc28a74527991ab209a3b47b955e02125e7285b9b805f183b1cb247c7fa0eed88b71eb2d5e7cdfae95f73611ad8047af2e2a8f68a8a1d611f849315703b4db0714a5279054d41a2e31c866b21facfa4d3c68787c9861b169fd0c866d67601c9ae53a976f045f6bf49f7bdfe0d23d4b80288401742e7ef24661102d77d3b8d846db6cb9c7f902b329599de7317511cb1e937a8ea86e42f77f5de49f7c17d29b354a4c601782b48434a6c7fbdea2988f2e039a6036778586aa93c222ad510ae866965140888248dfe27ed9524a0face2d70ea4fb68c09e978214ce6d9985aa7e2c0c173c87c212f14552481a7a7d9ef7aefa97e0587d2a6bfdec9b52fee8b7fc38731c943b8c3cd13869a67cb7cfd8dc3a6f5e22633f12a3dbe49235d5063df4d2d13980af2f1662ec2f1aa35de403cfb24bdd59b4eb5687292bc60064d44a8f60b0c991549583afd45ead3dd9f75964a7665e3d66675afc4c88c0e527db0ca9e04a147c9b5a25f261c8d31de80eb85067770163e89cc4a14d8a17af73ad37c34409972be542996e8e750c08eabd1002e8cd8369692ff954073441e512f0441adda09416ce84072e401aeece725746e43a68e876287dfef672a6263fc9e6a07ed8c842c86a5bdb56c83b397b1e73a4173b6f61501eae31ef396d6dcc79f9eeebad98b7636322e6929e31afd3837efd7cfdfc97e4bd6d3b6a9518bd5b9f2ddd9a25c4a0083013720794ab210453ab006731029a2ef34bee57e680ee38530795e9d13da675a0709eeab8a0cce3f14212e9b6ae8233b6554cdf3e43fc9965ef3e817d5bee99a5711f0c77ad7d40b62eb5be59e42c35244b04a265bce13f0f33ec6ad53880f2d3c783c6412f48a87a770e68ffdc4a7822493fedc3e69256ed02bf13b97c15e12101f069b164b86206308fa7553b8eb2798d8a0025074b25907422c7116264c58f439fb11c60a3e17299c2bbc57c66c4972caea9bb932a8e580c94e3b564b63a9c7abd21a0e7477310429fffbb1f06f5ad207f7cf728cd31ba70710f86b065e89ca903f0d225ed4442666952d7d2a76ebe4b61689970fbc0926f56bb756b88dba9a8467f107d39500621203390c8a47c6bf96dc5d3fab46199fdf98d6d6a83e151db7cb46df638f8ee6a0d424d7571a52bdcce128c993df92526c5966aad45bcb587e4f715aca69feb1f9093833fb88e1211ab3d4a7ee4ed5b16949aece6a2e7d6aa7867dd00240cc7df1747363ba401add68fb8d55b24be6dae4d1b1220e97eac21150dbb7e7956ec4d30bfc7e79ba6a3ed619bf6a2af2855fa853dbc904eb9311732a639333b8120c4e139de6f0edbc80cc36ae681ac475e27552ac6aa07838f68ceaf243f687364b0d6d971224b837b47cc66dce09a8cde9b1be2f1b986531cafdec65c92cb70f867fd51561749d3d3abb5f1c2b1a6a2160e12c9b7839ce7fc15491091dad56a84bb45ae4ebf429bf198423a6baedf22d48204d0704cd3816354512d0441562b2ac3445c81a98f2a941199e9c951714e523f1e4725c7946802fbf37c785efec637b97a46292f7ae771dc2704d1dfde59175fdd9872599ace955cdf5592b92c3f2ded73b4f8a0ac4449e55f3a46c4bf212e7311fed8a78905bfeb1c731fd12586e3d23189a1ce6f851029d3b6120b7d021ff9a6b4c02351f01c8e61bdbb516e1b57593e7c617a23428e442f05b4660cd1f798fc8669b4167684859b329e35b439a8f24ef4931ac01c7b734e6541cb18c0c153742ee66e109c5ca9abc9119ec74cf821eca3f66b9cc67810eca6775d7fda8b1ada7756a61cd5038e071ffca7cd0f0879dcf1e2540da92b8a82bc52fb54628746b3af35efe8f0cedad0028387ef6f82450b90a0862940529a1885192ec97b70102a1809cc6b47aa9deaaf1d128ab223a382fee5fbf8515d661fadc57dacf9f92baadaa579bbec9ff09301c2ca977c02dec978ecdaa3c3444f4eabcd4ee29bc79afc121212114bcdf38c092a5dd5fdc3afc12a69c2f848b8ff023a0028b7ab508432a92ff8f7ec8d4195d16c4a4a22f071b1ae45510afce39448b15e11c2e8a9730b6367ab9f9a517d2ce1bcc5dc0cd3e79035e6d641048254f20573d8662f8ceca8e72765c8f1e21caf5dc00e955f1df7ad237e613fb9a5e2d3418c733ac1532b3441a41dade3f659d36b6d926e11107123c0275d82221b39233b126c0925aa9decc76a7660a9076d3795e783beb131a7f3d3172c8f9df9ea7b8978965475f5e9f53cc7f333828c4d81d7cfa4053596daebb3d6b41fb449cbeea886e1cc00b997b6bba8d5f3ea3079538be615ba33d8138674fdb8ea9bd7ae7026898d4598a132439a4c7726e7a56f103fcdca8ee4252c8808414e518d1d5c7e8906ca4247f5cd96836f82381885b246d1c58b78e075afddf581db1a0ed3724dfe981ee0295f4dd8a4dd484e44445478e3281a0739c59d83624a805b9c178bebf4c1e8fd2d42f0fb6322c978c301a73fb263a89fc4ce3c52373cabf32dcbc3e6d4ed1b681b1d76cc46b1be09a0b52e528044dda305e4996197add7facf42b7783852e8d40588a355a63a538b9a80b9d4be3e9feeb4571f1833f3fd5ddfe7cfe9979d871ad5796422da0dd03293aed699e2067758d520cb9953ca9346744c4487eedd2935858470323fb908d2defc389315bbacf11a282e0e5e615ba4ffe3ffcde40e6be1a38595e37ad457a9f975e7e82eed6ce3824a8a273d30e9954ee385cff13a9d7def93aef30956c8067cd1101104c343b028516ef1b55351618ce140660a4f0e9cb1632ccb29f3de7ea40be70d811aeb2baf0f82c3bcc0cc3e347a875fce6677833f631c80c305b839a194fe0c94d0296a8fc058eda082bf8020cc1ba59e23b2ee9b770d40712f17883ab9041ed580a900687b0e7c0a5bc3f417027e973cc552f6c129a47cd831afbfbd2d8a6f88b48c7c94869eef44d3b69a523eac6fae5c245c4f1b3b69b3d4db60e78541d23ba333e5e63820b76a053b12eb905124163320a8e6b95fed9949fe2f95c595bd921b389db5fcd4e39a43cb1de5ff6da1387764f1a971bf12641e2d5be51ad17de954d4d1b29ab8081d0d71b6c5fa90cbc76e297cc90dd74ab33074430a574376e31b28eeb1b56289a577edb42e3e8c540bf10e57f3c55fa84af1d541ea9a73ecd5965f2daf62f5c510fd0b4154979b115eeda57b0f9aeacc818246dac79e0110457e2f8f9002ca638d381781205a0316dff5160ca7b41c68614d6b9ac49bfd4c6750eb36fbeef8af8cba3f86105873f2e5a9a469a4e8f21faee8cda67170c645b6b3ce2ee0c91e585eecada4c728f0f01266c8c6818cc82d659088ee90cab8f2213a78505df5bebfb86ea3ebfb43a45c744bf8954d39c320c4f02355f5497774ff93152a5ddbcd5032bd28da9a81e44d890a00542f0565f834c844dd366b8ba3540a232c2627aa13bad1ab593b6c65c7e021697dbf59f4499e3380b97e61faad0729ef593904df36dbce02a32972c8e5811775623f1adff5837a3eda9c6a8d063675757367145ed8cb8e6e7ac275afdb2d7461ae4048340f828978730f33e8f1a0ddb7ad75cf227992d91fd0d739cb62336ab51780317c89b9c5dfce77fb21bdd1eed9e936bb56183359d0ae16df72b26a10f7f557320d8f86ee768badada589dc0d43593684db6242dddc6f0342cfeb9f0f76c2c8c570e2dfa62b18d01901ca0ab5e10e7250782e96987635ee5dbe67ead931018e108a02958b85cf0c3e31ec35945d96e2ebea54e67621f7853c932be3d5e17aeb26ebbda4077a14a29685607f3fced00c813561f9b4528fba619a23850313d7c376e05e4bcc8bff392b3cb091dd21654326e1ae38a0f89796ac5da1226b99e166c17c8daa6deb81d15e6e7a2ad4c0cfd439ac096a0fb750ad1178b7766666554a3885dfe6e6262770cb700ebf161f5e670a22b65ea75099aa05218122946a91fb7d7400860b85153b9178f1d6eaaacb0e624ac7a23a954e80ffced78b2737b3eb50e49b3f4aad1ce51ba9a2fdee3384deb289090ae4a2bb4faf68f58b00557c0d160221b550c42ab9331518785a8783ac29ce3746d19c2ddc40404c3594407c4d7ce1fcd5347a94ab31ec12ca5404ed2c2cad83600225d74a2f44767a6ce57bdc8b9f2ad16746bc3874a3aef2c1eddc3b73347994167b3c0cff3b73bb6438dbb48b5f45a08bb6b632e0aa3d02fabc2bf3bb99e9ce12e47070d12100d92768a0c5221b30c8cde1e399c14033f83080c40cb6b361850220691616eab8feeceac529897ed4fa363b674b5d30adc95eb2d9243d1df270c17e37eadd67207730d96aeb1c5ccb76eff09aad0e52d01629ebf7685be08e79e174bbc3aaf523f37ce90420101482aa7838ebacfcec9dae4259b23f7e73cd75ee15802f2c261704a411f62e6ad772c2c180495aa49b6bb8baef4a9e05a59c52ac5f5169916e645972998ee31bac7bd758f10a15ee25a2f56f0d89220f3bf1eed1fb476f7b1c1458423645d96116ff2cfb25f36df4cca79bd9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
