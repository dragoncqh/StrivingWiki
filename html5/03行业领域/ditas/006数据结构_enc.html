<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0e2108e8d160f75e5f336793d7105d08a4fbdf7f1e1d898ad9c570773ee318c66f72d3d13d51f5d6c5f35ba8c59b1e942ba8a455f3adbf86d1fdc99e57907dd46a9bd948f8ba4c39431b62d6a83b0cc885f6f93e254ea487fe7d3c460f16b4d4233864eb233b660b31d3101d87637b763f3650b92b24212489d8711acca22c7e92852e078bf26c99d60477a8b71a887cf58e719f2dedeb72a7f30f0ab181d7be43847c0960d22c73407e1fae7bcdcadd46057c1c097d9f163098a6c69d6fefb188dc3cecaf0b138c9a6640eace646a962111ec16ae065ec2646ab0c16a55ef2c8fb8447bc635e9b6c4bc50b16b51ecf4114805542aadcdb4fa8c8c8fa6ff21e0633184da00f2f5695a5d66d103fabdfc079be6869734482249d7078b2a9bdb5fcbe517b6c3995e10b01023d52fb405c17598ab065000e659293bb447a917020b38e07e7b481f576272d28a1a07bcf877b159f7d72e51a2faf4223043f9caaf2adfa5fec8f7271bd5b89a06fae268753a2828d20f6edf9343b670cc9b9578b02a5dd488ebf305e436e974e8b6b2ebd37b2c0cf9e94d5b6c05f9f78800bc103aa3d0a2949aa9f2885830c689a045ec54df9ef6d026bf3973e26cdd6d158dffa9075c0b00c544bade65cbc6ea9872157e073b068f0ed92da692f0035cfc08b6444e7696c3b642be33eed80490e6b36062a7b2dfb4a38dc0e8b8026879db521d459391c8f13abc2519471e9ba0ba4f66ab7f190c8c317022376280381931f5180ace3a4a57af85a807e0af9321986e1ecc7b65a354abb932ef70000f0acad3ff62ed15cabbb2aa99979f0f610a775db120b546a6d51f253ff2f736d872d99dc80fcaeb33e29ae9460b45f7e56bf6a5e7a996e32947ec23cc359ec3d327786e334204870f9448ec3ce915cd06ababdc93e1df6c357d1b76037e43cbfc49ecfaaf23395969bffc4e09f2eb6c0ff1cc4f5c39cca7b28cffc257df73e805f58f4f584da3620f2b0d8936ecddc68591d3f82c5ac0aa8fc0896ca5d5b2b94cec75d91e0bd6255e8740263491aad8bf72db028286419d46d9be42c69199b1e7c3c3891889cc94016df6960a5ec5c1d9bf63e4c254fa13202174276a0bbb50b5f7b12aeb19428f3dc352a029f8eb1638a03dc631fc594ea78cc9881433f64180b4670917503afb300b2c1d00c373ade56e311f60ede04bf656785a63b5d1cc8e71109420dafe3c8a1186c2a6e11b13d14e4afc6726d7f53ec991999ab1083ed5bcf839af8bc1f0c73b404c03adfef81c762f9b88f066e6de98bb027bed468b713f4efb1cabae713880cb8cfbf653bd3e508578debf246a7f41bbce5ea96a73537d832614e998e05fdee92e5238a8f427b5988b694cd0b9079e7709734aba50f6b6f07d41f0a0e73b5ba47007baef41df71cc2e725dacc7ff080bd924127753d76b37326b5d1a69a9417ee920813a198fa2331a6092b02f12b53042104a45da1e80b0dd23c19fc8af96fb8b81e1970a9c02fd73ce91ca5e2b4d306c3fcd528729c9139c22d404ad7d36442437f17cdfbef90286eb88a1291a55e7a899aa6d2d41c82bdee810b35581f6eba50abfe88b8397697d4c9ca8d636eabc6c42b6a9ed2494e9407712f449b6c1b02a59b0eca7bff4875adefb3a85b0fa6001d7a92cfcf99e5ed3d01fe9ca1be04cbf71d6a0470a8f83b2c848a3a79a50fe2ee8d121050a902ddb315b4af34804f6722fd66ea1070b90a917b630099b96df3858494a7197587c2a349737bc2b8b2e193f500856e608090f21d4f632d4ad948c06423c7d7da8a81004d5b83b34110c38c4481de97bd08f846a56918bc20db4a6f8374af21b49a61c9b6c63d95b799eaf05dde0079fd7c00fd3b31ce2c5f34ec634cec7cc047980acb5c8903902e685512b2c2404e9f15bbf86faa999d1f06e4aff92d057941be5e575030d6bdfd1f57a055f3c67ab3886a653ea34569f7452191b6740918e821a3e2f580dd496a66cd6f7f5e1640b40dc4f8f6e770f4c6ebffaa2767875ebabdcf93113f445ef42013406879564c1b9d638498037fc9d34858eef9d82953f4da2233927a14c2a8df74fae17ac5ed62d235165f9512112a90469a5fb75ebc5f6abce67636c94a28c5455e4d05308125c3139da917f787e57af4c94267ebc523a1c955371a7e90f48021ed0c1aebb71f31ee5881dd0d4f8acdf2d159fd9edae0fabe4f7b8ee51a76323af8436c62734fbaa786e5084ed76523b3f7ba454c6fbeacfe197b38ac3432e99eb94553b3251f27afd70e280608047d0bf6f69efb2432971502f912f8fcb83116d8c61e1a193df9b933ea17a02aabd288183ec7fbd03764270ec75fc412db0c1abe0e6b798550395475b93c54240406dc3f4668e1e3e9e2819927a910d4b7150088ceb46b685443aba6426be32515a01ba36216893ea4a251c127c109c501895d3ef71dc9ad440854818314c7bba4dc2f7c6d258ac74d76e37086613d0304a858af1322a8364a95969c7c9a6e5041da4e461fba2d522b8f32f0b26c3b734fc7183892645928357441d08623f2cbf26eb8dfc24669ca4f04cbc0af8a1f4efad34d98778611e925e4fc0fd5537c5c12eae06560b7ece7aba977a27a547575195a48e9a6e5f74d538f8f2497023100593910b9bc0cd9557206d5eb06f2898ca4551f2a6db64254168853a14731058aef87b816bca2e711b01b986a364edb2a65d4ad07e4ed6c5868b894e3bf2ab161a00a361fb7fa54749d087ef15403fc604adedb0717c7ce3f0ad114362eb69e18ded0787a0f274e1a6459bc49c42920c71a322599f4ab2dd46b636d6b5213563272a9c9cc3214e0479ac4eb3aa5d27fd9f42defc8cf49be6d4cfbd2f0c9b184a8e9d8ef8594c7e123f7d4ad030b7dda4106d280b65106118a3238e92ab613182ecdacfc299603304f97b047eb06c2f2fd63ba95759ca09a8e99ce4bd6e9a6cb180ec41bd90946e1161fcd4030d344d80e311e10c4199876aad5288e9b937ed3b7e22c6f0372a6077d7c8ca0cbe5784ddffcda0114a3a4c3d07b9a839ec9b28f8a5e5f766621841ae653d01e4c84b4e8a8e07cb857c9300f32c5ea4eefc8186801d8a7a6dcc2fe15ef4c97f9912c71ac744353d847ecf44b0d6521a14f1a2f9bd1e518f4d801184aa24d71ac99f7e0b3eff03e945cb59d5dce4b63ccd4bf02623a0d3c6e316d99d35c410e357af93c0c145a564b27fd16ab56e6fbe1a206a2332288c7d85667d33777ec22e2953dc00e448588da625366c43eab5ead7e06ca91b047817e5d3c17bc775524d151a757c1b21a37bc8c0e935de295a63eb12c1c25303b55c978388978b307dca572d46e5093f3216b82840f1975716d7a31fc06d5c0917e8bc8dac2c1a0fcaf4a8dc3e58869537dc83bc23f68161b76e262b8de11f3d53dbc0bd46b400fd99c3297547f34bb6e42c5d6068c4f70d3bb4a1fc15dea6fbd096576f2dfa671508ff9d8ea26fed339eb294a7424af89bb61c91aab88cc2d94cb61a6c8747a6ea3d88993ea70cd6b2c144f09b3441b348d26ebc83122651de807797452d695ff8f6b6513ea05dff5ee673f7415291f8ee33775066f3a327a82ece78c414ae3378715062e1c64206ead9307700fa857b87b9e40033a241807986d945e7b92ffccc861c7c2089a34b9ab56e3b42b49de220323f1800a561bcb80aa25a1f74161f76ddee4cf73029855619121e69bfe189eddbad90a7f686d3db49a49f8cffa6be9bc412e7543ac182431fc06820030383a4e6a3552ca44af72d5d896e28a978b10adb4606b8a5d869cdbe44aa9c8deb80a459f195020aeeaee47f46bdf079533b711d058e8b3bc83937b2569f87a2381edce7088e28f8592fbfab1aa06fdbdb06adc5ba722b9c804a666446f74e80351f2141416b7393b8e7aff4de3edf14665e81cc93aca4ed17dc85a1303feeef1fcad302aa7c0f311952b23e8a58a9294c3b6184ba4a8fe78fca953c1a22e7a14479828d7ea6d49cfd9bc709a90d19f0c8d5a5c1439aeca5937c4faabc4fa9bf7aa00b8e7de2c266de7fde88c912d4e2ff7130001e9558281f28e6dae6b4fb3eddb993384e629d3027c8f3d8ded64e6f5bf4353df7691b32407559a412b2ff146fc1d195af2e561d7ffc5952f230cd6bc346e13c02bc9a8131f562784f7b3eeb34fad726bc7c262b507c5ab0a2188b9595f7c84f2e8f3ee743968ca5d38774136b54509e44791b944754be2e0f860b0a0f0e2fa078fe36f281a37c98db24cec1d71a75389134fa20fce89d7f48e83169f106dfd8aefe2cfa2a1adcd7caa3e46a43dd9831f2e9b3f67c86b4c1a1f0d1e730271c5318de072b8c25b7b2a8b242810468908dee6074ab17f37febb2181d2d84cabc06fafaf2d68ffc33b5d04cfff2c02a9d203327c08faa662fee1de62f6c38bdf73e3bd5348886cc2952638c329699dacdcb588dc5f56b03ec1767a182b6d236aa1ed0023f8d94a2800a352a1e9079b2da5e1cd43cdf4bea871c8afcda2a152dd880e151abf82b814760b80ca813b35e3fe0b05d856b16aab2667d620286dcfc35c9145f8de8fad88f4538a7405d40bf5930d0116475d826b33844086c09f074a3f4d5aa749c8e0185cd0f92a4710c0122f9ed389799cd095b17bfd449e4aab3af4a33892a3d6776e51bdfb35a7476e1a8d04070e8794b424599885bbe64950daf3b9544cd502acf98a883917497bac638a62eff3c2588a8580006442b02a5c3408ea32d4ce4eb8b38aeb1b4935fdb3a3e35cfc98dbfa158027c87d8b8bebde6c023b154e9adbd069ca4949f9f660df747e87951a7eb34ae40d11362a9f8c1fdcdca473ba46d0c3c9787f1a5e10d6196728e1a6c5779cecee8d7d44c282138c209f137185979e9cfd40c2839ed3762c266cf63d0bb1b94959e9cc9c494cad69ea4f9c5fef0c30db489b29196169b3cec31174f8952b30afc754d4d10b68638fd765e9d0aa72be23a719b2bf682dbf6aaeef64530cb48f552bfce2191a55b6c51679dea5c7fbf93559fcbafed2c348353c6722b81d44dbbfd10e4ec57698cf92a20a1d499e94894ae393d5700b23e53dbfb43983ddc4c34f0c92494f8ab43b0521f1fa78e3af55a3513cb1efadc09cc0af1aea1dd509137a802badf924feb975a9580482ff415c7efacd07556a81ccb0c1538efc39b568a56c74b71b55e0f42670b5b2a5410863c62ce5d73f36cfed1f5b4081785ec03d03a73961751e070391d37849ef9a99587c16b54605e967a2e3812f182c4a9345800c440254884f261b254a618bbe6132e24d90bb431d4fc4910b52d305cb3b41a6c57ed92eea27f774715cfcfca67bfde2d624d97103f50329ca0345ef364c64eaf3e0c9b84d2a049522c7e2f6962744115f5d068813886bc3f4129540afc998d2da8d5d7b6ddf01f642e6802588215a65e1c9eaa2290fbe0346119a898883ebfc26fe2505ebd00e58a8f2e99a0368b18abd9822faf964e613dc4d8a0c0aa0703cff668cd2a00bb1054db15c7049524ac2483a5889becb506d3548c8d90ca2d4442d8c0189fb07dd6dd02eda3a282d739e39678c00af5c572f911272a874c2701fc362d4816c904ba12944588c5cab370ac19448982b3edc050a0668fcdbcf7afeeb1df167bc9e35d0b1783a824b834e439c06d999c9e7522e17bcb37e0cbca291aa238865269941fbbdc06a546935b241e5ccc3df0220a5293b709e5bfb4ba348b1d415aab853d53079c14ad34bc2f6d5adefd1c6bf4126e3ff04b6d05b88aaf81a31ed5dfc089c89c6ce115a43427157d84b02e0fae116e1c75da4aa62930e20e672dca0cdf0fc2e06d67dc6bfce40b680d0cda28020b1c6d308ddfaa9a807a5919c2e9db7a816b023f9cb0ffa2dac7c62ce2f1c09cb6c215b96c4535959a57703b26ff6a8cfc1c63bce5ce4994719a29ddddc49b57e4d2720a2dc3c42b2f3b01b861414abb0097c65f1b98911e86ab6998af8bada8492239de94c89ef01aa46d89c03c28a6f414a6d686534e694c269a308c22eb3cc6c3287db6b2bd3a62b5585b5fc8067585a90a39b34af42b9672f4d43fc600236b0f618c31fe0e393be6970480932a24069a11b8065a9da7fb7bed0b13f6ba1351a8c1be8f337240a691baafb2b9f258a227de9d3c879c72d0a9cf5a2af3a4eb3dd8c669da870efd763e9fa11bc152ad05d072c610d1df8139b773c440946097e080d429da17bb52c6d95e0592970a2755e9c7689d9abe977062d71cbea96d3ad0bbea183807e9ab761bf9e54f2c25ce4a4875de47eb7ab165d1a9625b48dfa28bbf46131154bc848b05a1682890b113a7c51cbf908302e953d67a61c7e9b13432ed284a1ea39f27e2b0187088455ef3fd103fe5da01f88f1ee8cbb26be7732621fa50fa3595c6de6a22c71f047366fe471eab79ae291ccf79a61657d1a2417f7915d49aa358ffee7c27279139989c7f1415b3da2e0f4396e77501241eab091c5275a9a5ac129db33ceb5e40c134c3715261692e287db798ac9c10e991382b358527bfb3e02812fa61cac3553f0f28d083213c2940b7014cf95e05c51e5cddfeb54a8c055507d4026e71a93fe1c75541b3016f27ce45cf390aaa646ba08d2c93501a0108d675bb069f860a84b32ca778d73a92e081d75be5fbb6e1f2d76c0f5ec832e3b969471e2a564c279a8cfe17470c0e18757a5345a0baf0bf60b58a451d7fd4d5a7461d76b6c8ceb1aceac55857c8b059fad196bf578473c17b1153af27b37d5b59c8aa4535f643fd70fc4df0727ccb6f9f9f2f1fc45b0cab97536207131a0abc4e55823718209326643c3d1d209baeba2307712b1559b194579e9344bf92ac1d607619b6bfe1c179a2eec2a192953c0bc236f20da58c80986c61fb643350cfe9b90238d8e7a40c42e17e323986b8c00557e4e671c486a1071b92fe6f881d7430b245fb3a57832ec55d706a09c9e9327d7a976512b522c71b053d5079b8c3d4cbf1893453197e5a5f3d2be5eb888b2869c2704fcf0f0a5429bd7ae4b05a275685bdb2b1e7c6d932b22aace36aa257c994522a6e00fc67f023d2fc3068fbc79032e41bcca5539a56cb05a00fbf2a3ff7c5988be78eb1e19c750da2cb488c923350140994e0be6bcfbd2b09dff3780e25b06200ed3bf6f20ff15348118701c45f4c10b2f1f9a02f51aff7c9f1d1f1895286bde195b46af24f4e087581b9433de2160df54402f8c18014030e79d78e5fc0fc1e02281836fb622fe38f359f16c7b0f3d0fa3e3a962bd091c157edb919437d4d16e9a6241e8af595f4218f173943b3d5984c2ca854e29a105d85520136186cf126e4b514b98037c1ae5d4e67d8f36625496d60462e8e301b345253c4e1f0d8af7974b99c842f1204a96b73acbc755739d2baf34e9944f83ef5512d7219dcdc9e839652387c3f557f65315b5a46af51679ea2f1c23c64e99a61617714786d3a18680294d64478cfd3513358597f31b7c570be492ae49a409b00556d4c03381343d2ab2ae602b258077927c748fb4b5b8b87f94cdc31ca994cf3499b71495a6c7370f115c7c69e1023962d6160b5ce7e01c3841e1a0f307d70b7a52469d257b8220d8082f896f0db4918d4d0708a3096fbc70e072d265894e7e24d04add0e35c0b3dc14edd3e185b7d3b646b59867b13f3463bda31b008425b366b824bc88efe3a75bf78f5d3c85cb7d82af0952bd6ea74ae6e9861e288f80da4ecda0615ccf40ad9bbd6db48f270f7574cb43c1a69d12ce33a808f010b31b7e670689b6165f6103b5343ef3b84a6ea1dd6e7aece8f7d77736160c39744907183a3c79de37bbde736bca2a2e4634c0ab1f5dffaf9cf7a92c2901758c9a7417dd7fef5c1281bdcbd83f685c29080305597e6fd484bcc16f9b5042eebc4ffe3d4523033d172b2417dc4251f2b1f465bcf6032e578b8b7aaa13c2aade0489303da4d3a369ea0a3bc93ccc7cef4485a71b09a056d247422452e91efa9245d41926935f7f8e2347dd921d6c8c5bf1a0cf7d8433ec237a6417e7138bb28c47605b567501925fd355dd22cd5af029b6553b92b9782884032a2b4535b9302657599e1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
