<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c34a15ca288b1e860f02a2ce4d76f64e5b3068dbcdc01d21dd7978a90622801070cbb8104c4bb1041abd8ee71a79793156913909d17a05b0ecd0a5cc7d43929dcda22e9d0cdbaf71c76190ab4ce363b84ce1c2ccac061803bf2057dba18839c03278b58aebbca7f51d458499a5de0f78add05a7a0df9a5f24dd034b91cb47ff5148a97dfd3182a7a3b3a751b69a0462dc29baaf326b5f3dbdd3211da5dc94852faed1a1282b04bbd75b36dc12d46d6f68befac13f21d71fc55816eb61d140968607fdd64f0c31cd155537bc434ef4a2a5263bbc32a8bbaf68f559b6a276dccb51caafc5856965340d91538325d2f9d92e6aedc38b038791cf06b7d14febfe2da7166d5ad44cd4a5523cd22a8d0189fcc149b6ccaa3498ba89866bcc5f4910d9a71b97fe2ec1a4ff64c5a917bfc9dc1edb3ea88d1e570e793b57c10bff183db7e32914355ea96cef4e84349862d1a254a80f446c76a405651c0ebfc0902899447130ab76d72b7d356f5c6cb326ce6b12d3b50e0e31b574671dfe1b72ade8ad2a23d2c2c02f9df945e5e3e35f3a168e1d47efdac5177cee9a6b0097fb96ac06eb740584996fb8ec87e393c881e4ab8467ec2b6e09db6d06f9206587d497eb7b58be6b455326000884c14a39d4a8bdda5d34403d5a783315ad66e49da850a747c5a0d882e9b1dcff6f6486dc90822097728e93d1793b40e436f9f53c1c1d313f10da60ebf74f4d013beee31280fb33f55692f5842dd1416e906746e153a8fe9bd0b107f84e6166adfff8c8fa39c95ea1c0fddf79aedbe3c650926341badb9f5a6d5977c4cf3f2b93a3aa9583cb89ec5d1b4910d85be3877b9cc5082b36ba8bd0bf68b1cd8e3f18102d939f2c974f267c8f9db98515e735f43469d7d31b99d0eee2e6915cd38a50659439ad3f1c6f3e5a425c48fc7b6c2b9cf353eceb14eaa170a0f8ed5e965dee5e73cf7e72c203ad76cffa6cc454191bcb0d4b9e4da314088969da9e77f4908918a8c8cd838a453bd818eebd0693760d12624e5447053041857758b1be0bf8c1174f6a3ce0b09e0fc31c0458535bc8f05abfdc4cf8fced4697ae81cb5459de83557323f3c18483fb87ede4f30a2c909e0cb664bded93768759a9e2007fd105f391e8375f4cdca3e61018dabec09fc2d8ea5a2145aa0a8792a86ad78a63dc10b7adeb9e0afd47671bcda37d653bb5312db6038910837b49b973b5f208e9e3dc8972845f3d3fe9e51488e7096bc490c50c93cd9eaf5f1c9858d9535a6071e2121c8901e49e76f483ad69e3eaab2c8a9c038a136edc50ab40eb3f7db51a7398445fe53cc09ba7a439c0f2e5f8d1c4eb7a75cd3756db4d8f71408e4db21f43819b1fe7ed73ea425a07173b57b0adf9b6ea970f9abac889d9869049801482b7f8d6dc438eeca75db2e003536240f95d6fbc24dfb79e052c6d72eb0c2fafef5110e846a4fb0b494c8081641e18342a431df8d8fe0809c4df828ccb8240f71fec467ba8500645e19f4219b6a36cb862fa73373721b51fd3e4f87d13ebf941c9c4b8bdc31e5bade353c1298bc844f2efccd70516d39b29802d83eb5676f1f4afcbe5606392894bb950fc0cce1c77c4ae4248c25e51e17cb016c5af7a965e5bfb519a02ca4d828b2257f33b039a51a0b5b393b2f12f76423f6b7b1f91ade24a1910e002c4b798009133b6a00752993d1bf76635fc18bc843be9c2367273112eb0e715d03ff6966d41f50ddc2e65059b4a4ba31b25b70ca3abf79a4db5df452188a19ff92d585c09817d025dc060c9172ad9902ab9c178b77e19a7afde8b75aacba92bf8c288faee476593fc1c0d66b68cc626938b6c3186cc551f297e785fe088313015017318df37df36cff1e7be7d6b0cdeb18033b86465d42ab6120b1697ab458275ecde3d190928dd464baf97bbcb67a43783d395ba6affba315b5703c4370769374d2621bec0fbc201ff98909f77d5deeb3e6d470b06857b8fd1b88611911163186544594c6607f0f0d87c364d3b4f5ad253a93c5492be391e29eca0f7fca3910db117caaa09a944c6a575624b898b0fafb46fb65fa807434abf976a469fab09584134566e53bda7939dcff412d2b07c7965eb6e2de044581ee6ca58aff4cd60f83d462d42833400fe690f076a6f0e0047bf8a83f8d232234af3c8bb241bc65a26fdf78538e520d28b35bf083ca3fc708db696046bfdd5014f09a24a1f053403a9fcc11dd0e82d7a901059a34f1a52c9b15f2bbd9f95d12a388f2de5a0917e31a2387c07a28e26ccc1bc0d56ca09231a043c15d53a7bad2e99a48da1aeb0e03b5efaa9e70ba63bf2bbbaf67ee2350223e5900ef90ab327da2505e529f4659f585090dc00e6c1dc115e4509ecc3bbb294f2288a8d4c09e89f518c168cbe779251f653b320cdfe8867e70bcbe54927dc95b17ea819a899de046dce39d3fe170b2e6656030c88e193da535d112c376658a647bc3b6dd8ec0e3cf904bd8d8cb6cbb5b8aaabc547d06453338e730cd2e21c77136bc4454d1a1492aa266ad4426a138069145429e4a900586736e2a9dd8fe7f75a2d1f46980f55185cc5f1a53a43c1e09ba4ce4788c432b7f1f4e8ce9e77086f33bea4105e9f4e5e798df8ccc3f2c1e063b08695ff26213d44f9e2610f66c1f10bd9fe1b94735c014ba8c342474029078de13cdcf009e34efe0a6ef87d348a49cfb2acfceaf1b804ab4af2bbcdeff4385fe50db7feadc58b6029a7f0de7515489a41efeb7845f55c9bab5f6893f05be5ee1d230153328e9862d58d4fb0ca209744bb6e9a4a8329143ccf7609a632a1c5f0e20aef7c045aa368a2567098e79afe27ffd549c16107e796b8a1f253c954da6236aff89a65bd31d151a8e9b6fe62344d4f80748351ce36f788e8c7997cebc97f77d5148c236289bc19c4cb7cb693760b8c3e8e56af313c8b1466cc7a29718256d18bbd1ea5adb1922b656a79a14678232ed68248ce4d2baf6b8c4caaa3563d987a9fad14e779b484a9f8c2518569496756c245b5f682efff18d20c16599517f50da4ff1f2eaf6fdd0a7c1bf02ec8421caf80423bc710626d08987fa5e3732713c7db04a76e8654f9f7022548e94e3f116a398de900f3947bb7fd5a53964185329097df46512c6ab51bda63f7dd2643e427f7320261fea11afeca3f41bbd3ac571a94c37600ad12b8596239660339ad2e38c8b17f178b15c4c587c3ff739c0e85f43fc203318d3526c863e1252b221919318d248f41196fa591daec02e6bd32dfb5201459e63188b030895fc7a0ea73686e491e8df48ee1e77978c7a54c5d11a19ddabb9ba6ee01d81ff62c8e78467306c8c443964eb790af7a4b80fe01eb3534ff619392c84f42727f68cc2c74bca81fdf08e8784171e17778b31d6b13f4d420d3ecfc6f9c3945e1883d4793ecd44ec3b5f3126c0c022e2daffee051c05ad0ed007cd774a277663a1c05bb3558b6aaa288f6adb507a426af7f0d5d50d8c9469c54479b13fe64ca49f46496b37237d34c88fcf9bf25281b51db229846418727a7072397419e00c96dffe948b26a5fcc1011194623d2f1f23ff9378ca5d2eeab86e19b1c66412c731f8eab85e3f8805b2c398a2d696de9c49de329e4d53ac1051fdb20f7a2d1fa63b743f8aace18b0909ac5a6501772f463aa20ff1e5f7cb85e1f2e0739a6027ae10788f9364e99f638d43af482b926927e73ea8b1827d065bf5f224c7c845f3c3e7ca1a9edccca1538d7fc709f485bc3c6a694ccec382ed7986e10bc5e96eae46403e53c57526642e5ccf817261127ca1ded3a14a8d2607209cc1413f937107435db363b0de5cb138169b3267862f2cc861757df875b84571d23a8d660f04d9cda84615e9d65dceabaaa2879db54d4bf9966f714ea4443fa1fb6879ddb7e83f4a82155b69b764971fac34254fdc4df04fa0a738dc7d11e45fcf9a6301394e2e249a7fbe5557006913c51273f99469cd87d78fb4d0461ac935ed9e5ff2889f4086d3ed6c473d0326d04868bc1599c634c3582022896149008ca797c23727e424dc9f05bcecb2f8cfdb913fbe895c12a6f2d59cb6257670a0210b2f41982ce56f2811dd8a165b15d1dcf1e2a99b16f1d675a7b070402cba3c71f7b340406e57a462b33990eed24165fc1f8e21fbcf07c927d822df51c53133e454dacc7334d5c94d5b7aa651a32a1e209f85ec2dec3fbff53fb64018796dd824bd3068479337864aa4b857c235f02cab08f54594c5b7833b4c84d1bb2fa52b6559dd3c705e30fa8cf72c047eaf7e4dfe6fb88639005037d225b367d33368d5017c3f32e6e05bf3897ce6e8d5cf76bfa03026f861a446bbfa16c469e107c2b18f80cb2fc076b770c23c72b15e51d986f975c9f5830b5a5fcc3bc968a7c956ce36dc5fe39517f34e6aa89102664a48b874327004ca0eba889ff3cc18f9526bc1a3fb64db24b76b4fc13746166566edb3f2c85296cda3f0c91a97827ce86d56fa3a75e7e206760722206b54b4ddd52455c71859b56abed67e07795080dbee922c16c3d872bf710d61c3686592a05039f501ed809796ec2e92439ee0bad6b2d1f4e6494dfe8f4893180618f26e4ca10af779eac6f2894ee73ed9a2aded68c038d60cb70918f86a281b420279be87383d6419aabe154a55b9743cd36626c495f20ec56206c324b1d8a48e65f9cebb0f753bfc35e4e57e0bd57a2588863b85c50a77a8b8ef4002a46edf1208354b75336821786d53ed9ad06bbbdd2fbd5560e3fd54019e971fa052a85192888318add4c795b2cfdc32616d03081d13b85f9fb8be8e138ac93784c641d1688cf135d9ff6e8c51b7c2c9f3179cd686d3d47a580ee372de59019d345c9ebc595b13e4c8de38138f8eed182dc50d5d29e9bb0e7ed7497b47e951a19809d9e0ae27712a5158d2e2656a8d53e807e8be099cd140aea30a858dccc5bc44f7b90e1b518ae018d22d2eec46131243daa6ea059769bd1cc36b1e34e72a3669e610cb282c364c91001923ebbe06a822b51e5884ef8719b9ab260f8fa950c8b5669c8c257a4c272b93ac1122dc9d11ba18924f0d5d0d057075c0aac9c4eb851f70946d05134743076999974a311c1111e220869db785e35e8d1d54b773936fd492100ce986268b2334c37f391b727143a2a9f8df1dca28d400e0647e0933ad2133cad9bfa6c4933dbec37e66cb51be6483aea477afc95ad68388f2134c21d164b3b020436d04f7ab8a81cfa321428ec24126cf242d9c0bd5ef62645e6a59320ca9deaad123f5bb0fcaa3426a2b158d35a3019042f65a9e81d3dc8928eca1e1265e97c86889b2b9d71ed35c85f12ece00cf73117f383b332d8175fa83e2b720daf369b2dd3cda70c5606082b300fe82c307c433dab3df56c9a54d75ccbccc9c5782125b524ad6057a77ea231defc467d04e0d8c51b02c75b13f4b6b92b573cca3f1b9eb5a981a633bb999e3d99fffb307051d7eb5e0800e77076c7d3c2ab76ee62e9706008d30277915553e0277109b8efee7feb8d2296e07082f56627797367e5279bd96759dc7a0f2a0e1b291731f6f3e501d1c5160ff190286c69d0396e1c6da680900b108fc7f5b8cfd0fd779501abf130c49fcf13081d9fa4eb906fbac5f9bb6c0de6185e75c79c7fc50ebdee1900694b61c7f15ef914ab58e4eba672686bd583df46babfd5c1d61a1e0adc56672fe5a4c0902f04a26d22effca8163d54ec1e92474adfa6fd9a6705d7a7bc0252473bc7ab9b7cf40451abc3d5a409bd1d56bb4511c690da0753b59ff1d4a8c93df7853dfe2ee6b25a15c3156a32d9420f4cbad8a4d5c3768400cf98ecea62e143cf6fb92519111e1200e731f031c5dadf4ad88fa13cc165290af513337a69fdf95fccba689828102189bc6d90cd90e13e96713f61ddc254b99841dd4fcbc91e7c35420ed3410c9b22a30aa9e3a0afdf460c439abcc154d4cbad5017cfc199c6ff8322af7905bc6320c9c2144f9b0011cc70e0003d4b13fe7df01a6b8c0176a2aed2a4fc364cf9a39ec298b6f997cd711f31a907beb9dc9d363728f5a63149b709393dc3a17248bc61ada304b05175addd56cbba26614475994e21624bfd8a1110c8ac465679c29921f5e72d3366f79e148705d2a5c435f86f400a0deff6bda0d5c52a36175647ad23b14e8d88ebb9d278c15167b64bdf9eb3b4c0cab3fd1af2038d937ae1b6f26f3e7341836cbee872315737bc9362e9054d10f6e2dca877794518c9ff872c06d2bee624d2195579f466e2b28986879817b21a562ecdde3dd6b61cfbfe899743414bd3cf96fec85e3d064ff1be301870b80db3bdd201ca8fac4c3ba17208ee8be4d138681bf01d0ac6a359f1588ff686d5bbe77a5402b0cccc9e095a7f4a275057dfef7b3ebc0abcd3ec02dec8d770de1758082d70a937bc66e2cddd75d79adc3593f54f11a334b9438f71bf33a9dfcdc75dad3839a9583e22f2d9fb2af51e9ccff9bdc92319af321cba6a6efa4d3ba90b96a19d5df895311decdf932df69f947caab241c669b3cdaa30eb45322e5ef4a937b4cd1d78272a38994f4d82bba1abb1597e3db87882e150d00af531a314a13836e5ee19da5d47dde76ef8399ad589de62be5cba0cad8c6701b2fc177568e943979d3b9da6c5be43dce08e29c4935e1b9bac094b6bc62c5c69d8d1c0692be77374cf089575a09a94ef19f5b8af92ff722af8e9b4fbb687d63c0bd808a9460bb6f509f11e3ab28de941287587d5cfc4a15f180f4eb277fd76e4e64ebf345d24d0cf98f23d0e55c4871e8d3129ac148a251df9d4985f05f5b828e4f99edd28818b95fa3bbc2246193a287d3ba1616027af8c16b2dc3911df43c8ec80207006cfea6dacadd6bc7f4b84a26d2dd1d069187dc26a39b36e8b439508a38f92281f380b6513da5e82b8748523e44f79f995e5e91c1ae8d4e3a500afb92a402dc54b8e7ddf677536b8fdea342b2e0ea72493468aec613907e00b7f161d8389078d26b9a4098f4f41de2317af105d5aef5e9ebc90480b9de18f63e264de3b1da75cdbae633b507e5d9ac6752d050dd4756a5c7d60536d830912bdb5c80738293211ec64238f2cd7164459f165b4292b0e3dced28320ae683ee93b046fd72fbc5f0032228e7ed8184d49b65f761e82eb4c4f9296a48a670a0d46fad6cc57ee4ebdc91b5443946fa5a331f4dd55dfaf1473f99415e9c91474f240d27b6371561cad054ce8a52a22045fd19d13da8646874a2958df2fed404387224863367156e09a3c3b4efd9fd65b75354bb12e5162035568026589eac9cb8e236f0465f3abdcbf4fefad556fb67476fad7ca05a5f7f374c4c1939acb927d05e412ace7dfe6e3f275f45e367cad6aa1e24ea640c809b52c5ab6b6dd18677520b3181a6e611e0b892f14e252818a619e0ff72cd862804363275a3ed6120a5bf46710e8cf1221d6452c8adfc6b2a6ec06dfb3f3e9b4c2352cfce6bbd4bf68eb2686321ac78fe921d741318e4004cd3248517c2f717957c4a01c3527dd455750da46d3c30c27e6891a444e93784ef755ddd671fc295887fa9a2d6856a539662a268a264a1d65a9ebfdb8f651f64784bf7e913fae66f225103a254983dcfca92695ad8ce004338aea1765c3193bd9e32c2834d13e950e9b474e5be734f97899389041bebffdf41d5b8be25a7993b5249eea7919a16805a9ddc1105af36ac49f428bcdd4b6e713abee980bb886cbe767967c2e61b8e1ac2241f9810181cb9918a440acd7a32687863d1eeeb20baa62895231226dad28e5f01b12efcc8c4b171e8eb6cb67101d90d9d390f5adcd200ddf4a2340e02f461a95c4c3963bed2cd5055593637cd4676567ef53fe8046bf148cf73de362dc9ae4434c446c731e3f411c640ccca79f9d4b67dd08d2567241d184b90e3559812801448505f059b723efa3f6d921260956921e70065a5bf71d45cd15e913ffbf2d950c69bf886eba6e2c632e3f4b5c1f0316d2d4e2c5e912bea3ede1ce583da251f68d16c0afde000fecf544c0d062115f8d36f49209d72d0354895641fa90fd1e234a6fed11306aaa189284fe6b12a93e95ccc1dd15fe2ccf4511ca589990573b8b9411bda6167446a986327a5bbbdfa8afd6f5fc5df7272df78b46cd0ec8acb0c47a404d48edade4b20cfe88abf2aefce484847411707ee480c28d847a887d09a873d1726c413b74964bd2fac1a46c280df7bbe86783216aed55ad766d4b697d852ce142f64a7119f37fd20fef496ea1d1f470ca3ff4c3ead6bd96bdb62184ae35e2f631385cdc7975280ece95c26274b7aa71b2c0283867ea1bbce9526ed7b5997589f17378308f9d75c08673bdb1ec972eef7c3093da05b592e6778149ce2b14b3e580323ad9023eff298e58cd49b138dd1b1a27465c3423b62f2e1a23051987b12fff8aceb2cf999dbed5c5f6a53c1ae648f50c39c2d8bc35290757323045ca6e0b58269f2bc57e5dc1464c4f4f8ce2d5960a89effa7ba91cffe638c53fca1473bca6b53755dd18fd7ecd459f2b2a5b20279455f2371f77af3aed559a7fd9ea4489f86d5ebdc20eccc8a575e532af9be22af0a8eee271467f7864f1609a6c99f7f165f82a188d36b449a04deceba2ce9622858a2793c79fc3157b567b976b4afaf9995da587a8be3c6090ed8c88eefa78728f9a9b29c9f88a10a1fbe55009bfd958e95506183f78244f3e9f1ccaee7cf6dd19cff92e2269d0292c362fa56057fad88dea4e3f819f07a2804fb90dc7aae01d0b98bc06ef9a3c4ca3cd3ecfce57b57368a0b8e57c95c24e79d96871bc8a52e5560290a112a8e82216b2051ca47026345c136e3e0ec0f0870199cd753d9f52d85ac5b72d71c3504960e4a0d881862b5bc29e5487f9ce58cd1ba553e756903e24ddc89525226d0ea92da48a7e0bf0ea288a36863749681e212578a0696e1ba5cbffd5fcb6a46c5f2ac2b6ef6ebb6a4d926e83edc9629d0df75b16a82e3734f9fac144e4c64db8a0f5b17360ede10fe6fd300f11dec7602cee21fe52ccfea752515f4b8afdf5be8316c2c049a781b21486dbfea0d0eff97b468fba310d5e61c507b8518315ef7fb20cde15f0bd6e6704afcbb9e919a6ca6dd899775576382e01643001fc00112aa9bd6afb1c85f6f9a0869cfa422465158dbaf42078dc50c0f15cab4bc8584a6b0a4ad0f7e46945b166550e82e5330084072a4da902d5b14acd832cd228b7806f1fa020dffb77ca56ad51c5dc55442922162986a4f57ee3ad79f444a33106747037781466291c519620ff560b345ad1d060299baa70e851718582db6541408e4f008","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
