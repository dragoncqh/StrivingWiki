<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a596c34c87d38c6a8eef8cdceaa388e3616b00aa784ad62f250eb454b67c27957d99e2863c02583fc334f0a14d120b4ab20cd71a5850a4aa54f63ba4fb197b2c1e845376ebc00e9b7424cae5f34224c975176b53d9b28656ead26affe62176f008225d84951dd8e6278a957e7d931dc3f5246aebbe442cda74b2b517cffee86e34282d824a7739270e734bc359c8d0b4737a9cdd21dfb29d2477c46a3e32be1a62408774eaa471a78ac33db9413969df93c1f5afa52aaf34c1febfcd509a98ecc26eb5aa32b912c38b0e269bdae2d87f0107001f17d853826a12838a234ed04de2b47e35eb91be7039516f9e0d29af110ad921d5d316adbb71c68a0739c42b51cd5d090ab7f1a2200cef75ea6dfdc3668484846155b1f998421316bf80221f0d3234e6f177e12e1ad0423825e38e22c396642155c46294be05e119ec3e4f44ba94bcd911c02414dcef36c9484d1b8bbbddfba620e4b00d67efb2db636c5a1623cbf521eb7531bd84652566dea9e9bc0be6b2c817fb8993dec091bbbf21406393c20f6c475e9a458ab4a46caa12a3631e821dc0ba22831a946e37af78dcb63f34fe9a57b2d1075a6a0dc88f2c135c9683f3935eed6bad40123ed17af8ec1d0bd98b5edba50d4842cf290b9e0a0e2e970d33e5576177dc3dbf7c13555f920c4cce9678d9061eec4f6b89a2be6b45bc790d0fc140a5330dd8911f4afdb5fcb50e0c21f509ad1f31c66d578d5303608c0bad4a1586862d9ec5d3e265324e092d8bba602d48bdef232abc5ab72215687bb518d79b1e69ae2ecc461cf95f8f5a10a9b1672684fa2328eedcc95e71783d410865a2a2609949ee052eb99a4deeed70e3ffb9b07da63971e2b6e764d2981fdf320f0616e3b2d763962b0b26c1bfc9210fd6acb50ab093b39afb0edad6ffb692bd7aca4703c8ef1b86077e19ad8f6411c23c3b7f6d60295d429a466193908b78fe943737991f2ef2245bf60f29227c5c78c41e19c0d7d0a4d1794ba7c1b50899f7a88b1cde23b70a162fdeca7c759ee7cbf7562fde168e0263b8c56fd722faf03e3778d9be6971dca6ed4387681a292cc8165f3d4d10f3979e99ccf5b8193ab9fcb8e69e5063cd2bb8bc7045cb95f100d898708aa658014487c896047a8cb0928ae7c2c5f2e331980fb11a69c94fd8cd69d2a2c945a4a06117b3963cc66406588b5f2128bf48e9ac8817ad763a1bf5d0557d718587392e1e3641545444a472fb58e38c217f3870179dec658e0381b86ab889426e5857d90f91831589228f0d59a2fa1a8a39544f2df7933334962e658d62cd0cd0cc039ec68ad5865f39e4304713fba23de4e1408fdc1fbfa583ba23ea849b43beb0c7aea6a64a5b694d561bbb7600ce4fc92bd5c128dbec7a205697d67c8faa8f205ebaf8d351119b2c89aef25aaa70d5de4f9a5795e53189636ed9db538aafbfb1240d501e3ee0eff4e3fa8aec6177d06d3b2424a3fdc7d3d508b87159b58ca0aa32642b4a5088af8f543489adc11d2bfae07462fe5751d1adce4fab7c5557bb132f382821c5ba1f3f9eca3f86adc9e537a9f79c290629ac6ce60c3d3386693b12cfde5b8b8ac967356f1ca717e0e4d7ba2c9b5135a2061d2bf3612770085f0396a88997e034681e8d981ffa262b9d1079fb67a8a522f5abdd6580e470ac4b088f8610bfb6e06f123d45ae736e12827d6064193268bc84334ac4c5bf1975140f6ac0599320b76b75786bae06e4b61fdc9ed14a4db720e7a6a6bde20075f300419b504505bd2ca5de63fa9750b4fa91042483c486de9a1c6ae0570be296a3d4f72ea6f5dfcb001c8d23ac43b3c9c08141d2136bc9b6c5727570777f9384eae4f654330ce1cb12cf20c285c6bdc0bd90aa53c811991e8840bc8cb93bdcb7893699495bdfb77b1120dd678494e7e775da3d612c9594a3705c5e98a9c32fa045842dcfff9790bbe51f2ffe162b195b96d13fcf0a5f53ec43bff0cb31d11f210ec7e0b56bbfc37394c8918cf5613d758b2ae1d49ea5a9f83e59313dd968174810196b525948640e8f4c44d55165100c2eb8db0a3233d90195e9cad805ef6af57edddf4140e836934326a43cecfc2d9039e7f973b331c87e49c44eef6d225c4a0cf7161d0ff66cecf8624b11ed2c1b13e64bca9120319aa6dde7f633e51de9798ec913141ad29eb88cb27c295412964a956b23030830f911804c7118f773dfa759e918484baec5b625b5719511587455e80019ac1668ada1f9842bf869e0fb8dd75487697891d670cddba9eaa440389f8ad4be380bfbc7106a76a8c07b125faa94051d52db824e64a7762ed2552626d4dce16d72b791b9b1138d2f4f1dfca28feea5366902c70800a785412a898899dd48919b533fcd2c1403e4d9dc3070fdba01c9650e37c4eff459cc62b29c5aba6746d35dc97bf3c58ee220df540cfdd1dab3a86bd82f12c54bb440619d1d58be627b6abda29e983c39e752af323780cea878f16ffe6a1bfca18df19305f88bee9161b965a0e902e93ddca63d30aae42ec91e5e3708630e5b7a49a6ed998857902c2ba1c72f84e9062c4dc304b9ffaa1e45340c4be8e558025117d6f96ac66fd3c8219f5fb0539c941637066a366ea025c15ebc358e069ef114c9d35a3da0a1596bbdaf648c55b54e0876d56817f0f467af5d1042ba061b3702f6db85feba392d872e48806710cb98d57107ce8143524410f0dd903e381c39ed956b9d4eb8585469f3f1c7223ca3ce1c55f00ceb32274ba63327120fcd32d092421ce30141f861824c97180142a2a5c4e9ccd808838c16a46c373cb779055119b04c1f3a239f0bbdcc65e85ba231e32173dc67c9389d5ca58fec0ad1cc2b8b4a01e2426bc692fc5029651f504006608b4cfdf487c4aa24417d10e6c4b09320f6e94283f8b6aae6d143397c10d5a3c2ddc41f600441cda1f0a25ad6b4c252952a6ff2777f16f63ba840410aa7b57d8a03fdeda2a2b2f38bfdbf6b56b77c0c0fb0478979f49116df0b6a01d3fe712c1b3e618c9cd4f3920f306eac0035b1f1f22ef539158a859b8d0d6809c4a01055d574ff6531146834dd9c74e74d443af8ae6da9a85b406a3aea9df4a7126d590ef6d66a6ac72a3aa744846338f0a35d26ae95bd06ea7d12f3e78b7948f0e0db2f0d9c43ca617cca8dfd2a3261f825190ca2c3ebf0323a73407843d3766edf6af86dbe4bc9413450427de60d3d62941e8746194b05e9ce3d258cbedaa851edee9599f9ccef9f4c6cd44679658e7e229c8dc7e84679cc14f7acf1c8ef91854c8359b4f9d44397d7233d9f98cc1d503515ea9d2eaa7ec86e977af6751f6e97ef213da6866ed2395877a8fbe779ffe54c6762bff1f402a0ce4342281fcd02fc324804acd75978bab35a55115db213ede975d80c2869f2dde62d4d26eb1d52ec029f9d438a4ed8eb4e27b5b2d341de70f47859ed1ecb23269765b36b41b6739e6293e7d7e1d5c53a723361df90da1910862e07aee181b7ac7b29d37f839ae448afb4f33ca6d0629f67ba59a6bc0db3ff049b8abb67be805296f0a9efcab1d31bb9f3243eb02992ecabf9abf73965253ca71048548e93a45c96bc1d51960b14e49b56d0b989a1134a5b28228d09f32f6ad7555d4cf0c33bfc542b90979ef7bea5577f1a22b5c5c2a8fae0e98157dded3365f17af62154302acb78b2df0098e0bd11fbee9c3c2b37f8f462b19babecfd21398b6f821efe36a5461871f0b7fda847400f8a2096bf2e44b60210c747f5de5fc594785e02f002fd693b84fc2e9d72ac38c152f432af0ef8d9fdb8497fd93dd04b153b6a56e410ff69ad36833e8ed39926df346bea582fadf76c7144821fd28851fa1976a4ba9234fdcc1271e21d1a0b2bc1e188ae62c327ce39aaf1d2f418aa73d29c87f48716e0b36749895a6d720a895e47db2465b60445cc1e75e8360e0d82e0f7b4f0be699e1b06eb78b1ab2d7fc8c2b986556076b9d9837454219ee2fb7676242f76286eb9152177171e11f41ae3dc9da9974ae33476b228f318476cd73aabf7d3fb682243314860fddc3f53a2f87b312204946427083818f284d3ad555439240d93c4132b9279d1ed9e022c9f6940aaa4887e750f44af5116c93dd35f5ac7c4205c4164acf6917ca5a6b9a0af59852593d1e38336c3b1fd87bd8dcd66d830048a1c4453250be487132db20e67b0e2eccab61ae358a791f6c7d0f89e27a395f4f0078f83ae4007a5ebe9b60f6ac4b24fb4323a68b0ba602b6365ce4a6c6889effe14998f0a9b542045cef71c3fce18ca5d8272f8db7f28b0ac6575541ba2c83ee0960903bbb3d92ac5cf75213610a405a597e1b9bbec18ed770a9cd6b7240e9aa400941a0186d24d973b697ce8ee1f134f8bfbcf6c3b4c2c100d286d16acedad9d2b550777dd49e31abfab5c1a46f082d0cb7d6bee7abd0643325196df4d17a1f6c4fca863761089b5e93e359eab8c299289766bdc69804f513920563fb874463a276da7961311c8dab8ef48b24b086794676db8138ff1466f0cf1d77019af6d262928a9fbcb096aa22ca8ece74b9232a80e5425a20d0f974f6a6415b92f2ad8dc68216843dd4893e98a6f685526cef3dff866f5b8b72d9197c3305d8291cb6828092bc07b5cd9ec54ddf40d8789881852b7fac08be2ba6bbee12bd4429d7ee7ca289e677254db20ea4983a0b0d05e273dabcc553a8caab3fc1c776a0c835fb326079059149edd79f71caff063cae58f18e09de4a8ee09244d669f6d7be0a37f2318588f006e879c4cb8b0115b98098c324fed2c161d8c1f5652eef2a3d18f368ead55d0f8f4dcabf56691e72d445fcaa198c6ede7c6b9aa53ce5a4aa50e3a959f4052009b5bea0acbff7bc689ab0d62edc988860de68e2c9ca64e9088439b64a784c49bfd354b05c1cbe97046b5a881cff1563c23e48a6d7ebbf83af79f53789dce3fe5e9f4f082f2ad5ffcd2cc0f0dccedb8dc2d3921f4d24787f2be548b37f49e10c4427af857f11b5ae0f91a3b32b6d0dfb9f52068f66df715735de1b28c2484bf0267e97459b2a3e96d7da5084715428b6f69bda18ef2a023304443a5d865eb94b49e9582254511cbbd7b3f5f70e1e3a8874930056705342a13e4e1a4e19c4eb2a60449196077d9f58878345caf218d35301359dc7d507ca6e6b03e9c8839577c95f701b5d5284bba197b670e3173685940be2da8947bd37a973bfde68ac86ebf6abca717110679372786a17d3ef8fb5568fd8a58737bea4f0115f8d2105b8a3b932615c98c0ff5f5e86fb71f0ccbe77c5c0f0afa0e6a98b672f3a17eb8309e0809c8ee6f81d2fd6fc4728a160d6aa1d242cc9c4c81abcc8b9230d6361103113232a29b27ee143419779e49c1332a398f41bb49eeafb795dbed47481df65f3610e77695f8cf16f23fe87207be1906bf4951f8877c250366d0f344e493c218de5ade165dfa32a1a5895230b14eaf5dcfbe908c99c0a0601960b65f817adc8c91abb7393b34b992f8e9dae3ab59ae29ca3ebd054b9dbad0ce5fc271dd2abdb3e60ca6ef06061fd4d78b7ff798d60d591fc66c33711ee26081d44c704ab7af41b6b0a951e692ba4030e0bb14621d51fe778344fdf2dee9fd22bb60a633ebb13f2063ae590a70fdb0676d5a16dd72bd4698962d3b4248dafd87d95e0d318ade170cbd1de0ea0f9254d3e7ed4276fa364b30ad198e4944f5b777ec67dc132954aec2695d2a2c388a18d4c5877e7c3afa736e91141e9594bdda3ad5854073e6559f77d06d8aab8274533d580f786324a96bd151735f1e1ff81811c4666e59fde9c6f4218af6a962bef7059280986916a0ea72a570000ca0932d08f89636e23369814fb50832399fb85f62d241849905cb7bcf7b0b8d16c1293018d72aba17c74a330e5e1b6490e9004a12a8c702e408cd7b3c86db99dcdccf1b9d9ab68291d5c998ca0176d76e2e1276ca42903f275feb4d69603a034dcbe8ffeb90a41a64c4d1ea89ddcccfbfbbdc2e1a71e36be5016b91d241bed749ccecfb7af1105baeecd6df54fda5e0759077ceb9516b618adde485c208b4f05c3905d1fe28c09294625627df235ccc56d6c515e869185bd9c11b251c3cb9625284b2a2f84342c1f98e4202653e2f5f82fe2dafc71d76774b19b41d2e8ee4928689a3d8d5f094250cfdbdae05a3d54176bc6e02bef901bb36ccafab33f5f21d41e6be6ae5d4b489392eefa9f90969f40146c279c28475256f794ea5bd2f741d2ee7f0fd1cd6fe3ab5d6351977213c28408929d60396c8774863f6bc64eff5258d192599adeeaf37816dc0b057280062dcdf20f10c5b4a357f4d8f1ba08a14e32620b95c4c7afdaed48f8a07615df2b3e018add9776f26b04dda2013b6327397bc0ae279a6cc0d806a40b68d57c34f222fc4e6eacba1629e4d8ca43e8fe91a8fba5b7ea218104a85771353cf318d29ab84291d5c7d8a5fae3edc8d7e409d0fa4d0bfaac9fd9ae31e4e1e6f11682631bd5775c2db35561e29e381bbe0423b4b34fc6082bab78462e0e1f722ea944799f2d19dd6b9a5636f5571b9ff60db65afcb01ab3b1df95a161294c163f4fad4c3044e92a1d13ddf220fa25e5f210255b035e4bab40a41a924f9bffce9ad9207b095488ab2f0b6015926e5df87230a4c4ef32e505a002fb6a14799388643f3a15d23c7629db206a3ad730544cac5d6a3d25fa0beb13213159cbe80ac9322b0fbdb9546f5d62c4e5e66bd34195cb7b3165c672714901b9d1fd752d468b2afb9f98acd77a305612b377078fc99c939ee7262de73c62fb655cd19f879f154622ad139316fa81bd06dc999bd79a2d2eb55d6db12fde0abc64801475424573c3e5658800309f337ace22a33339a96ebf7d843113e860b1a1e4d9bc159f68fb6ae7c13a83c98930046d0e940ca55a4e99c370693f11f760e9e227d087644391337d9a0873be2335a03d67f269de2e80a73ddd47edcb79660fc6f30e585189cdbabc098252dfffdc01c5a8c4ec9dbeb3afc8bf3dcc87909edd03e847441c12c5ab0fb532b653d4079d832ee7ac29f136b60e9735dfcb9b995c63776cf323f6f12baec555c519047b44b722be6ab12e161dde3669cb40ff83458a11d414f348ac354710a795ea849e6c9cd5467a2f8235cd701e864474d8646eb8fe7bc92b2ace01b1fb1f2e0e9b70f6eaa01f2dc2ae19364575fbe62747aa27ce6fdf8cb4623d191e0e4d0e4f4ad5b2d66957e18cea51b68528515afe190f7e1f223b1419a959f211c854d2fae2da3b968ea50e91d486b0bece38ab5aea642ea3a01b2f5861d16a76202ca129e71bc32aa34d339aa9c292ae139d275f46ee78cc4331977e8d83c18636df1860e315d06813b73f94588a770a9440a17c3289f85c38f0a690b710e95a5ec7039b7032fd141bfad1eafc2aca5941ee070b0840afccc722c920c75a5e03a5dd3f98d78af08404c43cab6274d84682e07e429bd06622ad4c87eed4766e6cf42d485e4b645e3b3ff2002f00da4ed76a291666a62d5fdbe076721e85796ff3f91b227c088d870543e3aaafe4141325592832733d379aba00fcd1f0aaf352786cbbde96523c15b6ba66c726bbbfecd2b75be18dd9866405cda398f1e96b511d49c460fe1d7c17c836cae6194835d99e8bc4319ae55c8699571a3dd2989a5134af3a6561933b08a2e5f1b45279d2303d9f2d15ac7a760a9e6dd81d99a863af0d8ed573cb8a795823949631ebdb88cf87293df85a09dcfe61e81df7517cfcfff2174351d54b174f14ede34ddf2df3d61c729a25a38c16608bba5ed18f38307bcaf69767ec5d83c2fd44f83347fab5980012cc57ea96ae622586823e566271467105556804419709d9cda76a2f15c045f53fc6970a2e25eea4166f0cab77098a8cd88e6e44a5fdfed214f255580e0b4e5d31fe81cec8d0a6bf1f7b422bf95f65d2d5ab663929e87c9432db39cd5eac87c20879748fe6285ac9454d814168075c51257a2bff1d1021d70eb4e3921410124bf189baff0fdf44b39a64cbf1c03bb45bf6cf3ea532d992a26184947d43e2d708d87f346e295c3785627243ef8337649b370d0d499a3da6640e484dc1de2089e193b0647657b5b861563f4408faab6cd1b15058824121db7e07153cb96f8713364ea773048f389bc27501dc016c2c8709cc93b5d6e379d035497463e7c56a7c037b3b90be329e145c40b5bcf4342d4fc84eb40da37ea82b6fce563af0944058e94f3342c58a9b79e3996d2f644470ff806a82344b95a2c69a898c224157872ed8723ff5b97b3fcf6c9f890593aa26e2356e3e9090959789056f4676c0b8e0343165c1a3fb4e433606541837d9feb191950c9e3eb48cd6dc6a0a149392773362a068730135091cd34ab387b86dbc513b72ff1662ef569810e833015748d9ee5c23b805fc6a35d2db434dad986f301cc5fb26fcf10b18be798f0488fd7a698a0176e10eafcda11476f2a0b6a4a20c641b7237153bcc7aad2d57e3d092cdae22d8d31c0abb66957cc8ec112558aca5a8f8c1a0f96bc446fc831664338a12b459a67e1125c01775a9a548802e93e473e4c5cdfd3f0fb78cb2dce49fecbca863868ef92258b7b156e3ed429be25c53991eaedd0fdec2f6b19dd85ff1dcb035209cc45364c4f169fbeb708eb7595284f8ef89e3a353a452ffe8f69a4d71bdcca93e859f85d9fdede91684c0eaab027ad7915333768eb62fc3953382107b96e21083f52f1809b2b7c30732ba2a0a987e8518f9de73675170c28f95be9e1112b397648b3167062c7850e4db9095367ec2104bbc24f04677dca27b76cf337542ac78fe323758c315baf69246a8277297cef52d9ea438cdada491972262a7bcb0a7fab2a8f227fa52d44bbf74acfe86c51ba0c1c39337d94fe61d5c44a3df35526bee403fc8ff92cb35e32da4d6e40faf6b65e85f184e5dd1c9e75b40f888905f6f26eb6e56309b017c75fc7fed17358c506208f127c3b4647a58900d32921b71e8bc9593fd20cea5cfd225e9bdb86341d02cb59bc91b7fead1f78c77f67028e84401ded08375e10ffb787900ca9e1c27b7312a02714d5d21a8be1116859291913edae52bb537c500f20ec5ef3af8cd206b142a3c3ed0be7aad2a5ef50d1bb24d044226553bc8f7ae4bef56e28e16edcdbce21d34aa0c52a22359dbaafc965d87c8ba74a01f5e19dd40de9882fc4ccbc93961de53ebfe1e063cee24447159f3f0d6a8471a015da3bb68983848c8c09d79e918d5893dae56cb837e1d7c1068087503698a8771a7d0324ce4c1948e03e94d71cac366387b4a4ea049734e86f2554be4f9d65bd9b67df6d132251fa246232fa8c5183f3d21c9a9c70c487e60e642501b952e695f684b5f57e5ac90bbfb27627fc86ea8cd59dba2e6e2c9654b0e808386e904f68645c5616b6db0752ccd5dbab75e350b8e8600656bdc56a12e42106403d9da49c04b22af5c859d95c5d84ee38d8dd36ad9515ab76f4ce4d46f83ecd158c3ff94d44e2081b46ff062dbcf8a4b1c81173c2bf5e2af8358c530b8f8f832ff18a63b97811ba98bbbf39e5ba8a74ce4c66c11a4e69a406f1ccb80ab4608b7ec93837f79d0f806ecf42b56c99691a0e3a7d12bdeba153ed29e46215e100c24123a45d459a3fe161949b0420c451cacca7ca31cc95e6c88e1ec8f4411b95595f53578c2f06534c5c8b230d100af7c6faab1548014484007fd4e7c4fea67e86140f4534b6db71146c84464f61da9a27e194d33e9c94f9374d3afe96190c1d742592e7b56c33bf2b014972a37252a8df51ec503922da48a6df9d4a975dfc33c00e929b891638fac57eb49143f411eadc7281d0e55ae9e69184c97b11d01a6ec610c760abaf7f5947fdc4912d38d699275689519e133382b61b328475105a5dc76ed6433e62753c4dde7b256020ed5d585480032e3cf12bba15c3c25c410687304333d49a5ccd4f225727bf85d4257adecbd4c49fde02f0522b5c40e5a2fcc3efa96c491547dd4e21bfb5ee1210d127f76809c04285e9782c9b9f3c4b457f3eb8ccfb8adf8bdf745f184031e7c5d6b1c0356735fa33cd4f8e147d329df642f5b74c6566831e8201e1082275d63a248d0b7e595c2febc62f5194b566bc74ca0927935955ceea77b064d847fdd33d2e1d8a91d97242b6e7770c6a4a6bb4cd09882e6ae86d568f743dc5c52aa7f26407bf50e5e112a374d85bad0bc8c404078ed6fba58d4937d69dfaa78808c7d406bd27812c364729146e8d66697e1a590c4dc9a1d182e3434fb8c75a83078390c91d3d018a5fa1a79716271c0e95953c3f18d1dfeaadd4e651ffdc2563e6f5840c5d7d5c0eddc272fc6861b6b88031f49f00fb2c2559ec6751c9d42835688019d548010e9ed76fb1ba59424ead432cf4520fa3f279045624a5d114dcd782bb65f9a58e1b43c7d1eec6afc1e94de0008a1aac0b63da79246aadf2544009d89a4b65d2553dc28527fad2f71fc45290a091197081b2df11f3e7792037e49bd8e54f75f68b0381a9bb45242e40db0a4890069cc08d621b8cc11d6443b7a7a169a06869488681037baf836b92cbd5049f62fc421d09d6e1c5a33c247f2b9d147e2209ba11d12a32b7a6e08dc67e33c0aec9e19445eeed2d3c7e34cb61914b33f8f3158cd7a4423ecd21004435fc9751803611bcabec1dc5f090a8eed0e646c26c91741db61f890100f72be85f66ccf4bd4548d8a54f19e5450ac504e17fab6ce3e7c1004fcf061d5afb6b9d66f22a0e33160fe5b55ab97fad7be7379cdca68b15225204f18622233c2d059cfa113b63ffbcf9184b31e69eea481acacee1741b5c881c0f835765beffd93673d4fac33d952fb71cc5298900a3008a26c9c07e2c4ddfcf01c8af8e93f7c5a7353e8efe8e55a67f21aa095b36eda9fdf180a512b2e20d403134e355eeefba294156488c52d2a50c5aee18a44af29ac0493551f9b22500cb591f0326523a53ac7b66f88a49fd254644002650595d098a329c38d62b6f7577a1a29cd1ac345bc4961867c15b3f73fe7524a5a4b6847478fe2a05ab541fece67239bab4ac00d1ac9e7251c730d28514c00277ef7e8a9437d67aba91f8d55e074795e89e7db658c57cae09c578d55e03e477d5817d601f7a67f1fc217515112a930ce82139ea2e89df06d23c42d4936f095fe0ca634f7d9c0085f51cc5300f1163a8564d3202da09c4296dcc2b66c4aa06d80f0281ef65e58e9fd89dcc4e91462a36f72b152cdbc203ca9fc9b24e0ff127975e1fdfb147f24bc0a3605e18133c131e3ab42eede8f63b95cc53f598a21fbab0db73681803881bdf85ece9eb938b2bcd7f1287192542368f74152edf735baa81f2d2e0dad06e46e3abaa934a90e59db36c18378ccb41acf9a5fe5e99a5da182125599d4b358f5bc5eee5c00856d21698e340d9eadafb3945f8e8e3d1c722a614cd992f15f376d00d905a474b7a9de10b7dc859426f5ecf11b82b8350fc3e905d3b3efb449b0a18907110fae97b61dc0be03d312a4bd17634077b630c924e2ee8ac8a7aeb014f27f0e028a05afec35e25ff1123be07d0d9d7001982ad002c3b5863a0329a22566f5f4a176bc075ce0104a9920f68909bde0cf0ca286abbc9f7cdda8b770239c121c636a668ad65ff7a43da4313c00a15f2d6101a3e0d76f26675170c8d697fdcef0f7f131c9d74019eb5e6131a40bacff4d335c1236ac333023d56ff2256c2a90ce1f77bbad77bbf07e06611f61b617806ad6d709cdd50d9349d4d63aba5741b8e4d87e56ed549cc58adefdef62be970208e0271602fb93beafef61a883e7131cac04724272d5623e8abd1f32307350738c0ac4c96da1c85ccd000feb82c29bbe094e5b1e8e947ae766a170596a1c238db1dbbb07c4bbbbe43bf93b85fcccbb7aebea7585438f9decd80753a11a997f6f69d6377838776f06e0f5447f3d2dc1c7e64dbfdd78733518725629ee4472f92869ce0fddb39cd84546e577efbbf150d97e2a6cad0591fd26f5fd20669ceae8c00ed7966dbf5f8a89363b3519ec1104832b518278f8f427c75c3bdcfe7e14dd3d86526f99a8f6aa4a78615f2e2de2dbedf737bc8f2c40d448bdd4a0433dc794d9148144bbcd6a0e4d98db5a1ba867b3a215e23d5829f4f5eb52d28d8358f56362eb84bd2af4a726c7a8e3fad11f22a0a4aa73193112ac7f8bc34e76e9052404508f331e798b4bef2a1a7058ee7bc28b5109b7431ed1765432c193033fb89720dec8014b496f1764b64bba63c6eee32b2bd63931ebaf6d59b31e30cf0d31927ae34d4d4c46ccc22d0efb05c0ec819e6b895714de2257161d481f5d96f48d1b10813a7bb157e3d7d297fd49626bbdabc8d22e2037b078b62e1e678fe6266d1b5cf6b290245f730bd9cc0104376e0fe5089bb350be6bd674c409999dc9daaf979c86975f0d87bd1e1b11aa1710a9cb7e6c44fe8fbe500019750e13f2ffac0d0abc6a6d07497e26e4f102b8503341559343b43605dfbf626fa9d97749d03e14c2baec99a3240fbe98a9a716c6a0ed18565b40405c909a7dcd4fc94358fcbecacc8b37e41ac38d3569eae78b72080d06913c7c23c0734b049dc4c8657c41485b5f7c4c8322d101d8b3d8cd70b604aca6183e0d428b23b3a7fe4b69d3bf1f02f6eff2329822f43b07dc67cccda050fc4435e068a696aaf783d1184bddef85e1a6a2afec67e788a4c34d3ca157a73aab86ac24be910d9c8cd65e4bff424871e33929b3eac2fee876c2c4d729f0372e9b0f29878ceec1d6ef0f62d9936b55789f60145ee3be5b404ae4fe1940b4c985f2a8eaee6f2a81d64a315eb3d76df4feb7acb1297b607168038fda4b2fe916d62cde19115cb03fd4700a15d97897e5266d084e392559c9df82039b878530cc28750b12101fe7f4094a9aa5eadce392e7dbfaa598d910b837f3f5848fe749c80603d5a756c489d9e5fd1083463b8b119d29cdcd080d23f3fa4fbcebfbcae5985c61e92be00eb9bf782595a3ed40cbb37cabab2a3f7b2b57f198fc6b7b2f433b4fb53b66a124890f2f90e2c17574e18e37cee7add1211cf04b3481f74390952f7c40dadbc30814196951c0826ee09c87d7cb2b5245c8154aa52148268b5926c3af547cdb3242a78723e081931d666574558cb68a8b511b20982ec32d13648ef74ec370581a37488bdf727b66c8ec5290bc0971273a9fbb947a216a68c791acaf1e2e9ee06a742373930497a09456f18b5c1c2f2feddadc31a5036ea1f95e38425a64f84fe310970e720dd8a7cda49465d82c49a8b1ed9d57bea65bba64b1079cfebbf7b01ef1466d404c00efaf6965a30e18c193d569154efc85fbeb423133f98833d78747febbba6470d203edb7dbbea6ee47086b0664799214c47abd6184e34444af6602799aa56454431165466773557f4b6bd7a16ea29168f05a1b749c7f0154194cafd833c93b7884fd70771c3d44115bd07502b4c603dde0d46eeec945311cfab793a2726e3323091df44f76a9585997ba57ede2e272cf8d81194abe7751497249dcbf2f9e56b959e7dad50b1ad662ce60f496dd94433feabf89034235bcd90c6fa16816b13816c385a05fa749501e927cb32c6073f7a56e2f1856369b46a53d2a2773b959e939128719c4a6988680a9ab39c28b134042b37c6c3c9bc4abe0434d2a6ad0fa12a66582510f51313e3b47aae542fb39d5e97627f8b3680516b1d7126552669868b0f8ef9d964bfd10e907560b1712c5cf7d1864b917e6baadbfe62c1c77026a096b9168bf68afe8615a740793b38d06951c1f3b4e55b26d51ade6aee541690104028a88039b2c0e0721f941229bf1fa73f407bfe6ffa72f91ffe47cfe66e57e20c947233edef4997172dd469bac12b59ce51246fc0b04cfb7b39f6d6b7d65727e2d8db51cfeb682579e2061b73455c384d1e0d4492a9b3b1b0334735ec659288801010afa4f5ac00b3d29ea70e88e838870c7f9cf4a8d765792f8b83a68c88ebde3802eab5f5deccd488e0dad3f09f92c2e594672b1536b2c6cfaeb6dba5db001b4f2c8d7368a625688d9dc0a0c272633135e0a79d42be64e06f19125bb2fe172dcc58d48332fa7c5b72c8ea8e8cccd0df3dd5805bff97a41cbccc6043df9eacc29dff41bea079fba10fb5739e9a405a5d485b6e54af479b9847e18a601e3f9c7bd99e415bbc2503848f216d18e8d00b36f12484afbedb1b9a5590d1455e6cfdb7656ccb040eb5e619c2ed500ca40b2eceae060ef828531a990f69130c0c6021144f2a20ca11c5905f6c69e7272bb4e08746324dfcd130854be16b344b6eec6435bc5d6650edf92520ab82960f7996ae2a49f47ea1c0f34ce01bd066052c4b895975234f020ceff5e1957173b1ba5adbae81e81c7c404e40cc4366df15ecf20f41accdea72e9f8eb6d8fcc01506e6463195b1c275771b007a00c568a45a05300dd947bd2099f480c2cc6fecc9c4b3f0aa65d251a5115f721d820c822ea1039d1b0e00beec816380da3e10e7ae01e4eb326b2ee16a56e8b60fdee89e3c9e7e424b015a483078051a42d44271a7f07098e02c8999e9f737b7179b51eb8fc2dd31cbce60f0459f424a0f16441f257d736c5db4824f226ce58f49ef57fc8b31d7f18e54db3e0f98092a3152d7f9fef4beac0686edf646011f8d02f6ede6be2a3e366c15da8ead22075acef6f1fbef809540ff21cc818ce44fce3cbf55a943d67aa26f45e71e1e50dec219c5b591e03c364a92ccba2b4516e7fc0e0db68e5efa85b20a637a7d4b53c8aad1446b2cb809b255c30d31b1b60d26bba3009b209f8531f8abc959ee8bd37ee68f7db3d262183ded762e01a6760097effa30deaf523599a786616f560e61f56db415903bf60205079670455d2380cd76b7b718970de1237f44f631e8c7916fa94d58e3ebc1ceb2fe39eec64b65b6fdf8b1da496aa2e2f0eea1ae1502ae24c04da3561c757014911ec86d5041e64eb3aad6408be9806cc8de76ffebe1ec269ac3d7243a8c912d05fb24fe5c13b22bc30988619c7f6ee82bccf2f051f29d14c07eb506d4426e513ff8d4fd619f2b63d3b34fe6ae4b406f295fee9edda65a2bf1cf618e1cda8ee2c14c3dae149be99348be54a4e0d5990933a1b217f5031dc37dbd942c87e074870e098e1b05f00b73549eeee666307205ddddeb7719fdbcba37909acc20d0743b3982891e76d8be8dcdb4b4ad012ec1b0b4b72d07a292f358460f99734803f950e7e72e332c35406f605a6adc95a845118224fefa7c23da16f8cbb4f9fbc45f2685943bd85095a7d0d9aa2167b9bc3b669ea7de4f8d238996d60a7e03f5373a0a0589f93a420b53fee2a744a041f454283c6b45fe0bd4f8b7ecbf838614ec7bae9b968efccfa10dac7ec3249ef0d20c58f29e529b854b68b54f368a82a56c095ee5762d1c97cd3c76c1fbc47220ce01567c32d1a78e3098cc8224c8c9b7b72bc5aed4694a2534bb6fa0cd4f902d24384a2b3e7ecb70cdf0c9f36dbaa10f70b3134ef75995bd5a30074a000b988a2a156a550c3cdbc689b3338ee0c342e90173736bf5c5530d887cf418889785328aaca2dd6c4dfd0297c9514c3f6ff75500a148ed8c27be978503dbf3a9d0d8560309611f7073415900f411e59d558f5775719aa9132efb0b00aabb45b94bfafd34f1af797acac20008dedf819f434311ae83a137980f839941d6173b4527e349eda7f099b53af13e920072ca1f94f7d4f5e38d6a5311d2bac00abd500e7577af358ef46ef2b50991f6a2ba8bfe0e881de502215dbd890851ca11c09ab655631748d87fc0933d8dafa71916aa89f12e75b522030f77fafea5e3b24aec13010396e1c5008596a61fd5819c914ee47f8ee98f90dd4039d5172aa9ae3d11313af65e16233efb3119414df51ccad513046b94009809df8d8822e6fa2a6af7848da02cee044dfef1c79b71ac40d31e8ee7e7acac817e650d03a6f7fad5e78bf523e1062f6361a183b47bf5525bfaa90bce2608514dac7ac59e4684966068dd8c1e6965fb91648f7e5c52946fe3a424f23b288f487a5313c61343ac43ab57482db13e92dfd550c96108d050da9bbd81c2897b9b041bce03cedc2dde2d8be2fdcac288aa9ce9024d85cb53884ec9febc78fcabac424e259b633e420aa54360858b56be104a14ce37e117edeb3bf8fd993f6ebd2013f306f38d0c951cb60454a587d6639c436934156bd704cd5ecb25caf0d20f839f909aa789025953aa50f897b6750f4d3d66fdb3762aed2328d2cf5f0632ad0d2e6b6b33e285f4def6d8448b8bae4c65715d6f226f6f88e83e85cce62e607da6209ccde5afa3be268f29501d492d4ef6bc450288ea495a8841808c23b078772fa18cd794dc0db4c5d46ccd9e2c2784174a27993e11e3f13543e16ac74447034ddd58e2d5e3f2d4ba9940775de1c398af4653e12a0fd20483ec1ef234938ed9a171f011fad7c028dee8a52169b2a1c116255e3e9f4d0ab629868c524731df95153c7dc35f2f3cb86ac5e8c67bb107ab1ce6ce2f02506967596ba4022674f714568e10b8f23c509d621eb67bfdf9fa10666c4adc0fa0275149a64b5302f35c6bfc73e97b26aedd7db4d09fd4eb78fc2a8cb75064d36149298e69ae04debad3268192dd4f2ced845e6cf0ea053ffce38014a8fd02ea7f7203f0c5737e9fb9b33ba644203770301e4174829086fda735ab681290c4576db871e46c8d2cfe674d5f3b9f68923a7346fccec532c2138a2aa69b70b89fb218c0151b383aabf15d98a5839b3b2278010c98bc3eb76ba18884fc264876c38b6881940028f30a20d5933f96f3666626c333a829ff9f07a1351118ef8276e729a1edb60577dc8cd4f423cf6998346905cb325111db037b1900e07f37753fb9546352ee04c9eb16f3f5267156a4634d182be50338671d5b33085ed220081a7b0e77a38dc32387f48594fe2e2f28212e100a1522ca740da3a95a4de64c63058deee396519596ea6b77f145921a5924abd338a64ca399a036ee0fb8cf0dc2d45f0f370ac141defea62f06c9c983cb6f6d31dc62911e2598b5eb0274d362d68e44ad43aad564cf44231ca6d18dc93973458ff467b3b7e06c8ac692aef90e1af9ce3ad65c00bd3480a0a29a50f46e01164c707cabd4526416025686d78b245a2de9163a3ed9cc8f89e316726a58a0fd86fdd85892ca36a1dd106a61b3addcf41787b4c8d909634c3faff5f511fb623a9108b32291cbb9bc4a0bbb88d0543a09c8b2ca2f986b087cf4b7a0c0482641b08c8fd17a25c767316cad8a95a1c2ef7d400dcd7b2fff7b0a26040f6435119e4a8959b2bb3c9bf5ef0744f6ca71fca9b1a63665952e4a9db57f0dc99bb6ffceb17aac9e27898e40074201a8133a6c9a31b250cc683adf1ebd8091091aae3e5c421b5dc8e83b923385459b92c00b267a2b3ec20dbd264a17f7f88007ddd67ffe771fa860d7ded210c9d0c74ef85f8e2c8d79332c052f6ec08da03af027dbd919a6b4360fb81ae2c605e1f99ff1915a4b052ed9170c7b40151386a19616ced16cd8f7fb4e575489bf1bf5520414d6db857601cf08e0a894a1c3766b9bbda89371086bda45758beb8cb91d3a541a5e09d54c63bccf39df0f5999efcc0b5ef4bb45efe8c1cdbab958bca3d903145fc52825f59e44894522c1f695d7cb0ea51e7bce90262dc0a61bf973d9c9b746eff3eafe1ea4283639412f491721335b112f05b4f82057e1fea1873fb7f8b8cd0a277a72d3d4c5c77f00ee9e7b0ff2c94a1a3eb6295766a70d3be49499c36b640a76ec52fef5c7d16f9e217425313be3ddc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
