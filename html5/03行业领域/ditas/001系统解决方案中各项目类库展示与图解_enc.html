<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1ba3e4f0014f4847ba1d64e3321a019b5d55fec562181c5ca496e8f6371539a380954f16b6e1f5132e381da48e741d3dcb8097254f15429aaa8c1b0bb65fb41e97208ee7e73f1cf4323a8359145ecf6ace8212b5662aba2d29baf579242f02d6d40d450de22af40b16744faf1849ae1b56392a1321f336b98a09926c64cdb602776702d044ca11538d3e52f6d219c559657589d87c21ce9b4533914eb5eae80f82fdb6cd262d1eaeba89c544b09772f1c7d58010d03ad0cb0d2fa9d08a72416e9852c3899a6bc28c38d046e67f277c404b0987e4ed30aaee7a23d7c0a1aa0a1c1532d518cb8b3b4eaddcdcdedf2041e14b6eefbf952fed03fb77659c06cf684fb6ec75c8d36ba405ca4dc8dac1fb21900165d2d8da3e6683a3a5802a94c1203dc174baac647c3b28bd7c62a6989efb6cb2b6780c8f7f654861367bdf9aea506cf077ae600779c6d0513dbd01c44f2e247ca562274d21100c3807ef4f9e660073d2497d5e614a2a3176f35c2be648fdcc9ce73b383020476aa76066fd2350c91cc039e9b95b240979faac9f7222eb77cb9d06eafe6db423f15e3191fa0d5c36fd74fece8e68107ba8ebeba9fe9f0d2e0a201c8da395f01b63c2f438192e35efb2897ea3362f468a68012c1f7712f307ca2553ea55f992a3064e6dfa62931a3806660e35b84087f2d13e1bc45ed5e3fa00cc280b3f7e21e3caf07d7978b819d7821ec78567792a6dbb9087edb8daabebbac7bb5684952d24a791e0d2e6197eafb25f4bd3795b5861143ca3370c017418da3aa49f202aed992b2e0e4f10ee0ac5c8e6381a4fc41e7952a41f17849e66f81677231fbdc35e02c2739b4b06dbfdf12bba61b198c745dabb05279e12c5307e2ec0180aad6e9efcef91c83a4081b4e72630f78d8f2085dd2f106eba28e83596972301a9e4ac9dfca9b91a4253bfa402bbc749545d3d15f12c2d4bb0cee52988e0ee6a2169bfb1fe43964d7a2cf9ffa2418567b2fbd8943f57ea3e4859b621620e5621a0847346abc8cdb94547c7fe52f56ad6f7fec28a99d2e7ff8487fa07de91499df75942ea95732f7dd32db3ffa6580819f1ec4ab8a174f0ff089e47a7f06c696bc85d907ea735845cccf741aa6aa65e1590ebb462be2b42f72e590254e7e225fa71d586b7331db28c94f7fb35620fb8cba5aabf8fa28ddab29a709a9e906eb6231574d06e0f104c70f12de3e977b320e7157ea685894dd213dc465d3995d512d0a2b764e98f15b5c348f3dcf7d1d422a8dd9c1e9b06adc6f418a9f340b010a9e19cae3b2642a165f4580e6523434df61f4925cd20ccf3987b7e0cd492f9b02e0de9b0486bac6c01565c717bdccad358678ae04b449c8c70122aaafdf966c5db71bf4df7534129fb354463c0e21f8c97276a33e7cc07f25cf22ffc8f9bd6da80897cee9468ff321b4171f4a9f17a39901e727e743f6623cc5223fef9768e2f77965ec1a72c93739032240fb54d08e9b5f20c6197e93d11a8ec5795bdc9ac8d543803cd43070726cf6bbbed63596c6e6461ad0529696116ff83dd09d3020466ad3c4f3fab90f3bf613a5df21784307f0ccbeed3027f763cb372385df2c9f5057715563d8bf3c04987b31d17031d5866198a6d404954d5b6d61a735f50463a0985a50913ff9ae6c71a7639e9f7fc5a62fcf64e2b85f4e2412e6fef9d56477819b00119ff1c7c95501cf83de88ccf3946d07da97720b4eb648e19ab7699e344370b7c6f0e9286c02a9272c06f3c5e2e5dd9ee7692d67259f1132fc3a71cbe9eea901a46d601e6503a9ad07da8c4dff7946b62274abbb45bc06de0467137e4cd17e6330dc73d813ffa1fb708ce50193ab08354da358881724865ab30426fbaca687faafd43cf708c8ba97b179572b87d45dbcb91f150eea5bd8f9742085605754ac1f4ae0918aa67c9bdee21f06e5f7fa3cce0c1d836de7df4aa52f85d753dfa066ee3fbc7e6af15683625e5863147d2b7c1b98c676b9877f473ad8d3e4ac8dbf9f581cdf501bcf40d3f00b3505638ca2eb3203437a85da508bb7ba72caf102f7fd361d643e5d7d41e855da969c4059e816ea4c626c76f633c7dab8009fec1e4205f839a01f11b9aee1038043364914aaa6bd3ae44c661f6b2754a0017b7a5655b67fd45c604917665bfc93b13ab380eeaa4f174cfcd702ec34318fa6816d1370948ebd929fd8a7ef65eb8e7024d9f9b2f93734a0838e94d0dfccd4b21a5777735429b5784f0aae27da7a54166b8bc1af90579447cab292d2d7e547bcaa878a5c867d55a765d12d450919ac9e41d2484b387e111fdda691c8b40f83976c8659e5f8b7629a6f9c523d9581ffbcc9877c20437b128b4e7f8a6c045fe3e4b08fbcdce10ebc60ea03927d934d93af373a677e215438ce0273d4afeae21cab72da1493609350fb238c0fd1f610031d19d9592e64939d78e066e47d8f207de3787f6919f8b9c399839daba80131ee6cce149f38f50d9bc7cba705f936ff5eefed1fbd8e6cacaec89dab7f0ea09e82d1f4e2d5215f111618ce4378d48d63316d27358816f17d4c00492b25766a0ed00098427c2a232de75ca2a7363c7b5f30a30ec362d2232254ae4efd0a3a621b9ffb5d4289005a4af277cad29baa85fd83ae11d36ea2bd7d40c7973658cb2b8eb4f416ed047fc5af02f4d5b8113238a421a1582db004516c12a4c88f7909ee5d6058ccdf588e123a4176afc9376d71a9a0f8dc613462152426814d69a83ad347bd78b3d7f06f6de4fe265d8fed1a10987b330d031618ad1e7e6ce60a9e92161bc6cec03375a3f35421458e8f0f6b550b6526bae9724f26fcc71b91038c4d4fb266878d31832d0a5243bf65edb390de4ad18415556cba1ba4a01a65600e283dc0893caf6e42468e70723bb3d6ebb43259419779256039df55dd85e8cf7e3b45d2893ee18297854e7945c1be0e1616d7d19385e53315e2b2de4e0c9fb0e9c5f04194921a8e140e3d67f36a3306541c2cced9d7965eb4552cc80b605c8ff3fe8a7ddd533b99745e3fc16312551c575049eefd07c9bae4d270fe92fbc92374814951feac4eea552ed683392d0c1f378cb2d0da3ffd6f4994de9d40b36dac62d56ba35e805fbf399635c66d662d2e09eab9ac1e70047953e102d79d193f0176d973be481fcd968fc64c1905d82891419a0030087120ae92dbf2284aeba3f65954cfd71f5fedda73b7402c93e1ee7b1af37956b5048a62503c0d86b25c79211b504caeeda0fafd4662d0fa9ade6f207f2aad55d62d726f9f045b0fbb6b39bd801225f5d66b0f6b1342d82e38a849d2b37b3bdd26e404fa2140cecdb434f65571c2d2898e9673ae7bc1d9b4d680cbf03f7441bebe954352a9619f59c92d114b481f180a15a4a9f6afbfc68cd5943170db3467bcd27484069f76e0d76372afbb20c48e9c9c23bd980d1b61fb78f9398c1050d02e7bb5dc92df0c904a04ec90892f2923c0037612681eb0712cf954e264cfb2e8774a7d48dec71233dd55494ed96163cab5f442aaeb5fa4d337bfae307acd487a5a11f3d3c1ac0d81431c7db9d4be03aa07d5d6f9832034f91306b5832ec42719d681367a137829df6c208e282d164d826e394784cdce6fd15cf70a2b8f1d4cd4952b2e5cd6920acd7922cd0d9bdc8a9b97f70f7d0020e10198abc8a629d952144ca8bd2f7aa6c6c17bbdd89d46fdec4da1a165142ffa10246849ded8ae64798c2a7bff07c05af4bfcbe072cfbec0201fbab736aecbebd152c742af24164ab4655f8be5a1c782ae8e546a3ffeb9abc3956701ede6062220bec27739e94d5287f7bb990f3fb055db2d42b1c460910da48895bdbc9f5b512b1b4916ffe65a98f86253e19ce40e8fe47e37cfe71fcb283f8035e6a23604aab4cbd46ee2ad14f90b8f2bf2bbcc233787ed89d74278dc7f092f52573440f9f0b731dbd1b2cdc9bd70e10319def2e33dee67850170a8e8213b129fe3ca9db117bb37ac5b21eb8200ff211039e56d4fecb829d8b821eb25d28d805dcad13f112d153b15109de94e8da8ee8a5c9e796e776790ec1c7d8ad6aa0638459514ee2111de338b77093a2525fe33430af2f8577a2868b35f19c397a58dec9d087371781b3cca81a22f0b076ed6869a404669cd146f1b1280a0e30f27b094864f6fa515ae0d29e995e1402de1adc2a923e7a179dd10bc8ada5bc0850da30780d0aafbfbfea695ca9bf003f52b4d0e0eec73fae96b228846616a5c1af82cc194fe2edb9b5825dc5b49753445b7636ccda97fb48a2b69fa7317be3e891310ba8decb3f0753d169a07c0672ed29a6c14d01b35d98691fe01ac289b807aea468be18927b78bbba20283d349960282beb7053626c2350aacd940a83613e245e75ddab2cfdf4fc4ce5026afd0bdc5ffb1ba98a15b7033eee167a3f6342b87b91a60555c3ab06f2c53998695093be46ef7b10124de395ef68646af5868ca5358964cdcda8aa13c3e72c9aab0b92fd6dd7e8c02c1277fc3a41e1460951fbf12367731309b59db4225e7051514fd1c5dedcb36b92c8c2d95cd26ec126016a3e6779acd41e688483eac3be094cc739db2fb21a41f0e1c7eabf8390d7676353dc925b32f8125275bcbb16aec371431a1ebf0e44853a89ead04b18aaed5ed982454d062f8af7d6e687d67caba8955c602942f84de5a5e018ce168c6d9899e8b09da3b85881c1bfcb9d5ac8ef43c74693907d3d8fb351847acf9e79c9e4eff3b6fc324cb68d7db9364790c67ec1ef44b041516d34c3451924fa8cb23b20185e128911ed8f50b91acc4baa43a0927a9dbec4053e115955b8d010033341164c6bb95e0587248f976132682432905286c55ab3e032132c5f8caba009e0a84369d9c932871f3ffdd55a409d60a41e92784836d2f306b1576a040c82dc4acb43673df77e7d477fd4c02e9d09a0c314511f1ce444cc72f616d37f15dfb45b39132b0c96c0222a9ae8ec5bef428409b2ba3ef6b4a71f22f5f7ff8f2d7b92bf4607ec6958b0cab29849d7b48c5ac721c20c9311d20caaeb7fb5959a73d950d2445b4daa971ae982a39dc7ccb07d18cca2c99c6b7e649c3b255631bf5aaa4279deca3ce7350c114d38724b2e59ad14cd7c1d7af48e427c3721820f14687203ae6638aede9334d0584aa449ef1dcab906fa5aea9816abacf4a6eee5ef1ceacf2ab6457952ea38eef1c51168791a44d252ae8089a92c86af94e31616b82d4fc46a2e64f016f1aedee284c3b5dd2ed9a9d59ddf0827ed819ee79a123ded3885d590fdc6dd5178e95e3fabbc6886b97e425994e4e7f4283ec2b8b32122d9aace2f126b744a95db6fc47720115d6984a81e49db9e45630ca2b22dd8192cb544b08e755a028f33ae1a83fb0046066de89414916035d41ac63b50e3a3a237bc8ea6bb7cb5476c4f97f32358591a70082209952d4963f4c4eda197ef43c3843a2e1d53352a5b239bb2d6a4981fa747a2e81fe4a7fe60b0c4fb051419a7900674be571b4134f5ec6dce1a05144d5bdaaee8eb62a32c5e73e03ccef4be5d7c2e505b04a6d9c8e33aa71b97cbfe2f317217202cf4f063595c60f8f049172dd8d4215c113457e1aab1613db1bc6203f2113e091861b81ad6927cc00cf0d7f18375c7e2ac3eeb614311e9d5b0b3cbac66c9cf69f9b71ee7efdb940948a7a2b6e00f16be18db1a36a552ed8a19e07df73d9e42f1958db235052220a8afa77a199fd0426daea133fba746dc58baf40a73c326cb89e1c31ab2a5db4b2c8862328e6e763b22dd232ff678281d1beb19d77535f56972c80603f0bc8c75a963361a76d11145d83b0e3107f8f47a2cc8b5cb5bccb44c1118d8fee1750765c58f6793bad0466635c40cc56fdbfa68df91bd704df9c89bdb6e2f63f91997def3f8598ee41c264c96d823149ffb8626097821640cf4a60e32799ff2839726a23f89cca7fc3014403ca96068f32eeba140a1a86d2dd32adb03505de5dee34c4ad52775a4fb355e6658670c952cd82e8c15364eeec1c43f4dfb9ffea9e6ccc5e9b0f7238d762f264a097d34ffed487d0a38e509be56075b39a9cb5c1f55aecd8e415309f7cd6aba787122be97cdbc9366fd4fa025a30bd97808d1ea18461e827f5bd25fdf0b486d3260c776123a7c9396a1ea0030fa3ca6f3ef7d8e05893ea281f1d475ec4dea231c15275a581d75c6a147f569f6dae52b22f079b6adaca7054a2c815066ff355d5226d324163acc1cdd0fbb7b2c492100ca28e961b3015719866c9eed60cac10c1761a0aafd774d219363cdc7ebebc6d09741bb270dcb20c490bfc319a457946e8f93344eefe2f341b49ac77df3eb2c05f20269eef043238192d1c0aa486b2a1320e52ae1754020a400a09e570626d72a0ab053a7e27d21b937ece0525a083da273eed724565f06a1cd91d5d4d7abc2a3efaf594f65d12e4d5e9132370a86d88e7c32113b8fd1811c447893c6e4caae8776038b4f29c92cb22a86b230c211acdc62bcea5cf06631e6a25b237d14c15594580dfcdae728b2e47721db7553f6deac2a757ca263efaef289d246c657b68124c4b95f2aa2732a7efa032bb75307c606d13c4037b888d9891859141835f52a9c0fe90fc9cc3c936dde1bf1f5772721f6ed2c123d9a8173e73e82a574212aba3468573c58f47de18428e069b3ab3d47edf0266ba687f97c20bd816adb985553e99492897d930e7ef1ad0c51f8411dd286895ab79102889af590038b72498719f0f5eafbf3a4f1e403a7f331cecbf5b06122cca9f9201830385edee907320805b8f212ec1d21af0bb7c6cd7a4813969b7d60f931d6a932a127fb46f7be36c4030bcd9bf354ec6373522630ae68c78bdf0626bd5bf1549b6a83dc0136bc26b22ab80c21ab372bd9568cda0830291842de67851a1aa475af0cdb6d7c15fce1c30b643b0083f784abee260758ac2a9b2f24e668cc979c54c0e2453f4762390ce7131ed93b039092e11fbce7422e78899564951dc939375f5c2304bcfcdbb36d292114fdf6d8116645f76916dc2c07423902912cea79962b809bd9ae7c04efe275dc07504768349c8774e179be7b2b945392ec6ecc8500bb98328c0bd05d9bcd9aeb911711c0ff9ee780583e51c6e56c1a7a272d36a80327256f18b5dbbbc9487bc2cb1490631f7f3a9e39b5e607dba7cf829b148cdde562892ec1722fcb5c7ce5b31a84b95e84dccc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
