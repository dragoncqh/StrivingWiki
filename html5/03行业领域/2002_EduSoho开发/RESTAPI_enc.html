<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"926ea72f624486756db65803ff46f4bd4cba1e292ddfff17a5d1f3ef2dbd8384f2378312d55c70f4b44e8be53355c613bd16e8354c768c8146e2c40a7d100566fed5504ade2e51c8064c4e99f928b7ab9a5fa8989b723bc46cb72c16c946d3d04147f545b3abd0ee2c9e3d568458cdc0d457095077ae8e79820855595a2483fc169f10332467a85b84bb8e5ae67b2f7c420524bfd5a1a2c0687f60a5368d278b383e22e0519ec6ab6d4613a8ba82d610b316171dbf7bf3a104a0c17937fe9115a60efa44d75e4c1df7f21d175b1b2e5116eb05b76fc61696ac4b569a5d0cc833ae515a3edc45d8f2e73eb9a7879b1e9d02baf33e6caa82738f9d6fe72dde4d53b3b2913e5db393a2d606e6e019e725126f422fccd082594de3c56d57423e8a6db5466031fc2faf6eaa7fa7b23d62a7117228630f13b528ac84f22453bdc7c08f619b54161c3145347e71290ff5934124e19ed9a774bbe283fa4470d6aae93544b09d12d24509f0daed2465e018d780413071b8e1146a2734fd2c7f9701925e6c776636aafde23eeb00623a6276fb7205f3cc3b42ce3548306da60baaaa4a640cf8ef2e24f831021b94848bcad7f8350ddaa7a1caba58f3cb4ef1437f252a04977ec241b35f43972f9a204de9256291b7810670e5a0c4f035c3a048b014c4bc709857c81fb54cfee56836470d58ad95bf970793e9fc231c53bb743dc00be39d7a4b2e5c74c27c40bf7d85ab70dc52b0bffa03e425299b2bcc770867c21bb73d673622aa63ff2bfdaba00a04423bbb25f02c388385ad379b766d94096c3572dddd0780e574f99938141e529e8a5146533536648ad529678fb8f32257e661aac7de818942e38f5eac74210648a577506dff7b2a370cce97c5525e31556ae852c8de801276cdf8becc9f259e462603460dc8305c2399f388608f09b22b088a84d39141f6beb41792f10d5b215c2aff6e87cea2fd1095868c2b8d873e3f38c8eaa9a4fc0652a08dff45a42c6deb4d06117c294d6be3688d677eea080f0565078c77474ab6a6f7e347ac4bfe493772d5c971b46b808181ec91647cfcbb18617b701600bd5377e49b67e7aa7b4edfcd7bd1f7b714c848d2e67842dc7c30ffc7ad7dd162ab685ebcf7af3efb936bae4030dcc19249e2dad3da33472d87603142be789ecac44113b8229ba209848642368208df38bfcdfd8944a14881d28afd044778c3a03eb2b0f3f20a75c2df4829c3df9e588fdea365ea90352e6c3288eee7170a56c8885e7d0fc0f3b479e1ce05c7fe0e368c7c542cba018a45e97b2a9e08fc664c0bf8b2c88044289f4ee6433d6f652576945a3867afa4ddd0520f71821c14f4b4b442cf390315c8343179508e67763b087e0ebc079b9931ee2cccda1ee14148b4401b3cf538c64982ea8c25c9bf3ba550fb689477e0c8837841ffe82e76e1a65d7ca6de492af2cba489f1929616bf1e54563589d696bd258be208a0073bc42de236f107187119e91281f61308b1140da2373839d3fcf514e6eaa2eb200376a6c47f299b8e008f79a798422a89f49165037e9593273a5e4873f0b86daebd7268997d539472cebd86dc3d61aa3a7c1cc04f70b1e2f6750f25163a742ef662ef4b541f02316e2822e9c7bd2b7f11b147498b16b164f329c54a04b3cb4c3b455a4d1328d02caa52cd450f65abc6c1ab6b38cfeecc98ee4aa356da0704203c727b52b5b9bc5056e424045e70612a4b051c872d0e4f71cca0474c5bbf3279791c74eaed103abc21a46915d28b22ef14a7624a65298ce1dfde557a6b0aaa4905b95b3cd38df42025a19d6c0fca62355dbc617c0c5c428030d577cf5581684c10f7059c41a8fb16a0026f6e47dc7fbc00d2e3ad908d0edf10c809701a3ae00f4251a76879ebed31383c139eb08647b13c26d02098af2fd59ea60b923360c6a91a5c918cfa929eab57430d85178d89131a5a3e44cfe6b0cd9a2e87d78bd8d2385f554da08152d75530f9ebf36d4cbbceb28f9f4cb89359e677661efc10dd048cb2329d8bb2695f82c9eb73e7aa4f03e7784e7b5742bdfde4d65f325bbab4779f853e1866c17a4cc845f6ab96bc9a8a073d6a65de1e0aa6eec6f835f41d20e5478899fb66aaf60a7fdfc368f49ab4240260b2470ecde9a4de6029543b1d717757a74f2ef67e03f3fd28baf2e732109e44970437131250fa3368f2b27e5e8de2b63c816b955659f2482cd279d1927a8cd30874aa61177eaa45f50249aee74c0a14d8b09d6e6f430e91ea970c99ccee6596cd1ea8a41fd29f410e11729b9f6c7f38f92ce8eb277e58b033e955e5361e4e233f65bcb42dd9ba2c43018e82b21524e363125c5dcb10e966f0aa90e44eb8331ae03ac91a02fa8bd23605eb283ec1710e6d020c41da70574eb1c97ffea7e473f68475e6f37313f3766190af6b29678366bece91b0fbd27bd6334dd3f6f7b909d36ddd279e8cf0276f577f070b024ed4fc29db0834d8f15c54a303170e22081a6bf6ac965bc964c2447f0f0d2f705050cf3b377b1e75cb9dad9e24ffc9e1f228f0ac6afb0b35ad6ccdc89435763af3af8f64f488c3020a66f1f938cb38b8674c7615ec3c931278d9ad92f194ce099d1438a813f9eb16d85ef73b9de35d332a6a8f57afdd3977ea9725465f49396afb2e345c5014f464f01024c0ed423268ef535004ee0ceea5b671a3f700d1ef6da49ead6ef16f61ea41642d8035a5f70b18b7c1302fc0f268da710d0fc131bd4d11c7294f085bb66da0e9f0f085ff195c5e7cc76d584b992bc83108a9d3c99fb9db0b0f8d1802cc09efda118e53142744154b49b431a041b063c36c88073a4b0e8e027836d605c9ab1c18887ea725ffee3664c7591d6476a2ae0aeb78f98cab3da6f301eb6ef2770bc5b586376c3ba9737b0f934e86b3c872e574ba0aa1820c0195f67cc3751f7aa6baead9db9eab811a1205edb8f4b711c8dcf8c8359f63e856b6eb670694adfce3f3e7bc811571be5544df1b0f1d0ddb3ae9e774d7a98ac26403de4e76c56992e143359163814c4d59b0a086cdbe08e1be99f69f11735b90365ec8195f6412c9db91e41d9b0f69da273e998cd407d24fadded5f8163de471445c1709a791050a2f710b4b488a0e5681e5ac525e734ea747a3f7d0a1d00af4f36a4be1fd491c1945932f4e896afd1b20499f1123614db9a72e71009111fbd8c999014168bb59a1ceaf799814d271f5d7e71fc5b5a0111d831aab0c4c797f28f059ef916dff3ca7541d42fbc50a9bf20af251119bc043c042d3f58eb2cd7c117ba4a2d5e184e93a7e0baddae38f65a8004a59ea71e75bd412cf3d8cc27f062866e3787495e05749de85a927119104bf75384fd77b018131d77c2f87fd6ed17edf84f4ac4461d529577d6c36db7548a1c5f41800f1128601a2ca6297c62b153f4f4c8235c7d6615ca8a851e596f56b8d58e789c984f3ffdd4894130f0b1ba633bdc7ad022c416e09c40af16559503873812328b1da100bab07ce8cde2725f2fdaefc27a12fe4a025f6a927c6338801b53a7a6bd01d4674142e854b6f26486ac563ed4ac7e71ac4afcc50b1a4d7ddc670d4e9400084cf584dc1e4466192d3b469b35df4c9754ddfb7f36b8a95155092707527debdc1ef37207bfef390af3385d0c27ec0b2aba6caea2f36b52d306c6adc1593889b0d19783146f942c17bcf1bf5c7aa318c6d21f614bfc61e375a7a263e66203986da919c94db017f269bf2b8cfc294b14bf11ee0c7252080492b298eddecfb2bb25cbea2a9147022e84b1cd6e16dd2fe7f51892985dceb89e88a1e2356066f45619e3de8a0d28211b849ed3ca3719eef286329d731eebd63214784633ac9c967b49dcb22c7c041768a60cd2437c0f0f7a605b007092ab3f30fdc8a294c3a4057e2cf4bda6dc0563a2228c146bd7b847d99baa61ed86ac0c071420a5dc2c57cfc127cfa136ec2529d829297039aea91c9b4b0220997baf60fafd6c281785811c9f8411e685ce9715318abd40887b2129cf28708f6fbffb8a20193403d8d441c1b5cd2e5f8a985bd6b12504f3939428ad78006f26131fe51896597ed888d3e691bf6f37d3b1a838fa476e4eef5f3e0bac4d0aa18041931fc97ff9939701a50184ec12d9a59ca1ccde8602de11bd3bba609821a747dfda9a5975e71ac85335358af77c0680639173c29574a280b65843e30c41e61689d642639ca4b272c45426b72b613a5491569735775734cee2022d9e2505c3bdbec20ca6781969831d9d6c5ab158b7c49c1406df8ee81464d1f6e94c732d3b607ff4e99436ac8d4178ce7af761da0152a4482617c1cfa6c39eea18809100d4acd5b951f0056eb595f5d80fa68472cabb28c66e44d222484af4d3202d73c93c40b4feb02562e61f5dedae163b05890419191d109311ef96a45313bc4c3c3f76659e981da83d65f426274d80fcba0ebd2e6c1f57089036965994e3bc20c47118a7ba3aa667f6ac81f4cd583d8cf3fefe4b19aac4bfd8e1eb49d47a603a4a7d8e66809160347de2d9ca950b921bb7a82b0dabb2e2f1d3ed060865d6e335d1ee112d295d6f900459aebd70a635799743333c5c81d89b321bd486422b2ae7146eeb2429587461c1cf61e5f133e691f05b49266eff3d87fd7e80d5b33d96c6a6da94115d4a2852782d1ebb69877c86dca1e31040aabeeb280f973afa79f76b1779b6e9c18f518d18d12f31af0be38b5bd4dc69c83f23e51331eb6d5ba51276469d50f880d18f73dac057ad5f9afe8efde2dd650b17ca32f79e9545967d8ec38a4def3ff18f6ca1d2e2ff2c2617a4e3596edcbfa633a1aa20436e2449b761691a503d00d09078c152550fa3509b7389ad6cb24979c321622025a3ab72b6ac52f9d30d2cfad7d71cf18b1bf6b6c222d4a0b9371c2687ba6114f81ad5cd74f7dec26da9d5edb24116f4c9ea56f955180a117c42fb5e144587ff122d0dc412e483ea8eb1590dcc1309623ff7411f14b815ac4910590653b7e5362c89b11fe960995e05cb8d9d0834683f988e06951f26b1817fa9fd0cb5c89c0572a9abcc809cfb3885b3053c18f5084c2c7707e38761d4500fd4ff80cc0e3f857d37bf64965403512439ad6ce68faf2c8fec61348271eee1e971de604afd0829abcb6b0fca048c4b0b325402395455a20038a135e5397e01a925b86cd0ce981d062573512374e21276b72cd9f74aa1a5c2f1764e1d358a5a8cd27b2709e727f79a0c9268475e8178517a03fa6883b6386f24cbea3c4dbb380ca6642810f28aeacefda061205b3ece3be48fb227f429940456d6646e24fcd1d31b9689f59ed03a832cbe31f3194d86401bd2126b0686574b860f0c4dfd43b6bd8768aad48116384a82d2c430712819f4f57e3a9116a05dadfa9aca45b27b05b9136ac974ea68b7c960b150a7879120214e52488174d4bd2aee9a6afa8bddf3fa02270a05368ff3cba317bdc51d55bca72ba867c667548df7109bb29d15f9d8a6ad7a2cc133066bd81967d3f0371dbe88d4217c7235d9e6343eb129ddcf1e822b188cd0e0779054d8748cc9fee74423074713d118f8c502c03e57ea4d7887f5ca917924685bd97bcd0ecabfece0451d03db42128c4e78e1c826c3fda37c7b443b3cbda40e729aafe686b476e16c158eb25a10c98cd04be43d3df64a1cd5bd9be76b168a1c73c101d7546873c47708f099643f34dcab6b867b8c2bf641e64a670f38bf60beeb7e347f50b22e514ed632047232adbda123538f6f8a2024c4fa3eede57f939611d10d5eb536517b48c96a24f1ea0de68452723b743ca3e24a508901a880a36b353401fffe14b8496c697fb50fc263634fada48ffdb6c856e682c4b932421d1eb2b41a8166ceb027d1fee9fff82fc549e4b469e0189982887375c18e9c9e9e473b8e3e52379c6cd44c86377cb6d4148e384c03064f5f0668a6444018ac0b20495c4073bdab45443e679018d7a0a09ee2e4d46e5b034e8da2444ac40153d09092e1f53cd8f69b47b0ab668d4e93f2fc362fbb8c05683a505a46176a3319254c1f399ef4fc0a9bdfd48aa98fc695b97d46dd9f142f1725949046ae219253f572d10eba27770fa1b5bfefdb9a07ccb729fd774acc348d3c0d410f50361e3e6089780862b0fbbcc2e7e92aa3cc8a8518e819d9e281186955ebd21bd36a848863566d4310cadd066ce844693568498a6aa4751b2ba3e7cca5633af0423be149930957d1d126f89868578399b180d3f2edcdb1e161e82ece9f9e7621c68ed2c47b052bdd44e080d51362ba94980fea88f22a542398fd08162b3ead6ed51b8f2f80d399b8129c82c4f955572d57df69db751ef59cfba8d2b111e9c23ba85903e480900e6c5c69f0b9702daa0e411ff6659e01df652022b83355286acd2d66e3390a6d6e75b0062229f7f66d4734e2629ed3ca3e68d53339923416e9e357e994e8cc102bfe824e5c830a78d5fe63e4b0eae9b3d1a47b96df2268618dbfda58d3072a3e995092e2f37263b5d59d7b24d64c06dbebfbbfc92614293fcbdf38192403c3cf9104a174b86786514f55a3509443042c78b055b7215259794926e8ce5e1368473d3e2448f05ae3019157efea4aab6710934faf213f2c985bacb2dfce476a30c42caf85e837889f2ef2af4168ba227db24972b5b34515cd09725d8cc4a66f707f8d5d9ac8b08bf98322d02a7353403049b47fc4fa2a7e5b7cb0990c690ffecee3c7f197155a3ea4d81fc7ef0a7fcf0dd6c675fbd2387f15bb10df6c2fb02225ec5e83c663071ef235af3d63379d3003e992dc0ab3a43225854d898fef8af31f9945e6a00656f115eaf7d9d6d2123920de8ff5d9cbeee59e3d8b783f830bb6d6323a90d42f445d916c8bfa270c60f44b0906316aa6d09af50993a9b0289ad96e5a995d7f0aa3618107b8dac349bdb44c2e66eeb382df9c98fdae86ef368f32c57f69312effd30c2cea4db54c5cd91d196a7f839878768827e5628c23441c23c5bdc40a1644df3f5363cb53f8e54ee5797b8f567c848d7173370a531c46ec79b7c3fdafbcf271f8cacb0af33e27315095e0c0799e26c3af91b67f292d3e019da17f54a6a287d1182bb82c63a4a54e329f0a96ebd828f6c6ca4368ef4f20819e9c2492cadabdc167656a510eb5f1ecbdd32177e0216fa24c758025b5d337237c840e3d077068024ff929e4436ab881ae220712a5dd9fe01b2e670623dd9c1f2dd651fb3b398a31179d03c8b47f711a1b6f3954ffc2853e217e395b6f89b235da3b08c5bfd11154953b98e60cea97cdabe86d358d95336ce65418f5c440b0a8a101de690a79cb23f818f2206a8d1e823ec2729d87f7cc7a211e9c9c7bd22f25a109d9e51690507e488ae2efa066acfff29570988524d013ad1953b167b60a823aedd9f7ccefb4df9e2d7ee8c4e9dab2fc9d9870b76d04abe825744e4aa04cee4a07a2694331c1f4df31ffe4d4dbcc61e9d414d327795d22e99092062f270e2afe241b4d40caa2f51372f3437afa838eee34fd386601a544118e2be2d3fb9cd882f5ceac11eb2768be119d2ece9270204e5f028a51be591fc272c061a74cedb6e027a77be575518caea82490b776b2b0346b204d8841cd6053fd67b0b6ae7934ffd56bbf2309dace13c27eff8af119d788167607ddd3bbbd07beb4debb20a1083d16ffbb2091d70e5c846d748910dbd379e3e7a6ddd231c1e530c91775d107e8baef6f28a9f1983065f1c6f036f24eee0b35830ea2325ba5bdee13de56370453117f94d2d41958fbad82086da9034dea26ef018aa2a2851387a9b7a0ff33b22bfd104d7a21875bead0dd02d89faa37a5d5954d431a09030493cb441b356d1e41a31f71a79bdd55f782e35d04a1c9d020045a7c4e43ac8b018775620b56c649ff0e3a201387ca49f0b7ea2b6da681bc0cb807e2ed08b9f175b73f5479c68f3f5ade8d655463da38edffd92960786de21c0d1d49502aea6d48374a82acfa9e99505fb7ec2b0be1c99843c4336209751b31ea7e648b9b0dc80778031209316f756881574a03293434d971f258bb04ca6ff8fb32144c9312497f63d56f18ddb696fd0e07460d6d1c8457856e5a8c42bca1a82d12519a5b6ccd5eb579c8c9adb67c38d992e4ff0804932719b657aadba71432a9abd742d0e9356aafd59e21d53bce8cba2da40c51968aed8414fa687b4131d7ae5ebe9fc4bb39d331696d1413fb5b953c58c7e7b90ea8b91eec9b77e2c782d009c31819d8b7cbcd53ef974a9994b3d2c7faf2c2b0b9c64d69c9306182556574621e0ea854172c330407260ca91cf4d3a23457997f99a8cfa4f546f1754600c1cd724102207eda70f39161e4fe370ddd02fd9fb24c906958e95d05c69cdf53a0c1acb4c80cdd4dac439382dba9d84e73252ab496240bf8acacde4ccd42e57dbc49e1f3f616abacc76b85b214f67910deb0e22c322023959eb0734251f79aaaf1e37d29e3c38926ab61b06109c1f5cb4b7ac0722721db3b420f1dae2d9ef35238a5bc17cc630c8a5394dae4648ac8f63abe371b4881a6f3e99b94526d5eb82c798d9e9244c09988c58d6860090bdc476964b05c8c40d6517f7dd7f0ad86f183fc6ed9d07bd33b85c5fcbd74ff69aa0ab6f740b658c62c09ac98c3d5548bf4030a93d656cec0a8944df45c641066029b799d91e7801e21f6724e9dd10942ee0b634b424115b2195559c48da99b39a1ac5d3d12b64031ad479f5401743e45677efd9719a1b30007890c65ae7dde78f6a42285e9fd34a00400457c111563d68c3526002a424d8a786ae67552f4a787d2565816d7e464c5036be9348748f875093a4e0eb11d94786679c808c20d4bb66321e860681554328d607628d305e7d5c90718a7b4fae9b8944b82e51ac9cf3144834700d5ae81a16bee2c761631369bf0355bd8efbcc9905193d854205646835b5bd8c23124c205bbfd9d39b492dc01a9bbe1b2246f5f7908f7d66f9f1c54f7b4c6d2466bde70f11050bf1fec7b6ccf191709152a29eece756c77e7b3afb768f4c2de345ffd223e4efff766b65c853f6ce4732fd3500fb18d9cd927e5ac9e83f5a70afb397ec8cda4e6203b1d44c71de0f5f384d74912d48c6510074641db3ce8048aeaa61befaf356cbcdb740ba3cda94fecb35a08e2bc82698a49b59f7174e164c6b9a872b5480f9b64c170e36b8feae3ae3f2a6c161b04c2131edd1dbe3a0a11343722786e015b3224b8eec13687c3e154476d6644c0376260054e11e6f021c68ede9282fbed85c55299f16b60e19f1858d9aa4dc86dcbe3a4f537f9198c5f0c479f89be75a058bfadf0b2d068bb6d28ee54911d392cceef136ac733a4f09629a4d0a46905541b346404f2591f053b7669ead9920b0262a8578b9f5a4cd0a0e4fe8b6551891c5282fce6c29d4aea6747834c589b9743cd613ddbcd836bd25d558b9ec1a76c97a73a10d0590824c0ca39aea61ef3bcb6473bb782f7e3ebe21e300ffa7cb026c7402a9e4657f22f964160efd3b2de5d1a86ed4f8df7e9480aacf794d69107bc7fd1c4d22fae93617f196be6c39a642962fefe74fe0a950fae4f33e850b877a8dcc7254cfe564613ecb0141172961bf436b85c925467d7aa5553b95516a4b811e47154b735910f057aa2664fe96eae6b5d6ab7dde8569ba34536126366c9c7265713146878e08c9395795ac2656f2412c00ee8da1aca7c066450f7ac39fa098023a00f9d7dcccf09cee3e34a04c6b09d29aa860935023f44035427f865f88e2ceb541ad262d84d91c082bc8a5963985930177962462a28479d4664be5cce5e800934f8167f3ec01a97cd83be27ef5878a2db0ecaa128cd56f08f784a58ac1d9eeaa8a669c3dda2563743c09acf542cf7ee84510f61a71f61f4f60bc2aa865d77ac31af2b2e39f4e82192a0e96805a2dc65a7ced2a47e066eaefea7d9d0be385ea8473448e61da6cb024dfca00568278a118533ee3a4fe0b31fd5050ff690dcbf08f7d055ab0930d6ae679a90a01464288886ca6e200aa0fa238d5e42e036a095b240efddd846e99ab32833f8f8fb839ac0ecdd3b09ea7782bb162f066b8f0f39bd146965ebf03520e904994739e6210e6a519afe321eecaaf4b06d5f28656f280e822d9961c491b5bac7f1d859d262d758818baf8bbe0582534b7cda4fb666141898f905e606a009b7a7d23ca797f54b3d5d2198a23ce018a680225ad5f722c7b2f30e0275037a0eff0be62da61bd2a10d538f629e0361793ee7609e3480c0835f97148cdf29e52ec8f388ef385194c24f66422dd075a6ff7a2d63786b799a2a9574cc64aee16e82a46b3b383c7a722b329fff86ee4b3022d58abe879205d56365c12cce90bbcb884e645c5983730327a539e096f07b28a157b9b31a6dbc50d5ccac5364eec77ed6fc46d763ba400890cb84a2e566e48ae03a77a044be47a6664349066f2c2015093d738cfccd1776a1df3dabfab504bd0a31d61d61d06ec659cead96f7393fabc22f5b132349626e8f9d3ff39d312e8dd369c67ea77fb14eab11a587d55071aa807960a409ad7c78be4b50f0427c4cf5b4b4fd8b474d82764885d589d0a94a0a2474309148715c9f9a9dafcb3c80cacb3c7f31220b797940c1f6b776663834393802e004bd652fbe675f680972c3d7a73f1807db376f5c78edae7c4ee36a2cb99e44d1271255d7af36aa691345db57b9e1a6114192b803015483b67e008d6244ffacde4cad830a95d75a1f36d3d6930b334f843038776ac16e68eb38fb7f8a9801ff6901b285a97d688cb9200cc874b038ae80df0208a92bb6df7acec54971142f38e4308bc0873146a329eb15bee6724d68db78d19e9d319f5ce2ad8df58c152734155e512da107dd0418938459d6e0b99d15a8cf0f638e152eb05c8e374a66e48d59ec3d2ede0213f629e229deb8fe4ca8b71b97466752fa1f4eaac2f9c024bb59322c5202f06442a431104d2729c94c14023aa4cf57084e07351513457777e81cac7d387afc68230823e1914ca608885fa89d763cef3c51935533f761589dec591c4198bbbed9c0d795238ba0a77d0635e97638d9da3f8d837cbad026709081a91fa2ab12c8494dbf1ec5bae667cc1aa5a2b9a82be624366dfc5dd2544ee65a42f727132def08aee4d1cbcf4b239abdcd49aa39c22331bfe39a426fc3c0b089bdcfdddb3c8e4beaa5af5821c18e09827649b91a5bf3da48ef01e3d2a2b217b93adf7a3f88b4b0380d6e9b264a8e3b29e7db843b78c623859b27ac4e9915b066d5af71df78a0a8f927dedb321e13749020ae35e84882a0c99b1d604e1513f06e3c83b06df91b30f0599099f00cda05937778d530dbf89bdf06829fd68ca195872d712b76e81ef4c77de51261e0d1c48240d891617a8b034ae5387d261091a099ab5360d7e848295a5fdbf4f9e05b71e67b53a5c445ba15248983ae97cfcea9847a9b9516092ac78ab61f64fc50e1a708ebb0b1f8b2af30f2522e94b76b72466f5641054930aebb4ff238ded45663c14baec16ee6f092115c12c768c47bb6aebe4f86e7d2734d3e6645d8488575462bab574530163fbcc5d27de1cd6713f640e818ed65404825a0562d20f0a22d82cff9bef02984e8326956576542d015253510a767d6a32552ed05f76e39b1b088c9cfa99c4b5af8470dc9ba9565cf1806b5e92b9b4449803469dfead52c10c53262c0eb93cefb572f3a12cdeb8dacafedcd5e6202f42c5601409996272eb52beb348c29be3ba878bf478ea21f2712a613c7131b4aa7f6692597a344f3611ac8738962ee27b78b6834f20999b2cd20c10a04febc4b5aa550f5223edb14ac29086326ececcdd7916e00ea2b0f4de83cb640c8a5cd9920cffaaeaef3be4d4b7a2ec0afb56210fef7f4ae4571755d77ef561ae1a2e514d3ffedac570ce6f4cbebd3690edd5e501ca42bbea19ddaa12295419ca390bb54ea76bece56e671f1f2b75540823aad74ec5007f68bfe27dcb3d94b91976e827d81eac597cf3b0d33691b0a7e445ad58e373c426a5535489cf01d37385693236e451aff0d49da856a89cf6242d4fdc9f7a7da58803669277fe45a0c1a51699fe3ce789a9cce1f832","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
