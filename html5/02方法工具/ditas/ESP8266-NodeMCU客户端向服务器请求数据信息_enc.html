<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d55dae250ce6f5031b0d80722b7e47de047d859d9febb9938b3178baa36fa0c8208ed88d6866e52212f602b33943f030a825b9a3625f37b453b865982a1e528e9ba96bab45d7dd06efe1b18296f6ec1938ad21a4278f88be40190b97f22aa1c17cb575ff8387d5b33fa870f014b7c008df8219abd75c1daa7aacb560a0ae95ab2dff9b0d2bb7ee445044e7f448b75886fac79406969efe495de6c588bedad68a5cd0812e3f3d6beb05526d353f2941970f4c29da52ec8a3cf21e43f0ed956eca518a071a5a9afe7645b44c1f50c94f8c92648f9e594eeeb2ceb4d77ba76563b17c6b14bcb3ccb97d16c694fb46d631076aa3f9c8b0beb0f5ba97f814b3a9bffdfe3f0d90b7d0821519926b2b29a922967fe64b9fa5acbfa8d289f3bce8a411cf3411a29e49905b318211b4516d774a63cdd8e715f9bdd295cc5d2373bb9e8b77026712db1d869ce49b21a2d5de5181763dc7486521a9754d5bca970bf166585bd5172113638992fdfbf52527c0bc434edbe15f73c35eb983e50669d4663003b6ec8ba39ef5b0e164d82c775673415e366ee251971c14c1b31461bc169862b64a892139ddd9124bf6af8fea675782df40f965e7edd55602b8a02af7d77846354e73d8eb613d9646c154426d624bc74fd323ce610ca2d5b563a6d84d95bac882157f2fa3cdb025f656052e1077a90d7729d1e1807b4f03af0db9dff12c9ae84ff456159a7907bd59eacd25b34fe077741270b7edcf474dd4c06d2aea87c9fd0f3b1012c10ebca335188ab2c3455f9bc4d5a8ca26080aa05f9df9844c770593b72c30534da83080ba7298c68a2bf70bb7b556dd37bbc2213602706c327bc212da4436f7f1fff70aeb79ba981169a4d44bcaeeac7042f9cf34a56f87443004cb2c261381ca98cce4557622c5b965fe371d53e550581b1e0669d9aa8f408261ad3f92a6c776aab4b18a331dcc08f047e714f2dc088343bdd643a2f41b4c46b3a18de1ecfe46341087db30b8fbf2ee70ae7dd13918645325d744aae06c125062a5736b1bdb40cbadd67972497952c11f3ef1d1da56e4fd556cd02bc2b0a8d06a69a41e42fbfd127b7caf75ffca6b06edfbb4fd8698daed986aada8cf97fdaf0dcab93f07d4e15245b28db0022de20ef375308917c9a992830950f95124de9b5c9d37a4a656c49204d7bc518d3f98f92967b81a3380060b9b89f5f5901b3d0832c164187313101085db77708078ea68c62609eabe17cee33bb5024e567f3b7cb4cd03629888d196413605bf683c76aa5f6f39489591074a6f9f9ac1a17d43ede027086c5be79fbcae2bc2eca44a15808f21353be2c8e79d84f917abd38d300fd309ce2372d5f5f814f4293c909c697acb42424a4d0aaca103c41206003814678d833aa2aa2247b56e51ab43877b5df19ef42d9255dbc0100d87724bddeae8efadc6f9cdc8299024fbbff34ddc04ca873be40d05801ed4fdfe361bdc15e4cb9494b6a80267ad591fd5f6c610c9057e7ee92705a7ca798b37186bc7588e41f01dd4b25c259ea89b0dfce96937a751e2c0c9214e78f0d6c2d86b3a90d01a5cc7ce973e260f7672d9696fa7cf9f493dc095576585098e61ad6f4d69f1d5f5f17fcda89af5ada511be173797c20eab636272db8bf44eb54c4f10f411b73374d887f7bd3aee9062cf2c01fbf84db4a353ec5173c29d705494fcde9ddff80734e5fde77cf25631174e6986e83f2b3fe4b773f084dcb000367b85777f00775294a93ed2dbfa14dcce75114f9ff56c7515fec3c6967f58fba83d8256a5b799118cf8b90747e074c8f4ea48019166bc512a4fd215185a2cb55b6e5615b4e921b5e41d61362b6290864a9746191057f02f05e6f215d7bccc75411d135d104ceff4c6ca68d0008f28ed11b7887caf9e26dbbd0dcb066fc73b745e9312da3a7ff104ad5f461f86f45139b7a49520004dc2e97f18e1d531ead5ce91c82eba5c2b5950eb31af7c0c3af88987afb39865dcf00df0ea7931332a9dcbfc2f9e04463486826d2b2a6a7c07ecb4744066dffac960d2075629b4b93b7841e3a833d42ddf84e4d802fdf364919f32ef6e16166e41665838d7407cebfa1783cab3841762f82208e8160afe2890a4c32978c0e64f83b7e9c601507997bef83e26f549c99bc3b80f6761ad2d684fb6b6b0cf382aa0ab1d3c0e4ca726638324bff44ad4a0028abf3c574cfe5668e4c3e1bca4f64b0a11a3b30c44e69ebb641f594b9c4c2c15acee6d21e8bd0ef265a2a58ab56e9e2d371bc5161936f8111fae0c19d450d08f4bff35d04c34ad7c5e2c9629e69203b959895d7bd641e2dea52d8b0246448829981b30baca43ae7d3463a4464e847163d8e9f36509922fd31efb5c777d9ed04af4a15f49427672f8d89991af1b94c9f8ef3b10a46e81da92c269752a90f03675f307221fa0539b0a551d1701c9d82e5b790b873eb1e0e973e4dc2316e222737f2f0519228e22ba726c83e86ee88a7f87acad04536e4f360f95fddc4baeb530ea36c11ab0ddacc4ffd53376a3da6783757b1ca91ef2a9d025c53d2af857fd14584a05ec1be7bd11f606257968e7ece5175872ffcddb36355f1bad26878e0632d36ddb9f390362501da926fbfc156ff224fc88451e421307343fb1f7c268f1ceb1a41dc1e924c4ef0542b19a1c939385f3280deb2e2cf75210fad0a151d9f5d7213430608c58e063e61663e24f4bbd59f5941398505ccab83fe063d4cba297e612850d97eec94df7176c6a472153f4c9b03fb8e1e94b1ac1ef7fb904134a9cbf9a4498ded764976420c2d00ee992c755a7e0348edb6e45579e9234a54c542a7375d2d8dd9fe46ea712a03518c7b19d3fe45d01fdb817a4e407cd948c4337bab509268b9ffa2fa36cf8d3be2bf36cf4abcf4ef2744bffc6fbe12d5ae64b3ba906d3e9bb7395c0cb4350e9f3a037db85f6193eb965805a491fbf551384e286458ddba2c20a3e1ace5508bf5f2b4e61b4c8d3bc0fe31217540f41b25a70ff17a70404637b5cf879f35ee9a904ddafd1167385f1b06d5a76d0f0fb1c80aa6cbbbaef79f66b8f16b9bfa17e57f393ac26a3da0ffe7ba29ab22ccb29140aa5ea895320be288cc8f45855882a48cfff8a3d5278536210b9d2e49c805184966d5635c35ae445a90509eed8733c218bd2beed5c869ec167c6bf62ecd5f83c1f0bb7b7eb794e71d320bcc47d059f071111c3b7211f889d0eeab247ad247f121c810d6df427869c2af5186ccbd4363857f842fc55c83efbb3cdfde9e8bbdb70b045637b3701f073c14ba98ea83acc09fe2aab722f170ae701f74ecaf06ec0302fa73ad40e03b6193a9db887ff982a791c9022811c04c73d756a508940b241ccb284140f1f6781d3395660f37da07be342ae82739b717a9a252abfd69b60236917b4777c39ee21390fc8841fe436283aebd75d97d708e8935b0394415f511842fcf2423e9c3474b89060cd9f6fa5d6f872549e64b862e7bffaa4d69d722a2bd134168e816b557aaef52c9865d991477603783bcc3dfe27f09748229d716ba9dcb84f6141e88fc76131d67c71217bacbaf4a6ff2d6aa3f005111878eb534cb85a5b916a18644920d183c3c616f2d5e8a34f9a42726e937c9d4550775ffcb71a7f2cc291b9a12fb2a3e7195dd743cdc945be40149011837a962bb8adb27e5f0e346ff9e4737e5db91ba5b60164f260f8faeb491b98e2375dad783018f5be3d5edcbf25d948a0a3b11de8bb3695a36e274013c2a40b2d417aaa5b8a02cb4bd272c2d9c3f8dc02ddc6c3b4254a311bf574ae56cbf865488d0b142e2d72396fa9560cf2217c2e013f193e50a79edefb9502d7026e0a53eaa5f200ce3eae9e8c0507d1b123d0ac831341e92bfe60c18d4b25200beec66cdd28008e0f93037a26bc8bc95e7233b06fa5ec5ea3ab5021c559fd45634e61d44b7ab0c58937dc72639d26dbe58941d4b0fe45108172ed931ff467001f5b81ede253a9e199c9f1ea5e292a922858b41c3948d357f0acaa3bd4f6d82178b8f1b46640e9f607331f7f4ae0a61da5685e9a98c4971511f643bc0267bd484a94248fde7a22b9393c5b4f66b76eb2cc1100c0bdaa7e16d401bb751db595411423e8ca1ec7301fe6c804d72b58908270cf7e7fbbc3890620d9bd097a7df093136a47a8798853a92bd431171a15d75f0facce5ea8e7bac7e280d46fd1f72891acb1c9ecaaf3db8613fe0bd48d8611bac573375a58f7dd6d9175dd57dae638658e42388c6b9177abd9fc45caff9bf8a6923ad49f3034c26b9f69976dcc05aa3e6b61a697b40b56f099f50eb1d44da22693750dcff70a425b27693bfa843695aa2710048b01a936bfc77e266adc89a4bd83819b922e59a497afb8f71dbe076dde244f8905f0e2ef774f4377b7fc361b40a2fe1ff50769d7c726eb8e7807b4454e064c16960fd80cb53b5ba7e862b689e6a7885c8b25ffef1f7666df9179f8205e8ab2afa3b9ae1de3791cb41250a5b72c185c16817e08130bfe98167863f4e6b9962263b4f2e8092793ff86bdf11e81e4607bd84a1e5b053cd729c58b212fa72a5fc0e75c298fa13336286ed90a3ef11694f1f0676eb188098b1887ecc5f7d2833d153649216393d147ac9f7e5a288684f9ec75c5f199aca466f57882c4a37062523059f4f8565463014ca4cce8e97d9e7fc3665407d6cd6d5219f9a6ec67afde7497b2ffdfb3b11e1030ed306f8044332256c6ac6be542ceff7a94a20823a219c5bfcd2317cb65e4ea0d45591da628472bc65804daf7249e8c54a4cf3212ab0a7bb4ffaa45239840e655b0d17071fe3e8f6e7da6f9e8bcd670b01ac2e6158d8547594bab9467a741f7939015f2846ca4ce0232c315b4cae232c40b3b24554b434854069c5dcfa63c39c57b7c30139adc55d52dd47f7f4f0a3c213eb263661e1ca4fe4fedf1dbb1b289900cdb3ec86b054a8f88e7b22c02c8af45d26ae217f3ef5f146ef95fa94c491fc02f37654ecdf8857fc342c528883d38c284fb8286b3785d73ba1a596c977540b555c9ecc989511615eacf0c96bf0251ac8988d5de313bde9c67e9e62a087f7940f9367f0c8ad55b3a43bc301199e43d95d37acbabff27dea41407897f611b47270e5144b436af104dae621d3d504374cf3331146f0c36422a9d29436a7e33bb46c66e04ba7bdd4797485f2487db10257c9ce1edd2f1fb0c6c950dd681c2a4a3269d62dd48f140dd997513d95a482ed08c8d5d509db7f2814e58b23c82bc945aacf3a244b89d92737eac2fd8e37d64b25846ff17bb89cdd97d8e9209d20023e819e73cbf50e3b45398bb28c3768a5a5f7e6b60ab268b8364ebea6577cc10110d484ca7efceaa23a47d4befba562e7968d9a9d54d88a0afb19c466747528c35ea8574a1eacff6406c1613cc3f7670f6982000f070724988e8e6dc2e5764bfa086fb46d9d60eae6357fbfd009f514b769accb0b34894006e573fcd28d60516dcc54adc50d10a2afb0b85ea3d25cb2fecd0266d1ecb481bd5827d55cae56ff08bc81f2863e99ba9f633aebdd685e928b1c26218a4b158dec0939dd18b0d9460363d485f0dd1f0e5953959a388aea1e9c3e4ad31c2ccbc08313f58e40707b43426964822fad5a20eeda77210e7d8f79eae5ab1356fb19573ef0ae6854d7f5c48b04132ddc5b18f24fbd6132a75f59a72265983e4e7ebe0200c8ec21765e69da6307a459158630acf60416ba61574d39ac4afd36834e8166fff0e8e79bd271acb078fb66d51b4a24c29b78689a765fae7778d78b0191fa12241b8e4e3a3dfb10057178b013e30688d062a17b827c9d75f15bf7aa5e7d877c987a728cd236cbcdc13636712ce63552d0100d6baafc3a9effb4ce40d74a2492280d9db35c58e49190a4c6a95f9ef5cd3b7c8b7b108d30e868ea4728ba6dbd64a465023c9bb4b172231cdaa4dc5fc89b79650db6ca159451437a8493d3fd0d65c306dfd81fc98748cf3604eec88615fc068aa920340c39d31670794ab5ab2725eda3054ff4b21917145f9179d62070edc6cb10daa795adadd58bd90eacea02534046fe06c65e6c320686ec85f4f874dc35dce265cfb82d6897bbb4d8fc4491ebc89b7664f246ce34c58e64b0a335de2873003f4a263f8a3f91d7769192c6ab90b5ea3ce2a517c83354c31b924c1333063f4a4b68b13594e40bd4ea3a53a9ef8e9d6a1fb0e38e43dd82a4526c26dd7924c75eeb2c1bc263d3f5e7649a4aba74537f5c352fcb210d071eaa56eec0da882463968e345f3de5003f20b3bf43cedac381200446d0e9a427afa5d73a784caab1db4106bb36b5d40d9e54e53c010d8277bc8113f6a1c1716c6ce0373f1ef78dee1d8a4cbb487a5e366156f5556cf42c701f8f011ca058f00ed9f66419ba1233cd4d758702328240298d467f80f623ce5003ee91c086a81d1681cb6b5ab0ef8fee4da839a08a4def3276167a129ce86e29a923e209983a079093964330eecf5814f1e8c33837d9e4bcc4408a6e0641a9a50163c21e8c7274c4346c47ae5ce6a559a45d1aab460648813c25bb1e795206844bcb58ac1992253d858ca1f2aebfc9e237958f1e7d4a44b062716da44a54f0814c5b02b02b22995829ad181874a1f872886223d3e0f7c55f863d0e4483c741e5d0b97ee318facbcdaaf8f0fc81d71bba30c959b4d865adf997411adf37d2408f3eebb0c02514ee598456b4fe2da3c4377c2d9778c733b5e10b5f9110e7c784edbcaf8ca97dff0477cae844ffb968181750a915bd9ffed241af09eaa3dfcb2e4d4b30911186457785ad07f7098f1c91474b320464f7143999e89fcd28419b8be5db89e6309c6f3dda2aeba8b714b90e10957c575eb06db6042b51ba3d50c9a669deffb414d4af794f98241ed9701ea8c35a3eac38773a37acceade4f43d5f2feeace2c97d6b0b3a87ecd814c87f1a84b0a4fa7ecbcd26f984c6b9ce531962f725874568fe63253c7df3d08f70fcf17ffb2425cde44fb650dc08feebca1a43e3233c306b0e39a6acd64d67a97d81ab49873effff4821576d9443af1c4b6a101241404ac203a5688c86db6f76bd5ea2b3d5c4366b9af37fe19a1612dcadb75dfaea316e04681f1f7193ba45181b00ff22ba5e4a5093f536b30118845513a8377e07ed039ee73ba92e69dea75ce2c69114764d7927b7320156b1b9cd08536379c2e2dacd484b4f1e0501180be95df01004116c51ed60305f1c332d1f01dc5da5539db0a5f57508a5cb736fc1b0eadd239134a54c81152fae9095701e9e158bf2a62d770be8732f870cd3064f1a4cfabe35e045cfae506906d77a8cf46e2ae77d5288a802333a88c73e01216cc36c64a8f6a05a48144d353cc7962b57ae7283ef08af29555ab8445f95617c89388d42f81737195935901d1e393d82e8ad8c80bfba8503add6bdab3ea665f8f66e807ef79c13f01671724c10ebe4b5a277d5f59e7e99b1307720f8336f8db97959d150b3dd23af626abdf3dbede22c47328c4202726f6ed45d7e2497698d2209d67de30d1ca1129e8bb8c252562ae3123d7dc2041573497eee7d8528bcf555e9b85fae3cc2c3861bd6ba410e7c61adf0a63ee141cfe6997e97253294f2e9256beeea272bb8076905bc08727ef111e565f0fa66996d8745ffb00ded5299611f4d3dd7b192f38d8a522131ecc4be8a4784c3579642339c928a6c0a261b0e3105ffcd73223a13204e6bf8104109e9b888576c01608da342b11829dd9f28a81061f388679b4eeaadf767e511c1998e7d1404da75210b194d645ea1fc9801470213b857a352832c20ed999ccd6fbb889ba830e88e158411479850656a46d3794137f26418023284b050d65ffb271765a83f67c84d8eba19cee1e910d4a22facc4c3b860ba0327cdf927dde3e89e42e0c6d56c4ec041d7ecdfb30c2c7e5a15e492a3cd7689dae10effe71415e3096dc4c5e85bd4929a4aeed610621d4fb6e51f8d911070927497fb4e3cd868765acdd951ef47dce63447dfe8ac636d24e62ff839d9bc09d59596aa1605fc4fdc9277ecbaf315bf2f27cfd3c5f602039b64a177850fee8cad7e649f5b84ca838fa4ecbcccaab6500763cfb733c92e6a5eedfedd6abc82d95ec3b449658a2eeeb2850a308556d1eebd946f29fb33c32d2fe9210033f42b935d42b01fa4c2dee871a7b4730960208f66fddc26a3d32dec17a74afa9d882412608200505477aa4942d86f44402f9ba3eaaae36bc9a76e6ff846234f1228e0b2df54b1cab11b0f3415bd0efedc05c6a5d37bcfb3b45074d673a1df2f9e871df7c6946ff8eca772ae934689a7fcbfa337814974fcb1142b3f957b2624712121cf8408690101bc8f2c727eb89bbca09e92aefe852b7f241b898939e48e088c500ea5234de995a2d456d66b3d7634a8ad58fd8cc5a0c2b160fd168fb8febc738200e31cbf7af1a7119f8cf566ea455845670ec3676c3567025a00b8cbe7dfd6aa8182901b702fc1c37c53004cc6c4fac5fd9e4815a0a0cd681dc47abc80c2f00513df88291c337a68e45440961a0e5a5af076a40255a6cb5e04af7382bb87ee441b3ac3de69ad0f127cf62b9efbe8de8b8c9592422001c71d35157e429448be29dbd68b52cfcfd76f5f53f7a64174a88947d983dd18f1f56ad95dac61046708f33b871c6e4478d683621bb369c2c130f6d85f28e7ff653dfd4085ef7a55b477cc69d99b8869c887a191b26ec7daf1147f87d59498799cb5359f0c177b9d98f5c2fb974e9734ea1f4c9786dff89aa75353c372541d4af7fd8317844ed58e0aa775ec59ada4dbd6722ee03ad6ecb68cc589a322081c6aeb20d57a9a3fec6eb60ce17f6f4782a63867c4fe4d096e60afe2ab512bd87ed5ea1e749f4eba2f627ced8c3b45bd25e73d818cf3d5b5f5c23794f8a6e79ac0bf0e29f13b2b0ce716315064c55f842fbe1fd191560d66367ffbd2e23aff48068f4f3ae7e4b3e4e45e0e0d01fb6a9aed887e8fc8b6d435ae84dbf43784726ce18a3d53b8dc46b195b3236ebdca811f987aa9c991c86e8e19805becbfea84f23c1fe9186f15cfe7a1d8d631322be83378ce1caf22c5deb87216492d95ff943b5138ffa4bc8ec723428cfeb72146641f188303843b51fc83b18508db2fe7fa9017c584b8d3b9074cc0fdf4a3402bbcbcbca956a229018e835fb6db25d760156a8b3b96e1e5d330e8654b6f19419bfc64f85444ec3b7b03495fe52ac9a48eec5b4b67b57160ba69bbdf05f4ae5c80f640c2ca74cd3fbc171fe65650bd5d36b8844937bf873dea3813529b14780f97d1ad73cfde9d6f2e19dff051e9e505a441f594dba31a944f575d6a0ae265f212d426c5f895c635351da90a441f85c8f0bad736c7b6c14b0475dfc35bd1cb4819a6a8d7fcba44b5e0159e762612ec6499ed9beeabac113100d1842b8d8d0b3d7aff9db9feaca9707f4f30cb3178bb46dcbf70f2d699a6e6764457d491ed8552451b05d28e6c87e6030e1afadb772d90487d693433b584ea987f5450d9aef2be6fd551544a8bc90ae96523614d92833d4d05e5b05efaf6f3d058bdf11a103ed80b9986c553b95a28b57839fb7ed9144bfe3beb6d0477b738126687ca9c5f238b5126bef3bb92348f0598e59afd91291cd5d74181d9541a593f91dba403c9b79a6fefb544dcb33843f5e0dcab040499ac366f716ff1b7ee54efd11fa34db70ef0a6552bd87927077eb82013ef8900d337db3bc6bc29b214632e3740dd4226200107b1944bbfa3407234f264ff61d5e7c76ce6372b4271b77f58da6296df00966e547d645aede1ade339c0f498eb7c431c31c5b88d7650e97d6169d36fe19e1a25fa2b657d7e68970ef50d318e482e8524f4029fbc1c0e6c237187614ad055aa3b869be6d8d788b8be4121f74f74d5648eec79374545888a56532ab3fa8deb081d0f3f83d532e8735cc15ee8349949d501456c1fbcc0f30d8f2512a7dd0b656cfc1f5f6581de2b1f370396b521174d26817a3cbd1637c16a930a0bd77c7e0eedc2a112c55f2899904f2df7c903449cb5337199e891687668b9d2d9b7189c6854510b2516958323f16ca6b1f8c00d974c15818271e57cc589f9c2cb48cf1f66d2ebcf1a789a4c9bbb6117b03cbe69f6a1da62e6f9ede3f8385c3c9cfb1e8ed8064ec33f7c2211029707d9319250c98a74d9f270b6a7dc089349eec52419d01d62b205b7a0573601b55fe6b8a9f8722c5f4bb9d159e5c81a5600203ff40fd2faad16e85d5994d692e5aa0ab7f34cec780b23540680dde8681f6733c006e4c5253fd4e625779a224c2137b8e0160f2d09f49b2d0857655932cebc58141adad8f344d5649b604e740793904cf9c18decd78d417a1eda8fe5eaf73685f18806e75e7f0c49819d84ea9c76777d8ba2f0a976057286f67702cd7cd5ecabf88c40c5531919608f96e18c538bf7b58f96d6e2d56d513e31379bc0ddc0602819c918699c6e21d6be899257bb29656d66c0ce958749f502242167a1d2148e7acf85710ed1dfa19ad926557506c5699fb501a92cd70b638df2c0e13d0064eb550a908ced0aec92117ddc32ec957108141edd007f3aaa59f9335250c37979464f109029aefd86ee4e19d3316bc7cbfa264c80bb5ceb46b2890100c83c8970847544f932a53adccf4dbb8dd0caa5ec77ea2331051adf7bfd73c981ac961a3c6ffc7501335a20d867cd86ffb1ae3743abeebc724c44ba62326add264fe48474e62cdcacf65d09c9e028d1bece795236970eac994f1c14deeaaa84948d1fadc24252612f50c813f5f7e6aea20eef238486ce338249a59c2471c941bcf0e64689eafcd88e69baf92a75c5d9bfc00c1ff909bbe4e6d3de24fa11e67e5a637d0f07395dfb5ed0de39f7e3daac7f7c3dbe5595dda702fc8680fcc9c539cc748229791f4dcc64111690161fba7057be09ddb03f14667e758791fde191346b3b9e207e075647d83625284ecdc95acad02f7c8f168451bf7dd7d3800b8e422bcfe2ff5e41c04a1e1bdedcb1fb47076e108eb7fa1c75d01578acc4b22e4af905525157497aaf958595e2faab999fcdad86213e29c2d704c82d97677d5df399447fc3e70eec1c6ab2ebd3535f3d72ac352cdfaea3c35b35a540e699463db93af31c4deff9f32e8704eaa71e30b1895f5f49d27c349d318f3d1a03c62ef8b541e39680a7e58a95117c2598ab711a5d502397c7b767f1ca8501c8ca57c76a8fce5b503c82c2e5b6d5b06f7ea3c5b07d68061cd6ba6ab53f76975667399ad70ee54ca36f1290e278b88939e6a0d4f9d86bf4c709435f2cf72e4dff8af716956ab4887d760ee6d72f3c1562da822afa2318589a0d300501559e94c91c4ce6056dfd0674ba4dccdfd4dc7be6cb80c75b16cf133a83231e5dd72a48140504b31771111c2088c5a5b19a619d8434859d4b9f7e61502e694dbd9d7162bf74c29e220e552ae387f36deca8084e75dd5d6afe11f7c90f3a2a17ae42ad74b3828708f074a3824f63debba6089bfd6670df2611182465471497b16255c5ed1fa545d865f172b92f9c2ff3b8d575644e37e0897c0d7574cce3ff932c06e694bec0d863a0b2701bffcbd17103612b5cc85f25a8d34e9747d8eb5a7f4642ede2f91857a342fd4124d9ebae3851382e0dbd99baa93a7c00e44e7f0d783bd858c0700b74b12c894fbdd28b9d01db086bb3686988c5df2fd0aac9e761b2b65f4a4eb3dcd2db72c9878d9ef7bb0de8abbf20e733cf87563f27ea6cf029597a46d03f0a47fae5465896f52b5c24e26a1d5db669f33e94f0cc94749974dc90eaa0a7f32f6ad36925d17db09f029221a054e7ad46b1ab425ec2e3e82e88ac34ee66b5bac0091f69d1225391d354439560a57363a4e599b8978de93b2833e3319005a6da199bf166df479044b96140cff1c31e75ffce5708605c301a8514a1fc275e47c2d28bbe7c06d36aa20a19aec04678237ca6c1ba31fdd5b6b8bce5119b91575132a4afbfe41b049c479bdfce95d2a5d18b3b9661493d56d1efe2dcd36716e0a5accd890028d3fe171c9b1431250ba01485a811979a6e0422d093bf94e038dfb04dd410fb99f7eedd695549090075d11aea0d3c18d006a4e57a6f0a3dbe1010bc89a01387fbbe668735b45e42731ca58f33951926f0d3308b7b35fbe6f2d03ef050b6e077761cbdd4140887d211a60046f5e0a61ce16252ba7dde535ac33525078b9602ef7db932e7c35216b251b2bb1522d1d07b5ec4923eff28ce711c13a6347658c90d0b55243f09da71e978868593ee45c7b4d40740a50c04f7ba480ececdda6016fb4a84caefe0cc9b76e11542631e8d0e24b917ac8b1deb83138127cce2faceaf6e17151a2d4165ee44738dd7422eb50fc657988a9a621d828760b704460a22e28230c47ba3fa716b7347502fe46d50b94e3d48e62ec406cc0e206c84d48a0d4ab974b0ece442a77d2ca54484fc7fdcc650eb162b49944122b99c9e4fa08987309fcf1d2ca44bbec61dc5d225a779faa0145c0a91f0203cbd8e488d8437037ba0327fa358017c33f2ddc80c2948ad412da4a22e89550fef36ff98b352fd821e32b701635c37dc78475642f5269a581e926b421dc93fba983033458b691e38ff2815d3df1184fddd6e36b90b6a8639ceec5418690e514042ce7a912955392da574e9abe266957dab52cb2b2cea55d4e7efefe20d336f143f4985ee92baaeea02b8ef76f7faaca261df36c01954fed34ff7133d7f842f736ac20f4dde66f0f78daabdf57f16074266b2fe6f9be7518b0c253fd970e5f715dc751825913093030b55494e4dac379d80f3c129c7e4cf89ca68443db42997fad4c593db663230e54426b166229216a45cbe979123fb57ddfc01df66c9dbb6bcc24d6feed2a47b41b9da09c1cadc53b2a89a699acc61914e78962a267b10ed54df4642ca352c0f4d9ebd19cf72efc7b88532819c41af12f3c284a90ac19d7d9a3a854f2631278d693525077d0ce4f3beb5dc745e5b34e0844e08e3b8cdf15bf6b8c2be0021818f2a7abdfce2493b3d916741e4be8e144cfb2f0a64ff8f00c9b277469760aebd8bfe6e54846f7180fcb6d1d8f5384ced17944404f59deee8ad86fb6f6f70beeaed91bc985f565d236c9955bd4532f1ffd89759a4c4cf81f3b619a7da7d1ce92a60be8b0e8a04788e697b65f3c30d3b85330a482f80410be76000bc76e78a29ff8a3af3fad66f69cd408d2200852494d347b7bb61e0842430100282f580cef5182f2daf608a0b1da9c8386fa8a9504e6e378e26fc5d6174ae6a778f54f66910162dfe2aac6da119afd4cb21ec82f26194cd6ace7de3e53a85abba0bc5b78372c936befeb63b794e78a28f84eff1c8c0715d5fa4aa6f16a9889091e73c472956480fa270e26cd7d570afd0e68b67cf225b0071a03468b30f108a0cbc17238afc733a99ead994e2b1250e92993fd78cdd1ef5d6828e6d65a0816f651758814770c0f199972f9dff0f3b4a2c0f0932338dab8a59e0a19650142148951eec2ea8c70e3b2e95e6a97c07f686fa6ce015c2c132f60cbbf88c64a7adc70544cee529b3c8abad223ebc245f62784c8097924a08114bff4c738aa99a8c8f67d1b9890d3d94e1b90faabb3e7ff099b2119b70bc0dd1788aca2cc2010aa2607a9c5cb1581f278e5c3363f5a5c4bc167831bc258c3dc8a4ba4406913502e23a30ebd6760e8c7fea3764cd4cfa8894951bfcd58d2f1cf32ae53b0e2f344495a6c3ddde8d25c33bc59553272865642004743d5d2e93178ac5f5857dfac446279409acf301aa5e8fcd1962edffd0ffd877e51d4245c02a7a38c5143d01e402749901b7116b2ccce571584823c125ebdfe5e7f969066de8a2dbd3811d74aec4e0af53f79f3c8bd0382e927d40d572730db549c22f6cc0ec5d35eae0ad1dee9c30efd37e2bd64ebe81c538ae04b9da97b4fe7f33761798fdbe849e27e5614616b637da3ebea263b1dc7d5c0b8c6959a1d8ff700eb97d281a730e78923499bb45481b48ca5806c6f1fd33d9df5aee2839cf10030edbc248a731ffbb51f9cccaa60e3a0bbe6023792b3032ddea6b3822628dd1a437f7aa85a3b3988691c72a1dfd85bc700b3ddf8ecb25c459dc665e2fa9356776479bc0acf7fb80b3b5636d83f6044c11eee6e56fc3337e4de52d0b1243159bd0ba99b3da0f9784d5692c3110ff3993c414c253cf7422ce88eaa29dc3a0cb6c6ea1d9fdd58c7978c3ca3c9ba62b7f307bf67a7dec3e05a9bb850046516d111802fd791304fb49af16a8cc8b5e0eb7dd00222279439e8e16cd691c9c47fb73a27d5879711d577374f86e418065cb27a1b52c54002ef4cafca64fbab689e73e4454d559ea5846144edc93c418420489ad3267abb771a034272499a54654d2c61c7599835e305fae86b2e56e905f43cd05b1575c72472e2a3fafd45d6f61d38b6f9497abf34484d8e5f3a0b71d182ca480b8547e1d16555305031bad49fe36503e485c9fb6bd4b15f0fb7abca1d17889671fc0d089fb3214962484ca80caf58701c432d659ebe24e39a5352078745c792fb86a26cbf0f4516e8f5fe1fd935e6e8f7cf09e84f664dda7dc700a87a4940f5542aeddf2effa53889c42a87f4283cbcb77735da0daccb7b6802e691a2546b84590ccb2764e4d63c08f72b985b1b4663ab123f500de278b8982937ad0360f74d9fa63ad8cc78bfd919b19ce90f549fcb60a5e254591980faf61e29962400576b3d3982d31b64e69c7effa6e4483787a73a3422f4c10af0870798eae8a3f70e046faf0df4510646f4f0085fc43f1bf6831deca932c11f20bb934fe07deed08acf0a17c0ff916a21d8135a308985bde87e609374daa8a8c4eaa5bd6f75baec720e8bbec0e6dbcbe3002cb8ab2e6e9fc7abf1c55d4c1bfeb64c21da73b1bdfe6978e7a6f9c4009710b687ac451ea302c906f90188782093d75fdbb892dc434214186af3df0b1f72763ae6dfbf514afd5182b4131cecf82f3426e89912e24aaca70bf78eceb6d97ef99001827ac5f8a096652d0746ed9905facddce0268456f4a6976325496adc1d5545db269c4c41fc6f6ca0176d211de44a1761387cac3d1b792670221009b8470bad5311db74c531663a86a9772a72cd88537a0f1a0c47eae5e2a1c121d765365d9699d3cdf4909403ca95ea3b2c6dba2de074be06f372dfe7283af86dc6715521cfc4d7f674ba533a6965942e752e0bef8ccf5ae605f20fae61694b35b6bb1b19a6ff75b90478ac7c27d6883a69880dcff2ed421e8623951034a039cd82f104424c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
