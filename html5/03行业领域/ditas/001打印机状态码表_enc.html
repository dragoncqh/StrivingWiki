<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"765d819ed7e16bd3496024f6339397665299d79325cd3b0d0447d89798519a9d2a7bf4cdae7aa280a31620c5bde8782ff704d15ef44244cc41fd501ee1baf708327cdeb8a985d30b59b8abfb07d895e80f7fb5dcd1a7d1bc467c196ca0a450c83c6dca7457969a33b77aa1637a1ca7c1b547e1a8fd857bc6a6bebaa1da992aefaede3c2786ee9e54450880f091229447b73b07f3265feed6d63a83baa4b525e72b0f07f5ea02d4143a6df34fba7352bdbbcf24ba71f71ef63b56dc2b99bd95657a25e561c286fe5d277194e8a3d27cae6a9ebd2d4d1b0aeaa30f3638618b09da61adffacb429ac89cd2b3a93aabaa78403f7efff2b1720d899d3bbda7f651ba46ec11197115dd24b81b9c4af219d6de45b8ab679fbed5e6e59f163138e868fafb58d5421b7684ffad6f257358d751494e4ab5c52a13ac621214c6cefb7c7e558ba079534e709db01109e98943c98e48d8f31f7ddb40b0fb06860df18c409ac63044bdde61073734507ae1a8e673aaf09ec70a31c4451af0bfefba14fdcd9ba8446f06a4f3310e0f51a09fb45cc3e52a441384de91ecd38d08fe26dcf15dd522229752aad1523a3ea7b853c54c6f03ca30d9e9219df59b829e92193d799a4b0e5b50b99ebb98e4bd81eb24411dcaadbec82a0b3a958d556bbe17379f51608a86803c2459124c0d4893ba0f739c90d43260426f124d2fd9560628842ea9dd1500e7d360a4d4578059ac98e5fdd52cb9ba4e5b911eafce158deade289a3b1bd5ae82a95dd27c52f7eb789ab0e7cebf65b98a7d887ee28257ee7b710cb5eddab7550b1646e50dc8701a3fe635ce7aa71120583a3f72048d1d6ac1bb0bec5ad8bf24edc68d89a3818facdf7c3f69faaea33677ddc4af250e4e7241cc6fd58e613ffb7faa300b3d354413cecd3bf35d33e173c6eaddec18921536dbb8648ee11ac1455e7f70afbfca4cb54598c6ede7758aae46b9500d8309c2694425326c30d8bc9103002f96a09fe3359c5ea19395cb6fa18b032b6e34e8bab801b4f875b4df63f92a1bdca941d031ade09b1f70adab71558fad616e39824ba0c093a5769e8bfe02dddbc667a9280e2f1281538e01f40de6cac82c1b58646cf7182d83e594359dba1b75ce5b1f6444572da9484f1e79a055fb1c2723ad0ddef0ab2202dcc69789da90ff2d58ea84407c364c42c0d6e2b9143228fcdf0c2428f176ebe3a1c7fcec61eaf634e3727cfb401386e7880d16851ef08fab340828f17e290c335122d432ff1b86328b162f22d6ac89dbbd1703b217407ff294fa721995564b6a4a395018f944fe25f019e90ef99c585f0a3338abe15ea7530cd1f28c7d97644eb53954f9075f80939745c8fd1f1a732e17081dd7f50e3d25e2844ef3f04b9190b5e0bca27de8524d141db2f6e29adaa822347d41319414486acab6cb5f8ac6937bc6f2a1e3555292eb0e03076f1ee2e70259ec5330d712ee0dc1b6a03d2e374897c186222c59c854f1d1ad54ac7a9978e10a80bf4366e77960e0cbcc0057924045180eeb20586724447d9146984170b390ca0a062e042f5e70b945a9069cd0fb52ffa9abe1b9a74df367e6e6b38e7a83d0422fad57542b7426a80a8047695d596c5695c1c80dc657e3edbc5d61fd6ce4f1c6fa2bfe313df425acf93b8071a332a85946cb5300efe1ce0ef2ab0e6b9197fbe98e0947e08cb9f051c6c6123688fe3446ed47bd2df96b37b81efebfd0529a1359ce78798d1fd919386e101f32efa319ff54578072b4910eef0a5fda8838e2a46f47f54cd2f79663fa01bba8a07e822dfc604d7b63d56164a13f8866a968b8a4c7516fe0e916001bd65b54892131d719afbf63fd145d4c9ece66e8bfd1cdc0fa2532a1489c77e4c45da9c9064e636d0be4c8ea123930ba0a99bb4b82e65c33c27ebcceeedaffa338531c55db7f357a8937350c27fefee90c44bbec987d3063ccab73d3338935b1af102bafb9cdc33e373145f9c00f9d5168a971d89bfc032264aa054013184849090d51b0d2632a942f2b4580b39b447fbe95e50a8ea5eaa60acc61ebef6a916b8ec70ddf16608170fa1fd887af400a78eb130a5dcaf4def69ea610365f6297ec45749fc88b26caa5f2d44112c45879c3dfb7541bd30b6698dffa2a8dea562a64eea3c042469f64c4d7664870519f899d6226beed67827269e75f9fc2664f0dbceea4314be698c9777489d8d417747f1045d3d1da5dff4d177171d7eac91cf67c77841a2a638199d3aae977afe2ad787cdce457db98d4495a094e2729fb462afcec2434460726a6a88371e2e8e8df9512edf0b5e89b9b351debfa8041ca74e86daa456409903e24ab35e305b1f67f5c551d4b6f79fbd9a7d2ba3cf00d55199c43f68024daa2afd5b781b8f43cad0ac9b3e8424013094870056347e3c337cd6a30d0c74fa03bb6e118232d1c91bdadb6120da5ae71ed893953986c5b756bca6226c58546c9be0430fe1685ff13eedd5daa2a9a2b9ac25417051c1f1f2c07d64d7cf33246efb85e71329b660c13ac7c0d6eca67fb3f4fa2fcfdd35fe86ddfeb85ca456a6b67ab52625d5b053fb9579ba774ec215ea0bcce36bb61ea77f02063c5efe4611f79097ac5bf4058c7eebdb57ab3dd822a4beb07d095cf721d40c58eac3806874f9ee908b078b5fa806ecfa4aca865cfd029a4b0b5ef14bddc2384bbd608d776a4b21639696f15b274ad31e33fdcc937efac4febe7d8d765f046b81c2806402593838e7cc3f40483d10b8d2338c47f9610008d012e183034bb9ab656f85df3feaadd7758c1126b0c2b0c9e9a2a189bd39e97933bd8bc8a105d972cb1026710b0ca88a4c99e754c275025e21d682121f101cf9b42481e54ed3239ce0591f7962b40560a23223a0b60167a2243e7943516b1027ca3343cc839c2897365a63b1a86114a03f2483fbcb1076f27862b1e236c5dbee912c92ea4b20f79b3d672214037c5a8cacc3221e9389953b35427a0d8dd762a585a6fa9f32c881956e4754490f4c6af1005259c0a52781dfd2dc43b4b787e1e1a75a13bfe042ac348ad2ea753779917cfd7dae2d8082ca2fc73749034cf2a9b0757462d71841ba337163cd22ab4d67b279c560029e863cb1b7dfe0bc4adcfbba10e4e3b3f15300a19cea4442693411eda343b41321e8aab5c29900167e4e739bc9c5f0ad30d9f1faaefc4dddcfdff07bdcc37e9a9e9b3ee45bbdbdc53b37425e7870220638080e30ab7010c57babed59a2166abbbb388fba67a4d6518db3e0d295d2e3c0aab370919a6bd0e1818ab61d91dba2d07f983853c3d1e1c6685624bee31ab64cd4ef2c0330ebbef372fdb485fcb54306305d5af61b18c12e52c01e952285bc6a149a0bf266f8ca523c29303b1f0ec7a75f8bc4feccd01dd4af840631412ea2c93bc476c87da8e0e9d04a51f6226c1a01e792577fcf4bae2f77a68deb35941af741aa62085497ca8b679427238f1e84148bf64dddeeb34a11c43d95b11ebf5a0adb03f8fc5da5ed80e6546e59529530bcbe9101d71ff2837d21e4266856a2d735d445a5db907b54f5ec37cdd49193aca2284f16bc5e20c5ac39fefafdac09d20cfea2b1ef8adfd0b87efcdbe676410515ae1913c4bec5f751dcd481dfea599616617023fbfdbb3717edd55ab39ace6ac503f8b7677807f8e6ba639f60bd963135e11a5048fb80bb5dea3004edec59819e413d117841e7db750b673724d49bb888e2678735b63201465ba5598eb6bc6dcb027ffd962f508501d25e984c1f0fa28b5b5f9ecdf8cd1f9ceba10ce62f6c9970121cca7297e57aa6bf5fca60a4de8f2afae536dbbd9adf3522ba8eeed047ddb551cb48d9d30b29ea114bacb0b710698db203bae66ed1c81434005ed43434eab8fa0b3e081aa9258bf1267416199493209bf487aedc803602b9fda35694019054dc70bd3721d0a467553f021fe66a065cab0b00efd166d638b2cd019703248248cb309e0434d87b0b2272cad4c1a6991e3731dd52b473aaa9e6f10b5f279c4e017b38d60b95fad77693930d02a503c847391bab922e73417899e953c1327aa58a83a53657e06de901232d9892096906825d1cd04c274b30f8f481d4a3952ce8e792e07dadad0de523a72286557098cb34ba2dcd48f62b30d80ce5ad74962849c963d4bec9c7f209a3f4a513ba8eb7a19b77d3aa42564b3b262c7f8c468c47013c2d885b443e419ba0c923fca2ab971f64f48976fe222d2bde380f287ee7f57e76a813938a2bc4f48db64916489546e0a79d55bdb6ae3f89ff17cbc5fa638cc3b84dd77de8987c87386b6e8f39989685ad38906c4d3f9f2258415b98dc490e54e760a5b216af881a5aebe34efafe385bc546cae266ecdc765ecccbe5d45b70687f0317edb09f67d507734965c6c47144c90f9df309405adda107c88774a0f757f5066c73763a1f316836755b4637ddf4c8607433dcc2147acb79f1c87bf25a3f63503f05212a3d79ce58205bc24814308543ca3f0d42a6abd15983e7b40c1cfae353c18175d3d8cebd651d47e7318c1244af0f53a3863336a392b89d513468b937b329ecbf77d5fb82476e550c550e697d673f5e7bed0ac928c29bc656a0b287234f74366618a6df18649b86859401a03e35f40033a1f07c38f531ff0fb3632d257013f407f48e936eef42174525de57d5215b637a38d8d78c7654f49542abbb21ae8a73ea242e4a8b5609811642518deb4e700dfe691acd60e05c7fb973b7df81bc330b8fa740ff533944263ccd7a56732c8f890b1a7cdc9c9def81adcd3adacfb6c573b07e32ac59f4def1dd01060c73cfbdad6c5e80b9425ea6e7d2a1e3383947c44d53b2445fba51121f3ed0ce78e878538f84b8af1f8550e3a7fb178ce73d5e5d41d64247474febbe6696b177aa88b3d81de814aa41368d53f0087773947bd95816cf2f8a03568cc50a336014395ae46bab377cfa34e8b734269489b1b8576daab6fb01709da69f006f5bea645e603428aa85d061b70aed9b4353632043355bf3dde5b78c28e5b00533b238c5f6533ba07351a4a5d481717df32a3969196145083cbc055b92bb193e161cf2ba4027bb70f3e039d35d7081233add5ba9136254869ba825b30eb14287bca15c10a2500611c54552bb7d6a0ea2cd7bb7e07447fe43ae7dfefc69d0964eabb05778b6ec5ee1f59db693b05bbf369234759fc0117f0c0a54601c0d811735cd4578ec575d17afc8c87614b61190ce9b2c1c4c4026099b8ab9cf3d0716138acb8dd629ac25be20baf2ae10f9c43635d8c03531156f8e9fa5d503fbcea44b507749554d8a3edc361e715f77c1505a2d3e43f0cf25ffc67abf4c876106f59ea9d84a4ea28e8ae8d3e1e54c118816e8888ba3ab364f32ce1e32510b3cca4153bda9b6fbfab6561dce30955146ab4581eb2a07d7c226eaa99f0e55eab71c50b6529474d7d20895308b48e00b441efefd83b9c5393d6314fcfecbb963055fa0358e87cfeec869683718fcb19c917da859e7a4160355a6bc55893cd7dc7506f25c37ada63f90e62025ec0062453ff7c9fad812262014a513a4dbb292d836abf7893b2f99bf9c283388cd0857a5480686e05ac51d0309e1062f95886665ff30d1404b5d32105b665a7ba77c1abf30d85d1ec0bbd580afb250a8d50914344d5f303c6cb04b9e7c6207b818bd1912402724eed63cfcdd3e3eae85675381d6170adb9ff12ef97809bce845ab0df8adda1c3111f4067a13ecbce789a11047b26626908fd1a69177e7602958713af445d1b05b9dd63663b4011e1a8e405e1415d3df7c4e302b84cb24a2532ddb341ce5e44ba818c76241624d3ba697ef9b867a6599d28d1b8933933f4232891c4f6caa4b22a04846b6b216faeeb48461d5677b8f828e54260c5dce57b0a574fa1350bc753ed0c0db9efc4b93d9cdbd58d49f1aac8b9d8c54bfb4fb0ab8675557c4ab20e8aa85815520801f7b938fea68faadd998949d7dbeda2372789f850780d30aaa38234507d4ea2547a057c51b7c5b96b3ced4d6b62b25b51e37ae660aa9858ed54df43905f37c445c79ebef7d5af133cf71ed3c46d780579bd7edd9063590c62e62826d1567ed18206cc1366098aca1c2575516541b6afa44b81aaf9fec489fafa92d22ba6bab9f480e5914e0788579a3b3e80136a61e4c8abe1865b3a434a3ae9e782e01fd6b459beb5e6c871918a626c402697140ddf2a780689078e12a4feaea47ee119cac895401f46d7c6347e7b56e5b30e913deef8fa61800dc25ffb6dd8693372b02829e5a1c506a9f06a9c9b80da417af9f073c960219d50e327025eab369da78c2d4d0989422ce90cdb301bdd98edaadc7fad651093b19f381d3e09c0192c96219887845eac754576ee8da49f7860d378aa893e8d313ac49fef1efe448d503b2e543de0b4d5ce783ffac6316b53a67085ddfb38b9d8b434b0f0f5bacfdbcd366b5b03106041a8e342545020481ea694e828ae243e2216da593714c130b96f17a99b0505f05095232bf9584f1a055e218c4f3507714be3de7b5e48c686e2ac84c4081b93627dceab8c64d668287b0f6c417e5480289907e3395e90a4561231a14faf4aab14d1e9d00a3ce18326b76f4b3a34246399158ad8b9a219756e88ba37fc2e0c2a657c74c7a6d4278d356ca12ce5d72cabfbf2698d418b5286d538c06734bd06edb634e54ba221b078b0e37faf1871c490e2c38338bab6956d81c7129539c43758418fc385c921103f5b8d70b3e55463ec5558f5e7ec9b3108e22e215520011720a539b419754f097ac24f50ac8d9ec561b94e59707473dcd2daedef3e21e072b580530cbf824a28e8ca45f1fa7fbf4fb2523f796ab6da5e8e9b414ea369178e60c9012c2c70b94bae5d4d29d8f043980cdc2af3763d5e0393052aa7770735df7345104ec541849e72542adbbcf8601e54703708860ccf1a08167b3517ef9e027fa7dd921cf2599515e330d224a98328c58adeb4dc4495562e6280e221d7e6a8f17c325c46a818dd0bb51c3f8b29c82f074639d0a42cbf88ddbf373dd0499b027b329d1ea79457597b56f604e52e0fd507132dc3e85faf6dfa0577f766768cc2294c8085bfa75b533d700ef262edef340461abca5290f4505468288f1635a694d271955b5974c2a7260bc87258c64634f4a1085c0427208a5b8f9b4a774f990eebf8330cddee67ef140970527e4c58b4936d1abcc0d502b06962f02593f4ef0d0809fb496106f38d8c39b286406eee6b460a2af53ca3e23c2b5c3ce03126b61fe0a600ac90c3eb4d5b02c681c8094a969cebe609d9536cf78cd5c5705c876ef0f9e5d7e2e22490afc7a8fdaec02aee92c866e55ec9d70182ea7526457747b44b712b5b4370b69ddfbbbb3ed1a41427414c4e614af879a2ccd2b33f066309f5fcf21c137d09925cbb61e5d678ea451575457518925cc51cf77a536e29cad2a2b37f0c2e79b0f177e54b17c13a69cc2b8c1cf756545f8f42059a57648fdf9bc9f820c756c41278600ac4c0b2297de87a0b451989e36cfb71004d4f260b8ea6820fa78411c05b35916f8651f3fb36270e2a844503dbdffac55ecf4232d390db891b5f810ebb363876c3e192fc263caa8697117a33be54a129d389e3b012b9524eccb8964fe3edacb9c33f2189f34f69bac745eeb4335428f5c91af9f033e7167aa9de75a0008388da9f7770fbc73b9e3085659c7bf91f47522d358e5b3d24679a0cad9e4cb35ba3c7d102e05beb22b63c7df580e123d8648d8999bf30cb7c0fa31130a5d6c70525d931b6bf752c6cc30c150f67c8a7d038576ce94813b79cde0287f786c9e82225c3be6337f08456d9fc6ddd481ca58329497b13d094cab6fad1e3c1eb2b28753975cc6926a631430147c0d2b4d252d24fbbfac261ee3dafbc0eb988230cd11837ae47829476e80ca1d3fd18c50730db6deb337c07dceeb4832da0f3a727a49a79a707ec1929bd00f34b2832609c2d7b356bddf5c40b203144436ca30808184ef2b4c19b1dd18a6e96181788cc0bdfa149711eee17923126950f212a41107291d15988825c292b4e17ef12b36a0ee8df8546f80a7936681e416abdae7204e09fc3ef4cf93f668f5287892de1c3ed3f59a9a88bf65745a6af92553237e14c4397a816621dc7354dec654b3ad11616eda911960856c718f8067830193a2088247ab4d3991a75c74f72e4d8f07dde148ef2bc3bf676c452937f5dc6ced7d608ba12bc0ab2f5d50509c39203d6a54ad4e1f8ca7570bc00927a463fcfa8e0a0e317d2c2f637e74ae1e9b2a80f5b60bfe1a71c98800f6d77d0bcde9967c6bcb21d41c46a69fb57f77aa2f6b0bb46d43a282a4584d186b1fdbe6f4c15933675e6f63902dc5008fdb97a10e0fa97356abb7f0975e7533ecae","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
