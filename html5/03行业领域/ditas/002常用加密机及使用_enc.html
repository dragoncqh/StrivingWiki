<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"13300269197dabb15783080a2582b26f67fef6214d9c9597e2c164c46c3f0d4bd0c2cd1a9223909c9b851fe044c510cd51f37eddc5dee720f9dcfd9fc52229aca358c14afb16e4961dad13b0d3e0a6cb51824873de045c2c622f0fffad67161ef26531e30aff77ac28586888990f614c9da453cff4f2dc62f8cb396019fa1b1138440675ab7f4b280ce68e5e78ac93270be0e22f4d616e8b331ab0dec42e8f5f2cdd31794684564daf51c8e3fcfe9f05fef94a66ea639792669a1bde5c12b3c0a7d653e343f71e636a4645fd991159f2d1849b6d3179308f601a30393f427d92896c6f57d4f449e24ccea293f86218a6bdee2c9f644c9938b70201d0002c9217d4aaa4d9ecd9383cf3a9ee48ca0f051b7d03e986ffcc218b1bc24e68fc9bb95d262672fbb0984cdb37daeb6c754d2bda2cab68ca6fa5877d2c24fe271094fc4f7d9b1d5dc186ec852b187b9463c352dca5d710c99ec1c778d4557a6ff88a1543e70c5eabdaf5a6e8a70280c421dd3df246b95c4a998153fa505c2ebefeb78c38c562c579bb8e611f427ab0b7bb2b08e30be9db2981ca29447c636025a3f6bfe05b1d28c849882cd9b5c1e5bb2ee05b535432b1ce8718ec7a7a0c2b7707e95e16ae282aa455e51378f193b5065a8f06b7d6992be4f277a2f1677156623cb8700e76fea25f53613279808de95f907b3e48442e88db5a1c6396af524d1ba9f59484c860af51bc7311cf4adab33cfe017f2cff3dbdbcc8cf80d4d2fa224b206e7351a4496d04d2597daab4b73903b8c8073c0ec39de57c8e281c2f9392713f33eb718eff4476e22bf591af9f9aa203916bc685324b53caac6b9c89759e7fe134802e04938aefb1521fbb72ba5f06b88caea68a483fe68f478022620a27bd3fc393380d3d9eaecae7c09ea1726fd42fd5f16c3a351c9ea9dde120367a709bc926d717cfc163cdeedc2227f07fc88e9d34cffb46a8156e881da866e2205261c7d3495da9ca8cb9e3a9ad92c881af23deba3f0504099fd46af5ba8a9d97a1af7c1f3e84b8282de5716231baac5ad305d7adde365ebab7a914f921adb7ceb6ab1aa0e12ffc2c7a5244d8e8290aa2d0c37cd890f7bc2d0a8c1f45347aa941132dedfe27399e4798df1d21c9116d27d68eddc4e310cccbe9fd1c27cfbaa9e64aa9e1e6e9cb11f11cc7dc45230fdfb4313a1d89fef04908ad3f059cfc9c2ff5d3430aef3ec8f24b56a2ea2895b14b94080ab0b82937ef8b82142e8262995eb30f3938930208552d6ad4bc68140184acef01fab73e68ff9fda71f5045a1aa6e781260ef4743b30e591e13ebd0c8b0a464a6a5c0ad53c840d1403a22d0a6169b19e5933feaa99b51b391fd7f06b615e3c2587a6116da673c164b9831e723b4a26422dc3347ba36ac68afc8912059a261085d498c4f08b11076fe3612bf41af6fbc8e0bdfbf00cc4b2456cb97d1ef147a21f7e93a8d8fb29d6a5d16268a1ed914672c793143d4b80243313d207b308584b1078ab3bc039a03df5f2d57fed9ceac7017f92828e8f85d935027c0fdf58bcd300abdbfa6a55b6f1fd526b7f300ff0eb5bbc264e9f8677ecaff6f7002cbe8fa011a17f30105a5fcb55cfd4022f574f2f054ffb4e07bfebc9e46e9f29372a452e36e6e80166a69cb05a5ee93cf6d13ba035ca491fad9a86d2cd00b4aa4fa7482bd42d23c756bcd3b1f2eb5c978be1660a82afa2a4bfa35d0a7f49a9ac6985558d4bf73b2a53e11ab910634ff4cb5e55793e4749b941c005078712973b7c6128806744f5e809bc11c6703de098502f9562a733bf72e87452f81ee18831c23bbf65a5b1b891e15234644acfdbed539f709c84c53f807c32af891e8b68f35759228b3d30551eb3c1a55230e9cc5b20db959f7794d2486a69c16f16706f6d4ae312b9bd41d0173d1895e5569d7844abbf238404395234112f7770c48c7598c9c9d75081566a39d8fa9de4461348b668de81f5646d3446a6b559a5c0f635f4c6e5bccb70f5fa88470a4ef9f5f5b02abc39165bb292087b3bbc7d2742cedf78af52d7e63e0c3703b233490ac3c539e68a21589fcf30a74470da7ab6551c73b2f2b2241a3393bfb2cf27aaf8ea67165e98b72747d39c8f4ebb3013b111e2a4a89df2664d21c94301992a12c07be851e0f58eb77affa5df4affabd684c922ab605574a430c611f09b6dac65382139c4e1780af75fc1e199fa3e21ba3693ea486fd117943bbd439bfecaca39c8077fb738230e8dd19178104721c0ac9fcc22092e80b65e3b7bf48a939247a46b25f61c7e6f1b94179814f4f835ed71a02cf1a4878c72a7fa9f3ee5e9cc916a519f8e4cec90e8a2c3690284bf711642741a685bdf088bb03b8448c0140229f2665427beac639412b77fbc3ce48f1e00f95fb17ab87c77631f723faca0e40cce068517027c0a4666e19e00475d9d4fe09f49d08426558883f2d7755799988c8271bfaf6547a288f09bf18138ca38576636463b5ebcfdf907ee1e84c0b08b5a1a891d527cf03ae0f7f0d9ead45a93f6526bd6b81f24f9009ce3e1630988f156fc56f3521499899dbd84f4df6b3fa807bfbcd4e510357439fd7965b8c91a968b9b34545fdd59027b8d1a2d392269449bc2602945944dc5e102884ed07f77ebf73fb4c665aae6e1daaa4fa517d955851e9668f8b30b14f7356e9d8e14e5193933bab3b1102ec66c6869bb011430400ef0ed51c0b137bafdb707cc7a90b628ec97fe115ac4a0d5417c03b78920db583c7325c723533ecd53a602efa3089e82869663361d103ba6c01d964d15790461be80c26a6438fb4df55a12063f1b5ee93dfb37943283c9b04246d53e7efca4f42566f8f3f63c8af79183235e807c5bfa856ec97c47ec3590c13a0eb3ce411bbe26fc94c8fe5077538547055c780e557b37e84eff73e1ca8bba5b5c57c1b6c62f1cb9fd2fd61c7a4786ed08ad160bf3bf771b7f1996f95e00f75202801481061451233bfe5d76d25b2378164055b6623d170c66ab7d3075ca04f28aeed47b462984054b99eb280f784be3fe80dd8a8e2a17ca571be56c306020f12280175df8528e68add792417e865985c02cdb20eec9fe04e7fdde30fc04ca328b64f040ee83034680961611bcfea68ddc11fac340d3cbf488c4ae22d2e994a9faa4b662561ca8e909d6d1820edb189ad2814916cc0a0e74edfcc2e03d566e54ac15d762cb2280a241cab51fe261eca0eb5ec6eea5a5294c1cb493688d7f85db0088263fe0b7f53e463f73895089569383f11322f51bc0f93115e031f33f109cbf19d2e52ad838df6e15434c7fe437be28cbbec23b75c86bb29e630ee61edceab45cc8af2e85a7182411942aae85226ca66daec778c95c523fb19fb8a5b9f3f7bc09786bc9b8bf4c4f3976f583b1851e738e717e48f89fa0943016f88f92d12fd7783530dbb2a962999bd7a8eb347ec1563066f5804cad6f1d16e10f340996167bfb576a91d048bb6e0f6faa95fced196c53c41469f0f726191db975a579395291d59917a693f3fbc595af1f5b539f4049d2a23b00a2e93cd66d32cfe04c1689640a8dc3f62abc8f735c770f087e8104ba0816086d39201967ab6469301616a261426b7f2b3917a89f728475effc9ec134b64eb8f4467c6e5fb5a39bceb7acd9e1c4ec06a3045faf4d63399bf15e9da92931a38a2aa3e845c9a86c14f00e2ec5358c2bfe26dca912e9af42a5d9f8a0fc04f6ca9c2dabb90a8cc1adb4f45bbe7b932e6293bb64150c3cd367d8cce79aa9268efb6a16637de0839933cbad5e566db09f836dc28ca3f6b538d95cdf98b15dae76fbf71332c6add32d0ea887c450da59af7711fee7c7deeb4eef055079619b58a2777105f4a1e84666cb1165a8a93d43354f5f02e178671611a5fb525d01cf0c59fd44f92aaa85b271ebff01f9fb59a57261cc5d7eb9306780ca7bdb66284c9056a65f0e5a0003244980fb8c2a89de614c79279e4e8078011d74c449a45fa7a187b39583c0da1d33e815006b46aaf877f4c6dccba5f8d7af0fc068816eda95b0d3fd63038e4ea37eb0275ce1f3a016a9160237e512a67ac428f4ac4b1c691b62a654d0cfd18d6731e31588f9e2a5cb26f27e996bc220c04d298dfe34bdda2b82975977adadc35616ecb99891f7f666d561543f91dfe70abe5be82aa8d8f47fafa8401da58757949b46ab6a533c9f21e74f202707db15d89e9e648d7b1c4935f664d2b559d38fb6aba1879f0694a543e61e9afb433c8438ddec9c9df28cbb40c0bfd691825f7d2b071c713836a6b809177f49d6272cf4b821f29e5670bdbb6ec89de21c64ef411944af9082ac580d0369fd519953c0fe8e7c964c2d58bbfb734090c6236236e36cde61b3bf8e9a64251246d201a163d29592c37c5b26d24ebe5ca2c45356b2a43cd089be4f8f907698ff2b70e11d59d24d2cbabd3a580ea2aadc398e4d1d9d7db9d98a4f924d38495f3aa50e3d25b7d6d2cccabac28ad0a1b08dc113fa9c29c5c6bf93f2e88db1fa122b86ef8a52b1aedd63f0b1bf62fc771d851057081e5fe5a6025d011cd62152564d72f8c86ea812f124ec0d23ea64be5ffd541d0541c1bedf707562de118fb88ec93569a8af01adee7a7b3429ac894761357988a3a53e328e09bb38ae52e8ffc64ec2525dda9dc94bb527f843523cd7942739c5c28fb90c7c41d475fe7bab2a21dcfdf80e16ffb79e398e5c26e3a1bf3ee4173399340f77e124df9c28ae7ecda749fd96830ce4c5ed5e1b9e8ddd563e6ea09e16b42abdd919828fcc2d4b35f5063a192a7d6aa8de5cea52e00e96ced275ce2c36ebdf6a4402e7a4a308a0e2d4f21507085e55829aa178ce5cd623729bd531f780d2df3e5f2d396b66866b401f6d3a34da2ee8b172f810cf4d86e5407410fad71cea7c116252becb3f467c907f05d34b3b00a3026b1c7af70f1eb59faabfb52dc81ea3f22101e67dbc219d26e72463f03d411f2bc4e0f25ccfdf3d6826ea06201509de93fa1b2090aee768a97aca3ec0f0f3e0e1ef3f4cd32bfd77de0f2dcb5b2e36af3d4413459f818f31f8ef98d8b7088918868f73d4f47b91e061dfc35d36f6df9b30204fe19eb25b716951131aa94f8deaa34b88182a4cbefb094da8c8b46a185a762a4ec9bcf3dc685254006aa54c518d6920b86433fd775fa1f5e081d78472334dbf4b27f48184c2c156e32bb8dc0f67739219cc5febf120e85a328a45c10bbe797de6dcf850ff3629734695d8096d449391c1d5c89dcfd2afd44f655a347e976816a89512076e80afd7e265e51367c05175561bfe2307e40a428c8359adafb64c4255114d20dd0d4c7393bf32ade28255a99ef04a883aef668d3d760e49664c931e0bcae2ea2010d93610cc711b5c25de9f8bc11e7cefb04329204f292eeaa502087b748724faf61b360b19348e4a1bd3fcc965525d1d2488c21d9dedd362001676539f9d54c14cc9daf8eb867e4a6ae07626c212807a11bf1a838c32bb12b8ffa57d9c994e3a395f8991eb579d6666d306888d0363c791bd51e7262a90f11fd38bb4b735424916289580079952c53e1df60b70d160d2960955c71bcd66be17500e6fc24cbe277c7d20b532eb2499a7bf749a5c1c5b3c4d84cf94756565226275d9253310c3011ee602d009c7ae1ddac8e089c47806f78b79232e1eca46c97e6cb0c1f6c151bc4eb0feadddf7a7678f99ff4d0d227ca8e3ce868aed3a9d7dd3e669888c21392e2bfb42f3b27be44cd6a33bb859552c94013bd898a9e6f16f0a6ad4ad9ffeadb73042808472ae978d29472bdd3c6a018c8cf84501848d28b7645a4ba617987306b3d48c6e0f25eda9bd7cf898ac8f593ecef9d1fbb310e045c06b677e09e4be514911aa3e11174474f1e7114089f0a5ec6bf5a45ffd651472f51f26854e0f47bc3589663e7c38076eb5b6bf25f7a1c5e9eb39a843f27c61a385d66ae9b481719c5e92111ad01f97a096b140466b273837b81a3c4d18d69292dc943221c14653d7a122e0786e400f7f58ab9379970bac0a65c3caaf1709755ac3d6f8e3107be4675fc7e8f2859efcb47dcb2315a826d660a577172f22b3e2c95f97272a96d1cd3f5f29e4cf3fa8753f4318a9f7d7f7b3eaf4eb989455d8a3a665418ba96c2b7283c6eba4af34283305eb9f17661428541bb53e1d8eafb319916a7251e15769db778df243b7662cfdcf5f1d314dc5c511632e24a1b5148cc27dab3520c51a845c8b069d288c329324afa202896ab903e2c29e643a8ddf907995966aa153dd3c78547f0188a56aea0055ddd7f85c611ea3bc60b5cf048bb6cc018f1b3b0ca70e4b96a0656473a6f818adbc162b88b5a10117e2f85c0540a8297346665c668c756dd8b2d1c995441aa1488b6714a58865bbeadcf8b1fc7a2cd5332bfaf3a0994a6f5c12d6784abb31798136d1453615515359f4573349c83fe92f53af3220a431d4511391afecb0a0af5c718d2a71d87d97327a0e55b82a690af0b295d372dc29badeb25ae1348b14a4cff1c40986cc3e97e09e7c711f7a3f2b0655fedf9bf66cb0b121919b47e96340adcbbce2f699bd91ba0384e132a810d9410f9ae574264fc370f35c8002ce98ee1be227aa7ab1e9278bea06dcafb09ac2ee2880101d2e4d827c3f1fd96013fb3d5e04a47e6b148bf44ea7366e91c009f6eeac5c665665d28c1de1de0d3132ad960bf131af67024b15be65448057fdf9927a9cb27a8c50adc4f903d17efa27dac8b342ee42ea97299583f9d3e9fd068e00b87c45994eac3ad3dbe4c42a50634b324285de64c7c4edae28dd5ea0bdd2be4040f8df27c2f59e934bede39e863420d13954b08dc13b6204d4da937d8904c6ec3c9a02c4740b7e36bc81d4d721e8a1f9b93aff592a19b9b6136aa06ca359ee60d7a425758486c5bccf972ef4dda5db0fd2bd323dbb5093b14119eb1b5875d8e2ca23243aec21352bbba873fdf8b4c39b5f8017f824efc01ff76b556ffa06e11990cbfa850643cb104bde65aeeb3baf08305a616c8e171f6a8f16a53f12427ea4fa2c4aa2b9004a18406a9803333f09fbe22daf311d12520c78eff014765c3bf9d433683a11d019108bfa87a2a81ce948ab25bedef529fb4be9cb9b15a25f9aeb97becacb9698ee8fc605dde53ee6e9de072fb7fd82e38924f14ce60b7b67670ad2e14bae16293372637a04ad3ea5213002e34db3776630aaa8d3782150d7329876f12a21244c2dc15697d213334bc25b15d70f68b6cd463b40e60c7c25bb52079b9edb110d2ae396e0fe4828e4dc9e8cf382ba8a02b3fab750110085cd2556f94d36b698d60d913bfd5e04cfb336df6d2da64d2b6ae220743de93bae8a94fbc426e9b42fa94de7167ccc149ec36a3f978c2a3f3b954bd124fa07055a2074c19e2c6ba5ec4359d82bef5a9e71c5fd1cdec2fb5a0ede4f6fac9b674ffcdb5e90741bd1677e1dd3ae1da543d642897e2ba93c696138a5ace2abef29ca9f5e263fd1d71d89968eb92efe34ef938f68a877e3fe46c88eeb693d54070eb2cab84f398e832cee18c3832e9a3e5c8dbabf95b70df4ead35a3499a89d21085b65b2acece7b0f809ce66e54c3ff4d3c8b8404ea1ca27cb1c23393ddb49941fdfec1f56bb8f65e2d7265687d7ea08469a652728ebcc056c766c16a2aeee92dc0e37aafa1173668572ce2b8fc460f79b53d7f425b2c3b983f4e5eadcf658dc50c51e6f4481efabec7375eb520f47c7891c932df13241407f1f50ef79361665346709beb006cc670e1d5a08469185c92e8f6455b70cedd750845595815724ec1769d0d12316478ca1be21e56371a9c70df53b9cbdcd337cbbe881276c9beae1140317b1878ad6f322512632be662d2c5ce2fdaa1ddb5b25f797e84256b42714f523662e94fcfa203c418325e149ba2d769287d1d7fc398b44b62f83a28121cade59eabbf8a2ddefe1f761a703d45d712851085ff41c508cb2c74614365e69ddd497ede8d65cf3b0549ff38b2b7846d6d5f867605cbc036cc9121f6cc652be5426c3107f380e5ccd71ebc5c13b06af415b184c3ebac0d0181a6c0cd888bf64ac69b12773ceb95ccf1bb1299012e26722f26fb89871edd25c46a9b5068f858c5cddc56e6f30bc56962154deabf3a9ece056e2dfb140c977d7f7ca9957b557de9dddeff0f9b62cefb5dd0da53231b867abe6bd6f1d11eb8e58f79941296282d6527f063f0965667119ada9816ef7d3509b892800ced204bdf2e87282b49647bf8e290d3de90fab825996dc4a3566b2bb84c6edfeb9c4ced45fc2148b3da8665a2d2644641964c2bc402bfa88c20dc908280f69c9450d5c8d4f613120c503955e2473788e306d03c88008a5cfa85ce9bfe0b9122f5e9091fabaa2d8419ceb41cf49c980bbfe8ac2559570016530ec8511018adecf397afb625460fed1f83d281f654e6c10eed744fde69003231358551bae1591b56ec136bd3b002011e9f7a53aebc03953b7af9a8fe1b1c046efdffd83d248137f150dc153c61f749df37d87afa64d58bee172e4022ac3aadeab915822824244a3599a23f98879cf44d489400d754828336fcef15888a5a980d171322d52a225f6717fc3c63ca0e4306da12d022cbfa6da332414e49ed84bf70df19000e1d006259a84b7044da56c52b4a60f85c70fb05311113862fe04723fa51e2f03adf5dd89f3bd99fd91095075b105eb2145a182d8cf3cf61a6c4bcf8a8872181a360df6f268913afa795255029025a6938c682ce09a33bc8fd87c4276e79c3cb549cdad27aeadcf832ebed0759ec0134ce215d127e7560cc54f44592fea637833ecb0529124098ba00d94a05e7e19d6f3faaf9a52f7e9751be2518ce03dc5288efedeaf6a992dc45ade5438e29153a5a54c8cee7e0c5ffbc66cac125d31f1ed20e03f7574936e27647ebafa5a023961d6306825fa5ad38cd0b357832e20b4575a81f970e9425444e80e08d44b74a5895ce55b6880d384920bb3096456b3e020fe1c531ffb9555ea900a2c34057ac72fa3896a51b7d1d726398e205f22f592cb56e1027181e4823affcbe3c10852f83ec1e64d974a07e9a7415401e495e8b7a8fb167de4881ae0f92efb72f219577a3eabad0fb3f63312793583ea9dec3ebff45accabdcd8baf7e77919b0a31e82cdd01293c4dbda3482c686796f59e1ed3b3d0358de5e8fb8576d83de9c9fa32035b6f792089aec16c793da0b3ed8621e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
