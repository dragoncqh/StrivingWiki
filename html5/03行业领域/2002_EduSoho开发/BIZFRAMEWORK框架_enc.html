<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"43dddc8997e59797c58bca40300fca5f298b2448fb94c98abc9c1b888c8edf863818350bcd67c44e88b54cda7a8731d5b57daeafdcdeaee831ff402fc08a1f5ad61dc15edcdf5e3f397b88b6bd8e69de8a1e9ad45da687e4e6360808be2a0fd50e73ad75e7179f82aaeb98d8ee6bb0a5a2b2cb478bb616c4ba888af38e2372521ffb5bb275f8fb920af7f0b9648c12707cd177358bdece6b3d7b3b92568056c79166ee31433a968f4615615b2f9d174971a80c5cee7f4f896b3fbfc71b40df1d64406c307f040b09d5bc581d87101e9665c5f812f05827af16bec4a8fa275fe8e15117fc050cccf23b4fe5fd51a28e0629b1b65d8c96d374ce9fd24234cef5065c9d4f907d2758bf40101019ead968f66b27fc3842f643bc43094187a75490449b4af8331121638686711a047e03919194cc39f1f7e68b64c717af7eb16bb619e8589d772638d5e1bea3ae476630c0d09d185ef204ae4c17430b33712a598ff2f4f149eb867d6ea3e15773990a8de49e13a30b9fde3875c85ced3f73ce5b089abe16c1922bed16dd5394cf9af68d4c3a02e2193bd3063392bbeafb9b455e4241f624a399166c8be8cb1ef43623a2f4f08a028a87f65cc3cb7048ac000785aea4ba61382b63ee07cfce19596e36537bfc67d2c35903b8491ca044ed8830f5374f55ad1aaac961ff21f01abbda1c74205f9dd73ca15d5b66227091175ba19a545a27c9c83bff778ca7027c6dbbe288ac4c155f679505088fdbd05ff1ca39b24e9ca55e1121a3b33b2c8e7cf7ce7b1391b95676bcaed48cae277f4c9c516ca3c0353152a5b7a94ef45264f01102ecb523e7f7879f872ce251ab512541afda0d987b68b4ca5bb40474b49784ff73889731bfc7dcb979eda99835e66531aa7c3dd100441f76e02c1056c9f8cdc404e552f3d7917b095714cafac0511bc63fd16535596e073e28ac1a095eb3b7f34d7915b0d9e40ff2b67adb0bcab06f512c5219e9f05c418a7912465b84f048bd360a2b00aa138687506e4718d5d4648b010030620d150b8d33ef32888a30d4d33491b7506d8a5d72ded21157232102aa2e2b2dc681b159511489f150b70e062e4c44dd103f73bb5d78d3dc8d32cd23dc845289305cb3af7054b94e13cebb8b564958cf928dc188e8e7620cd7c7df33921a2a44b721e682db2bbe967ee9ca9c97e662ed4d90ea4c7c2fa834b0915eb49cc25f8d788289a4277ecd18217bdc8a44ce87bcf604d323971dfc79194c05fdc89519242a8982e4388775573bd6c4129d501b4bbcc42d8025cf7eb4d77ebed13aa54ee8bf99d4970871dccbf794998463a21c25c72e7795b1a86deef251977ce7ecb8dbb25c561525fb452129ba84f3d6647ff4bb2c61951697833802e81db391a80def452bb94147d65ae662454e8b7c83dd45a92e166f51939c4cb94a5e23c1d43e7fa8873a49f6869377417ab4b6d63f0eb01eea6a001f6c7b532bf2cfc3aeefbf7091cafe682ed7a6b7b3c641050371617c04bbf07ba097e2b3200f88835dcdee83aeea832a1f40a7a4fa5cfeab472983fbbe75ef5eb8d6c4a421f95ea6da603d6143f89423d7f2f539061a64d9a4e042b45700985d0ef0afbef34669a9d579dba92ee70b2cba34cf78816bfcf6687dc4e24c48f51fc37b26e18ef8b28027b155ff67af39e35afdea6a64288ee0b884d335933f128dead0728ed0aa368b32e8eab7d191b58313d08fc7b51d8ea78c259f93fedd09fe9adfca66b6a61117ab04173336f77f60383b0daefff641d900ff0f780468c944022a81cbace9f54ac34be2c2627781fb65887f999ee1f3aeeb4974783b4ed4ea6b1e7b2025427d10739bbf3be273d15ecc8086c9a2febaac9a2c61a795f20ea01b33c430c18065caab28c165f7a51a0fa553020e498bb8599fa9f53840073f7b6a996b3108efece85a11edf34042a49b100cc9b2d8b6deb68ad21c8d007712445fc340f2920909ec3b8400b29971307990e69ec6ca343e0cfd52bb6e9aa0f945b9124851823c053c518e1e94eb671bc1573cf259ad70af4ed47c1810d567f4f53f7459816462d5e9c41c24c10ae1dff4883a601a6f94c2ec97e3f9686c0dc9afdd6b8e438d10799844a2f8e6b95724fe62c920c080b294dad45a7d80c2b8524f51ad65a2da6c49ad090cb070512df2833ab78b93e492abcf31d2b7c090c3df58cd174b26d5eb67b1a25c0e31db175689e490346242785f7423c23e182c1e5c0f0ea927af8ddc9911d1fddd411577686ff746fd8364a8a18ea6e7d8123456ec7d5fe30dda1372e23f55ca9e6519b8765b478c4f01c127d369cf7d10420d44060b5c4170616205f7f9a9fa1b1a94ee3ac118c913d947c224f128bd893b5fbe5c131281c25d5cd5aa95abdd49031d7aaa4ae48a766278eb68427981ba6911e88b70c6d61d20e018bd51e1843a2f3e32db1e39f83164163fcf04d8476b0046f4cb81ee6123a406723187e65f7a659d54e06a5cb7582a314631d7ffddc56bd6497d502cae01b89e735e201fcd62d0cefbfdb62e963585accd4bd6ce403b47b64c204956acddbd2bd0dc7ca5ab36066d203c8031ab76c6c1f23976258e4cdd5e2dc2d075e02606397b3aa7e7c665bb9444626b10675601b7ee4cf07c4a88d409162a584c4f72f4c93da8137160f15a8421db112574635bc8d5d371e083c314d51c171619c8fd8459247e659163e7841cc7a610d7128e2b4e103677318b11767813330f55b0777cedb5e7a0b5e52e73ce265b086d6efbc9b0883501458ba4654377a833d6d9b74d805b3614c49f0970883c7f23056bcb12b44893d51c610d7d15dac0eb49923c637f0e021c951c6aae8a9f882bf76d985651b7368778cc44b4194cc4d7032e3b34873757caa1cd17767bae30dbc3c20d3c00e8f2772da43c4ca1e4b74335c9d5d1268773a1dad5de0a6e57aa9991f8cd967ee0c87895174ec70c358db0e74d8100e60f69248ea9d2da8064a16f0b9653cb4f2349a90ee75ed3a2da9d747a0f52aa093f72e7aa14bc1721814553f341d4a9a97df4ae22fcb416a716124090ac3867b6b3afd43d399581fd49a44fda5dfb9b502dfbc131b6e659e2acac5a7dbbfdedf767678396ffa8310f8d3aed4e234587e14b60aa23779816b0b84afe2581354f5aaf3875df048dd2e0fbc2fca6bb9d11e094f11a701a7fbf462decf8336f8fcb3cb8aff60a4744d2854050d51be5caa66c03b280bf56bc23fa42bda402481c1f153e24fd549be8239418aefc8554d57547884b3c7e3dd12dc590eb7e49ca33a71a99fcd7887c8b5c031046585bf21094f955207421eefa87c6ba9ec08f7910dab0ddeb0fdedb86b6a087f7a29733c190e22e1429136f3e4a11289c61e513f612f7121d0c874ece71d7a4bc7ec52206c14cd77791c9d86074c2ba20d6d87ecf7fe76cbb4d0b7789ba8a3deb50fe6609b2466536dea1bc4a5f57b730d734a2cf597bce2bb879e7075f99ac63262ec041bb22589836d674ce9089b60861196281918762fec0eeda6acf9953331d67121e0a8e799ad9bd218b2f21d110849d4587477be07029f17fb6e9430c92fb6b2d387ff1774d289d0604e4a56142153846cccc70124f64e270e7984d416b670e024570e200b55d789eb53b35ffad97b6264a17c99e2c6136ce552f7fc35d1acbdda5ff577de472746e9623f3be43dd01118d6deb9d4eacde49c2a951d732cf4f0ee95c482902d10bc099dfd77257bb7d07c66453f1c9d50fa500d39b5ce5b242500f7147f42cfc74abda9aeaf26e633607cba545220d4552584424b15916746939b570a7b954ef7f966872da8ecd82488b4cad0ae6af7bad80abff4153e450d902c3c78e18dc07cc1834fa0fd5457f1c1f965ee667308e46e4b8dda680eb9fcce7b3ff90ba224e99f3034a58bb9b3b2420e136ccf3b0da4ede1b7fcff1249cfe0078b62df0e5a887691f2cce04a6e131d3773794b7a6bb9da087122d9a578ab2e49026099ecf24e6de1c5f559a989f7615b03763e422fefa83a3f501b970e8cfd4a11b264e37474ea893910c9354b75200685a39ac0feb166dc7da2dfebb3e5bfb0d87f907773579ff9dea16b44f7d140cdfc5b0e2662b9675be89dd5b33bb63e548fbe26b9a3405955ca64ef4c939852eb3e66a79eb51798934a2a3acbbc0c9bb93848dfa5c8ee2ef4d76f10ded42f81e9beb9f67bc8b3120e1d6b8fe2d41274f1403a96d705325545c1f8e28d83c926efd29d8c8ae29a8e8f07531afa14d5f49120877d667f2cf839be8053ceb3a57e922ee14d62aaf1b69c7871381e5c52b7f60c4f02863d27057e9d442e8e512c45ccb2dd271ea21618856347e73706dbd618e483dd3d4149fac1a3e5393244aca5d1a1e63dd488992edffffbcbe59ca02f5576da52c9247eb034cd337e4514ff8b1c2b6a7fc23d80b4e8b7cf58d460fe481c9296717ea621876430c97aa50590956ca9e0d356b06f4224dffdd60418d5a1dc5bc80385f9dec7390d0750989d128206dbc98ea727a06098ee7e5d5d03b78e960071e0e86379de2141c7616b65c83f195f9005fb0563d52cbe00a5b6f5d75f3da61e40d6df3f645a9540ee45f555b87d1dc09ead5c36b51d906a811fe03b111d9eb34991c9bc5190658a5ac188334bf6843935e3b286caf4315c3f6184ade0d32f69d59ed87213174f7aa1ae131a832165676dea0f3ff471a452c75b8c977414e6e5b99aedcfb3b99bd3fe19c525cec859f41c6e66e876529f8dfa470116cbcdc0f346b6fbc954785dcfa92eea0c30d42f61dcb641ed6a186ab333c848d35eb03870bb0ec147a4b34eb6d47efa955faa7ba784ba261363a3850932995420da9819e9263688801fec1dcac905d111b9c53e8541a1360e73a6a02225ba866cf88b04db0d3b76549899b8e3c1fe34cdce2ed9db0825af7eeecef87be207d5a327960d85a67a0e56b8e565a4fa0185247f0bedc7cbbdcee53d7ebf4dbbb7074eb783f85c03258c8b3068384cfbcfa393eede361d718bb4acc5b32f77087c65a6c560c42bd42c81880137407be6eb82bf88b9d69254b45997f36672ae50ab94fbd432552bc76debdf553a640148cacaea5d2600de6c651f29c0d0126a5a96ee0af3b05f232c1195bb97ec572fa439c2ce7a6e6b30cb499c714ccf0b1588f0f4f2f63832734001957ee11c15cf13418e289a35361760b14ea955fcc8b9b49322c8eee4be8f873f3943fc300c48c7bad8d75509fa355f0181da842e3b093952dc2d5ba8cf50196c3f4f7a6973af3db7bcc071b3d3107d82c0efa56b3440d9539e348ea0758a6c869d5780619ab87d88852b6f9d3e9ed7c0286d4e58ae9ea0879dc27db5f0fe0be778b91bdb5849b59b00d2af36d985c80afb80dc1e2dfa384c9b10997f7801633d06d3f7c137e0a24edd655e66f0270eb9a8207bbc1a646f662b4e903b659157a7327e1f08fa484bed2d6f7192af9932a5d6b4f5ccf02776ed89b5f267651e9f497f59b25df4c305d65e742bdc0d29d5de229f1eac2d0eead0555fafe54328892f185073f5df55e872020083dc929185e3a9a0da3acbc3b5dc6c7d7385e242a6c3dc5ba1b262b60443ea637de1eda2d9f7dcbaed000ec13acd3291615a7dd0d7bf1982d3f78bcb9283153e67ae65ed5107bc415dc6237ecb7f32b61586a337399ff41e65f6ecc77d43637c9f027dea88d06d41047334187fe16d80fb9925f816ee6ae01174f45376cf7cb95908839980ba196bc81f20c685b1500f8c262fe220bf60996bfaeab2dcce1b485bc49ff1cb99cfb3ebf676e2e55e66033c06d4cb95f004b61732ea69577d33620abb19345bbae71a5d3b359358c83372cee39a5477279af461326690b37aa73ef7f41a57186e7c23003547f9f7fffee316e79a60cf81d7d75049e3613ca5a7352b90fa566147cafc62bc3584a3ec20d54c26a9f6c3b8e3173b4f8742d43f809a1fb21cd276857ce9a67f5bcbaba02550b211f3a308452a147225679f2c6c583d20f6250d67268145d38957f6751d42f2651a9a5e34ab8458b302cf8e5fe0982328318d003d9293a5709a22ceae86f63a388ba71d88f9e5c3959132601be2836bbff9bab07b69201fc103a57d811877d9970260704a567814e6df6fd2e14f993aaa6101e7ccdb58dd2b08f141aea57a5aac2fc1c822c41dcddfcd327ae9b8baca1a47f96415672739c9135680bb1b827cc6f943ff5cdd56f9ce7a81dcc0e095e56f665bfd4060c9f0bc0ff10fa52214e59f7afe1537126f2274ec8d947f1c51d77c33696f5f9185fa224d9c61b5837bc881d5e220c764a70312d35375beb95ff64af06e4bc9bc5b4564213e096619caab71ee44840a357960147912e10fb68c2d646d8edfdb0786039f4f2452b6ec03d0cf7e20414db47511102449ff1e7611b72e53c75dd484ab981b2fcac54fdca3da277b0ed229ef6be04167eb9307697687f5ddc869322588d5919a523da169bea86ed52593ffcc6506c2cb61793b3706192c641cb7e211f579c0cb9c631d09f932ae4dd57539072a9353eb9e4c02189cde91a13914407abd45a9270f8e95b4bb06b4c3a90df9d48d8029416682075ca34f1bd1f6459e23f9de50cedb7283bdc66d2b3f3bb86bedeb0ec06d42b1346ea1057ff1bb763e5fc8eedf8aaff7b65ba82a96711550aec34435164ff56e99d4d477140c132cd0109e72599222e674649bed96436572949846f3ef38da4d52b5b70e62af65dbb83aa04832940ca6ca29676f7ab2963b0db08b1c2ad643ca430d88a2584fb8539681f6ba3826a27671ec4d4ada5f1299a4e5f2a2ed4e55e89548862b6eea372f715e35da5cc050813a81306e27c80ea12fcbeb2a76b888ba174faa2bc81daaf5121a342999d36dc40aaa29471795291c846aa73033793f0334cfddf213e93334f7abdab719d6c78cbe5459e7c9c783c6946a2984de08f240aa13c18a70f6a98a72774fa38a88e43c2961b187cee70d14052a8a393815bda2476f859e3e838bc4178ccd9d04b610c99c73d31058ad343ed2d0061fb77339656b312ffe9d5bae29d58068535e5113c7838742e245e3970288f5dd016ac3ed9190d2f1d16ed640bb485d3b95039aa77b01169f2846f6fd33748b8da2bf1bfd2546878d4498b12fe81227382ca6db13d618c3843d40358bbaff0fb22fa95e1ec69a232903cdd96c11c685fcfa2926d52b0ceb861ee6ee4bab6e6af76271642dfa28e034eef8e500b8302717535857c6e398f8d1c3849e273b6d0808fe9d734dd1e511ef5a230ba02d6486839f72e1f4ae2ec66d588ba4a73f1461c0de3d82791d0dd1b684f9c12b1c9d34f49000e66e68207e9224ba614e8e0655a64cdc0b2c6ca982611ebf393e8df2bc14f09502a2aff5e29134a891489e5f19026f31bedcba8fb64a05cbaf6d1fba1a29f01c6b19cd72f14e62cde7ff0f7acbdc04e962ff545a77c7d4c72b7e89282cfff66f31eea6bc6a04343effeba966a0db089f0e7ef97cb86d72afae68f4e7f4616b110a908f03e6f2acbef51e4cfcfb9f9ba036e5c5a08b7b413117156f05e500a954e7300f1cc0392f4bf88990257405ebe85c187428cdff4244fe50070e9fcc4c3ba4128957b70870a8b1d713a8b2c43781341298234e88ca7fb283b07c889b55d1581dc83c75521e71ca714f27dc1ab4dc5ae9cd32af553c3bc33832058b750e51f5143dd62a668a89979bc172dfdb340f94eac270d2bae4999387eb3703530393cf01f20d4abebf102d63052ddba1d044f9a48b603c2c6711506a7e285a7ab1d2fe820cbe2e6acc3cfef2547c625dbd4b8d1a589de35c5210fde42a33b49f224a849fc9a6406166cdb06f4a72063122845089168a351fb5e93ad6708da35dee68d3c04a72eb7457047681b2c41ee4d0931b763eac745d1f0cde24b1504caf2534351e8937b3b996d4848f8f0991bc4c1184f09d359a91344a255ef312948eacca5b67d36c65bcd65efdd3faf84ef40b8cce9e18930f3312fc57a5ed56d8a4ab9182c7d749a4f0e5976f8937ad0e6e514b71d86b241ff9391d003168c34320cb7aae6f2801ea831e8dc28ae28b60321f52c84e584cde0fe9028e52033f2c2610097301ea4fc9f560ebe93ec6d762fbef2042e8f0388b2d9b0dd3dbee5a354f6783f501fb67e602ec354e1cdbb083df255de6abf50e49506174f3ab4435882ba04786dcf746a8fd2dae1f7bd5f3156d50eb586fc9e47b227d823c582b269c299a62b191bf0a5f0aa1689ad6952a69f897bd456abafe01fe4b7e66f188243435629c55374ee814c5d1ed98b5f87e3ee3a4188154b3cdec579cadcd51c92878360cda124250bcae9e367ad357285f8284d4aa63633b4a3bd1586fbbb87e11f6669e3946d9d8ef8a9169acbbc780df441b2a7059ac1881ba44c0ed22161f3a7ab131cab0725e0eff7aece457b45587aaa860f22282342f47816e2f9b7934440e2f8dbddb93a6d13098ad6085cc0cf01a815b418e956d80f7fae352e0bde84e2a6a9cf991ee5e5c033b52e13367507d00eede86ad5a8a37b272f9b52ba904030c7623ad2acf992331352135b8ab6fe83181cfef533cac6098b8f47d40a2e5fa88183dd42cac01d4563c76be65769d6c092dbfcaec2e52b9f65921c706511d6d8931b8136ef21ee39a4f9b94d41496e3ed3e7c4e591024afeba57b7ad1459013cbe3beff33597ea122250418614aca35a1165d532444eac222d2488330a7e13aa5c1e38709e14046900056c54f2da56345fb711198f68403e74de094a186f6c2b4c76c3bbe1d188cf4db99f5665cde9d0fed7212378f918d7da49e4fc6575d9cf44dd79679a8dee8e771652bdb69d07397f72a7edeb70dd1e2d5ba4093970fb206471206494d20e1541b84c0fa06329e7c263feabe7fc1c44889fa1c168c3a8cecc4b5295d8b6270174b62cdec598693be744efb2f631393238b6226da871ff1b0b628681a31425a74de11a642657837ba86f20b363e4641ddeb84dbcbb357545b609da9d9b720683decdbc68c48786b52c94be8e227affb90067b54a3a1d2c2737ae2abd709e7864c75d07216647f027293eb7b58101e92b2136c9bf3d42114d362d9e62cc796e6b86fa8feaf873c84d35e0816499ca39e0b3ba33c6dd95382d6f939526f1fbc0a54a414bcd05bd3a7ce595ce34568a34bee65f0d6528a7ce0ced187e9c6867a856e8892487d530b34e23ae3253df02514eda572d4d120403b0ccf15b1e44dbe65c720584772495a98d6c385a7a615c32314dfdc6d03a04f1cfb8100227eea58c2e1717b1abd4c22018e15c9363bddaba195dd96abfdb44a35adfe74fb8107f09138819334f49e514d32ae14e33ff8dd12e889db0722d7877621ed41585e56ae12daa60d7128188174e476f66973bee9205b877f4fa03f798a7fbf3f52f602860076d11dbf6d11294ba8751241709f4292a50f40939cf542689e0d2f45977b378b51fdf55f75742dc3cdb38c681913cc3ef13b7d6f5629e05bd28acc383d7a3ad0f95c70531288c70df3754d8aa2165535910970c912e8a1cc95e48f3e65a12ef4d23d726e3fa134198005cf8bf377f32d399928dbcbcbe858ba892eb71a3d1cd54643853d3c274c55423e70fce26ee68dd867e05b5cd4212adcd8bbbe0518ffb17c220057c3723d64c7247a5f5acbbc74639d6a4f7c2b66abccb765138fe351a3143c7d39109f272f4d444b0540d820c6cd997dc067fd575519781a0139dd4c0538e4fcfab58369f0555f3def9f4d1fd2b217bedf7b087bb54551ea2d501c7558fc02cb796023d9d77e2d1f50490d3ea2cac4c8a4c4802d4168bd8e4baa07a2932a8c1541c34c914e87225b8bb8c04f74884e7f07ba1534f24259848770b5190b506a64104c514f45c4f7ea245c24d1b74cf7263e666216267ebda005a6823b44bd54f29641eb0a31be54e6667a9c6526c7e42f18710f997f70b7528859d65b01c6a19446f7d584e79135f38e7dcce5e728ce671b40b650693e357aba74ad76167740573311c68e656499ba8de81cd80adf315a59415d84cab5f7102ccbd8c6add1281537afac091ef932bc9bb76625640a22699e7d9f87ee5aa2655bc449033a4378dfd36a86866c9850f32718d2b4174fec2250e1e2b092b59b2f0e4f72537f42187489d4293112d8cd1366f40247b50cc8a927d4872ab31939f4e43ecfaaf11c4b0c6b5012bcd443f2d61face93f781a2a7637a02d6e5ce9e2319353ec02fc41e909edaf6feb358e177a2130cfdae60d76c407fb650e825d8ef0ff9268e0fb6ae9f39db04983ecd462989b5c9659d5237d86ce6c7bf72643e950c9eac290818551ea1e1ae1e07d34bb017b6814695fcf013ac6cf85fc98ee30b855e49cd04204406af0ff71173d90919f163f249c9727ec11621a14c92a8be9162a17a639b32491d65d9200a7ae60aac72bbc2f914aa242bca76268dd2a8f2863e3f69b40eec75ba2e209cb3602ff4978c59beecdb38e7c0d7839956e222be5ea0cfcec651238acba6cade0082b1b1a015ae98ecdf6ac85ea10e3263b0106795af384da645fc4904f63a042e05428e21c7718fcb5ffb76eb98ac68bb67a15817dd6b232d564d9e6c50ee89366286d4c9043bba9292f888e5564c46bba28d415457c6f28f733dd93f4efae722aa2b605e86c93e5a45bf60aad60b91bbe66766a1e15fd6dbe4ad7b9e88206fbe14b24c4eb0650714ece07f15970eec63784b1b910e08ce34ec121b3dc8f95e52904011689991f15af4c4f314452f9f0e9a408b871789ad90d0a24fab01e50e476c9735f8150e5002f7b7b0bdfffe55279ab42f8cb13b4ec2313f2e56153c7031573ddcc121a18f784429deed16aa579174981fbe6ed51229fec5607fbaff55b4ee7ea22aacac533b383a6333bf3c541d35994c7f9faa9b8e8e967327282b14b724ff46a701f0a45f75e9a065a58ca97c6e234fa5818e2d9c42564ae1f70104086d0f21a021d8ad8832cf96ad4ee2bc2d70319edb8bf3590c67f37f98b7b89f39c5748db2fb112c20ee97149bce1a0dc510ff5a8f61c0158a12f13dbc5e2fdea0320718fabd2d256d2656fcae4f05f3e7a154671473cc43848de219a85c3687ca48c873478c897a272a0cff683e86d62b335d49a6e0bb7c4dcdbace838204dc7589f1d9d7eb1b897c25b0dbe12ad062bce73b3edf4c5031ddd55d4a87dc513a608c293eea9fe0d20045db0296cbbeaf1e852b5e9b2b2bd97448df40536b11cbcb3e2ceef5e3e1bb6c7ca686f458a3e9dc901bf545b89d629e25db48f0ec9a595aa102bec39e38642e272504a9b3b41eb2823e5c2aa5b6810fe0c7129504b5378d731c5a32b086fef50f153e919cd91428488297b8314267cc79e87df71915faec7e4bb0203e3432128a20b70e7d2fbcbd2073d6d9315ba67a91706e49b2b80f5d16347270b5ef21e40956f223c5452a63de15765067cc62e75ac3134100f00a87bf3a15e9446ce632f54122de2745b2488b8d429cbcafb0279b9107b2e96c453bbbe8eef98e28d22afb14397b6e819355836940be67769494c553c5e25bb90807814fa773a47f1baeaf2ca809cc4709ee5be576b9331f0efea54f3845f49479a5147ef7d7e74abfd841374e2beaaef3f288c5ceb018c17ca3075d646113aa8ef39ae44e88912a739a85c54286757a88aa20ee6d5e7dc3ed4e9d73344e95bf37b94a1b01eaff96e4920b1c3c21b8d581650c75201ed38d306e62f2ecb62a4608c5f70e4cb7097f93b6d8262c247c34190387809f010be2cd5c342769004b7c4630c3805ae81e0eac41049ea5e87be9c1f5b15ba7ddeec568beee4c930b8a661db31f1f8c5eb64b7ac0aab6050db6cb1eb54e83ba57c3d9bd6f55199b25d8b39deed35817a6420a1358820268441ab5b51e7ae37b7e459dc40588fe55c2919a60e4640c05cbbd8d97d933b4aa2cc100e3ffdad8ede7b0973b3a4dfec1367f90461052a59a57f5cef87c380093473fd29bb89fdf669d7404e874e862da9fa25357844ff97b67a6cc89b9b8a1c983b8ef703180d2950d83e76b4cad98ffba019495dc0bace34fd90b07cc7cb2a1de6e9d8dac15cb322088178d1fdcf3f11c49d3ca009203d92783d5a3a000af8bfae6e56b9f486c2b263eb082aada329f9fabc91b659bf980ace60b94613898c02beeb0978f306c3b55854c81917530bc1af55be96f43f245b79fe12ec28ed9b6e01a03075a5b0b9eb5985d9960e056ce35410c240493b6672ab28febaadd0bc8eec5f685e030afedafc90ca73fae6470e1b9e27dbe76294eaae07bbaf3324fdd7e67f1855977a03fba902f7893319d2c60ad85867263b58896580e2ab2096a3dc6c3e9865489e11c04bb716fbdc0c197f708851a2391dc0a05077c149b9fb42d73b9a93043b81c77bd2370a36e882903a82ff40f739f3e3df7d37e71b005df0fa80192b0b2c3f1b209540e98b982633db41400fd98bbcdfa6fe94bb7cd3b79970e95306c798b042aa4b7c73f9449dd3cc0cbcf4f530b39da82a05643d95a922e53ddf57416ea16d57ccc50fe6827087270665e6cc63b3f24ee215f257a500d013afe900608ded78202404ccbf9a3e1512883702cc5753b894b04eb507c8eb2bc73a9aca0bf53c88851aab596739d50d16c9ab4ffdc16df8a290ca279e6836b0869053a44e7d82cf226cb0a2a48a69b1ef197afda0947f84c220e3d9bb858f72dc06b16cc3ed8f4037fdab3303f023d4b86810acabc7410d39a54425b9cdd070e054e183c5e4ee1cdecf9468da8f656bc7f85b988987274140a982b41fa68eaff8f3effcbafd170edb364c08c99a8c552e818df0bc80635a85df4aed43eceb820016dc2e04f69d006825167290c1f7b1b3d714d0280b32774a3a8178267c6ddb372521065aaee79cf92acc5a92a4f3b710b53761c78c1c56e7dad9c8e8ab552227a4759a117a66ad51c05139f74c15a9a4e9a00a49a54e9117026684f69fb75d52eeb1309db166c7a232576f2e0f0420beef8ba3780e17b07fe47218b9c31ab1bce8172e58de18d4cbe9457f5330d70f33acdf1f372823a5e9b9a390fd994efc98e87174bdfc54df0de90ab7cec428b59f228c8e63bc2752133f2af0bd668b1f0464faafec58085bc81a05101afce088cf74129f32cc0578db7c5533894ff74037bd21ee428144d26c2f61e9fc6166d2ac2e145c3dc67479e93a2f4ae80a0fb15e30e24da375d76b32857a4cd32525caef597349874ac9c77232a02e847669e11f477ec4f33b9dc950dffba92f1002ac525b99c0d5df3f63cdfb5f20567c9e7ca3796847781f6fc65a90a95077fc3dd82695e38e803fd7b81e4b810124b1bfa3dfe5c69749b483cdc4063106258446ff695a6e0ff5c2d695ef13ef98275eb67dae4b8cde9dc729bd380acb5801c97671c43d37cae2b6b3a9981d2d3040eaef8caded4439e58a736db8a172d849ea8c4fad02c63a05ae3148f571a9ef2a2971d5d827f22f0e94aaa14566a5a002425f42760781fd0e5ebb622101dff46f5f1c0a3130416d4e7ef4b68c25979a272e362c2d0a22a921f848ffbd42ced8b07271c2e8ec06fb8e66ccaad54f547e9e24fe3d64518f228fdc1cd93d9f7da916a8c452b353b88ccc08493a3fd50bf43ec80466286e54a5e77744d9b65477fd31f4dc2196a05d7add3170f264084604486ba040aa395857c9ed21d92b8b9fd5e680f7bcba653ae4ab18b479ab3fb57ee247c49f260e957e904b3ac232548379d1b4a212f6f262859436556f2a7058b68fd9c12717e27b14cfb4feee4dc63a979180b53c56b939554c62bcedb7dfa3229164b4c7a8fb7d0e3ee603d5f025db7f6b8cf813678003c73e6ed212d074daeb189ff40444b4624a9ee0bb20daee5805fa940e461b77af6347e15a5c57874dd926fde15a8e2319420499442c126ba5372a8cca7a806582677689ee06cfdc099ba4d39556527fcc42194d7fab891672f56a95aca8a88187a98278ff27cfea29c498cc9123091df4b05ffd81fb1333ca892fcca0d72906ad679d2d159a7037541648f639597ca8ccafff3dc361fde59bf8a7f5a3006403ad0974f9b9bcd97d216f3f28839d772ac7214d04359bcdfb11df4885ea928b2cddd52907476f67fff2c1de0e4d410da590213cd122814b13c6db12009bc53ae2923560fd0493391fb25bc83ad5a0e4597e75b94766c251a1ac4e4be50a1a51c96354553e895ebcc4667cedd779e5e8118f201f23c63212ef79fe5c7bcc6f0b0516aaf23e92e7ba3868ba14dcec880362db56617a90866ca07fdcb8b758c4b158447375708951e63b472ba3d32ad1b4ac6ad4c3424542d61ef404f44793ba0dedfcbe69e0da25abae263347a42a84df53939cde08b96da6245a6128d04cc7877368d2591bf66241bdb29c900159890b9cb066041cf72af7fe34f884554640ed1bdcb0d068f3709aa896c1abbfa2406a57c8af55bfc6e7ac4d0cbe88f8ccfa19e529f0e8ea196763b6629142d990f58ea4c7adbea44f11e1a3d1b3a310af52248ef870815fd7251bf3036b35fa84b93f598d2856486880c3c36ca499ad4a8c3ac70df379c87ddb9503aac5d886e55e26e599c3ca2fa4d910ac116364f9d35dce3cde2bf3af1e40c35c1409e8838e0f1e5da6706f7697071659bc2ff8f2e5339e1af484e0bce46d42a33bcd9a5738ee6c2afa585f00c45aefc413ebe04d66cb9c632aeac82c2f9fb1e1b55fb1159847e305d1ecaeb5af326767489971533440a18ead0bec6cc58b4ccc3d95675f1107ced1e5b0bcd9531b9b50ea0c4961615918294f5f28f2122afc12edc6da4a2cafe448232c408ae4d0dfec5e768f1cdb83271374978a80e49f55edf2b982690fb52b838758066b4184b4d6010ae1d3d8433c771d5955b29e25936b31ca7549b6764cc6dee8e790d2555376209d18f9356a3ace1b602523cdfdad29de95bccb2019bb310d1a089316e16806da6b5c97bebc8b53e7e42c9e9d76144b3dfc935fddb79bcd5eb1958dc6defab8119617a146089f46e2c93c7246b10951cf7b81ef05d3dc84b8dd61b47461688bfb952560a5c3f72c73ffc7b04a1e1dbff3b2d92e341eeb0166be902644c5aed558f4e6dfd93f35d0e18125e49589d6cde3e633ad956c7b2d02e3539f689ffa5bea91c1c283cfdb0872985ed33591b7a1e9edaa91caa6b955ead5963b86a5fef2524f9cbb574004ef7ee9292ea0823bbdc4bdf0462126a7a04600dd062130b5bce63233f473e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
