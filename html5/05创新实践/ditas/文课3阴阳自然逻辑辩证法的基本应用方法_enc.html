<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d185fe9f4d1da453f93a42cb69874a39da5f85a31a3a6b9705790f88d9a34231422373d4ba6328b44add1aec25f996e5f10100a26729da3ac375ce82c0e53373c4d6a97b477b130b566953618e9b4310ce7591ad0fdab010a0b15bdf8085842eb040ce6f7900a0999ec0c07ce233da3a24d9152022376206d81248801fe672fb87a2eeb643c78f9e90d6ede25776e0cfaab59a9118329e9ffc39d191db4da8e55b66f4b1125d7400d79137017698906fea86ed700e625602935b83da035802c1407f7ec37df4d30a07a80de0fd30113f2d4a67ab53954db3f3c9141d9c04e6d477e48038ccbba188a8358da163e7af36beab5ede762840b847183e0810d0c80818107032ee957a03db0881e69e79f139f3598517be37076d1b56dd5a486b247d5222eb7d63fe290c4fdfe04267884b7858a1cdc0d7b34a68112283b46539258632e2a1cd6006b6026d25ac21c6b6b09e8fed0f7488005889244eb3f0ef7b2c9f553b8bf01096700d841b379ea1bfa67cf1dc641ae365761310a6cc5f6658dcc8758dff74d6556efd9568bd126fe5bb94f702faf98b2a267394054c887453891dca75151339a9c2da0823cac5610e4dfde32dc75726eaf2f6f0d17e255b50fc0cf234c685171830723742a2701cea068e689554fafd260ddf92a8a89272b70a60a4a1dfcc557bfcd96a25e84bc5d9b61049c628453f7b9b47905631b5137e769f5c3977d56f163871d4827d057337db82ecbb8b09a5c9a4f3ba8d8552828228fb40e540689c15ae26e855125232b30667ecea7fedaa32d5bade1da59ee6f6818e8be09224056f421b2eb7a825ab0d72f0f8430aea9bd65e4b27071d425de8709f83862750af06c209139c3af3428ce7723e6f81076a2873fd6e6a1e210b10162f70b6d99fcd69c15fed7a27e1f7fa9074c344f8d19ba97c9cb9953915605ba9e788999b6966492f374019cad5c32cf59613e5752af24638967b913de4d7462556db559b1a9a7e42cb5c16f287cd492b1c7573da0313c3e2fe443645a1f5d5418c734c1c35ddf80c9d72f47cfd206adab95e67e4d8258283b812c5d9995720971afc8b3b4cb1da3cc0b933b0c3dc65b3fd648673b9dcf9b7868fd259f586f299a18e09191d27e0fe5ed5e97a1be36d6b1c31b49dd333c18cc2be447158373e8712f83d14320fb4e8e72fe1fd6c21fdc69a3b2c3b02d8850f589793fef0d738365de488a5a8a77395907d5d0269b75f33fd8e6abbf3d625301917ee4e7d8517003110b1e26d30d244a693c9285e53475d41d7b4c98d07d7595b18d60cc581b9bb3b5263d2d4068f6a043e1f99f5eb01482209de912c8b2c1f11d33ff189568bf67eb8439db5ad2c50c7714da71e03ace9df3acd68fd4354c38f4f960776e23c4ad47e67799ffd5331068743a769e9f5e8efc44e7af6c0a6d069a3061d880af0aee9c6807e75aebd3270210638b4e06b85cdf4f8fff1afd3cd63ca6e33a7827673d707fd7a7d870c3245a04a245f92c890a50d633ddd1a5e9a5e17cecddbe0ff735b1958913f3cd718b362c090a87a2275c6d0f766ce3802602d6857a16ab0026dfba0b5bc8dcf83809af3011df4e9d277021eb713151984ba90850794199fcb7760a384e46d1c6a2e8a3f9f85b7d604b5a77c4a691e1be2b9b495681787f62747ae47916ff1657e10bceb6d78c27b4e603a88fd80496b41ee67bfe8f4966351bb9a3aa51e3a61cd7d481830318e078f6f097cfccd7eff1c2bacc3c88cf8b7efacde51f5a79e0d86e3dea936e05888076a4e515c165791d6155e99a1ed3d17c98f1a1cfbeb78b2fcbbe78bc13088bc19010a70d1385d10c5c45e4fc8287e20d89ed8087c604c29d9cfb57e78157831f7b8609c47858df343941b27f5591398f9bebc830556eae33de02a0f1f7a4396d81e9cc9b128f3ecd7a6bfa09f74d4a2be3c9f757e2c7baa32867c5f42abac7a84a30f3fb7f891646160282403ffa8c98d4f2844d404ae61c2198763281e021f4ed09d1a73f054e189d86de22eb36e91bd2e212931f5830f8f0eb505a34c1be8651bec981fc5ada0bfd8ca3e40d83a34d9711d46726b514fcd0954616807aa134d5801bb2f74dd783fd231830608ab216c2c2131346835664823d21c500e4d6859488befc594cce422df6c810c1760295c6b1160c65e91e7b687ba47ab058eeda6b1beb99b017ac87eef13cf05aa6fe20703050d70a2ed52cc04802e4742dbbe8827bd8f87fae6d687dc46fc2de8137e763a448831f01ea7703fdca0760a32e2b2a2df5bd5f1fbe646c65b90ca6452677fed5bdf37dbd1cb93d67027dab3a8a30f61d9ae3a26d4553a8ad02a52e58434b62de71a764b982d149c2be48c5b8e96ecdc0baf41bf66fef0151d42035a976be1bac26714701619a1773a221b63f13023d6d88b5fe76f3d582b0c40029d76c15f032ab09734dfa4612062ec41637729a95b491c33575094a32af4ecf0d9f1bbf52d7fc4bb9386ae670ee3ff057b703a9f8e883c3d104f62e9f0054527d5d8f687c8e7c0caff95d4202fcdf083113394e76e5536dea8d25699fcfd4f893ccbc65b90974ccac21c466a4ea437bd00224f7612421d8ec9d33ac78b6104ceeafce1a027e4910608755d6c8a9bea90f0a496429f508787b3b1e1ac7a86c5c4c22d70c92bfcac277f1d0a52026789bc530426a63ee9fe357c64899ccf1745b4e11c0c48e864838c839f882622964b667264b9a055665a02daf2233fe330870882889b8128770b625b494cdef8d19fcebb44bbd48bb6784a965ec281fe1764a76fd929a67b0ce0a249392e3ab57f8f1eb067f7c4b69a58491e9734444e1f12183224526a1149d6b83c28fd113aff25243fef47906e2e03150a6b0de4cf55d11318eb83332847bd585116afc61e23c14447eda93968ef29e920274e79c7c9f7e1c20c24acbb2e55cc45af4177325f5d8beece6b4b707da8d36598347df318001cea730ba3cb29dfc1298c18170dd63e3b1167c6bdba9a6e24cc9d644b51bdf142d20a73f5c64e7b1a3574f6113bb443a6ea613d14fe38bd13af07600dd32dab5176f2d13ce9817ed02f8ed58e70eac0c80cad7c661c495d5be019698fb5d47ae4000ce94dee99ca0a29308c3ea4ffad665d19697d3fb58ba64536aaa52f0c6d99d89386a4192e77d89020afe86be8a612c242fb72c4315bc36f8a90fa172c15320377f22520b6e1ae45b64385d58a09c01bcef3a925d578eee733603661566ab6ec5004fbb926b24696773ac46b0a27dfcc0a2d1685c75c0138a94e7cfbc52b6691022a620b1048c442ca0cb4a36c8dbc2c08ce65c8b392d9fa2e61fc10fbe898b6cc6cc455bb8ed0c37a32126ede9efabc1e91071eabf97e3b6f9588ad31eee5e673d28500edf3c0752b3ddc45b624578051edb426022167027186cf85fe73fb49eeae60784e84fa615500c63d4920b18af6af33252478de74c6f9085bc7996c0ccbc7196e6bc62563ed052b5df2062b964f1dc0c2dc66a0ac07ffacf0594c69edc6854d025c8ec518c474f151e62f9f3d379d2d69a644d2f9288f27cf2f47aef89c5019076bf4e1296c2d551a0af158cdb60e7f5e603d97b96a5b87589f83ba3dd52076b7d5ec36c9351179bc5b82154066fcb1b62d01b5f687cc4acbdedc1b7d5e7410604c636c95063eb78d13ee95f1b09511794205853f4a6ac7bbb0136dafbc26a89d6d8279e8cc1a1955fb637c901faf15fff735f41ae2d25616d32e25a8cbdc432c163fd5158f71714bb2b790e2f1c83ce880bb3c99d2dd8ba69a3f3840a53fd6cb8ff01928c9efe604d9a1a1dfdc7d3e01b7d4a4bc14b1a5b65df56fe86d71fbd28a436259febc23fe8f16dc38a2b4d7d91c4291509afdc1188f0301443616fe2fb2df5096eda76b3f03536e852006b50dc2806b9491144aeef1c6ea4aa79722db9728f57a4cf1880c8f04a1eed73d252e8aa411661131c38ef057fe440d766e043cccd286191f37751091a7a209121b68a49c73f3cb388d78342896affde8023b5d2fac23e0717a8811bdb57ddfd1f1cf4c643206fb32db75f3f7ec8961f0d28b11712217b263087bb0e29a734625c7a39cc9556f19ca19554c8d75a473656003aafa764f2769ae6047e97d0cc2938d82b47bb0f212fd2b6a55683e2e9d4c027752908b49180ff3d5d01f8ecdb66e5fc7c2e7043c0a8661481074a3dcac614f5835937ff28c58fb5e6a90252dffcbbd7c7220490fe45d17b27e41a3e68f2e67eae7e7fa0532647bc762406fbf81f72a413c61777f42c79f6e455ecc9fd9059a765fc7f76fd5ca95206803be8c893034dd2d3e4a854ee10cf0ab17977e30da5d42ccecb73d2256758c856660ae0526e8f9652bd434805840c980a1cad0d5018c6ea070e1ea89f57bf24012ff6d25cca0c7e29a9eafaf760f7396be223cd9a3556764fb4f8c2a1970cae722cbe677c76cce1d407325ea003ad9559441f49142e0d1cfd014af1913272c632c0424b1b113ecb992ca8abc360b740a48a5f01f49949a063d7b6ac6654a9b0cba4b8253cf4649101210d3d248fa25d3bfb002c1af4c2747e4f1c0e7f1b0fea92c43533d50978754c810ea6229ed6d808cdea25b0c974818b81f096cc636ff9902d80527069e20b94d301cda189c2e685dcd03f5f55c629ee4dd8b6514668b0769a59b110eb27e548bd3be021349d7a2efcff8b97c245115e9d236e851e60d9b0ad6b3b48d16885385e8176a48197bcf894eb18245436e0a40337841d3549d8a340d6b9b009039c11198d848c0d28b933eee574d9c33ca21e0cf80f52a69389a132299b147cf6a207e29141a1a5d64f5acf712fc4b74c083f8ec78a5c51a8f7a350257d7b8deeddc7bbf13568d5304a5b4600ce9b54fbb50ecc6eff719f984f86db0a4c8adf70e5757dc5789ff22557cf03e6b5126a5445cb6392d7e4d2f270dd9bb6f1be2b1e453bcef34f026aee4edec14ed3f99ad487499f0f806750c55b0c9659a2a068bbd4ebff08eca7ef5eb9eeeee5ed1b717077170f71b26f7e8c4daa40cee704255140f594e36fae8fe795ab9efaa06208931c0984024384a7bf77eb499d3c0fc03a2c94047381f92b219d54e9726940663d42600a38431667b7887f4ec26bea50e3abd824981e20fa262895a62ba41bcce66bc56bd35ee68632f76ec774de99a3230bf640de127793c2732fdb3cd1252344ed01a60ea44eb0cbc7786b1216ac7f9b867ccae1117dbdb4273556d2a5d1007dd8b4a06bd3ba48ad389b09af8be85aa433daaec325eea6f3d6ce435de929d5e1084e92ab1b0926813ba21f739fa7441e91890ca67315e6251e1650f9c5e3247bcbf35d8e816006f37fe847b9b0b80594f6b96f6db53b2caddabc40f8216a259ae6b852e34495f395c197274e70147fcda5d374d2084c35d2ab6fcb7be4738f89f1e38559f465f277a908e20dc8d9bb1a3d084176fd52ebda12597543151e220ae5d62ff13598617caa70fe24edf0f8881ac5a955f6df490713114421c24eb7199689a4971707044659007127866106d94f470ca1f7809200347644bd15bbc2765ec0981d83c455a7330d7d350b12af4fcea5a0f590f4b9a425040658133a3fd6a331872673a190ae17f5300e6ee4be4adc9198bc78829c78f8165d2336a50ba66f7210779e83de4174e7a2a965305ad840f8267323d5156da6d4fcd31d8665132f7cc9b700f360e06de3893503ac14f58faae1d14213f38c5db5c5551ad476b13ed07a21e56cbeedbbf90b1b8c7dc477d607e359629255dffd5f7fc0ce56abe800c8941d23926ebfee33189acdaa9a48ae128b4ea2c53480d5114285999ed10ecf5b0f242fe8af2791eb7bb8af77328dfb9270ce0778f85707acd3a8c9fcbfd53d53d3db18b7fe8315966d45b2e5ecd869cba283d45ddeb86027f0d3b7984d8c0a89f0f63d3c0a86cc01e7b179a2b7bf7dfc9fa63ed58ca527de15e8bfa4673662585d9bfe9225f67ce88601841529d96a314f90aabb687187ddd9106d9c8af9c447771d86af46eba4a14dff86999ad63b4eae972fee2e595caaba64d86aa229815f70bcfe66b9bb58d583704c98b07f386d931ec0df9273cb680a4c4c4ecdb01b16acd65e1024c0958a98168c90f544b5e0d146d0998cfb14ebf9a9b8d5270af3829fef97634e4996daea86a7d05f4eb3174c891264516e48fbe7db49edc91b1654ed589d6d7503875bd53784ae82c427f5b824be4ab498370d3dca2d7ee83e4d816f1e48deba01383054035e56f093e37d1846810d8c98afcc0679d0b3b1f8641e2dde7cc873b939e2891bbfbedadbb38b4146eb925cee840f55ea5e7adb9e4652845113484abc8ee01aad5c6d92d4f724ab449fdb9bafe0f411fbdd3cfb74d36df079c251d71731d8cfcf07f28a4602313cea9a78d8679801f106819f3ff7edb7ae971c4d2556b7842e879e91a19f90e6f2a9bc8a4d088db53a987f93dc7aeb4783ea4a1a24d8e9de003e7c3af1af17688333a27c6e732f4ed7c327c927b325143c8100fc37694b2b6b3d5d0a8214d3ec579e4151b1bed90174027557a3b086802857e2c4a1f332cbfb5aa7de3f6df9b6eb4fb7a96d6f43bec476bf506fc584fa30fef5e61d21d3d2e0be929352208f39c2b93c76a6614dba2d7fbc343766dd0c0c3fe2fa54823c46879569d66f20f96233069009bbde6b8359fac37d51e094cb5472438c3de1472c1cdbbabd2e22fe561792b92dc8c952d07275249291c5ab615b0b5e4fae0a7958f6aa47288a94c67a4d4668a098327b4251c4e1a667ed3df533b5e129a3ebe3eb854e282d15917ef19f7a108d3fa7f1b41d4a96eaaaebcd74de94cc784214656fc0d26beeb720d5533f00171fa349b439c71ddf28a740e05fa605c0c3307ba493a856bd0602e9b574e5b3db3232dc00a2b23a784a60266f1f30aabecd06e456d7c86d31a086aa0a3f04a3ef109743d523b4579a4060cee6cb5476f67a58df3b38a91d0784fc1c1c227f563d803bbbd581ca95be87a79f090e143ff024f9a701897c27b78f5ee830ca2ad8b808f15fb38bd140a601c72cd32427a459c39b6ac2a5d1d8c25b3beb320bba9ce224b97ef90a5a76c0f706f6cf5597206dfe32a844c0abd643747aa54dfd54913dc4cd163c654e38f168485f7c0dc946a43ebac765058725924f47752fd377ec4d70332d0175d5d362f5ad6b7e7ae20957464342bb0bbae87dfead3a37da4ced35f44e71a80c16460fce3d15170bd2534e206c45cfacadb19a249a2c41f527db33041d6852fbeb46c301667c5cec130ad1f572b7967a69ea966a50cce9cacfba3b511e75c0fe8fcd3604255bdb67bf1ea569c9a3bcf21566febd50389f0e51ad1360361fe1358789d0aa690c27a8d59184ebe0be7887302ec0c58a667cc8719b6042a19a5df1a061026666c439cf817b608ac39c3d082c11ba53336f2d59437d6ac898558edd363d25eafb3857e24bf2cbe57f5047d52341cbc4cd1412ba1a0645184f62c1bc077931fe7c01557afa9b07cfca9614f5204c86fd18e08d11cdc3dab34e646c42b3c648e911ef04c4ca8015aa2edf26eba814491c093a96a8badb6ba5092b5cc3b3bd2cb48a0558e6398db811e375538b9000ab338cd567eb6ae6a486395b912f7924b00747e98ce5192ad06c884034197df2a1b79bdde807f76d80890a4120030ca3570187cfd65280606b22265072684b903db4f933c969c1247e06b56293da8891b737108a812e7ab8226f6ffa8d247d2cbb18087bd4fa33a7d366376f33d4c2fde60adfabc6e0066afe577bdb7f81e34da0e0e4b730e06f6f6a82095dd28ecb214b1851ae061aea7708ea57e0b147328ba4f90b73d0fa74d7912bfb9e364e22c6eb4b3ca0a589748f83ae2bd4f934075443fb5ba5791d6a8c2b695e468eb2a9557b793e8380948902467bd4444ce47bb41e6aba92db6515caf531de9c19d29f9984ed741b78490b0407f9b70c12afcc0cc0a64584fc6ac5b9747fc7b8c796944c57db3753c29017cb67ec063bb7be37853a8b3469c516c6441f8a56e03c601ea2d2f14940ab74a5cbe6aee56c91d29ec49203df36278084d69a217f93b718629730ca6fa4c1900b9188c389e1544b55db1e3ba6fed0cbd9a318fb7a31f80272d844a974f7e0c7cc496dfee4799a6d7fb3151e16c8dac85a4dfe3cf924ff24d8bec63263ed6f3fdb6ae12a7d929ac013e3c189b0117fd9729e11258b48f4c0bfd64a24e315ef58576a8739b0bf43537549097d0d251ec8e78bba82923e1cc962fa22b698011015d915e140cbe69f7d5fd233fa9d40054dc001920a8ef5297a4dbff925a57c6533fed63d69811956009dca29a09a8be99d40b106ab169cb516062278fff0a61145abcbc8415cf3eae141d46d300bf9f397d591388ff9cb187f590f096f54271fc9dc1c2fa441a4ee700a3de00a3556504248239d7fb0ce1a27bb04a777f439a31471acbfba67401033b9bd46e9eb224d413cacbc2aeab05ad0f402a6005ca207ba168da0eb9b782aaddd2359893cdd1ed76468222e64a32f8a080f5d661585c85f72973590e36fb36262ff646d5835d9e3afd023c01762af8288d82170958893b38b33ada8ac7e59aaff181e47774a5f2cb818a46c8e3ec228211ae61d122fbc4ba3a8603d42660d3ab723150b4e9e47c9d55024849e66285e303f5c3c3339e0448d9c8ef3d16628fe095aa40300a70057d6ec04f3d1c923fc7b4c1ea5e4181b257570e7bf2773410010ac5bfc0daae0f82d7b55d5114ebddf8ba19263f8257f06ed91b9a4823d628dbfe19d0ae573ba8ff7ab081e0a618670509974a7a6bdad08855f751f0ecca17cce4bf3528aa95830083cf09350f28aeafe0ef672cc18df9a8c9d85b39cfaa8e2ae5ba91ff03317ef4eaf95af0c596a437585c7f2907ea230e357b7881d0ba09e3a15767ea01f1bef51c914a6326a6f147c8da033655ff1f490538a10bdaf4b4fdd82638b9c5e8e08fe3484969ecc553f39d7498d906e070ca8e21c82b82902beb700ff75c353cebefe9a0e8b4420fc54aeb7f2c67bf7aaa5dfaafb6d317c010643c7e32a080d8e5746f881e0295f17111a580fcab142ce7432f9da4d6cd6196b94df9754477dec221a3a357aaab50ca07cfab81afdd02cc8010448b249e1fc9092ae4d502c3e3a3fe89e2e4f20786b4e1ded601cfe8fcd508d5cdc14e69ff28ac2343e868435fa379e7fe177588dcbf7a160eaf50ecefdab10f63e6c59a3bbbb104050671602d39713636687d0f1a6ce6acaf41df4b4cdf51ff24f1201e51627f9bf3ebb6202bd787806a7fa7dfef896c9672ac1293ae4776240d04f7803555e47d340da5c041cf245fc55f80c604a2aa6321c16807d2d776bcd86a01c0f66a85fac09b25664bc47354820db7f1cb2052f41ad7d70f4ca379d7eb2a13132ed5297d5409455902c1fcf27ac63fb8929a390c800af1ba529a4a53a921e0ffea50b5e35df2fe2c21c920d8a642896d440646f4b6197d4524dde44459f4f0185a208bc7d7fec4e00ba608441be18328f76bef9bf44bc2f29d4bb9f927a7e4cbb0a52e288fff2eb5ef5696b9cf4a2b350bb47d01f303c53028e24173d8f477711c6ac84177b510395b7f169d675a0be70ed541026892a56ac0a8b452e07bf0216d0036e8701196d55c0625a52d44216c3405cf87dd15210d5e873e6ca504e752b42475b301d4bc39de18c63c23f12636f1ed9dd707ff9c6eeee7e3d7277c75006d43722195114d08631e6f49e2cc19e44b476a71c9ab24adacbecbad8f6c43bf0b412e21d7de0cf046e57b947b6715a815b2121440fba9e3136e005eb3395652ccf182cfe6f3007d7c97baee5d7e820d71a5d86befc394e81ea0c8abfe73a278aea2d0f2c8be84cd6a22ba579a3139deda0f98525e3b51208a11ef5ccb9423f4bfebd956e2ea42d259a2dd6ca07851bb087885b9dc2621f712b08fc4bac73bcf5c5e32300703e559efe10c6a166f495102f1213b63ffe26e851705174e0002219073eda324b77ed7f405f2d31584126e56a3bd14634e61cb2dba09dc48e9ae9ce5748af285cdac6a81558ccbe87bd4a0ff9e662262e76d89886596754fa017bee8fada5983e1cfa5e0619c38fccb24cc6e46ee38419bfbeba5747939b80deffa9160952e3c344ee1a7aa2245d8272f0f6499f09c91d95fdedad6dc0eacf0fda343af691859f06be73a414a162d401cfe6f5a31f611759b5041f3a00432b91e5f47916a1c0fd2034ac28c0769b639c76229990ed62ea5c7c77f94e218ef5507a223712765217dc01c965243a90e128397964e6599d7ef17e389ac76cec5616ce342239d34c363d76cd30f027c0c704736b61584b2709393594becfcc66d1da618478daefc23b561951ea666e0793254f667e605d7c7521f93a997c49587ee86f49650bf6e948f75fe465b58c705c52c0a903b6d310fe61d8277a7697895f6469335713308c67988e61ea30be4620a887a82b1c7e5a5b40c2e6a3d6bcf91930c0534e6c75da60c3c4fe74a1d7ebe82b2ae7592f4a3f6f262afe40b38bcd1656006c37738e826c2aec2a1f91c7b6c2e2a901bb846370f8b2092637bd75c2700f4abefaa1a9e10d68ea3a0b1ab8dfc20539e071aba0dfbf599a9d378a8bfbefdd66ba0ae97b5e5e38300350ba71762ab49e02113fe0b8ac17412a4f90c36ab629f998b816e4eff4a451b8ea025a5b7a9b4136696fc851226ce66d3692dda5fa0b4b96df7b8ebb8cb134d9400c74b6cad389da2494879065f1841be27e78a92ddada5670f2560c25b7823731ae409df310cd90c04238f5eb14a6d086838e2d1a976031f8d514fdd0d7462255c1e9d35df667f99ef6e373fd3d4c595b63ed551647643a3f81cbb0da4c0bec2d60105fbbef0ec8f6c851b15efd1ad22ab9de00f6144d26dcc3ad6133d34ab855f2dd03f439db38cda1cb84470fb13ecb88a844b17dcac96185625a21a152e3afc60cb85a5cad66ebea3484833663b26cec3f85d465d4df5c9ae0e53b657dbc77fe239bf96faeab43710f724e48aa5ca351cf4a36d0e2716e0ebf09f7c512414af659aba99868875e2b84a1f04b7aed6cdc8d1f097740b10e07f2544174d01d9dccab43b7714c83e82fc4c64ec45d06ee3ea80c47590764a605326562dcc8c23fabb798cfdec92e4e47df738eda8b976a9b5e428cabc3fff7c012790017467f35c0e73004ee7169e21f22a6dad8b15c2fe848cc65f2e8d70f8d9bfbca0d1841011043ea89834b1ce1fc77fce2073fd3f01db5ae3ed6c30ef6d9d741f2cbf0e08f342ed14ec1244fe421e58bbb4b4833fb0fe252a9e6dcb97bcdf69c2f151c3d6919d7daae0d6f0a558dac3f07ae4630b32d887d7a3a76615eca068537b3906a206d88a404c1a763d668345698815904137f4c95e288a5208f1465756ec35b5a3ced085609b075f02923e1285f1c571d5ac6901d91e0de4cc84cf735f71aa0bbdb856923714409ab099c064cbef116b11bcdce63c29939b7a2b8ae6be87197342a91cb939924fea3e96c9d858ca34c9dfba55d68349839bba5ab6cadc08d0068c9dfeb064e46fb0cb06d6dbb6f4ee73706bfadc56455aaca5d063b40ce044a8db09a4ee5c99575bb27ec50dde87954fb88447f11d9286702fdc6d7654c1bbe165575f5c4c0ed8cfb95821150187a65a64f47e3820019aa5e80418f0addcc92b6b10a505a8fd806cf953e9bb431527771a86937061d35da2e29b513277f0dea1054d0056d385ecd5459ad6f47b8e7a15862e1d54c6b33af74357e114db8bb3e650aa3f69f0f255552612904052799e7712849db8096d935496c45e0a894f19e30a4516fdc8522fbb7d570b2731e40481d0793f11d37f37f47c5ec5b1b673b0ec09d6cf0f9d7cc0df15c4b9ea20a84d61da0a5ff56b3cd4dab149194a87a80e8e333413746f612b74839c9010dbdfa5e8927ba8c648f152661575cddc04d3c4b5f5864c08f90cd7d7061ca27e3f4079d6335172e3cf369329db5ca23c863043a0aab3a0b2d831bae70adc7992d4fa1ea037042a9c6fdf7b52443b8c91c241a7f8104feefb3e12b73422129662b16531a98a3a2b353096372b68425510120d6c20c2d081bb09f1766b1729f909de5ec6908eef946288c5d80528150fe69c957dfc14e781dbbee7197c629df358b063c0215019b6b7d0f2f553bec9e9a211632016b1f2f417b5aac1b3ff68c9ed34357a186347ff30f33caf52dc3af5039ad40e57875ba8a4a0710221d27b8891b8607de10c6a3c0435f01acd2f4ad98c8bfc2d4bf16a82d1887eaeb00bf806077b264437442c72f57626f3161fee69fe356be64fd3a4021357bfc4ed3c07510e988c7494986716931b7b10876e763e40b0fd09003df85e2f9ef8ba6e3d193a3a58eb2b9b572c966685882b566b0bfbcbc58b27e7ddfc5ecf7dde551c5fa366ff924e56a3476d1d65d89054c14ed09ce5728067898db4f6c86a1ae18149350ad7444368859627209bbd25fdb447e8d5823727af4f9262debc8196e05328b6f34ec302ad8552abeefaae3670c7a99b2505b276614c44795298183e3c39cf6f077c9f6500fefeab","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
