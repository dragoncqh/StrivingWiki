<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d842e03039c0c495a24e6009dbc5283ff150029070c5bc7c86360428ff936892ec1f6a557880ac6e7c804845577f057fd7bb3b5251d3d29fb965cef2398fed9cbe83125c114402415e29a08cb4fbbe1deeac12b6cb98168327def86b9e9b48baf1cf90e16f33909d03ae5c49b130143aa0a15009bbf310f3fcbf705849a45761b5feb23fd8dc292f7dc384e77949bb1497d5e965461cbecf25ff9d4b59ca282a5c82dd52e6430864a9251e12d7f37d06708dc39f35fb37535b9ac2cbfeca8c72c7eeb6cf21478e2ec0f37954bedb3720ab2ebd869809d249784bc9914a104edecdd5c233bddee96da147995674923b4837ede1ddc5ebebf0998d891318e69008ad50bc26dbfbb3715d7651ee562a056082792aaa182b1cc28e4234b74f9198aa8345972cdbb848f646f6a11b3a4896f9b8e584c6161e45bfb7b8dd079c393f5512a5808ac0c7cb108a9a0551320b7151c141f9becb491161aba08b68e1f4ed628f57fb2a65ffac7c4165cf59af29fea3fa78db2c7798a75a1ee191633880de31cd7d3604bc502cf0bf9a598f9fe5c8a26f9b5d3f7082ce9fd5c60b008fc77a225ae2b8943df6ec159990554a4be1226a6bbce99f6815131f7211df767f4b62773cc5fd90cc9187c8d25335c028f1df03422a270035eefb6221c06f61c6441109c0fed42de8c3e54181211292302d95c16833a54fc37f1695c96e7ef73633954f7a4664dbf869e3945eee3de98ae95e54d08ea357679cc77ff2ccbe33562575cddec9d27c987908e7a7fd005ef2ae7300afded7d3d8ac9e247859bbd5284ec0552902fdc92336296ccca45a1b60ed67f23ed6b21b6334fe45c9435a23062271332f39351d289660aeec6de5f6704df725283ebb938c2aaff16512ec155d7cbea0c8557f8b2376640ed151a86a3b14b1cc380a1566ba29037c68fc2401a3902d21a2aa3d8861059909a92828de6a52f2d8648573763ac0fb832b6ecf3385d0dccd4ae2bebc5410c4252e3e74ca38fb56ed1a54f4a9ade1535fb34fe0c5dbe2388fa2a4e381225696bbecad03d50f94d9dcab305ef2cd935b6b382c183dafa4a323e64f39a471f082db56422f44bbadfa93dcb64d356934984fe690008002ae903b1cce8172e2edc760ec2081601305db8ef63deee797c4f2fb5754517288658c22307b64f3b5fc367de3eac6a36fe1e92e8dbb8fdd3d73790b48f1badd537871fced856287c4d14172a88b42c6b31838bfbd933110c8c5cbbbf25c99fdea9e4ec2d3d5f6b45ef86f8d537abbcab3d21487a31d4171bf2fb3725d1ad75ebbb877eab2ec7501dad23bfdf9ac5d64c47d381d3528bb63e697f396526aa14b69cecf810f0b54c494fd3e0a657a5a9b270f006546bdbc435737cd4aedb375f8694449906c0f7e79e9e41b521fa3f4e2abaec3d91719a014b47a36a79e7bb6e2904c22b9ac95f5885c167934f7f151b6014744e877a2f8375e1aaeb17b51492d9c184fe93f7160dbfae0d947cd6bdf37f07b4d7fffbeb751d9e40f446f2a6ec675e8a2291aa9ce7fe4df95320868ff1b24b574ba03843539af8218b72d03f914ce14f27f82344f0a57f931f7d4c3ac499f9a1c2c59f85108751ffffc8f5006e0800a1f4fe682f1cd65bea57bc2a450dcf5a05f61af36a839955ed3b4bc2976e37a4ae1a84266f07a3a46aced150db3cc3bc80f347e38a9bd09789f50f41aa261e5fdfc2357972f5608be427c69b256ba95dbcb0ff1b67813c0f8bdbc0281a6d7e41f8e6d2d7f601a1d55a3acd6f8d805cc8dafbf1cacdcefdf1f01cb8f509cd23647572da78481aaabf6d3c220a366e4a6fd3ef8b3e5a66a1d6aac889d10cb379e94f578114c8ad1662d5e46c4ed95cae0fb7271ad5a2d7923d972b7fbce24d892ca34b0a3fd7306c71a42cd1cd07a52c2bb2dd465896a351913df5d0c04d4a52fa0f2daa82347b03939e5cb6940b4cb9db36a052f3a43f87350616e91565b1760c1d94e5e01d6fad06a83792e06534eb684bb0c60afca1a9742a6a689d884231b6a1f2ebad7e0861f2df0446c28ca0fb5ec2301ef41c83e0b97994c6dda9721cb90389987613228c5919f1197a6da01ed0b59147648c0191e7c628ff2ad211fc699fbe29a9a57ed9c291f8fbd85e9c8055748b3b0dc7bec64bdefab6627309452ed275412ae38d9c4e62c3b973a4c728d8512ff47f7ed78916122b19ffd8e3c7268d28c2e0890ad183fdaab40c7efb9a12f65fdad00e18ba8e07f28365f20edc98fe59d59768abc6cb38ca4751a08c41c047df2fbe186432278ed4caa675ee60872347614053e8f78e28926153ddad95e93ee980677061d94e991548519a7802c35b09b6fdbd0bc2a043377cb2b3ec4e6e395b230dea149c849edcdf4b3bf973d08e33a1f07032a6783d1490819d7031e0f5ffc0bdca30d580b53f4090f143cb07d7f5e66f930fc48cbb4a1dc99906f79c7874dcb20324fdeb7880cadab7e008cc4b6b391322bbae633732f30fe02e3d3a7e58b63604f4e845ae22bbde65e7316083b3a88698d149811399b8f1946492b873ff126e29d55b494b3a8ae531b5cb9f14e248fe6bcd9ddc7c4fe31fe94c00ce75896758a7ace9da3075741e886ce9310eb2e01cebef4baac21ec99216029e1685fdc5ad6a0e1aa2700214077e5d77a780e27dc465c178d7d177310f14524b8522ed9dc18979256eafcb04d781bd90d9f419362a6c848db655b9188a7a5de0369dffdea1146d0ddd76b261fe608437bed0c8c2bab653fdcdabf09a4f61cb50c71e60b74f91bd60f2927e620bbb4f3d1c98012f00322610d67f318f4bad3863471c397da639d567ef946904d2e40b1aa035484965999084a03e140fe25fbedfb0323677aca3ab49fa60ae1f60e6ce2ff2851dd239036d0c55d1983b73f8c8647da9fa469407906066e8c384b535021efc5b5c494daed05c134442c6859910e7d56dd5b18af1ec134a8b45c431df0a13ada2cfbd6357bb3a4903b6f671c7e8188f3e5c072bf74ed45f9b7ded9eb1b622118229c0f7e75dc53405977ecc0f3b1a1c2d0d37ee1578d146b31d6c6d43e99e52bedaf459920d18288a8b8c82110caed910c3e626cbd92d966dd05e627a0a6157dade465a568311871e074f8f60008c1ee1173cc48a279e1b9b5eeb559c0fb08d23da87c98e7eb8bb9252c72cc7cea7ca04b492533921307c7452b7ed0294a315bd5ba13487e64fb100e1e49e12a5005e24f64b3838d1d995d32cdbb6e5b1f1346ef2cc8eb0f3edf73ba3dc2b0bc149514d338f946cd29076437f5396529d5e002420136b8e0a4ca4fb388d2e8fe6bf996a8a6261f92d7d74ead871714d21d4268d03f686900e42a34aa779b68c9c5b8ff7212e6c48bb8b96ba807c9d379fb5366ada5472cb54f32ce53c2af3ee1a486cfbf24d442304ac016bf4eaa089a99b7be2ea73feebb86ab7bf442be25c8985842c468bf4237941fba150e20c74970f148a06f2ccd33ef6c2ff1324fda48fc2b7f4749c1969559680e9738f6b171c224acfeae484ec09a3a8ba454b24f6463113db181ce296b33b100ac7769c67f06b89caca79fc20fbf7ea08777b56e069a080c5b8e59adc06122c12ed5f3131821316cc7e62e8b83c3ecfa553d5b3b8ebea0cd247fb057590da8f8a491c71b7db67979508c7351f5b2cd891da3cdb1ecc889277fd7ac18e0ea2b0cb406e8fe1fc3e7a4f2c6b9ababe78ba05fb35ef3b8066a384dcea341982063e7a4434c0d4af5f049bd97d1facbfb6abacaba8421b21792a73dd6ae91ab1a28e3e949d8324c006b7ece34bb2cf69e83c785a4ea793811d96cbef7fe40a94262ff2dc93b4d5d92275846114d3c1c9b97a93ad7c976f7f3f92dfd2608cd77a256b62ca05cab66baf1ae6727dc0d9a28439ebe175080f79020e5dfd072a6da5fd02d483aaeb33e9d9b6ce5642d76b1523f441247e2b28180ba4f2307f484f7ca1791bff77fc0d6ca78abd8609f37a6ce9021e5eaf5c9b35e3f5c9e765f3a8fb3e2dcbf7efb75a203ffc3b5b2a29c9d567ebef0e74d090186a1857eb5857993a7961005a83341143447cff2520dfb126d36da02104385c7945b377d7227889088b154067315dade1e0586198c8224b5ef332c2d1ee35167f7135efe89c6b721c25f81efd7f70484f877649fc3e539f32632c351a28f9f8864320b6c5c26022e0fbf39701d5af3c491612ca833c1592bfd19624f30b35af392d67e3ec4a776b572aa878ab1e2b456dc8d77085a31eac874f7c94e839e986f55a4274430164dcf0882cec6dced86b946a7d673ddbdb27e9dfeb7c1b2fdb55e7e0d08ada2d61fbe0175562ca0d1f1e5f30f136c33e3408d5a4842f42abf561c2f6b6757361e6c872792ad06d1f4f4e9d16d177bfe2c374e8fa8cd01bf6215ceca71b672b5aa04add21667cc9f60d76075f4e1f8ddf5cf4a706ccc21b8e162a670a4594d4a71a191a52b933c6d41b95d4f0e2a6e53c1fa64a9201aec59b2a8ed3539ef4b0a73599cea1b364ac12255d52fc410deb261f042a08477d3f71860986c1c327de7989e38da6d928533ceffb897e25a5821e84b35e2f75d764b857324a81d715d4b11f33e91c1fafe6cd9aaea684f29af2cd56adf35a1773da65a7c582b8e493796b3b12da6a36f673111172caf7d119e127bdbffea3cd2701b69d7b077700905ef55c462cfa3307c1dc5fef79f2bd3e759a241bb36886c3782343f75c3d9f95ba9809c2a7489b353dca3729d4bc57422812f72c39196549de958b578cb59e12de7a8c87ac4f6b5e5896c1352ca9343fbe25fa0782394eb16c8ff85e0f6ecf0e6c2b8b3c74821ed57ca5f53baf4a89f542aeeabc714e289886ca5b82e896bfd975c022a85c783b837e07ab334e951a2b791f0427281b9ade764d27279b9d5176116cd858693eb51643f865bcdf08588a440e4355c7a7a25b394f445b1b7f3c8eb28203fc843e812cc788a3b6e3c643a9c887e591a9313d3276961c7cdcffe767312f17c43b651154fae2906519489778e08b705e40c12540307896561446b28389b943433353a1b99781946443eed05b42ae221a4857beddbf3a2298741cb2ab7c19ed86da450ce0114d38fbabb67a057f5758dfe35b1424450a7309e5e4f68ce8325e4fcc3b4084a1ab95e786e17ba1ca371f6e3e148a6a9289d23d927936c5e4e197485732caa7e39443c4c117e9aee819ced500fabe40d4f5fdb7a4fe0bee66348c805142ff312ccd5273697807b4735044448d303d3e08f16a02a356133df7187e0f3bc5965958ced2eccf03abce7f9e75035707682a5f69a0928d6fe88d0ee01817984b448a035a21bde1300095131dac4891446eaa5b6609b0b60951238a0e8d7e5145905b761e6284b2b9f6a0ae197996d64facf671e3aaae567d3c271e53c8bb2b730ced421cdc839ae773190b0be22a6a65da7f933cae0ef7959e19b70899a476fcf5c7ebf8a0995d3fd57dd135863f177be3a8a7f3400b78227625f3343a5c73d0acd350500da991a573f8300e78c4050c2ea114861b90e80a8080a1b00ecaeb6a4d3ac8a405365ba84dc6ade04304e26997636615ec1a387fd9d7bd985b854492d5f0f9a44bb489d7700ab8a8f3b630095f2945e2adf432a741252eb6a7f3e36baeb287c2491996d1bdadacd13d880edfb240771d7c51207c7441a60ff61fa4afc0e1fda8316a204fde7de70819a31179f33e1e61f1eb6d14f627e2bdb84f53e780658244f5c1dbf3b87a28c0da66f7dd146fb505d110842d578371aa173bc20cbeeaa0b94a253d2972c9a93fb523d9c4f66bdfb73d445c49dae144265f420321d90961495e941683228c951c1e8787d53325cd3506e4f08ac6293ad2ecd07d3bce466153c5461dd04d03e14500b6d2b3f65df8821180ddd620eb02c4c925222b81064ba327e20d7de2eacb45c0888fc72775ea24035017039ccfa4697bac4cb74059eb0789d9eba81f43ddf052bcb3b60ae32407907e11f69f23381ce953dc661cec8ac14587b710a7e1b3125e8a0535fe2da89b790a138834a9941ee1a7cdb8d32c977b800287584c1a99fa686abc0551f6ea38f88de33daa384afe08ffc33a7f715fe63eaf926b6437cc99366fdc15282ef4ac1aa582eafd79f4eb8902a91904959a7b602e662d0aba0c1026320a5dbac0ba47725b52798fc93d74d76d4ce82e6061790886b3495534d6d06b8d51da736334971627df44d5b1df8a2dcd0e790987dd7feb25125e5d873a91b89613fd1a6b61ee8f22eb158748d0ec97e83acad85413819148bd40bfe26fbbea72bfc30fd643da2dafb07a51808dc44baf3ae001661102d5f49756864a33ca3987697fd553d9cc3654e9af34bf610b73260578dec44eebd0b0ce0529f190d722352d9457039d943790da1f4b1d4d6130076a53aaa540b4bd5bf051c4821fcb5c201c77786165de7d584775d8a8d3a947c08450f574877b955b2a250a8776c959df1af5d2e68576ee0a86ddc5bc1abec28b6455f6ac94b701082f12bc913e93ac39a9310ba756637c8b0d8fc005d442dd34fd75a522bd46259ac5b170459709165088716101578b293dab2c3f74e06a08915fb669c657c6928c5cf74b842b1db27cf5dc2a191cdd045ad0a01b10b88b286436582028b35d0be5543208e8acd05bd8a55e01d827449e8e95f25fe61155b182b6a1a078f8ae72fefe58cf7077679a659f2c931ca5dd766a8e4d563aaa0935edc3175a1fe36dc82366e69ed1c53af2145b9891f04dc5e7e00a4f26a74c455224ca867cd6f7b4b523f4f3faa7712ff08034be380aa3981ecb90798c1c8a259b7f411378f4fa3e5b2ce9f853e750a5d5b43cad4901a0506a2035cda75d3b166569f07afa89ca255f1ff1be06e608e814ec181ed901dceb7f77aac7ebfcad3accb1d3597eacda65ec50ae9c28c1c66c3ba61b963fe5999022dfdb7a94a2d11c5f8f2e3afef2399ff5cec2ed85ef9c70f5e0abbcaad94d084643ca439472c31c01a688ed235a99021fccc4660f2db0886ae4b11352bc78d9d11f74b48f88013ee856a0e7b4c51b41b8af5074aa65732cd75a05cd6c39848deac13961a055e9f31d841d1eefcd6cb23d6d9ae270f558ba2c2fcea5333f5635aee903cd0d90392ac646ea111cc184af0d3604955faa51feef24d1cb3b29f1e456955e5cd729a73d33e9615b40ad023e1ae840434900b82c0b72ca43dfe7f1f75ed9bc650522d5da979fcf4ae80cd32eb5f3c687580f966f1919b66d1da198473b98e15782e6c78fa413fdb7d2e5ee8ed7a996cb430cf7f8239c20b96977e8296434588bc43c7d1a072c95edd4ed19230239e06bab3eaf9cd9b81968b4fb5dc031e50a58c4f9f24cc631e620e0b99532a8d0ab1d3a2236da7c9890bc925c9ef69f1893229df69645b2456a62b70c8d2d3f0b23263694d75536d5a5b007e6a9cebd21662220943389db5f713f050844b7d42cbb695377be439b420c08bfd15132ee4459436da00db81c8706ec18db0ba0215bb70c389848ffd893859b7d56a854f1e4204b3571e967621a105674ee64b7f46d153a8cddaf135d8150089b62123473bcb6123a823b432e52ec7b4ff9b0d3794d4598c1828872af43c92736a8cfb4244dfb6a27bd68745dfeba0b065a8796436165a77673621c1f6143afa0baeefe95695d8d402e41c41ffd6147b3f772ebdf0ec38017fe645f00a0086ca56f21d64fd906c3cec95ad2d2fc079c9c463f88ba425c97d11d854d2dea700b0da01fae739b97150d1f31992073112751219d3ae45505dd368313f8e246f40cdce9f6a4e1e7a1873e4632c3b64d185ad777378483810d1556e50ee9653a95406d7b898179c683ee9b828c12cc1814f460c2bdb7d6172c6d061247827497c3484e561f2444a6eed2b4217c74b2cc93246d33974f4966a7f5907bd9615ecd2eb2aea842a3c9dce1a14c1952b0a91d602844c4e2bd442087985464d39da19c8f69943b14c33cd18e7e4647bc1046a3a39fbbf62c5234f900c9894f8059a156a6861e9554792e8716b774b59d560a8ee6d775e52dd3a3334dc64d66f11597a4899ef6b80fdeb893c2555580064c5c6e383ac84ca60370290637641af6b1a9191aa2b83e972151323b41e265d68adb9ad5737b5786c18f407cb6ff2ca940c8071a4a79dba4026528a5b7479ba52bfe3765916065c58dba6cdd31554c1c2e20f769386923daf07becc1836e9ef62286e0fa10f27ed07d5686508b053785b05cd1968b40b7249ef71b29f674364bf5d20c4261ec44a0e8759650d488678fb5a366ab2026568428481273d88b6231f4d4b0dc18449979a1cde3db55237bec05b5ca07a594317c36c2f066a89334dff16344d7bae084ea1a6a448fd934515a9328611d818e7cfd171ac887bad87dbf5056160420b4826ba55403cd4f256da67f01986e4d4ca80940898c9562ffa56215135b0125a0bfca59f79c7cd69388f27a0a72ed12b9a0e1766a2e8b7726de91ba61df32c705b8a91bd84e9cd272530d2a12cba9033333294d805937dce6e0c49fb3762448294f4470cf6860f3d9f56740cd4115a527fcd2678d079cabb3f93a91a42920e02596aec2d09f72fd860c3fed98dfaf1a4e516828d693769e125086acaf96782794ecf3497bca446285e7253cd270e4a67ed11af7c794950c44cdc82c9f685b46156768facc998bb405c52b45adb42cf7e9b6c5cc2a56825720a817a5645afa552cfc3e68d35fd0b26d55c1c56697b46ac705bf456f3406f89dd0cb7482bcc913754947955a9f7d428873d243573a51f4579cc277e02fc69b0415d35a7ce178c3de64fd1c59c613b031b178071288ccc3536e543a05ea9f3a9d2ed8943ef90f3223daba9dd9fc7b785a66dcae584775b135f92dfbd7d700ec18a08fafe14833133e29fbbd125b372f32a91912a59f8f9ffd8b7bd88b3b5950acfbca23071c6c631361c57d2053a84d9ef8304d165ef6da4f1990c62498deba0593f3b4a7a8cac6d157957bfe248145efbb121e00cfc607b05794180bc36f725a9905a766e6efabe651d3e10bfcbc27b057a5ae876a1b3ac296ad2bf0d7c1f81db6f3a934026702527d995e589cb6c84391e5475b7647db3926ec968681f701185e188ae347ff9bec8de5927703ca4a86259f01a3e1505856bd8bea248c398ec69e38d26d39538615fa2fa475d9efcc4876ddca60142082d5a6be3e6e5dd88bbc7035e29e545d95c936657d45d79e5d174d64687cb6242f23506a7aed07098c0d86e1ac203ab7f3070a452c4c13d7a01168b65175829a049564a03773f90b6177af704d12b737e38f14b7a899ec8052e0250dfe8caff0c71ef15baf323be555c2461e23c99a94d289d86ea8fa36d3f651cc8440f8b8dd9f01332ef818d6fd57ccc7bc40b82ff8c16c9c71fa2bc067e2c65dbe328414680c0439ab9885f52ccbc844d87b09b876862d7b3eac542e4f5c7f4aef2ff87a520988ab82fda1680391f8576f138e039ceee3a32b865da44fdd74f6ae39661ba83f0543472779b7260b37480782131365f1c922659c293c3359694af4af09ad344c4b745b23fda1546c42baba457c40ee37f0ba8e88a7b1cef155cf1578fce7c97f1fe693c3e27e90a0ef57f0aabeb44ee0d2e4b7132dd48d27f05e944fc2ce9b52739762d572f50064d6a17ef540bd8cf3024a133026dd09a95d4a30fb3b62ad68e6ed8728f1f322006c2a5b88d40a5da21bdae6cbe34bcafbfb32466ba1a6ed1d0b543c2278a7eff45e9a907173e41f9b42e831671fb8b2a83e8725c38ee0f0f4cdcdf58fbd71315084cfe168015cf3f517064d47a83e12f1475f6bc29533762928e52ec527416a51054d367cd310920e46bccc17aff70e77e336071833298b802c982ef4a06972f88c3c0a520768f12b39f768bf4911cd4475fd016be842f26a85104259e57a72f43390997017d67ae7f33c93c82d469a99ba293794f80defa59e73870c13749e794227e3a4e48b3779d8aa70421f145233cc2d4a2c7302459ba629c75d07a25faf5854130e78b8fea7d58137f23d9d100cad29e9266b987ede28e63f11d6fd8ed8540292b9b61585bc124703bfe9cb0764b0662857321b56f400fd452c5c585b40fd6d7793f57deef03dbbdabe9dc159af510cd5b27850349a7329adaa1d740a62c3f71a382a98cf52636c2f32642eadb53a9fe72b1e274294a384491cee9c556ae0156a69b59e85e9bf1a049c963493145416ca37c4900af9a51ca15d05e6924dceaeae929b96ba882c7ff60aed82a999293fd330673cb7bb89a5c5f9aa55a23c76cfc75efead658a9316161a72f59ee0d68c14f4789691630f168608002f03885da6255d752dfde0f5dc5e824354f750673bf438e0f8ed82e3e802996c049387e75ff4268d2291df8026609669e6e689c1773653aacc9f332752309f656ef21c0be2cc18fbd87895052da3a9ba07fb523619d1d25d55f1729bce016156b821a31fef7ac44ffacda26ffdacc9ea61b610d28bac002343dce035384bc72d91c40230e6ef3da7f48f98be81062c173ab4ea51fc6dc58bc44373bee859f1d210ebd14e4635598e45099dbfadfcf9e0dac0e77db30ed09675a043d1ba5bde268d0395066f392201b67afac71661d736688201e8dd3378961c9ad0771a0820411d2b96d203d696f351d33f1f802d4ce4bfffc7bfdb5153738f2739678a5e276f00ab92563ddbc3e39264391e448f17d8ee760701ba8b0dc4fcd35947db42554d4525b601dfcb5ce4328271f3e3acdb3ed0484cf49445d590b661386fd01524dbb0ba2ce6cf75f78c46c8b8ffb6a5755ada0151a37ffa840f0d2dcc084e8896e27570ca0cf6986f261a4665abd08be2dfd0401356363ad54390b59fd9e88c6d71c12b7b47d886cf9e44743906e4e22ccc82e24c743785aaf7b5b9f8b64c49b7fba66f7cfdc7e8081ebc2702f69c1d7d89b59f9ffe90213336b12ee4b3fed385df81eb7a4b3625ea912500cd3df3ffaed32b1e134e719d0e1641400c0e4e185eba08db9da4eb9313468211d4acc823f400e443ce7dbfcb4b7d8da3c1ebcc61bef846835b838fed01fc856095c37112c98a5de75648def88afed1b698d0a47d7e76e155ce018cb88f5fabcc9b4599f097a5d24dc201973025fad201fce94077b39feda08b898af36e9a7f774ff9a6b8157d31646e67812b15145202fdbc4856eb8060dd5c41c622cd9ffcf4a7c3a094ef7fa57a231b989b0e6d8368eb8a1f376efa8835a8f123c11b0742ec0768289c73f8f8dda109ea521e345d16782f907815dd3996cc9fd9deb9f2ebaa5651d0a08927d036e45d4de817ca889ace0a6ec62898849b09bec2cbd2af5aed09048f9a7a835c104281fdf5e700f1abdd7abc3cd2f0086e02fcb95a87ba9600db443c13c5728b9d51ca24dbc018f44c6346622012f491d42ab5770cb4791feca8159952c89021b5b2defe6749536a6a19b49969c1f508882a4a0a6454ededf836e8f2bc88d3abf139e79d243fd6a56c8e80be7531efe1ce1eb8fc248ba8f62a0fd62feac5134298ffb999fec0f8c93a45dd2083f9d46b473838fc545436e37df9b092275fa5e8d12066ba6f535b2d350548675d8c1a9ea70c188e96e74d6d5ff8a3fb3c0117f39f5c8c63b6aa5235ec4cade288a8b52ae94137c54fe7ad02750a75b6c6c12b04b433fe0c23bafac35199d675337d368ffafbec8c7208a37fbbd32deb40e2874babc96f11b1b1b9b70baba0ee12e6dc1f9e65a01d2301f9c536b2c3f8a211dccc09aa936db4538d074f70a39f5f5278525661b0b389af8630816e9c9cbe019f4726a9d6dbfd10b6682618e6eea263b007c542e96489b1b2e41820d9c26048591df003bddf9da775617a726f2625c1a7960d2542c5176b57ed60f785d87112a53285842794772f4dbade9df36277331db6e805000ad5073a0088c53f32e797b59d2b08c26de222c1b8b8ecd636c5e6e9d90e98b14c84c7f55289d9ba59c661b38f2a30316b1a767b2baafa1cfa9451163d91b5ad40b5a59e9dfd7e10f033dda6fb38e6bd5b42a641669269df2303633bca7ebd763a7f5b50729f1f472259a6f0bf88e168c8a2cb606715021296d48d0be11edf545177f106022a7cecdfc7d4ad0d89c0735d3523f1bb4a46f3bcaf4707e8118abee6ce19eb43f527bfc5a30b63f8f37926e040469a27e1684171f0134d0f7dc183c23faf3bcd55ce99b85d6f06d5d77f4453f2a24bae9b65a612881180b5649ea524cdc5a1c2d3ff8e7a4000cb3a4e6dafb676a0d7218473cd269c751636570b4d8a3a10b378c5c097a5ce6bfcd6b835c2c8fd446a53f3c3abe33a55671a14658045fc8b3469bebf01921e3c9382006192bfca0c98deffc4f0669e3b4fe888bdf111586cb0999c17098c0a910968a2befd9310c9798cbf18d2c703e00bfcc6fcbd6c74d83a589f70e4df40d1876f5c25d277ea6f338208e9a77d5f8c71ed8c39bdc5aa41af132f86cac87f2b0a7506c18a4c7279f57d65937384239b5046c94abce708372d754cd73493ff3a6bf1da00672bff6de51b30b6845592300f7c3682fe528b0e534d1e1aa88cf68e14067ba9f1ae598d33dfb0a0df441ce0babf681bd18ce93538336987364fea1a8a7d9f1669663d56218d165b23d86888b4aff09c934414a47df199494db1573416bfb8e36868276458bf78cf2266baa0dd97324da5efccab07a8b70c81842f70ca888995267be894ac906e96b8a403127982e3c1de72fef8b7febad137e71cc2716fc2bd2e319d74a150e8036558b8160677a4f166891ce9b01d9df25bc75ea545cf910d3ad62adc872d00ec14c2beb16fda1facdd500607b295a31ea5823a443911bef5eef31149b6821d9e968e81298d0f850141e39fab5f6a2c9e3cec3ef663a9b78dca5f517d7f80c18088f6b53f502aed8c931bde84208d736112ef336174948fcbb25fea17dee7d655f0bcf2e2abfe955923fdcc14369c8cbf63163b78775f2e21abc14bf4546981cc5d619caf2db0edc61516a319ea6f9ece3a6506ec1c505a1651a0b6fcd07972ac8ce15800eeaf6111edef71524c635fd0e0eafa2602946023cf779781d66843e2828f85a553aedefe2d71a62fa06292bda12e53bbba88bb0a8265be6bca7b2853925d20310b1a8527bc324b6df9193dbc729ac4e12f5e0d8913b76717c53c6ef4ca7fc4abd2ff13f9cd8a0bb40b77a20432d2c88d35ae14c64a7856150eb2cce62d0f8698acbbc82e15e68d7ac7b89455d251fa6d79875169a2a9f318c37bc5895a926f41b02d4a5652eca9a955084fd3df968be05908d0fca0b753d0477ba0fe3fd6698f0a9fecfef84836593e408095c24390245e722ebb5e04d6a1dafa9f8c5888bf0a9f0385bb8778ce1d84d104ff111ce661955c13dec8f68530a99c717102577390ddc2f1ffa8e12ffde7d2574d8fd39290d42638f996c9b010210b8495e6bf042633a0a42c72ca5261352c3f3e89d94c3bca7ae4862e8f0c9af2098072739b6e8aae393d0f3315f32a6a0ffc551236882c723dffdc5b95c9d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
