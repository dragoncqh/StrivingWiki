<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e4f8fb24a043c5c264efc9d26b328f287eb701a404ffb6ca01a5bed70b40a1643ab0791624881a56989e1c024a6b8871c331f6f09b8ae73fb6e57dda1faec73db041b5ce0a39552b9b48ab0342573f1a03a28f6ea66abaa1843a2ccedf40340412ef4f374ebbcbf0c51945225ca8249204d35bea222fadd78e282f5650cad9b6e851c68a1c339bd3d62375d6037290f50e524770a91aa009bcc3344eb736b7a454be3cb2b9102795e08e3659a426e33c6cf7dcd256efff2c9d9c337f0ba408047ccc94c04af944d76007aefc994ca970dcbe7f869137ea3784db1a9658decc88752406f8dd24eb562d0ab108e1704000a2832753afc47e6b52999d67d4573a5153bdfdfea7d5a2f32f2231d24d01f07a41f031e087711563392e790b3087b39b5da567957147b644fd268b686e5ba35ea39c91af2a954582d998e3aaa92edfab2dbbb5eb00e00afb213e8e2af2f96623e9f34dde042e389b7030546a7c9896c9d95f626a8b85830145379388d48283e2c64365c37dfa70810b72e1f634555f819f70a6bab9803e8fc64d64d7a37b152a6b679d6d808623e17b01afa78fd1105f095910bb94640f75790c7616ca955f078c8d7fe70612b321594244316140bb3185b660cd46c2f94179b6dfb582405b4b0491b5a6772909c9bf19cf9722b8bc5c3da566898b955d67522b697cbb31378a8521b4471d58526dc6533c6f3bd98fcb8008411cc53ffa68ed81223b7939f24ede4bfbfafbdd50125b71313302fa1e2f76e18162baa848dc343062afc0de9a2f73eabf3398ad60d62fb36b98f087080fa9b713c765b9b3a23738a890fc98f14fafd161f4029f9dcceed14c1df55fd13a11269fb980a5d7d06b75d6b348c169ea338fbfce5086a01233267323ed5d7991bde50a5d09b39143f0a77b483d886e165dad422e319e714f5be0875f1c3b6bb269c467a2684dc44085a61e2f8a10911b641e2a6ac8b42fd9436cfceead155b500cf49148b4ed95c72f86010abdef12adbd1c69008ae2ba17c51a06f893e89f0fb0ee56ce84f85df5f6b1e852132dd9be15ccd435c7806e8c7773e26227983a5e26ef0ab3d88ab6778463c6ffb04f28961d9032e78e17307699039f4795c1379418ef9a92dfc15b1084aef896334e53cda685a38cd7b6873b7ee371eaa7bef5fe0f523a5cf95d61c1145392ed20b3d3925120b68aa780d639a1dc23ccea03ebe0976d44c33ae5fee1077efd1c9a054b7331277477924a8f17b6b89e5772c86057dfa264a567f7cc6eccfad66288eb0e780b8c36f154731f0c994448b4943e5045ff4cfab51f20aafe79525c1ddcac8a3ebfb89528c76d7f36ba6a6a97f14cc7ce1139d341874eba3c67b51c8cf89a469c1b099bb75defb120477a968058c1151052b627dcff5e73c9ac1079b46e10c8bb87215a2bbf3ab7446c11d090082ba4eb9ca1e5a3af9b4a3fc5ad1731b11f90f09aada306957065ba47d35b6bc63ed40533a0a3c38e371880c1fdc8f1d95b9f3a7aa3fafb54a2d657a6fcb678b97259afbfc6ca2cd71f45b6a8ca2cb1af6b71caa5d47a2fb7c8df93d368888c2a1f5d7eb91072ce50742f58761beb79685fd97c23c5753e11fa0a34197c01bf70d2fa52017257746fee0aa848dc24891612d0a3b703fa3540322b77b912b8141812014fde7e88face91ca97022822e01a7e63deebd0b4d650512847ceda1f2818421778e04fd4b730f809856e68d8482add08e341244573399290073d777b0cf45cbe2377fb92e4ed2d2fdb95686abc9fa58947120b25919a04c4bc5d0e7e734601f74aa95313d8e74c87e6e87993773d0b7f6b3dbbede7816f4cd5ccec769b7aaa12a0bffbcc61a668758e9dcca7ef34f934eeb27ae9386674e1f2c240be9b2d9e8304df8cb6b5e8170bb8a56d588f082c137071808bb030d101b6b4455667eed9dfe79328deb8b0ae5ba026820c630b22b7a3c7a0c2f93c0c01b4bd36407d922d52f8e35417c3097b45478a984f445583b88f7fc766a79d332f981b60c84917afcf2b3c6ff558e2edaa1d08ef792419b5cb4e38e5fa1521e43f007c2657fcf0cdf8dd466584a11035cec034bdd34903b62f58fe8dedbea9c7810ccebb2a20f2db49106e61f9962e3512113791cda32e6499f81c35c223bd1d12311fd3687d3a88fc138a691fe1d74cc5dc0b89bf8a0e78769ce7c054c01bb63f10f376e29741816ba7baa2b3da04f1873824b194b187afe33bda77c9b989fe73ecee543ca1f0abcf489991d7597e2df442c322a6d4e7710fdc0110b06372cf778375da0f1159e22826b9588ec435b537f10d8d066e68ea95ada8db7917ff7f8cf14b497edf8e695e8618621338f02911851464473c1453f94c6d6bc09d745a65b4b52653925adb84c3530d9bc00f15df86a48a64b195c461fed3f41018a602e2a6e4e9b851ef49aa99fda8ceeaf2569a707f9d54f5f722f408a7a21c2b426749ee7153fcf3bdc531b199a0ffb3eb0c80704ccf3b0fc47487e7b11f9d929c7f7ca2f153280ecea7a315d69340c13cf6c7b8338768031d233203e2fa6ec258839a4cac849e6680b4f17d175ae645b0783ccff3a1e2f7756bbd74bca95e0a38252e11dead750f5bd2c08da4e8710b26909fe4d06bfe00387da68101fa4746762d1f6cd661408159c92472eac50cd25bbd22345640d319bf6b5633ee2cabda5b14f55385b129a13ec2f6293d8d3ba77bd6f371b2db7b6cff69a3f8df1c92b31e6ab753c115aa2b09721076e5270b44c45d82fef83e956a869ab312fd6d2bb775ece634209be1e29f14b43813accf1e21aff2486e32990406eba9e66cea3e35902aaf8d27a68c87aba07a4c49ca5b32afc3c93d5cd526f6305cef07c018e5941893753b0d82bcc76afbf391fe6b7301e4985f6e9bd1edb5be162092b6f2ee802fa31ad60233bc1471f6b98bf85caa65e5016107978182785ec1e7a526a4046f0bca6afe752ca300dbdabb7892a93db6308b2f24e54b8169f5dbb2590a9e2726359d6cd21a47c5d16ae066eb0e2aad563d3e53f26064069d846b7c9c820114d1adf1e374db14c58c7e9d2027edfbdcbbfe8fd4ac59370e5440087307deb91c878c01f406c529352076dd6b0a45616371c653e0486e046b845ee39eb68fffac76a4e2b333b7d360e694a3231badef68ee781af2bd391cb0fc6e2800fc9966bf7cc88fc6314df08dfc3428797752328105dec7e25ffbbb14b01e96e80448a7eca79206237ce52caacad9426c6d0b21d9ab32d29c7eb351d4347d019d946eb098281f835c7ea202d9c264eaa716283959798b3c5122660cb7df616777857f7877a4eb93c409cbebc2c6b475b5ba2e5e348a77a1f95c358b335b1300cfe91189128d7f041655cbafedcf0e0e4e29202e50614782117f9c2290c5a8718e9a1bf6c3f01aef0837bbd3fa2d3298238f6d24fce8cf03fbe759f71460bf87b67a224a0800635d233e9bd5e122be574d4475d006ef2c3058d90db952870995e18f5d25d6899bd4f359d61bb5df92e4460548eefdc23272f1873330fe074a6451d66d309f68acbd4feb320bb24087ef968cbd2d181eea4d9bba2096ed6b2ff20ff45f9e12a160d66a28d7acbdf02438555fa510895621da3c7c1892fdafbd98c785180f55514eaa7aa4a8af66ac1fc359335217550e1f596591ded120444f3b4fd3b137976896092815493e275e9b595bf4afbe17671dfdbe82bd7140521a6f1cf3921ffd5bb63f1ebdc93eddf60bb0f446b72bc057886280a6fc192b7533b024970bd4952165efc67633556c5eea7021380f3034c9fc117fb71d346105df058af8aebca323e4f74f95b2dac6a34c0d53c183c8ba9fb2fbbb0aa642f912769b49a1c545c92c91fb1bd4c236bc98f4bb52611937bcf84e5fab0c7b30a664a772528c9597baa7a9c3f3ea0f7f6deab385e1c3de60db28f4bf17ad803a6d7147f3739983d8a7522dc13ab8f5b1cc291f8c3fc45fa8377d7b10bdcc55350d3b1a40f253b5e317aa1c367361e35cf1537a9d9fe4187449c13a57bc82c1f90391be6194a47ad6b7184f887c22702cc00606b78bf4df292e32a6eb6a8010278c20c527f73ec547524fa460d369f5731c4965d2eb41b30bc58408c980744e97af972619023a360383f557e47bd0a5686efa8a1d8b9c983a99b0d01fe50a89d8c6048ae40742c1331d89d67b4d5ed2b268f7244091868fed1abed04c78fcb08b1f1d11a3797179d390e7360d0e5ac1a42ec63347d1b7fbf6b75bab4b84ec12e6ea9b5f669d3dbcac6c6815d1cb873d92c3e4d2f8c067e7385644a252d61acd31288644f95c23f94545cf0aef82ba08afe6a77f7d203888ebfc3279c50e887783548425e07dbac9de31e91c0cb9d8516e4b4e0ce8fc81e7b92335c8f6e6ceef93a2cdbfc17b28724942a136739bfc5067f36e0ba16f53e27082d2c02b146d0ecb98d3e8c10ebaa3fdb7a2839de6d1b746ab1cb5adca95d04800669e94aa004139ff2477d3ee26684637f7bd75b6de341e732eba005630e714380119220c8dbd96cfe1318f5571629344711f3f1530cb1306d8db20e8e6b58d5dbbab8b515d7b5ee922abe108efdc2d0c4d8b062961ca097f1802be7b5a5bdfca80e0f80e2316f79736cae19e7c384fc841e01dca02aa94837f9fed13fc820642ed2a2a1c3f99f8191c12f53fd0558c829cfd089470331fbc8be040b338e090c37829a885a36bbb65aee8efa241084f1377d1346f22cb9043fad4b28c9dbdd787ddb4b9cf19a7e75725f0ac4fa5e8c93b5ccbe2251e0ec66a8132740bc2e1533156737c29057cdf31052f06c36f2426307cab846be569abc38e1f045a06a8d567466b54ac9c86faba1d8191753af5c05cb2693c78b83f6db81fcccf5ef4eacc2659d50ffe02d00811e69b764397e18ca1f2bacae0487a95cad9a4c55a9c05f11c42548280c7e3f4f5770853f7ca57fac989b136989d4a06d1c57b2376a4fb2fdd9f2c9449c81cec0400c5338f519c0b856027a89020ef2a273033321b84d60d89395c3e77c33ff31b1cb75aa605810dbb49596ca7d98fce0151d4bd4d62b7e93511b6e04218bfe9426289199c3e681b62da7a542a8055fcf64a7816b9f30c26c844cd798c09bc8dfe6f722ff29335cc9179742a34360bbcbaaac3099682f9528e6a120718394bde9fe596b6168dbb6199cff33074a244710759a51509ad8ec9e42c752848087c2b197ef2a66bcec953376495853830cb3d9500c8f10b197a8ec18b7b12dcfdc72c37e45e447058d3caa09d8c2c891b96df36c6a83df596351f23f244b89645652ef67ee84f335468eae2d044b77dafa952f0909ed7d9ae1c241312b3cc823d3dc0869cbcb02830b301bdc09b23719fdc7779cdaf70d734e9e38dcc3003f67d1746082c227a3717734cc491830d6c2d9dd61b07f0a56e4aadc12dcf4ab27dbea452f31cc6c01a1ebb91f3705b5f93a1c94fed631f559a3804f24b1dc199ffaaf443f7add58a9f0ce0f3a7fad4a41d647cba204cf3fbce24ae307943c9508c35b8a9df0a8e0fb0b1c661667a99a5e3461785867bea8caefeffd8ecaa1cd4e505321d52758cff6a2bd94c3aef34ce5d493ba65f7badc6065eebe0c2e91e4e440ae35e8e47af266c7d25b7158a8df38b1541ce1ae2005486bcd2de880b6082e3447d25a1b8ea27bdaf6690aef9cfe10af04bfebe7d8c1318c47cbe3fe47e2823c440748da4086aaa19b06b33f0030ebda5b87d67aa29a5c9b25acc8f5c4a98d6a0e98194c07c6f8b8508b6f131b54e419d362a6a09f8ea754e3880582d68647736827665a8eb443c55525a04911d9efc0ae761b152c6c69fb6f4e3574f4097deee2f83e3d1d97d72f937f0c795664fc41fd57a5c70bd1c0019465c49512641a80402dc4de0433631b14adc80003067c4caba04f50e30c84fe339751912e88e37dae8eae67b727a68c1ed06aee36a152fb7656eab61ff7996e36a43a1afbc981d03eb1149d6d2376d98c2471a78cf033d193b037b17b13e5dd2f6130aa6af0103990e59678767c0b746dd9a5e5dd78143ea1638fcb7afbb72ab025e7acc69d660beea2e15816d127bae154678d4b3243f131bdcd54d8cc1f30264a42ffacd132b63438d849bf4e6282865cbe0bbdff0c83ed589be6d8f970ea939b3fa73f064344cce84a7c582b39f5013de19a9e371143535eb742fe305a0e3512cade7e1b673cc95060f073bbd1cb07a6b6718dff41272668c081ae3dc60323943c29141f9c869a1e8bf62dcf867c172b453fb26d051f47611b3b933b4325636b18a702344875cdb607f5d4651e58e2ebb3d1829e378d20aabad0ed511c3c25998b02107f963febd7036c21fe82bb93c235b20be2f2463e73a32aaceb236b5e8ad81132137aad36d37cb3de62bb2ed5b6647f9cbe1da580308158e7477fd638f251579c79a0c7978e0a765aec71fa4935a9ef9169a605501879d115c8246df13f489e59e71847b82669dbadbf31c6790ee1a57739207dd81d5a38f1977e8b8355e502e6467b83cd2dbef94fcbdd58da074852cd716a88ce83668c14644373e2aec87c44302b66a8ea52053b86a3f8b0bb628a54d2eb10698900764f4cc2de07e4c6e42d4afeb4f74b2a3fdeaaa895e9cc0ff81afa1965e90c7b2921233179ba0ca64025b9a12b6b72997733785cfdc765da804d061a20d8f7ea4cd94bf6d40dd6f981f175cdf029bd0e9d7e7cd0d33634612effe8d00b99e27928703373e84dc8a02e731f369c0b160c5953881594e8416b6155b214bacc0ad80574927f1d71823117a5b29a3c66b8ead43b053c16971b58b592f75683dffd4234940642e051a2e685e04309e77662cd41f759e5434063fd2e04da77c5497b4dc9f3c32a58eda5bfd253dd4c5e5261ff0e95030b5427327a3b997eb08e922859063ff9d435b1c640036b959faffd23c8ea5f3d8643beb67a9080f1296d9f82552165039b2cd751e023ce0b37914414d883f1a405b01f0bacd89fdd0333e3474b25618ca1c4d4f669a42bfa88452e43de8694b9b1bbc9cc9121b7cf27181f79656ab2c1b49a29f680f8a0bb35414178917c30e8f2edd993e56d9ee8d5a3cb2cf3c346f8de118aaa24657e229a94f2804a572b9f0dd0e606fe75ef92603d4e51cabd2e9fd0c78af2874bb8d60b4ae53ab65f176d0e347e22537618d553849cd119cdd1444bb7973f44dc8484bd39a4d96d0bbcf7bf3cad9c0d79ac61935932f99f7a00258f5e86c2c510b582966ddf7c6972b945367c97426b0631a77986a1d1e537dec3496a70544b17ab0810ecd873388b19e349204320d550fdd953b4266e62f2ed27c3ff5f485304cdd7d051d46bc47d51c79e1558dfc9f136e0d3c2be262222be45a5c2d4be72d6df1f3fa397c421d29e55085960605c620dbf39c41679e161e2cf5fee54db4d69ce6e0f731f5f43cc0e421dc301e1aee8e3995c38cced1b530e65856b0316b6ff77d21212d5769d8f675076294f294bd327ac240946196d650fbc59bfbb8e6381e739b997567427cfb6dc24fc89463d3ee9eadd3c3f38dab4e15c011f7de47ce9790ba4bae5358c97fd244641d17fd025ffba740d6bebfff656c5b331bde60030e879ec917d03f2d6ea867bfc7d312e194a5b31d58b6dcc551d5da35d53b71bd15675b912728b2a7f0c86ad8821c8292beaa50c0c9d8f588c727001ebbdc50369daad9c67c03bfa1d7256eb20889dd35afdc5ffa9dae0b940308f28bdf389b0566e3782f0dc4d55f32f5693c53bfe5fa6c5071dbfaa97cda650ee1a3e657328a2425c77be33b26ece7d1766ff5caf990a09094733e91c40a882626a402eee799725e8576cb6a6982e39bddf97d01ef8ddd343a8baba2b8c7ccc74892b9911e8a3ed862b4f7348d2aa0024287c5cf159d68cfecec36b3ca2061060c9d17ae2133c3a0453a335d0004ecee1cf68fe5a6111facc1affd4403dc2e0fc8e26a4b330848d83d40b6220490d4d578eff2eb7c3a20c469c59e2fc16e08e89851880faaa7bcfb545a43d37dc2cb4c6408329d3c39c0f940ca86e38c1cdb3baf941199939002bf42db433b6400fabfe4b6ff43360bb7405a21d92f69a74cbcda1c8ce19f4a7e2565f73d13d36ee62a690d232830e8c2ee9989a612a82cc737c25ecf9f9c303280978e02135991c1fe2c297dc131d9ece4098309d6b2528164cd1bcff252e06c24e36e23848696cc17b0508ebedef6d590290ea1b793874d7df4e3311c69796736bb3a2193d13c04fd90d86128a90f59a01a3021cee239f377491bf4b8dcdc8071dea740ac9d529da25bbc11e3d465f521d12c6345c859383c60dd409739ab1ab8488917f4e4763581ae02f0a262fb72791c9c9fe1799aa37e60475ec9cf9f0562397192ea6cb2c800b8e735184fdfcad98d6e485c684a88bec9c6f1cbc927d8a1cf3a22f1501a24b7db290f1806d8e9055351d3e1648b47e191d5f1c1370631f1ba6a5e51607a17d443c8099103c70ae6aa78593d5ef06e3389c46d4241d841e231b976f5cf6f57b433dd05bebcb880d2a3fa03f99caec410caa6a688ece158181968059c23bb9735264878b5257c44bf30a0e340b86f8cb337b810dbaeeaed1a0811865d15159f8dfca418904ad186da6d85c0eedb23a9a9ce586e5b9732896f5273235821c797bdb418e69e5bf630e432aac91aaee645421acf685cba3d8299460f75d996248723c4d69e318aa6f5d71c0a65759c0538bd7c238ce2e3298e9f17febb2f854ca4bdd770ec758f7882765bca766f4d1abf954760de79e8b26fe69a52f171202a547d982b3ab6f9179036e2b2dd646e49a0804d0df07c77938f37a063d75da4f4e7397283da796890e51714c69d05c2615a9d99eb162f7af070e84b1f5d41741715fa2cb7a68dcb3bc6732f83ad38c55f2c8e0366782b921944b80c2918d426e3400b8e8fe668fad85153fdabadc392a2542f37a8b973a7ab3dc5d1cfc3a1e006028580546e31e898adbbbb37b0da162b5e55e494168752c0d95b28c423ddd32899f87c82ffa0fadf9ae8fd1edf4c7f98a9aa4954c0bc788dd5ae60b50391b888d36ecc12d31dca5a7086d150aac60fd38d6ced05f5351149927e7ff510e7858cb7c68f44f0eb0d5386a95cd7eb6a3a69bf76f40cf3d7eff5b11e5631dc302c8c5d6b2f3fbafd9fd283ea6e5892c61d8a871c7487a3807dbd2bec857178c0b1b3df0a2a90bc3ee8f5b0e75d90be37b571ae2a522b92d39ce6c907c59e994228f65e1d16aaaa129cc5362efe53009ae5cc0dbf66880349b4fd7cb63da7c04e8044cde63864ab9f1423f0d4689d364488a2046d0754fb619133f95a9ea208f67b60df50f354bd421f2a973300ca8d7f480b229724cb79ad14b78cd1cf0200386504eb567bca58056635ad15c15dc0a1053c609def0f44ebc76502d4c4d7ebc539441d7396b027a2a25cc18f6f0e397109b7780280b60ceb20ab728b528afb0de5f481b96ba6712298a8ddfb8f9b08578ffc69ba48a39da5e42ccd8f87ee04cc7824d761a3cf4220c23a2d77d7d8718fdae47c4bd9d8bf3df7dcf9c1a3100bf2ddcc033e65c71601bdff91e4d1755eee3230c6ed39e6bfed58463ac30d692f54b2021a03467195048013f2f87eacc90b75f191ae9ab68d4f1b74dd42c42dfb762df377a3d4c1cf04cd8d44892084970ecb399c1957c4f07710969bd7cf4dae5b2b99d1a42595cf4a19d35ea2b9e1303284207ba984141c2bb7f7cf837a3bf922846f971a1dc867b2c7c4732de0a3f616a7fbcae1407982ec9ced25920648bb4bb2e9915e7d5d852eac4b9c5fd2f9f1955bec226ea9a47eecb582935168c43d3e0dc9a3b97eafb2485ff36ee7991d3d58bc65775e625b30c31ad68face67fa75abb8597cd7fd983c6a9a4cb5469313a60ab68e74feb31d1f10b0dcf2c81cd339dce1c3703065ab091bb1f8d685e230eecc5d31a748fc2d4a7b81b9519a978797198857e8a5c81d63a05d87b0f478244c37f6c97683bb41d3d23962983dcca115098687350aa5e28ad805d3d5f2a82dfd053eb73e9acff72f2309cabd054d67e1a93d0c4350892b16f80d58a738513445cf03348ab9bb149595f65db5a2ff29447b5f7ce0b765cc7a757f9d3e7435b9c42a3c803b94a6010ccd0d88525774906bf3cb79ee7f71029a028906c206b2b2c060dc00648c69e7b64db501b9f71c54898dfa3b3e31b63b4f4a24328227511d531743e7a32394186ac72a0f4db2ca3a220c53e8ada54394714cb5684098dbdffe6e015a35fc132c2e9ae80d65d70f9989de239c11b549f1ea26530b22f940b4d5153d5c95961849038b714cd98fd6a0c8f58e44a99bc195544cef824898251135360c321cd005f9b23cfe46ff4a262623bdae70c8204a78a12bd896226dcbc7b17cdbdca753f60f49691160ac44b58968a662b1c3e026e580cfa535490eabc263ead715b30ae772b5d7df773de6eb14a30422dcf47e5b240d08f647da89f42d2d1abb91dff26c36b6217c472f978239b690c7dd70862aada361994f5e2b93977696a92a5e7e8dc0277280dbf4ed735a60cb69f46fb1d82fe1bb857df8741b8858385159d36ed506939f9f59e595a8866b476fb8960ec6900b27d12e1420beeb3fcbd0e7251b6d18df533ebe1465cee6e399b4cd51183e3a390edd44dee14e8791d8da6d2b1765cc27d9348a31d594b6d21c2aaec9e0398a848244c2c8746030a5b62428e31ebc9840dbc71e2d0b123c1a534576b82af0b510ed5d30d9916ad9b274f77dbd594a91f51811baf5d7934529192f557f4ffad0daba8224216522b00b57a20914b89191b90e9143e20e5849d4f114aaa72d7ac157a02f6de0307f8b6c635b4416ea5161ad301d8b914f769f290c12f7e9d72b6dbf3f7da45b0b55638abe54aa7b68650940346992b8d74b79222d98fd930397c6f8a3c5113a70675ff319b3384ddcd5e4900248611e0c5cdf1539343ac9699c651a87497e5faffafcd183867e67d3d84eced4e7b06ad617f92b97b48a65b77389c3e0f1ace2716a535319a8cc178bb2ddd7432d87143143eb602f9a0ea97c4dd364b7b67749deb170d149432c438dfe23a959f859352a86f9bb4e53c64e922761e2de1edc0b114244c37b39424626e991916c1af3e6bfbfe226bb5062c439bd9504d4032e78c4f3bdf8c6c32dc2ac5183d3c74780e75b4a334c66c206ee35787e616bd6d0112d381a9ac5300941fc46d3886e9451713ea154f7c4a6203d2de132575d2b57d2ad4b3975cb9c33ef5624e1049e446eb7967b9c663ce746f2c9d842bedc4a988ed388a11a96007c6f5a3947981981d8568503906ef3c5f0aacdedae25128fe94b11aa52371949c6b52bbf2a0cdee0e0312c0cb86fddb53f09c03b60cb8b1eea02c97fc4c61caba0aaa15e3dbd8da6af5fbc678a6de0569ad3126cb4f6f7ab221f351f8d82d9780263750dc98da4f0f3abb0aad4852767c9ec799c1ffb63512ea250daaf58f234feea8e2e8962cf86bc7cd712b96bfeac7de2202e327e93f152a4815b4f2e34506562fb1112e28cae2ca91760571019520b5226a8b6141f3b5ca0b978c9f94117d805139cd6b4faf28dd12e1150d9383f6ababb1e58d387d78f260bfce50a2107d83dbd8973a1c4b494d3fce48b003ac0261d55ad4b286d7d53f80d7496ea11e0a087b728a725d27cea22fb5d306fcaa010a98800dc09a696ed9f591b46c8c2c12fc9c71c48fdccf08f55287eabba78c871ccf8d289d7681937b5d985edb558ca57487ed47981ac175d5e78a317d9ce566099ba4bca3459d74b24600309e8c70b1fb3955af8505642f9a9728472108d7f65e775da652884ca8062fbb42bc4e40e1865d1806c627c4a252f2146eb88136a7a98f1e208ff6760fb6175de169be043bdf702a077e4e5690551a5d13555fadc6915d441ed0ab919470459b1d6e10bb4e72c61515d8e780aa151ecf022784a05c70d9e260048764efa583c8d3b022259d80f620a53b31e276b660b5cf328f692cd04f69f2e86547d9e54fbc286e1c2aa46c263bd103de997b9ee245c5e1db6f5c2a499d4e386f43635abbf0e4c3b9b2c3858213810fbac7a2e9b99569fe0a7655d0ca2ddd4ecf059e121fa83690987e9c32d6da4c9ccf8d79aeff0d9e0a27198a287f6f538331e914538732af169ffc2f02ff425d900e36a5faa8ab22defb67759202dc5b14f68bc17047e1c9e926d3580b4e234fe2677adc8ac08ee22f4a0d82e609b755c67bcaeb8b57490699a890d5bf7dce5820d06bad552bff41de627e3c54ee42f4189f5e9ca80f0e13ca81240f2b8ce5ca7d82cab24ead72c961a976c33ab3b39578e6798ed6d755959dc3f79e697578affab4bd4ce7d3c359a0f3ec0b3d71ba72beb0b37d546a45f8e1af17dd5456053974f3fa6de44167b68fbab281a474f2f55eafdf1b7228820c69ff16481e67272ed3d3322c0c99ed41abc0651bdb17168b2e6dff692ddd5bc27b560ae83a4324f42b5c204dd2113c0af0b7edebbef7eef416c28ff36f32d775c3f25fb023be10d016ce9bf0828948566a333e7cdfdc80633b7c27e41faad51e72a3306ede7a6a9dca953bc59f79f130539329969ce241f1f3ca77de41cf16ef71e4ffbd10adcfb446ef9c987887a70bcdeff259fa61d41061c2bc737e48ad960fb8ae46b564b8ecad89e9b89d7dc647d6a6533b82d2c9a0f2b1306cb2970d10d71277290913aa87985c093185e3e3656837831771515c9332d5c034c493ae23072ebad42430bdf3af58afdd09becf7fc77e055b89e0d488a57ae75a31f4cf9426e61a82c7e8e1ec81baae6823fadeac4451512d9afc9831cfdd7166fa63794d3646c790ba6ff9bb22b4cfa7048888a0702db6dfb561eaba31bc19853f6f934712169aca6f466b9c2c9c532f76cd02e12ea7015609ba2f071aef71a5b12383588867264b34ad5f8f1cea9ee31488d1ed96cd23b19dd87e663b71b4e3dc67a3176a3dc54d80980d0ecb3ce21e1a9e65f048f1f7473be1bd74d78cb2db95feb0f964c48638b107016da08e88999a0bcea132f6cb5ad20ece63908cc86beec7da631648d6d977275a2d746bf4162e47aaba95e1e02271500ec6b0829d7cfac9cb322516ec6ee8a9081beff6390019f0de9af5b739d2d765c52530e346f6406b3e524ebac11c520e2f0af023d51485e92e8ca4dfe0a1080c7e17e4bc63907d9c0e7fb0bbf8ba4ac3a28d592d64137320c2b23d86bd280a8c4cc74e52ac6eccf7a1299c0334c4bca40ef84769f322ea643dc15850d29a83f780bdf3e25c483250503f05453bb249ac1f3e3063c26ca29ca3aa7d3ebf5720e354aa676cc3bdbcab82e1c3ddec96cf75c0c472c483198da2ac077f4f29fdf68b43d6e8c55ead73229382258e768fd819ebff2942177894952bd4829012d44b704db0da55c29ab205fd48e1203441f5f51e83d1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
