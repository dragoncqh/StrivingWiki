<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"27fca0e7892f8b66e886db5ea85c358de0dda1378398ac9142be4bf5e1fa160a0be0c18de690f853cd1baa7ffbeb2ff67a0f37326826abd352b42053c8f2e573325e4c1dd6962f98cfec92ab2b426ece0d50a67a7acad9b5ad4c863970af09885e644ceeb2670bb49e66104ce0a4e85cec0846c35aea8f0f8687549a96295f038f73c79011f91e809dc428859887f765dcd99c5b1219430c2e5b0c0a72e7bf90199e93632b8368e151a97b875ae8db2772d9ea0076ba5b1e0c68cdf2275012895990f995b168828471d9cb1055a893c6d20517024e21856cfeb3bf0fa2fbbf240ddaefd4c28790141040f4522ba1d368abf21b1c3c199b7ffb54b62113253f238f1ead4cb97c98b6854bc47725bd2a92f6f9552f1f62e6915aeea1b762e17d4c9d0ecdd2fa22a0bc40651bf783a99228d192e3c36b9d32c7a3f05e1314ab71d89b982ebf70ff1a0f10742ad9ec4cc5e0b78e8f92adbeb30197f8443421dc4d140b35ee458e639d982df3bceb758a80a34109ad55f8f965a99ab5ba9e9561ac7bb65650b780a813a7b332675f90745ee0d5f8afa53e664a1d7ba48276a2d863bc4f925d603fa94e68965c6f8ece34a957270bd0be68f61b1ed8f8dd27a203116c2cd70c1a365bf573fb619f31c0090c56ddfcc5fd17d99fbf35cde8d710634a5691f969b163126b49d593e0fb66ec8bcee8a617f885592fb3a574109db658be356201af1affedf6e483179c6ea430bb7db580943de6c1ef317748b43658d103ecb1ead58fc89062228fec3c4abd6caff83f122ea9cd62e42110694457d02a25ecfd8716b542edc7f0cbbfccd3e305048257287416c35e32db7ceb23425297cbeeb0d0f9bc34718a2776496c11f44682cf121e965eaf53718f21ec5cb7fbd9c3d9083b3e614fbdc0e936e0cde261e6975d034712bd1eda19bc9fd26f54277cde71054f53547e7d47bedcdc46111952f5157f0cb980a288bca447d84ac204658a0a57bd4e7e8c26743192534477612de03111568408e53fc4e41cbf44b163c250ac8861ff1616688dbdd7479907c901dc3263979e87c9f6e40fbc6f0f8872a76eb9b9a404a6881acb80286dc00fd1f17553c80bc1a66cff4fdf0e5637f6406ee032607acbc6b0e5c974ee3fe820fbe988f19602c2bf86e1abb3982d357e4bb3f80908a49d157667c8c8d3ffe93d8a5a3fc8cd80d24c647abd67d8986716fc523556084ab8eb871d197a2afa33f4544e3b25550f2edce02eb8a7f15e4d84b31b40baec7ef2265a38dd27764ee6616234cc37bb38c405b0a47156496141fb058e423d220e9c0a80f3f417dd0809c0ad9eab0c9e83f51d3217f688826bea4b06012ad30f9a661f57eac8355d83a10a3d10d409ac8761867a21b8a4648dc4da1e0685b4f4074e4780f67e1a2826e76865abf599d0bb6fe2b01607f51c0b476b6f9498fea278d6e2de6476ef81f2bce9dadd496d4e3f2fa62e24b9406c2e987b5f7132596636a590de715f90b75426afe595916acda8cceffa4943809e8daee4459b9fae326985ffd68b415c70c84c40954a5cb1b7c65eb19c3b819df181ee38590a498ce41c450b395e4df779bcdd4c7cb1da633f70389b808f263325fe0e9a8804c7ddfd53a78b8b90eb66578afd23ceda0d61da721bc0d50858a5fe18e8409c9d614eb8cb394cdee25add1ca42e3b1c9d15223ae24c09d879d8c2c9eb533fd8dfb9f34d65fb7c1db46f82798bc9b7d572265dafde2db12987b4c38a672d317f6d8c24ff814ca5571622e2e1cb7a7635cbb7fc60a8e8e92a418a0748b93d767e4093457a66cb696d542f67a31d04135e2d31bccb052286c2c677bdca881878a4b21fbbe4ccaa247091aa6ce9a185914a23093958ed74c7bc652511fcda8fcfd12e400527b6d23c8091991c266347489e4715b715218c0351172d832743ff21b69ebcc94bb24a4bc4742f52da88833f5446befe8bfa760a8f2a69dd9ab68755814ba3039ba7b8f8dfa6bcb0a425f8b08d9bd58d6df8183b3afae932d8b7c00a63621561821b9a48e0500c463168b6e0ba54ded124b275c380c133132c6fa0d78c5b9f9f90e1f8a965693d00991ff84cb31e668b186ef9227f0341b4d1ed1e63796f2eeaef8222b1dbcf813c94842f5ddd0b082418fa9c30874ddcca2bb127c51581810eb15b8c5ffe9e7917944eaf4bb06c7de659620c2ca0999d553eb217ec075457a9def70e19f817e74cb7df8c0e66a41a8bb8e7ee7f8c792cc915b3084fbe5b948b2314a0df33356c96c72e0e4484e975dc29cf8df886b88998e087ceb1e09deb2889e525e547ef7a022aacb6d6b97c4b53a4b9c2a2f79b2dadbf84d760854cb5e516275d49a712e3e34f0d49e8d0aff89b5bd6c52c9e48338815aab7ba6c119077c24a534cf1cf97c6bb0f885007ad44150a498e5d49b84be2834176852650757baafac8102b8383ec4ab6ff48397ca0128e23c67c98555650d06bdb8379621ea0f04fcc7561091413e76fbbecea65307cfbb82de09189a8d38e88a49576cb9b4ba0e70d035eb432bf1a301c84b7e62d1b6bc37ac020d62ff51c2e639363ff370afa69bcd9077e2c0c4add58f22d02ee6bcfc8d020a82ab9fa40028826d9cef7207f800af1efaf5bbd05049828f020523459433570bbb4c570e1c4d9c6dc5f7793a680cce1b4d6384e768f8306cdff6f5fab2dca1568832ab2bfb7680d62a6ce99a90e02ddd6b452d884839a2d156fd4395fe16e10b928bfe907f2818a7aee19a0357eb9759fd7e0b5510c2feecffad250bce59707197259bccebec8260ac1d2954e796ebf9d6b50e34cbc7e8668b42d093d0c69358e927fe041a6ddc9a48330777a24f4300b51516ac2d7d3027524527d01b72da5d9d7fe0635c624ea7f1274c1e82322d54badbdf8116f14ae413c8fa1f0ab5c89f708ef1d6f424a2b13aa07c800e46a3abdc18ae3a65cedc1035edc0d97231918499b73b45d4417491a828aa1172819f0018a9fb8ec23a4ed3bbc11010a07650594893e8923a92501d084af64d13bcf339ae088049c52614fab3015652c88da6e9c9493da6380207a023f1f7e6fa698210f31e7f6d34df0708134089ae65de9e92bd4d320848baf89723063216366aea668bd53496905b12d709933abdbdd2ebe7cb80b4f269532de26ecca787cc8c6f4d0846df45cc5481a6dcf22e9359f2a26f3dba6b0ad02f7f2c17fa009deee4d162d2be014a4bae60e8cbf2ef50d46a8dafd22fbc2875b7ec5675880f945b928ecafca1e7faa93f76a73ea22e6fc363e8a0113f963c8f0eed5cabf22b61a71b1da81ced78904bd04c2499ffba0b3b61dfac5b04f7e2b8fc4896c582368e7ec0cbb1fcacc0b8e96580deb3743236bc92a6dbf609789f2bbb3c1c0d767fa2355dbf6eb36b80a3d64d4f814c2223644954f1e1c22f523db618032d7399b29a95918ba0c10b4b94fdd1a23bcf60528072812b7d4b7b69a1bc65a28fbe745e659a010164cc68a9b601c6242422196fccbfb04e7ecfdc2da838150a3788321632af41378a73bcbbe6799fd1f07abc48d7e8aedd309e3fbfa7eafacee30428c265b0f06d789a410b80093ac921e3835d417a6981a7e5cfaed1954b64bc6c5f296922bd908049e10be71dd2df9a0464f5691fa4b2cdc6ac912abd5ce70d175265318a5e1a5942f5d5ee4245076a9870b6e034381a46bc49b619553540b8b7554a5a490087f5bd953752ffa5d881ff6a42e2e028579f6425d3c90d3d63d909d8cbf0db53718cdc6ac9005530f8f42177cd85ce8968a033c0f318a3e59b3905459eadc3b80bfd085d29995afb134f46a25df9f9fbe50abd1345eeac63d35460a0f83061acbcdcf2bcd8359d44ffbd87c62ec2adeba333244cdce1bd765180975be93d834d06c79e96d6ac596d77e4e994f5fa562846fa88305d1186a61a9d15b2546ad1c56384e86414b513e2f5259ff9b9ff2736abe98353d602216632a45af77d792501820a4088900191e07a985f44a309cf9dc4e817cc15b85c4f2ec2b13db9d81fbd031fe93e5a1cba93dc7fecd0278236b74c1b03fa1fc32bc02fbd19fbe7fac67e18ebb9316979849bec77afd2d289d65baf269a3120849922ad62556a62ede13cf0cc235794477db88cb65f46fad527229b22c9be7f374316d2fa16e80e5af325c8154a9b8115fc8a56d9417a1a7588cbce4d8e9ad51692559865afc1f11c9a8cb9ebd17e1c65450df65b73c119a384b4aaa43221e167bc50b1e6125aff125dce396502bd072ea531d9b3872f5ac0ce04c3f46027c80feee29a8ecaf5be936ef43851da6ba24b1808d92e459d757724ad93d668aa21dba7926353bc3dcb5437baa26c9279539b110ff48399597759dc0b1b95ac204a4475995ed60e5d582b612cb03a9bf6bc3df0f178185d64e07dc3cff503ced967b0188b4e8ffbedd688339804874848be110798a4b5212abc188157b4ff61b83b1f0bb6c69f4597814ff774266fadee8be2b04c53ff2f68b4c48377d86fc400f7b23cfa64351fbf9bd4aaa644ed1218a0f0716e32b1acb3e0802f6de0bc3204d7e796e643f0e3b0f29c67eba682144ccace989b1d090274b2c512879762b8a0a92ba61af1cdee290fed70149366394ea982ed6279775141e0d40f28ec333eb5b00a75f4dc5a2291c1be22d5643dafa769edc1cb556b68a917c3792154ed4e1f7a37acf6523da8cf6ef7b1eb1363114d9d6474202394ac5f310aa3cd225928661bcd908fa3c7a88863005f91b7bbcdfa8c911ce1085c27ecbaa086b4725455562cb2f2d3eff502388f8eee372adf23ce940a5dc3ec3f2a28ba68756eeed8c29d5f93e8257838aad849fce930a9043517865e5bf4795f1cb482158d2ed10a07f41a87b98b5ea93e670d2f07cc43c5f6098c77472235d6e35a56b6a682fad2c73125862fcd552684618202ef3f8e2ee83ab82f5aa457a83267bceb65c9deab521e20a98398323a4f9a223337d56f99989f8c742c59ae629e5f07ef9669242cc762dfa8c8b34d08316cb37b231f851dcbee7847a47cda0e483eb9921172aba032926070cb5fc4b6d903a7eba5a0e0a9d595b3fbb43c84fd46a4f504aba6333da63056a711327deabfa24dfaeb57fd5a326b499925415fd85d7be5fac8d790a8fcc7c53f2c7336027663a6ef4ae979d54b74341793ee1661db3b949b3eeb9bb1aee93074da5a6544c7da3cb509f006eac27bad5ec739454c017e7d2e7242eb93a8ee89713ad41f7b26d35cced5a4ce90e738eb2f8a61ba84622b3d5d06713ca6b0bf23c7f62384aba9ce8b0f40e5003332dbefaeb8a7a145312170f7ad36013ccf7b194950b9ea7dc41e0be024a9d668f30bb3d73cc498d491f3d63ab21659f84c495fd3356ffc266336716ea53c88c2997e47a84a73adf5eef1bddeb20819ee62671cabd99080d53ae66c20b54545a37511e473eb30a6e31cd1e0309eedc1d3a4b1dd0426f96adb04cc35bc24ab574713ffe85b738e466f91c00e1c47e313d0a4f78e813584b8173e13496fe0e665c226ab7d00e4f8d85e1b31b22e86ad6a4abd3c0608023c559358a459621e49f8293e03970f4e2336dd16c2ab55f9a009ba0325e132c16ff86f9e7106d054043ced8c265eeea92841583398df6a313567f8d0c235402aecdb0e0b7ecb9910999f2673c84e0448bf2529b80d9ecdd3f954031eb07baa9159f741974ed885ec1b243f94dd79f9e8897583812aed152c77aaf32d12d16d535a5307f7b8859e15b7df55148afd61d6a4ac32d49868b0d5eea1087331da56d8e474f92578e73aa2c26be84bd8355fca00a590fe1e1e5ffa1618945a32c6b78490c1cbb34af2f129041d0442c16a333a989fba60a87d63c46119df842dd4a3915117cec16d24e86cf921b9799cff6464f0027189cb17fadbd70bd53afca071baf6efc5a98df9d14ac672a35e3ee56e0b7e544db1bc7a68f42fe216961b7930fe50e14908246178d713c6f5ed648f5a45d511843135ad028853d0b81edb095bc2ce3e89cdfdd1e462f9acb5bf3f6d7c46d79a852eaffd9c5c5ce6d158556389b6775b85660296c4a0a6979ef300fe3b50063b1fee597cd7f3df1f344a6348e53c884cb43441befb4120dd2a4e0d4f6701c647ebf112f041dbcef75352dc469bb15fcec2b45c682b8e7962352532dbc0ec5d0354c3b845f494ee790efb5addb21ded8a8e15b7bdf60935ea5565c9d5cfff84be3abd8845b767a6935814577a7f3415f0532039ae7dea4ff1b5e2f42f9f369390c5aeef1767b1af8cc59f752bfad8c59488461426670ec717e900660670a3db4d880b985d308a4545d41f15baedcbf9cb204cde75787eb7149129a29fe3774df3b7fe7a354ddab8fa34099736319f2f91c1f7c1096b3fb4ad1853c1dd75e9f32a651490a66dfcb6f56e86ea861bc099f482e121e686fa50763c0bdbae882a56e661a0ade7e15a4dc26705e2852580082e928525c1778d77ec86ea7e5525d89eb059877be52439fe0b00edf97935aea9994b5fa76ea5db3fa2b960107560c29932eb8d3d120baed1ceb93a3708b2ea78850eff7398e69539281e12a8df8bd6c98f1207df04797a0141c6cb06e8e17aa33d5792f944766e5bc55e57bb29fcfe701e761b9913664df6334bee09c09f9051d12b775f7b60e3adad74d87f3bd030a6b2bc8295dfcca47f2b0e8078ec1f41759bc75914407a7e120417a22e68305ae09475dfb2582ad7810ec939d9a74c53af27a6b9b1c6ce9e020ba18654fcc3cc3201895024f0edfbf1401904c06606bc013c7af0c8c1624f6512a48936ba4dc67f47d3c964d4af79c6aee48eabfce2fccb44ae657131dd6c373518f6d795dd7579c596992e96e8b801f395c24166eb2604f4be3db258bb9725e4a6f703bca56a9e3153bc57a640e5ed4b0bae5d065bae3727f9f32d572631b6e012224b8e758f5af8b275b00edfe0476e7e32a917dfdb37ecc6b25cb524e81970e1fe07cc15ef6f98cc395f3d65e789931e07fe7b7df3213cd0388c6728d4989b06ddb6468f9a3f0c32966acac84f51016f7a81caef4a1f41a1bb2827e0e8cf293e1a47f81777d3dd3443e7b0e150fee2bc4fa9e1d2ec6013936da45ad4d9e4a23f409c9f84ca9137f3f019ca92057b64134f16e85059f5cb9c1d069297fcc1878698ca8dd4899c03c509f6d23efb2021fde338a6e906593db00e0a9a901428530c993a45592fbb4eb3a5b13cb2d91a683b7eba459d803c442131aa9db5e2631de86bf6f06a83aeb9df9ffd296685b0243a0a2176f881104cf58d7321f0cd26d734671057aec781e26ce0178b873a98832a22de484358c5ecdf7beafe221529f7109d4d0da807c01d736a466a4b7dba9a3a6eef5570273c05149e2fb088189239ce6c8a23fd751b7a3b571014937932ec8f3648608047bed3b041eb20eb6ddbac07b311fd1ba553c6d00852646b01d968362b1eb631372f833a889efca35d0780ff2980b56cbadb86805ddeed8981c4205243738e354cf7a25878c05cbc48bc3d7f63b121cc803d844eb292e1521013b50ce7b95b1faff3c49de6fa9700c3d46eb2f768790ec8c35f019d3e50f9524fa1ec45d55dcae90902a0859986fa49fe70b6228063dbd3bb58431aa442004c7ed53b1e2a142d93a220ada64110e8257b36ff9e45a380d19c4a682be6c7ffe933212af085d4666fb7c2d873deb1c5b2993e850881fd8f8b73d7cdab5bb9a47aad0433d1b09de2f28647c7fa562c845539cc9afc99c2192f133c5de180035dd948255da7bb7e3cb8b97cf0f75777018fa14d1c0d5917f855bccbe9d021a4603a07f9b2848ca70228226f3d0ed4ff22a56a590b752931dc0d763c1301a4b21974926dec59a4e8639e219039979fc93d7fab25c15aad1e01f33ec1b298e8ffe48cfb7d56ee8682ced1e4dca4c888c2aa39f6f5c67086a411ba371b4c66176452c30ef34df4b1071871a04ba750bca9af02d86a62440b1e8f60253c59d69ec6ab66df8821d3cbbfb281ca53205d9967336f57da6933a8dc49a0f5ceb7b4d5eb0a251d20d88e680b55e8b713eaf2f2e7aa3a18cacb1ed819c016e94574a0e90b1d7506672dd1a8cb7a0d36ff2f3d6de7b6089746b04f65b8222fe2e150708843e062adcf813ce23f1a5735c6d7246974fd352f3f432c572e03518bbea0de596edbfb06aa8f279cede4fd0aca59b4f8ad6474b2b0212bb6391997f852082145ab1f356b68250f32a5b8082afa17b2c4733416411855204d3356c35afd278b4605354ee48e5111e88413f26eb8027b3b0ac7ae1d372bb83fce6aec6f2f9c2dd926af85770c16732cba09f89b79d8a944d84731c8493f3d3be0f2308b65e09a0c4b231f176e243002e79c0135d47276715de95c5ea7f5561a5fba9788227d465c9a33542f7edd9be3991533869f3ff26ab476712d837ee985e789091ea275647df5c17cf6c690fdca9724c31c622300fd7be86634d9b839936a09590c67d615a6f862bce9f1c93d69287ef7011a0266fa6c174cbfef788209c5604e6a80ef308d386e22718190cb3080c55580d55dc75245ac3653f813734690451f5be0b6c08800770ce2d102e472c6c82679dbe0c2221ffa36b69ac472fee14c78853f1430e094f0f32e4b8bbc2dc2d5d1d5723da3074e12686e136d18a7bfb4a986218ca7504a22e66cf0f25ae9a7b86d7196dd84f2a30fd1e4fe796d6be895a2ad0da461dd9ed65fb3c7532f21ec07c0bd2f29bec3cbec0a2fc4c912cc14777a59183b9027954cfbfb48a905a4c86fcbfe5635bc8330783f3472b3e46b07685ed5cca45001fbcaec21e4f014a1642b3a26cc0eb542e5189c32c14f37709d242e62ef4b4f27814f3021bf41a59506087c8e776183fb880157e654f5f35d331721d3e3d723198d0e06311649be7561b255790fa868e89bddbd59c1e97493f37236d2274a4cd56d1c918607fec6027be144cd67c0642c2fc25e8960228e66377a47689541ec667387015fa46996d5c63db53805ad997fb059597197c78961ee3c76970b2be5550017998df8d4efa009a5b2860744aee0da40598816e05682626046641c9dc6d5854b04339dd9eada4d1968e4c34604b40e32d3fa7b08cfcc7400c04925525313e34d55f416efcdd27500c1e8e1df190e11b78946b49b518b29f6c2be3ccdd241b2eeaa479ddbc672b8c023a0cb15df3de1623f07d335c13bf36cd769a05e28368b7160b4324c9f3387585bab2ae76344645161e8d8736e54f945c61b1faa928ad9bd65a097517dfe563f983ea85f0125a03b732f4edc82eca3eb7701fe050365848f31c015d248b2b22365f36a6e5eb038563702ec1e71e9c1b48a292ac5b46ecf6913acd4376375f8b8fc14306b6acfdce7fc1c9f1f9ecb4c8598b21408d428268c402a9bef7db957854396e897c62786026355285bf3dc98dde29946a84a8033bc42bcbd9f96c25c71e4cc56fda8328951536f9c3d81841eed0b095383b0196eecb21016beea918229f5812ee8136fb07d8f003ec0597d19c8c1e03dad1518065621a16eddc9d84ed8e9c269c3b6cfb5c7e0a1e29d4e7467b04fd633589eb4fe4116a387718ba32cbe0f7892787271a25e36a4ed48be95c046a48edf9f9ec94b51b1ecc3b0036e61e0b3920a43bc74308f6d4a9b8f9153f26e5f004ce5e03a449b2eb832629a8f95839cf6e2a80d610aa7e08eb5998a79e0df6b7cf9b5d8d9fbef092770cce12196acfad77f7d1a6f9962e1e46345d5a38ff2ba6f5d6ef9327fe8483104abde4600ce730fa9889656a79fca6e961b9cb7a368267ee828912cb4b6075c98e045818c217418045675683cbea198fb560343c2a7a649b3cc056e0c45c68a9305847e7f74d0960671fd8e2997ac3f72cf4709ca2c573c58a12cd43abdb3f4c1f7e03e44123b7fbb0e43bc484052fbf000b2f9a0a718f3090b8a399df9f101174a6badd3ad8439233c78e77e0201dfcbc22670f61be8bcc84b4591214f52b7ff3fde951524b34ba21319c266c33634c2dd5fb49c7eea2d0348ec946a636856e2dd76f37d40eafe79966cc59cdaba670be7f60ca8936ed773d6e1c51880b0408d5a8965807c2fbd32e5000ca8363dd175d70604b08685c425e4ec7cbbbc2352e701e6ada40f8bca3720a777d1de23d030c31605a10fb460012a9d59208be5314eadb7cb0b1f230b1cf3f7749e716a13ff16020151d468bace9c2c063fc6858931dd846c5e9329a13475b23e03828d9170e7b49164b248571a7f4bcee43c54f096acb3ffc360f15d9ff73aab094efde6d8501a7908c5a70667c2d429b6ec8bde5d00347d593fab8f4db579145d5f20ed7fbd2b76da782177b54da632f2e21bd25566f46c66f3e5ae79c2d84185a03c014f56ca59dbe5232b58b46956befe086608bd0485143e7b2a9270539ad0862b7f348a6fbd4fee97b02f4ae7f9a4ee2dc79a968745349f5f30dc85ee524506863470643efb84d38238223c9a6d67995848fa1964d4c91fb578c3bfc32c2b21cab95aabf2feb021ee86d8da8c3bb2b5c3f59c70d811c64addcda67bcf251d3a17c836b990d277d5fb590a8c3f7b9bdbad537bc14846592c97108f170efc02697b8fbbb6e3f4d7ec779eb8cce7258f62084de4e93d89d7fa13136b13880a1f298f4cf35d63f775f8eed772c80f81e18988e7a2a9b9fc23681ca277b1299a1bac694165ccf9c4b02b9fe7b01adc7f7291864c0bc53c6afd933908f1c790d3b3945a62e2bd7bbbf57d5d5b3010c033bccc337d79917fe986dd2cd671bbe047964bb1f3acca3dbfadee366149f58f5d3d5efc20dad8591cd34195c3e6cb5bc3aa3f5a74a4df72dd8bbabeb26361ecdc806c0b0698af7c0619dfb1cf0ca6c95ba53d9e42055d4c1a68303cd05d5c5277695272d7b18a01f3b578de5c908a0bae5910ae0eaa33edf228315b22b5dd73759040f301553651b7c3b8ce440d6f7691bdf0e9d5bf793c1ae70a97319581fb6c68da9e58fc81036ab7da978763354c958e758853708c6cf51ebd2db9d71bf30b8aa94762b29f942b8967d7b3401ae3e26fb8591328a2df01288cc39b3cf76471f440368262f62499bf68d0e759cb5f38569401ff71f2f4ddf2e20bf484498354f7591adf34a5aa43bb1024ec4c2a972cd02c6d7b6584136359256dff252a731d3aa74008050ac4a76e030c911ed4747829ee5483d768521f4223541200c8537fe67726af11c76df3c62652ed5d047ee2c86bb8cfe6c0409776417d2d1942df55c5904a7c2eaa3b362c30c470f95c51096c7890cbca69d1edd691bc9c5d22be315db6a792c43dbbba2eff3e127d908486697c4f0fcfc22fb468cf30db25be96f63eaa63bc1a53f31b7a8e72a96cca67025b5802b51de215136bfd786242b86c81c0921b97533d8f6691af5032db864b934464cc97cc269f99f38ba6913442021cfce0634c7c65c4ac5cbb8b3f45bfae66dfb5dcac8e77ed6b5cd81f42517ea781fcd685dce6a3100b4435740db3b96d609fc2d41ec417a03ebc9d908876f5fb79605bbc99f42a68b6e87b08c82ac0a822c7392963b72fc1957fa968b66de5d0e70f0fc2fcf0ce711168d26b01d5ac1e5661092873c4987b15dddf99fa0560e59dd5ed5a78662ca5ce7c81a48476bd737b3b621249c38d175dbde911ada86f1d9bb792ddb4427bac3f25b4da1a807236705dcc52596b6460d78e6765d0de73c22a55d58705c210b32d8e2cef3185c0c33725af38b121e301c7f6031a7dbef7491529b6c332daf6d4712684625769234362fdd590e4f0282e3aa2a4e4e9dc1a0541b41ada9ba4cdc1a186026b1d6ad61ac4830f5c95e7323668caea79c952c120ee86784b69b5580bb95e9f67f0fc5924328d9fde90fc108637731f7f4089838eac0f7b84c0841d19894344902e394debc6f0b8e07f8ada7a97ca52b2eaf5622f7ab69942f1539ac9a60cc2c11a97d0aeb179a6f0c1ea0f5285028821e5232c54b15f66a4b8579792c6baec54eccf33ab0c809930c9415bc9372f4048142567da9dffbe9153231aaa3830ff01f6f48212c819777705bb83e2930a1ef9f8ab451eb760d5caafbbcc482355893cb49e7fe62c4887610e2f711aaccffb810bfa6ffce73dd03dd1e0033536a9f60dc759c3945e61f0aa11c85572dcb2143167fcaaf5294fd29bac8e6877a12e1e308757e68874886d023525a47594daae9e3fc7ec7570f0483a84f4b39a144512422c6dda572c76da84446699292a43f2e5f469d6e8afedb15760c85a3c870d4f8c8c18caa2a18deef0165fa116921801cbab10fb03b352c211024f406befded377fe7c2af9cb174ef61606061b929ad89fcfeb7ce876c3186c0869e3162e9f76d65b849c6ed94b4aa9366c3d6e2c54acd3960e169b4c53a741316bc549391193d8ddd38a808232a1f6c9089cfc724462df26174d3085c85c436d0dbc5c3e21872b9583b1ae41cb96c28fa28c6792eab118e364fec1daff0c8d34393638d50e857df6a92e39706fabd54cd1be3d5a19fcdbb1683e653455d4a1686247fafa426357054ae6965945688b99db9c9fd4a8e2cf75f1f090dd04c0224fafbb51aed4dd7fbb24cec3cbd8f73fb0abe46bb92d96b3deba9df5f63c9d04c197be5eb9843e90595ff5bee173467bf89297db26d657ba3b3cdbe4c995f85e6d7914e7d961da2c2079326ffd7b77446b18fd6ed51a50f511fcd7917cbd29c037f7b33b7106aefa0fb8494f93701187b75d3b349a1a50e1c3797e76c708fce3df7529bc28db76551adf88f3d7f86645b275faf715267e7e945839b0f5319ae43d3b1d32fc2926540e0119737da85cd9b9ed9b0aa4af6ff45d4126c37986945daab2c93b7c0b689f4878eee3716f344e7a1b1ffee18c35e67f4e150c6eae599bea41786944b19642c4d07de0e9a2999f5af148c412986691ee2efd7148a592dcd754d1c279cb5f435659cdfae52da7b1ea841cef6d3e8fe71a12564e0fa3bf10d7cb5a89506e9f1282fcb00afa75f35ddc8efb4bdc7aa736ddd0467dea6b04a7ee4390d9c6a45d3067dd3440389e21faffeeaaa8182b1a8bd75e1df7a76426b07791d5f6dc1482ef149d175444edc151255bf0193e193ac4694efa8d0b4a55c5a535715fa327dadcc288815c77957517edcd3949f9c88992cc88e40ab30815c929aea1a12d5a544faaaf7240b166b9d06768fdbfaac1cfc8a916199011cae125fe2e3c75726b2c2530ccfe37d84ca2eab2d8f35189571d2a3e5d9fc4587ac2a9b904d34064823fd3d6aaa3b39afae61d7055cb916d785fb3b8349befcb18f6a8411a83651df769f9c59f35d2aae48e4efca072cf464953dcb0ba09d8c47b7971cf3af55dd4b800f0f85e16577ba6e5d65d10d917d11094ef77d1186224bdda6f931d104b6b845f0c13860e938675a6fdec217ab34a49558b34094c0d537b801b62d5c989de86bd12ad09cd18b1db6f61b8107fc65258270697bda020bc05b32c55fb0fcd5360da9732bb7d0dc3d16c668560de1ac175acb382df8f3f7ff0e56168f41af8da192bb82bfac062c093860e2cbd91636479801c75047ba4547b0505c7d94142667fb807bd17814e22d15e434b97383aa81ebdb94456d73b55fadfd02f3ab5f64bde947f512576e0e0e348ac4b479a17344587364c3d1b9c5263e714d23173177bc3b6753696a0cbe8f24c68a3d2cf45e9240bc014ca3b190d0d1f8772e9b6406460c7e511a4def03a42f15170ac79fa050ef4d3aa4ed5108d10f2e485c54502d2b5f019663ba1d757a5390489ce8b250b7ed08f96b7a4fbffaf4d94755da9ae58744bb4573fbcaf52e4106e9155c04f04dad9b929b5ae551c027a923c512e3d3a52cc73979c1a00168a1fc514d2926933de736277a90d744d7eed30e8165b20869e04099a30dc540768c1d05b8654606c308a67aa7378731fafcca5ea3e7b0600117757a53e890e245d1efb3a16dd0c30a510f87788ce1ead2c880fe1a17105efb799f7b1d9902a9b7bda2d5c88d0d185bc47633adeb7de74b6342053abfefd325f0524781053b08c0c48eebbdc71833469482814dac8d2b01cb8bee090fc3fac90fa16c7da7bbb9dbb612d3c3a8116c76925e4597e21632c87b4b63648d8e44971a94ee68e9a51ff338d7dc0dc01c432b160688c00b99c0a209cbe638686c18006b14bf596cc23f1618c87a04ef908d8de587073b5109bac6228b51076c966e09efe1d4fafb37e59ab2e0853b50835b0fb13d191ff109c77af167ccb9c34351be2b6772cd535ec80d1c81e3778c556420f794990e4a9cb785f87d90e11964012c168517d1eb5785e16346e715b23ffd29101eb3c88a92b7963a098bf8e71c9e4794afdbff6b7e52a93d3f968944742be8576a6aa2e8b30a5f40855d9d2b1658031c635226d9e4edacdf0005986ef3c4c3b27ca8ccfc8cf836f9a14ef693ebe46322921e126030f8672d33b0265c7005fb7515c99fef463069e355e4277d4d55d498bc53ead2e8ab73f54ee0847ec99d1d9992dc71cbb8dda656ab424b66c98ca44f75fd91614516c0a5cec6b0e7e4010a8aae7eec82cf8131cb520114f8fda1aa6951236c8ff9e77d34351912861d78b2147771c43798b48d9e05ade3c6c800cc8baa96769758f3c6405b2ae7480eff7950545fb928bc25aa9bb8f52683206dc60bea93d8033f2e3473a971c34d2137dec41d91d461cb68af1a813a0f8598e6f3d78d8ea8bde1972528cc01a40700d28f208c0987d972afe7fb1946bff46375e4eb69bda317422d6ac497194ee341c3710fd95092c351c201c9feb26480c0760b86d9d49b38323ea7d60f2acf70b281884e59bf81a3a49af398ff268bf3c49d6f0e298698dd6770bb74f965c65457fdf65ec1cf39c0e159481236c0f4dfd40050ab4a732a09eb10cc570863460453b027370673350d8a985521ad7934c734b427dbbf53426b423b9c2c167fc3d7b8b9b13dfd81e4888f0718b55eeecbf7eb0abfb657c91c3f7ed55d1115966fa7ffa3c8bf6435d0c2e8f72d027f67fa31004ec9efdab49f132981ff70fd6737c264662e2fa96d69e19d6dc906cff1c2a7aa803a0df5dd2e71df3b531aa4bed1241a76dcdc39bee6e17eecf6a3eeff98eec2142daf31e2a08568e9d0e620d3c224f5c990e414d926ad89cdef0ad19d5410029a4f8a9f8a6aa45f8e06a0cbbad1be7059ac690b1524733c0066e357bd2804ca2c3ce27c2eef0055a99bcbbd9e2fa12205e2547c0b7ab1527f6c357dd91e74fd042b7300072fb346f0e965ddeada61e7832bf59d17f478d8e97440b92c9c1d52f66691ab48cc1fea6b8b7ee7b1ba97c3adb48b6af75b253f01c1077d8db7384b9a64339c624605e257a63d891a6c44259ac41992e65d144a49a9133a762a487771dbfb4633077e5d2e858757174af91fb737e1e9b93970750f4f5583400a4d5c3fc8f7b2d625a6b99df7fbfdffcf6fd5345856ead57adebf19d1e9c446156be95981b9b3a96eeb1f6769fe3d15503a41e51a2038a9aa3a4a4950295877a29dd4815a5b4c6afa581ff243278c94f132b726f6949d5579d3d8dbbfc5aaff9c36bb2509613144457c4ecaebfad38c9a59f29e28a3d5f44e1e4f3e8bae6223eab7f49cd5221160313f528edbae464fbc02b530a4392704d7a081adf2b306ff3b8c46e6e39b09b11a0e0e1b2b33f25c45bf9e189fd8a20c9ca347c5b35fb50b5b6b914936c057d13cd39ee61597a70b614f7026bc24ef07de69089e8ac58e4317e9f3e043ce82b241014c70b5acf07db2456a66d23784023d8dd359e932bd053b1ee9f5397062725355c488b35b41f9414c7bb11fd7b27424d8e2afedb4c45c37f5376b6ab8c38a26a19a327f92bafa3110265138494c1082fe08219c78ed34a0750356c8a7875075943cf71e368d82f27887f5d8666d3315e8657ada95c0026ee8778f7c3572b19c0ce1daae2004d268c4895f5824daa7c4401374cc9b128d283e180ecf5db9d343d5ff2c782d9d202b706dbdcfbb0242ed586d5cbfd63c39777d3b73b4f0757a8b41ddf1edc8d771dad3529bad1cb65a4281493c85383087d4179901b4eee70f3c4b85df2d56ae7930b449a99f3aa6a31a676c44294254e8a385f4e682549272a31f2c2980708ee589ea7793b1b300151d91fd3049ef7afeaa45acd0bc457e3e5b08e5081ceeddfc12924acb31f755748d161d15ebfd4190b2e91ecb4150853ff36528a63d1df8c411251afd8a42a928903cdab793f6ba914a764bb184f961116cf0ddd29726aaf708e3804f540b8ff4dcf5d1a86a4dba252663b9457a83de256632b26c9f8525f34ea520b1079bcf5983bf9d8d8ab821151b325433817de20f819934e1124960b8e5da3a6a43457f3d33b04cea98615927e1731c5f5175660e261418b0413aca3a094e3d4af3d116b3d35de33fbd735735aa6dd51e4609a3d8f2a54122764b84ae4c222a01ee0f140114f35db53d2bc5dc4cdd48381567b8a1881a72ac1ddf0bc011f5fa0254ff2883cfa6959be571d8ba06d4c6313e2bdb117336a2de6d4bdadea1441d78f5c3d9e526d028dc4a286aa6e79f17d8d11f6719b3012c6a6dd9afe53cc5bc2221112c823987f8c9bdf1eb7711e49eb5ae1958993d44bef9410e92e2b6e825af551115888f9e13620dea875daf9cf1961c9b7af64b1ef57c0911fedd60c9a109e51d22ef7958fe79171eac38f41b38cc962661f90377174cf6ef7042abb8bf1eec7d354bf0f29335763e4b1b0ba5f23937049eb952e5514494e9cbcc9f344cf827d754e4a86ea9b108d05df24ba5de59690cb2f67ab017838a348364fae0d91d40328e04a7eca8303d6cc9197d82f8fa87303730f44113cb14bc76d92bf3a626944c407bbab89e1310cb135f57fc585e1511008038b22c2167632d9c4916e18e5c463e49700b227931ba08c238d1f30e8f145ec3f2db102652b84f615a0443298efe70640df1845b7616bd09d0adb95167a7531277b591e266ccdf200c282b6f40ec0dc444505ec6711fa1da51ce26a1c936b92a649e1c511a5184841e8b7631994ce00660c658a4c5ec57186778645e92a5ff0c86f166a690fa1d65ae64fae451072869c27a8a0d13195caca30b994b134a447581248a5385198918228ceaf06cc4bd4237bfe21e362555b7ce04eabafccaa896f3d2d92e47965a672ff8df6c92d958fcfbf0586be8832cce97c8b601f450882b098397840a55d10c0c5765529e62a8cd51d8425b601abb89792c1c8ef55e9adee9073a83902bda4e47ee5da953355d905689e936cf3748924e3bf12ab361261e3fd5851557821af49dfcc34482df4e144c96c92b52927a7ab12c1f72dd79fa8e54450614f69947ef303aba99b6474e7f4cb842a2a6bc1d3d96f25a0ff41954c5d26e199a88b9996994228d5d2fc508c90091cc59e9ddc04133980c507617e2f50b9e2e4ceb8f871d2139792bcfe1d44e915920758c8debbc19e33d239f8b4ce7af331d9367c851a880695b52cd50231c779701cce8e8bc4923a37b460bb9ecf03ee0aab90d550d4d9aa2259957f3523d4106c7ca49f35368930b075e2e18d99440435a8854d664f64396d67de51ae9943d15002f779b28fca6541255eef9e4f94d1ca411775661929ad392ce392c0fb181dbf437a5f870edf1047395b5c03aac0a9e7aded590b26fea5dd2855a664c4611a32dbd14cdd712ac948f01b4074b38bbc11b60afec23c3dcfb1a5e153eddc618f72368a83d5383420ae60151341439120a4acc8369fc16e9f161f36a7e51b3ad6f5d4ee4d52740f3276c22a0d0955c6e1a8229f9b46899d8c6dcb5d7eeadbef9f1a1259470d1a4a7e3fdbf0e68c4d2b2a7d14d54386bd2a5256db8c3ec1d4ba37359bf3d938ae20faa206fd585aa4f5ac02fe3c067a2b7eaf5278abcfb09cc0bb6f439bc1b036e5bb1e6774b6c5dee545654977b6e9d8c157182978060bd5f688cbc9a6443ad329dc4ca4ce59bdb165d745db6210d338c89c5877ff1062050ca4f40f0a27e43423580e5636efd0da2432c503d57fbe789dd31d16a722cdb47b0b4db2c44bf7d2e7746f9d8e0578e224d8d0ec5fe82325596e2147991add86cc1caf7e6ddb5d901a2d089a5eca00db6af9d7a2a0713e8d69a2c2a3336dc6dfd25fa341b4a96f9247c364149230844bfbd35c08f64642fda175cbbc3cce020ac8f176a609b5514e67a16daf84b0897c9c261f59c6817b29758731a46504a59ba03c50f7631ed333257f53a474ffa327da56c428e1b66c2ee5dc08e9c4abd3ff964897001460f6bbdc53042e69d85208e30c208c07f6f1bcab8067ce0a0143f7928abb3ac1992a6c74733855ad479dd260980cc69c734cab983f74e8a7082cb5aaa0fce85a9ae08582d504efa639383ad5658b319ce7e667faa8b09eab50b5e64b8523c23056fe932d96e0b18f06ecd5a0b59808c681c2de301b9d6a38ba826929eeb38fff958c29d6e12e869d98e710dd36ea34f9527c217aba4552e1cd06050d0ff5624e81491de2212a4d8746fda84c93539a637e8552989f2a1018eb16b29eb6b94ede7c66e1accc6128d25ec74df0b846c03de91f2100cbd9846dd6d2df44614a94739246ec5c58b8d7fc606d1eaf306fe9740f140ecad63cd6f351686c46ef6fc5c56df7e68cae875dc5c2e8d7cebb6f70a9a9d7b9543c7d8cd1b9d6a556e060c6154f9ee66eb1c15abb8bb637ab911bc0eb00965aa738da7fb905b6e351a3063542e7f62885b6a644f86596189a479a755b6a785cb0c67d342af6a2c864f05770acf1fd4ea29de5c4c0d00e5bcf1bc283d75710874319d3d2418f63a25a3586b7c51cbf94793549e41c3f46fb57e1c810510543b4290cb56c124222069bd765cf48f44955fa323142b24536ca8c7cf0e72567e8e4635dc4c8546e5cbf2d45877f3426a963940043a7b58508f1864bdfd4084943261f798da8ee045ff0e1a048c2dc87d761992fc02e430c4822930b9b6824898485427fc89db3ff444bfc9ac03392adbe4387d916b4b3fdd0b1f695d0dc0c14a394ba03a0c7fba9569ef9b18d2c92ce56c1074e2f3424581efacbf974e2fe4763b877326c8b17117d5f1204284e7659a665bd3c3168cc47e18acdf5dec8c1d545e5f8b54583979905cd6066d78ef073a8743a8a761b491075ba17f935b24b47d199941407d9bcfccadac11ff818b031ebcac9be1bc48668b247b659e034165b2978ffe00d76ecb18306f0b4928313e9b5fc3e85bec2fcd536066f0442cd3d6097e8a71145a534d45b6232351a2a2044e5c90382d1a241e856469365ba2b24872004927d62fb57a28802164020d56341984052383a435bbd4d97c6035d2871feea0ba9eb350f6161dd9614ed66fda0f889e79c22bd1544be68b0f7aaf93f8d2929403dedd6de6daac6901f2b5ee2b5bcb87dbf54913d610634c44af4b3b19a6c1721828ef4484a76fcaf34c72a7d9b83566517adad6ed46c014f444b0a160f7c6f95d21ab92965910ee944abc502180bf224951ddb699f7fd8d1834860907a949dcda0dfe13a128bf37895a52427ecb8180e896f3053b6fa3f47b82c725720df3cc4c1b847a8f943ad7f2b6882f8ed27f7de288bee8716d5698c394dcb7feca0a572458e6d7842d78201b5dba514508e75b707e2457668696bfd7bf1dfd38768c925dfb4950d050a9dc785d5dedecd73e1940ad8fc7737479885cba8be6577d086b21f02798deb8826356db99b7afc5b67f9bd15e842906f86915acb2b3a0874693667272c633fddf267fda45798ae72378d88bd3cfc8819c55a766a0f80c7ccc5ccfd85d53a70d62950b3e77df8bb89bf6502f3549e7e0c52576f82de2a8b2ac3e3bd7474bf16ea88e78bc75c00599c3342f72d92f7f733692156614cc2021f30a62a05f812c99fe7cd7a728bebdbd4a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
