<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"540d80044e0309f1f271ed995debf4e8223354ab7a66d6972f7ac3b67627fb29e5236e2afaf202142222d274110120c92ec07c8d15d40b9d5856c0eada2e357a9bd731365e3135693e8fe1f29fe01103ec726c73ec3e4c3452d94620ff54e521a069a111c058304ac6c135771aef25419305872cb3a4eb0195ca5322cbe387d6c9a64d269a39e45ded40ff0436a6012dd76efcfb72a80552993dd3ad8eb008e5db1982b2996c26eee5888d59458bbda9cdd5d0671ec673427003c68d959466ebaffbe26839ce2b3cb1514f568bdf17d266e1067613734196ce92440263548dfb44cf6e2bee42ccd709b6bb9617f80872f2ba7214ebc2533375c61e5c0f699bad4fb0be92c93eb6ee93dd1ab9a898feb1116ae7f0119882ceb2fad32362711057ae90e8da38e58d68e731a1a914f73368f3739fd4764da685b40d60108c1a9bc6af7bcd8cb3ba075c7007b2954eeae9a0d7e7730ca91e1aa4e9115b394978db920908175dad6e7a3fbd921daea44b64a513849c90cf8a5a7d86efe6b71ccb7505722186bc246637818a1a36a7771d6292b40d89db85b0dbde962ede9d2be62ffcdb05c42024c5f70ca5eb6d1bc22a7da166559175755ff341c85abe276e1ee6fcd23d0b6665e11ebfe6bc80a01874f53b859daa40dd3d2c9645c5d7274501356f35c5de4b9df47f3c10d47e529bb8ac8b3e1b69d4a1386152ab3aef93ecfe0a9421088c0a212073b55cedbfa3f273f5527bddea43a2fee2021b9b73caf863c847c61a16b9dd187976dbb3319499c22c32aeecc0a8040be35e71870c3734a42901c2f0a2b9f793e6081360424db2c228514437e974aded75c675fcdbf5c599766249e8fd01e2ef285b77514f705ed3a37b3d8f29bcb3e6b0834d379a705b876f860769e7fe08047b403d79d299adcfe610678dcdfbb79e1e13691eabe983818f085b7da2c2ecb1d5cf8ba8c7ef1013f27b2d7e7dd3ce98e1c61ec5da01fa85a3d981ea336da87183f4a1ea66885529f293fb7bff846fad71da1e7c1315018f862fdd407fb91af385c06f9d68a6135e7366a2a3f33b39e0ca5b87d6897cdbc95e2ecf809a85c6682067a18430b0cae4998eff832788b6493741c6cd1bf4306d624cdc9f1b8adc2d3292501bfdf7c34e2e520469cd9822b0d20474a82b9a1bccdca2c50fdcd8bae8bd6dd41a7e5cc037fd5d74882b02c8a19b5dc6b8eccbc3eb843aa9054fa556a0e55d758f6b3dabf9e3478e32774a5180a712138f109e5eabc92d72c50b8c1e1cc6b118930261d50571c3c3b3b2b36aca863a8f324138c920b7c95530c6f367474333ebdc3b5221502cd4fc94d6ae8560c658f910e87172ed0395864e7af65eb01549933ef1fa7b40596f09e1e9b4d9ccf08dc6a01b0713030c186bc16b46434ced1e45187741fd30daf5c0d81d46c9cfbc9bb49a9db2a9d7a3788b0b120a8ecff23c78e5ebbd283c32d8e5f2f643de05aeb4e2e46ff67f2d2416f9f4834dd26b756c7f1d54ac3d0f8ec693271e55a0989938b6148ae059ce0bbafaba537551b0d301650217e9a46307b399fcb609c2d0ff8a91feba07de548cec0c4756b3bc62a63c46cc3db3cd851917a3f8b2d9bc05d622d1360a2c1a68425c673b5cc9118fb9a9251a77c8aa13cba6887eed0cc0c9c349eae038ec5f225328ba3a448858ea71b9ee0f9ed0fe5fe70f265847fa03dbe0fba013dd504791c3f5048ea8aaed22aee744e9bdfb467cc01ef9605f489e3f67a6eabfe020f20c9ceb42bc7ffd06fee0e10a81fa990e133e8ec79dea7c16a0c0b58ac467726838a948a08d1435028c2f7487c5a4390ebfa6ab0cf5f486d4d04418e627f6e94d163f77ba4ea41a96ef5a08c4423106a86fee7e6147829cce1c61483582406e8dd17eaf2a047ee25614f677e4dbef26b4651b861e6b9a875dbcf2903c23d814e5fb8683623da3d44bb8c7d55b18e7c5ec24945fbffb15034a00e4dab9a226499ea87f76337060d5f98d7cdd5e2331e4d50ab99aca81190706db5354e2bb6681949e373e5bb7b9c20e35e24b72aa6b78052844b79ed8711e63a03c6884793812477f31087aafb29cc364ce1c1c7cbde3e325382ffa5e0ecfa30d319204d1d04cdbd017fdfa7d5f38801b0d7538d3006641a57bfd96b8e02379cc0d04840e951b0b97a60e737eddd4ebbf7c289e5feeadc4efee0ac469403bc85354505524ee551c153fefced8ae3403e336b2c3ac76a293038ce702acf7c7b5fd425d3fca158b596b8f00acfc7d8fa1fa8b938f43a6e8acdb7d6386fa1608e886b7a7be9a7044e41e40e09702af184752adb6183d5c9deff2da4fb863aa227aca587a3047ad5385fec160a6792760ae64c46a39f0e346881848575a7545eae697520bc8752e61075ac92b2c9812aa381b120ad680822a0f75ef79c3c82ebb8012c9d60eb7bda5b1ffb591415a9a21f264046b3abf7f3d03643db8aec802b565e8ec28c05f81215a86f71ab2270e84165261cfd514c52a48946790b133a09b327a63d1e73b817ad6dceb9fddc6f03e8dff12c1ce00120af49cc021c5a31139afbfeaffad681ded3339e9639d563aeec0e8310ca8821074afd053918dbe9c07f3b4ce7a57225aea1969b57aa237376b5410361a64dc397ad824339bcd5642bc5b398974b4a8188a7a272884867da17962faf364c541053e2b680fbfaff0f3f0390d5977024473845cf6a9c381f9b93339784de0ce572a6589c081744a195cee0919cc84329bb13c9f80385c80d3ff1c648061b64d27bb882fac4d5fc95bf2066b2d65419a4bc3864c030864c5693a9407723f50d15389c8a5bc3f487db47acd457a636156ddaec2643be8a007c74159ffc99220574d9dbde754b67d6fc8106020f732ac8af1529ba889d39e485693de170bd7f4ec4d774fc9dce511a2089685aa589e2e582008aca86bda7395ab4799569bca246e9f00b98b19370fc2d5d290e0a3e76d25dcec0b0090f5c5bb248a44bebe8a45e62492c9af686257bc96bf85e7d3c0cde67f9ac8deaf250321a3efc48288d7761263e455f6a50f65e942e5c95065f8c89da6e20838c490629eb48e48c71bd711a2d6a888c9b3dcdb0ab5fe6b697a82c67e50bc35cb20f79dcad08672fa2ae6bb9049cfe4df799422879f9baf9b737ce882974c1a75e30c7462ab3b7825c3b3e4910cda9968310a24f2d23094798cd68f0f7f5de61f259269525929ac776eded74f3e0fbfb4d74186939e613fb51790ef2a1a0f92d2c0f5337d97c92ab418409e56eec4e6f4eeb3870a378159357b0c1c031997640849952b3d3f6d8400d1c7dd5c3dda1fdbfc16fbedacf47752af2ef7ace60f28a400328336065e6c4d646cc4e4813563a6f73b5b7bc618d76217b7a248547868cfb4ffcdfc27ca52c69e06d8709871caf59d21e823045f2a83850081880d2e9a447bb9e9fa6981c393e1f2965812e7935e52ffad6c62b1bd8c370697a5c166c68ddd041811aa6292d165eb348e82b8bf5c45258d07a5e97386a510a65667d4398bee05c8c03c19eabda2f86df886f46340d624f76f801e5e75122926b4bdd9f2cfe798b94d5625d937f8653ea37cdb31ed03164e6bfabd86e1be06638b89bb7217981f1130b4a6bc403adf8d4cc8684c8662127b081ef657827c6f36858c52838ef048a84ae26b9d4775183f464b985b39507e196d5a6b52206bd65666036db07defb4fdf9f543b052cc0ee0c22277810c5df269f50a4c7841f2d38dea742363e40e2624a29384a82ca10b0b9e126d33f4c21ad5c6066fe581dc94002fabaad9e7174d97cf7d5613db8bff21054cd81d66015ddaf4f4cde364bc6525f685a347f6538aa8be2944b19788bf7af2a7f849662bee6eb9da130992c5aec47957c7b2ed68dfcf2f2f9e4cdd0090e4fd958711c67f547f2fca10f777b3a7d74c801d968c823ca02ca0e740512770a475d5551fcdcbc73e3a0d9bfe77d7a361f8be155f7d0814172644c178b8b72578fa05ad080e1f48e09ee34896397d863d402e7b1a842a99466b3f67502f44ed4ec51cbb0cc0f378bba11ba1033b708866620aa2b8a26d68f3050dadf1066fcce9bf97408cb290cc6a71db660050cfa1bc9edcf418b488ef8b1beaaca2131f95b503681e5449ae41ff6294a469d20804412f14f6fa527b7a90c06962c07db62f8a0ca1a96280654955be2705bf3f8ec44be0765058dea7438dcc35351f7378181c1db5d9eb04e91e80a7b249bcd262c9a2ab5142a20895769e54aaf703e6e3ea5e22c8fd7048d977d1bc2a49ca3af8430bf4f45bf479a47981d7b0afc857cb0d28e0e82fce5dffea422e241e0e346937c85eb1dfb7ac5b722c552eb520e39ba48cd38c81ad4eb4eb2ef3e93931a8fa856c1547b11ef307db6c9648b6610e8dcd6db09923a463186ffec3434a8979fcb04376be4b860c744f0e90e810af9b79d37597eb379d3836dc95dd6ce6442cb36b019f1609a47b7b91ac5be0050e7d796f21f9441fda13809aa84d9d7c9fc9c61a37292f1f414b20dacd9635fae91e3ec1d497ad43b68ac3f52dc78ef1996bb689d4a6407f5b4a56cffe400ce6afa1caa2e06d3aae5b9ffa37ea7a1fb18f3e29d129a6e00f1236bdc84cb0981bcf7106d3cdf4f2e036abaac3a3d82e9f4a71b090038805942d6416e19b7fba505d5ab3b0156550de3a3d7bf98d8ba664af6ff58d1da7f8f4de0f55f9e114fa15fbd1a74041f997d3a37fff670b2029c9dca1a3d680113303be8a83876210b7c3fdf85160e5fb67004f03443197a14807f6bfd7d38de0f1ac52541ee3d45f459068b777fbfc4e85e92487aec441fafaffe5ac65a9366bc1d641b08e993f10a07e1d32411fa778a4433302aa491ae0d6cfb942b73960b1ea9c2c0a8056202235737acfc24cbe9da6255d584bc89ed9092e647da48ac810008e237832430f02d6be604d72f9dee85cd21925f0d6ca1793e58cda9424e2518f8e40668a4db5432e8455a485380043c1ea827b7b8b1fb7b72b559f6e92eb71ac3a0d776d9e95961a487f859e210f35837f15895401c80994d943b389d5946815eb4f34b14279e8026071f7b450f9d9dea708e303dd80fe35cf5b069af62dc7aa7d0675760dc5a701ce8aec34bf6bf9d81f74bd63d1641a4cfd03b6ab9b57a9f85349f9b3d782a94ad9fc0cb1ed6fac18dbf88b7221a2d2ee84d75c581636a936e391d8e14a9656c5e1d67926361b63ea4c88dfa2c2a3d1801cbc314173b8bd7de6e6b336371b1f828f5b475158ddf2ab5c401401b4e68ca32e9e8d9082a85035eb284640ba6e9cd83a01995acb9c600a19f666ad12dd809ee384cdee5451b06a5a2f07b3732e55fa83d0a237ea7e9fbca862b0e72314ea09aaa2d9c2330cc42a5b3e4e0301a2c578ee72deb36bcbb1b2b2355ea0278f0ee5a105071d8cb5c2c10dab71c652c02b04b6f11ccc925894372b82b44f89e193b87183aeb26dab0f72f93a8a3e76d1b082a31e2d6962666e3b677c014d610b7f946a84007363a8b8aa19ced53d49f655d579cd00965583b6e5eda9fb8decee19d235605622554ff02ee970e3b9faafe5532eef11d221aec85e274a9b56f1400a429b84b41760bae10b36930615d5135881931d9f61d31ffe5b661b9f50c828b7f2807637932d0505698696f6e42793e26f4551168e3032fdbac0b9cfdd74727b5218389592338b45b7d1932513f34065f4cef3c700c2d62bb43a3f923c93774e360587d52da27fed258d279c1edf2eef1ba33a40265756b8363703ebef2b60a24781d2b5918c3c3b271940f9368d60505c8f44ea2982072100bc48e723f172e9f869949d96e27acfaf0f379ede6906aaa85fe4d8fcda4f61ae5f8a69fa0a117cb3aafa1384bfc02422856ff97e033f4354fa99681e21e6482afd36893332dba7c98fc5bf0eae9617bf363d9a68290d43a5405977846aa1ef170894ef96aac061d0b52238fa15fe4fee46f48221465823bba4c6ca7dcd10212568c26af77885d03510c1486f3d650153d0ca40037a29d55d5458d86814751ba0d0d62c7a89cbdb90b218450bcd50ae75cbb94cc2a21c36b1ab8e20e12481fc427427779035f9f1beecc259c1d6f40b22d745a99dceaac25e10c63e847f3fe98c42a4bee25af3282eaade6377a3ccc63191c06be7380bf8f4bbeb2e9e27a0e091175497b390eacdaed87660f5de1a29abbcdeb8b7f294e790c3dba498262db9a36af81272435ddd21bf3641f3726f70c24e15c4e1b93e58f65655f7078dc7ed92691d467096887b85c6fe9a91b77dbdfd5469acaa11bc3abebb0b0d047a0934ecf53a77e5cc3116e14487dd1f0220843cd5c8dc62c4967a758b2850dd1d31c2e5d25f16363bcdce3739258867750ca0ade9cc60b736aed7f785e25d8bcf3273c3aafabbd86549aaa24598bf3fc1496a8317f06193934f3ebdbb1f637e324de47c7e38bb9e44f8b9f2ff720e0d2afcf131c9a7b6d09251661118c610aa629afcb9b43f3e5e3f42e70b3ff3f215df89df92f72219701062f264b940c5ff659a1a6479a50635699f277b7ba6ae59f14b7552d1f2ef10dc8655cb5892be5862e5bf6c7e767efa321f0eb06f3c11f8a412b5db57449a9bf22e66f83d9412f8f3346bbb8ff4fc41fc88e43cbfd0601a2dd943a2ae132eac5d1d4845db4e66399547b3922b9f55a63acb1128dbba3c226ffd66e7a6fadc2053bd34c2ac65ca657ef8263456959f43e842c919bd3e6f2246714f092a66186b7a470b0be012ac334400f5ec7ca93c510ac7672e129d231bc6667cf2b05fcc75a7da6200b0244b879decbcc29603a889396a802e78f70c48fd3826715323104e08e1b4592722ab4afcbde8cb1a1b4c1bbabfaf1e306f5fb0b3f25afde3bfa7634c144db0ec9a9caab7ec2797f9b933c20c779ce5cc4caa596e66708a0907b77b06de61d6a5436042da8ada132abcaa9102d1a463f637491acc9272aee11d2f965459a74dd72549728eaeb6cd0606c37d31aa54d6e56d14185df5f14fc5d2bffe1a126d3fe73d095ca8a6399a3ccee6674385fe01a1a1a30690c48ea4d71c8977af688465c3d99cfce037ef182d401ab6f7744a1439a06358c4b003c2d3cd13fd6ffe35eed999626ee5922f8a58381e04dfcdc8dfe80fe94960260915c627e73a1c70b38e9e5f0b51a95c35d6e91956d0487b4b56211fb9abc7d10966a988b875c8cf43113f68ff756381b22631d2c3514dea9c104518cde9d80d98beaf2cbc9074e78fa027e356283494ee624ea2189b45db62b508ab551d7e6505ee9d214fe6833591785ee85bee2ee25675fd0503bf53f8bbbbbfc05e9e35d130902a8ef0c541aa0fe14daa061cb7320778179829e5a612d0db4251f4b745f09260351fcf20bb6639d419e7356216e0e62e511568d468655ce19a0ccb9c3143255f9c5f9cb661774f94f7d81c706851ef660df9ce9f09becf39c4858b0b54633cb8439198443f1e1461e2d75cc6398ffc9af0374a249399b20fc51f18cd16f2f4199fa6785d224e61f0818079747506f9e94f8fd8dedea942477d00d7287e39a6e00548a0bc2816b3cb68f6fef2686ec4eaaf6d432dae96728b99c2c6d999639002c4c792c12de05a2468f531fc836214423b59703342ef240140acf31317a97b01f3a4f3cc2eeec38e23ffbe4919371d9f42a8d6655e74c681b9ccf4459703ecc7512495bf59b6985de6f589c074f49ae250b442e8708ba83dec22ceb6d83bb314d95b832e32cf1a8ffb7b133fdbf7ddbff85caaefb4f36e863d15a3b1a0940347b8d53e360cdb661f025d0748d0b1b4d9e0dc1307ec2a270e8aeae19f5740f76413a945d50f8d71de6c3a3e28d7742eeae57eafeafe987b082f4cbd4b9a95424f56adb7dcf1f121e5aaf46f59bb2970c73da4aab0febbce7da0d1aeb9c1619ad1b65ffb58ea742001ed4b7c83c047c9b64d955751e4b44d8b884cb0fb78d221a680c4c38a8c2cf692907674aba84c97c5db0b2cc442edc85731ce309dcfabd75ad00c77ec45044fa87f74c64b866272b91e8159c8f17c18b544b4b8b409aa56a3aab43bf1c6fcee195c23fb07990ba4973c381028beecc86f52fa3923c15db1f3953dcb3efe9280f11a2a30dae100f236817791d9955648728c6f7e1074391993c1623dcef89b436a0ea14dfc216cee5d50d63b158651371cd3029972e82923f262af1dc3ebc0f444030f47fc158a4837be4261a7aca314932590a2893b738a8b77be6bfb0ac67e7dc99e0363d9a690cb0f8301889ec6fee4756f75eac85207de56cda42f9c1e55d5e92c834bc8652d9f82f76f163d0687e8cdcd7488ed4145ed6544efde1726740fb81c9a2266275379c1bad4fe0363af1bd6df3db9e29c2cc2fb6cd31adfcf9734be6023dd8b02163182a85b9d494545f7b1ec8b0bdcb104665ff9b01e7e09453614908834f975ce9a23d15eed0e24ced9e00595caab7cb1e9be1397e35e83836a64971ca7fd809b45afe1ad4f88c74341c32b5e57695881459f9462f8d8adb28b3897f09479f8a90bd9db3913b7e8c5769d3755567d5f04fc82e84dc32a9274aaba803530c5c75695e9043460dfd50eab2db1127159f4d38898e088651d260e89e6e76dffde78806b8137775c32277f5831219c7a91db6866fb5f33a42540560031287ce651cbb4701d2b3c8db01867398967ba1b8c29a05d60a9c19cf088c523cdb765166e5051a5153ea559a460ebe97b97bfe7445ca60f6e08bc3be87c031f7e6a3445911cffdbe7b942c013948316948a92109570e71becded9dae93fb22b5560b5488d20d1a3886506b445cebca818fa861362051f4d0de4f37ad8841ef7c7b39a8efbbfc3468071a764a4922c5becdb3e802cf87d1d86e53a058bab5bdd2ca333499e153e4cbd77a31c80819e3c2647447258f4031f94838940f2b4e0050e69cb0b770fabccb04c23841488b1e4ac0522efcd4fc75c9bbf496b95032384ae8d3ff7665f29c59591c2986cf82f23cbb3c621e9fd023f15d7f73c9b072809fe42ebf1dd60a2733b65c146365d9287b9b954bfe563123033ee2e9a7af66d2476b6118aede13612999c10cc5dcce875b658d98755003450793006e1965ad37fa63c9094dac8bdb4402f492556b965c051af00c35fb26f6ba83113d891acfb70c83f163a9db3914b91944ead87514166d6120ece5cd29957454b5b5afd255bc327e7cdf557b75402b6e26e583f5029afbaddedd6c2f6806212bfae9499601ef317eefc727a1a91d6277fe3e2a437da8e9ff76fcccd739d066990812961aa445aa8cef4b6633710a7944c42d4f3e12e8ffb976faf7a20e0ab31300efe5bd25af5b63e9769b64bb3a2ddfd13846d30b7caf2dbc4f28229e5d74cf24ea6e89376868a916d4604767c0518b4277828cd2d3ad20b6233b2bc44bdacd5697b2d4aad1038be951fedcccc5d410da8cae1cf051280568fe29422acf72f1fdef048278934b459354995ab48740bd20123fe1eb2aad0d5afae9a1758dda23614fbb990009b1f39985a41ff9637407d6b234a9a86d8b0f1cbbd6bf4e556a4a7cee555e21ab1e960551c276eb6cbbeb03a13f5df71539487f6e89ec0a7b2482b3e72eddb23f66fc701f4b38c8db9a50a570a1816abbe05ed154f58e5340e36f7a36ec8001522069e3518ef7412564786013d553d4b47e24bfeeae4ecffa5f258578c3669ee7a43fd17622d55b6c5270a5d493b1ea2643948a5055c85862c5420f67452efdbf57a36d486a8b70aa7b599c261b0eabb30a69369820d9c83892ebc2042e40193f9faaef764d0dc26b2420483ce80e51e4b178c77a9ab3516df27b2d3930ddfbf89eb0447c7130feced616ea3ff169089cfd80a14378b577ff99df2b41d5679fd2d41446f6b1a299e73363ddf430c4b5e72e2a095a6b742b321fe355c5b02af55c29295d371e888020795e3fd70954d06bd7fe83ff2c699c979d6c0ba69e5ad0eba0dcefa488e52daf4bfc0d5ec137d46fd86eaac0ef4d852cf99f7f9bdc03a7795d4374183e41f57fe5bce2f48210d508180e51c858952f03bec7da8c422770e8f12cca4ae08e8498ebf5bdf51dfe4f621974fecd65937b5165e756a3f62db78517d9db74ff7d7c8c9e7f0222e3826aa7ff7533b49b68876943b34d38b00e55366f8dbcd23d927b51542a57f89945db2c31a9ff0d1009244331a835bf355974a9b1450d722282fc4fbb6e41cac9b31879131b09b93a0609a6719b9e39196add0313eaff69ff6540100538eb8709d9347e8b4bcc6e023a9ae3751d04262efedf7826cb7fa9c2261c4ad697273a715bb68de9d57aa7610a39b96341c4b8acfe06d61e45e9162c46bb58103ea2f47a3e9fbbcf0958bf6b3cb8e1b8bb2e2f0afbf7c72e351b457afddbbafd5c03c09fd0cc0858946e4050c6487bd870adc80d252b4dcfc053f3727b1c03bfe590a2b4bb6a327b2015e3599650aedf2b5195cce971d633a7e14ba1d73aa9f3d1a83c5d0313f42e97fc4f057a7f9a1ffbf2c90a329ea35ecf15923eea8392ec15e7a83dd23b22b2b3ed9b86a4b3cfd483dfbdeee252f60fab141a242e6f13bcfc37e4b2c9f6bf60185c5ee6a240b367445603c83521346aa88637dac7ad6c438cbeb06b113d14fc645803a5e517d7d3eff2eb86fa74875ac7f9f9e0decc1327ad1e1bf5741a935ef2d6d150ed02752db10151492e3ee4f5196711477c2f85896a5fa810334b9a106f7a51d4e3183087fbcf63539a266de18f05c558addf2b42b382d058aacd7ee0eca463b8e2ad0699609cbf1681941ed900a0946dafefde653a54809fcb2a08fae92ee681df512c223fb54c254c18636fcc2f0c77be77fe269bf3ebaf4b238823c290cf77eb3223ffc5389ea55d31fb62e3d352c5e2b64664120cf2dd6e03748555c916ea0c462b6bea3720710af59d6a8271ada470d335413635bfbd1123715b7d5da0a2e7614ecbd8d18e64341aa67d69c34d781389389e987e97ecbd32e9010b2c53a6e3d128c85583c33cb326a70ac9057e668513eddcd478d4099bc985e4138b5d8142f1a2516fc5dbe28e6e130c7780916eaa5f24012d40af4e300aa3251910fa8b678805e76a20177a58f8892b3fd947f96e49724e7a5e2899666e1a0ca268c6a0340d2d39c323bb23b1aa5d4e1119971cd5ea67e82c59c8d828fb2519a0cdf0a37b6ae912a6ced69b4c7d24659f083c63fd72ee0377405b27e03fdb3645d86b8db63804d84dca26ca9f2291828ef18c856074edff7c9a09a30558c50085dadaa01ee58846ec43b9679cca90ea3e53ba5fffb9fed8e5c67699f736d8812b7109e8ac7464e0ca58aa667837e1f8218ec5d9828a0096a3f069292f28edc45700be1a58ab048583df59e99e9a1d05a8d9c7d4dd77d1681eedcbf096993c60c5c949573fdb081fd6c3d2ee7bd8bb442bc148c64d6c957aee9a1edd98baea70c93d1eed1877a79df7742af3d90e15a8858c9b6f115cfe3f13be7de631c60c55cc61f7c257e3d02cbfaec60cc841918ac06dbb6ec783792bd0ddf7633a40ddc44db32ac0222b3bb524aff1c9968dcb689d5d3760a997bc9e952184e19f63edf131cd9a704fd1e9ece8e3ac37933c7099ac0f92d329703479caad031a4888554d59b50549368230719ae952b0a825cf74af3c07cb0996f9b3dc7a28ae79fdeb4bff7a13e3b729054a87c0207f048c6bf2a91576b897a8adfc97830c971aa6ebebdb3e16c6ee723b54844183ab4c239c1e671b51b625a6c953327032e73ca0bfe4de040cd888723e19ac785fc3c0e2b4fcc4730040de731d37101f2590410c902721bea940a58ccd7c569a24f7026ad924c8e38b5acffa932028e49a9872b09f6ddc8e9505b4029e13d08489d5d88f08201f315ba529e488508bc5910d187dee76c606b796222e94c2d4c940ed330af584cd509ccbbd44e876267532af849fb4e7d957b01fe925574f12d63207cc40476286aa4c8a353a54e0dff594e756bb1c81979a6df2093e81da6ded0f2a8108983bb6acfe10a9a7fc347a6a949171cd52381a7b0b19320c96d253327906da2a145a2703a8f4fd6b30bbea3c651951d0def970b922f1412f0d16af37a148930bdbc99255046626c70c3488a2bba13e3c7cfbe87f38a7feda2f74a30e701399963638ed456fb3b4db6a183e7c09c4f4b0d0b8a023ce3a5489257f2e924149be5391b3ca735392e0adecad14ae8a8ec2f00c5d115c71c5509aaababa7195c0454c0a31f5395dcd35615703cb3542ccf1a22b2c5041283251ab93d5254af2d2d5d0b498ae666626e5df1b8258f1ef49bb32015da8d75f9e7e70ce0f11dd879576dbbf22f2af89172f96392375911fd30d19baaa29cf000d6e39c15bc7b7a033173b0b263b44386e2e4dd7a1dc6a9a8f4425b95f2f9bf5c62caff6addc4c2c53faa2889e54a3eba2ea2a48f9bfa1a4df43efd77401290f731b8cf539e4207750b7fe92acacf761f9db15d4af08939fbe598c580373d0f479c1504de349485dfadbce7481a5671d04675f9210448903f73271ba07d5ad384310ab87765de58ab9d6631b33495d8c20309d73cb787572c18585675c0ef353860d7534b54093aa2d13a85d11bda8f7ae6779f396fd4f220e37d1f84b2b1b0409d6e1abbd12bcf1b42e7cee79d1bbab43fbb1def84fa62d951e6fbdb0259918727c3479307e516d3f72815fc8ae66e328587db671eb1c2fb7652d5ec25d113b420880523d84300b93a0b196d6f6fcf39e9378f079b4c92fd4f2e30a09e11e10cc57e91fb9737c70b4f6ebe477471520116ba0a2d610ef2a35e8ff94f0dd4087bbe8cff6328139ebe37a1c4223cd8eca1ca3d53dda5d6c3a80e6d0ca230c50f1bccf99d298485099c9018db03391b1a70cb15384bce1732c19919333e1ab562bf1c41865fd0dbb120dccfe9aaca721e450fb7b4deadb8749d0d60edae5d0ba0b334ef39fbc7b907741755716fe4b552aee24b58f31d5325b7c9d3dd92cc66e9a2487dc28e845a83d37ffdda6006a78cbda7b5a1b8dc015d4a110fb427f296b6625ef59f166d17cf938978d4fe01ed474584f62b18c81caf0cae4ac196e9f2a493633c409667bb56ab0b96c3b48c94c57aab68d4da613eb8db6bde51e6dc3bd90b9b39ec8a1c0d47ff80063cb2ac4cdab298ec5a45d1828be5d8c88c22ccf63df1545ccabb69b07de513affb8c0d2bd7dd7b71296ed7eedae05cc28c14d6f21a1cbea26c1d22614a7f73cc0a5ce91e8d1ded487321ce234b0d72cfc26d669c1c268a4c6953d420fe593f9b55ac7a91c15d63b6ad2c3278f3e5d31cd5fabb4896fec4defad5b6c360c46ccd4bf686bfabadbd6ed953fee90b9cae608c41d35fac3abf9c17e7402e9e495ce7e3d3eb70c27c61d80ef2bd274677bdbee7e6c59aa101e49ea1761c366a795f22cc0f9a5f4434f0d6c6e63a37eb4068e4df1aa01612590c7ba8b15ff34d184fbae77c78f06c205055df749870f5235f1a8b5e4f14486ddca3939d7321b513c6fea25e737a2c8923821f86fc9a4ce50797fdce38e32a891892de0e43af2227132a6e9bf997942d76330ac6381f69dfbce43854398f3d9b0a6d209f48d9c98fec37a564fc64baa0f7e1ba9fa07db2c7d7ca929b32e477e316a5f0a256efbbcca5da","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
