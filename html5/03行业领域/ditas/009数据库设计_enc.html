<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8c655c2b409a724cf76a2c2d0982a38716aabc70e3ffac98073918f25d2e3a4d950169ec06e871baf4d9155ec8e5da029ff30a9086403c4727b70a454630fca3ff13935f8a51b223ad7343be657066191cbcabc68f6c6c01b94d8e937f9e6cc9bb15965e731bc7ab7378d702a4d3c2e3c3481da0770f0ca94d7738db2d00bcc0267f464386aaab847cac7fcd877162af6f88fb08a39ad89132454f42e7be90095099bd3b2bc8d96bba0454a26e7888415918b189bea8defe8fbbe0272bf27f356291b051fe8665f482ac7a29e79dd7448f015f37c9d5c7ab2f3a9923e56274f4987c0cc0b63ce358b8477e1e872c7b43979aea26c7369805865755ee0159ee8e1986c8db35d3646671a727dbfbc282013584c4b61b20b5fdb713d45f56b3b97d5a1d481fcfe0f730915a0489a7d55e20df3875c90ac28bd705fc5b93d91ea35febd3bfd0f1240aaed84ac9b5bdf23078908360f0ca50df23343aa22fc2af6f6e0c5077ebd5ef668a7a81f628817feffa8feb757f884edd84da37b266eb397bdb345ac55c17c86bd4f6feaeb8b205817b4d71d91d6f14a59cc50735c9ee77f8836424e318f863eed2243b3819092d4646fe30f55a27e909c4764bf6dba86ebf562a1175ff823584308e040a69351085e8e156289804989b8287af378c8b4b9baf49ecf996648dd61e12109da096468796c830035b32378a7a8b81f802e224dbb98eb3f06fdb835a8f5f20ed5b5ff386a2461b473618bb478ba2b17eb2ba2090bd0f83ba17e3d27a4f77310896e68ffa3beba350d9858ac06e32501e30e036f88258dca010e26e81afb8e2f1049ab337cb199dc04eec97a3097fc44bb88209911cc2c730a9a59e0d395cda52dbe0ea9efe712915431f6d6ec3fb7637d57ea063aa3cd69eb6918f71da9f3448287f1e40e6f81c9fbb57936620cf77dca8bcb0555b0d2ff98982b8ba9f24426bbc27371a45a56304b14eecab2e28133bad5156fc95b061ed75ee4242645d773f9d3ead97c2ca88aae7f3403490d4ecb909be49cb67bc09aecede9025c3106f86b3973ddd0b1f4c8db49a11cdafd8abcf8a27f334f3b0f201fbd7cf4080d1be84ad2727c457630ebf0ebc6eb49166ac5b8a07182e311f18ef6022fe80aa9a3e2d95459f1b1a41fb838514d8791040840b92bb356d5f597ff4f152e9c539853898ef61de75691d222a524518559a5777f97bda102d75db6c9ad66d0ef4b014d7b458829b8ac99544677b2441c024259dde871df5637219ad4a074ae4e7f3348da79e97b0418e4b4c98b760c2488d120085905cd0ebb9fb29c3425e672d16389fc7d0c14df2a79140928f0f333834c8334f63874301e79ab28e00806e44ee1f39dce70b5867e3649848a306e9e45053750218290b05315b67498e42b301e31cd47b120aa145ee8263f96e4acb2364f8c95038ad501b24df7d943e9b60c038238c0c24cdffe315cc992526d0373f27ee27e19b5aff82499c99cf6883eae38cafae86f0b959a87147239c024f3f56ae83f36ff38de8baa888522f899f661f4a00e6a25bc04901065177766aed728391aab347b7783931c365cc34fb0e21f41f7300d7300e544b5720a08a6c2142d8229995cacd701c1f95835e239de855ec1c6f70aa021efe5c69301ca902ca9b2efde046e29de33cc395bb4b957a0eaa9686ee9d25cba75f30ce172df4768fa69b854eb01e1719d399b09ba8cf3940751ca50aab6706a80ab6e1c2620cad5a045ca28f052c9ac458f26cdf67ba73ece0ee8320960544ee97639e06bf3db96cb7e155b59a8dc9355e36ed32a5765ad7b31b434d0239db9e38580d0bc0137f78e40f6ca533bab54367b6d2169874675ee83a8b6c825b28783bb63273bd7bf7345dfdcaf814445a921e98c3b386fc5e99f59cdff255425949daf4814f9927151d9188045d5868b744edb8506ddc4d0bffd671d2cc1174d658c461ad6e1b0f4bf70215a56a85cd74087303814f15aa2fb6756cae1227d6231cb25fcb48a0b567f289e49414a1e913e53a7011ee12cd9382c70eea0904495407098a41e58625d020d82ec857cc2c4527718b14b634982efef201fa7e63ea5be7b14d52629b45609b931cbcad43eb89d6d8607aead395f3d706da13cd685228fd7ae9ce5feaf7a0bd7a193f8c1d50b0f5d322a75976bd3ba602b2ab32dd584d798e1afa7d64ea7164a435935878dd7d96b0999846597e1e9a0b1dad55cc0b6edae503a57f5048b0560e27965e120986e1f716245690c3291e4baba8690ef9e31cfc40434ea1602336a94ab00416763063a010dfd35ed957ad9ee2bcc523231008167e8acd6c12c133d86a944b81f89ed6683b7ad5815f2544641961b350f63050582edd2cdbcbd6219836c6d99e2639d4a8152ddc776d70b766cf083d9a3869e2afae186fe63c01fc4cad361b2f93192f9472b1dcf92e947d0e704789019d48f07d81348fabdca06b04de8aec29d50bbb02426bd2ad33a4de3a56b71fd708210b0216552d93464bf02f410ee2e0758f184f3d0935605a8384ad0d39d6d93bde51e87e608be6f48a13d1c570347905e5db9de9028edbeae76200996a6df0c844a3de1245ab5408de326aa16788a8121fdb6de00cacf4461a9964bb951d85ef312857d62c11f760385b5801c599136090b26f34684b88a040ca1e638712d5afba9c795a85686471d2e3b79577e5384b3f05970913cd73dba37e6f92fdf0153169030de12d955d0c4efcdec347121d4b5366b426c810545cc9feeab724b879a1f13888c537abfc651c4aabd94f45b48e1accaa70894666b0ff63d5cfdc0bdb5c5d5948ab93e66c2793f1cb1a6edc7b12bd91b0449781d4609af47b795b5636c96ca7dadb01306a3735c1aade52b04d1d1a9721e02703521cff897db3f6b03f9ed78fcea02af60532312e21148d82783e6f7d6adfbb0f06fd2f179345298caa3d1bd0deb15c94291789f0f79f19ac769234552c96442eaf92b8946592416dc1dd2fac981adecca6f43ac1e7051f87648c051dfa5e4065871edfa531bdac07f5767ef591ae3622ba2bf16605af1ab632f4bf565d2f347d08c27a75eddd830ee33f0912da7afb4242736f5505e311cc82d85ee76fe1b7145f6421e3efac9382578aa694287e06854f45a88405633eac147a0500f103c6ed2fa388ac6a9a45f60a0d72b951473bcdb8477c6bc2a6406f2bad0fec5cce549afc257204a510d4509f05528fb712ccea315776c95668a9d8ee0ff6b6b99e0ed279047e7e8406a97863a73d379d3dac99f93f00dcf385d0e3a92b9d7dfcb60f8592469d6e91ad3904496ef6aead8fd955771826f3942b7b53ec1b7c31a09ef690dbf70eee23bba9b470f6fc8204ebab288bb7f9b827126cc375b85e228847703b614973b7844c438f4efb0676886e9a72385a938896bec16ab9c51f340bbb42acbb3864fe43f759123f8b83e7e297d22bb4a4a4fe494a588aae6619b2fcfd281100dbcfb2c4731c5ce0cf7e48d23ca77f15ed1a0cb5610d66adde06f58e29bff199c007031c64eb6c1b48d5f6c3a0327018241f16ba59d1122b9967add037f9292307a3089384c283bd8e6e2bda96774b38727eb0b1dc6eafe30b156c6e85611ca51ca9931902c1c9716af728f1fba61a92035a04eb560f0571e1f1ea487809e02702b3741c95620b7e44c7bcb6217bc2392b8775ba53f6b2563b7ce409ed48c1b70785cdd2eaf88554e9996ba73425e0435b68b3eb0a2fd57247d8074c3efd841fff71eb849851df58a477ce982e8e7dc8e600a1f8d5c4ae106d187a7d4ed0d90dba90a16dce3a46d212b8972eaebdc037398a7e143fade063178f176d3aebb86fb0705177c5406d06127d9b60b5b34e2059860edc7599f6e36509503814d73df243d4d9bea692b99cf988cabe6848ecaaf05f10b37de5b0ce454df7b04b98dc68f0acced73c17ce545673b937cfe4658bae6835473eb0747d60ac4f43d632b20cda9fc4240a3973bb259cee5ff9019e85c4f1db20dbc3419be0fcb8b019ca33105d118215e1bbdd3cba5dde91f79590950661546f381f16719b9fee795700cb32c985d9e98f15f2b044f15e279d1114e9208703f6641ce6150ea9e832014e0863ef20cc4b1b1f9d5397e30eed5167d7c4580c0266fda7e72554c607161bce71f653dcca1f866e8bc2232f844342a5e79ccd2e951929e18f57c13d08a8f5c93b25d1424a87be7f9291675baa4900a6b186a2a818d7196bea0f1183f02e6761204eb5d51106578759ca7aa9b548d511b8a456af3586b3986f788765f382680033c7a34dc58723d1cc262a1e7861a833e89a472687a87d737765bf39933c0c49a40f0f5d42b78c0e86113275bb76f7b3efe2e98e092cd02110899beaeb28b0d3462e54e56306edc3d5b8a8b463119f967de14f309f5809b78d512f4ea938d38fed70d4d25a0693688836b1c99be2e40625b9d11c2b3647da834f2d3fcd58ae24d68aa14820b239c1dae936b218cf2e6a24162ac1321e3175d415acfe7e595c79303ce2dddc5a8d61e6362ac5a30d925539ff5ab76694305e5ee9ef9f8672c1bde346b0ed39f7a954f13eb7a8851d4584facfb6a90887f4b699e8e0ae6731f1e01f194b2427a19cc48d09962bb258ff932c4fd348de85318e486824a552a1300614b70fafe21d55b481c7867a1430eda5751d602770317827a66db345ccd537bd8bb2e570383430cee0ecf9c4cb316c69931b12c79124cc3a9d43d1dd58de2f40933b4f729c1811d824b60fd1a1d3c78bd7fb803d45960d099458792607c2cc0e5918ae6c33210ca0d6d55517124ed3bea17942f4432304f5c9b2cc84bd59d2bb05aed25afbc7a82907c87dae5fd3c0931d8f033a751951ed0eb7e8f93c704472eac243000fa7ffa71e3184e8c94817e6235899d606f17b4ad7ca8b38060c367d3e4941489d414374e0ffadbe7e3c755b42d190b6ac3133d2f447d0fa200861081d6b64ca4755353715bd0928ae76cc5a9ba33f0f50fd5b1737bd1736f2e488853613fd18704ac8a7ba9a49e3cc11ba9515b598d4acc885b28f5ce44db87d6c8bfe6b73f4d67a73f789c0c39144581f29e0ebbf6e877f55b839f59610905d239b17a43ff26cf0949c2fbf216bc1a313a73cdc53faf8b568785bfca0fe3aa2bdf6340d55d966b8641b4c51329e4e16f72c350790e5bd68186d131c3f93158032572c2400cf3794ddfb4a87006602577cda5f7a64b85c03d973efffcf83e7f6f5dc3dce99f2894375e575a133f160d81d6b12578d7c8b97a7970c7e6a998c783e592c5d15d10e0dce35604ce29b5090df2dd9561d602943863f2bd14428c83d3bb3911df46a08fb02bb08d8f8092574e89dcd72d76ef3278cf238006d0be8bd9d717cc2e76d749cc4a11ffab8c7f1148b69c9d18c218dbf433d92fd4d0c2695de9d79b5461a28a923fbd398ac4e7e713b392d915fc58a93c0ff035c401a73e77ea8b268f8493df6923b4db269ea5ef6b8f544aee92578bd67ce0b11e3b2af5273df53c92f9264bf98e7b390ce2600f131d3eb82527d6fd6936f32c23e9a5d8595b74681c9e802243c36e080a2e0fffd0d36d6cd502e98badfda8a604df8b14dacaeaa4d8839a7f26b4628f2d48433ef44f971d6f477a2b60e4a19bfea9cf422387e9adadaf14507029ff08fd9fa72904f8f8ab2c1654e59f8b501444961864bf011cd870ad8d82c910badd025daec1883e1cc880eadbc001874cb8a94afa4fd4d824ccefbb21a77207dd43e98fd650a6103e098b69dff455cd54b95bb0d08f00344ec683b4dfcb028aafdc634f079b8721748b32b75c73dd54124f43faeb63da872fd1353e666fb267d55ae51e4d337636bd79edf28fc1dc8bfcc30b37e908349c93877361b17ed9a00a961fe324acffc989067991506c9ff76d80851ae1337c17f57cbf8c67ab4cf3cba64899e486b8bd78d14331d7bd8d2f1428a2e7b0e7952a88488638a670a5bceccdfec55595cd622e9c9d3b2d59eb447a5e6d7396143021174e5ac2357d75ab38f00c4c1bc5b2f1d0b2bc529c5b588cc09e9bfdbc0a6a3472984003f0ecfa990500895143b1e9fea64b7c715730ec70d5d55779b1c6dc01a8175bfbb6d726796c8a3fe942f341243f6739afcac5357b3a18f0f31777c9258ced6534f5b181a750cf476b4d20ca2820d0b08c388af96b7d80eff0b1fd16321c7a463b60d7c7d750d94ba69781c3a32722faa3525c71b4ea5cad9fda242fc4e2ac2a4985c8afaefcf247230bf7f8d9a4e36913f8fad949f13c873d3902715ba44b21dc8411b55d4d9af7095669599ea7ed2cdfb1543dd5bbfad0829d8955a3572f382fadcef298ae420a7cc482e1a3fc8fb7ff954f05d58f62fc4918dbbf28d075ad78338ab2c2447d4a200adbe563f9cb43c4e462bff53b8b310014b33c919e256513e9e5bd61e086e93e08d63b8765e16bee73733761ce297b7ba3f3e64a1536d775782ae1894f757bf061977b8953f51cb47bb107c4b7ac6f5378afe7a502456e9fbfdc8941a86d5ad7138c087488ab3339587b82b28d1f2002308ba7e0a80d63ec21d2c4f6ff254caf1e1500bd53e0463fe8eae55f07819b3eaa54b3968bf8168c7359740fc6527f958afb2ef049921af57e8a257b2687d71bb9b00dbd123bf9bf2242893c0169e181746b78829e99b7aaef3bd7cc29fd1321a645b31501491f8aeec8311e8be7ab4155e17e3d4c0ddde0e0267ad38843e41fc8389209853268294c06496048284c3d011172257ec281de82ac5135754c7f508a7efc56e3cd6be9c51bdd40aa4a4743cc830e6e6fa3bd1590988d0098a66733ce56abaf868fac513fe899b05c134d942e8e7055a674e70efd898bc24f0c3fc5e9f211445c6df06190ca2bb07fdea7cf2f6f581c2879dca20c5935dbc918210e016939097c67286ec58769e00e8390844f22af32c9ef0c59fc9203c25cf99b4b22ab3aafa6e702a0a2c36fafc636ab3475aa4a9db105a78cce2fee61f4fe3953f142f622c52623e8d44ede95eb2287b50ab4c3a3fda19983eb55028e317eead1397a3b1996d638f2ccd2ec24bd257ddfd679b4a2f24a933639c03ce104981fcac8a4bdd5181547bcb4a2d6420aadae13a2137336c51f5a3ab96ed568c2aac2f3f916c1153470362257c68d3c90bad71b95323db1a48aa81d8dbfa684d4495603c8fec08bcc3af7fdc78dded29b9d98ff2a9e72151ceb73f249053acd5c99d7ad80d5b8fcbf1e970daeb829c1691ee7b40c8eef0d7fb979497263d3e79781b865386a8d2b9dd029b0d55649bdf0c0e42df7ffd5ecd0f0ad584a8d00688353ee065a78c09e6cf5cfc2bf89a1bb22c0fecb04d08ce1e9d8571a163f3fec6185b4e29ad95a1b31acc0b6e3abd1b86b8fbdfdb15e741a45d549a6d8ae5a892c2454a3b1ae156aae9b6cd865898d184360299be2d501404c062a6285a94110ca59e323066dfcde77ec9f304a06aabbcc6ee43faa755b6be472f9bef2afe5024a54e51a75735c25eabb17e42f977d6d103cf4abe98f959b3d922da12b745a3e68e98ab613f4c98238087fe62c3bd81caa24a866376bfe0be2ab9366a91721601e0121931a9e0190b6f38060284950ba655cfab2a301607ae19418aa9210e08ff828ec097e716223d9156d6edf1be3132977667c281f4efe9133d2f8c31bcc859fc6ab3b7fbbccee7a738d731f16062786f78ae1eade3e64808d66d7036952e0290ab56b2664a36dd4643ac43ead13b8dbbf7f7ce2f4259cff39b767f78944676af6bb852916d305017586e3185da4280b851a98a7028ad264c9689c1013cd6431da593f8a7039fca32fba85828e66c2eafa64522bede1786dc6b90a235c78bfc2f855f3d9511850d0566b5900b6825d6cd57f4df1d5ea495b8ae24ad51cfd28769bb5190b11e9bda127e4570c480f7a17173a7dbc933866f680935bec581b61bf061760a6db2e767158d9f7f4bd4832c8064c2fe510e2ad48c06e04b4f520b9b8a490773ef2c83a8f5b8eb5b0e76d1112bba4abb07fa0d8247be7de984c2b2cf6320e5f37c1c8df5eedcf63bf4d0799f3631c7476cab77fd15d60fa49926a97437404b3475a63d0e67eb77426f6f27eec4daf58a8ba7faac19194a755072970c4f60c53f95237b2ddf4688cee28731152721458aba4f209a72837ef7067010e9b3581e6ee19685ec5de4cc10fb005c4fe4cd70dc3b27d5b6d79c28b2abb554e81233040407fb720745338129dc2f0077d9ad175e536adc4c33813fd97f3149dd6ed9c261f98aff91000fe461921e1f402f7052f356beea166f579aac0f3731b076155b860ccb2e1d078e1281a325e21d1cc9d82d70c40a386b3db1dc6c12adfe719fb1d39320681dac7ce10ec35f97785d21825017ad8e9e506580994fab22512561923a0f8867486a6feb3274e78838322dbe505efdd9ebf8c31ddb742c66cf3bc3a25cfc18f5f6c88be8ba91409ceaba315e8bfa42883b04cd9b9306bc6eeb2bf147c69407605427ac6154ce361ea0a8bf698ed1e9f14177b38d701ef914d161814ecd28c554b23fc0a0698447920539aaa2a8cffba8f6cb91732a18212a43a5e7414cc3384975b561080e3e0f57df9ae7e4e14e105c3a0462bcf9109f17d39a04710b3bf47dbce129d3c968abc3e412f46603d10fb8abbc19a85260e757a1bf180d99dd2cf170c3a96b8a8f62df2cce075061a3e2b54e0ee0825bc3a66b31d21427b981d68a8d683df03b56f8481b7911eb2d9afc688c915467121cc5a889ee54219a36d8c8453ce60f1baca47cf4a072c52b29a578fb7f4f9d244701cd99b8d3719ca10492b406ecd70294a596ddbfe3551ebc05d8c6035e2590856081644328cd23658e4ef23b629e2d4cfc0a724bf8de3fede5468803c136ccb8158209b2c7f5f1d3b34148144373e6d86525b563eeb9fa2caaeb6ee548188e5e11c1f53958bed48a3d4d0d0f81e3cbeb8814eaa4393b4d6435931b507703104a688dae10167f2799127d8c5985a92e240e3d1198ed143ee3ed0456feecbad674fdfda963aebeabcb242a00878b8ff019c5addb9619ab13b2d3b1a2253a5966138099ff5e8b46b6f0627d72d76d571259623cc16988eb6a591f921dcec060f5cfa9459d0aa7f48059a89e03d1c8cd6fc92b63514a7cf10fd2042d63b0ba0f8055534a54644bb615f33cc9dadbbce6be105b70c5202e37c707f2050662646f5cbf5ccd48e347d76c1a13421f441e84c62874d11a79be73e4ab04cdee1288b5352b351ac75b6bf722cc6a0c718385fa7b8d6110e2247058e0a907821def1c0e840cc112ab226fc2f0fd8b637bd6980e95601aed17f35493360b72f56e6cc050f48f19e6ae9a462b577e7e39437fef481fe23be22d8578d20a03ad1af780a1b145bc24b06744852bc94a99afca08945f5e9e15ee68be8046bd5561dc51c3b43cfad4a60ee6be8e957ef9351a7bafb98e45e1035f6382b9882f64909b17cc29f36047c493b4cceb887803591ad06f0de067f606ba23a6ef828a2a8890d0dac4e583d9b721ccdb0595af279d3f3152a9c52d99e6e4091629b02a48deb7491784832948977e61a29a010b4fec5d980e28c6f8d8810135ccb5a5dc43712d03beeb36869d9352d8914e08a912460abb06304ba2c8cb5d46ff6f08c702c5692f9d533886ca6a74d732daf3634cee247721f6781b65d2bbf0a8e3bb6df5baf35fa8c31c1154b78e5ac6f1fbb74baae1ef6357adec76991cb7d147048a23b95b639c8c18c9b08bfbb2c46aa92e6bee3dec1643de246efde4b1c63103af3c22bdb127667bff2f996921bbb914a0ca225e8569b280c1458cf2c9a996d031ff1901b72d40bd03704c77e6f9d061ad16e6b45faf4ce18c905274a49968b4f2e2e1e0ef3296d4b8d3d37dd809f96f529374871b6a03f1c0439db22d17669d9c58a40daf22606d0c45e7d730b227dff31fa17bed03d7306c2010f1e64f6d3390469093a6ffca69331e5376979a5a8b204ece9b12f5adc89b35da3bee093bfbe4fc746a40e728a7fb6d0884471f45ecc0ed8e4fa13c8d6b9f42ec2aa55876d0c7b3985093d61e0b5c2fcc8688364f6b6a68d5c1add189dd82d5e5860c3b82b86532add05fc549ce22c07ed7d04d4d94e330584af7cfe7caaee937e1bf84b28f9813db151dac1d95168392557ff1ea804b242088db8c15c8e55d3fe9f4888ff44a393dac78e9e3d27736aa09437110ad1bf0ea9beec7037bb5dacf3a7bac19d79a209bb07337c548a21969aacbf9499eec1fce8ebbd606bcfda4da334d8ffdc485665a2290c6a4b82935dcb67dbd0ac4009f6adc79595c0a89eaa1f4201189b43822ce2fee135e850fcecbbb02b8e8ba85e95d234de19a4cce3a61ea5cd9aa6104ecae6d5f7109af8fc1c793d8c9cb78c32b07d9f4acf7f6d8aa4b2c9c4b84dcd512e348f0adf5ca315d7a208014107a13b0e8cff72273bfa972f9df156af443cd511f4f96f44b6607f5f3a660638895174775c6c18f49f26d70d8a9e5b23c950f8aa2721f64f909a91b288fda4291b19967f843bb66927acc14fe362c0d2aa597f2d2be557f5ed1c8afc5a5089673c71b1c09e7368e899dc85f9bb9037452f6f8c133a919bf867508fc6663b209ee67546c1e0eb6393fd213a7eece4c3496a21b4242fb4e7b140e16447328600d2e8a80d82c14ca2641072191f5b95ef816e2a4a02353cc8aabc66011b895ad3901c7d8181bb7d51fec8d5487409dbe851e1c005bc60bcb0021085b797e797e2fbd630560872f31d0c903951f60a01d6be99fc7b9e442b577fd0c05e30ae6976319ba91fe972d5034f229c5cf41e7a83b1d31768014acde1cf8100a50f9c4a252e0a56be4d3ff151eb9d373768b0bbbd48729414f66582c61006840ea94d69b54534f7617294e9d831fd954b1c9152080f49e19b2a464193c3c57f030b8f826de9dd0afcf4b7f0494c5950cbc670af349719f55b10816606e37484311c64ecf8659b5f0e8052bdd93bd0ac71e5ad4fa08471dc02d1df64d8c42560f451df0fcff609a0a637f8398be97d1d5f63aa0b2d1d1f758e4f77f3a1ad96948e195e09c1ce8a067fe2d5ecf5d5101f7effba77a8cbae3266a4e6783e5927588cb0111770361e1beb32f3a7d6a79c5e913843c111ebe26697a3a67c139be62b11f78fbc9bd767f51fdbc4f138e5965bdabf00384848e72f16f2a58be2c9540b1d27983400267a65b5c9b20e334df209600bcff1b48f0218b9232ba596440a050e8866c073e2dfe2a5d4ee634504e561b50c0d67995978b5c0a3c2d004f2316a886d6fd21970620fd26884dc49dae4dcd17bfe2fcdbd402d2dca15364aebbbfb2462078bc799870ca84b6413b8996235a04819b018be57037a20c7daf79546159a0a786b9717b6c86ab78d8576d604ee8741d5a10cbb4190890fd6e3a8f2294f12feccd7f69f11d8adcbc4ada8e0e87e58866be2337ed7af7920cf7dd35a850ca03b6e6e3790d1ce2ebb5be576dfa7ad7222527a1a6645a218e26b4f88004464ae2af6b06bfe683686fa19f53","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
