<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"47b4a8f082e675adf95fce7e6db994c262c2cca58337511938ae8d60eae0fa2d08f3ecfb092a27fae1e00865985a6561040c5fedf979396efc58d015367cd8b4beafac0b98a58edba80e0c17c387f0bf31ceede70601a67c4be12103cd9493b1dd76172099889a257434271473548e719b8ae0d3bbf456f8da5e2406e4771b4ee668197453e0effbce19ad86b9126a074f7abdc2dcc8c28da7150a83627d881fc4b2b113bcf6a149879f33a4473a6e0aedbc09c2843eed2c674ce0bf4e6899d6caf0f592dff9c376e9cb5249615315cd4fecc4fb0de19aa36474dde115a5ab87a296d34b4477c5a8be34bbafc4201496d073e7cbf646d77605185dd228ee0906035d911abc9568ba5a79eca54b67b27800f492b431ff88bdefbb55651d4391b164fd347e4e58470ea59976c7df231aed6fa18cec102c69f505456d6d171ecd3490a079ddcb17a25e64bef0d26c62d0f4db6c8671e64c3edfcd5dae595707b74b08df3d1cbba0279dac63052fee91eaf62d8b3d84afdb3db70dc5945150bc8d9a97d3f476c574a6389e9b3f51132f7c823037bce885233278d23bb45ec14c5d6bb069eac323ca4d007a1da112d68e7afa44617bb16fb1d283dbc6b865161410192d808200a3afac4e52c4b8fcc615f5271634ae2fa0e2c46160a754c882326422aeb07ab9b0012beff2889914cdb5b21397e420eda1cb8571a3c4335463c6202e3950e10ec13fac9eee22892c18adb3c615fe9edd90e81fdb692455fe6e9915275500eeb2fbfdc3d0ab2357bff86e75b260c10c87600e7abbd2dde3511b18b54479c46da63f9ff93456e88170a7beeca061385aaa9061a5963565a6992c90a6ec95736527532cc17ec6729237f915b518b2d91cb78c10b24935773e62ac3c64df314cd850a8cf9363251a77aa5e671e139a18861525683db91a8e9694aed405af6a9d477ec84c0bc5d87c2dba1fb4a66cf0a0d05fdc5ea35fba123d77b4d7cd9a9538d12d60003417b90479b148d1f78ba53ca45e2c19b1af90078272e05e3ef165b0134bb2245dd32ed9f2a01181352789a4f5b4614632595d2aabde00302cc9f9a94ddfb5adfaa4a5a28525b5f6f1cb9e0c6856c3d00e65d8f312ade8bdeb6467bcce8fbc8f17dae42c813fecbf076dc327df36381eaa1549f96f63855b575d4d1ef81cdd04324e4e717d4066893464b3742362c3643e985083b94ece5ef857d7668a886a9fd5bc58b6b8228252616995211b87f60f57cbc2be79ea824d39c409e8617698b4d5912e3c1d5b590ba8a37a3626aa71cc374ab274cf42b12820abc59d01befd509297892ee3323e0f2f342482869cf34a0625458cdd4aa72daea50c2ff820de971831dc7feb1a5072077c6f2f380524ab3748db64dbb9e9b7fa55132874829ef1935eee7bb833f7531e3ef42af03508e2ac734028b3846d8d7c991b424a62b1a4bc4d67e65d5ffea0d124725ef9debedd9db66e3f4d4c0a4a3c7c5c3df478563df5c4d3e4df8206890f0fd586406701663af9e38ccf503c08e7cc713a68f326eb9189f63b9d77599fe7b9441c2cc6ca152e229e138fc0a516c42b5c93e21111977849d455eb3826f6b7ee503bdcdfcff85ba7360765804a5ffc608479653864770169e4f84b5b87d31c27464c80c2bd3417d9df6caabdab197b173d9d586f0e72a600e70ab464e28d96bd0803ad9a0e20f967a29b3d4e0eaddbc48f05ea00cafcde107716f25572964e1c143a736103ff8c5f7fb574ad61929ea79cd656f21829a6591c0d15676a12ae3d484b2c8b80f17df75d4a06fd3b119b1090eb2019e7fbeff5a72c174cd7cac2cf04fa3b24812f9e289b3b408490b0961a654cbebabc9ef3e4a3fe0baebf3b46141a76b3573f304fd8053da8b8d885216772f86c8dde553a8882f9e0aab0edd13d20c67bb2aecefc459abe27693319d44a57a5771fd6ff258e1c2e5e32ae3c999eb8b92ca2eb9e9f07831781ff9a733c2b60d5dcb07a664860f09eb18f86e7478f37344576a7edd57559c34c1ea8f069767403576a3bab50342a3416dbec4f5127fd5c28e719372d21aa0cd23eba70627ab40a560533bb9e0d5573e676892b3256bcce2b5f02f453143f798f6da8b8176692d3d41e28d8e5c0aa905c9124ab522a8cb49bc789341b3770d9037271655130e5d067a7882302fb5af5ee6b4932a9b88de4eff1398b3a9b4b1d423e717c79934b90e4dc5b2d8e3877f03d2f0b1d7416fd5b91dd17a91324d599a152dae8ee8f5b5762e5f1963104b5bb2c3afb8f50e39b0de5c2f688e82fded2491714df04e922039c2d49e83f29911ebac864af25fdb6382874b5c22fd4834c918d909a988654599ff52c872297e479e0f551ebad8030a2babc53adaf9f9aef03cfad6653e76c9a9e41171d92e5845814f50177aaa1ce737a55085d070e7871038d7798a29b82873c56b24a702bab88e73907fe9784c8fdb1a21059bf056b77df22e986c79e719f9f9ce6bfe7639a3aadcb618685debef4be35a58d34ef4baf686e82dff41d47dfd2b2a2eb8b7a6a69459d8cb1941aec6c24a184f44b404929939ce6605af8c2df7823b9f9ccf1c8482e8b7703a43df158b2583d00d7196c1496dbc42feae7a1bf2ddac6542e5a9e6cbcf7d865d7ae4548f87b2c93c491bf2327a755f59c81b4e8e34b2f8da30f385aa194384d1ab70663adffffeaec2e3704ddbca59b820cf9be82d5e894d67d366adb1f2be07b12ced64954cdc9a8b780b2270d24a37fc7c5cedee2221d74b62a6de8d5935e894a084ac7e69fd57268866bc19a4a0be2c090502a3c89b4adb2753fd49670ef15731038d0bf7bc5b31a1f8c259d08e05e32ff35e0fb5c61d35bb6063dce642a0f1777a3e5ef33ac9d8f3920428fd1e36f15bdf36bbfc7cd6fc7494c5b7b149fbeb5d9778514b3f63629af20583f63241fb9a4d04af3417d872b509b8b9220f4e72d92c6c532cc80edaae6e00e512d0f57cd4185151db776b038b6dd620997bbc124474802b14a97c6bdbf7cfd199411c91233b061ab744f8f9217d69daba59095ea61efb33eaa6ff0c253411e023691a3ca3932e5b303cbd1743943af00764dbace4de90cf3095ed29367f2c3fb0032e473cf83a80d356b6f21e03763c92f4b79aea74f77597bfb6261cf7e5ecde71a40afae98d991965bf891828a8484b944095db24083ad237886cdcc3fab908bb819bf0e5f78a4bc80cd36941102b2f45cf005faa7a7ef7933029772a32d6ec1a370ab11f991cda6f7d00ffdb214f130ada43371b633095b5689115355741c8350e0ab64814af7854774ed86c63252cc4093ebf79375eb98c9e360f04eddaaf9772f17884412a2b5109411ff84e177fc6fe72de88e40f05baf52b58eafe08eacdd4472703a4f2aec1ebe0ee256932c1c07665915f5a779a942c931e8885401cc5c1a1b1fcf2bb2aeb855926fbf817590311dd9346b8e9afba68a44596ec05cfae07df730b3bc6012f0f353ea93cf61175882d607a5277dd71429f0f767b103eb4c8f676a849b3189a07c724ae431a95071316c23e0e7fa4f6902592e1a85c1605371ca2829296dbbe0e77b00753d034fa558fd672d74974b5dbee735277f073dbd0e135ef17f22e03f6bc0e2d919ac421f61c4180e686df9d9f64f58ec2c2dd122ea521bad80444c44c10dab32e88b58721ca26e67fa4be43de08b2e4988509fe0d88fe7f9b335f2012fcffb94977d4b359c204239231b0115e0613a6784985d6751fc97d50a531d2d995eafd43f6809383fd510d7872c06b4abd23e750575ae37148017b95db74479aca82ffa2b7043bcdf111dbd151ba6f40860643ca2ddbc96ad82e57dfec0bb5f7f7dca16f3d704b23f39a450e1259f4e81fc462d573d66e95e04004a65537bc0eef73246a0b810dafdc881505409f80bbf08ffd3fd72e47e69ede80475c920ee4eda561d539cfc72138d3093440bf3082bbf5def5372f2af6c6ed0c5f398dcd5d4f301b74efa5e52736a7d4c6e7e69f9cf7bce9830249e089ac7fe8607f9d364bd84462c9b8637c93a5ccefa91642f353a072eacc0c0c8f8a56eda1880d71e141448797fc217e90d533e8fe5d864727c30d1539af927442804c34bfdcdca77454f850b68f43fa2c7cc318d6376eea30354c26de3ba8277dac160cd80bb15d278ddbd863d69b14c96e58b7ae0dcf980c0c6358338fd70eeed24e888a075963e88c5484f3921ad1ed68f1a7183308290ca877bd080d3b28045dea2ac2ead054544bd27d9c40e6b24e59a3b302932710ebc8f5ff0502b0854cf5a4a37ef7bf5c1d343ad085734e769ac9c8bdd0addcd6d0a149b49ffeb1f5c06dc660fa239efa1ec3a0bd2412ee32ca7480c2f5379636d5055ada3399fb8e0e5894451f5fe96d21c7aa50fed8f5b0d122d082a20e70d1f05276dd04bd761ddb3b845a03a44bcd936064ed3287b41b84437293e42a027cc9ba3bce19a3d18785d73353185754c8e4f4aaa4c13792eb3108d2a6732f6b42e01674c1a158aba1080b38b53d2bef4b2789d958ee454f127c8c72df9758bf57a58ce79f243016fc20c66d21dbdb379f540ae7365956245df31f51acff96245806547bb8fb0d19fc626dd2d66ae8972327e3b6bb7bed9181fb0adf2e85ce16c65d559ae8c146470297be2a7d6c57a35adb12b8c274649d6229accf28202ad2e4c7e262b54d608bffadb3555c2f0cd1fce7343767a8d0aac85ced485c4d0c32f70e6481a3bb33cf7cac482efbc4a478ab70c0c80fe8c9f7f63cec6a97d0e056ee8b32c93ed45a35bb111a850c2ebcff35364c5c5b9fc0380e31ecdaac96102a9d68123cd71f58f701e308b288030f55d5ef21f9b9916006c8f6bbab0614560dc9430b6a9ce5d48743f943997a8cc054d1f7d3d04e5a9386428f8cdb6a82afa49eb6fe98caf77ba0e1fd2c3f64a71039231f224210eac3b4d61b932942bbb38b70820a9acfc6b04ad5af4183213371b1a29a68763f0a75bb99572deb239d0c50afbbf1086a8beb3d8ebe3ef7c1677327e38103cb05442354c59b916854bedea4042e4e650a53d1712a4983897198a084d93edcaba86dd7de02192b419d6906748b061b8285825dff33b1567968cc58b50cd4f2f373a34c5917de6cfa5102d7aa517913f4a2ce1c479774f981bb0b2adbded4b9908d2a7be37f6b3100a52d639187679828ca8be339979b3c00300bf09973afa7b8b35f162e0b184aebb7a0db984e1d014f8231df744b21ac291f1b8e2ff7401b1e1f183a5c48d3cf525316870edd7c5072c8acad6832f8676e4929b9c8dc498de9133e5481faa11fee6b98611d248454eea061b89c0141d911a62a2c9739347922e02655d8d4944b921af77fb08e00a9acc8eb96c78d33f4991783e2a71bc426ea1c893d5a4765eec855115674273430cac823c3aa7d03c460ff5fe39feb17c68a286be150da72cf7c4df7b73b59bf9724840b3d95d9f37e03dfa898ec065830d6f77047d3ab7eddc9f95d158301842c5fb545c84e356a621f147ba659bdfb0b3f352dbfe2411e4ddc9f74018aaf25b766da5495208be92704b0a095355e86373e6a3efec1f6027ca51cee1b485968915e13eae05eeef233a9145ba48ea4f9ae1e159974c31e74c121fa56c3892663a4d2a6dcfb86818b3265128ca2220bf9c1ff6edf4f104a6e25ca91a410b06302d98a5107b5ff2de167a54251b781522749c1048f5245bf8e289f88fa49cf5690d2801e48019a85dafc7fcf7435e10160509344d36c7851ff6f14d79feada961c91830cdcb77172966e76837f2a55e6e1fc855da1a2539b3e868b01949f20cc978f703e39ea1fd14bf2ef65ac79beadb3475b48a3206b557c594f585e5919d3a675b38609a9d24ca27c58c5fb081515f312e36cc2c0ec5b7e537519947b572fa9cec2679ea6ef7f80fbfcba4d0f2ad9af8855c44d31f9b72a000a259a906c12b5a8962f9ea6a9b55cd0cca92d096e2f4dd91a3fbd07a26ec4eab03e4b170df432cab827decf096106d705867689d4fd7f67ff29cf8814d99ba7c99b99716ff4955ac4bbf2a4a01860ef8138651fdbc9a3608662325bd5c6cf88ba1935aea183e775ae07c95cfbc7f239317e8f2d143af727d814763db4d284ff9acee91bda5a344993095e62068b622469e419df005ffe5e16e0ad5504188205e40fa64c3e7553ec1b2e042e8948a0219ee5a332ebad0617ce9015800cfac0e83549d90e5ba928da1a56321fbd7a7c2f6c2da8aa32fee01cdca62738096b423b1d4bd1694ba18bbb35cdb217e3816d2f2c55ea36c5058cef2f15e84e1bcadd3b6819890a1f8740131d3c51a77201d5799a30d2f78adcf794861a6563358b6ed161f47b9619b6ff6c5d3526772caa102def4661ece9fe07134e22c4e2800f1a453d6b999fd31131e708ddb19f3df704285da4cd4e129f6c567fab96fe017b42f6804718dfb2ef87f5adc48eecc67d245373b46d9fe1320cf75f42dd04d2bd39d645f23e36a65961565b7e1dd66a9f33c4634c786515c8094a1c37a512e9393e2a088eb1a7e8ab7ee07ad4555d6a08add1192e7e94ccf28b78649ef02697daf2b441ce7b0aef7bd61f83cd5cc9b7424a52cf473096f2f6b35f3004787691dfcb44c4e58c16f87713899d6bd6ccbae343304733619b12fbe6d4e6f1d7f13b18e9234c556d1b0f6f164166985feedb323f8794401a4047ef4785b7e84470879820720d9f9ea8f8060850faf1b4d600cbdddb90021dd863eb4bd67939b03a1e81b73f4aea1d7e7044441a7002e6ebe888d56e10f62b2a06d26b7bfc34213f32814ca3ab7909fce6f635dfea24dc765c8d0c16de67112a51fa442cde1987f4bee18d9cb6f6204254cdef9ec0402706962ac7d8013ffb8b822a7be48a5eeb3521052fc420c813e22704c538cabb4ceef84b12f0cd68e9c2a58906d1046f55d5e85e4f9bfdc5d3283a9eb4814367473144c56002ed3da42c868a7f22b7bc3b97bb54b1a0f56dc50ec5405d3c46303a56c59a2a8c0831fe6fa9ebd734be85e15241e86e11b9f2fa0b78e1f59559cefc32102b71e900701a8350372c2fe322dfabda53a32f485ed2a2e65bfe253757ee5487b7ef3231b5be1f15c60c70ea1d6083d1d33fc6092365b48db0bd7fcc74770c98d02e5d68fd371240283631e8a993cbe86b9baf0c49255930d8b2ae57986e26dd32df8142f64c806fcc4ff8557b6a12d3ba118430be6abbf05f40fed48523f964e3338588390e5e1c030a26085b6a1b64509e324b0c1304dff28a840186d27c0c3ba7fadddf14b94963031c86d2baf6f84605c842f9fffc27f0fb6e3e197c49fb5af2ea414d98575fb877774caae2bea31df6bad578c1183bc5720c0805fef5be83986e9e9a148702c75e565d4549bfe355c34050f77a4c080783c08044e619a2f9d15beceebf58352d273a20022382d6220995e64d5f67d2737ae92ce480d63f68feff61cec8773377318158a69a2689169291d9750641d23126523df8d3e4d53e48da90bb5ff8b3d5a160413dd2d46255d956e9684a59f5763cc99d23744bc91e1a35577a1122bfe58ba6a388275e41e4a0881686095c0ea0c92f5c3608371e6b9d3827b59cfbde7354e6e0028f453d47948a6de6007af50cdff38f065eb9ee546f90e9c3109fc892f9704fd4f085a4791cd4c1ac85be31529dd9284071efbfc8fb81182752fb71d5cd0c2c76a33bfbb8e14e2bfbce16cd37ae0c4732493d809cb5605425d1a33df1e544961a0e3a956fa15f14aef63f5caaf1989efb51e1e695a17d51a58e99efcdd3c26a10edc7a53ab1790045da5dabdfd26e510e8fc21c6d4af5a7ecb7ca0d884994704e8ef4c06be9ee439a6a75c910d6e78074617a0acba1268fa4f005c187928abaa8c8da05d57679b3ab3b1d7605d9cc127f4b5f11e7fe1ffc90142014a9dcacf2fc952b8732d986de200fc7bb0429d7bf0bc92308fce3bfbbd71710959ecb741369115705d397e36dd565706dcb1c6b9b84272bde57e6b1cacb202750d80256fc9a2f11b669cbe35f603b8f01885f0e414329a6abecc88aa9414c2c65025ac5376ccfb6d17802384c1f88f90efb91ae977494fec981d60fec2af2c2b8a333b5341a89666af260affd9accfe35a776227ad45559238b3a1ad075b31a3f8514a5eaa31234cdec744dc2cd1636400321e0e19a4a9b59b6717227ee30798c55128a612e487d9dec195dc9230452b366f73dc31ac7aa85d7a463b56be04c6b5e2e19653f3367f2d7d7d4ec77832b9675045fc3a4e96300f65d1275b70163a08100c395cede23e23e33403737b6e9712f31d4251c06335d64e6bccceb534a854fe2c326c37cdfedf4c723efdb7f3f550d24d3390da103fbfa0286005935ba3f7197c4138239ba1802d1e730a9d91bb2e9186d4e92f0a406e50c9afd1ad800cebdfe91cc9d08d8796ee74d85c0af55959057008defdbe9fade8130ee11fd50c2f987ac8acec214a06870b7eb17ef1ad11e68c8bfe089564703b2c05537cefc6823dc7ab332d6a82fa156242017ecc3c743f02541c6e6ea146636d4056ed90c942f928cb7d0b8ea8c24a5c2a1e6bdc1693717b3337404aacf18d026edba8463bf15145afc4053da2255decd11156d9c3b75bc2cab593a2d4d69571a6fd93c472001a0a0890353d86c5565e4f079177666262014389c1b36e3feeaa535dcdbcfb7f9fe2b43773a048ef590cc464316b1ae66f208482ad7ee9ebdec468202ff4d8f9d1cab79f31d2abdf162dbceb46b1fea7db8ce6701d4d8d1af67502d3d2aefbc4994a4b471bc8238ad5c48b82e92b9ccd85b7cca493d75e2d012d1a3eeccdb049d37cc0354bac5ddc9f60d96ed973bc2ff9ca58b3f8d0bbee5a71edcd3cba8348065f964331eedeb97aa6df94dae24f39d98f1c512b73993c6f2143ddd5eda7f3ac459b36303bb823c809fa9eea31ae718932132440713aae2f5729ab14b174c5db1c55e6cc76bfd1fe56b3d4a97be397b6dde758196d5eaf1e64d02e3a850adb0c754893f3794a17d810061bd38d5c2a3a9b02e33bbf388108b1363b4d44d40a5698403e5c0d8640f253ebb67a71bd044bafcaae8c4c3acf28788b45647995a0138c99a72a1d5d6156ae9b4ac57a696097a935f3bef32f45c3b155cec6a197d23d5e832117734443f87d1e7796addeb0267f088dd2222d3e08efc34bb859ac5e9701f75245d786b5411cfc30cbe99848d0aad86fe1b12d2af61c69fc46c0f49d541c1f10471dd3e0968f7fee12e11c6d440b2087dace8180956cf2e598c7c629600123fb55da8fd0105ddd28dd15ce3aa787c080264665659e58f4f68eca107cbefd0e9b6ed5065141dceb26a50338f0c37351420cee588afbf267e276aa075fc73af2892fe94a49a6bf16e7489dfb6dd7aee8850b0712906774ab65560d5e94670093a5dadefb3bf5141771f367bd7359cf645ddaed98088bd77ff01b0a246177055996f4edf691453f4cbfa55883fae3d7108f87ef545d9455163f494ede83c7f5708d885cd6b869766317467a926a6a1a16f0214ba1a2e07f05a2d6c082b0e28fded3dd94824cfa96ea7dc9f9fe6d29c4c71fe38ab3ff2226f7392ac16d1d8fa7d99ca522680f8ddd8f5add3ed075edf443ca99f1701b0865dbcc5c1b98c9802d7b8475642d39802219087153c706437fbb2e9c3fb360dec19c6e45671c8feba6a8c9578f7b1876d9019ae9a65683289492a6f3eaa128567c5ea64abf9ee9d6dd20453638b80182c538cc62649601204fbdde133d5555dac5b2ebbc857785c293d1f30b068e9931b7cf5e5e339ab271cd0b4a2a726b7f561fd4bc60bd3fa49f28583639972def8e130fb8045fc27cf3bdbfb1e6132a31ed4eba64a8658e9f9af80e6cc7494a045a46fd7c18736d416ef7ed2dbb6ac46174252182efdff288c4ee44a2132da1dc0da185bbfe20179135091ec879a326b2c3e0af7e178cde8a3ef1af1f6e83345e58985879c48f14d55d713e8733c2afd46d57d71691de8f80028b04f3223a2b9d34c23c71985eb2e226e898da4453bc456db9fef3cfbd446b28cbe139e2909d3448b10a15cd4899e121bed019dac54d5a4b5106e93073a0a52d0041a4b937ae9349558e7b3e2084ded6603dfa782a45efb4cfccb0209b0e25d956d327b5dde026cc992f1699462548134efd05cc974e507deba4271821ca5f469f8962643aae2ac3a3d13cb3457173ee6311ea377d09f44340ca8bff0e39a74340522b02f1eb667f2d1de23c181b8f3834c4de63bc2589bf0ae6aec9e56bd350843729f1aed9fe95d16de9bb6ec7b4fa9edf901cc6907d71542db81354bf2e6fd1724e5346fac3e71d838a4da505f817e1e25196f33b22f4fdf6bc71875182cde0f173897fba865c1f5df3dbcbf2dfe2d22da16766fa37803c6001d2231667423f3b30809fedc224d4f33c59454d02de276013a03b842687d36d651dfa90da5116f326e2d2298078e91c0411230b0955751561ad4809206d85620ebabad32ad2a6503d5921856c312518fe751b0679632f06170c06cbfa37e94d67716f0be8bfe3ebc1e6c2581598247e9b389727d59e198324102a31c362f41880bc8ca61f9431a0413d1e0fe8581d99991dd9ff32ad5cb7168c4ba712a702d171016456450c588817e2ae2e0659501336778050e75e495a614204c0d3d223cc129e8c0bdbf4ac8216bdab9188eadc568fb983f11bcc4518ebed5d27f17ac25f5c1bc6f0c064ef2f6d730f2854a54761189d897532476ee26a6dbe74e4729a14e9e836ca04d2648810384e473c1dbddf3f85958bc02ce692053467f4489b8c8a66675658a3668eec7d7666b4c994bf04e2b23ae8b1ff51f4947c7d15a4d0e601adcc4a360d1b7b4fb64ee6921a9caf12060b5f9f76b9f77c9b452953df8664a67c8339ef9214fc6a4192bf49940bcb5831d9e1698ed0b25953e49ad01f2c2b1fba29a0292585e7525d9657177baa0baec6474142ae78dc5b7dfc066c310639a8414ac226f9450959551ebfff59cf2cbc470312526b0bf453925ab5df3fc10857c04e1d8070619134802b8faf274c0dd3f5eefb9440e375f59bebd252f9ed8c02256d223936117e1a3766602acee2e0d77e97112a80e847da17eafac2124f440b23b27df0c26554ee950b39a2205a36dc82bc84c8fd26bc5eb2114cadc1ff76bb1f88030c6c82b58101bc1386f1d58c2832df62284ca24478c25ce4083ea3ff8352eb09ff695bd4303a169576837c263fc71b8f4babe20a29d67f1102bf3c35f82f493c05252b5a62688aaea6c9c5844e26dc5d1f8d02e488f27cdd39bc88910fd126144aba3e8bcd04cbbcb3ed4bb77f77cd9cba0a6f0751cba783f35664386a0288db2d6ad8c227d0bab1dd8953010d54d2d0b13d51aec6f0a8b39963cf01a0ec05913183a95c1418b68c8cd6fdae5abb2edf23695516c95cc943090a64ee378f513317b8c85bb09d4c7bc8994642de9fc6ad636894ba24f26c3a8c9fb0024ad955b44627fabdc918a16c1145c18f90f438e2b5d838ce9c81dd192ed7ad605a945c4861f1529b920395fa276d67e8ebc0be34c25b2e58a231d0f9ea4037020423c6eba473280a6f6e8ec1ab7700e10848aeff74bdfe6dd52e7756256d1f114fc640eb3610b4296934823bca2f836252e37a22865e7982cb077c00448f9a135959fd8d76ce0613505cb0aa0b2f380e83244e092dac5ef36b67546d17bab6ad2a5e167cc85c20728fc0f6c67472318464190f8634e1a752ad3d06a966f56c27fa28e90aaccdb5ef3eb857b470672454481c8df607bf62b8e1f39d5ac2fd237159a40fe9f687bcd9ab03ed809e32268a64547bb8060cd921ba884620d1fcbc3995089d9e21ef38a6b73429198b1f35caedc54a91060dba36cdf435876de4cad165e716cc4b6e33bc077dc07a4272abaf91baffc943417c5b14b4aeb6ebf3ac0cee7a434ffa59c0fc885bed0c343f1d20f840a431b46d67b74cc66ecfb60321ebb69b73c10d13060b9ad5cdcd57f9032fd38cc1368e3f66be99d45d7e2a809ef67efc39175c6d88c9d940d4df7fcd411db13a934c76b65a44d6e6c603192d354537c3c5b017ffb2b7dd818f40667fead4323f6a70eb9a4548e54189cdd55b83f810f0b4b280a468baf70f412b1ea4d2f352e9050112450ad4996114e7c0a94d28f217d0482b617cd6d2fa006ff93fcd0cf591ce5d48a0432e69615ad9b5840ffa291f5af99c7ff69c7354b860b31e382fa3f57bda5934c5abc0141323f029cb0a31f36afb703ddcb4e08728392a3dc45b0d2b99cd5866776d4826056d38d286f9fcf87d593973243409135e0b34d21593cac44a5db1dfbc970468ce278c98040c9a4ad9204cb5d6063fcdbc372cb9f4f7908f8cb394c0c9b0505d2b54dfdcc96a479be0d78d087f9467ed3201771406aff611aca0d570e6133a8c5d64f46848542fa5cd0a3cb5f4848e4aa4380867bb44f424dd7b17c6086504a5d5199abe5ea3b74e1e05914e829f3398ced0ec172d9262d7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
