<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0c40d4c26d60c4806c14c591669f95b501a1cd3560f4384e5943585e10b2204ed1ad804610c32159b299cf3913192b72268bb7b42ee7b4465c301998c9c3a24ee5f58d6c693e25f7598934e7e8b89b848a239e2f7e9d187c523aa99bd8f461a1c157c49e7ecc8f25f93d60108455e2755a98df37df7f57dcd1d5a85282c890c07a9dd436315af32a5ef3e9eea3c44680877400ff219cb4a1aa28db835e28fdaeefe7ae434be501b8b7fdc206b82fa85dfb033dfee3e653462ab8509e493fe5c4040d7bc7b926863cdd2a75aeb8b47b5c72e2c89c1bf26eb598600814856e0f2d72d4b50573b38310810e430a646c7c373c96ec561a4c59b0a38fe29c6ce9632a2d2caebcfef226273333d993b5c65014fc2438690a948df25892501d477708d141070b2b5142dabad0a3d5ef1cfabda4e2de90e680152891da735e694bf3842b59ff8099ce002203d9a4010cee63692ce7f09ef80a93d2fc80d442f602b32ba1ae63486b363b23850ebcb01b73ad494c6452578c7a96ef7dfedd326f79a69e397fd497985fea4e1fd6b6c0d87267938a79481de2297b22bb1ae4b622b1977feecbdbbbec82f203ab779351c67b457ed183807489f5dbf2ef68004067a62a2fd3d11a596b583efc23202fc2ad3a23fb1245001f8efe7529f31f10cc308928d0aae0d69da534fbe67ba52ebc8e1e0a659d72bb49a143821ae2eb258ad97bb9409c7031ecb3c9ef5e3f9350599022c2579f18488fc78d450d3f11bd10fefbf30e6f2099fe300e790724228fea4ced7311e61db811ed274538a169ac335342a54e29019bce91ca369b371fda467f5d99feb6e484b511c7a6bf71ada2ad3c0d534c20e74cb32164ae3e094b1e545dfc9f51947a669296fef7a3362ab750a83146c572a9a5fc4586474a5d5e15c4f114a1318a105dc704ecf72e1c32d850a5006aa76ea220adf3fd39acca56c6840541255fecfaf3bb56110754f45f78c59d7372dbea5680c0154c7a9118702f5e080f4c76e03b6c73784a5d905d84b56b7a55f0e8093c4e2d3b2a2f2f1139ad06656e6bc708a35cb9be411f8ae89f518dbbce22e6b7d6289d0ce791b4b9f1016416508a5bfe2f3138791181eaf1986dba2c75aee47b5e9270d10d572645e507c985cfd5aaddaca2f64ce0f1c1acbcb972ea43d818719efdada454f5aca008fc4d46db29291d31ffc8a6930af905b770901e6478631362d91133abe18cc11a47d4b6a69030297d95f1213018f4678b271f4342e698ffeb3aea9ec3c3e957a7b624876cbbf820f63e7f9460e0e3eea2c1f0dca1263ca6517fcb1260d839c9263766b920f3d4eda25dc983d92f909ff2c8e85ebc9e03ae4417df489821ad9cba15654019ef1eeae7a35f8c64e8936bff4808b01e35327c5a93d8766104187febbd5139233f347ea55945aa7d58537e27c7b5dabaed8b65a1c472b08f7ebda8c83cfa1965ef2fa3a826ab1b6264ab54abcd60719feed8c26a9792bdfdd1a06a778149bc8af557fa9b03fbd1988fa21d3d76eb30641514d1e6b156880bf706e9c06bc9cc2566b8d4bf5fa251cad3b1c7d916a6ec469e6bed98090afd8e8596b22925bd99a12b21de584cbf8ecea1f205f9e16b65447f70e919dc7268cabeaf5813cd359d33afa45c518b7289fe956f5047bb55bd76eea48c57ed18e4766aafcd6c162b37af5a429d260a2d7b25fda5380c076c63a89a13ec0d8df6da2b1d4cfdae7f831fefead943ad67f9b13e7a4e17704d40219f90c7ae9fb0fa86c17c3ad2ae316b2f885e37d49e9589588c920f884053f94856511b50619b74edc882d0499398662f296201c178ce5cc7e7e98e5d9ca29e72410d566b171795e6bcbeb75d455afe2980ec9e54c5a252e6cc455e42150a5ab501c43ad20e75c6240eba7258d54bbd58ca0ffaf36930b0cabf6a62fe2cfef8988d16d405193d9f497d140803b4359fd8da32322f07ec3cccbd554b1fc48529c6576992429a79d3ea272cc9ff883526870fa47ca1e596112fa45438c7c4ecd009d5eb5322baab8c32e310cad297e1b995c3b49db9dc3a0078fbb702786ce4df6bf57a56d857757ca954bc2dde2a4f7d858b279e6ff516616bd2313b6b83471245c63fa7cb3e0e034cb87e99287baa8b2af0f5d3971e7e07ce9b6f1b6f91e5585b52bddd6c5934c67f98a907d2f08e6ff18e72a662ffe55b9a36766556d68f3c7ba951bb1a7173dcb5c7a7455a4751046b15bbd47c5c563a890105cf3610ea5fa40d4cdacd336e58e3a4593420390686379a6e03df44332feadccafc0709ed1def8000bef45af059aecc89b21633b333cd6750f3f53bfe91844cc6eadaa42871278e8a218e3c6989fc4408943890f89895f471c92b7f2e5545288dc8fe15ac64010f26192fddbfecc2c6f126700a6ceec54c32f41a78c3f896872e68b51994364e49ff7e4771a88001ca636235269415d21468158ee49e73be5b77463156670864eb45fc62dd8d7eea098f3c3e09be9a3e05c6432da4eda73d199ed0613d2ee52354ae4e575fefe2a5d50014c04d948a1f77c00754d0043b78f4aea4cb0493c715f5ca76385e63e1e82bdcfbec5db1466b98011a8f82dce88639cb78839d1024a134c2a149456a6fd4dff422b9ddf6dbaf613d4df5484a2e70b6f2c49665386a0848b42eb1bc80745e1f53c3b165ef8df46a884db6a2a8a42ed6959e5a0e0f1f781a0a8d4fe8b817feefa79f572f8e66088e0d494f0c6184ba09b2e8cac80797f0530c2491afc7de407ac150a6585643f5c6fae0d1939061bf11b09a0a2de5bebe6c10a6ddf571331fdbf1939fca0760b1415e82b22097e309c449163ce3e09110a1a4971619d9f99fc14b5a3d27a89b6b3b3dec8006b5879d8a95dd199d8941b9f6262076265d683bdfea65e361fec1fe6c57e03da99f88376888cdf63be22fbf922943baf6fd10638b75ac771a52b1bfa67a1b46c8db6f53c58ed8ebbff268fb0686584ff937d7c420a1b0b0a2abfcad3296e6360cbb1affe178b55dd495d21c8217a473bc07715a8ca1f7ccbbdf5f2324dd55ea6056dfe93a12014b6469be7de2a0e8c48489a5fb63bbefb7aeb3ef7a81a567a7d0b447a0b9c6c42230091bcb96c5696fd820947b9d0139c1ad9002a3edf264bf94eef3ddfc76cd7d9eb8dfa3d7c1c0a1f16e1112bd6b777e32cf5e1cc1bf032ead5ed0091a65ade96d565d8c1eae44aeb5a9a05730677dc1e445e487e32118471712e8c0f78324b4833787bf3aa725a3441e0d100dd9426cb582d9b4943b014802f86632ca75fbeb3b747448f70296e55e7cde88a0d523c4d62ca4dcf9217e9a1c27626ed8a344d35f6ec7b6d40c3177bda2367767d60660dcf4463fda1bbfabb696cb834bb6210af25059e5b3d1097fbf4cfb65f7dbf2a3eac7a748c532dc23519f27eab6f48afb6ac40841fdfb5c106e7828d8833b45d71e0e47974a5a3b65d51d57861e77de3ae9cce7ef7a4457d0b1e3b7ae406314b52d782d31e65649e53e70328637385ede4aefea5c328641649e84b8b9be03350a2f2a82127db9ed27cdc2c831af3d3a049abfb7602f28dae74b1d89e970d46bd2f7959db95c73868564cb04c7a0e21487388ec812cd17e06dfad9dbb3ee248cf77aa25fe11832eea103abe16e214fd868947b067913668d3da4e036676626d21c0342c4f76f6804ab911975f09382c674fb689c6165ddf9cdee9e7a48f09e2262491f95bef272e9517c433c1c3045c76ad84eabbe6dec5a7bf25b4cbd6a2c4dd457e4751be7cb46fc4e714ac722cd8eba0fcc594e114d0eebf7c75e9b374d217a317f94884a3d2a214471120e291d00fef2e913c4964d5fce1b418ad797c94f9a64db5c98304b4ad23d13964429c532be1e007e67fdfb88d9ff9530b221da4d20f6d76ec447b8d6dc4516d0d0896a562e2f62e8e2cbb5ad3e5c795c1e67d64e4e3e13951ebd97ece44811722784c109806df26b0474ca58094e0ac419467d1c7a1df0de928b70327fda4da343cba0a843dbc9941be8398cb40c5bbc5be8840e27ac029db33e0db7f9dad830057848f2059930e9f4461793c63736eaf49d8a623d6253476ada314b18cf617a3b8cb8112b68a51b35a4da7e24ee408d7383a598858dbbe79ed3d8452c50dd8d9d6509c90ec54217d40a13562653b570e5f0ba3253f49daa115e9acb0a87f196ce78269e003ef679559b27a182801013fa1bc77b9714cece35d104be0316dbba6874d01954ffb505eda766ef810127901ff6b2f8811f99b8b15ef703968dd08d98237c1d23a4169cdbc9a2d4c3cac62986a83c13125ea50ef211b2035b8ae1ed957999b0b366df9ba6cfb41eebb2da2cc13a6d09d34c4b02a18353498623362b87720f96bdb5eab3cfced0d8967c32ff245f46f0878bf8e8a35bd9397717d05ac620bf47194b35d605e883e504def49034580cb772523d3dda4df4688cd06ce9aa9aa13f08ad7eccb8327abeb771511011add3bbe0c2b8bf4660e63120cdc501a2f2288d40fed51a21875309d5987448662efcf125e327bde4c14fc2c1a8d6f5685829fd297ee30b2d2675a9f6c9ef22b65ac9510522c351396b98941ccbf0be599c20c6ea6c87b6141caf5b9e937ed52fb4271c45fe4761a5ec2e2d6572d9e6601776a899a4692177a1f8a1f4848c984bc92a7dd0562119a7dbadc74246ccc6278b5e344de5b3d36bb42dd8ce1dc3f14b45d7bd2fd08a4b64d741c3d29105ccc2652fb05da6c9236d5e099722fdc1d9dd0edac812034aaba5494c5e678d3a34bedd98e8facb0e614d2ed0849844a545dd82b1ff292d85309bd6dfb0a2a0f3b53d4a20236589161a13f5fa0bbd46acdc60d12eb4a08dac2895128739cc4b27126f02978a1d762cc40a440c11d0c5eefb3fbd43081431a114ff79decb333618a80651beefbcd39663d2828a6c29a9a91573ac943464fa0a965a911aaee98a1d7e92e0c100f1f89affdc0a3751bf7b24bb02dd3f83266408423aae6451a6f8f13405803cd1889fa4a3faf870bb7236dca85b9b64a8046b84dd503631e5e4e62e18de1d92cefc88207e755bb6f9c13b689af934b6791e092b095cc8a0dd51d607413aa738e6c8d8c9c0ca8f0b5f936f384f920ef65f3cc2f49c91402b928a9622d2d31d05b54ceb81d22019921101ce0a95a4823a74cc9a75b54b8a93a63d3db6c4d87ae3d6c2949d45db4698575ad68fb16dd3352f04463eb86a7f9f785df8ef40b409afddd6ccda1f9042c9ed13d056cde15cfaf00e2e2b50c7277233d62221064462995a79c77fd6e20e167b052b42795161d59a9a43c042990b6ebdd87b9479160f250356f586e852df4f76d31a8a67c2f1d9673c942cd1e12aca2005bbdd0a9f45672c4beebca03e7a3b5e927c1d4754d959b2680d5d6c2e7bc6cac61547e35f616a0eb882442cdc0e16eb7b9040995747f6170386371859c0c897bbc8c8e14759e846855eb0efb821734eb601c15799ec1c1fa17e398a0c215d03190187c9ddc0956ea6a4cc586e70414a646b7956289be1c316e09aaca1e6097f7179fc548e4dcfac07aaa0326fc248ca0f89fdd1e588f46913b9a6afdb94ca080d14e2f6bee3be7688535583354490157088fb9cf6fbabf9a5f19f15f5fb61edaa44367b0829e1c65c765c0b2c9ab4b4759501b15ac34fd32ceb5e6cc7e152a7a95d10c5af99204e86dfb610abf46490ab4d5da768d1f837c82c2afbf88c51fa2f77b4d26f4bcd5710162256005fe69caef9c2ded79cb4c7a42a6942ac0cca6ea285c2ff822bc1150295fc88b5ce632d1b09e246476dfaba68ef097ebbd4314e89d82a0c0dca99560013e6eaaba3892dcf4d2d9c7a5d2f3b08b66e25afc217f39ddd89c8897007876ec3e849785b98f76cd2ef66fcbea853b94ae3b92846dbf500c51716e387286b525fe155d6af0f182e60ca23c6eb94d4c067ec36ef1bf266d750b95fc6b569633687b54f68b5c61a9d258cff676b70c4d4337ba846d1e914e18c5c0042c1d8a09bf5822106627f09b86d58e35e465e68351661358505c9caae881b60f75e230852bf35a7b2916c8ef033b806d12d18807fac60d65d3e9d4e82dd6cd17498a199045a3b450e14e7109f971e9022e8dfd40d4b1b1b2cd455cdc775617b43e83e8c34be15d2fc7f19573cbe69c024821fa022b58431a58031118533c568fc6adfe23081f1f219a770dd5092e036fe9ff84cb7a83295b280c78b480b7b66f1e488ded0b0cfbd912516f6df54d27bc2612fcd16cc037a12e102fd505b33be6a79eea33ac2516dd5227ca7a50365db7c31b322cf78c996e6f22ae1fbf383001d76b82e2b70d37ca2093e4472c818587b6c4904ee4f64a89b9a72cda587a3147557904a1a3c46c12d979ab0181dbecb4dafa67953e62a3c199c111b9fe682bc9b2647d5187cfbb79e81c5ac003f40a81e6c564b27f350f5a708aad1cef094c9d884ef1f3c89c2bf6df110bec0eef4005167ac3d02e37b4a79fea904ae7b6e6e199a9a856824e3915db8c85c6427022cb89362d9941f33e82d02c7b72726633fef368ae5555e675176bb16539dff8ef836f79d8519c9805829122ee124200d9921524acd569d2375d33b4a51b29cbfbde47edad62e8864d235b2a13cdc530ca79a499c1bbeaaa78d132510ed56a190c7b51cd815851f66c31ebd4d11f4a2975f33dd34fb2154536aaf907ab97506b961e719d0f9a3b0cb675e216358a6aa7e3b9c4c70c7b4db677a49c82d57f8993f9cd45596ca2aeeb8590bfebabcd430c832fd46595accdb8e44c7797ff633c793f844c768eb807faded4a88f5fa37c99ddff63798e7c9fb0d730c62207314eb129fca38e864a11da2d442212d8e77e12f97e9ed1e925e2a50318f93bf459052d5b727700af38a7366335861cb1993e9e612d1b6f41b1bbf14b0170fb111448c9df34d2437f0e15c620486ec961b80fdddebd7881d854390d267103b61c8881b0998aa01190646205dda7487b37548eec5369f385563f1ae34fbea9f20f3bb094f7d4c8e9b9c9ea2b1414900c2b1cb3a47f2d318486d86dd79935b867c0ea831afb16b24f90796cd4191f118c3d4ff79f1801822d27825707b70ebd804f713cffe3d6e1fbe69a835b2aac8b9f5b0ea259c2b10d23de1c8fcbcf7e1aaf3edbfe225e90a7b904797ba5d9f943cd9bccb288a66c227f45d52691ef8a6cbe8902197e85aa8455b27f2754e03d217149867ba3bd0a16c1d06e4722db1ac5457284561a64ba4c561ebd2808ca920f66ac78d5cb3f9e0800646d872c15ef4259a59f46b2b7cf959965f28eb9cc6fb8936e02a0fb671ebfaf41f08005e817268ae283afb38acfca3198ed4b4093b96e56d50ab2d250d5422a90db72e101cc66d2ee029db8032ff4534b98f4e711d88b34368c53db1bd5b575186a65f5d1bc4333256de0716cbf81b97d3728629ea9ab814318fb76f81e1fbb88623e151ddc1d1fc4d7cb5bf0b02896f1a8ecf6f5f8c8d9cbef56336635a254e32069d9423e5f9ca0af113d74ad960612de0b5a9e4c3dd9a62ad1cb3c39027b0b3e5b2f628cfb292d6754b3d216086abbc476711af9eaef00783665499b11da44e60f1f33d8fa8ef9b4fba1c667febf78cd4c440224af02331fbbb2014025487ca447aa2fb00c322b2c8c2987e040f5a682aa66300ba8a06cbda1b67269f89f70aee17dc653459dbcecd0c7533914fe05d74230e3b2b5e167eaacc402eb7751946f136d55699af6b2dc838a35879d02387e96adfd8a2a0bfb441e68b5e4c55e05d2f74c6a4d105fdfbd47fec0648d4d935981fda45aba9fe1407792d695bc67400883b6eea13d4ce06f8634a188d59346eadb1dccb7c55c87018b9da2bd6fc53770ab625e71152e2275f85f89d1a08f3580e3f82e21350c06ad9901e6fe4d4a97712e4cf468840f423e05ec4fa52c9fb17449b5d9f6332501a6dced38889c873171c881af35bfbdbb2cdcdd9bb0162932bdac44c8194d8e75ed504dfcccda62839a4caa1ffa0fa5649a530e3f36f642183a68b72d6300b5baac4ce861a1ef84a2ebfbbd612ea99b8c6a94c10161b5de62e2728230c224b4de1b0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
