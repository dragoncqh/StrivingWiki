<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c2895ef8817b1dbeb44899c7002e50d16f329747fd64c8c5703141cb725dab28d93f71a6758e6a13c4283df08e4b0536f8fd738b21bb2285a4b48effef86b9952f7ec64e10952aa0eb4d5dde588b466b1667213b939737ff0c5dced82eeab4498ed3e3c026be6294a6ff3e09b667a6d8345c3591687eafe180847e3277cfa737a2fcf6af1d2758c12bcf7dc910bf45e0cd2a9dfa23db61aebb178b3921e7985c5889f968bb85f1ab4f0a9a2de223b218d6c2817433511d14024906b9861eccd22a1b6f798146c989dd88ed324d3fd94219bcc112d54f1697cc6ba76ba0f40cee6dd774b7aeed70cba5e04cae901b090115c3caa5c2bfbe532dd54d7d64b8ba6a90bcc396c1b456f33cad774f186ecb856acd7ffd6f9efba0efd811e0a410c09260021e488883d7728204a148224d7d8f2698bc43bad92dbd857138f799f27b4560a008cb45d86f94e60987691b852cbc733bb8fd420770a61bc3bd18a60783d4c20fb982f3f07d7c28d6769fa0d916663898ae295ad7ad7777401c7b3454b3ccaa87c71f985385122989bc67e60709baccbccbdefaf3897a8176dbf28183ec374f48fc159709b6cfcb36bcd20c751874a37a582a73fc95e8ae68b220e1d6142d10cad90c5de2aa7f803aa9ef20a6166fca5ce03493d93b01afb5a7ac1ac6186765686921a88d1c19853679975425118566d007e57d7034197f306b8cf5d660baee554a72d6ead3a1fa76c65e38d648188b4b098bbdc255d9c90c10e697d4ddf7cdd5e3b8d5918f88e0b979243cd332e70cfaa66b9b002d91c5296f9cab94d57a68d78de3b4cb2c913b3b841404f73ac10106d67f0ebfd2cadc154397776706beb5979661b90acc5edd847c5e03a43a805931cebc3c3e4f7b7850f24f680cb9d78ef76674928741ddbb54798d4bbf7244e0b2cfad04c4b2a38633182e21eb7843d29b22eef3e4374969e47ecb57fc49ddfec9ef558ea78a458e91728ebe6feffaa3d24a81592a7e0ab9c21707c54184708abdcfe26fe48fca35cb28033545748db5493e5b5ac3bd7aff9769390d16155ab8e5fd03891ac657ef0d67c2a70532fcc8052f36a44027f52bc6bb751023b8bbd014aad34c8f23dec52608a019d55f46f70a7b4fddd783c69c189457756078214db4b318fe47663c5d63c307609842e8293c4a2f7e6e5f2aace02ebe26eeef25d388a241a0f07283734d029641aa80031238ffed9e4f0daeeade84d7a1821663b840d4effcf6cbbd1d8222595df2e206b638d1d5270c67798cfdefde25f4c2ae0f5ae908c3b0b07336d67e04193fa007ce7f390175759df4e3cc80fcfbdd1c3a53eaab2fddf79779ca4cbd0cbed3329ab6eda88ff288576bdc36379ed26e7d619e1fe59a0a952a548a74b40718bf8009620f1cd01a207de8501a79d667811ff2d9be8a9abfa4fccda8b1b9091a7ad70bf35d839e0bd636af0b5eb4cbe5b280eda2a1767d3a4d6f3cbfbf36ce5c8c507f6dc1aa99ebca31bd712b20d5157ee6677e2a2a01bad564c44ee71dbfff4a6e7ed6aff7b9509c4ab04f62106d1298c04fa151c212b4c919e3618d4f6defbed5795b78823a5917d557f50c3cca78b4a680ba4f5f43914a0f7c6c5488e35663d7a14d619fbea96e2338ac63f1504f9d0863fb43aad5a6b43370688b49512faa640f66056c2f22f611f047eebfc206dad01623f3bea26a0404f675e1d22067db6baa5cad9930cfbd011e7f79d1be2d194d413ff062a5597694249962891fc8780b7d682b0516956ca2f3093ff9c427d82d5851a490eeb10cf272ad2ceeb56ddaf6d34326f23b9d449ee0efc9612eb1dd84aad87ec0d9e9ab894e9b0d2f28e9a374af11363a5cef8d1cbc6d9c0f881c066aef687fbd13f0dfbb5e6c6b2fcaf58e949c494a3f2a038dd3959cea2da8e8278a9ff441b7da33bea6e85d1e8890d9b30473d870785684c61117764400b6b6dbc8bfcda47a681fd8fffbe97f331267f5fd516bcc2a0f35b30f45261daa542b9069a11645308c48296394fcb4ff04e67bfda2b588b0b3f0614276663c7ffe7e83a350d7b2ac72678decdd3c7a7a7c0a9e94216bf33af199ac2843aa4cbbe786c32c9d07814081babfb9733e293ce37ed6be9834da395c7b935ca68132793db3b7c3c4e638d612970f748e326eb9b7fb72e2c3b10e1b9c20313102597f78d4fd1e74d6ee4c2b46bf5b385f67786d088459404261b83dc9e12bfcce2c3d69ee6756336f5f54b5c57a3084c67d55372601e83916117b4ad2586819ccccacd3e429cf6e3e8839abbc3c4eae09e53eaddf8062f7fed274ebc10d04dc9c431ebd72c813c4ed31c0bb10478b0aa1a84a02a050e177c9a34bd867fb9b55da333fc9d5014ecca6450bc8c1e8f8ee467f9af7ce5635400c6e2ada82ce11a528ce1f860004d56ea9a15151162a351d5b30e1ba9c95f771d623262a43858153c001844cbb453301859e6e4406f85bc1fdf6cb80a413147a5f782ac38dc03cdd46873136e8d90e32e25c81ff6582606de3877e00df822311b68b8f02d5e3f374792a25cddcb574e99a79e888efe96455babfb25a01a074255011a28b5028b65460787ab6d2bccd8be769f2b69399aea2474cbfb06ca55e3d099c0048ec2bf640c9ea6a1cdb11a0f0021a97faa1e37e89b3f55bba0bf35be7a1dae90cf522156bca1d493bb8f109c1cf9313c2a137330b4fc22600a23e15df19d0ba52cfa581bafe9d432708b4d49c7aba7c24f9359a6d2b90259cb5ab3ba2f67c9f42348afc38c54999ce421315bb2618fea2e8bbb93f49d951b2c01f86da39213f8173f0b61a0517320f3973e70b3e1e995150e4190d09340d1c94f30468647fb2914dcd2594b61e36f202999bad8d9916191159d3fac7aa09b359758f6d36bc12f18c5b674bfdf8c4bc9a7abf3cf51b0f4dbf1c794dacb1f40d7b73e8ce9436ae27dd1ce56ee1e16142218f008a3894059bb6c55a3cd01071046764f65e521493cf628ea24ec9e8b087dc682c6baa1937f5242d0b2b68b67941822209ac9e74e40fd265d6aca34dc3fa129d96a5bbd1c7c4252f724d0201c3c2d4ae7c643a2ceaab2ca9cf430e3a0999255411de12718e4d073bb59001f18868f5afecd912b80c2654979a10d900e73b1ada6c717233afb9db264b48d2a25742fc465c8fa1dfcc3c8425a01cf2ee9a69468dd47e35728bf72086c4b67f7ca8b7e9304abc374694693ae46d74cd83ad8347dc150161abc510140134056241c2590715d0528582cdf07b4f7d4abbcc004b5e129ec9e7611a04d4311913190261295c885b5575203469155233db2a43d46dd0a55a2bf5e11321ce6f157958d10b563b1f0c869dc0209312205e2f1a32f9692474d5f4656defd9b170d30e7092b359be88a3386c3fea0366a1ea110f0ae080091d117ffedf54f436a961c71c286b23918aba0fec8a2271b5fd76d3b4020a364277e9127563ecee1db7516a7172aba282a7c2fa070f9befef77a5df4a20623417e5e24dff46740da6af2f684286b44e3f42935c1ce7e6ad42d928d82c657078fda8ed2f64227be8850dc95ba865e2542b19321567ac8cfad50459db4531ee9ec79967125ffb27f9a2a9292b526f52d3b65c9715f323ca77b27eee756fef94a8d4f5941f014ffe5cc1cc1249a1ea3155fc3f69ee20325c825125c151b49a9397bc699c95bc40c872feeaa0e745b75ad05f9e4d06ae157c9d769b401283040b849d6670b8efd17b4fe03943367850dc33c00ab58bd639900d71b533f5e5ce73a8a5534f166256edc3b021b6e2a089c8359d3271d2a565761cd3428a03a523c326243427027ca43e6c1dc66694d153df2ab40325eac9e23f4019251dbea89c10ced2e238d45b5814cd6562b4b8ae749c32dee2a78fbb77ffa906c112d679597193cac311796c5e2aaa9fd488a2627f7ea00f8e55ca2bfd0a66f09db9f18dfa319c8adc59a228af7667542c15b99d2aac961b940c5f1a33c4695f8948e927bc253b315884e66f7cd87be61ab101db986f7455b88163b6f779c3ec605ea641f58da1271726aca45d74af2f5a93a9a4b4bd342a7a58412d4c5276144f925cb6eb365ccb4a861fb796dbae0153c238657107b315546f12b7075b9b13686e67c50951bae8dbd40cb87d0c0dcf711c11be54682a80b4e88f99884f952ce1081de256885a200d10ec9fc34c96f1f40b438466062b47a52fb3a7547c91719218422ca8283e3f736c12225b3162f0fa406a7675207d207d49079a80b3b9643d2f7bd5d6426ec683d95ef528c2251a398f01c3bd5a6901cb0e6796e07598edfc3d21ed87082ae046e2364e11bd7f552b47eb2d21c0e09232e9969371fc89778b07e6c1a9949d1c57733b703134c9de0413992fe807a91c29df96d5a9e6d314ee0cccb7034940bba7fd4c829cb59d0111d502cd808841c0d9079a480cbf45165058d0ef9b79dbfd037dd57a1eea0e0f8306db8ede22db96f9c9458e527a69bd06765936f18eebbac84f4360bd434429f0aa4d07f0a5291d2f3889fe82e727393426008469e000af589e85dd93860c9fdc9a4605e9df62ee203fd66f192fa1f0e77f6be04f26a44dc2979e914ffbe5076846b00c7bb4276428f3b0218f49ac504c755cc02ecf628b4dbf131333cea6e1cd26bdb36fb380e40f09f64b2ff80895d6ff8c0de03982a5400a78db5d32d771c77eedbf2a238c664810daf50ea94b57749cd49cd9f0913619cd4b1d3061327cc3b264808c74695c78cc75983fc2c294c0ff14046d42c1b45942d85ca27c16545c4634a8238c7cfa74ff0100c59c7592f25d5be5b8fb7c757abba964e206a0c309bf4d5be3ac40a4662a2892b04c86a43489da037091a9687e23020ede3e31a27ac00d6233c0b5f4a245dc21102dcc2995d995e71bee10071a1cac97707ad2fea58fcf6de132d28493b79a24cb14bc54af0952d93f1768292ee7ba62ba20783b7b71cc218e5400ec3dccaef2b0e8224746f66687058b35ded78283908283e2b096de3fd832b530e0bf18b2f8e734ba39b1150922b665e21871d440fa5af6c04d40518ae7a21d60329ca8b8e982c766eabc6c23b396c1d6c8473bd6908263318d159b29a145d2b4bae5a725fffa541d8dadea5b16e74b0e63350010178353c63b44f8a2894d45a05c483cb3890adf20ba950ed94c0bb8ce2c82503ee3f2e6fd12f9094fdf2d056b987493056b7bef32acfb9d542d3a1f60ddc1220c348e230e7e252fe3045a1815341bc1c351bf81dc563fe4de26539001eac4d1197a3e79af2e1becdb0c7b05b3fdc0a3331f40f882472153bff4666daae3c2b73ff6936756b1bde1939445ed9fd948bb6dbe9c6ecfa0583a56da09f77705a8fd2abc139eace9858d964da893bef9e5d5c09ef3c137f615e190cdacc5b0ee28d50e4862ba2d14c161bbf9b41ec3f9b89d17074d665a4451572578bdb343f74256c0af78c6eeb26a0f6e3d6e6f6aff2ae7b939137fb95906e4f59a64776e249155fc264d9524853ef2e7389c829a5888b8747f9b5431ddc0a9f747a4372e60e46e92de2ed2314668d700d766567285ec63fe9e8d7e85ed17fbd748b451ce3be4957606466497237eba57f1272b0067b8ab577c08f1d1c792f601d472f3215139239dbfcbbf8fd0e2295691448e04c74c360046ecbbbf5f4836ae8471bccded355da7e1414778fe4e655a8578f97788f58fda36ede421f934f1b88b8f6fa901138f6cd60dcb72bbdbe7dddf305eb5aa5e1ed32692bd88eeb475cd09a5932ec95613e42b23ffc15c5897e3e016d376a75dd393c898a4173c31aa5058fc92a2aa1dba6dcda30fe0fd7e25f2db84269cd4e83a85a7adde42304e66be7310f06c399c5b0c17accd53db849a4ab4fc9eb370487e91ae24940b4f80e44d370a7a0a8a1098c37014a42710f9dda141c5db0ab369abccd67cf7120d536e5ac64844f2122f8982222839118308c7245dddcfa672f0ab7f4959a5500436174f33ec0d5288c9e50ebada8510ea15e4f2c28397a948ae0282874f97cbedd448e1ed8d1f441107d1cc8e72c33c96cfdd2c4466ae599f1fde47dd1f3b31ad1408c8968e2f60512abf987a2a99478e9686d0d0cc35530d7fab4195dab1e5417cda94c4b4233e56e9012065ce5cacc6621789c3c7a6f43b07be897da10d787a7e5b7c9d8703c705dc1d2f6be1332724ff8641a00dc6903a2eef438c000c6d74bd9ef31628af96699343bfd87f0dc6ebccbb5a574ad2b4e279fe1d8ad9954f6439995006747f366fe29b528e31009a9b890d1f30b527c13cd2a082b252ac4d6de468308294381b2fda8e5354089e004a598ebdbeae4df36373968695afb20f84cfa31c832fabcb3c96efa519c5e1f8ad2ea4bd34ab22aa2ecda35004948cedbadfcd215e33469936dff2a8adc47be2aa1004a7d1e86efab5da9a14597566367d80939ae25f56105c296f9ae27b07a34a9378b4d7fa40ecfae553c92c2445ab1192ce85880c06372f734ab53152103367a3b21b720c907827fe75c34a86d7c6da1a22cfa4770789ea2ecda38b24ee805192cf7684ab28a34ca13617a9826e487c21845302914e02e7aa790740bb603470478c358f543b9bd14ad3e97d13ef6049341a88d9906e24b0f0f68f3d673711ac711b9faf53b5f955af81c7f3346fd1accc1d6ba9994f276d0a71aa9b30c6c57d0ae837a33cee0c6b54aa0e268e20cad792c9133f5b1c1cb2c6a4cabe008ee22e95f654092dc3bcbcd910a5d26969e1c72ac1d84423aee5eda4c4ae5f0f4c4602d9ca47f44a86fa395980bca5286c8918ce371b50101862e26628804c7a807fb1ad222e10323d31235375c1a6ed9c4c51dad9a5c856629f44a8eb006cd1814e7464c34de1d3e97181bd87c542cb98259fe500bd1623df17c7167a35b337238621c4d758e710784f8c2666517aba9339eb17d14b9d5df976b52a0d72bdae8308bf3c1350262c940895309150810c9b48345bc569f2c8205d5904f9f08e4a30671c60b1dd30ff8aecc07a7f0613b5c42eef693d330a7e0a9043ac23a5570a598e4f9917b4363cc392af4ba879d286e661f770559b4f7c3d5e08f25ec81cd79920f57595f265d3356700094d205fe44ca675afdaf7df532a0deb70a30426c14a2a6dafbbc3a52643aa221e279c8b3a89817a2a19d18ff216386643b9b0c85c2e35bb048cf4406deaef93cc4fde6a961467ff98227879503ee739deed49ad9d436165a78ac7b4cce8a20c39a1cfdd8eef750c826ac13bc4d7f3184a62adc5b07a8e76f411c4eefe45c06cfef927a997954f6aa45a7430b07a3a89ed9642b61e0230d4a822fe285ea091260a78c6f32c8c0678dc2be46a239b710e7f9ffc31d573c4f862849b2c08570b98c69b8a835381f3cc4ab599cb48d53f2c5b7bd8471730c90b10e1ee615a1343b56756d428d09f9af195c1cf99e95c3045dbc50c51caac0cd870112022b60137b131396c54c7dc1efc2c7b5fa31f0bf1fe3cd3062a6fbb4848dcd19f8c12a2de81b20e0c6cdc2c5a90a7921f6cbf634cd4efe50da382f09a2f05767c0ca57b134c428c6119719919792585d41e9a8bd4bae8ddbb07df8a9c9556b53460370675b477eee3d8cfab2da26f9bd00ab5ee301d4ee5e262d3e476bdb1e9a942d4c7a5244268d99a3337f2a510b6b2243f82f391a59583320a8342e56c8cd2baf80390b9563b9c76b9f055c09625ca66d5d796613c8fc9d20c2b1705aba9ffe384a55f98fd4895c55c128190c068a832b06f293fbf5954263d05cd5deb9b8caedf715b736c5a9584085ced8d35ccd436dcb31650062ff44b33f7a70970f53e7758b58e6d5a369888fa1f032816ba88be6897c8f9eff101799f2c33fd75d61df63d0ba625f37fb7e9433a5a9bcf92729d46595cae80bf1ea2bbd4c8867aafe7e2f9eb46388e44d87f6a093f7374b18727f147e37db8c97d46bf7e1edd454dfa179df19c51baab1a4ed68316a00d5f6dcad0ea6118196c4c0db71ae70327385bb84118db77518ffbc5f5359237aebbdab20fa2073d3ab353951a87f535ce369f82e6d19dad18e7af42cc71e809e669f20a7b3b9438e4b5c1cfd123c7ed450f3b21a31ea4f58612e8ee1d3e654108372794dc86b1771275b9f0b288d9848ecf9b428c3de396a50de9200a424dc500e5c457ff96701cf5ea2942f97f5a005ecb776ebaea4400ae0f6676d38acbbbbecbe68fa7951bc6da083259e83f7ed0a84e286a2086e0d6ea65578c0ea43cfa9d7b3799c1ed43441924c60f549dfb4246e053b58876b6e0cb19ed7bfc1ce7886bc2ed0ee1eb3fbb35f26429941540a1b88f17c44905ede972c11fc417a0281f86d0f12f94b6c9b4d8e9c41a1a443ffd395068fd1949681875cd44312b33d55561b2b7f0fd6c09111ce16327e087760453f029d07b136fae2eaecabf28966bcbc57bcf6db9401fb8bc4f0c9c289fba7e1c5d8feb1bd526cfb0a61e1a9021dd8df220e1fbd05562e1435ca7728a0d68c9efbfab09676f741fbd4e201cb5309e7964caf9703af27dcee26b0061d0d444f492d2bb46d206f93120a24727d8b85733644efe7883e56f28e6dc048ea31c566b33c1802e358a8c2eb5c063d9ce82d8a5310b69a89d665a69c7bd5ad07cc408889707e57d48857d021d9e0a97cf6d28573e47a4ab473101c9853b7ce21730bb26bf38489ef274f7f040d146d17182b2cb2f1c9e393555ee8e28e661f4e06dfd9c094a97d18f7f7f756e7c2dcdec95f65053d3238d5c854056ebde695ded3582f13de7a2ce80d7bb2b4f7093e2f4f8dde4a115defe68b77f146d88a0d49150ab95a79dc12dbbb38a96ae2edd1d350d07712b06a128162c00989fdbf35a8984b785cc88c5caeb1f76cd20984d4d51d15b7019f314c96a904c47104ff7e4c41ee8ceada629db3718ab694195a1186bdcc856497b69059de603769fd0d5a2ed5edbbb5884bfa2ba21d79d6bea66361bc773becf726300b2d0a95a4440e8fe914ef34192a615743dbdd4ea1dae69a1f4aaa9efdf54714e586880737e2ab2b9ee219ed6b70388a248ba2cbb8ab805afad6438d0b49247b3d545fffb0cf178673cabad72d50d85f007e508bc6a1f40ec45e64fa94d8827e62404af60fd8d8c80bc29d82ff223d909d913e01dabafa043973bf825f98ee815dd660cd1c8f17774b2c1ee62af413354dbf4d3c971e5c0d5587227af8758bbc0a67f996025f5770068cee5ae9d73b21d9f0a48d81df0e5f7a66c0818eaa540dafd32643c0fd1f12ae6f08605a2df7bc538eb10510c71b8f72a07e8a33dea601e29baf022b7e237faf10b84e5cf7714e013ae44f9d6b58a6034124a54b60f40bc0368a02b37758c3012fd2aa3675d78f928c165e28f11a4fdd7032266b027518173a6c494829d2b6dc818ae90e6a1bcd2145cc0f9d7ab1c010ea3342ce893accc9031f8549d48bdb42bdde6a23d8f54697d2281f21846e81028befd87bc1c67a298c8a73245d4e7c707e56feb1313da0555813edff356c89eb957da198f23f7c5792e13da55bb8e48d05211e23540c20d54749c013d692940966898ea2553746317a6ae02f51bc3a07e2e9474b860b8699807936ee6f6f7fbafbc81e493366642919fc52422d768c578485b0e0ca4790fd84d276da531976f6d6b0929d37692a6ffb136c971d3d4a7f83526e2ec5b608d7b6979224c85ebd4e85aa2c68020f241747cbbd2b5433c410b4bbc6d5a362668c41d9492581c3fa0542a6d1e41ba8ac7cce274be2ef51d9071c813b943ff4727ee28b19c8698aae52385e462a55cccc532dd478b46ec5e97904a678d857051717c38b272149cf12ccd97288193cab53cf71dd50f54c469edd118e9ac67899e0f133930630372237491ca25d7f490e3bfd8ffc2709ab874d2e6a4ba79a6b507ee68ab1ee97f02085268efdffaa741b50eaf0a45e05458625b462df31f01ca90439025e9dc3a1a431d9a646c1dae5685c685217c64c39e1b787f9039ab4579f4b8aa82745bb8ff644faeef12675a446fb29d75651a4291742bf4a6181e55ba842023cd07aaf44a7e6df37fa91d9359bba732a2c5c7bcd68917254b8517c19b9515487b34ef81804922a75810f5e42ef9a8070acfd963542809d7a6f06f9cd63c6df73c52e3e0240040e59c5c1e0ed9f5c555133f8ce056dc3dc0def57aea3b9345ddbf72eb30ba5ecb553d924758c1e5e7551bdbaeff514f3deee0551083ac74f341b16c2c35cb2d363c86e1bc873c977b4b82ab223dbe4724c3c801bce2ad9ad70694f9f79523c4255061813739fe72d72b29517d789bed4f18ff5c2738e989aea2d7ddea3368abd1f3d32f5f0dec0cef10c064a913566d7219c9b9597c5c2133bad9aaef08392c8bee0f074cb530e789301ffcc323f400ab3916db22b646732bb68c8c5224792604fed4f42633ad3c6abaee75f3364210b28c76ffa229ee73744a94fa24e475e083501b80193018d72f19522033beabd5c4540ac9c468fda56fa953d3e39031d8d91b8e6f3a63a0d8746a5e156d0bf6179ad4511c8335c3bb2726e72c43f96fe538017656793e58037929b89d075b7e230b6f718ad723f04773a018766b346f8ac5c27d90da3b19b87c3bf5f50befde7c479e17e0ffad15ca18f56f33030637cc3bc537d12f1cda76aebc6f38d6d1e3bdc576a2267923f2258ec8f753f291bb77b0fdfce14264b2ba734527b77efec5b3d8abc63b2a219d2aaa5d46bd2804778d5888c99eb490c29957e1a96636f1935ba11267b9b24a7ddc0e728c27a8eb487ffd1447b3b11321e962b43f4837a0d2b5af95b3b6017dfaf17395e09bbda563e9f2babf4ed1e8357f07f5b9ad89066693ea470b82b72dcfdcbec3f73a73e572ecb7554f9e18e808b1052214e329f4b522efe7b9ce39bc552c8bfb19729c23b32f85596edb40667af8723b295287d52e60098512a8deed369c6faf5593ec49f93420515d5e9baf3c0f5cf35f1e6fe6744abc437c22d2ba064d7b33b23abe6a881b2a6744f611d573cac44a58aa1391d8306903a5a995af548f014a9515065a6d542d4f4748da2d961bc959aa7ea03f1b011fd393987864fe297ccd94289127e6798c82ed4c74380303a505582dc8445007bf9b9ca6f45b2fc29cade714afac00150a3d2295a93770bb1eaa1f5388571e9c355670bb112e448ec7db3adc98af0766112ab7e6327d4d3397def0dafbcfa111e816836a71628be2a47116aa292fb9095325846a2a39f44cad4b301d783aa68e4311d9b2c90c121de3e9909adb1de8fc2997fa9d5d43608a6c19f87c4009092502c54d3ae68b169b75eaabef2cdcaaefcb1ecb9939df925188e101c1c1a658acf33ac661c5bd3cceb668b7afc68ac692ecaa0082466b88e0053d35adc6866324a91c423ea56260769eca040b2c607b944f234731942c969e52dcbd4293e5acce6347c50d692341ccf87a99db8dc17ae549e71600f47ffae34f7112fba762454f6da2cb7244c7973076b20b35bbf32ac00ffe937e24c5fa45c59892f93666bc23f8265fa68fab6c2156f652c6aa301e4027359b5f0cf5b17b85ff66ba433092fcac74069a48c90e166bf078066044dd526b848c7485e2a29d17aa1117f3b7f9d26fd0c72ceb69e15a6f4d4fe3c56e2b036d009d2dddf2ea75ea59b8368c4343a1e37cf7bc60be4ded0b446b4788c81d9de1e5c61bbfb3343906aea6a772ae333ced603feaab96c65abcea7dbbe2ef1c70aea725e0b8854b9fca7265866e79e16a679a33831d26ad4e9af03d0e97075269a69a86361aec0158543a3aca8ec2faf07ac7886e24a3a07652fc6a474b9f23fdb44041c710bbec1084d262e8139baf1ec7c98bef64ab47bad2d544096ed87ec9781b346f44e7560c6f51d521b897ef7f41f6a327c2b9ad1bbf0a234f46dd2d7443cbee24cf01fc05f20415e955840c322443e3ea589cc54578bdf49c6800e9a18ddfbfe2021f6628673d4802662670287ff3a15ac25dd00e36451327a4a2a361948cab12b458279f81fbaeda58510b315a1caaf970048a80a828c70d1d89303c3fd9e11af92cc2039b70cd2d41e45795a07d533565051ec3b2e40fe610f2966afd0a99b4d495b9c9599e0de1e8d5530c09f2013eac59afa0abf78b35aa8f677e35c6ddb674f5c4a73652d7ed43d763c89931fddae576c39ff6452626c17b5b109c14ad8bc5e4ad856000e65db92617ef46d5d20d0ba16c28ed1ca62ca850aee7eadc5696a385e2e0cff78e42e54e8bb7b328c4368784b8d986a3da75632ccba47a52a4ca6675c8bed262cb03cd80ff14fbae1282c2e6219e0ad9f29351838002788f1ec25e68ad76cc38d1d3fa94331df7a81d2c385ce81dfe3ccd56a37397bc9e20500373e68e30f38b1be294faffc6db0b19a4337eb9bfdcd8a57a73d271475a03fb508ba2637d0bf2f5da65dc3e7976e79dd7a486449a841e9b5a4c52e006694c8461e0e5e211922a86b03fd30a3e098425e5363b7d8c290efc0687a7877fd93e825a1dd0594d667c23b0b05b1c7c3e806f8da632d940bd5cc0aaaaa37c128dd7297ccaad91fd24b0ca057b17a20994b1430b5245de0df996e9860c9cbe6a54043de64813f904686b5f1b62badc2f9c9839c6310b6de6cd1c75b49f1456266abcb297806d0589727b54bc86157b4247b76cd53f48886472f50a29e8362056efae39c3717fce3d950b6879cff0c843adc08c263f2c5d1d771fd825a9e643cdbf4b6e608a9e37a9493b671172326a9d4f431df43704b343acd93eef055b83bd35b52a2291142b2c2ac8db70fede638389c8d8d470b0abb50260fc1cb1f048208f11939a6a6c74dc60f87b404de51b3378ddec741d8ee7a35a000867b69520eb817ccefa0b8df6cd95eaecfffbee74cdef4f5fcb6396cea224631db00ada965989ab2aa348879fd338357b109d4095cb95fa15bad53b49cf218edcf45df088b43789d687b210a26a30f5838f14c108dd9627e1133a33d15274ac90d19d1ae5ce69a07af73f1a3bde77eec5b9be3f1c41f04561acb624011e6a69fa2c5ea06341a3dad4d102814f9954d1619474212d04e98f23614c90edf7a671926c8b08e47908b6ec38457d1719fd0fc4c6bfda9bafc5b3e5e9941f2277548d6b565f163d4f4811850362a5db80a1e61ba4fa41ec98c228b6a462992df91424c6b709d3d02bc7ff407255224eaa96b2288a4f79faf7ff1f2e7301326351d6dd5ced08272d34ac11319afdb2f84ee9df8df398cde72c7014d8ee72bd8cbbb38f275128ca52b366174deb76ed1090004f513149602c1dcdcc908d85f957a6f4459bc20ef2a46b1db94fe1b328d211611d6c1b711233ed36ca83d6132666c6b4a68e0f0f7a2b66495f081ebba7bd9a7a19d2f4ef2a4b91951bdd91f780fbd12a32b67a74e1765ec802aad0747a4c854e0ee00cc05a8384878bbe693a5ddd3d97962c93e0506971b3e6fa250d3a673038ea22a120af751e359cc9befe83a094027533fbefe7e7213f08e3d6cef57b0ca36fcb4fb74cc94ba598dbc056674f9ed567592e208c57a683d0fb45a82c32c9fc505c73e78c67bea506d9c1ff7ba04174c2d8d77830d72514e72f5b0c11ca01cf7f11f4a173ad92d4ff1cd8e4afcba093d5ff1129ced6507ef8238e5574e5cdee60b4be6c0d04ad955c8999bfbaa741382ca0997f773468c11ca4690a893677dda98ffd5a36b1c63206d3fb0849b26bee1a5b614d22471fa47d7b0fcaa5771e120165fa8b28d080e44775189458c1581d2841677a3661921772c75184230706b550af819b90a91cc4d2eae364f4e7ab1b303f913c391a323616e528d3af4155864e51055f64d13f02a3f963d0c3b33427c1d0e5e3fdbf467cdb7601a6954f15658cae5f360a18c195b39660aec2232e33bb8ca9a3cd6c842f63860f94999ecb6921a44c4ceaf68762ea122070e181e7d2ff098e19cfaff2b54b526b53a0eec4bec97cba0a9b20b01c31688a2caabe0506ac783bdf73f4dc42f1cfb2325dd75bdd0e4e8143cbf3e3367f7b9168ae7ae776dd7cf4a5b409e972f01cc7e7c80f64fef7fa8f86c1b3a0ed77ca0096568cf61af5f907ac3538de416009481e98115dd99430545b5e9f610b212d9f0ff5e3309fcae5866cf2cbef0dd8de74cfa14c2ee2616b69fe8ea9fcaeb6f08a214b0262c1d4d03362364c534c7c38c395a58856826105546d3083ed409ff5f51064491f3063d821438ec35374b443e4215483f87faf9deadf7706c86fee89a7222a9b8d2472bc227d4e8e984e32645797cbdd75613eb773d0f2fa575d698aae8f1888234d2046888ccfd6d00c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
