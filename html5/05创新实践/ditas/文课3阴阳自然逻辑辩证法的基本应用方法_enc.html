<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8aad9646bca9912cd009cb5217dac0b34dacac324922fa9cfe98cd87888e573f217113adee926532ccee36aaaaafc4247b3d2bb406b1c0cc4ad4aff1c86ebb422cfe357adeec7337832137960caca43bb611fdae9aea2476e872597149a085eae54e135d2f0525f5ee6b7d46bd9764cf343632ff66ad66c798ea3982658eb8ea894e1de4559e2b0555db1f45168976c4920af63fb55da35341e1ff6e7a377a58dbcff66431619d17b6d0bb33866bd2f3ee67b854c53559276ed59abfff127210a27fcb48cd42e92aef720f32dfacb7600f1c10debeb90263df00fd740ddf628b9c843759c57f6e1531e9874006702fe777413fa887daef1592f57a98ec99c78827b1a96b4d8e33c1970a9fdc0708c089347e28473c49e8f305bc86c50ef6359afaef75d4311aa1ce64b3a2643815be56d4fd2cc6d0acd16d2afce3b1615591fb5f2c0fce2c7ea3201fcc59c416507cb54584d41bd479003be519b310975a63509ef9a28ba80759da4c2749f048452964b37b46f8c766b1ab1099cdd5463f69dcfc6c157f33742520669635ba532dcdd5c5706234a52dad4d64c289e8b5908132363f3f59ec77cb78dec21dc9e8139cb2fea12931add20a426ca1a255cda50f8655113905a88d80b2fdd78883d35a2171515a677170f36f8bb4f23349eeea83a1930ce80995700a5b330b603a4f8a02590a3385834efc6af07f9bdc4f9542f36c7d29475a22b173ead61617c5b160c7be3eb3386154764b3ef49ceedf9024d575d14f298882f9b8ddcfa3dfbb8afcc4783409389e30bc2ba15324a332cd5c73a82990c04f9ad8fcc0260ca366f5d6dfa009496f5b3bdf5214fdcff8c6548c86079db3c2039f13785dd9c4a126c3431a26ff187d7cf7ef17d96b5a1d0e5b1ac6a4c1ad1d14bf3fda55e5b72db7b411d7c851d0bf147e18941acdd7c3c04ca9b901c030bee9a1e205ef76786edaa5355f84395cb2f09496658306c9ac0afa5002f50ff1fcdac4ab3ea125d55e437ec029b308cc94cc632a62c080f54bf22f4a11ccd116357374b175e7b6dfd78f22e0756383740b4eb1e564d45cf6fcc1b3e78aa7918b2918784076a1dc5058a201ff9f5f34420438054e31af454955756e875d841e22f26300d344899c9cd5b0d4e543f75d5e5766b3d87ed7f669426481ecb1d4332c18a33e5e665983201b0204bf8455f61929f10af1ea539190f506edd8e5bd97d3190c6a5913dae4eb3eddd8edb93865c92f2af9bc6e7ba909ebd2216e6efd016597874c4d09c07247ed7d86583e563164ed28aef5d98f21e3a89b75fd21e070c284f8c4e395c828cd491db300e896cd543469c958fa6a52a6583528fe11254f5b2945a490917e74afd07c169b26413087d94f7df01a6dde94d07b70474468354d06b9901899db4d818e9208bfaa65cd190ba194937561878474961d7b0675813b44743c2632b13df0731720ee3d11c33a88a01d0364f2106f41c350e4f046da31e2d28ac30fd9f61154fc9e02382110440537d6500a4e411f569423a526b01f1f3d41f6d5c062229a15d2d74072f4c29d77a84f59d8b39b1765801311ce676aa2f9c416bfd8af2d3d4eed8dd160bfe6a0617c418b5c4059f7c4ae911ed0d32c7ee860bb8c6cfbe365134bb4e05ef933c33f5ea7f0e165db64109a537ed30b016d52d630a171613bda8c69f0f6a61ab3b6d1aa8e34c9bbdf70951103b2d468cf236e2a623093959cbcb0c6192140f034dcb9ebacf4a7d25b8f229d350fa38b2a95116f4d1c23fdb4fe5d7ff3e574916323c587c9130a9615b691cac872eaeea704924f3518bb986f550170791719b616b3075ab0d0d88d46be7ac4fd44f627b60a26ece038ff9d9ed3dd70370db182ebf6416fc5578cb71a73eb59bd660696abaea6f4bf0ae9ef516da9bbcdc796d7ececc5830b7d23ecf6e30f8e1b9976229b33d40a1309271f58ccd05603cbb7710278756e7403a8c1744e367479d9a3329b9fa7ded41817f6db1006659f81cf9dc061b5353f14a214e608bab00e368195fdc4b6f65676e8c7be816f275f67366fedf1d624b5b2651d4ede0a95f915eb81a3701a519199383611bdeb100183183125bd60a520a5f60b1457b8673cde27e879ba5bb1cf67bcbc2d0fc8859984427d5c829c41299ead30449f359f082e0237816cf5976ddfbf737eb383962b34930fa9659a9ad9e5f535a6eb93ebb06e9c26ce29cea5e0792cb3c70acf776bb6f03ef1dfee7ddb38a5714593bc218fcab5f5ad597511cb1560ec7f664d6ab248f0fc0ae06e724f4ff6376ca2ea7f020029d97912efd06f52fb77e96e18df2f1df743790e362b6c0ea25ace4952152baa4f619628c14a08d875c0a5426b9cec05224d1da2f70a25982321a9f38d1ab429c0b1c07a417a9bd5f522dc3a48731970b98ee621570ca38466b33a47be337edab2fd0d0a803ad246c928d1eaf69ebbd1263b35c6a7b9c29ac4d7146a6b1e1f3d945cc97abc57aaf0114a4ad8d13a4b5da2f1aec89fccc2294ce7b883098873f6e11a9121af9db4f4b1a2dddf110bad9c1dddbf0153634af3f65d6769a46f4dce7a44102ef607d4fe44aa3c24b845f0463d5c49a47974703cbc561e761f1dcfa4fd22f9e7a2585b1fb5d92225a1e75f362cc6dfb6d7add9f86645c15fc70cd530dca7929c002183bd7756fb6e6cc1f9707b644480cf8f278a294ac6ec8dabd57cb23cb12c965b1beb88155ac71f42ab9e88ba2008a7fe854f9c829fb361a5d123cc889a21b87639142e88d039a8597b4473407aafeddcf7b62c871bedddf0c68f7986c247db4792eda0cccc8b8ec4941488cfad7cc45988c0393c1907366feecce2988a6ffc3f9b856015ba72bb8fe78533283b618479bb740bed79093b48fa7a34c4b82ee5c5cfbfb73ad894a735ebd9e8a01c04acf316c0a70ae571825b5e278bc25dff90c6ed1eb8eb82a52e8bfef276660cb17f8e3e3718f3b3320f6c9eee46ab673dc109ae5c83adbe8556546e825905861e36378b806437d8a0bfffc3b3a4873618518641a97d4a6d2e871bda6a7d2fbf598caa041d28df17afd553b51ee4cd503f0fd745f46924ffae9a7cad8a8e6e5aa941db1d02441fc9d9a8302d0d5b6a5dfad50766599fac84811189745257f21e3730dab6ba9417fb7b0e063220b57921ab4fe576e289fabecb0990cb51d5e6c996a7221d75587c88fdafca43053ca3d5fdf525271664880b97f476560ee426c868a91e3015ff7ef572035c3db8143cbfc497d3a6cb9fc7ba0a725b039d9c722d2f7e46c632da50efb1e7fb42682c86ed6617238078ab5795a90ba9d487a8c0abdbb70e4b0471be5b78f8daae332bf92e87b3ea914d091542c66ca1f1895fcb65d0e9da0d645b0a31e86ddf063a800c857a54805dfcbc8427dea2f64586399a29322f1c1ae080c87c08e477632e2203203c89957f7c552f8e13f17a2edb6c5f2a58363dc8c3c8eaa3b9160316bd1995367f653270c85bbefdf3e1b2ac708b22558016c4e5c1fb630c0a21af552523d3304092ab49912dced9d25c0623696622e2d7c5f8a4a9daad4979e7bbc289bd6e46583dad950c38b2bd7251b8cd8e69f231a7fa889d0e4263b9d94b9c3987e25ef0d448cac2d4baebc1d1c115ac49aec7468b9db17266dbe7034b71fe0c73b9e1bfc1babb3a877d716284e1bdd9ccd6e3706e0e7dcccb0efdfe6ac9a883ec471f3e4a569edc3a122339e7e2813e5c99ac1f491aa85a5f5b67eaf322c64c8615e6d4adff12e2a24470f60633d13c65e46439a4ae5256c849dfa0f1a6957b9a62b948126d87c5064b77b32ede3a60e2d3e685921c0f0e6363c34a51adcfcc5eb86e04cb49c91099adb07e322e3b52472fb2d8bb13e66101d6a9316026e9e60e2be1b0eb0dc3198e24b3c642134998e84346f32b7dfac872ae885a6653b93ba9cde79f21fc865583c69e20250041c0a80613d7e77199e939f39ff757c424344ac8a3db2cdb51130cc83af329021004e682f5d35ac7dd8d0141d21c0d27bd3c58184014075e21f92d2f2dacea6bd717d959bddfc97a6c7d41e5121c9d925adfdfbd77b146eca5990fdbdd08ddc1163483fb0a03eb49df23b844cf2e83f67b2a40edfc477cc917480c1d46f086c1294ca455d27735a75d67d4cc1325f638432517cfd623d3ee5b34f091336dd31037764f3215b5013a6759d13aadc45cf8d8b5c3bdbf43181a12641ae16b42b19ff8b75d0106841b3d2757496f53f6ae3e84db33ef04c00fd65fdf25b29057d5c065d0d59f087d39e4108375f4d5c9dd52f9967bf7d060055756685ea57cd2e1c257a23dd44d51f348faebf3bd3819346d0158b679511236889a54702f846010abb63c2509af96ab1da6aa6f6aea6432f5575d89863a469dc3b7a96dccbfd30f9c0185ea6e578f1f1e8989ab87588c8a3579bfa20606f48f6c48aea0893763d3f18b1143d68129ab948f92fcb3e92a075ac948acbe8dd5a3d46d9e724d034c2d3792b85f7796821573b76503326f4bfadc9b7992b7b9df99c8f5d999c1aa8c86b3e2583ebeffc4c5d4f76aec806163b190d411efaf60cb0fcb3ae9a46dc73c14cda2576e91d0e38270f9ab86fbbc95e74e68050bf2c1470db21421ecefd9c6bbbe00f103d44ce26073206adb3f04fab7276a679df8202a6776fc316247fe1a0ad6c2dc8fab19bbd75fdc70bd30c3f73fe8b97388901dea099ddf672d625a5a0019fc9d95d791bea8b12ba7fc743c2693d6e2686a6aaecc026ad67032ea318d3bde9db89596315ab1478a6145350a553a91e7a18f04e7fcfbda349154ac23498655f5279e8649bebf9093397f8ece4746d4feafd14bbdf78eaa191b3c26a2d84bfe7508f46f851c91a05b06ccd9fb69625911ef6b6b87236e0c4d4b032fdcc58f06050f98ba712a0d4f5e4d2390f30eafa9595e9d648a6bd5210917833c48568e7f22f95f113aa6c72a61f1dcfdb14a35ef7c02567fecacbdd4d6350c19d73f2f480361c0acd195c948ae3cda4d4c1954ca8b5c53649183a193ca9e752745f82311a8e10799866ab9e76f21dbef02e96966c70959b9ee338a8711e59500a311835eae7d4b1a6d4254d76a81fdf64bc37439814d559da7c35e19b8b40ae49b3aaf577390bbaae9e369002b7a1af9dfc6d7ede6ce22ef620d2b255746649b42c15dba9848705d5f5ee8c8c064f94cbdc479ed53b9f3e89fc7980e66cfd58d02dacd7c2fa2530e5642923db2b662322ed35ffcb639c28ea282c59d21b64ba7d061057811f4e57ceaa7317365073072588742e0dd1e27479b2b3c98d55fbd02dc7d27d823399a9869107f009c04cc19263f828f12baaa958347d48fcee64cf12d80e211b1cd215815e997af3ce2dba42abc723cf094b8ca882e8e2e9bca5e046970dba1b4111bb93e84f314eb0e214997e0a872531156e6dbfc753481d0227e83300a1ad317b5f68a1989ae2ce407143b4d800efcdfb7f602395469d827eb18771c0841a7c13c35a8ea4c1c0dc1cc4ed3298e04805bc735411888aefe536b972e7609f882cc9fc19ebb5c17b9b8f37890b6d7df564841aff7dccafb636039117c39cc052f8a5b128fecc5f256dcc3ca3e6f59dc732ed009863e01e0d268d89c32641753c9fb675b3da3a902c4a4c647c7ea6d3e0d67e75801abe962a70c41a867da2fe594a5cfeceba8040c021e39210eda7d9eb6408703e52a1ed2bcd1328f7e0e3d17e82f1783d04c9070e678eca72a3a879e8ac94034f37468599532721a424e9485af8a4bafee51e13369ee571688621aeec2afeee6333f193ad960cbe2fd1fb5c2fcfbeb1f8ae5ce0ab64833381a6c3a8c7686ad17990f05a731724e96956e131801c46a677886e3e0d262fee997483478cc213f71a80b8c8c00bf4cdb77ccfc5e1945e9606ff5031f03c05f98b214e304775b661a6c6310758b0535e6433c8e82a4fc71def9607e43732b41c48c349079c1ed76d4d5ed8f2e99a3dd4bae3ac2ba835f4a5f75bf8cc12fa4cc2777584ffd67b902d837d814e4f0c246c5bb078b5b91399e08bd2f49c241c9ef8d5038ba1c3db9a1ae315196f2bf51ab258df34c9dafa861d9ae9f7c8e96a3714e5495e9068e7a17b03b71fd26d80a447b47f702f1cb0562741607e6b49377a20324bfa66ecbda65f5ab8541e7faf581477b88c52a9943c3e07e803ec478640133b616e39982a9d15104170a6307ce1aeeeea5387d7c2a4022f8b63ea3b96058f25e3577704c1e3274abe4aabb0c0d7a35d12760d95583c8161bc3aa93dcc99e1109faf210b97301ec0a44ce5f92ba5aaccb06f597ab939fe0232888cb499ce75b0f3c716a2b58970e94fbe3f55f2bb8ff26308926df32d6dae1682fa4064a736d17cc2203c48cba20b93bd2eb1751ff9d1ebecad6d1ebb2e0ffdbc33e595f10a438cf91ddf885fefae8c279f8cd31fc55471f683d6f0a48713839defaee4637d83e683ab2363a7b9c444fd2cddcdfc33aced0690c91b5bb58acb7af42eb37cebe948bb11a217a1e614a70c803e37c47e90fccfb5bdc4e10f0b03ca093113d2f55c5381e7dba3b30493b27bccd28e4d960ac1478115fd86efc2f225a902bc1170ecfb27dc36612c83a623d64e60e445f15cfdcf46f434cc6478c7547eebcef01c65646a3cab47d4d0107a59338335fd07f9eda5ed77c46fd032bcf1c8edeb8c671c3a05420fec30cf803b285790a04180609fdde278db03347bdc6342a8a905e4b23637718303d47209ed0bb101f47b3127fada227f66a43a1d52244732973c0eb52bdb422840ed1981e91223b764b20d68334d00a7c479de9182d57c86293994ff386ca3bc1a27ecc363c4040cef3edca3328137d60f808b2cd39ace7396ad50fe98ad77e8a6fe003c96d4a6b21201f45107ba7721be898b63c8496ceab2aa9502066205150004e22ed5bf6268eb26ff8e4d2d3942304b31507fc384ee2d70e95c3cb885c6b52fbdf068f07ef574b3f700df49a12a701bceccae5f8052dc924afe139485f5f462252ba4f12aa2d3929a48f5117db6b97311ab30d332d7e08f28886e06242f841a4aad17410e7041f18f57bce28a01dd34e7a5fdd3b733b74a39a75e1e8bcd5de27cbe9f7e01120c2ba30e12ef6b040f9a66f3d21bb3c9df613fc41638e213c43a6c30452cf9adcd1aa89c17504ffa8685bfa10ea43e972cba1c4a0cc348058c5184051d52597635bcbd991cd989c55a0dd162822c3fb4ada36675817fe4fde9a32bd281ce54b4da1fbd0d4ef7710c19008d93a4ebdb1827a9888974ba75bd5e080dbe414c6007a844b5c6bf4f775788f8f4b6229cc4a2353704a338c9a297057dc65f1eee05920c991ef4c2391f7fbcb7baff3da80c2bc5fe35b0cec79450ba3ff7f9d2594166282e8141a4bd4d67cace7e46cc29c519c2dc3e26b358db7941628b3091d8ecf3e3457336a255bc1965bf627f323af7dffc03291356adc1e97d761daf64fef3e6f0ea4e6408d9c29ad3d94b2849ddef5e6a24a54a4d0c2c6ac12bd5034bffdd5baea56e9a603806a01405c185372e3a4a560eedd4f9c7fe1c2127a1877e107f6bfab95cc8c13bb30447c9f6a4ed0a63d2376f4699b231ca8fc8ad0db549c007702481030719e64525f29805d4bcc49ac3d08c97a2e30d19fbeb2ed5273295bf67f2110137534b6f01233d4a2f7e1603ad5e4e78535c7e837836ffc1a55205fef6e14f21240084c24b8e0dbc3c93afe58df2ac01bd9fa42eeac97d7867f297f78c8555c49f4dc98ce1eba82e731feedd083cd1c51353a916a351aa162aa01fa6f77de99bf1b19c5cd749ee7b653f0349527b852457f9202856aaf15a17877ab684b8c4af0db58af26284ef95df8bbc8338f1a3dbbd1d0a08154829d2a786100498dca2b5c9bbfaf7cd3c76ad00fdf0203568b8d3655c1eed8527ca181138eb5e69c645b35ccc3d2ec6dc6620f59fe9a22de3ff81c51a4f4cf63e26cdf1607fdc0b2d9ffecd61079ea426030b2a23761ee8f4170d60647109fafd3bc0eac0f17abfcac18b01cd6dc199b1bc9ab886550e8b909fe2be5471a8fb6ba7b6db0b4ca6590a31c434b116c8b57e2c389491b5abf78acfa778db6a44d98b05657b0e333c43d627d77fae05b8af46d35ba1d73959901cd2bc460ff561c466edb509384656d89d545237635ea2513109028f9c80413abcce61bd31ea13921b2dbb453aa9b9d1f9ac5134af272dffe6ceaa676bc2221a3d66801eaa74ad09dc9fdcc4edf2fb59cbe7befffce701a7e6f1600d097f2a06c905293058d28177f300f1f1bb90d49d12c22f8d7e55ca05adc37bd29f8c90c5efd1dfcbaf505e880ec835a4fc767341828de4381e8824355ab3ad0c880104ea3f1e583d8be62fac4fbb5331289217a8f55365650b07237de23c137ebd3f5b042213b1045ff586d574ec3f89222281dd06ccc48a97ed409d6035634622d57699861237a0769c08b05b6d0eb2ddf1acfd8ed41533927a6677907da75f5f97f3c0fb0e879401de4fb1ec9d4e81d37fada90b7cc1ddd084e51abba8c455ec05c30213ea4980caac967f21dcf208657dcc21df51d0cd14573e1ff9f6bdfd82b70332237cf160a5890e056c235dfa860b4400ebec3b87fec09a40ed2c2a1d419f531eeb834acb00d196705851f3aa3dc816585902c781027c3022ed6109d394b776e5c34e765024d93e908215972ab73b1eabdd2d9adbca0bce10dc1235a5537c1e2d17d2eed7eedd9443b3de124bf226b21a3901e5dce01387d68808baa7a5cacc9e6dcef37c9dcca83e0f171f1a8a89bf9715b3c11f6409f1f2a6c0d6bb2e56045e6f257f4561e4f3855275aa60939bbdd3237ce5b9bb6d6972fbd224447ed9d4013df4c3c98b7439eba189ff501ad1a1784ccfa75e244d96f4f84881542b1bf691200ccd29400f15f4f53aa0eb7d68c1ec20380d08c0d12ca63157c1f45229187cfc3e63f250503a953fde6337b6c65a9a75b2f06631fde3d47fd17f4bce75877faacf5f645fef8999e9bbd62907f6a651ad4b32c4eb6615cad4a7c8f50863975a36cf0fd7ec16bb19129b50fd19918881d4f093a50d951efaf90aafdd0254675a9b626f297fdd219ba932097a6b2fea9922cffc6edba39ab57c1df606ec9b2a69ec7337c16ae0daf5c18ff54808264cf04d17ebbc22b74831a6cfb83fcefbc9c4c3910545de965b3703f14fd6d30d83bd7c2406b4f09792c7457bebd47867391c0e85dba3e8f4fbf4f250649951f8f6e5785fd1b9c092e9717c20de6a346110e6ba5d3c17647a60a458fccf6d06064bb62e43ed910aff1ea0f82cfb7dbca1b84fa04b727d43afa5eced8ea4a9337b5e7d194a9849a772d572b2d798526613f8cbe98c64fa37957630e2781dfb759da2bf53d006838fcc2176349d176f3fd9dc964802376752de727b353f1c28de35f7ebd14266d2b7026057082a32f1fe03236e4affc4377551b124773994f47eb88ceb3671f8458b5117e3159b89039c6b35ecbcb5aaf8eb9c3b3fd80b0ef39e98cfc1258ae5d3c805458bd3ef875dbbde9745f43b1bb104a83519cccfac85f8932366ce32498381642b5a36960089974ac8770c8e5b171cbb92da96db4d54987ccc0093eaf12c91f8e5d7a3c51b2fa21e3485a50cefac39942081d658d610a1666387b04f482a8cd9f0b470bc82c72fdc31d0d03088555d1e0c67dfcfc28b519bf5fa3828aaac6906ad9ca7db526f636f130fc84f6e015466db3cfc481f19828da65bed915c05b20f2d7e58625cb996e777891bcef2695412b6a51eb8ad321d71bb580bf3398ae6803b5ddda1b0258730391c3d83d530c9b426df32a874c68492e376d491e3316fbc3442af29ca44f7a4e975d52641f0ead80e9781ce427f10e0cff4bf66bb51c771905cec4d4226d33a9274f4d0dc66bd746972e9ce8fce4e5449c6aaa07b6e01ef022e96102101315e71028cc74cc1ea5992e5302ff9711787140a1e1e4a5c87cf4efb49e895c863b76704b0dd027c9370d3cce9d6957254a56b9575d6d8dd3fd51ce98254507f7a175677db607f931aa840f2feba51d89923babfe8c2f3f434c505068fdf325318e18123c434d58bd8673d5e78841da838f1bd7b57fc7b6ed8e9755ab5e3709b8abe596c22d66bec61ccb1bd5975acbd6c1193c05a045e96335f4dd195986bebba4def4eefc2fda4e47d7c0390dfe51154032c99443365cdce6b5b71ec9c2c7068e02c6375e830b895b429921fb0db1b3ad5100d29766697c578b9ffaa9879182575740a70cb3ed0214ee2e1236c12ce7eb1248c9bb16b1bf0020dffe1f1614ad72611db13314b36e8610e651475cd5bdaed38d40e4fdc17c78143e3d1a678b5f24fc70b6c959c9b5e6e2ea1696dff2e25eb72fb5166510dc33398c410ec9c557e5326eeda05ce35570e2b93f0021122b1bfdcc585b0ea302f6bee214fd6f4e2f921809927323b109df6eb811fe3f17358cda37f5e088d648e65c0c028627715f1a1e8bc806d63db4355cb90afc1b6035b84684b837f5688e5fc96b9b596a6e7d3125ac4d222aad68f9b2e93b9b49131089b54ec5772daecc14202f6c58759e43690aca861f8fd78d59f5fcbd5b0941b8459d2de688e2e56fa803d7b66b04b4dba87cef36af46f183c9444635738820ae06576e3bb3ad9edf81dbef1c9aec863bdfaf216c9d5cf65cd9423a8afc6d27bfef045025e215a9395e1da1f22ec2e9cc103c5ef188eead43bcffec6da24504859d660756a5d1fba57434874285567db70b846d7166b8bfaa75f66c4cc6e36f9f9d517ce40d717e8490b7741b4c9ad6ecae923d8b9311a1c63988333220cda7a41f20be92a37f8bd9ad7c2e1edf7b603cb6ec785d262ea884d6e333c847e58be9c8944b82fff1c636d74a9b052ab2c2da4660fc2dae28ad4e4380327573f6be8a374bbba5e5f194bd416ea1cd6c57e68bc05b23b89f10889afafab142cfec713cf0c10ea3ae7dc622d6d19946d3413f473a8d658709b0e59980a71ac40ba3cd999b20a6a1025684e725349606f79311c5df948c9674c3743e5abba0e5b2f77b79fa678f6afd17e610d9045b9bd77be212506183ba318233056a2d0eae2ce25000993c571110ddcc3b282b0d25ffb889276dd9ab238d7743574911f5e2bd3cb669a7c3194e5962ef020ad20ee9d8b83af3e8f7ca39ceb08ce602d11c4c9b997ff61d215d21f7be438f655c9338ff7788108ac4a015a4b9c01c6a5bd1a284c1513bb1c75a3062094d8442e6c8b03d27652023c195a816ec346a83c8a19c3ce50bc22e944df96066a1b07ec37c12fc6a902981f7768b6eb6565a26bb62217abf5955b1b762cc65f581604c88cea72a294de178b46f57b9844ecc4e32b79d6f97fad86f24f3df81a148323f177681da347fc65b63610803077ed70fcd63d640e8cac4124bf0424aa6f954b6af12fce8664ca32c3258fc93b196b74baa60182c0589728b89d51dd9b8febe1c0441c67c7884528fb19e85b761d11ce43facde145a97d92215e3f0130b40b7f42445a374c93320bd9788ff5d6bbe100510c2ec5e3da9b3eedac11a483fa847f1c2da1e58c4f019f2f362fee7391c69ff1966a1f358dee08330ca202f2bcec25d682ab5d8d6f979b53ab8d58eea2987065251a88471a60ea175f12af54f38baae7ccddefb5745614200cb7d29fe3b17e7dee378cb57184702a20542f026f040448324f57c7f822e75d946a257258e4604683f529d464732246b4e6413ce1813f008cd2526ebf1f5730ab0e7fd38d89efce934bd30c9429999cf1a97f5643b0adfec8e9f67d4afe5fd7734a38a2a5b88445f7ae830de79a1ddf180d6054e9853718903021b828689926e2d7335c2fcf0d5d3ba16c1df905f6b6fbc9060b1ce227f677d177a734ea2c3757c2465916ab47595d8552dbae73a6d0b43a67085998680a65711c1c49b5c0c72a4c609bd8ad3e3caf34ecc50ea9943f039e5bb6268b82418a755278aa2c3d00ba299f0c80f0b3ed35762073c34897693c856ec9b0fd1307aa1e919a7f84c5c6494796451febaab70b1066f4c61ac2575fd57da90c210683ae007c96811aaa2cd83c2e032bb6723855c705815003e983436c604d3837b71fd5dfa5522abd602db0f95f0524e38a1b4f9ad84fcca3587d49f8359c0440f8e941f5aabfcba9b9dfd101c0a132b6bd8633cd0c57755310a6fdba66e60e0d36dc08f6daf8b12387c97421122725325c3bfac0298a53ad474dba1e081d2785e8fafb60822ab66e26dd63569c3ba5264fefba9f7b755fe1cd439846ffa774c67a82b01850f489dd76128fbcdfd6c1c9289a8c8546192c84f3e023541e0fd31d5f9ad82644b954723af244730c0d59c654b77552c7aa05aab4aca81f639086d1a23a8d6a74d45a3d2211aa158799e37ca00f12723e6af4482e2ce06ebb0bfb63653b5c11d44587ae028286ef79da0c614f8fec3d914852df5ab96ceabd23b44ef308b76d1caf40ae7674f7952fd80ba68179b14322eee972fc0a8d87c1ea67310bae9ee705976cafa459b920129f667ec50b364eb6f700532474998dd3aa3c7b29f75b996b3eac815233a59c87d114fd98eb6dc943a95c5e0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
