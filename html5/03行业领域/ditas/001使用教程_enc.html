<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a7b2d6d5d14e1d30b9c125c11c4cd9a6cbafc419577e98c292130f4449e9327852aab6fbefc67211a75dada8fa6943c0e18b06c0072b7320d7fa15b9711a6155fc267d4eef1866270a1d5e7d61e79cb159bfdf6a73ceb252a7fb39a9720f5cee6c565709d6ebea612655f16245f45a8aa4fe302a9c90fae3baa5369d53520f7eda9c6fee1e7830deaec38f264d4acaefbcaf78d6a1708713ee0c7745f23eb481e8333703b0ff2a3faf6b9641275260e2693e2e9874f9b7bc1ce40cb42fe48664e1f17bc84bca082bbe0f3100c6d57f078c2f39042855f0298059e1cb4ead3f329df75bf1f7756df762a2474d4e0f65da7443a532187e43c996b6f0529f80b9c04678295b52d8bfe698cd8a6e7932579151718fe40dc6b30d65f0b657792175eb639ab78e6c666b7aa3b8ee7321872a0c2502bc3cb4b0072460322d77ccd863f94a7309b63db411ce967c2acd66b0d29ce738683d6b627c5efd7d778a12c3590ee468006bbceed254967ecb9fe1de7c96a09c935b786a7c97c9b1bc2523fd63572b2194b822a406f803522088f05c21fde5075d73d40d6a3675084e2215c8d73f775ff140e4bb2de3768c124a43addce8086a3c6df0cf311f0c05b684377c3116ea149a58a688397b0e273f409fe411f076cdf26bac1c06e488375a9a763b4f982f1931e1e5de2b932f7ca32381a1a3cb5c0adbc5c9bf5d42d14dfe20d5fe194d68da997e0373e1abfc39c369c865084bd7058e72518f1f67e6e60582bc894730f531c7905124ee9eb3ab390672939edf44645fa2d645a871bc91af543e9a73f00b1b38f59fc48281941d9b1985b0ba9e68daa7d0bf416056544cdc3ee0fa9134a7f592a2979dc9b9c173e4aa6fd03b09dadea05ab42985503c28b09f2834d054bf600325c5b639eeb919b4a454c57ff053a181cfede2f064e25dbd0f11a1c26f6d39ae113fa7f7dc6019f3ff35024a5f5ade784836c5b425765df5d22764ad8fb466ce9bab39c25d46a529c47e17e1a2bbea402161733b98f1f71836bbc858969994bf2655cccf138af9499ea0b5755637f7f86c35ce1a4712f0266c12c1ab1cbbfc3763d06a217389a341a5de3b0cb2638f2ae01abf9c739e75429274a741c18d34e92b35f5573b9da6ac80a66dc00d915f663f31bba54d78ef5bb1d3df389f287b3c4d6e17f800f69b461c4c51f67b977bc5004964e227803caba8c88ad9fece5a6dbbc4307f63a7ec531b38eb43431e3d13fa7e723453dcd6629fb3bfa16259a411483127d1191e20d6c1d770fc9162a9ce80b5f5020927b6fd77dcba13080db50b7d53cdbb6c8934930e58c71af8a5fe6d827def93bc9c6459982cac8c89f5c1bf95f1bf389fada8d4374a3fac745b7267b8cf814f00c9494d50f338c2cb6f304eded878833dbddb57a8f90668b1969635bc7fb49e5e1ad9090b0537af92f473be9c394050dff471952f3dd31222c801d13b83a3dd841f16fa367fbe92cde8936565bed6fc48c839eb193ab1b4dae77640280a9602182cbe66413d64333231fc10e74413cd22062bb3c7fd1885d86ea587d33b18eb32282bfea7000aa3b3a0f0393a45181d78584cc2c5eccd44986297cd59d9d6c1235a55a83f731534f3e21cdcfa23969e3a658490e3fb2beea8eabebd0dc2a120703fda4afdc63e379ef0f9270959cef70eb8db32a91b9448366d8ea3c77f01e98448b47e3b300cf0c3f4e805175a7e87ea33526767d5b67eb52809151093a00f73621f7548f565a54daeb0e60e7ead2db21b16a23c1f7e94fb1f208b30ec36978185f33e0e53c74fdc4fc14beb238dc306016be46e761c820fe52a4b6899d57651b3d1236ea8d834b164e146249981da17e97f7369c4af86ed91379b770c67d5c086c3b149a71efc16c44135226e22acc1a9c11c9f9e9a801a6b9a246750529342f1beb23eeb1163db92b58036bf3bbd062faea0d7b64866231b55668da94520a4d954c92d08ee895c43880d7a0d21e159b14451175131f7964782558d7744adf0d2600caa44b34760f739eca7e6617f8822491d3a33280711ced1b4ba9630ef1bfcaba7cf348b93e4d390c3d08e6d85c7f3f9bf0db7f8a259abc177a9b66629b422f0e23ceb723100245dc9926f3d490cdf0fd9968753c02b0ba2feee2264d93940f69e84868f2e8c5bc5efee06c41dad00826c9758ba5036b8733bff634bece77953357a640c2109fa14d52c54e7620c729972231b3ee3a658b705017d834f000413b25d90de44313520b01cf87bef7d9b92bd626772181d004629125d84d0c68ac320105c22a2f54c20fa27d56f7299f2e6bb59cd688cd53c92b410b70bdeb7bdee65f3752798eb3f016fac13333ab55cf04b88075d221e547e0a21f875fdf67d2bc888b6b2b84fdfc0a720f513c28a7f8121917dfdfcc0a2ef872e03dd82c9668d0d4ab70c4ab4f474f01cef0ad9018e4c4b57b4c8fb54db56c50086bb069484f07f5d35b57dc68b680d454b3ef6a317a61067b39746fc3589e893f2757b4342149bcffab7cfc39db45e437c1999aab63923b19acc80b5351a47c9cd5198949b6c81c7d70a8246a8d596d4d09f629083b65446e6a1bd0f3ef9dffd2501de5191a63f84df646290079ddafdcb92031f0e6d5c870f7f96d5398a7a031e0af938f8e8e2d6e09b6daf85c02a73a1b471ba6598f85438ee68347c3f1620cec4e66cbd1626b20a9e5b2ab27a611f7827f52ac9bc3323fa45168143dba7c96f144715ffc3b1f30b544f3c2e9d25e6d4beccdc4dab9873a8206a60724de637203608b8d409c3904f1a21501785670e2096c249a5ea28462b6b6d05e046a874ce1e9a16eb2ee71c08970421d588d908219b179d4167f25f0b68d3b776c42bbcab8e98d9fc68041ca5ef6e328a0e889d3711bf63650d0ce0d6d6a2ff186bb4cd972fe83fc738959e05c96667b09cf4ce4adca393654eabde14cb2da9937ed0a977d2e5d3ff2ed08d6bca21a6f41740447553065e5a91af41b2fbff1698cdecfaed8157e236a8f80804159829cd63c0ecd2bd897cd6e67921ebf85d2e2d793e6292c2bf7c7c147684fde161ad4e6e05e318eaf47ed1f408ac19af8c1bc2bcce8d113fc8629800827017103d1d13b49bcf39860dcbbae38615b00c851079db92355aa2ffe3a89bd6f7f4f17b544b2fe471f933ca0a07d8fde03fb332836d248c149945f47237162d6e3ff8023fc58b9cfdb5a2c8348ff361b048ea367c39866603f59cd2b6675e01af4ba8b40560818c6613be6966a57b9273adebf4e1edac65dc1f7cfee58f8d3bfff914d934ac6e438f3c4c9f7dd5cdbafd81118a92992afbe0b702d03d192bc00643ea31583dfa36eb9aa708965c33252e3a1cc96950713bacd2f54905e7f7d5bd36209db46724b6cb990e8a9abc2f13adde34af9d2869f6021929e38bb2b660fb1a243f0dd24fdd68bd915ab03b71e313ece5349ef1b5a9bdb07bb531537e2979e277991b54c492737cb6d3f8d908eeb10785d76480138f6e1db1eb1435773246de6ebf63dd72cc6286fc9bba259204929b6c1002a797b2af2600da6480725e014dd42c99d022f882388fbc06fbc79e8d683e2d095d6364bc65dab4165bb30d545417a72596c7a178d837e756b50b7de01313e2fa8a7edad24e866620886e55a8160a0c9b20d28572adcc2b3e2ddbc27f86cacd399b302b644870a06058b8404f70b7add4c82e0dd508486de2a1abf25d2f3abeda1a869661b99ebd190c758e87f60c69d386d20d88183aaecb3235e6141ddffe3cc1b9922994add2237ae610e17b55a2bc49b1ea84151bece3a80feee26a4f07f350f430c56736a02595758262422a0e9d577edf5a3a4a36f087f9f529b200c8498810015a15d8aec3a889f3d9a04c9fb89d2ac3604082e78d9b873d02a79955d416fffb1691e48d0c83ee41182a7e25ce5cb426efaa58036da2322bdc526a5560dc543c74114078d9e7ed11dac39e368b312f7cb584a4725c4baaf3d229b12cfbcacf9f051cfe7986722c598ab8a583a1f38df753a8dc460c186b2a45a93bd7af98f47a3e7e9c9e900d504517421b2d0786e1139fec3de52bef110a268e05df5eac51d0bdc06345de5e316e9ae653991e6bb6a9fd33cdb7ec60d4da691300b81198f5e1cc9aa965c9d37f562d27d9cb00cfdadd63bd3356415db00df07b45c30d2ce4e6e3ec77341878b2768adf5812aeee2a730bf198025a2298812d68433aece090671ff016c127f9d3ca6cab2e7c021a36d1ba5cde142532cc888a497c6b877da5f73192f00fdd726e17cfb868aaa5698106733300418d54b24fd928da2babf4c9b54ca4b4de07df7149979b361c3b21d9ca0f27f6ea221a09c936e26d34688fa8ff9ad70e55cfe98a5ffc3718a9cde77000e91736bbc82a9762f5c98cbaf0af2162898882299b68c24732c46bcb9e82127bcf1a874c7924b517f511d252f80aa8a6fa202b34a8e1caaec8cb0265d05472c92f31793823b7f7a8442abca017ff6b01759b25011641c7ea977181ee8d5c6f89cb01b910a1c8cf49146537911efbbf14ce2cde943198cee373f255424cad016151c457a43ee31ba957be586688caba28d5b8a849104534407e1542f8c327912a7d4748e880577aac932acf101322153f757531b43aeac01aa7b7b7601807e1e4dfe166f0fd3d5e3d63361ab0eb19f596b60e629fa25b2d51a324aeef289cb10f898f5fbf23ba198bbc48fc19b83aeb81f61f158d8dd9d7bd8601a3712cb56ac33a00c911ce9fa078e315d385d5ec0db561c5e87dc62a0e681ca83c0a43dc740e64aa8d5864b5bfcdede67051da18111f9fa24b1838942601caead803c4e9e72b8df92260a04255dc84f5dc569f99dff921a39896a5421c98de48605bcc2e7aff7aaec788a73925a8b6094bbc6b7a6502a59bf5a59f5b43906b2c597c25202ec67548da3ec11a74d29d87e3e4cd39e6e4316c5f9596a7a0a3988cdd7ac2c6a89eca9e9ccf42f2ece7cfde15d59dce545409471a6e4c60a898a469431eb3e3cf4b076ea33e14182987c1a8f3a7dfde7e0734b5b4a7dcda00d11658e3f96de13f4218f5204f160c867fa8fa1e1f7d514ed225b77eb3ed03a7be212a822323d63532d63d6069601a8c9878f335653e9363a98c342f7ad2fe4ba493e16fb409eb39fbd06b12cc22d9dc7ef8693b59a218558ff237bcf7fc355211f3ec9cd5218cf1d0070ebccb58df41b18c38c9bc60880d81f60a2dcb32649b78bc5aee3e899837f34c3051da081d54d2bd58e06523329222774de4c88bd7ccf947a5ec064809af01b2ad15c4546c30b4e7701369b908da971daa2dfde2e71fd8a64b45d7ef4f55d9fdaf5b848895f80733913f4393d346afd866df2bacdb9f42148cb7905e294075f558b49efaedbab3daedc2a897a884026c0a75ef9dda744baaec61f6ba5150b95d49a3b906576ecad856513d99cd2bb6725019bb6e99c80a9cbef3e06b68a17338235b51f7dfb2af320d8881df12fa238db8c67af65a8be65cc47b48bf20da5644f5cbc2c8c46a9058978bfc90944f7afb2daa7ff1f3f3e54aff1368cd5f323c03c4e434f72a2df2155cfb52e9ba03cd34aa9ffb11786e0fe1c45d73669e8aa728b8f15e50dde140eaf1ccc55ef184081fb3f832d080120422d19c56e355a9ea89dc07a98793a253bf2d92a65dcccafa45c113b3ebfd8a1b16e38ad725fdf01c4f43c68dc633779ecfab579133999cc18e3d5134850e8dad9e4016bcbc9d5d9d6ceb1f6e5aa8cd5c61469aa525288a038dd885c9c95f7945e0d2d692a01495335d6af50cbf26502bae1db4edefe1ce4210dac826efdb95ed2a901076d8c29babfb4b2902779723f71e329b8f17a4f57e530a12ae5931504619d59985f1bfd816e150998a4b8cdcf208c140b773f646cc76cd9eacaac4546a80289f3aea9eb76d552eb19fda6c99813657ce64fe30a8432987a34e3326ddb54fae300964947517969eb3d961367b770bd0001074eecc5821b265ca9f48d5401a29a0288118f7a5a1f9b1f5ccaeffa9572090a77e46f2b2dcd69ce8bd1a6d451380b49166cb737152894b92410fe7a8d1c3ac1ad247142069caa4782ba022c565fae708afd2425e279f348dc802e41d63ab4814d59409083b78981d866075aba5af91f984cef4397636185b7d1b7e13554b4bd9fbba2d5475f7fd0b240af49f22c10ead3454bc642ec917967106b5dc775e27a6abcf2ce799ee039e9a17610611a29dd7eaa3c168fb5c2d77f0b09e2d482832e770b9a65c406b5b89dc640ba7aba058a01f092c3584defe2433f49381fa20c4bf975614950c58a3563290f786de6a0164ee52ee066c67625a849c625c4ab6de010ba7b7c5168bfbd3cc9668575210ed0c41bb86a127666f0d970e911c83401232d1e3df7eff32dfb87a464675ec6edae2fae1f0964bb52ab9291b8494a7d21499e9d3c0782ca241e50d8979c2d8163c6aaf0eca2fd7dec1c85006b907a4041b3e602a62f5a780e2dcd7c993eddda3e3e0eed99c4fc05ede45800b4aaa89284394276525b243363ae56ae0c8a18c7b8d027ef0f581dd4a0390a0e9ffe31dae9189a26881f1ef0fbdbdfd2f0c5f535388e52cbc0c7d9f5ba7e24f2fc57cdb718681fa820448a291f5c19be023c0507146fddb1d29e7e1d5bc17ac005316b94cb4ad641a91b81aacb9aa441fc1d9250c1d9afe764194298ed8cef16727aef3a13372032174e79e969c80ec6cf2d6ce33032f71ed5970d94e37b736d06e8d44da593c9391f9de5c4648b4f399159118ebe9c6c162ea0fe9384e508fdf0552ec19df307fbdd9fa963041f3611d32cd0ab116c481468997024314f50fd481512bcee05cc52727f25f2637aabe7e3ca2cd19fb59abe5f7e63c54d5304e5d0c07e7d40d4c7135813a59a29f43c66b3460b5aaa13b3948b4067b3102dae8ac11e858318d0a4a1afc31d03f2a12cdaaea02f71b803bf4b1ec96f67dde9e2bf11b76892a514d9ea3a14c577def599854059b389837da297e8e4093fa0ce9e5b7a90e143fdfcf7d18f7b9728c8b5e29fed49cdca0a04ffc236d95def3d8d92a2f8c5d554ad9c80845a4ff18bb493f9f1e4c3a03db0fe51cfc4bfd10dbe33e277b2282020db1a646e5bb3bb3d0d792f66a90f49523f231980225e908605ab8d2b4750a1dbb7c812ccfccfd5db5299d5f11082bac067acb3079064b777d787652f8f516891a75960d57d2bbb25caa26a17a2d788b102088eddb3faeba0e8721cec70a094b5f4ecced48ec6483c35da165ae5e3c373bc3542dfcc53815adda76d4c0233dc995991869c4ca63c932150f0adf78a7352b232f97a442f85bdf6359b3fa79ed08ba5be7ed68d2c00f5ce058809db9810957dbc40c24093a989fc3335dd820476916fcc08ef4617974c02bb7f0414cef0c9a8601315adff8f711664f643b09334175a434ed262b31672a97aac7448f7d9dcf61d8360f0f7222ce5413452fac360c4257272cf1a30e1b647ff5a21245462c3fc9462a2c2c0aec08401102d7fefc330c7494ffe0e6a5f58432e67dba23a08dd2f1b83490fde2eed0f392d38874db4d6d9ceff7eec47512e47efb7c834247dc396c4455d863b3a87401eae5d3697e376cab418519ba66ab9b8b2aa281b937a2b3aa260a6c4d4d6838330f989edc80d89da7ba6966e470288ae972fa536b44f508e25c810d787065877011e03e65d1d00cc6d38afc218d0468f1445cad0e091903b5816cf55f68c4fd395ac244d037dca946c6a5ea191fc2bc589ba6a470ab9797f82e74dabb7e28734adf5e5cd88d088ebbe1d826d69fb68248856e68da39438880b87401282d2df50718f2c86c858a3fcc3813a5cd567d5bd7427b251f344da76305d3ff7f9239823f9fa926bb6fe1f99e83585f56affef9616ae96f9486d6680812e449112112927613d9e742f516564322db1c9cc6d09f1e459b78bd31c6c11c18f3627420a0b64d4babb269260333ab459058ee694c3eecec5478ce00bc2dcfa878aaab60f2a259f54f2261296610178fb3b203097c21bb83a7393cb4eef23773d8e97671cdab3cf2275c04d040a3780b41115cd84863c8fcd9d37b86e4e2d1212fe7d75e988983b760d46545a59a078e571f0d5c54ebad1b908c85b4e7a6a26227172958c32fd7b92711b44d4b658f0339d64f3bbae1b848a279f309d0dd29fcacd096bf2925335a770c33f4c74c00afdca88d76cc56a59c508cd819399f00b76a911d2bd3ce7704ac6c0fd0c72ca43e143914bbb685a30da10a8299424c7327589f4a20e7466d9b664995609320c57e8c17ce373eca2637bcde7b010171679d92907f4912d60362eb3fbb4cd1c6e3d7c14316f04ae7ed12ec85fb57a61d5a8db7d313b809089daaedfca30f5e8cc82af68b7cd550f27c3cdbb8b0a442852dcbbd4f79732a185f6b2d9f1a6b644363944fe90e122c57adefd02d86000c82732ee2a38791b83b5e03b081534173d8303c4b7acf8b146e9ab7ddefbd77b2198f69109ba69145c4112c5c8ff8881e1bf2aa1b50285b57ea0a00807ff009c0414664d4d0c9790e07f9b07e73dc015d143842039a1c46391a214e92c36a52db8c83ce4d4c89633e01342118371e6ac9d42e87d6957b273b34abd7b2f671b40c20192921f37dffd20ae50beaeba4175bcd588d4017495f7e79c6fc075f883b31826dcc40d7876f75e6a69a4e93c4aaefea313c526c0ad4c729da97b72a7d5020ca7502093a7d05cfd1ca6167afeb60148150443fe4fa62038cc08f29a3ff26913966088e945a28cff17f265e9722ac787e612b9709297585a94499b1fb0bc3bafc24f60d77298769c11948d3f7cc9ace39e8e93342724ec5db99cddeb4dce07e4595cb61c1107917a939372b170084bb6458245d6c8d86b42af8079d60ae47b8ae93b7184fb752e67faa3bc33b21493f2b27026792c6924d10cb5d5151b4edaad3d36826370e5c7721ed71cf07bec1093d33addd1cd0c7fc4c52fff8e416c7a7e8ba2a27ccd2b6965e98e2a3cd0dfbf6e6bf2879c19cf6a1b40d926e01b7e2f3b836db01ccbc13434131b7a79e9d54f2c0b460a09031c546f9e752a1387725a4ce1391946ead9928175962f9c7c77f7e87cf3ce6f649cceb818ce6b060b55eacac00a2e8919efe4e650171c7e5736a7d97b35aa582d119d1a552243bc9a915210013f4f3767f5164bd151bc455f9ca67c4b2289042a745574e324a6f5f00f0573f8f055f63904e97a83028c3b4884185450a999257958973e8ae722ca8d1b9702d0734e2dba39415a9ee6bbb8fd3c19559a86f6f16d9ef6f286282f59ea6e2dcb9770d090127acec629141a104c94c1b55103e0407c1ac755691ad3667eebb8f6a8f369b420178a8b2441e052526b3c5ad8c143b31deece4e70d1a5e924ea2769521c8a86d7c7da741d8c22d67511054804676ba39903462c920d09fa52f4859dc0541317a0f170618e5b2896c95f511c1ef676754d25911fa8d8d5f5b588855afba6b783a28246af1239b8578d160380649ea8eb499200424b7563340216005de408b312de089f2c67c009a96cc93f76238b6f31388ab43274bfad18dc61e5f8562200fa1b230e8277ec6856d0764a0f9fbab6cabf43125aff7f458972f59279404d5511718e63c714141483330cbc9243dc5e2404f84ffb8cbdfb18f75b1d4007acc57a5abc58af48fa3ffbe511cfa8fb6d72b6a6718b5b34e3e4354c4c88c71a3f1aca9f19fcd118f636f3cfef6eae15bcfa9fa3e7651fae41815d8d6ea69432cfe4c84eeeadc717ca45c479645f242ef2dcf68bb629342edacc782d5ebe0d46acc3282fe30a0bd16c3c33e442444cfecedce91929d4119641339034110690874d9a166e50699ac552ddab4e509acafc27277","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
