<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"75dcddf08367cc97e9dfa14176ce9e21aa06b43dceaab9d3e9300649479ed1c9b871bd7bd64d51039a6dabe530ac06388c034929f343e99bb1750a2ecc6e2fe1fb7467245a6bc388751632bb6ba3957785e65fa8ac94fca1f40f39bf210cd1b1b6aa3ea7012f899061f7d1ea9054cea63927e816ebc6b4dca59233c8c29a7a0129ba9462e7c1e5e8ae73c8b066d771192567b1f1cf4717f28c3a66de0366b1584a5fa10e1f34e5824ee63412f01f6b50b9a7c4e09eee1c2c2507a41ee95421171ca538bdf6b7c0ee7d6471d417115359a545a4610321d9c8e01b0e8d6460874db0dde537cfee38cf03b9519e227f5b54875e7d725997573a17e6fe0a19da0f16059ea23b3e961f9823920ae83821fc9df09d1ec33543ed8b5be9086b7fe86709f6c1254e372896cc29f12f74aaac44a729cdfe26761fe61f29e3c265c62ed77c868d0e88e5a4d7966d22cc688a35faff86749d87075ac5f7e1d7c4699d66dc7704b14bf1b83dc82442df28be94fc79b7a039211e4346eea7152cb45c2a3b1c4cf5d60569e2375a417ac40d71f5d0d64615d02345d2f2c6708b15115129d40154909b06795ff8de8427599e8e96b527b7a0cb04a4073d8660c1c83d62a64c93fffe93d1716751af32b06f7f36616dc6205a391b74b5f4d44b6c188de80114ae51c7924bb6a25823c8c95d2ce661552b2f74367942287e122a70ca90014f706c4ee4f6d9775828a5c0948e5170dd68bb295e54fb12060d75887fa6a22efeb6c41602658598c38adbf95c4301bfbb069dd810a7f024f420840ee1f960acf865a50db6b707d7eaafbece5cc8af1063f39ff5cce6f15e788496171fb6132b5e7627409efab1725bcced274e08333e6ab03e15c8f81a6760859107e91cce5cb6fa1b0c7598e16e8c6da67ad5388e7b15810b72a8c971a8eeaae8b2da9e8c48daac14d1887acdf370b9142e265f74b5d7d03bb44ccbb5323188432922178e0e507add04740b4e576380c1031456fac96073ee8d3ea7ddcb8de949d3a737c53aecdbe1fa800bd834a30b0e8aef134147b6ff24c7a4e0aab52ec390179e13cb7fe83d2693c68abc350199014751aa204f33f8be266ec3819fd30712e69a6ef3807507a5c3891691d907e030926f17da7ed25d859fbc7866e4bf4b5cfe99f2f5f2be90ca2211e1309504e270a7d199dd229819c615bd2c953fcf6d3ae802b6c82b1c5004306b358d061a1b64ea8eb70832c15990c52634632b64b71194e7dbc15c7519009cede019bc68b81628b01e325ab4efb50f4952f40abb79866820448a7f02269a5d1f2374bb0ce3b6368dcfbbf3787fef1b31833854087dd93d6b5cbdd862b7a465c45b7fd275d032d0834b3747afd737dfbd701a12afaca04cd26e95c6cea6f3220c0453638ae102dac39aed32ba6b01b620ac72db0b92c9cf12f4b49a6d09b96c438831c3185ecf963ad404ac82500ec2b1ab900523075bd07fa8563283be0f7114d76789b837fc6bf5751b1370af2830cae816b0e4433a299b0cade64ef040e8740853312ac6af951e946542af1e8fc79915db477978d8c50921f35a3d44ee11f7e75a5fbf63a32ef4b76e13e4266f2bb2ed89dfaa9705a17f78ce7e1cb9944c868d3e0e853f1130f9db832f42fcecbbe2a3a17029868123b6755aee4bc25818b7ef999b407c0a6b96e330eb1ea075cd2fab0503501ac7965cb129d00468fe74d45ee6ab20155cd74b6824edfeced3d139fd7e5e95df824c5af6aa1a69420a53778de06df4465136be9efb732587617768df998f31cae8af45b889012dba5a803d6c3a6401373bcc21d40e05e1fc4d24c18f7fc5ed49d6b8e0e94ad504448612dabcc418fbadf12eb70bde8af7940c6a35e1ecc6ce430274dc021b5566fd53cb7a26b66a5d3dd8b50893b8c466bbbc722465ffdd5de8003013743c935dec40eaa5e09c8b0f6e99ccd5a1890abd524a339dcc359d6130163855760b393fa36a7e2fb50258eceadfb7550ab789aa65bd55349fa87ccbec307315b82f06f2bc8e66afae0d4fb984cfe9aa17d5373b9b6b1e04ecba824084c117570167f2eca7115d5316a304840971f2aca8bbf2e2a7051c27e51e41d2a588e31c0bdc30cd404c9d58b7fb213d7c9027e8ff2f15135a17195bded8031fb6a55849284f9aa07b5cca9f0ee8b2c9a72e417fce34cc41204a2e30309a0c61880e3bdfe83ecb1aff6c8ff5f6e166435ed76bfac7584b9c89a3f6b452e4c032eb8aca640dfc3c0daedcb836138ee746fd9200276c193189e910d4328045234f3588e99b7be302c1d3a13850f41c85030701289427557d57ff044f904d09ce00f77ed48050dc12b62e2b65c39469f7514652a2790ef388e76ea0efde12aabbeb8d822fa2f61d14d34deffb921370d532ecd03d116c4d6b311691186c7c39f2eac25ce728f475eeeb578cb42bed70940999a462faa45daf2e7561cb22d390ffbba8a410bc17ea19e989a07fd8f106eb086173950e412e309858d9e9f4443108843164e78bfcdf31d847fe9b33884751099e6ca89d0fc83091d6103b54303a6755bfe1f97b5d460f10b34b5dd6af8db857ad793c4e40839be9d19c7eb8525836337b35f05e1f819d0d0e3b41ef2c8ad9ef0cd2b53af98cab56beee3a4e67b90a18ffb2d7467cf28bf4acbf81dfd02bf381e112692de853cef03000f9c3d97f3d035dccb15280687b4b43d6570e0d3aac85c4f997f87375f21bdf091c19866b11694d49d4081641844f013bfa1b8b581c07f9a94595389171546f400ca76b1d8a06c355bbd2c0deb508dad5c9eeecd88cad1202dffa2847a096f49a75063e53ff2e4c0d7c72e06ef6a4eed379441cffa95acab83e5d27a958a187cd02ebf8fedccf66f63c721bc27cfef1ea7af3a39a5c9131838e07352e61e395f60c886da5f97f4173c17df96b70b2f704a233dbceb207e35873ceccbce304707df55b4013a0116ca64846e32dc4d0a441357d6a5a67d086a43c369bb1bbe670f094c6b2de3314bcd46af5929f50352a6592a5340ac705ec6aeefa85e2285fb15854318d170c01abae66e370e5d89eae906bbd0deb64d6b7daf633d045a7b11f40d327c6ba11cfa880c39db7fbc76135424f37e19c0111e8668ba296c3676d6298f8e597972ae9ba1d16cd97e062a4677397b650f32b253cf0b73880d0797edb480854fcced572e265422cbe8c3b2be10631da938973b76f9d6f13a2f8d3bbdae4aa551281034c01682b7c236b4b458e66a60c2b87c0d274174a7126d11f36efdfa967605341b9d9181bdbac07b3798aee08ce6ba634674ba3dd3c132e9665636a8d30fe0b9d5968afc1271b48bf7454a2f5b0909db4c7c206e6437da2e06113a2703455b6861e4be1043d94d71fcb42b5b2f516d8be1f53c154aef5711461d992a74e8751040f04d6bb5ef408d1431fe7e830f1eaf21c27aa1b1c2c1c225ea8cf126696a5b8accc47eb705b9dc18ac62d219cf2c907640e17d9775e63ecc7e4c37257087c2b2b8666996ad8c72f918ab3d8ccfd63ca1733b9c378a88c507dfde865b2f1d1cace4e4542fa32c1d18b58a76607a2f3930bcdc622d6405a58c9de583aec959feab729b3a8de3949caec6ff039357fc45dd52544f1d10a833bd4e91734686412001575ac7e59c0443c8aff5eb2a7a20b6d21f208878c42e8716b94bfa0bd48a952e6f99e64b4c3afd483a12da5a620e8d119ffb7e365015c7760abe81f6bba2132e32da10b6f2c4ba22347876d3d5f440b0eb925bfa8fe65cdf6b5cc8ae7e0422c6a56afdfe3436e4c4fe152448e7c071672b84f8c7ebdda9fc29b496b3bf6d3f35e5cd3c1fd75eb2f4ebc5f95521433322807c2553d0a2af4ba9c2ef5982fbf81e0e38fd6d75a2ae4363ec846e0aeba19af5499cae79bb704327b00d02959a8f4d014b3178db31d7b720453aa0dcc13d58922d28791cabcb14aca1205d129d1fcdd75a67e5cc20a8df04efaa591859c9f26ed664adb918fa07a75c6914ec08609ae5dd2040202a5a9bb48c18d1049dde61ec6d4c5c32f54918542147047a8e65c617862ee212a873627c70bccb21a19d88963b18532435f8ad5d1c02a5b4da4579db3da99d09ca1336f0ca54990644b02c89663a4fb32f91bbc02787759796623d4eca084688cd3c3184915e973cd38217a4401f772cecbf0d43f59f2d74d4d19e43d12fa45beb62273e54e9bb50d889ff527a93888878de6ad9ee22d34c9ee4dfaaa54b458b324d6faf94550f9071ca1d0537f0299d2a471db7a000a9a247e2ae902bebfefc7ebf4ef0036f89b1671806a9b7db0e57474c9f44ffdd916e0b7ffa48c3907944c025f5336fd104d1d975e8aaa55392df4ea10a1b2c3cdcbcc4d212357437e2db1749492c917a094649d9626944641260af970ef43e2196b273f67f8b35655aa8ee12003aeddf51e49ab9660090e4ad7e058b8663e4d9c6d25ee80070834d31416878ad73de1b6ffb2640105361421880981eb4119b01814db1f5ff36e963e65c14c2b306c9f47126ba7e242d47293beaed29f38ac76e8f480437674cd59c80a12e6771d65c04d87989b58b9dae7d70e239be833922b6e55e2438d03090dc05dc6f1762d41a61323e4a4beaea2b9f43cebe5757549ef3fa95d5cc6ede9eb547bac0c48108fdd7b7000623f4c3bd5e98062d137bffd6f9babee3d2c3f1680041c6c7325a1d383a9d9a8ffe4eaeb49b4a163450f9d94276a62c774c7bda7732776ca89c32affcfd3fe39d9b44a39d131ca83c8d26a5dcb4f3aed97b2dde4c201b9cc2e88e4ac1db3ed454844397428bd1066463306c9d128a33b05c54f1f3da6c95f28f586ab7f8c23bf086e6f965fe949b92ba2926054fbd8b8fb0e9ea14bffdc4db27505ba96d385585712faf980c61af3659f2a793fb76c0f609f8f22fcd7db16d2d62d206d5d2025e1542692b197633faca248a184d9d3c3bda678e8140500ee0bf00a8d0b13b2a328282b56d3cddb226c1949a8d9dc58d6d17258066d4b6f7c2dffea4cdb0d852c5174e12df0919c5eaceab8e8b98dcba880f28a7363e2a547b2a894072f0dd3abfdeb0aaca190598e0f74f8c212cfa8948b5a2bf6b97f07a364d7ac7a3a149712100c3916d9ad8fd8a02a5f1454538ca1347d0ff372af6c2934de200e30351ed2d501f1851f2db3f78f3fc32baa81c7e949671749cab7be51808aa0e55b7cb302e9b1f2bfabff906d3d7e5eacb420cccef752590454566164383fd2602a7cae318908db2fba0148f73cbd89f70cf1c5c27219a62a946eb2bf39200075ed897ce3c5c7a951303c34a32a233ff0167e21429da7401fd0789875830fcc4e377134146b67ac6325e39d1340430b085f0696dcefd98bc00422084a697a7e52680d9fe05bd6adf9cc01f11e906da1f69e38b9f99dedb4d4d9969428e6ba88440ebcaebee1832e56db4f6f67c0f735c20bc450ed14e899df4d4b710c940a16d60d0ae2e122b3d5528aebc412eae01ccb760c11f0eb9b4080735eb5b278f354e0efe8c509461fe2297665e8ac6ad6bdfc46fea91e813b39d7abaa996340dfbe878c372a59d81109526e0a2d95d7b7da801b75b9c98f0ee9265dd6f0fdddd99d2fa3c59d04bae87b5bd784c4fef8219e117892802cd09cf8260f6e4bb9db6a53424e7cf8d647474de1c2eb9fb29151e2d5637086ae82476356d0241cde46ed67073aa48ba525e12c8c6f605b5ffc057126c0b340b67f53f946620fbc756586fe56175f0162d4b598fdae4674b55cbf9acd89d08e43746b5e18a990996f65dfd51d5bc97f5490c70397c4036fc7ac20f3ff91840e906aacc55748c4b03fea78812fbf1e0bc3f811452d6d1cac98b02491c63477266ac2cd79cc66bb408559515d673fd37de4aa595cc8cc0f1007775ac6286cc1717902291b680d6a5a3c2ba2a5bcd1a4d8c2176665ebcf3741613e0963e893e492507709f84eef06c15b52bc9d25846f07f0c700da751c4508e0eeffe1c0442028004b83644b3dc414d8a9baeb0e4f575da44dd064356e0be6b8822d7502ea0752debd1e36c9434e73d7a0afe8f675ee65ded823cbcc340e7c783340343925beb6b8457e1c774d00981bb47d08d912922fcbe1165d0aa80601469fa461df42f019dd5779005ffb6c0bbbf79424645de38d385d7f79710264a2b33a400af5fe2257ef30334d54a575a8f4180fa4b00c8f3f51b579922186b5536e596c4a2ab8faf53764b85c2c3fa6035116f5672c19febd2467709592b7691775a32ce1db8eba64ce8363159238019d89464064e33a6d8a08c0fed571327e77fdb64c9d907476fcf0336f88ef6d47d5fbede6f7a5939476ab59ac2da48935a7c350add0a46e61fcf97b2f0ced7eeb6bd5f22134b4e1902ba05c59062c9209d53b76b2410cdd83cd433565dfccd0b2e75112a4c1c824e2942f6c11c5f42ae157fbd901d4f0dc7f660d42aa58f3f4492ee0f0c1d8ca778381897f7b54d2605ff055dc8ec82c3f9cfe4103c3b9b727d9efae9db3b0ecc712a3ff534e4dc0fd1b92765b6a9eac95b5b3833d5e9de310248ba8341b8b560996954943ca3baf18e81212115640da9b23d259a4d04258f4bcdbf69e2484f6240d1ab8cd0b730c3e3b0aa5a01c07aaf0685c17357ffcdcd971895196b3c16aa9c2881e5704d849242b0bf9660823c6f76f30c1b4222a2e8cbfde99e1f712dc08aa78e9a4e353797f0dfd5e115f08f96338485129e63e6c1053269bed8cd6d2cd3da6c02cd53d0d34eff5c1b77a99b630be5294e872b203809e0d6da99137179bf5a21de0ac6a27a990ef953577457b646fe5c40901af1e7fba404ef6ca78e4debfb8915b2124ca7874a9e6c4877c514eaee8c6dfa877f5bb1b64347b8c041c7f1d620131c11bc194ae7e7ee954371dae77823e93bfc1fc3e7fb85f8a19f76c15b0892ba8d2432ed7c33f77004c6069f866fe1e82828e2d2a56a34c4a5b505b98f070a3a820e3ab7ef42deac642f6a697086f6156b2c141f05d341a53d99c4eb46136ce582305b630a151dc6687b348c3f91be9fbe6ee44f41c0b6859024d91f06140f1ef8c4f8aa083ceaaebb1d16d1845fd323caead0472ff7a93ee5036202c5ee291d4367c0cec1844240cda782bf368fc093a5d6019af1c86b795b607c978c20f3957c0fc008bbf6c00831f4dd32fcacbc4f49f6c167736a2e2ae5f58edc280b6866d8720a04e58741fdb31aa239db558953e09b7688a22ef878a887876211bddbe6496b53d825b261c39335e8c8348ee57dff8c5dfeddb6d6937438940ab02d5fce9027bde0af70a7a0353c3fc05987edf830a112c4411a329d77c296ed290d843536d84c5d7fb4bd5ad100979072a34626b1a914eaff07ad1af0ffeb70fd06429e3b04a079907d8228b89343e9e199df4e637d89ed728e9eff234b071ece628b1189a5c0248553db0accd14646849","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
