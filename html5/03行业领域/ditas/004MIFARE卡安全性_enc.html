<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cfefd8a64371dee89486f6e4ff388e6474b8da2307322ed1521fffe4023d2d23ba9bebb88bd5a4592f9e225c619488d285f5a52118fab2d57902eee84069300fa0ad83432a8a136f4ff9996e1739dd4479c9bdab4b58d22915e408af3fef20023b0af367117369c6be592272984083c81e4338669900e8600abd8378072adad8c4c35c462c270ccbf0d555f7ac73c97c185c4487681e16de66aa2c53be73f9581b9928c6a14bcc18f3645728e8c78ae22b986a208f86c1f83db76d558ea281f30d676f401d068ed7888fb1227e52c1f7a5157eeb8865f1fdbe0ea8a18752e1a8d76ab6c7ba225e5faceeb24341d7ed31f05c400ceb05f14691236ff4bff83e87fa4691ce0dcc348157b60ec1b534d23a4576c9e9f9f2ea37e0a5c1a4d46c33db211a55ca582bf1732dff1ed2735f950b7b31774f63751fb1e9515d07cc7f23c03e8c6b078660f60642c1380237f6c157055e7aecec7528178d35c5cfa07168bfdc1701c7d56a95b4b15b3cc5922cee8900b613b74b05d5cd1e4ce359efde662f38c4f6d8d499735173536d1f3c7fd93197fbe0da84b381fd225d0ccc02edaaf2da39d82728467633793513a5031f01b0651f6184738e713e10aa6c561881e180d1e7d3fcfaf94cc4c776776b82c79bbc61384c10fb964e9aaf098b47339d09ed908664f1a4d36c7d9dd39e3f006754dbb17779a9274648d8a99f71ef2ae3be33a2866e8cf021367e9acdcae5e0e8fc0e556fc69033d821367e794f11bc4ad5f35d45dc13a61c836d43ae86d997b4cfb3c24842e31ee5a2ee784f0a87f43c1ae852c30302b7e74972d7193aba766c0c8483b5616637675922b22e76169277429a82197b4cc01fb99659dfe380db0b7fc9518de3db7c9c15df67f10ad54b34fc8279065e0a3aba82553fa8b5e8af54c39b5847baa299e30889655a4a4128062a098628e262ba437115ac8f990c604fd4747a7a035b1b4edc87fe3363ef9e65b3820fa4e577cf74ad91a0877b1cd899958b0a8b7cddb75b59d642b5d7bb980b3088c95e8be3724ff14e55104490e4c78a368d2203763ac83693ee5ef572a28586fe37b75845e4d251c749da1589dc467ff643a0f31749325ee402f40d372d616162cb97210f9e959b3111fb0ba1a7afe198d307fefee47416f8b5573186a904f4b44f864bf4d5c32b7de2109ae8933c75b3ac43fa1d0f507692f2f973e122fa9bf79d87e80a3bc01b94df5b70f9a9b52d449b2339db65dda1979023866c1e06a2007074caff7dcf69f5f8089407719bd41eca321208a8ca6df7a9898a299db84b72e8a3db80bdc825f57378d1eedc88f67f740b17c8e71e7a484a4f1017a4ac6a30cb2dcf189649739d05bb1329a9e1959fd76345956e1f0c3f6cf6eed578355ab6a18272fefcc2c9dd8f5c07a2090aeb3b216fc14dec3c3309f5321cd8272c6d3521a0bfd6f3a370b8c2f0aa9ee954ff927cafd50d849a93c7dd4f080aa6af1cc60f412f4fbe24b8a3c3521c9f2f915c073cd245ae2b31edc5f1de480121d05c88ee13ab33121814a3e02b51cee916578283ad9ee67deb3571458bf6c80f78a71a1496a33fd82c9d5647366ba77bbbf21e98501d7f1770595c369fb1fc5791246f34af672b06c6035e8596433e89350f38d3b7f8b049a73384a057ec3a918889c98f96f0b1eb9d6d39eb7c8c762083f5ce5eb9b47189336866488077417997968767c6069c91ed8c845bc1e94707d5a6503eab28c55b5c29f913736493456fb570dbf79bec04ae05d7392c6a4bb7c88ba1a08bea7c87d64ded28f307b25e88e146c1100a9ecb190e75ec45814ef7c86f60c7a442cafa8d70b32111acae4a67ce144ade59d55f4afb112f0f9aeb5ef9361d316e274d2645406a18d734d75fe71fa766a144018d8b59b8c002b8d179fd3f0ea81c5df0b87adce650e6a80161d8461a9779014bba5d0c2ae71abc1fcf30b492d4067cb85087e1c8e8af28f3ead10730d9e57d2926198701a19e328cb58b380c483b51fb64e15606cb49e7d91d4d9054c947199e3de8532408ac1782aac8470c995034f53b0b7ad20aa68bf9d35caf6beb3dc70164cee7b47118a81c09f2d06fec72573429f74fa914c3f6e78297eac100cc1de00cf866c969d5c43e6739f94db18806677526cac91a679460fcf2d436b351f818db2cb8b189f36b2d95793aa365512de97903e4d8516b2fea88c7c46dd597664df9acd44466b5a4bdd6c45e0ce18be6aa2555d7a53bb21961c6878e6962f577d1f0850931b94299a26de7cb548ce00be12b4c256306044a5cfbcbad78bbe97d34a2c957a0750a4b818def11e39e4eadd1f4aeb9de368c23018ce80e59055b16462a1af06bcf0d1f7355ea7cadb97cf609e968d2208a7871864012d7680b613a8f072db3610687b423b659cb8a356d33a0afec3b9ef338fd3ad8ba5f4576b4f58bb198523428a9c1140a4c57990725c5a7736bdecf3eb5ff8a46dffbdfce6f4a2adbc489e888198db11e8c170f3d13920db312aabdc9eb3296fe7f82d0e08d49894a9955799c15c1c48d2f059da9ca4774f756ebdda37cad8ad9040d20e4db7b5a25d8a815a6eef01acc11c86c529725c499355dcc2da3192236bfe0ceb0677838f1b6a9f17dc441a1e05dbd073da9337635543a5aa356cc5921362752db1b429dca9513aeb626fab7cebe4bc0b89d819d6cf4c74383e229f772b52f8ff481200934a733b8f1bec166bd9a65627574e173bf34c881d2538985862f30de6e6a5f74731c0655983cf429b3b2f12181ef8382d28df9fe3a11e91998aceaf30f44c96fefc2c25ba19406cb0077cdd89307e7f8d0c4f51117f6e9376223c1d2bb4a79599637663ac62b7b70c2374c64f141bdd74e2396143be4691a9e0fbf73a4dccf28276aa379a86d75169f0c70f962fe8ef67e2bb013e739627293e46214eec9efa5bc28d5f8393684519c5279bfc33c329198d0b970d0964d85674b78d4502cdb94d1bfdb34434f3c94df83736389832196e2e4346bf4bdf7a21ee5329ad7f12c4a76a43da89e1604885ec7df27374ab82ca5c42334d448752814eff2adddb44348465c2479ef642eb4c9bcb6fab5c23e591a19d52690f1b1a2eb143b760ccf4200a14cd50078ed70bfbb492592b8debe30e68eb752c61f45053039161a4d2f7e63381081cb12e791cbe647d035e7227377c838af26b3a25e04fcc127a19546cb69fd5d1bdcff0c3b1ad5a7a41fa63e116d95a9ed38c8397aaa79a9d5c805ade74558b68a8afdd0f6ada7fd8b572510baf5eb8d9d247a98f2657a8e0160eda648ef29473d9d55cbd06250241c94c016e3cd3e9d42b0bb9a43cc3484f3b892c86aaead5c6b0eb17f09d5adab57e95baf4cfbb2d9bef732e0c1bd0b13ad1ed6faf0a0f242e06d08df81f5491088d1c2d288f9838d86fc60f45d9387c4f19bc3cc3dff9b6002bf87ab3c7669ee073c1171a679958932aeac5c684c6bde509bc33f571698c87e27d78fa65e6abd13c6ca3d1abe47e82dab555b80cdc2093081c8b2504c5173df56361b261259f0a86247088fe910167dd6cde63aa07f4ec36a69845bd4b38e9920c5b3f9e675e958ed6479be842f678ee9e7dfae02a2154204e1b7cfd2169847b82605adb8cf8fae9e512abef27c72188c8517a129089e32eb832c29ab2de9218860827f255ee1fbbbd917b1c3ce5c480aa3eee9870a9d9f9e334f642714503f4f8256fe55d57b257b199131d4bb921fc8a75631bcea8ed5d6dbbd0a4e2a800777b6b8e5b419d3efed0480f3146248e27c12f4c3d6ad6a18952891e93dbe796439b2f96096f99ed05e93a740f8f978f3644f0d122664dc2fce8f257796ae240a72798b71b2f639184527fe1f07b0acc77c77d9f5f53bed3043341c1b35899ec4e81a4bfb0d06732b47ed4481663f772c588e7fa8c225de447e8dc895709715eb25a20909e181d61674751f919b34f7293ab1c2036f21bf8cab31003ae39dffb84523684082dd76642d590e2b83081e61d39ad930d43b2654b44c79dc9d54a8641ee71ed6aef3932a86229d55af88f32521f2cb635d415c475a8b0e48d899297a5d2aa995a0fccb0255fd190e4d57d02da811dcaf16f7947a919544f8045dbcd9297ce97e87d272c43bce5c745520ef703524034c7095b21736dec238a56c433ebefe9e9e67b3b81baa232c42878581dc99830c637d92ca8ad2330b628b4a03ea2a16447430bde66c40897a7f22a6db62519e5efcdd2bf121f2f504563852e5894879a296e459ff6a8ca950a9945ba1045f3679ba146f6f069d69dddca11d42caae829f03ba6b4f602ad5e14305ba16ff1b39920a0417db899efc70ed960247886c86bf0109692c22d6e452f1b9528cec51b00b1bd9f95bda1a5f41e832fccf6009843a1c761eeb87d326a3030e1af498ac0458685995729afcf8662f0eef51b1b8a4e07e1ef682b5c0e1d4b7257cd9b74472e8d8240e0b5be3a0956941de243740a868d2b2cd49d5bad974d0a0d64bd12a0cd17e607d7684f747b36ac7278e9c1ef3f437373ff11c9e64447da9eeaa25b22dee6051a867ba820a9aee8c2dc0f3f9e706f3968032d609516d5739d94899fe6aefd2b15e2b6208cfa62efce8c5f933d49178bc2afc1771947debb51896fc89acd1c24766a13954d3d4d1c8c2c54101f49ec8300c0e5c97d5852329baf91e2f483cdedef590d8cad3e7297d223d65b70a8ae2dc6988f683b999f29d3723090eff429ac60125c6028e2472724e657393cbb7eee20cbe693af813249599e17e4902f696071dc5daa97835f31f4bc4bd3e72e656e96a81e6cdb72b6c7a7f25b3ab6ef173d2fdb85f5d849244198b15a66144e96de394ddc94903169b039ab2b87015180667e79b88d9599c8717dbbdf05eadb0dbab4251e57b47c966b9ece826b0343d6cd18d108b9573367d7ab5b42b0c2bb7a94768e0137f6789f0607781be47ac6d3f0e9b6873ff69f1887806b97c2000e08768cb80e806a09179ccba287210165bc30c8b4c9224053b5d89df945f6efb61961820c209679b623c467bb9d6dc73325abc17e4fe33716438fea0890fb61023cfd8366efb51eb95b44b36dfc8dc0e150205fb79e9af7cb842bfc818ff6fb7df0db38aafe6f01e2c35253950a88ca0c6bb58778b98473c6a66365447b0863d8774e56978dc48155e9acba7ef89c84f595a77d8ce2b405532ccc79f5aebadf9b4ed408c60faae0636181c98a1ead717b1b491ddaeb2ef4d10d7ea7ffc60da6d51563a2eaadb97c7f27b7367c0046b270b7af2c9a043e2408e0b7dcc74a76e9090ee139a347550bef431e764bfb2da12d21ddf940fe1c73fccc853488e9216d823213807711fd4aaf6ecd43ef2713d34f234d6ec5883a10f816f9fe129ca50574459f9ccce6afe9925f6725f271735069c12199c90eabcdd126c5ba3d245fab8859e151e161a9283a91f8a9089e2a5cbbad41c382bb8c9191616b509c3514fa49ba01ff991064cec3b07d8f646f9aadc1d2ff3d91a80432efb32f8c1c254a53064b32d97826b716412191a3934b8d453eda9c0ba1288d4f4f5f237fe2f6e971717abc9bad6f78fab16cfba226c620f04254349a7a4b0dbcfb39bf8b1cf8de677e8f96dbaf088b46ec4b411265f5ae1e843e0e4fb33ff1ed0e2a704bf9cb23f3b011f4f6437fafdcd6103b4a0f3333578fff2e85d270906d89e46937c3a24a80b670a03040d9488dd9aa5eb76c0a9c63c4c1aa517d1e93aac213b3d202659b8cb8b9b0f32cf19efad794ce5a8202030a5e435065991c721025ad467e6a2ba78aa28ddc0d7d47ff2d472d8951d1d8166a3faf3989e347241cb392d24d6e6b35f343160d4eef97936bc28c2cd2c2bb24a8b7c16af3b17e9848135c8ab493561fc29070756b89e4352347773e51de0574bc301c291925af2c0a9410677f2d267c3f268cbbec92a0de6eca22d4a79214976b24011bde12140789272d26c7074a42674af9eeda6671cd52ecf9fcbfdc6b79e68d28cef22ba50f8eea4a7844abc0a4599f16e1fcda79fb7b3f702d322ec5c62a46ed31aad4a95988661d0e1121b10de14735929c069eee3b39cace51965ed8a5c0b8e065747de13c1c273ca6b16f3b6d8a432678d4c9556416aa7a7beb22640a027105f898aa19e37db8f76e22c15251cc6ec9820b2260a1365a4cac2388082d263bef6cb4e2123300e154d43a0ee9ec1851e6e16b55191f9f402be865c0df66172cd1e33fc8318a6d13d68de6a7582f5608e6ab299a2b04ca73954007d6106086d1e6bfd28367ba8b150a736534daf918a0d2c0095ce9009570129946196fd998c2f148f0f22d1ddd201fbc12238fb98ad377f694f8816b537c0f3526124520dfd2120b609adbba2f8fdcc497699c562d9780705cb1e5a9fbfdaeb4f247f13039306bc5ca4cbd574d4625f29ccf00e85b5d30508570f5551f0e8424539602ca83e3f8b8d1fc2c205b93a65893279295425308eda2d029c3a445d95f5adc6e5f0fd91b47138f0c7bb4655643a05e57cb4e615b8a381d3ff97bb74d35595ec97fdf8d10f8399269dadf2dfffaacce83223270557f89d01ccdc9674f812b491cac49173eb7b728d7bf761dd2b5398df5e98ba03a5679305e2bcb6d84ab00718af7df1a72d8438cf81d63d7c66065246ba30216262eddde9a9e98e0e5aafcbb1580b5447e40480bdb768de568c72b8cbbfec71fdc141213fc5edc58c5e06c48b15b84ba1814eddd74cd56ef4b71d16f79ee32fb649a0d8a139a63ce77bb3ea9bc0aecaa16f773834dc62bd738e69cbd1dd7a1b9ebb5182d4eb75a44ac061336cb441546e89dd843d0b81571e2a486bea2608c4792cce6b31dd76197ec17ef3a9b1f7b50e1340cc64253433209cd54727cd05eaa8ab77b1b9d59eda81c0686129992e782bd39fb849e26ec448aa618c3b1680eb1a6f83a5a25c4c3f4e0bbf223496d3fedc7f52576d66356a92c14cf7a315d641434531d6177f42bb2f0045fec0e6c5a699294861bf6ddd1f9f3b2f51b40da258c37e0e9b204cab3a7979d338986a8cbee0a3b12a944c03e962af4a05e0241148cdb1b77777bfedb41368033767a3c1b3233ab2be38f8559da2359a647ffd2c4fadc43c2014889ee5331c027ff7595aecb1ecce01d4504b0c5c9471c446bf1d5c3224a1ee429b22269c825e41961d5dc81d15e3483f994fc9bedaa4deb13a1f84c263c20c34045727f17d604e77f6fac05058879f42ca7506cb5de092d821c6001c1101e30192df6c078ee089f0f568face775b73c086905ccb4655b85707d973238aba588e71ca72aa8599792addbadc98022f3160f5b0a05d829412338d2f0587e52e06da523bd13aaed300ad3655994d28285103ae57c3c834a643a191a82399fbce5589bdd1927be6f0e0e9e054bfbab45913e58d3d85fbb84da38e07472d66285d520af0560e420227ef090d63f53b4818e6ddcd4edca7ccd725f2c44b39c40c678fdccd45814eb2e7db03251aa99b209a4220f6757b1aebe2956671d0fb32eaf3d8977c59595790821e0e017a937426e2d2c2164b9d7d143f2952dd5fb9c8a19ab1ecebb1279a98cd6017856554d6199319d6cd4f401297cc8fbc3b94d143d443e2378481fb420efe318482dc97ed6a7d1fd2223a8789eb7798d403650e568e1698ce624f9456ab7f01cb2e69b52a94126a549a30424ac290531dac307b855a29dd844196bd461cb33d92c790d81ba832b9f154daefada7decf88928d3ad0598c684d4b56f7cec2be8cebdfa02d915c7b4e05ce79f0c4f85ccd840d482ee5e20cfcca11a53f5d21e2874a24b97eee60bbb191b08029a9a0ac1c29c8b87f39d9e09b1d6883e9ac6f06658a8c9753d51a16cd6b5451e8b8bba2da748bfc3e1e0916ac142d0b52b17dfe60d13fdf6daa4cd37a46969c597aadd9a0a015eea5aca22fc14b9e28eb803275556d2fe634273bd6fd583126b45a84b0c9655c13a609621c049889be2b43d8d2b43b3f54e5b1102023acc3e62f4f31a567f576e7e2bf402cdf613d0e300737ab0269ab7ffef505951b96f1164a2bbfa41c33686d7952d2d1b3491b43d3b3b0b606c5bcea7e24bf6d79d8f08cc6112aeff3887b8bb5649d0707169ea7fdcdc5c8a8e5ea036957da10e505d6ced4b3e589066d85e46f0c0a21fa1926d31223e02c708e449cfbad0370ad016967269161e868e889caf961e54b67594298861f265ae12c865d1a26d64ccd6695b210617fa1f5200ca6c106b0c0ed99596736e384d05e38e3fa1be0b709e1b5031287131b59535d1d0d16747b059c3e8cb8f8e88640214905b995478656e0473a1a456debad5ab823bf7f98127950dba6b9ac293263e25558c6314fdc0c758a9ad9608a41d3d33b9e34982b9b44a2606730ad5a2621eb7156a1f9e26db8f9cab245e078ac60bc99014134679f91a9f7b95e6250f11e0c6b7c99f60591a834b2a844570b454ab88c5fa2adc173ee58ffd11760bca4165681f5805950a10494d46d246a517479ee474a5578ddc069c32ff1c7e94db6ebe28f4137ebf99f3c30f8a4128bdb0826592d96dcfe7b59efba2f002700cd16c549ae1ce5f803a770341c58dc48806a8f583ad6d4199ac63d61f8341152974198211eaf7e002ef3cf100b6c4598be3550b957891efcabbc65555a689876d7b1cc109acf8397715b273036c1ffef5606043399eb68a32732d56b3e23214769d67cd972c4f4c64aefe65e21ce5efe15f133209ffdb3cf76b09bf782c37387d7c4ba6ad5a5bfda93b56923b9e8a1b32b482b21164261a7498e77d4360828dda7374644c3d49bd18423161540e775031846f56ef2723815e6c4775aa90e499eca897f6031a1bad95f7b4a23c25a8e7fcd422719682a3983277016eadae44b70e27f0a18a2f2492a0ac98e1f084d2286a8eb7ede208d44711944a9f53e36c583b63c04c7c304142572b448f67b60c3c3d0b2a8a1efbc07d6db255f710bd84b2906a1918e370068e0ca4b0ecc99bdedcea14f9586aa065760fe5554f104ff8675baa6aee2a9c1f9fe3ef0fc6db1694b9d668b02c2c647a008e2193da34f8e1b5f301801f670f6025aacf8a82272403ee0e6389ee15d65e6fbbe0eaaa20f5696bdd75bbb1d08d15c76f9f27573ccd2bc192525075483049595c2f3304ddb4b01862a0f00de6cb9b0b8c86b23b3984d8b075319ee3bad3b0f79b3038e6a121e220a523d1498cf845f63371d45f384fc6da9af11e17f61594d5e2a17c1e4563db92041770e686c4516c92367954fb8a5cbd8af1c2321826eab20b960a136344ed5ff667c28ce6418a9e1b809d3af4d4da318b6d5480460334f8e7891e9ee415b028edf2e90a4770bce85f21fa8358536be3addab0edb8f64783f0ca97dc7dd49d6f34b353b6bebe3008f284cd9292798b44f8afc1f652ce69c9190cd04f192d95fd1dbda5a641f5cb3fca0964e975ed8c6499c21fdc6cfd4116403fecc017f5dd94c0a5bbdf27725c371e02cb202d98dedb98aa90f0d8c655f024c6ab05e35aa6a2ba17bd651e747669070bb463f519b4920c6465becd8b4cc12c93c87e6f3192b8a208b8db1fe6cf63b0f6daa672992405a4e73c1064063ab3f2dd5d924873e07a8c35b3f42c41748942a3e8ddca51c8657c61794290c035550379a26fb30a4d581bd37ac2ac8b86c2e085dfde3f2d6303a4fec877e31514b9462d4ee5aed446233a66474fcf826edad0f3c63fc1671dbfdf4cc323bead8c938f687a18b6aabcad73f0aa7968877d8fe0ecf26a616201a82a11b51cc66eb771360dc51f4fdc7e277e6ecf74a1acabfbb6e4593da90c3920b16c909855774a525e0c68250ad3743200d1c972084813375cb3faec7ba694f7021c6dbc6d4498a6ecdcca9812ce8ad416cbfa68a7451e4b452a8b706d8558f0308f0e1bd707536a6abf10fa5d3a287f1e68467e943fe4588037b6ef8bf488e031278aab4814d0059068b34dced0f2044b153adceab3e5e3ace0270e544dd20191cfefce2316f09bc2ad42e47505abb8e5e751eeddeb6e7320a6291fd487878eec34b71b2ce4a3517988997a6d484051a040e5cfe1816767b9d0ce6f9dfbacdc5314e3e1955623db9e2c2bdcef08bf6e489e93ce612e93a2d7cdfc9b663714f0f9407512a671d4a55ff4e225e01f5c0367bb1ed0bfd91dd41ede2d67e3396ce2c80f15445e6ff0d23da9d8190ed4502d517cc49da836a6dc75320ed0503a67f910608e7ecc9869a61eb1aa62fdc539d755f467aebe27482a3f8cd3b776eebfd1f9555a9783747261043a6b9286e5be45fe10c1952d8ccfe91fcd8896c04e864736c8d76407ec9c75529341b5ee3ea9683251c46fcbbfef125d5db03a348e8fddd4e7a6c19a56f8acd45330f2e1c945bceb0a0700aa543fcd7e489978eebaf1e0197d2e3fe65540abd96af6bea74cea40a3e6a9ea2eafc04c20400d24ed5337a6e52fcd1c15880ceccc446647fb11be21f541453889d05ae7b656eee08e4b6307ea7457ae1f0c376bd6ed8646a4a119054e78f0c31d680a8831c07c5832445f3f636e863e06b27c685fa09f44e08e8feca85bb1ce125ed22900cdc6fcca9005cf028fa202cdbb1b6ad0c1f1422402c3b67b20faa509f2eb06c4ffdd70629224d2578a363fc2e99faf5b130671392e6f9b991352cf175de7546b549d0cdf7900cfb8929312742a15964f694b87fe9beefa10397fdc59571d97b355d40a95de689bf8dc4401755110ef4c54c9bf9fd8efdc9d1dff537bd2a81050d7a8d286ab147649b5f0d78c8ef957de16eb29e54a4ea49f293d96f3f7f3d89b4bb85f44fe3871a87a97134bc03cbb2ad5c448d49392ebff188773dc94c5150eceaff7e3dfd4d3cf9452ef15bab08767145eda21fc30b16bef3b95eb2b350a1b9f8d75d3b88b7bcf870fea307676019dcfd254eac3b7fb885551a9cecd01091bced8f7e986b414b103813bbe359db017523f8175b08cd7687f48843fa1f8596645b72f19f32af48c93b16cf924c425960c2496ec05c6bcb85399aded27824402ab9a1f8634d44a0789b11a5b3c2ce885032f9148f8d934e550c0022ef9011c9d6ce8613ab78caf9929fe9fd528683c93f03b1722f485e3ca8bde93a9eaab2a4cf6bcea33ecc1815e2426c3e7bc72757ef8b55bd85582f9d70219ffebc35b433daccdd8a56b728f21e663c253b5064896d58e1e1568f556549b80643fc6d34cded7f08f0c67b64456e472a0f5b5f7798024ddb14d6a5f54583a346e92aa27e28618fa8629c5c25e013f98a38d4886640ee65fe90e82f1913c6a9317a1524328a9e4903532906fe7717639f1c0ca036a442e576bf2dfc006a73a53c8ab037d79fca0e79351da2ee2adff8a267377d5a845e00d7fe80159b97e6aa33a18a8d74bd9b0991810e8867aef0079df4accf07b5c3736d7494480fba74360be6bf25ae6a7239e53d796358d52a876ca3349a6825aaf10743c15416c4fe24ce25fb934aa16628c9d596188544249a5481e0f49bf882466bf674456fc885f698a20c60ab720874f5b8f832791585d792c1a2e1123b35ac8cc3206e97cb91098963aaa67964012b8580a3ba582e385a93b037698fe5137455a128e797890feff3eca31b2c53f0491f3267eb17ceb6e799b13237e69c068017ddc09fbfe11d998db1b26cf3bef5ca778a5d63b997c4ee58307b393563ebb5dd43891b55bba8750457568dd9c2d50961a082d8e72fd63c7a6d7e39c683c2ff38caec3fcf84a09d2b57c77d7a63c9bced405c0174ca45adad5153790d5ed75497ea93830318044e5cb29ceb1e45e9223066e7ab58e5df6a1d97c07469c9a3f0e1811d896e2ebe0fbb7bf3f1e7f5e149445f1e3fe0cba9d826270a10bd25c52c45140e074e71b8660c4c82f850568dfe0d774fe03304e11d2f52effd90732b0205a2f82c1ac36e6c4452738f239c6d33bf6f85421c891f714c1b3091f68fba8d041fbc59a7051dfe61c320ae9bb5e87e380a06da7a44b293390fae120da081e2bdf33fb072d2e3f355b734843fdea60f6872327364b5ff8fdcb35978ffd57896cef15b2696d2af9ec58c832189256e1a6c0ac934aed01eb6eb57d453d71ab9300c5e64906db57b812eaaa91fc4f0db1908a961bbb2cd25640122f00d7cf9b3394841702fb2316a7ae206a2e598167176b07fc0ef8d17d51f894d2ad2b4883ad75ec1b71eca1f9973c5e34dad7d68fb5c0c0341f6ca1882177e66292f7fd2b31ec060d287b92012b31d134bafffcce1e5e59f102aa7ec8a012b19fcbd2e7ae527e883c87db7601d9d6e963501a492ea44e10b1bd96fd8174404d255285f9259b8ee51e614879be170bb3502f4e9530be11977e0166d3bbfcf2814bf1153b11cf24ee8a8f154b274103c254678e6618a0e90956a4d4db5cfd09767e9e03987875d5603fbe8ed8e950049fd49ed9f33f6d5e13ec8135baa228987c9819b21ee50bb1dc18874a58f98f0851e8b413b24dffe047a296aa7e4f36ecac7485493fb03b52bd246a82376fb4e9010ec4f9b1a1471dc178c2feaeb30513c24a923bf9608c02b4222c6632964e2399e7239f7af70f6bec171bec0c3d9799606b381f3e71f97db2f7010d8c0bf5db6da1992607a2b10b8f2a5cd7781d634657bcafe8aa9301435ce38810619998fdfcd8cfc923b9231b8c8da7a7491bf26b3d0013969c09ef560b7fb34734a33d06700a2d98c115ff1634e11aad35dca9e8f1a0a31657b688046aeac87471688281e6a37a0ed2a571c7b30321b8adb61fc94392f7d58e9fb361967597e447938bf8f910015dc6695d793ac3d98cd469dffcebb691c60e37895ad84337de84b7833288c8ad3d441e0dc4f93c4e0bffe99d2766286442ba541c1c762019669f474c26d6b19534cd65113b3e7aafb0bd2a53d0078ab5db08eb9f2d5fbf86c29123d5f879effb8a090758f8baa68419938f6c9d0c870ada7b60cb5c10e3d5be1fad48ce1118739034e33ffcf911dec4a47d4af84cb8c6b0f4db7c58e0af79f71eae0b3e60bf7038f1179d0a361d4795cfdb52ac774307d6872a4e8988c5e2134f299c60a6f265187968dd3cad9f530a8ff21f3aa8b7ec6e7cac0829e2cd58ea66ff16cf90ec3ac67b480e61b47a7bcb9c7bc09ac7b16d1e93e6067ff82395d456f7cd5027d9a508638a5de5c88e272fb43df71c6dfbc759411de1a7246503c49e2b90635f6929b54b54a97cbbef49a7dd583848fb6b9ba3bce7e6ca7885c84e05a2c41ed938cadeb02aa2936409f89724de2cc62e7f5d0b7ab26a67c2f216289f1525a4cbda19df0a0959b7fddb15cf904876705ed963de256b52b5ccf6979d5ecaff6dc46ec6e40b8567f395cf1f0da51233c1c4ee945e1a024b942ff79d6137d99e179bbc564b555f8aed17b51a60c061c3eb1d90813cd890a92b6909e7a33b086f6ea2d2dcaebae0d97c785a92e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
