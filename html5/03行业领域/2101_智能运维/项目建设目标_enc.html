<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ab45e913584c5c15f0e7a9188d01958b646c0a6a4fd71008c7eb8b7e6f0dd9c68e1f7ab60df61f1435f052e96c6cd72c2e6847c935f80fb126b8f654ef632fe5e8f3312d173d1e0675e94ef5e428c8da8bade8903e6948dfe31c1db380c4581dc7da35d91fd28875d47df557e0c32428ad9da2dd7773e20ef4d6baf7b54f4b69709198f5aa8e84ad442f948c7302988772cce06857be76996d8662a949346ef562d747b540efdbe7949a8599691bee74219b4041ad463afa958eda8593e5305c99c33691101dd40bb7dc29ab6223dc717d3ae0bcccc93030e7c015fb57ad67236129d0682dcae727a4f0aaf72729fff5a65cb416c482d275653b0b9f8a54bd93e16e53f26fd5a28be2b5dcd587c34652f8c1d6a8f244cdc6a655040aa004e8238d898a65e6f4946db0bb890cfe9fbe65d10242af4ca31cc6879d9c5ad09b90ab07fc713a7a3322c378055d7c2fb74ae870df7a44ae8fa54b8dc989c77cc701ce38351206e522fe0f404328e4a311762520cc9b78acea472f4a5101ab027a482d365d81bc55d66d97e0a328615fbbf57fd56b23d78facf94e5ae771fedb487f1a180c9107a38e85f32937829bcbf92d620e8edaf1000acb95c29d5d7628a77b67f951712402035d1ffa4069c0b75c8f2f7aa139c37456cf101225405287d7ac85f06b3e5836693a9c0f2d898f95bb4fb07a2c321163bdf7521035269598063a794830bfac22d5d423e5c4e3f4eba529c905ce656df60916cda47da0f8154f63aa85e7f8072c54abfd8909fa428e1a236ccb361c9939e86d19b73fe3c0204f5ab948ab2d5c4b616733a2b377752c4a9fd7d0f807d1bf361a6dffa86f6b76825f61719383a99116b89a98607efb2acc1bdb470a3f851a56cae71589a8aacfbfc1a83b1fec79fc24ddad83472e4d1b1ae2ceb2a0b40bd6e753389b8838151b967ec592be79e910ac42cef3da4b1005635043fdb909e44ad39ca00deddfaf856d163e40efdc5c68b2fb96483d5ca0ae2ba2b96f6efc7209baef7f82c408bebe379d2682435933390e9ab4e4561198bdd59a8e335aa44ea834ab35a2a1902f8f3867ac094bffe3f77154aab9ebbbdd0f4833869e2b895d05391869c4c17b592bb855a7c64d0cc4f729f9d8b0739a010a8c34ec22f1a91c230af5cbdeb5c788dae978e0e9f9300eb9943f2ec4ac0d82cbc0d96cfaae749829d5c242122994291c1273ef763580bf2168d7fa9fea80758f4fcb3e00fa24d4bb8504992cd8d6c627745f0cf27a76b1c21c66c697c5cdb201f22d4c505247b5d8cec1091ced99e7271f3562b13ce6774cc123a601fb391569ab766617b4241a6a4078dbe164a39458dbe8b5b44acb92e12efc939a8cdb29dae6fe2dfddfaa525c0bdd94ea608ce7f24379d4fd3948510958bad596542268a40e3fd3dcba7625f70ac460e5dc4fd06fe5bd453405aa4458b1532f824771fb1929491630dae8695ea70c8b721126107978f92d7607c06f35153fa65c6ab32efb955168f9462e825876e47afe8df79b25d760a8168f97e54f399a600ffa9b8f0448bcde6c6825b1edf223c085cf94518868db0bb5c5c22c438b54f17b16fa33cfdc9d9860dc2cd5d1dd9e4e6f166776e24863a4097a1ffa3fda9d22d6baefe4c6232b9ad8fcc93b49da4b31c3f259d824834d14dde9bd7c4c397a823d1344e8ea16f15ce8e12c6b1c0c2670952cef3998de557695f35460f00e9a4486b6095827748f0f802e3ea485b536706f9cea234ff0a9cb78dbefada898d2ae26da9965139ac2d01572575adb85193b9b948e3d30abe185acae0aa2c869c2840e407bdd575fae5c3e42bcc67db3691a483174a1ab4ae24561f78d23f3316c279d1cc3696acb78a72b9e8ecd031392249303382147f4e1aca750df17a95b62ef36270369c34c77a3c62237a8ff8e846b639ec1fc67f8163bad883a88c7448729c7b8958b5a900aace228da60ae9a03a6095b293f0435e5c9b7b80f82b4c4dfa8bf9c93aecf6d6b4e9df68851282be8503526319e43415cf254770e2216df6fb79d9d12c5d616c1770539ca91a9a3ae3729d7ebb331a1156321e578d7bc0dacbf55afdee3870a00e54966bfdef5c6c65932490ebdcaa45b6537c1f91ecea6aa844fb96dfe9eebc7689df4edbee014b4a291f3a00cc3e7e365d81ae1983193dad29f4c38eca6011078d15918d11ccb78b187cadad98b309f9aaff86dfc6f78ba98e3571ba7bf228f7060f7aed3c3edb128773ea90d7d5bd6001f99d993bcf4510f87f3c96e9b7056b1dac6e017e17e5f34fb4c436d69c6172775ff6eda813007381671fd24c11ca82ef8d14ca5480f715c04393171a541340883b2f33f5d5f70f5fbf554eefd0da1e6acdfd85d88b8d7206e2f0282602c70ee1aeb458b11d72f1c72fdc87ecf97a18daa9e91a986e3e9b0cc163309b8a3dac254ca3b51351df261a1d9441a63bebfc67fe23a177975416fdbf513d854bc97a764fe5e7d72fbc78b74937aa6eff0e1bec0a4ee05efdec263169dcc1e32e3cf4cf51b2812c52cf3351b1bce2779977b31d4a147145d4876054dd7cc01ce53b89b067cf32f2f9e8636e6d5c479e7b43a8168e4174f4ff0aa25c3af7629185e0772b44785e2f41f7460304e1026b116e7633fe847187a155d4e813c74e9913416850370444a4db6908345b2b2a6a9c63bba5b36f4e3d674472a19e7f939ff94cd7afaf0fd3273856ff92f7da8180d17a5b86aa4e193876fc742fa46386ca17bc7deef21e495bfe1babf4b3ff0666d1bb3ba744daa7f335cc5c2ea76e25197c82c05e1139ec00ba767a858319eddde849efc99d6fa00c938f0862a475eae6258b88e2fc3f50bc377b4389ac4aba7ffdf6d30f281bb04756143ce597417e040fa80d11fb263f4cb7d66a3d65084cb22ded415fb43ff635bfe6e93260534da7865256e0c1fa5c47a8450677e9fd5e02218a83afc61cc74544c0d18010a0f550a792e1633651bf96afd365cc6a75f57543be17cb9e513a3a661064b0323e7323854360cfce3175b842299744d4c99d4fd4475fcc5b5a401dd061f45475ce730c096ca43f241335f9cb026c8a5bcbb249a6ebcdf431cb068400f1cbae3de026bd94ff4831121aa5642238ce124dbc60d1f851f9e7aa7c2284ed33ffd61a29050e355c1f1629f5ab38d250d64dfa278c815a0bfeb2331ec0b95bde45ecbe10ba513025c9197f9a9397b0567379da0b1273bc9bae6aab4a8d4041db8c4072ecc11b1a90250af4c1d582f7894b427b5d85d0d03b5548eb8101f9aac37aeafa8ee7420b549eb5f4c9edf232fd9f0c774d372dda039452d47860e30dad13dec7828275ade636a53916101b544069056ee722acd9f51d425338cfd356df7be382c00b2cee64ec25f495ed342e6fbcf389c7c2c8713dfbfd4c9e69632054bcb3ddc539053704ac22ba437361d25c31a79c61eef986538082ae9f0eb58acb20bdf104047a4f5078e188ddff3c572a4718b51d08580de0c686fc48dd48b29e6542e5334e936e0205bcb5a752b2cce1ebf18bb8f18fb4cbec29f97b9ba0a6efa947cc314c90d75a66a2e7f6b4778de82af20a57d591a1015fb0f7ab28134bd9c47c0b97b6d03d42991590bc0a5ca9fb76b3595df6b01268de670bdd10f733c513bf5dbf1cdbab17805b025b814e1b1cc7ce8cf5c6f5f7a800c0a2b0743bd9389e2a07d8819d7f707fa3dc70f46bca67df73b5e08ab77007cd862bf349ad4d9196d36cf7755fddb836e258b48fc18d679953002eb9b52e16a7e4304b15353ba12fc0746d90f5f607f056ad052c41ff8c32813727b91419912715bf86a3de96aee511b8df750f9d3a659ba4b3db49b5c4fb72545b68ffbfb41bae017fe9e25b64488dbb52930d1d7e4aa2855f2ad1107997ace1583a47d6a73a26b77abd529affb033fb9e815967068fd049eeb3bb0b55515e97d2cba16d54734d29141fa60c1d208b78e0189ee0da5ee7bb52deb9d8ebb8582e32e6a600d6ae57f6f6c49819ee88d019fa4a3490b9cdc5f25bafe4cd9de6f77888c69ecbf94b831a42153bcd83e316028e16c2d24b30141f3a2be074847b017fe1425131cb932e97dec5fc944ba130f6d47ba43ae07871fd8897e07f9276b20a249d87e2b4f6895d2038bb9ebdee72337325742ccfb7a81b43701d87344555ef0689cd660cfe74fe317a637aa56847387e4027e3b801d7ef84aff0808e8b1278fe48827a6471174adfd2c956d7c181bf9718420cb45b6e1505aeef166e02f308dc6c421f0c500a41c4bd458891181bf2726ecc63c485124831f9e3f3cd1775c55e1d260628374d6d60177f7daa4efd38c68ef9353a2c4531e6b6e907d12bee884844eaf0b2f5bbc0d5efe1f7a28df988f5dade2ba98a8db8bf3212e2499d5ef32b9b62cd1edf0743ee9cb65ecdb18f8c36053962fd07f665d527355cdf4c1ffcece7d4bdf51fc022683b48de5ccc3ce3ec632735eefbc74dc7c543d4242fc5a5df852ac1e9e8cfb4b5fb1279574b47391f1c331883e94c9efac6273e3a4bf8d13be323589e3fc9b9b72e6271fb7d5434b0e677b0ef117aec2fca8cd1cec88a42025d76fb71c52a34be3a774bf59e79f0f7f03748599e2c2332da12d86fc5db4ce711dc33a067ad6d660e7a68cb37d52bf0342957bf02db056a8b614b6ffd73c9c08e34714c0463f00227f913415a940beec9bf1f5bcf1008d13e0c26e177529e80aec21c36659f22b59a9049bd4ef95ae5bfa73e18e938149ff8d2ad5be8f01723c8021f01ff40ecce3e8e0c0addce4ab65088a1cabd053988a2564bc17ca57928ed5d0263dc4f83ba08ed354a64622194cc046e2ba69c2db4adf93936e380a9e6c30e4c32f2b69369cacfb231e110e68102f393e4eca44ee447699864002e25ce98903b61b9ea03447bd4faa578287e848e531bb23da32cbcbbf85ea5ecaaff58039de595770047b4f28978e3170e09632f52d4f37e31dc00dab970fa66f23911537212f7c413a8a88adcf346b13cb48fb7342a2f62b971bfcfd34101fbc62e5da16c7876efa35b9d695c5c39f2be75b7602917e4fd50e185c76787eb59d918c8266c9895b46bbb092e43e48d9002da5e9d881349f6578994211ad847cef315bfd3266253cac7c210ed7bce70bb22510539ceb42cfb1af21404b72dddc16df1f851332096ac3282b70c47680e877535d6611ff3f96f96edafbe37f323d5d34d34c68055e780089ff8b4607b73545a4a82b91f99fee426fb8f8cfff848a555c80d27ea4cfbe119f5b5e1ebb2a1522f14286232233434efa4baf11e6b0ec4e3aaf7ef7ee380ff36ce602628f5ca2e6766abae36850efbba8a9988297c933b72c6a5aeb70771e8e309e38abcd619f7aedbef0bff964900dfe4428665b520fc99880618037b799d35da6776328eabe0c84b0c25990b32c1c69914a22f201c5b8d35f8b71a229844de5d64d47aac44ece77eb545b362537fcaad4f0e20e39aeb172fe7d83523fd481a37dab6b4cfd615fa90f5b4cebfad4a6804e6acf04f02a0bd20d40d5067127385286a1addcb469af49d1aa0e49681bfb90fb50d9876059e2cd974f0df878c6276c2467ac860494b31e013ad3170e7fa85051697fc865674d7c3cd2b61780858298c09750d4ee97d4fb39e775f0a969751eae22c8dcc859186356bc1176e3b33a45297d073da8784dc9a294cbad8a038cb500bee07429cbb8643aedfa4eeff39887ab8c830dd87f9423e3d243f570064236d16ca906ee3d59a255aaedecfc0070a7c10905f302d4875858a2ac7666615d8d07f07c7eb9d88fef55e2c3a116aa022bee9e5931b9a0bd19bafbb29bdb6d468904e30a4c36eab5fddb1a344b4f9cd0bdab32f5e7c438d4bd2c424b833490ca8693e854da3817648f3f44c5e947088ab6b1f8dc156a6fd7a2b64bf867361e1813e4c6e064a3f1ee7adbaff4247caade62eaec3c3292052fcab3fd138ceab412bdcf0b09bdd5e4ae7896fff88494122a8afe6be788e50f77b4e9dd98a8166644b6aaf61883d82528477f2d8ed08326140674ccb8c02556947b99315173d62133ae70beb13d19ea9421596c872e1aaf4f41d91040bb72a3ba300573d117baac8614cac48445242d419a05ba6e6ed1a6aee3d887d737484b2ba9fc4503764bd273343cde8be5023c44db932ffa5d257c89a30b4cc08ed306ec064222ecf5f6f11eb6c3cdfa629b1a73e87f7ab8cbbf8af5e2f62cd20ad465973c625c13720ff49c2a051f82478edb7a7fce821c56e7f1f0759bc680b0910c6711b070b313473f0698fc80f13a90abb423c2857d27964233cdbe0ac62720d1c6050950d1c87571f1cc15af98daed3e4174acda5a66a6347e77545c4fd79ed5f56b665e9291d69ecdba238fd1d5056976101a8b18e36194bca28761c0ff79bccdc3caa378c08b75b2c25f27c746667325862be34cdab9e35147587df3fd505d757ef942a861724be00aafb67c0d3bf30cc863cd82c9cd3a0a701357331875c854f0197570980d2388cb9c1cc8f11e1ba946c7e5013ba2730b033be217c271bb19729e2eb21c0ee462e1b56407c337a98d33dc79e1a8736c963a780a06cc8acb4800e33a30128fd5a9d2d91db43e7f921be675d8ac73dd73060e5803f4533cbbbe4e49b72e4517da6b938239278f1e14041bb1e2c17595fc8d7fe9b71d091ed4583603d0e7a96d096d55f5d91edb04e5e833b4064db0d2d2b9c0ad1a2beccab15b13d637f9e1472f753eca2189234f0ad048d09b53b2999b6b655d88a481234f03d8a7b1c20a4636c5e95fb08ef455f719fedf6540c21f65cea0af3bcfbf894e8286e240cd8a7f514ae68e78e3f9132e4011f5c254c9232e35ec9dabf0556456f2e1eec70a9c6a42934aa38ab84fee601dab86986c1270cb71489dc351a9404f83685703c2202466754d5fe6adb5ac1390f0a354285ac4e1a8103b4c5c747a4f3c458a15d74c34b3f2f0395b10347f4053b2838554fd10034351e175eaef4632d4518786a4f2aee429c9037100a5fa3d12a05abab54b6e35548eb15bd0181f5fa3dd2b574cf5f17ea2d4f6166d31e307b9556bf88cfc051dcacd1dd9f2590be994bb6791bdb273c6ad5917ee910947b6ab12220488476f02cf85d0ce58e98e049beabbdc84e68cc1b38b563ab3f9cf1d42616dd6b28eccb43c61dd452923581a9987a950682c0b33db5e78b010a71741283cda7e958a5197bc93bc26fe5139f9a09ac503d7ceb475ef6572a2c61793b62385d56a9a7402a71848ae25774e23ddb06a6ef4800d99bf62298fe497dde2cb3109bca6315ac2db69adc9eede3ada2799b2a7da9954ffd76ca7e06d7f7c34139189e057feb926255c6f7e8832d36ce5a561df04e8f78db9d456855468eb258bbaacc6fdfe082ae3958403a0635de59479923ead8f300c9cec827890b236ac0e7e7b2edbb2c53823087b5f1747423adb873f9b588ae421317f1e5d0ababeecb6bb298308ab7f21fbc097fb1075c7af26d3f54df754935011c6c12d604ac4c20650eee26f06ef83dcc36fe118bc1e1e67c8eb3656287c7d34b6d858d7f9c57b5407fc8bb1fdfe2df874cf9324a0251fd37bc1d60a6ef8b498cd1b6b1ee95157275aa5ee4422b811703cb582eb699299f69bf58245dad677f12bf99a2b1b3ab0af8e3b531529bf9c9eb5d2af5f3702c877d3b6d7558c7478e99800057eef483c43f6c9d126336b57dd43385f8aa18ed6dec06ba3f99020676d3e56de4e43f0439e7492a679bdd91a1dc38b796d7e93bfdaec60fd2b9b830895e7023b3d1acb223f305a3d6c5445ef8bbbbe915d627314ccf7d2cbaf051a3f3f336e047eb116839e5b43f3809c6bddbe6338ddb363117de5edf3dc7d97965ea9c58f58cdb13a7cc05eb0bbe95ad77bad7dd72be4537385177259f1b35971b92a61380f53acfc24bb4df80a7403ccd31c12e42dc4ac608325a87148fd6ec0371a71b4f1e91878bfd8437b34be8b700ad50976924d596766a9f458e00c5b12676982991719f4ecdfb08de0dfde3f3f07f68e21e4826734c9f8a03bc6c4bfb31874903d44dce1369a8e9ca45c6a19cb1a11331bdad8c0bd3f577ceca7d5eaca7a307d1ad4756b1253e8049df04c7dd48f32b48a0e6c2aba82b2b957ac0078b5223413e26904af48218dedd18de48bc7904eeae4d12814124a14f0fd2385466016ccf6cb8247f4197ef1139158883ca8b732162a64b5e6d597df14a60073136aca17413eb83e7845a4a5aa0c47b9337954f339dba061853abbc46e8112bbb4eb1013ccc6f2a65de09c9473b4f5fa9d1088ea07e853d96eeb21e26760c19e2fc985f3a42f1103b39d8f17abd55b649bc4297e6a7ca154b76dee3252dba51054e09a4f836b39fcc0c2e397d76ee6ee476dd9842c0feba5617e00e91c6ee5c22d9def832298dc4e52b1ebd7ba791380b37c72fc4aee7fabaee911e32a4597dfb9b8b97d8fdee529d86e45a8ea4ab7579907217c3f7d0ef12264cc673df220e032b5216ed11214eb6c10411a81cf6a20a3a3eb329055930a88191e2aa0988a2327aa1f7ee3b1c53c5c09b6c9dd4f79d94675486b38ce2b0b0aea42680feba2253bb99b4755c7385e0bb94ef4a267f4ef92dedd54c4acbb8cc696cfbff0857da07b89f09294990284a963e63acd70bf1fdb7d4ebde29c39fd5bc95ace818e06b999f54f27174d9f669f622078f7cc0d8b6ff737d9a717c682dc398dde1bbbf7e8df9d913cdd6b7fcb1bb0b83b5c6b87e201b23c1425f8e834d0a22b747d01985cd9cdd135afda5971adae19250895a893be92d2ddfd73c843a4f0ba935af965b515ac08935fa78aeae5d76f7f6743fecd07316867ea7a40c223036ec2f7f5cdebc5a8ae72f24146316b47ca761c788c020decdd3b51bf0f834c077be21b99e339136abeeedc74a20af378fa30d54bb1c4eb623895de8394534e247fff3279a421293796b73c650155b8cd6d2570ca725fb6ad04dabd0be4a0f5d858bc54351042ef9fd3a3cde1309625bb66909f60120f30464216c792d1b692bb32d238a36e38de19f469d19741401e24c8d5b0ea14a4ac01a3d2477010abd9f0cc89383bbb88937843325850e1456b2b4810a810d2580a70f798ef0453df1cc0e174fea6dcdfc46493e5d5e16a219786e6a5806fe3ee4d2b5e3fd9969e35913e7cfc10b82a2b26519eb9b4004b45f92937d5a8ea51c0832218229ce8ff9a59d21d72cfeef7121e4cdf51f69cd2209fe5090ae21925953c6ed3e79b731d51e3efb51c7846b32fe5bcd608a05b0f19743b29be254e50604fa96799087b67ddcee3e24212706d731ed96220861ead91cff85e01eadba338fc3ba95d9ce84836ce696a5781ca516c45b161d573953729cd287b8badd58b7ad0d44b122c73544e2c72b510394d19ce9fad506800c48166ce2b035304b1e10ad9046ead2d3ff83f3d32929eea1cfcb00cd2eb2f3fd1c6f806b18f89c4d1d9294d51c6bebfa911970dd8c32c1b341919bf4b8c8e40ab827ec76a8dbe389b02554a6e91c56d5c0b91f96488556b3e13250503feb0d4e66d66d80805ad8943406ff13eb76253","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
