<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ca1d2d151025334b0151482da0ca104eb45f11a9cd174504b6e60e5fd90d9896c7940f5e0d68982acaf99905061916c291d73570a4d0d0fbb6ac25bfc340b9f122f8dc476f3d87ca7fc7f704c6cb470bbc027513a414a3f5bb8ed08f3bd36defd6aba18382cc1a2b76f1bce3e6a803d8f54add7e1eb4c3b23511230fb96240b0aa34623d5de64bef21566286199dcb517c22b558fba86c475c91f462ea9a48b3753b794f4aec1c751b0f1660edbf3d9f7a847e7dc8d1fb78bb8d14c1cc08d6d4ac626d6c5245d739945c24325114fefdb949fb0e1db13e819b9de2f0daf84326b4a51169a4cefecc1bf2d13707c4bf669629a00223783ee51190d1f1f2d68e2c54fedb15ae6d70d27b41a535450bbd4536a2cb71512e0bf11ff7f72f241271c815c53c2b4fa1faf08f08299c083d45615e0e76798717b21ffe77e078ab260730d3859a535c83c10814a090903a5ee643b6079754d3afa3a68cf16edbf1b2b0f8cdf8759f28b2586a0ec1e9ee9498f1ec69cb9a51d1656710be61dacdec7aca699b887d69bcdbdd53062ef2eb3b877b191e6312d1ba6fd32965cbc8b47bcfd79c0c764b8d78f41bab95c5cbebcef8b21e4101141603bffdada56184170ac275601e0fef7e30a012a8b19e2330e7edfb37ce33099415f5b0e1aeef80889f87a599a466e18d0b96da104f27f7c5b84dc349ebf166ee2bc528a9032041f4774d6b9ec89c24bbeec08e02cce85c5e132956177e8af3e7618e9e59f7f130ff5bf69feef593b98aa98083141fb081bf2c23dac03b675f63a7e2ad2e51245774db1f6c908ba4a31dfbc798e1b3c7f0efdfb352fdd799991b455d841279094104f816e262dd9afa294556891e6ef3a784e0048d0bbc8d232b935c505cc08efd1e8fbf691bef1e469e27ecc716440ae1dd10f44fdacb633f430d834acc3329fd79345f48441c8ec1b43302c79492273a7d551ed48533f6976b58005be8e8bf3a104d9e42944edf7f41be92371a05e962d7e4dd68ea33b80709fceeddfadc7885a1f3076db1433376a200fc82338695ad407b99c1d635d8611bc429d43d605cb3f03ded88b4d6a93d04c8bafb2d7531c1ae9de7742218f36a8f2235891a6c64014bc2ccf58513c164f1f6a43784f6ded5fa120be1bceeaee832a3fc64863ff9124a65952fd947a578766abaa6618eb58ec7a766ec4a6550d78ef0f7e90402fbf484167cdf9e2842c5b7058c262cb172cec698e0d45b31f98e406346701d5543255bf8a186438c1cbaa8ca10443406dfbd37df40bced91ebdc40262efaf5df356fc19621ef80dca6dd764e35ff8f612ed0162a6c26b22ff1d703ab4f3de80690c357eb329ad4f0ee2c9891af38f4e9dbfd0f268822fd4b73ce38c3081a81453de5cbb15860733f8a32d1600d002a0caf1b85709156ea314d76cab1426fd293671eedca1ad41ea8b8ebd1ea43e433f674d337bc998c2603dcf318fc249bc3051f73bd9d8f0fced38f261af2000933baad8adcf7bc8c67fce1beae37bd2818fac9df1d67f7f4654cf621e1d1d20644f4af2df3c352d0f881bcbc452306e94eb6879f717fd6ab2b194eaee27a8f887e0bea820dd188ba1b48703b6ec9f3b64a86c682adeb6fc6290fbf7f4f94114a63692db6f5db547e789cb2388a16235765fa803e886fa4f5ef170b934528ff00e44c676b9e0100e2321858e84635d7794b73d3fd772356bd8c640db32dff390ad3196a8e928af7a4861caae4a668dbf9997fdd872a06def5ee966810fbe1e4bc4954cd632a87ccdd7e3d27866ab33cc3bc10438f02566e861ec518fc6483526988f4173f13b20239f97d74ae208c279d0bc3d8129ac656686dda4d1144d5697fb992d6791ad457a674c398f2e1cac23a3f275d837bf575fd9aa21f10a6b3bc9c759716cc17093706830349c0b92f00f7ba189398b690a7b721a0ba8c2e0649e78350ba405c7296578b54f5fb78ff598c7f8084559fa070ee63ed4e9a2479b96ab32d79fd9e61aaa107715323dff080d846368e5d0eea2f44076f6dedb684b5541a4a47e9780104f1c73d2cec81d75bff91335aadc4e8ef7b74d11cdf9f49563d57f0ca3a1cd859222d3fc9208fe1781d200a1ae509027806a7a800637897c17ac3e515367c42336f2a329c8f4197b458ed69bfce14587e23d47705fea9743572ccfb9178d6fbf5ceeedd3e1355b5fd6784a4eb5b50240f7d396b65fcfdc9391f83a8a53ffc767fe420d530f709b26ffc706375268ab6c55926a1109dd74f91526458a0b3aa92031074c469618abfd803677db830deb906b2f34a3abff1b95ece41dbfbd37fb296aa5243f080ed18e1fe607c8e64aaf018682bb10b026422ba81131b44a2a96036d75c9fca42ab95aef86ffa8d169dce2e4b2c1968a3b0094d9d780926258e4955e775656966c066b5c8f8977f55f9fa145ebc0f24f5cc04bb958996eee154aa16e4d1174fe3e67c8626ce449e0cd87670fb159e44c3fbd653ae7aa5e4953d04c0f85c696fc8c2b5765862d831c5cb6f858ba597bcf83e4695ba538918ef1d475e7afa5c4104aa128cfdb303430281f104774e3b6000d96bcc5b95d3f649ead2889ef6dad4b5082b5a37b72c03bdb35b2a6a0313f71e03b89f30c6ef08ea0fd1901f76109793d7d810aa35edd2ed9c1aa13fc262c196afff18283666329baa322d395975a0912401461e02c38700135c88fdc54852f0910fa15bb24ee416b39812c5d01727acce661fd4babae188f1bc980a81046e7583869c4fb8f27c73cfec8f4b91c08ea408980f9feef0070bb08d0f7a1cc27010d654fe144ef06afd00652efb0975a72dcef34cb6d085a42fdfad6c6bd4113c571440e9fbb9aa8479baca7a18696dfd266e0dbd8dab6707b43d5edc8a81f6d9edf64d3912d17294dd05a7e5e198129fedc388c6d7960b8e1f86215bc794f0598d854396b6705b4cd657046f62a8ca87439485aab894bf65d0dcb49f9d3c5193166ba7546ec1d9c715e29f08350d815be59a2965f6493a1f451bffd33a5cd0557d2c522e9fd48886fb7dbd4e5123a250d63b6251e66a215ec200b8cb4cb0831c01ad002526c9217196b334487deb7dc4898753fe772f37c869cef2f5d38d723b7ded8958a76e0590989926932a110ec1a1a8eee4af70cabaa78b218c6716adc6b9473b06494394d2d4a43ba0763dc6468952018e50e0e36d6229d6b23d7da8d0bc828ce67eff27257f20dc0c1bc38c3b84b52b0aa925a72e35343e888028a06883217b793001249aa5762d6dffc6aaa23f601791a9faae0c321c5f17bf5af79fee9abbdeb90e728ea28565d25a42dac526d4d1d0fea6ecf51664b38556315ee8a31eb0bf3d9e838f252422dde49f1e605443684eda1d4a18c9f2aa200284d9952ba4f4dc266cfc2ac03d0a6bb50b77a69d79ca7b54672e8aa67e6fef788e304f63ca9d1090fff1b03b98b4fddc36347bc88ecdd6b990091e4096a07ccb6674b71830d480c0556e7c95596a3cfab9dc271bf203e02dc482472a256df9aa6e56ad1034dd04702ff0abca55bda4e8cd23be0178942b4ed38ff49286bd4d76a2378c401ff388970f181f5d23c67e1b04bbf4ff2d80915299de7a9e36a5177019fb82d1c2007e726927ac09f440ee289dd2a645944f9d8d70e4064d5d178f28bbd6e63294e049777ea633acb1dc002dd12d68321377f9ce5b0ab61cb7a7901c05edf470486087fd4b1c89820e3030f459700e24ac2b526afa7ffa0fa4bd03d994dfb02ca94e13e44609ed7fd113923e87f6c6c97ae19052ceb83608cf9ce04d0d3931257132e274a80313e9b641d632eb46d5e298381c97e4ef8b260e525a9b7b58a873872220baffc785e59766f4e40590fe681031f3846283e67775d2e9b85e9022f7f45989562592e66ba7286440aef9f00f268019988e6e15774769dd91e19c6bfeaa750e6efc3c447ae6173ddf1d06c2cfb5d80234b8bb311a6fa9d9378220b7ce4b61b9c10d3a62745dc2331f669058eff4e680b3c4ccac604383708b9ecef2ddaab34e58e3beba75cfe73830d3aa3e1433dccd7aba2982228cb66e4bc2482a464f8f5533309b054c4161364a7f4b47ac9eba7259f567279df07db5a8ec531003ff84acccc7442d5fd0cf7b665b93e5ad8aef49e77710b415ce89cbdeb0a70bcb9694b7c29e934dd14288a7ff44f2aaa458a936da0fa517ba2de2e2121aadb6054156c8729a10a09fb6129137b1f579bdd5245b583675c650380f81af7a8db900035f96c5458ac001447648f224fe36b2a724b44c1606240f415b82fc499ddad7a7a8b4f74813fd99b9b0a08d54e62b41bd30cf3c6d47b79d94f95bdb1b1b73976b1fed4a883ebb5f6c9ba0d15d4852252b922f49d330194aae149611149721b7b1793bfe140a0e75954a1423c9d26c642768de534a6d8905ee1caf30642c63833b5dab90cd306fd1884e5ff6d31b812d6010c1c9a4ddb190f15e90d6e2d1eda5b146d29cb0c90da82a6f4bbfb467d56aa9964e34dca0019b90c450990154cd3a17fb4aab1ce6121f34a44556e8fe291a5bfc53d0309ad003286ad475f3b7a8f18eb33c17d2becb46570710193bfd09f093f70b510fca2e95dbfc8ef8e6b14ea1c4401f1dbe1ed092ce47af750cc71abc04c9b9f326bd651f8b42a0bdf9e47b746011a7cb28d25af1200d5ad4eabff74b839e610bd368cfcee3da32aa7bbfe43e7d203cb5ce06f13b0477afdf575c8112bf54f71237a1124781112171d30fa69d9d9d52323c0100dccd655d8e022dee89b0d8528b69d3882854ff645069fcd80fecf4be2e7cd90fceb5f318b6f0cf2fdb2cb20746147450719550524a342c453da39097fc69cdea68f3d3f461df51fe456620cb0af80f558e705b7a5001d03883dfbf1c264ec0d66938e9006aa22b0fb9e7d31ee9bce0c1c0e8db8ee558a2d34490d52ed14e8c8afbebe2af175fd5b9ca7852e282051d776e9a477a94e2b8a4bd226aeec51580b6d72f7ac0f3dcfb5e34b605c889af83a904e94d1f32e3b7b01131aa4ea770461185b2f98e293f60f55fdd9ccc3c06f278a398c407d5391a20c5a8fc2a8a448dbd5c5fa8904b2903a30de0c1a37612d6da45c12ce4fbbd2ffe8661026dfd84872dcd2f0da8cc39fe6efed060081e30f8fc5cec67767b4e8eeaed115d71d7a8d23c1ec231bc680881c992c2985e065c15226cce372a75c3dffce52d3c70bac8777ad61dea2027c50711f64d4933258817e6ff1de9ea84f9119be4f41d6596c3e8709950cc528528ec7fc7138e94cdb3cc05ce5f529dc64ce34594f31b34b846cf58f10f85f7de99683ef61b96a97561f91258630548a1488acc96020ff7fb88b5c4e57535ddacabdbdcf6c703a864e7e0849f1c8cb21e9b7a3d7d3f853cf51bd404d8df4f02daa11e4cb586c34d12b7297e43d1aa4dec2871ce27c886ad7acc4a35e6653285d8389de1437067de33aeb8fbcfe7e271b3138f94cc9c53d7135614baf3024c62b449e35d5c2115341ce948bc1dc4573577bd16f9a60ce6b97c4708e3ef34a53427721e48a3a85f6651aa18dbd02e2b707cfaed19a1ff468766090a9651aa2297b7aaac2905c44abbaed11a67b17a5ce4daed0d0a943eff9dfb9e3074bccec66d74d6e6215bb9a43c9785f43ed2e2792fe95c2682ca9c98399cf402782ef6c817cd24885bd2417daf2109f5dabd0f58070c9de58869955885a14ae5069ce150f3cbf1f89f4b0ca02f47b0a118167b381a73d21d5fbd05faf37e992be782f2b5ce43ede2baeb939cca07e362ed15db62127465ea690f7f4598b18f1badc0e2105e8845b888f9bbe7509ac9c9282e4cbee75b93ffab68f705fe8fe1c2f6813071636b335b12e94792b5a1e83c5504cc9804a1fa2627906f183e2788eb3b11b08d401162f8bab275f10e576695159353af7f0771c7cd0fe9872fba653cad52da31f343952352ad1df59719458f8f8ce02ddf90426ff57d93be410dd11b1bffdc063584c425bcbb172647b3ea7d1c345eb3da7722ea294dd94924debb881e23cd063c83f26e7bd1cb9df1c33a1e34e799811572f4c11207b010c19a504654b21be6f09d75a5ca561957dea2ad585f5b5c3dbc326a203c37d64853cbff1d7d0dff93c45ed36d375cbd9731937a6bccf206c43d9d961d7c9c87164ac837e2916879aa285d06d28439d7db42e9d9fdd7c5f1a29245eaa4f25093fa467bc6784934aab913a7fdf974f74d91fcff40bd3ebdeb8e76e740d2891b6581125d9571e5fa8b77e191216b2baccd27301570f27e852345198923dacabec04a16d52f04523a27490f430be3093f3447cc803d768d6613df1437d66f31f886dbdead20b323a9bb0d46914e30b7ecb8c2171e9354b959da61eedc8f4b2adeeb3d2200369a898dedd69b932356ffa8768fe370d1d6e4457ca07763cfe911216c20bdeb9fe3a2fc9c524b16ca8040b6d06ec08fa7ca409eb917a354add6e6a5600a2dfc7afd99c5a601a2783a2df85aaad126413c8ed4bec0866f6d152dd8d0346554e286cb001e7057906a1d05ac0197489ed14ac2978b547238073f299d8c3dbd9e10cc3af322b393cb81b9527afce7dc9f0a2ae9a125f896c6369eab4b5e7600d849d5efa7433995796ee9ff0b47e609447442f32f08412a35d7d3928c291c8052dbbeb30f5f9ec8c6e8a5d50c92acdb8f5d71adbdbb48335cef855e7e2bfa032cb4f335a75c07b2a5969191a16098003e96b5610b8e327832cc031d301edd3393fed6a666808a1e5787e9a7a3bc7ec9afcaf6de8aebb902e22629e0623f96b2cd04f48f3d801bbae0d2789f6d9ea95cb696a4b1f3bb6aebf9295006e3f0acf9d180c50f88171c5f28e64877160b16b8416de25c3b1c6617a72aba1c0ff2a67bcdf3ca74bc0a1fe2a785e8b1d2ab8d69d3242ab6c2178c36c3d3103e3172ebbf6a0e9362ebd5f82975eb108cd3fa10cd8d1daf64ed31477a56b68a04ec7b48ad4d5309fe926510aae80a57","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
