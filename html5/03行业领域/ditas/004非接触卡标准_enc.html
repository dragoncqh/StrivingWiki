<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c0f51e9a91e501781c0a20fbe41ec9b8b28325da506ab95a3dc5a5a01f595d3d8e124d86e8aca688b360d3ad71d698aad180acdc13cb9254f7298b54262b94eab1481beff548c2bea2e1d1ffd24f1a111910582af8aa4ceb0034be5821b213918626e18bf32cd19b94564c10caf1edf02ee7e8530d8c934fa5c08832639558344ea45d69c9577eec4d438a86dd1d48737b9b537b2adafd950a26a942c73db56f5f248e91c5af284056b3112520f96f92f9828200374bf3961179587d95c27d7125d6c50962a4f284a8101822c99a82573673ee0d230314dc3547a4c7207db9219fcee1b8ec00f719da826ff2a630bff732bfab50f1f4b5beb67224ce9eb6b4981771d593913be717040056d65165238738c3d77564b18b0b78046f217ffe5128ddf593118aea5f2a50d1c19e7cdda1f1ce2d6a50980d4fcbfefe590276e033c72c6979f1e7e8d76f39835af65e9870681b59aa1b80f1d8b087ff90e4522188311530baee02f414d5187bd37eb7c4208cd5ee54258da783c5e6766bb0cafb0aa5a750dd5f5b3d14e6d033de930b6b53a6e226a0644172a6893348785c4981a3fed73839149eb39682659d7ee65cd7b90348953750653ca0324c15c4757437d54cac147acb3a417ccea858100f169949fc554c5125f097d38797633e1dc4d2ffaaf94512e678c9c4fff4d133bdf64d7e61e3cadcbd1069c4a2aa0e3f8c3f024a1f32e7b5d9a5632be9823742686c2b07fc706eedccdbf4739c0b8f499e92937eaf609331deadb1a8553d3b256d82d22c9bbc7b844b4a6d136f25e5234ed5757eb5a97e402a2cbbe9b4e4beda262e57c38090065938568416a63f5966f63cb6f994de2f5ae8475608d4dec3408c7cac9449d8279e54530179c93d9e9dd99bec700f762290fe82e0ac5dcc972a58fd07fe4b316b7106b5a9cbf39ad4e61c5b2e863f94fb15d81ef976d35f9798f20c5ade8ba8f7a9738aba238d430af8830a6dd5631afb6e3f662d71d6a1b618e8a1ff7474e58bf7c31b739f3311511504771544444d7c1814f32aa195005f493c7fc51e1ce5ad9557fd2a04614d4fbeb212c61bcab2abbfc6c507f387441b1d849b14d82161c9fc2233580de911922bc70eed55c3c74fd76c7829c96ad15843665014d05ad3ea083b0d8a684682f466b9c218f61cf27f2b8abd5d3bf61f0869c3f9265efa7a0d773b8e18c8e6c61e85014817de836b6fce34e3766c56e02a3a64a47250b09cf715cf3660363ad7c33c8d278158b8849bccc62c108de27ec6d5ba3b3cea825e1fd4ca71b8719e90932f06086a74433837693bce25ee0fed2d65695f75e7ff18da5a9cc0cbe9aac558399b885496d392c7bb45d4ee90f217874e61beec8a7a0aa6683f82e84cc3984d137a38b723981ede2ab7177e712359cf2ada72756fa4d1c1d41ad2b8dbf4229b2fef0408b497fdabc905bf48b61cb473dc1ca2867cb54f2765fda45d309b3bc926681925a36910c7f7e5ae9186d96ca66a2717ea20a7740879c43200f0434ece62b276c91c2c1c245d403628ceb5d0d779073cda91749b9ac178f549bb945d35cf8ea4cc84db788bc38f75b706937f70d28fbb16c9b7c643f6e6c70bc202169be2ed580307e795d551893db6777b6bb4a1a497b4c0c011365ff7c30de01af9f424390bfc17fecbad558ffa4ce8f0ca45f15340f2516c84f7339b22a37273a218bfba5fb76d09986a12660c1104e1cbd7a084d9942b66ab8b8aef3f529858693e35b3544ac9c7bd77ae216508c5fff2f7117252e44cf922af55795afbf50e49743446f28b98e8be0a63f4204695667815be1877c637a673b808fdd144c1adf56b2cb05f68cf8aa4ed075e5230f13758a79e247397d16f5f6348e9b028efa454fcbc1d96a2ec04412ca17692f5cc61650a7b3ef4ca4d0e4104f15945545de60fb451db692627900e2bb4248a81de0e78cbfb5c2f4e142ecb39934059b898eb3fc0cd046e630071786f94b6951e1e65d938fde3a4c0d47b317a3dd845cb62b4e322c0ff3ea87dff4e35fe8a3eb19f5f3dc43a26f5cd683370b1521b9426529e5e78643958dafbec236131193a4210424e7754145849f68518497257f02633e79200e939866b77f8773c7bc2cb1b05663d0f7bca3b2799ff92211cb48b6fc44962300582b43760d4e489f119883bf5a74989963578957f480623639bfe63de05adbe059d8d990b7662b970c355b3ec6a619c875dea4e739f1a44cd3d18511f0ac04a5283037f1537d9b3130dd516333e8abc37712107cd71d21fff0022a1b75462d1d26b6ec6399488619c00b68cbe99ecedeaab78e7b783ab5a89ddb2e9545d66495fc71dccfe5eca88b0514f7c106dfe74583326e2db3313f494b839d9ca3215a038261967a66b42716fbcb1b80db66c75a9eb8e832813a296eb820b4a12fc3d71b4dc648b9684f14ffb48a59db3cf4dab72cc5d4da319745c4130a728a1d7628690cade5b034c59b4b46982f2c2b6a13d2dc247a4e8fa790de5a1e1a66b9e549f179110e0e50cb60a4359937fb5d5ed0c653ef3ec24545bf66f9c3169026cefb3d69d3779e39f5834ffc22cea0493d5021c315388ca0287206a8007f861b3ac0c57bf5c9212e6b7bcca16211163777c785c3e013bcb7a1f9721df11c25cc8134f7be9957375f05dc60188e67f32b9414d1b3458e9e3c51a49ac4c1ffe23298d975471b24039e9d22290901bab15379c1acb407fa8f5f77a4a3a392de4d28956b850caa2744e255d6518d5818185388fea3618ec627cb859ea292c232a78ebf84b29906dfe3bd1a1b0300838e15f83d93eb8ce4773444f6d52d9f3a7c5b097fff9e50437ea8b8f4aa838d4eac31653265d5e0fc2c79afb9c388a0e22a8bb7ef16829e0a05058e4bc8d85e8257c6f38a9fb36d273c78e7b5d7e4e8fc0c81c753983afcfd1c174a658bd3dd4b0c3f1b2a57bbf22693b5cfb43aa1ffcdbf6dc2f99b6f4237b2a172758b5196fc28a081c537b011509fba455fe4a8d31412f6559c93dfa2a0396085fdcb588c50c485267cfe7313a230d0bdc19c77066f7c4f47fb7f73ad7120b271a60b445a6bce88c88cc03b6e6ef21b356a779bae25dab98965f42712f92156357d78b9bbdd953582a67daf39db3864f1eb92265e70e7e18bb1236f4965e986d14202a1d537eceeebafc92be141d3ade05267a152f229dd3328c69bf53fe0e8d30e09fba4d37fee0189f235196676cbc5cab44ef64e8cb974a87836cf7076a90a3466621d9422725d3878e2ffe82ba236529125b362196cc5fa2a39c5e8d56f227fd00237b81a568992f0d34579637fe7fa8a0bee33729d4c5e1cf89217276ce1445cb91f8546fb9e1513de1357f8ba2529591ae8cbdeef64a69b0359219ac6eb7ac4a995b7c74dcf3322a112c6c7d71941d6d6b259463e664795d69f421f1770d0dea1676edab9377d7e489b64750b4972bfb936cb22e998eab191f64ddaecf199e75d65e3594ef6b167fede75830ea867d6e737f62bc9ada6b566fe8aedb75a583696fe9444f74fb197dafcc3168e6aa192e2a1cfef3d12924f92ae7790ec204f3e3bd48623578e1a8d0502bb2490fa9fefe07ccbb4e5f127385ae64d23c452bd195da9a47dafd387fcb20d9daadef1e093525e1fa96f1e94cd939a600cb85891dcf7abdfb0f41d8f9f7942747dde27a4de2205f38a6142c707aa35320e2a0108fff1181f0b7f3a9fb19447bc941d23eeedb9f956e36331fa449b4ca9de6e552d89683d8101ccf423d81056dbff3c4b597025e10e2c5f200a31af2734fae78d48417a21682580a13382a8216e4c25c6ac5c8c340e186e043c7aabc2e77bc604c2560d8cbd1e4b775d5e57703af3e3dc852da0751f985f01d11260feeeb5aaf306da4fe7d6b597caea422e9e5ed173dc5635f6abf18534cb309dc28479fd06ac9cf15484b7b120a424841788b7f90c7cec5f8a65baee6845a9dc2d320559943e09949fc4940f3ee008feb11ca0c1e43df0b74195ec27e19ee13b978a7587702b570212ef35472532fc2f985ce8521221e0f4f654c8feb6a6ac67cc172756013bec00e98129bfc90c904698c599a842c6d46ff8cc7416f0d2d6bffdc781a7770632eb8cfb7c04634df1a72f29658a481f8c09f721476de907bdafe89011798145d4dc13066644444900136bf6c8d1b4fd92e616877246b012a941e382f0f47d489cc7a04a349e66831b5fc685452ab3e5c29f53cc1c2b7cbde0657ce2dbe125b39e79897d719dc714fd60fbb1042bd4839f530bbe9e8dc5ff303683516c463ff49ef054d65c4ec6dd674a53c76ff34bc0e4d3740d590fb7538e815d7d96a78f7882f586d0d28779e260075428125db5472f69ee853c09b04f7dbc2b5604d49879913df2b4ee1584b936c7e6399cb4aa76b5eefec28764e6419abe72b0705bdc4803f299a1a7be80da992981c0a17836c435ffc2a677f92dd414761e4496744e1b361f98aa30e8a8ff6f17e2b6075e8ac38fe69c60fe04b7ea4a1cc9a5193b0152c39182e98ef60bbfc87910539b16dc4c3cb4419dc54e95f61cc888b0f1a869038d803ccc1e98af3af076a8d10eda4403cf521afa531c0c6c6c9d9214bd09af2b4b5f60c34cbe534f7a957dcd5a0eed4e4a0ab3e8f00f24ec4ee3f5a37ce33fd324d81b50f49ae0a7563fd68caea9205922aed18e952d0758ad4f10f3854945329acf08efe51a98410c910209c5fbb667089eb5742e49f42b296abe80b5893cb22ad6605cbba58244cfc80395b10af857e3b8da100ff0db561089264ddad31be0144df84d28b8b2a0e960139a8af44a10ed1f2c461fcaa85ffc42275643864b05c1b177f72f1cb2258549374ed1afa5a37d1b820909154b65c5c81f3577c90556d76b67fc0894f1504df59061e7265a7b4591645ba5a29ddca85aeca0740d7aceb6d63fe36f8dbd0087bcc413f78ed23fcb9dda236de7259652877d7afe42a1832ef6d88852f33d52be604235072d01a24bebfb0d3d086f39bf9e3b6a364b7fe90856342871ee261d1dadace8b4e450e3d45c87d5da898a74f7d976eeade331d0ac21c302cffd0c3925e44b33c3c1c4159a9f04262d769e739c3a57ba169eaecb1546e402a194102e5cfc719e422246d7254018c182a601b69a608a552721e54cc4e5926afbd443e8867e80522f493c8675c5e4fc3351515fd536170c2cddcef664df0497bfdb62340f3f4a4062c42fe538fdf4b937ce3920d788579cd68b8525e7b294c8ebc1e357b35c335d577ed752d0b7b8047f3ab68bd35238554f19a3567a0dd953627700879791c39d353ffc8078313efe8ed7771740ae0cfa17dabc48b6f81fb4c35b2ba331adc60e277ccf1bacf00a0ab901d1c95dbde62d82ec6b822f7bf9badbd8e1e6b50b56e3d4372ff042d98358f198033abef1ac6461a54cea7c51cd308bc2dff60c169a493111ba5a63179440e3ce8f7997423a0ea7f2c7a9e40007658a5d55a21c64533b7e4cca3a10cff6a5baefe3c7e2dc153bcf9169d5aeb1d5529ad10b02147167d5f8f6e64c7a6a51b49600ccc227ece8a55094d0c97d2759ef02e7a5963258fac8ed9f1b0f3022b087cef340803e3f56d745e8eaefa3e27b1b2772b5f04a4d91d1e3f65e98059d158dd45cfc6f7ac2941af6ad008bd115cc3cdd09a9250cf2747ccda986d5db866631f5bd0b69126eb1ebfd86d8331f032a5f26c176fe5df5869ac0f4ecc8f086a99cae15899ad64dfec1c54424aa21657b40393ec0ba9b72133711720bd907b61231e230149d9aa8888691f9dbe051e3abd733c1448ed859aee9184df05e0ba6c1a81a57c26df94681f812fca44902791ca36056aca394db37f986ddded88fffa3182bcc73fe89b3db3bf72790668cac27733aef109dbc923898d7583d738645aa74e75a993a039ca60d771ce571da09f5a727856447e0b1270b26b1ab5299c9640074e957206d74f43490e9c79058b516b4e56206832ba230a513a8895f1cded3fab94589af808b6c64c302f49e8af9a2f501943f6fd2420c7077ea1af86efa681df616380976d4bf290ec6c1678cb200b06bb376afd0027572e8c53ea3859fe73ff3d8c48e3b13ee66e13997234b6876791e8588d75154932bc6cb39209000cb792ab1393b2802ffe0fb0a0d814980f0e7c5567bb5676557f5022d34fc8c7980db55ca6ac9ba85c0852d756aaa6dd44ad54a089728d43310f16b1729cd2055f1bc49db5501954b7c65ce017923fd75a76651899b766ed15b5fdde7cd44ca87dae4a5bdff6e9b48758d435b4151b0996ecb8d1867b55e89bb5e8360a57e09593c15fafe18df3a8d89b139d59a91b56235240163893bf48b2ae80c94f36272554b4ed7d712cec7d826ea8581f444cd1a8149486f65d3625b4097f8e5cbbf0cab71b367f6f31810950c62249881a67e28dd747f62dc75c663d827cbf9f85a24f810b68371e4f50f83be5d0a99d486bbe611212bb67ae0cefd6a20821f1bb69618442f26cc586026a6c990c935e23b106ada62e038e72b63dcb57b3cbb9de26e5cdad34b2b5b96fba87f3636607b3ead22006c8686b850a838c9f465ee97d447bf4b6aaa106da74a60ef7f6796fbac0a8fcd599df5690907a6020225b10f9a44324ece85b8bfb9376cf38b085262275598fcf3f3458d915ff417f08cd2a429c3b3731175880dd86d8fa68810b98ac9c2bdbd28ec25e6c055ca564bc5895cedccce0c9ad00ffa10d2bf54ed1d1f634418c2fd54fa43d3aa4bdf81128c0c773b73f8f28d4691c2d2566e897e62a7398091b00fcfd6534ab9a72e3c302c5521cdff205f2db49d24327f955363aa5af1229780765fcb6091254eee6909088e12fbf39d3d912170456c4c1f23c43c0f68537ceb7a3a88fbaad56e97801efff977a216b390279156951a4bec1f52ff92617d753bc4a75cec1ad96cbf94c0962ca2a09d7edc340eb1255441d50acdbbcbb880125ff3fb632c3b987e580569905c6f288907fa7dc47430ba75efc728362419814b5198342f76f59eb739b7ea3fed95fd94c19fd4ca05c84fec31867db2d3fdf366bb6b8f6b1e8ba95abd841d17cad58f64cefc1d898a15a14f2f7f8e5335e174c14fd4ebc0e8fafc6f87df5a627e07087b99bee30cb799b02f6fb44cb0dfd3cd2b38b9c8550bee86c545b180a7502af702d6b2e9b58c41925426188f58cbc46abc90c76fbc8cf412a4fac0de2c7fa4fee2b2dcc86c272a563a50ec00d122e8c8cb869dc70ad538858f9ae32d33a70aed1f131602cbb2440c1388e9c0f17e38c897329d46c1b4c9a5607dbae06df30eb0b2e60bf64e28c86bacf1b4f53be588c3e09c6a18bb886ae712fe85cd2b1a51f22be338f6528cd40fadd8520836a81e6ffa04fd8387c7fcf1f4e239b6fadfcefa7fe1e624d334eb61525c85d0e814abfe757284056e1ebc1fd9d67584d70d34ed709348c55d3826bb8be82907ecf396137cc6d165db9d34896110b79d86c5deefe5f1e759fae5464c240319a867c41640328343b2d30191e08ae73643b77f462407943ed24ac30fd922cf4f62f7d3a1ebd65146e0a9a9fdc9e3f646773850d54cb166213d2ad704b5f2a822e1598ac38a392e56e748f6c1997995c7809d05d350585ab3023f48dae33bab0b0060e8589f21f1b49f70615b9531c2fb73fa6530edd636c8d49b4f01a0abbe70b0b933bd52998720b673ab1d189a266c25728f796a03f070cc7159873ff3b4d0352bb3f81a4ee289070b87b441775ec61a3606ccdab923357c20796ab5b66a47a9a7d2400e029fb61017f981b28152b68da693bdcd84d3bebe02799e333f767b329641e575537a5e82ec1867d65e6856c20041971195d92657d880eda77f39c66c7ed928de1722ede8f7671d64d6612cc0825197cb865eb510d70142785f4d0d92ea2fb9b81f33722c60d7897878494446526bf32731892d0e2bdc1c1e6ab44f51bbd3be7942037e1ef1035d2f3226cfcbde742b091d0bdb935da1e645f48219f3c58cf822f481e0706c905e1e490367805e9d4f47a1dbf60b14acaed4b410a1ab84ec6141cbb50fe94164ec58d720319d3355381df7ae4e7bb46fc2ef26ac0a9b29e2c9e4002b64093eba4aa5fc92c6f60ed254f0d7e5d23802e86a5c469095617f94ead00cf3a68db9a460b2f48d1efa14ed2e08a38099f02459e855b1f1ea1cc312b3d3aed15dd2be9d8e0893e54ad45bd3394964cf741c3b3b38edac68900e43e2c233c546abaf355c1a13d12dcce25907a2dedc9c979429c799d39f4d1ab124f7e25626009c45cd169261570f5b1e55435cec28616be505172385ee4c0e00908a21714f8b9569e08b7b24de2c15caaf76dbec93efc59dbb6a1d505a95e2c39981449a3ae13a2414812bfd8ba3f2f5a74cf7afb937176a85fce23f553a963f37b3fcdaef161527e103ee2330d32e630fa885174b1bbeff5ade203fecb8530a9b9b70d51c6edfe6190f1d1b562f303965c64837bccbaee34e04f8a47a2a72e10f586810a328bc6ccc9d5e493250074811cb517988f23fd531482bc8eb511fc15fd0f8c9a1f672bb42c531b24fc2fb90d07439fff5c7bcd390d876e6551e5df6abe4f225411d057ec2dc6b5915befe004a654f12bd24e6d97ef3fcd134baed79b130ea82485ac72737b6bcf06f8ce7740c3cf94b4423fe5b2fa35db7fc396acff6c556c59e89372a0f86a66d0bacf69891c998dd71b00d75ec87b44e86bb1ad7aa9b98427a10f4a4bbcf4f92004ea315003b58d48e0c58f396acc27ec6a296372230efd07c330b0c154ce5fc8755d89792f05d751868af858d6b438e00569b730894f1c42676b447a5a7506c323455c077f28fa53b947127dd8a46ea4f6258c9f84440de50cf3de9f2b4a30ede15ffe4e4245e1059c54c0187d7bd0be4bb2d50aa83ff79d37e2c77672023152ca144e7ee96403e9aa58eae2ca2df9faac88b932072fcb8135e2a02eb58d711d0efa960a44924950a1f230f1ef7b9ae8ce93cb0104b33fdbd880f00abd4e50419639793789dea50db4b4889e7f26cef906aae21a1153a6aeaf050daece6472a97113d3409ae6393c8c13f80c6468f246fa1348d573a786a8ad0834ac48cb94cdfbe4b86ff098c0d180d2458e610437f9686e5522580a3f0b123aa53496c33510475d14581c9d0ee96155752c6f2f4401f24e47599ef9b50ed6a89ff2f80d99cb24b53fcb380b2816b97671ba61f389eedd2fd52cd37c8a2eb802fd5ae238db3f5828bae14982ce3988174f7a3f64e79cf515c2c77a3ad2e0710b5c56f7b1ed51df56f3cc7ecfee2c59ba0c3f0b6114116013ecaa6d4eab289b8a73c628b454e7f3e4febacd1fbc704815c250bff0d9f1d13a8d3dcf99770ee9fe0343db55dd5268e31d895d606bb870d34a666ef3cb68e3cabdd111be27303a776305eeb525dbd165cd55541b962d62f2f7caeedc558eeeeb5d9b6e0f3123134a43589138ed61252b66fba8d56b420b12f9f7d3086c8999e8fb08f73108734924498ae7d9ae23ba35fcb10d79aa3e586995fc21813e11a89ffe3053e85e9165cf2a2ab0ebcdc379df7d48c6fa5ab7953091d6eb59792c950c66d4a28ca7c43454c1c4557a4bfdb90cd064193409980c535718746c1b4e4376a1c5916d376fb9000d9302f98420ba70b6ba6795ff291f7f87acd65a8c7eb6e7d5ec2f58a12bdec5c33d7a1f1e39bc1b3a17d8617f766b7a366f222179ab6836fdd4830d6aaf5a1c45893f7aaa52e371103cf7d83fb9b4a218e1f7f01b0bba7d730a6b47839468a7d28804fa1501abfdd6649ddc59844308727480ef1ff7655441a1f145e7577fc8871318317b20555565b3665d451d16292504710721a82cc7afd0a41eafab14a7439f18fefde2ed320480a106186dadd279f492f8e1e6bae0e1010681d39f42ec65053454d0a88ce87d1dddc9c774b98604fb0cac27895be1bac0ac2d3806d4eb3cd933a5bc0360c8c05bd5788aae7703a0d36e6b1ec9e93dadabf84edd51f01af8509958598cbbac81fe713908a9367b73ec5fb01c2e5e869f0d8b7d7e9eb1a7bd3449fe0177378793a3f15fe0bd54b495d3b1db3c40f11a171e10877bdb568339b095fe2ed3b50af7feca22dff97395ff4ee5ab0ab71ad20fe4944bd732a9225241d67cdb3330da329375af533e13459bcadf8549557c04ed801e91083ad27da7b04c56ab50e3f147433af07a3cd629aa12f54fb8f266b37b5223c52b8aadcc89486fe55de8d640043ca2efded65acc49c05d1362fb2ca669adf9c74f09013c281d6dff6fd7dc0f1b37c0d2d28dd006c19f1b589a8b573b124774a1aa0d93838421ee6da8286d3a9a556230936d2e9e490835ea9ec3a720da9861cab917f94e52a3d5b1589a1fffba39163c760b02388ebd0200c5048494606cd3eea13b5a3bb1e3ce5f14d381145f53a1c4adc427213afb7047e5e75b623f17c30b81b5546c0fd50205741b38162a9960f24699bb67fe6bce867e71ee3cbc575b4dec062bd3410043f236ae1a2f6c1c777ead6bd8687aefe4ed9e7b42eed820d9a073fa27bc520f36635e7229d93751364f2a25eb6d7161c8678ae177825591ced95d853d67ebc3a3127a51af8b71603b3bde2517e64d402a7e71130ea3c7e818fb3bde036312d34060ccffa4c947958a7f23cf0649cd6b135fcbbb00639c3aafbc065df03192812c218dbef44de715b439d08bc5074ba500677142722c7cd4933034b8b173596f4a4a08678f246299e9a12d6a066393920ae3656197d269e81878f570271b06f57d22adb4efb97a783ba9ba54554817ebd1b37a07d7d70968a67e5a3bedf1ffeb8ef41a9c714f3c5818dd9c9159e15200fe162d70dd0fccd21c9ace1e0139eaebf602eb53fbe85367755a9e205ee76f233980a050ff65182d12bd7f048423e5ab47740136ab33f406d8a3f708ef6756247804cea5b3e387d0991daf39e69f0b7caade408cee71f6a570e8fef4dffaac4557e8b4860ccce9be57f7c349b9a760480048b0bd6371e790c728e99e60d42be6ac198f42ff085b89818d854f3d2ef72207f49904f4dd2c1611af8ccc4a9a828b0f162a09b18bbe418d0957f2a6ccbe1463ae0a9c7cc37506e76846a6172494fac1a7adae416ff43538e73083103d1010e99b75ea391dea7da9d97e5d0de6f8d22ac0bbfa874fe288b45d921dede0bdb2847ca8fc60344f2e6600417067924555a9140dc55f088dd12588e3d87c61f0b1aaa8dc6c95a50fc02c69f8f65467f0a202cc4f72d0a7d816808e7b1d4763bd9409895b344cf072b4eed980cad894b4e5fbb84c0684f0aece7c114dead6b31423dd74b998d55a5cfdfe533f751a65481af735613172030de7bfd458da03b5a50aa24e21e3712059c69db4d9128d681f59307c0609003a481e98bab3035874226668ac5191bec4117789483edc50cb72a0d653d4485f09eca7c8430dc5714ebc680964a8dbe42e3b50f579a3578858644b00541f80cce49cab6fd41feb34c88d5bb1a18bb2bc0129f083786decde3c33cf03963d8aec5d4b10cb34f1077d735b96fb31b4beba6c6fc8fa1659d31ed2a67ca638d10096a2a5b2669bc23d24bcfcd33fffe5374470d19ac8a394de6a5bd4406bf8d597a97bd7c4280c34f2d71685c923679e52a756d974a1f42631d6734827f3aff56e9162bd655d156cf98b8654e3b1a25c54cebcd13abf937a1bf52d48eb4eaef0c455c231f8bb4954f1cace6ba96a7aabeabc330d7438ef9de9a410e6eee68c69751bec72d77ad906f8026ed026a8311c4c73765950a16a884df43e59dcddc17444f4d4bdf4f95fcde2b3955adbc51840b618f3d8e123915a7295b3b75cafa83a998d221a43dc12833d618edea8136c8e13fe579726d6021ed795216d1c696e0b86add69b66f4044f48d7fa809d6d9068e9fccd9a55e58b94032863254a84e34cdbf7ac6167b05d9f2c5696f6741497a98b14dda51f1450c269f56312a73c4f2c7c9d9f6eadfda8c50fb64142ff348fc23b66b31613677123ede11f1f0c6d45d2c583dcffed66df7760489a1e14da4b29644a7d6c2e2ea717d626de5d880c3c03cfd82ba8c0a0e1bf8f1eee21ed37011ae93b59eda9f8a680a3abbe7df891921c4dec94db00a74fe9de742f250624397a3e61d3c0aa45a2796ba756b5e780a6745e67136834162b954b37e9c5c3b9c6e902e421ea35f1c6e84f4c32b4e2189f13518c4199b8309246b4fdbfed0dcfabf0664c69d6dd7ef4390df52ff85045a38b917b1fb99f32326b9c4773ff3e874315486c2e4b1570992cf6e9eebc9761779ab2117312b3efff2d32f536438d92f5f85c4690ee2931326e31acd86322b8a3f2e8d3366d574a6b99bd23a5f74a6cc8cefacde55868cb3fdbca33ee3477224efa6828b8aeb1c39b17a44c59de09e2c54d1b83c9cd78b91a2a3242f031b744c986a433e9a976d92c727198d84bba3f6ac522a4715e9d5818b9fb9b5bfa96822b60ef99499d7fe090cc1743b1c4e7ce3743c0704d89357f0c396c2c9e067dda9884ce1ff14a56d7ef51e093502cebefa7734576da119b757928800ca3f6288e2e2fb02bcd51d0b0ffa0a9c8eed5647f600f54566e815b5ec2dfff7fc8e754aa30b1cdc8cbaf37e90d2e71094433f86d274f084668ef58b916daaeaaa7f3e1e1ba71618b2c69035ba0e198a1ff979359bc728b3b71bdd6f65d4e31339fee9610368b192e8c874b1dd5cb2c64c71b96af0b6240387e67f535a355593123bd07ffd2d10ed7ec3a1fc70b90d729d471256798ddf784a05969ba82bca59abbac3c55a2b501cfc5bcbe80dd664e18fce02108b2d7e1515c3fef2cbf30f337ab213f6871158bdd04dd881f144469e97d883dca93fbed428631e20259a367e0f02306c216bfe50ebe4de1c57b4d794574b843f222f7e03aa5299cdc8b04be19410f34b388950f9e5747a56936afd1a6f54bafff2845a10902df9d5a4b97d8f016214b4ce4ddf3bc7cc8d799ec636bb7f4d641ea44b7b05eaf215777e9b4042fb6d55e9c439a109ede6f8c45019233febfb42937fe452b6fba2a767a51d5b47da3ddd9833ebb7010b7e8ce1fd36818f74d4b4778293f8629e8af780ca3cd54d2fb68b3f65b62538ad2cc6690c6f0a92ca721d6e892dce6b53838ad200e43153c69ddb1be77f9a044bc2f639938722eef13feccf14b76f69fa4946437208aa0005b95e41608f46b35628236a945b4fa095b9ce3f62dc3944d489c20e8c266cca1e1b39137cf9c14fc8c12403eedd36ec8d1ac7a4c1c39a83aed395db0f8aad399a4331cb2d83c8c0326f3a762c202eb4238b877ee27282d75e17d06c6f48208494caebfded89fae17fd2c98f075626f59c7c19f1a3db43732918bc5fe694c929a9c12611420daf14fe8c0c764b63dfabd7e2ee4566e14ba4e73fdbf393d6e504fe61acc22baac41dc37b1d1927e7e89aad19e9371a1c541a59727bc70c6c51a81bf3c60474d872e205e434ea1bfd41cb48e09836b9db83c6757d55bd3d08a0d8dcf136f943f862b6490cf5f984c5615ad22f2864081137990770fc8dbe1621aa7ada4426a6c7d9f774b980442ed6568db0dac4823535c4c993c3ee10bb667ab7b82812296b63378b0927d7c7e0bff9264908db49ae8b6203f37308605b0f1746c33102c4d3ddbc55a53a267b8c3e243906f5919e4d19fea8964aa8887b7da457e4f34cc96a6ef3c5dbb09f6f5c1cc42d110d446f1da15ae4785d3e115d7a362f3ad198d281ca46946a0b36757dfae718940ed860ad0bec4b148d2b611a85c91667c89eabd8b8da5d9cf73728374489524482711065d7788ac151f16efb537fdb029c57eed6aa7b3b4b579c7045828e81158f497cdc6886fffa44984a9599d91b5bf8a6e04a6bba300bf6172f846bb67592c9a923b5290bb0e314990773f87695f77a1694f35d38031ba3a0c6c2adf80dbd86561a0f3baf4345e37e02e9dc7637000a6ab14182b747ad466ac82bfca28033e12122eb59945b10cf59da6c32379a08b1595bb3b84873506585e135b9850afce6b49caa7a6d70bcee1837ddec3e529c06d32018276594779a4c8301c5cfa7216f6822591c53a8c297c39a7d5e127330c12bedd51d29e013efaf7e2156a29eb05cba0b6b94f29088fa85c78177272a7f44bf2f6ab7d5a77e951ac835ec85c702284ca43696b2f9d411974a3a9f5c64f9984ede2deff56005392fb990d5ea4e65ebfd671ed19295ab01d57b75e53c7d385f9b3e74c2c683c59be839cc6041f3b590c4649c7038bd915deba84aa86590e6e80f59240084381a4e2f5fc8e6e9f4475751a484cfa4d19c19e4db6fc0c6bf34c4560ca2f9a32aca1661b407ba01ad769e1251eb374271e594c28657be8645718781376eff22cb987886a61666c428f5b2727d6ca8bb80bf11ad5b8c48506a2fb0d2bdc18d63a5506e40d85fdaccc537f8d6ca767d90fc86546b86da2e9beaf8f829a5644b11d2f84202bbfc9b3a3d1697ba9fdf4185145e136543f7242f8d24917f5a805c4e5db902e14fb433eee8a50ae6753356c20602986f6221aeb4e252bae3696d00f1614e3fca2b4dc5eeb4ee6be8d236bb8ff2e91ae98e8270be91259e8ad05bc7021607a9e2420fa77fc62c3a18317632b08b7517ba69f9bf3ad8aa4ada2c1201d88c216d757567fdb6e2d671ffb0a965ca6606b6f2f935f15846ac88b2e235d2b0d89adaa3e735b6e4951dfdce702bd2cf8ccdfdff7f4f3133061b2889cca7c72a6542b3277a7a01edf57b614938ac18796ab6b3bcb42887cc2a5a222eedb7033b3ffdb32e8ae1c7ccf0b42e202affaca7a9d7049c8f3de2da0f3f0c7870b046d7d831996fc5ee0497b0892c56c1be5a434fabb4fc3c334c1baa34f7b1f5e8a2e6b41155a3ff0d39874c46484be2bc3c40dcd760ca9dbf282ed71526b5ba7fa4418c748b7eb6dea44c233cbbc4e3b7ad6bcccc5807b8ba8ccdc7305485b759ad7fecd55e28bbeb7ee3376c6511c0a05c1a4619f05c5ea0783b8be0282675bbcfc304d377e6e8837757655cd6ecc985d70b1cc58558c1e1909e286d0b454c04886e46facaf31774544a5d2d0e36002c4f6338323548682bf5a1e9951797074577c0d71881f2392ab3fdc11d5a75d5b42d3a4b577c76c42fa969dd3d16034fcea554d7fdbb6a2c4bd600c9e65ad28196c25aeb169e549513cf9c3ccff162fdb39175df3c807aacbafd75a91192e5f1e5de79dd1e7ea0700dfd1670b8cfbfb4178f7d8f84518f08d5fc0f985477d4201279ba29575385328efcb9818c455c5feb05545c08265134af34be52b0de6e821b6f3c6f767eefb0028d6b46508c7b999ce7c7327cdf6fafe75ac5b5fb21bb7859a26e9fd4e2642c69ba6f166e42b041010d172a04569ab1a78154a790253d4acb9a52719d94d359e18da5525dfb128bad93a9c3681b660c63ff60ed6d02cdf20ee47a4a7c8228d5b78de44c16c6a2ef315ed9f1b92298787c8c0607c98bdbda8a52748845ef06cce457828580ef0e1ad1ec763b7150f4cc9c67bbea1b95bdc7ad0e4cc4ac4cfd5ba20d2ea7a07a612b8e1f86db0f18c8e083da845ed3a3d32ae1616be97a3bf3a24c5e7a949154596fc951d2172042eb711f6322319b8d12001744d405666b59abda4172ff0bc0a80baa9000baed2d5234789f4bcc5e1e260dbec274ce9c5ebdc140991c9bbaa27ddd96fbed0870e7925f8132e235b4df9e0ab0c4adb45d75aa141a05e2c1f703e5cc88cde4220a2df53d90ae5d5d389eb45e8cee53752b730fd3c8a8c61caa25c8b8f74b99ee0100394e47981a1c840de2faac14b68c3912cc15e14f380027a673265e7f5627e996a4c7570db4a0c5b76254dbab00383834c09773c822fcf70fc42c2df7f1969afd00097a4f65a85d928476606dd62294ab4fdfef380498b4b5a1aa07b5da50bbeb097c8891d1d00a377b73b2030e5a6fdf551f5e890473e4862f9a4ccaf9d6017ebaa651233c3f1cc25769ce8e423814e928241aa0e6eb86936ec16f475f0069aef7b655c4b22129b89ec329335a4db65c184805f2353d2c7c8afd77c744f2aefd807d1b7b1e621c03cc25d7df555b3df2f14f653428d4b6908d08ced095cd94beb6b3e148dd9898c321979860279b1945e3ed8e4361bb2dce98391e513d40385aa367808dcb4f187cc66741f7e4fb44c1bb4b1a83a4e20196f29855d41387acfc3731db68ed16ff5eb9c77cc5c8094f2a15362ff8a5ba4871bf0afd183dd5a7d2ba3717fdcd785b7966e78fb5f4ee6d9a4bac068dc49e3a18eb8b1aede250365ddd7456b23a70e6ee315006c7b973fe70bb1b39a9dc5768970c2400e8bdbcefa244b63780d695466461ebb7e482144eac67a228588e0bad0a33ab8c0e8ecefe1d5f43bd90bf4de07180c2f202af9cfedd1368cb6db0d9040a4bfc69a1ae56a7c6598b5cb21cb43cdaa5e68850171c9415f9bc9b6d6e404d789deca2edc29e196dc9fbb76ca0f3ae919b627871de1f489b8236a078f3d1ff79a1e80647ee2b01f9530f5bfb489cce10c60dca2ea841829413fc14a352ceda246ecf643b9c05e440e10449b50b227307bcf3d5513094842635d4ab681c8bfeb35bf30c3aa9f2fc03eb701366ec7e1697814636fb1f4d8c4e54f526455d76daa4f8a2859f4080daecae85da557f44903ec2c4aee101b0d96927d2c9bd633239230b3c9d8f79732e26bd7b35edf66705925c31034c3cc3cdf26fa9b6b8c80a003710b4fc6bdd52703e58e283df5ab471f63909f0beb05357dba88be492d9cf5463308a651b50ae5e1dd7fcd9f5fc76978946b0046ec5a15e1b1506f10778e5fac37b06a50fe969eae95a6390d7f1ae71ccdf7f0701c2d9dc51781128057ae6645245f17ca96b5d23a21466fe71deb6866777819a4e303506af36a81b87c389299d017173d59d720d86ca6f08c14a17302abe70cee3b0d5bc08abfa046f629c102fc5558a3034d57f6fbfb2791df21a900738dd9fc430b46be6dfcf7b3361ff42c7976fe7b91f9bf4804f74fa59950cd9bee8418a096f55eb8cef32ad5f7899ceec678f63bb99ee7043338643cb2d4fe504a5f158b2643845023b3f8a7e9e7e606c840a43011904e59cee61169c7f270fbff140f399dd7a8e58155343ad840ab47646a7c6ecbbe29bb4929cd461369397db5fbad4826163ce2e4f886e5c4177f070aa541ddfd0c33c4091bbab7a44845305f93080759823cfe339fb992487af574e5a042d7f584cbc7799f00c6349b4d34c81125ea4606fa476a341630b5e74a68957194b8d05b9e720a12304971d91e913d71f8cd821ac08984de0809d0c7333a142e659a95d81b1f40a03ce44b92881b2d839439bb6ee954648f55436fd90535d15f2d70e92fe5ec6570d156e02cb4db21c00ae537dd74a2a28d13e763490fac9dd0eec02e0f76d2217da22a954d19ffc8b7c0affc01c77fdeaf427fadf185c8d8802fc8a30adad2d566c98c93bfbdf9b5682d7769d30e9e49747fce9e2bd3cfd68eaccf9003a6899b99fc15e49fb291e85bd31020760b98828b726930bc7897a28e97f2e8e39e8892e4ba4a1acaf02b890bcb8bb0337bbe950e8608eef1f082b4f25288c2f5a91d03fd1529c8153cfaf684043a53e1c421c4f0a71e1ff04e0e5f088365256cfa620d9360bcb5c80142c72ff02e8d7fc20b60da54ce1692e45876245d257060a93f508443a4721ddac31ee60ffbc7cf5fbc0b301fea9760fa0c75776bd727d700638d4f7b655b1684554cfb0a209d7ab56d19e2685dd5a40bd83de8f20e7b43dc776676145a49469745fc1cc9fb0fd5099deb3ccd0685a0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
