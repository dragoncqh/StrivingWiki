<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e7d371244f43cc75c26cf1a824c6bd1686d5a76d8c0ec1d0704f9d7d6d90c238bbd3042a68daeacd271e880b317894c9ff43e425e0db3aaa4e28882c6ff7c6fafb215009b170d8a3ed14cd598ad424a61fa223a211eaf2684f490f96deb669a65bee734fabb34da20046a0bb2db8b9c77ef70a22c5265fbb008b83342357a5ba991875b4f29eb3c6ea412a0d95291a754c3db67184f7bed7f0da417870909c235870af324a763e1dc8680bd5a01c4280be4f5c397664d7a41e84233687541d2412b0d7616ac8267a098c66e244b23a6314163bdf96370ee56f5e703cb8c83587ab933761c530cd9ad2fcb6f7792de4df0c30be927c75f45569c1d8d0b0522b805619b77e68fc66bdc8183697c015ba1d86c919a847a6fd663d5e09e5e2525caac3c7c036b6e532c540c6105717f7121cec9373b0df25e620f19f7020a6f53d7133fec8b49ba1a2f40b57e8dd5bbbd2fc8427df437f125d2b10a2fa68f90b5f1ecf156aea37254d0e91c97d54333d6ea35c7fb4dca0017a52197e3eec0d5086a2bfeb0ceec72be8c049a43dbd3a3153a5554c13d5a241090b1520737133f0fcb425073f347a1f0a9015570a0aedc35c0617852912df63afa900d519d20a437a5249453c0457bc8e563e14856b93c4fc26e99c1b20f8c38a50914db1f0212a548a71890e611a09919cec8ab9049b66369588cae2c6216a208bdcf320abb34936a0c1ea4f4f45a29481c990fe55560774242da5ec663e59556466a722e5e445d6083df4b68c2101bbc4e19aae0ac33dc8439bc1f76fde8486425d2faeddc3a83f666a144979420c68d3b5336eb736a6169a75c2fd398fe6c3669fee84433193fe05b25c7315caa948b0bd6ba0a84abf0a23426a38df97769184e45a084cec10bfbe46d5f5921f9bd3760801e64ee379bafbe907b2cd62d147a6a5220b9bff687211d1527eb97495e6eb09caa828b8008f9f2ca5bbdc8c0fdac130a0e729c162743ff789d0cc4a86d1dbde6853819476e02a4a084c831c9f4c61b0c11efdb3f01d6dc1dbcb3c2a552481fa356729c8b75b8b5bf71dae6bc90baad80f20f2caf89074f642d368c6b2d959384837abaf2b73e6bc717bf925399cf89a02d01b392b8eb2bd037e50aeb9583033affd43b6a1429be59d462651224857da8026a22686b2e3333133daba57ac0c3a4c4ec3cef8b15bb134fec7bb13197a077d2c214a9d7142d00bfa0c14129f69c57cf25f70e49a513c677c7ea7414726b40d3a371ce934ad107bcca5b653acdbe531bded5bb565b6f7b9d233ff09aa1f72381c74b9996179f388d3b40bd634c1531fab8f5c3d7e5e2f47e6bc95a2d3ed8f8ebbc03417be5129383c8fde7c457d710bcb249427544470583f9da2f68df9eba0f9114c300db9399482a0c0c60df6d819b9e547f50a13e9ce5901e525a3287c29e139ec057106d4233608787d3586227743e6ba1efc80263d7a0a2d1b56b9dd4f6b026b8ecd8ac9e0491e268456fa2e42d604110111a8144d3ba164eaa5b42eb5d528cea484e21f1e9cd98dc1fab7dfb8e9e756fd9784642790d8eb479beeff546515beee7b1962804b432131e7db655a350bc246c0ac6d336a49b74b4a7bd2a4f215d31b05a64691327000fde0c9c9972306b097162bce8f6adcecaf79fcc8652ec82ea07ec1fe8cc95c437a08b99fde009021fa6442fe207bfe29df6b107cba8e10225fc6b6fd22a0725cfddb4e89215dba49f118227d51b43b800296e4308b411385772536a6b1156f1d07e9e02cc222c49644ef440dde415afc7732daa93a04993a94c5e3152425bb59355ad02b68b1c5fffb4518ea25263cda96aec4ec932b3cb5467240b4f3c126a82f605015fbdf50a60fb411158584c499063dfb1f45b9f7f93105294677da2aa28ccbfe6b3527855a8ddb5d82a4a7079557acde3bf88bb3ce335cd4314b34c244d8f2925f69b65eeff65d028e32229a2866c15bcd7f6e50a36fc73d60de01c953768e02e19fb6e08d6838f7e0ad8d07aed26e0b372e94b35638285d8e7b81addaaacd5058ace76df45ef7f906d9a685d7103ebcb78a6ff0447c8f6394b90c3ed5d0992dc45ac3031f11ea8965dcb6eec215616bb9de10858e6b59a54aa95856e65b1b45519980cadc27768fc403a1322eb86c88c3ad7ecbaeb9ea4d2bdfd7304a56c444507b326e275910614912c579ba8b82c3a1860a5d173d43bc8c72d19ab0c2bbdaa53f7f651dcd14a5040527bea9287388e5fd9ace432d13f9406afef2117475ce6e0ab75b19d6bf361f54a2cc9b4b82f47e2e3167967277305443541bdcbd8a8642f636ec3cfa1a96082dca2cfbacf303dac23450524fedecd7fa48bd27242cd39fa2f17f100e350e290ce73ed272975c782c1da0510c4d56e536f2eeb0082dcee2f2365054256cd2ff10b4ced3a6756a8c52276f7f39b3f19d908caea1499f7e083beb14b2129ff67ab55047c4eb224a459b67f1c7e3fa1f3f6790a6be1c5ceedbf6c8c3c8b67bfed568cc9855667c31867ab0b3d2c18819e0bb6b063bc4574d2fed5bbb9946aa35d768706065bf83d0841b07893a632a5cc5b2a87d36f826337532f4fe5c03e9b12b1e312ebc6fa245bacf7207ffbaf2afb9a2529daf91be1baa7166ffac64d8dd2102115d795e881e7a99d1eda266eedee91ff430f344bdcbf2927a8c11273399c0193826c202a308f8d24ba9b38693cf194d528b3e0ffc5fbfa1bcae5bd23b94f70b8b33c07258cec4391a470cfd8386c77ad332d9e1c816505ac68e6e0030afa717ce5cdee72e8474fafa59e79fa456e89e0a09f1af43a6ad8c8d261be6fe7fa60eaa4055d99359fc31620647f02601dbb40c91581d756fa2eb0ff6f3cfe2cd9a20fd5680ee16f5253795acc64acea0e33585ffa8dd93cda1d582b9abe212547029d0c67ed262bd02bcf1b23c03a138a5d70e822addf387823da13ef65da1c5230eccad54ebfa39c221f00790baa6a013b3956f77250a5e3d3d0259b0b6eb8ce316a06a35570eb3ca6a19376f0ba69470bab2b7808a54cbdb21554ff7b0157de3bad7bf9f8ad32e8f21a8f680ac7b78231cd2359aeeb06722ec93f5df7e5f1572f96ad7a8eefc26b251bec88037bcf4fe4d2279a93bcda103a58d9537ba7bcc46db119787f4ca4f6bf1635bb5f4bb7dd5c18c26b10a16229a15e30fc5cce7e1392c3697c3ea46d586bec0858d8c03e4a69b65fe8424c9eaf422d5ae146fcd8e41a80146a004eb3fe99d378dd2c9b98fa1e194176fcae019fb95d06260d3bd225fe7c85c9a72a9de4110b72d0abe41f3d37342ae2fa5b1dcecf6afffed3604c06c3990900a7b1ec28206729b2f45ebf1e7bdfb712d17cee2e153035dd6ff354374942aceb7bce8225ef8c0e7689b5b577ff42d5b180701a06fc3ce5a0f1e37e10e74581c8c97391042a98519657b2294d0bf814536955a5edf6b6a46a0277806ae9580022371b3c43770b67e4f8e6bdf08be891387ddaa4b93ee0445341eae400d32d39255cf61af9a508a44ae2a2d8ff061d30d39bc0d4daec04e7c8bf99f368af1a9fdd6a49c494bee90d6c03794130a68a6d5b0eb59dfeab3fd101e151fd7afb708c844a141288823cd632c1bf362fa4171910a9d7611235bf4dbc10dbc1639c497cbf0b8c342548c0c730b65a4119f7713823403abc95fa5f07f0adc5adf7cf5422e96cc2cf6051ae6dd5511182f09e2fa5332d6053638497d9ef9e839c6b35762f76a2c1697a6c26d459b6f4916a59b047e00f1540c602f7cb9769f0e3fbca104b771bb6e1377e9edff7f317ed1f259770d6b325bcccd45b89643a9a387cb06168a63f56b48adce468c7416e7d7c48076c192cd837d85a08ff82ece35b9fa5e32e9cb79af758a9feb777e2c806fe5b384c84440c935ee440df559ee511357ae2f1fe003eaa087e47d1eab916053835c04498961035e49e67c86bbc8fd89368e20757aa4bb6af7f82d4ef7916153bf7f057479a45cfb4adbb3b983d12fc63ff567a056ec51aed640cec422ad030f20d93ddf1a9b6140b983b5d5df1b8c74b906059b649a7260a1ba6073e6b27fa14412063a9c7ffedc4e836ee5b051b6261b9bb6f04511861ef0464a78b6f4753d6e31e61c228bc802a353f53a0389c98ab4b2e5e2081384638dacdb0ce371dc90ac9e1ac5e91c2791301a95d2492f013f58a55f545a561fbf1a17d7ded8536b66cc8900290c0219eff31a22b641088ee9e7a6f7aec3ed71e393b9de38d96912870be765cc25f5ce9075bf5d7eb96ebc5a50ab48741f1a7673938af1858de7f3f16071a00fca363f042c5f3bd7be7bacba928c9ab3876abc6a45092fa659e50dd600e9cc021fc95df5156bb6fa370edb10462545d4c40c6b3c2463a7e159366fdb75b3a1e4644a27ecc5876cb545fb62a5b0da1fe338b74a006d1b4d434f449c9412c061aa62e19736bdf47b1ffd1130be7feab1bcfba904d367b8150adacffe2a79efb4f836374eb654f5ddf76ed534ecb3c6df566c35aeb79378eadaea3bb82285c1b72bb5909a6ed17404c0d7366e96106ff58dede4301b77544af8a2953570fec8d54dcd538dd85eeb498acaaf6dd0a0202c624e39210ffe62fcc3ec6f4feb312fbb32bd7ab6e157116882dcc524e160e8d466176018d9896749dfb2e7565a8f4668f84df1358c8d4c32f4babb1b36d187cdcaeea2985f8cc7156ce8ab6c0413d02ba28f39067047287ae58b60b034dd3d0737f3a3f776d01d6602220662f8c6c70994edf5cb2feffa4298fa9e5dc973f38b9e31b5fcc47fa8b79766d1e4f5521f168689b20686bf8690642b7ea7279ff71dd1f5a00e7aa90f9a00a2eb1d301305ecac292a79edf481e280b85f62ee44f3e5d1a44222a570e473bf8211484e52b52663ae9576aa974a72e7a775ae63e2296d4437bde7871e2626bfeacef0069df7fdb93325fa0a0b3b28194bb4b6e11dcb22183c4989fde6a27667ff7cf9def8312cb28c6cd45f9c16b38800dd42ea6c0749044cb52ac5ef5baafe756ce53e88076e6a7fb0ce2a4c7c4676f95c769dddce4ac09587827d1d95d4be28fa2b338f4c6baff5b2db4c90f36d52e79512acbc693a9e3a839a487992ac3ea790450b079cbe0ebcad6ed5e91b355f726b56c5c895a3a8ee9e115846cb49b8c6bd77add3aafb0a0da35bf91d8f31f6f27a1a2e962583f7428a285877536f7199ff542386b0b0e7faf4804d1f1a0eacdf687bbb4cc97c5da285f7a29f8482a0600a22329461d328836875b1df365d71a652681975c1f104caaa0a1c866a073b79d6291c1aa031d63b685061dd629912dd5954285907ddf548bae2f0e6bc360e3d7186d8e8c56229dbb7a9d0c509b0d00cf4455c149f1e445c40e5c9c8010c332be7b02ff4896e7cbe8be57283cd62a28351e9f2d711977c3ed9dd92668144ed3a54c08417a07e4c84d8ebe99e4d3a39c2cc28ce848cb31eac595095ae329a00d1b7325507ae8c9f1b19393f2ace0f815329b36bbe29c3d9189edefea2c359c0ba9741239b3651567da2e85a227645a7ff41564844284b30547ce29fd02620b92a238d5b7e56e72b9652fc933aa9ec181e6a71cb2d9ddfd9fd14c6b11ad0b8ff47be6cda30eed8e4923ce885d6c5ab9fcfe2190aa1225bd8102f00d6d0038e17bd7b2c64f124585f05fb0f24031a125176cacccee35e9b67467e84e28af1b43c1f9ce9ac9d11972d68e409ec8bb70df70ff487fd653227f7da570a29cc0cb619623dc3f6583004587886d4e824a447048512c98a2a6967e7c4fbb7c2467bf0e16849077a2f1ab9846aa1b39958649baad38c0ac6cfcf953a7850febffa00ee8317860dd13a5e7c332424b5d569eea4442abd5004ef33dade3e12e3f9dd76b73b5868080a0c53b035ac36ae1a635c64ad2cbde111405359669f9de554bbd3e90515bf2510f33df55519d85d2d9354e46e03a8bb17e036ab37bd3c6a21d5fda8912523753ff120b4c034c96a59ddf5c5d390fac035648620fa2717fb15e0ea0d33a7dc47995f22bd70894b51352e717ef98ec90b4b59c21c11e3eef1da95a35687db517eba416f8789e7728f9fd053f701479dc3e7e49f23d4d57edc00bad63ffa152112419eeca9070d910b144b17d91faded3d943c565b912e73699ceaf7279e2e317f97b419eb9a3c8097471e87c6c597f012c2878cbe1a9c885a9160076db7ee97c585be615a87a419a0c61779dba6b6f3730588b5a34dd1a81fe39093837cec3c946ac459524da9cf7b0a72a7b252206b1f73b523ddd7787cbfa93d014c07781fc1249f84a3189403cc45d6cb9ec6059a705828deff43e2d0398ee42bbba531c568ec831584fdd9ed39186cd9d1d11d7d8745aba38cd395c58b42ab18755064d9d502037ed335c7258beb2a75b756bc36f067a0bdf67b51dbc4c5abafcc5462788e59ffbadc821a3b7a66025b9d09e2d8fcbbaa980e00e7c812b2f9d2c940ea27eae4c259cf6d55cca0a00a34ffd9205a49ef89285048f3cdd8dcc6e64c5d13f7fadb8a85e2de2103750db774d419a756bb4aac92f67eb0417e971dbfbd0c0f37f0be5d3a4fee0d6bbc16b357a6d03a1eeaec60192dd3c3a3fa2b7ba23b8d29906e2f2d93215116645fc7bc4e155c8ed65fd23e42a6d82b59ff62296a5303f9d612cbd6d235e9426e1529940cfd1c627212ed04a361a872bc4259a3731314c4dc855ad7901f23c9d3dc68e7e5dd9c5f1bb85bba84c5b8b569227dfb68266c09330cb8023c68efa5bd5c30a65cbf73a86ff181ebbdbec297bc3a7ca50e2c10b217068778e743a0e0a3fc74b538c65a700e0674c9884f36908b3fbe04501c633006db6bc39dea8a8d99108a7770d72b92dd63cc329864d72fa7ed2a564b1c405ed18e0672cc270be3114e3938ec140974e4d1e2b7bf3bb65aad93386960c9db3432a81bd8aaf1979115786f2a356612b9597d0ae89f26117163a7d44227a5d846f67a60c4f0adb9253d2c11bd71138d269bf55130f150b0f5b115e5c2c78a7a139d14c1e58c64a9853623cb429af017bb69991640cebc22a1af04dcd54eaf4a004da6820c3081ce7207b2f2357e74ec99cf7d00785806aa5374574cb45219083ea685690998c7d0f73fe34bf96849b8a431598d2f0eb599d06e2579d9a777f0e7b7496165816e3ab49b3e229006ee5a5ff04778390c2527d651dffa516cdfd2a537ece45da327ca73797661043cfc48af9a7f5796eb83f480899726af77ae6adcf50a7a8eba6878bcd0cdb1da5795423410914405da1cf015eb5d3ee2db0dd3f2f42e686236be9241e86dd6c04159f0017124f60c329fe3ba35dd23c6dfcabb2c7f2eb5135f12744d67e31e88983476d92d572c3dde333546c8e9002f6c8c4faa80938acc90fe4b6cb7da8589a317b1bdb517d36e67c23221b103519c44777e512b3cd12a4149662d56226738b67ba8f4fb4779ec529f23579b6365ee6a790de34d88b99a6962f5571a91cde56be1d8a7c5add17c50bbe3d069051fc03287eb829695e140a798ff8cf70d71142155c190daa3efa2df7ccd4f328560aa59a8b0df3ae54b3763f2bf77e5fca827abaaedfa54b6c3604c8661184e9c2a45030db7f146009351b2273610a73958e6bc6feffe0cf5d2fd9c53ec5a9ca52cb981434facda0515c2552cd78e34fbf7755c684a96144fae6b29c4e5c949a0499ea5cfe57df8707797341fc21f116b010e66a70a2546f18c014527881efbfe83b2adba8593fb6752b998f170ba67a4aac73e39adc92f17548d16b017736220d8ba1ef9603045f18458a865de6d3e29ad9e9e8df3f73e88f25fe4e5a21762d61604fc7d24b7c0cd830be3d4956d4c64c5bb7b121819dbc6955cd7efe98a3e2e900f6d1cd242fc7322ef70022f97044f09fc0a4088eeaa8d1d8e7a5f2603d96de51fb27d8abf1f23e626867e462bacc0d079a663e3ae458bf8f375378f1652d1908fe45ecd2bedb9fee97a03f4ec05d2c31b5e1975105f615bffc6647e69370f0c44f9b3e9dac31bf0196b1bae2d53f45482672ef9bb35f17de63782cdaad8c52b536c5c8d83fd6e43c6ff9dd1bf4bf2b82c42f18fed39fe6579c2ddad3f2e44f983289e00d283bfb2083a65bf3165849ec4c8f8fb2ed3b837ee9675dd410cdf0d59b7b4787f4498fa1883066a9d2eae3b2be5bcda4c8a8107dfb3db0cd374a7b62c87b55f82fe3e735ab6aa76d799fa359be9f67c249a7d225057a2d159e0ef7888d36eda7ebccb780c1d7c8226eed2ce24fcd12db7d0f771d81fa345225bf737fd7cf555257652f23e3b0d0177c87b1a38dc96994eb344143b93821ad39f01c1500ca3cbd769695f68e74692b1c16e994dcc682ecec121d8bba797da35f4bcd79ae177e4badf6ab16c071dc563c5cddd1f900704d4fd9c4bd6e91426904556eec2af3866f12a4f074fe231d7d3f48a527c65ffdd0df195b4fd4eb92cc38dd8f9a0be3653184577075f3a9431a4cb45dbbdb84e90984b5f113fce753fe689af5d7435ea376038b0ef6c94a779e39ed59d0578d8bed06db24096ed810e6d9cc40253ee4965f75e354b3115458c478edce6ebdecbecec3335a97a5e8f8f488392e6943e3d09198f5808fa6e2aebcf35bab05b8118887f5786a9073c7b229bc5dab1c90b8db79f0d7fcd7080345f13eaf107063f11c87ee214b5c13caffa0968ee13449f3fb6836972f7ac27165e77644dfe5c9a88efc7e6cc5dbceebce0e8addc1d0879af77413436e3fa119abbc587a93e310699538ae02238a0939ae1b8742117bee28fd942943da41c1100a79d95d4453885dbf78e68480c17b7d75d3246aced56211337a5fec704b2efd9656ff6964b3996e7bf2062ba52f80711ba8f8a439d39413eaf70d4bb5ae91ae5f8ac2b09476ce400a9f87c8b0ec50b45cdb8bcbe0adc743579144999f099a4ea2530b9318a637f8da5a27583e62a5b65c060c57536d4a4980558d1d1d16886ad3242d266b7e3a948fb2ba5c165f4ffb8260566e136401949e52015579b6794f57257acf0b2f5c496aacc6dcba1a73efe3e0aa54d6e3542a8fd7a6032de25d2f1620287b45059c73ea93346f2915a09f7f498e1ec6cd99848a03cf8c8080efcd9d17ffbcb18e7763fef82decb2f1bb85b4e3e9b4bd72588a9ce2f6b4026f9e922bfe2db3e594d5a4e2936da1e792d11344b45800afade75c2e864e190aba972d59ed2818affc9625f736c138307a3eff8608e5003f711058f9ceb75864d124ea18d833a6efd6b622cba1ea7eb4ffce32b249d9c2eb5e1852185c0d604f3c25d41c88b8b55041e34e29749082e63cfe261fa13bb417868aeb7a1775d2eeb1c369e62be879f4421a8dcf01597e0ad99cb1a0e349d3b2c5f02c0fd840b5302eaf7a21b7e3ce0a86cbff02c8c4ac069607e9e389ba60b37458c56ff4090ffa351448081e06ade8c736fba520928e2f1aab439e2d6a58b1900604dc329d2391025422605f4a054a47af6a9a31edfcea7792f95bd61744c1d0fcf33aa1355688862be73b2f0696e80c48b58e3840597d3a9c3b50b0b4d0715ad5c66bada18f43731d7868657f15618de15aa9d647f94d2c1606f6c6488545ca6ad16556202e414bc4bd1fd4d280dc0d97bb9b33db6436bccf0ab99aecda5c681fd2f3a36730c14e92fbd435706e54f92a62858858239095c01ea5856ad6a6bd7595ec1b3330116481421584112f12ced5c5e41016a1e95b34637e2cdffe2ce50fdad15f728ab439736bb40d7e8f950fefbc5ca1f049e070f51faa24f0f81dd50f06401d64bd8c37f1b0b8cb14a1a7029c2a5410e6a2eb69352ff2bc669ae93133700ad1089e04bebc9a212eed5790a9d7796f55430b2f1c84f4ee5191b1ebb68f96633438760ab8842cf417be87e9ef6f01b253228ff260613dc103323751ec416ed7cfd416ea7c7b74a65fb0b38c41f0c5356ce485273e6eca0653c941d9d0c0d9054e58d99e070e7a1079b60eec251655792c2d04d80220246a46e517dc4cbedfb54a5032974a41b6331185ef0aa331f7045ac513cb4811de8c6a768bbdf8fbc156ae7ff7c23cc610c0386a520291321c4129249dda2fc21c3e53d437e1cd923ffad8dd38f0d03ed6a100bd7baf96676cbd22bcf8a9a4f273a85b6d288a034b899767719109f551d7713d448a86bc8c58424894bb415bc8c8344277aece849d29e28824c07e9e187140ecebc6484634ace27f268f7cab2e06cc26a6e692280332eb11f40bda5a8a061e2c209440b9817f7b3fe22e2c8e6a12ca7f751cb23170107056e0300643b3db2e762edd957c6161c56dd76ea6bc1685c9ef75a9e291eb93da8465675047886232c631f3fbff5af0cd7d0747885fdae0c0c3a4aea7162450e0a89e7f0600c5e1073e5354db4dd23a732c75d059f2a0d483d6149c768917e477131ba11e967b50065c362b2fdc557222030ebaaca9615faa497ac9b95357d413747f7c8d8c2bed99313dffa6d6cf09b3f4e4c20b142250740daf889f146f1d069da598d52f92f5e31d746df5f532da8210743d4bc053f91b10d8f783f3d0930439895549a2fce5ba5624a150f16929e26770e456ff01fd1a6533330f57b05865e06e230822ef5eb79b93cb443025f2734ea3fbe35fa14dd8b8405fc4e5c65d014a04fc386eb5c561441ce47f0209b5ead7a3fc41113effa967ade474c57b9bf7763f0f70e8247682217756e06c2471e088f55fd1131648ba52a22bab812dfe8b06db6a72088d4383221636f0cd63e12a9c209f565579b0e955bf76628a1edf86026f692a5baec452212645f8f58390cfd44a86ac7ab6adee4834b77996dd12073fefeb84f5b17c0b9ee0c6492f835ed615477552bc3fcee8800d913ddc17d3e7a216c45912e166113ea17fbd2915945974965ebcb37f3957581906ca9b1da71d9ad434455ffad00ad200ba2e2047adc378ea71b0254a6662a5d1b5ba82d6144efca17959f2e1cb4e540d3a226afebe4ffa1360e1bbb06721c17c6ff2528bc0050d1effd9c3804643cd98f3adbea6011def76a261cd781094e6094936ebcd1db9b340cc50911ecf0d257fe1c164b978a4361fc4e70459faee1b1d5dc42113e819ffbacb45f272cbabe3347bcb05deb29248f9e8dbf32f8a2ccdf1a7d9d47615c48d90d6260ca7b41159f5843a6d035a9cb8243fa16","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
