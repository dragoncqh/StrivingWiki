<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5a6f78fd77d4b20ac580901c84d224c6c75a42f60d724a91728fbfc2cac1a6f31a2714280782c6504eaee175a5e224230d4f9128cbe5f1d8f1059ead630f13bfbc2187b4c5012449093f802c10a3ddbe2877307feb66f90d42122156369b20e0002707d2ead92e3eec9f3639310e20d0b17b41ba8587a6a74b42331e89265f89c866a67866d56da05c85c626b0959556190e03b85e7bb760512e14ff6cbd1f889025d614ded662232c96503855f25ad94dc8c67a6070b77bfd1b4f9bb8842ad0a91b869ebe53630906ad86f8061d892b70d63752e399f69714483f01745bef8169025f291257a9ed910a25f1a966750dfd639238155adc6b7194676fe1795e7d5ac26cb11ebbe825079bfd0e6ccd8b112b2c55e80413a670fad0030064f6004d2773f3299372f65a8300343c276043983efbc263fc5ae4d614a6fba6153874d45ca75ab6566750a81c8ca8b0faa7902f9db6297821eb8e476d94d740a4b903eeae00da455bd0f80cbb3fb69fae25652787ff99ce76ef0e6872bd9b590b61cc5986ea187def117e4a96991a7faba9d44dc84eee7d70fabad7a4172ae5ce71f843f65c2fa4d3f89231edd7f5971bc01ce0a3ef5221cca73b442b4a6948592c7cbc807df5a91fa2a375d85517c30cbd2beda05c086574503f9703d5a67a909fd0c6aeeaa628c0bf8341293cd354e34bf10f991f4f3861a31e34e56cbeb9dd7dc89b4c6d2ee81ef3d286776bb4e60be7d1a2f0fcf19ab1d7eb6e435270a8575747b867e66a060c6fa3664d45b895d4f687174514db0b3106ebdae88cd9bdd39fe081d46f13916ccb9a826194479098097793dae649a8fab202aa862f57053f42c34da68bcc43e9f143f73b1fbc23c0c61d8c1ea48b82a06fa3a1344683c43d183f35fbe4c7e1d579e0242d50320c640d91d5d76d4637019c57aa675a408b7c5b0163493ab3814dfe0ee08e07fa822618fc6d09be886424aa35af1600528b64f32a1147c986ba96040a0413d86b484ee2683b95a927a9c12a03bbc7d52216aeba3128234fa3ebac543b017aceeecb6ddeb17425c09999c3c3f20ce05686b68f7130db96d14b0f19ec47485566e735a7cde24137246c6a876fdc7db3e2657c324d91616b0595d37066db5256f7c2d979e284fa8ec78367bd20c8a8a5f7178d1bb15395f2657f558d1b3db70ceb4e463056ecb006d36992a12b423275b0712e6f999c8f766d543edff4371757668d02927b87bd3e2d2b919920b3f12311cbe5d57926933dc065cf92a67bc06af77c26b36aced8213d125f3b76672d733bd774fba584fa126b849caacfa48e52f96756545e713e199d8f39e80562937d18160cdf5ebd54a8e4919d598eec3a7086929837332931e3f7fc199178a0a99274bc97d1383a1163f1ecd51074fa8527b0850708b30d0ba74513fedb200ae95faccd3354a018967d1a32a7b6f56d67e80c3d340c143cff4f5a65ca006263e747bc29392f79690a22384808f44c93e94bc54a4aaf1311bbfb77242315e55384e0a931e55e21cadf9742a11f743a4aa67da36032c94a7a25af5f5be305adc99be30137ea6ee431d6185c9c6732fa135b0b741b6807595a9fa0945762f1e145f487830e71d0a87eb71867e7d46555518e793fd416129a0060a498487245e7eb0fb9f23f6328e2ba179aa5d3db780803627cd00860d54c4db6471c8867e6ccd7043607d6f23b8098f7c1578d61f2050a9d714f23016a3d6e1d420d00d0406272f56de6c6ae2c8c40c5c39c0d7047d84b9fec8ff4c23db6ac1af75c404ac5869aaee4fdc233740a1153636f96f0fb9e1060ace26961bf909a7569a608bcb7cd59086dce6e8dc43558f28732a16f1b1192957d772a8b37037bcbb2e7f50a2493989bd24a98c909532ceb17e06ccd4ac64c574c28e50c7e82149c8cea4ae3ae982a6da9bc93cbf29ae8710f133349bc4932c94a63f8ffb05b8ecf2902ac3207dfb70676119687064b2a27ff5e3e29d4ffeb392e2b2516d1669c50ee742270d64ef00633caaf1bb9eaa2120c19ef67e9b28cfc7e98330a3894b1a94fce038dcdc17079fcea247080d426c8b2b96f82502b789f8c5c343598755435867a525c208f55ac975823f9eac214b6e3edff153c717d6582448f40fc7c10c841319e3e95be458f65afc01fe2d532e4a1d36c1c63fe73262d9323bebe99ff99b5820b8bf3582030232b719cac34e6a2205d8198227c337757884edd69f3c4bfd2180de1d2f790676be18b2548e07f2f6f697eec1a09d78449b7944bc717334096eb36b17a11290a8df190191927f6886df27b65857586a5bb9c1d3d4495da4191536fdf91b701a7506004386b2e6c45d9fb18b17f357602f8768cedd9a9328b1f6b6f1e312482c1066bb517f22d701ac0da5532477bf465d9899083d0925cec0622138846614373616dce34e781e8187946ab90f651c203164b7b621c8ba55bd1097950db35979c4bd00fdf51fccd24a5bd4b2c6885ee283068fb7d09b950dea238801539e4697f510d8a37f5d1d014077fb7cd39d4bdeb3f271b90e96b5655450594a212fe879cb31823877dc0656a9163e5b2bedc7e6f44b6513adfe166c24d8fc2aaa33b56a561d851c9d3f83bd9626e6d1e1921a0b290449f977a204ed6b445eb7b1d2737bae45e87e07129c069eacc03b1654c7e8d7589f245c2a4d03e0eeb79a0878b79dfec9b6163495fb444312246d43b3d0453fb232743c3a4911b7fa3413af0f65270c63ff5174ef5714907c0737ef678d43d84ee91db4e1b0566b14177439d184b9152096e46da6f20bda27394d3f5f53894e8fb7ebb99d4cc05f804f5503f383c86ad14f680a8e608bd410f9ca75faafa397bbbe1d3d722233e63f6ecebae317d502fca950f89f37aeb9ae3668e8635421c14b47e101ee2cdaf53b346c1c5f1d70248b94cb09ac8c24360f6800ae66791187f7df2eadd83b9ad47975529c278d74517be6c9dd4db44f67566386edadb26388aaa439df3816a7de795d3674fb76ec2e3efedb2f2cc76f1a20da488dae0ec99c43e0aaadf5d754772c782b9a5b6984129f5308c3cfe726e52d1b56ea5b3c368a829d775d84b8556f9d9acbb525c423cf67a4eef69c08f885ab43944a91c1116b8e67dc0e390de6a5124bdbfdaeb3be3ead4a39685f778a99ff7d81e99d09bed3f42322dc504d04a4bd28e9a12dddc0e625ef9eee1d0b726c4d6706195d49a63bbea9ed711510f0af614a00e317cdc41350b5d708846f182b408902243c2ef8b154255fd6fce5a801ad50d01584110710a78072846c060b89d6f34b0e896610656cf42a86a6bf5a67b37bc7b9b8188dc99596ac2ac0fae7ef96edb00f7f398a6f172192e853942ae91a7ab2111586c846bf30a42c45c498d767b4f85543f3d7b28a0a36b2df5b41405fd5573fe375c2debe68f2ad8f9954577e2eb797962ca01df3c54b96e673029bd0374852e458fd34a8a9caa737629dc49ec6749e1e5ab9218c830dbcd7b3d85eacf35a8fb707c12113af7df7083a3252426aac6c30b96fd5636748cf7218b48fc108a30ec1531cd527a7424b0f3aa0790b440cc683541fe4d2e3e239caa5e06f858a491c08cf112f4e92c5583875335d8da2a3ec8bde7ee7a7b40dd183e5a9c237433c62d01fd4282c37ff9a993d4d21f7b0ffa1c6066d21c55c672b9fc97791c85c785af0e13e7b445905e26e9958a92a6ccd84376679e97271ee4f80462b5ad85f76bddee84f2e1874c25eabd7c7f433d5b3e833a2960e95b46208577201537c895634219614801627a0768513ddfa60a39dae8b119b1feb3620865a4c9b5e05791afde5297f8927caf31680d00b34c5bbd97e0f8ecc224a4e1c5e0afd2d655b62880bb892a49a90f28241f437427b2c489b34c3fd940c0f1be56880513eed549157dedd3fdcf998abca6d1e4330a21c100e026d46641544f9f8f26d4a0c955463754c356c0dd198a52b8f6ea93cf6c4da1fd433e2ed7a89ad148b89e6afe83a31d2d89829be17cf0b4570f0532a676a10a72f55839d520e05005429ea3ed39c59b27a86aa474e5c40bf61a50b5e1e1e21b451c7ab9d21bb09593f2041831e6373c5b47c9acfca00d47e0b5554833c8241128efa1d18ec92d03a8e7f9d36c93e9881f0b2c68b1dbcd3bd873ec55dd1f18bb1c1c4b27b6ff6a383835381d9a31707319aacbef1ccedfdde2787218c932fa11b98e7e9f32d06288e539b60cd920a289cfc4095006b72014077c1318ec9d3292c25edcb8ec0b692ddc991c2dbf478482ba24773e05b02aca30dff82e0bddf3b1573ef129cffa06defb41e601a9143bd00855e73a5874556759c813ae0067b39cfdc05a483f9ef167d00d9b5dfaf9f49ddb4fba8daa4a5b9c33c12c59b3891f60fef391e59fd83f6badbb85106e8d3d307f481ba000a50838d23eef7d4046f58601694b941dc753007fc16b0de0036218d24874bacd2e997b3266b75c3a9f44b9afdf4cd91af429b6e13005578e93ff56d1d4a6cc93c602ccf15f0acd52773733e6bf7c564700b2d37f89898418d9a577cb5d12b81017695dd29c7a1c2960ac36abe1ac434c24973d481b30f5e1965efd005c4682022b90320b50acbeda8c7e2913a54df2aeaa058ddaf63b21c0b57782a561d8bd1783f214585752bd4cfa6aea3bc3e7f755f484b82a73a7a7a05fab865c1c94cf3a25947d8932354fe9ad20a14417a4010e417d41d12596948803618f19e58d3c20bdf7b8d1aa2a7b9573461e139725bc0afa4b0a785923d7ee722ed4624319b743dc99e7b9f6ad82854c9b80b55c3497d820830bcb86b25ea8251729be0575a9455ed16ff2da6101599fd35788f1055693b14a73a67c8888bfb68e4790466a8c362cd3210e75f1c76de672de440d1302ded6ba7c4d954551ec4390fa5d5f181c34043d9313d6f802b9b2d53ffc6e1f3cba6f9c2f0311708bbd92e8ab0b46e355f8c59fe8b24164b1d21ce4b512e1273af9285ae4da61755447d9da40f80321f947bc28ecfd7e5365d485c6ef6963b17c83758df4c35aeae7971bd484892d50a485aaf4281da1ca74bb9f0c2c95ec82a9bce5c535e2761df9c168ca24b795beedbe578a1c917321bf24ba7498bfe7a95209290d8cc9722b884983e57ceca9f812f3fe83b4e93129bad755b27b01a791860b8b42b4cae88aaad6c535ba9dbfea25d89c5624cd5394d29e34a1a4f5c0205cf8c0ea6c2061c3ab5ee9e159184fc91ff61a53490b735e7982325116c552c4cbaef53bf3bb587355f568e7804122e45bd01b6123873a53fa87ca5a51622a566514117695018ac8d12ffe8995b97d88f1d770b979e9c50e2c09cf5d45219ba8d1bfc3f30ac0a790ab7e276439cc3803a802ad5c0a5bfd0a40fffbbb62bc18571172d9f0831b4f66cbc1871e4a4f208a38101c0b7236b699695fed54f829a3a507929ae67ab675ca4939846df107d463bb15cfe55a2f21e75b26350454ae823b5a8576e1a8f1a2f87c563147f02cdc1b6ac68d8ec0a5b9ee74969593e87174ed82b7cc249f40db461d454c1c24f516c423ab2f89f971854b8e48b41bc8a5673491aa5f02d725a2919c3318b281f56eeaf591e5f6495b4a339a4a45d268f19721d0afa0ccaca5e8c243df516f36ec25c059b000ffba457e2a004dbd9a6c262a1f935b435c271ac90313db765933b0adab1a6d7cac511177019b7e0a743adc93b171226a86ce51f6874a52a7bf896de39d1c683a5d0b2d2c99d4dc9ee5dde65188cff18131d92db7a02b380ab69486698bd20f1b26e916262d49d05a1d97e5d88323aebf3fd7095f427b3fbf903d702c8b39a81494464f480db895e818326bc22c5af2f0513272753f9ec1e4fe9449497e53e1fd66d95f649d2ab8bf524f786feb425b2801e62c5bc0403992efee17f3d60ea398ec409fdca45e43f314e4bfd54e4e177bd2b789e9c20136f9c08a36490606adb766d04ba8c564db257dae94ec548200050e226fa3b2230ff9fe4016e2b9e7e12f125b2ee318bcf2e053ed2c071c69b31d7d304531421cf61f522f4c9ecf522f235904e7e215dcec0b195ce744b10a2566859bc14ebddf4424cc660cbfc08b843567c5afe68774538adbf8978facb718efba4db863f6b350ef76f0e6bea8cfa118f32e1f8492637bdee0f9a6a84d78853ddbbcc7f18d00ab80f5e2245a6674d81a6cbd2da815f2b73f97516b6296922268aa34f1d852831492f9e6ff308eefcb3363bce67b8f787a8299b90efa315bf47c7941db5f554621aaf21c5942fd2045693b1d01fc43e4ad1f5ccaab927213ce6de59dac79a5b682721e27f4724e93b2bbc49269fbe46fe5569aaad4bf958c27e588df54787deb05cc2302edd3c70e1e2db5d41e2fd8ea251c1a217ad444044755c58fa1953c6bf868ecce0622826e084f8e49b8720439b296d6b27505385456da6447430d2be4b330766ca7e9f0aae74a86dcc4ecd736f91da53e43369991900c4cbeb74d2fafb2d46a91f9f951b018d41f839c4da3cc7338413b2315ac05c44ab3a56e0985e193f827780a77857ebc504acdd7bbf4afef889c9b7f5433916ed9ea7c90363341df5fb757907f8845c2615ee87a670125c0729b3e01a8dec9908b336644158f58bb825ae8439bcc6873d9f8c82a10c486cf00d96e5a0e59696fe2e6364fdc601ef6483e67c5a630c51f7ca1548ba4d12415fb8d356b85ee24a4995101c0a6cabd2a0c38681501f56d6e7924363dd91ffc4b4e497cc784b61e4a38d8a24329e8cdd85f7f3464beca8b85f03568a3af2de5d6cf393f3d0ac0ce9e76da88dcdba93185885292c01c6d348436e213c6cca757e52050310c6585c7f5009d811ad9584835e8ed301bd1fc01b3c9a1da117d8b5467c86dd707bba2c599fb7bfbe8afb70cbf1e14d3e45fcf1b74a56d4cfe631ea956a53aabf7fba0c8029fe072a8f8b47635a8a268a7d225335463c2c2212317e8848f49e5817d5a1da55b26ef87b0ddc8f914fddb730bb06fd43552ae6076a6a57d7fd5c7f90114336c814e0beb99b20442a1ede3588ce42a9c65febba52f66df93868740e35ded6ad43fe2c075e8b5b5edc3d3675cbe9de1a32754b0f68ece280fa15a94e91b9f9e1ec6d17d22f4eb35203caaf777b4e4aa656767370ed49009fa4c8b757b2c0147ee9ff9c676dd588b095c322ab7efcba93cbef276c7647222da99b7b905c13ba58bf34c31b9d5a7bc7718b449bb2b5d7e270bca34718a610a5eccb5bc0809698d84f0ad3c790d61de17ce0baa0eae30e1a183195ae2b302af1fa3d7028b0a60d4685ae48cdd71040dba1e7f4ea5915f0ab1209839fbc84c064c3f352e32bb48533a66d9fb6fd80e9424646d117482c0a41f475eedea2c075355ea1bf597f9b15754102987911eddd251b8be37c8aadf1d6deecb532fc9f76653876f598b91ff552e912b94921359255de7113b8745510c01f4b35b2393664a65ca9a4d848e80d88afc793e19aa413fd90f22c5640f389895805eea3742c228f6e2b8d5c1ccbfba9b2181d4cae1c3a1c4c7a0f197e58b0b6244de0c827680de5cae40094da113cfd8b098e2c0c04533ba97a8a527f4fb38985b2a5c95e0353de9764930eb5839ee659837938c7abdf8a63fe26851f3ab70bfd3ab7b79c12a12b79c4f365e1bab39d43139499950f96a14b60f154a1b2f5d425c4151b174bea41e7ba256c4f437d2c45750f04155bd0a3a6c52d94931cfe42921e976c817711b02837176dc6ab7f61cdd19e2dd9cbb67700fe1f6128b6f146f3155e97d8fb860e3a27b0f7084fa22408b0a448679a4360530bd053260648f7b3d03fb0bbb1a8ef1fe503682aa1a9e52a71a9530a6c99aaf09550875a220ec6b2746d99a54662e05101893aa0560c4d5992509e608fe6d80b0612e81be9c494a81c5efdfa2243db27f51f07647d3591f00db036fe509003ea12618a6a2a01fe2ad47ae5be4223512dbcc91e2576705596a4279a106e7cf8707f7f375a83ecf9c1fb4e8806fa7d96a4ed65b2067cb884c815d258d4f20711975e888c745d3a4525c4486386b6900fea7a56eeacaef798f622ca8ed90204d3d36b1cf4b3de7e3c26845a942fd1a2a1f1ff1332ba86e2413564d50a9d732fef00d51e75df5b6b4eed7b907d8022a91bf9065490db1d6dd91e2cf18bc273fdd154e423e283da4dc12003c56050b6a100626ab6ecaf96ec5a4781fbcafe3f29e057b10294bcca0b0b8b82bc8ea474726d13fcb857f16243e96c44692fda7531b1012b40d1d9c39b21f793479f3bb5cf52b55170a4a823e24d6f76ebadc582619ad4af5c9aa808c6827bcf10d6360a1d2b7df3c7ee1acb71f3fd61eed0074d551764eedd233ca2b87149f6388517df4de99408139ba6643b72c13b578d8ba5ec137c6a578a761e4aef6c1b0fa55d1ddd1a096d7853bc63f9a836aa152f883be37877523b16cad9e5f7f0e471bc9362eada31ddf4d539ad23550a5f0f9011953d85eb788d078de4cf25c55cd4d96bbb78337e7306006ac376c4e35b9b9a881d2e48e443b7b661921fb5c9e62d7cdf58f8d2ad88eb2ad52581be52fcb6e62ab67843d8fd548741041bf578be894b68ececf286b7b6b5a688b356fc3e3ed60bd4eeec63fd8d4c0b08b0ad66a72ba383484e5ce9859ec34975b3b53392cd26e3725589a6981d5236875114cb4d24abfb142d3d1469538be93389cc836a7401cb757dfec94b289be090dacc0ddb555458ac4895cc11941b685798738f51662b038b77a150ca98f743e0a6a78b634f971e6eac5d8bfa6dc63bed8796ff3d052f1747f21fad628d79ced645cf6dfc175997fbe7781","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
