<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"799459a86e0fd25b941286999d4ba05cf2c974a48693bc12c365cd2d1e368a9c88817d7f52e6731c177002c9340408be0b48a4396da9cdec887d4023a9b61abde8b8e4c20de7e53c89b8351e650e428b5b258fc2c669091f62ee9f5812aa8cdc737104ff6090c70d722a99289395067f12adcabbf75d5f9c7dfbc77e027513450331304686af87d90fd4fce8ce00dc44454ed886db503701429c8108d26a4a1656c4bc9564742cae0282b2b68388832e98402032fde6b1dde85d654c73244d72c13cfcbce1bed636990eb4bce1aa189239b0b9a288c74921d6a816c54dfc3c5a3e8d3e9790953e3510b23f0b0b2f10beb8556bb689581e60ba363e4699cde095991dd480df5c3f952a1a3d2f98bcfa9d3f7bcf247b79f1a5362796fb8fd5614f7f6afccac5c5d67078859df4f726fe79dd6129590f7bdaffe4a64bdf5a5839e6623de8218158ae6fd8dfb505313f8d03b67a339e677812bf4d78c664a0b31801bee233408e289509090f1009d4d92d92bc503ff355cc64cc36e13726bbdcf35cb8579474f991cf9a7efb9be3c78ef28ac1262b19b97d1d3ad9c2915cd4548f9529fb5d0070d3e3846b1ee8c0078a5a62c0d56092a92fa1bdcad10b47c2aef29799e453353fee9bcdd82b7280684772b05f6aac12f83b705ffe4048abcbb78a30d7722ec75c10cefdd745ccbd0926372324b579771cead78db1fc2389bca97c2ccdc0bfcff43bf76944de47102f1738bde7c0403a3c5483988f599de2a1f2f8f06da73b2f03cd9a08d277062500e8de9368cb2fbb44e91060f5eafd4290f5812b879b4667d96ac61638b94fcd94ee2b40cb45ada2f5b3f9bbb5623d6973775d6620074de375cf6c47e5cf6a8c43c3129e3560e0e533ded89a979bd3e4eb932c861e722942564273b717f3fd5a1ec02600178c636ef705f067f9fa59111634ac8941dff5f12c1979a3f42cb550b9d6fba296f6eb9f383baa58b5ff8b7c16f8cfa9a0fe799afdafbcea6f6e8e795a3a8c520e1e338a0057802d2805f144af2911d5665afb3bca57691863fe4565bb91a4f80d8f34e337636bc376e9f477c2d21586a78b8af53a6a64f0068665af8682b7072f01b347a3df3bbae0ac22fe96a66f289b29e9788785adbc75e83cc315475936e6389bbe3a2cbb72cfd4454d59c15c2b0c7eb157a070b9dbc136079b08821d6d2f76c6a0364199bcd72077cfd73d79f0a6ff2ba0a67fe8cb6924aab88d20f2688769c09314dc0fdcf23e2134f8c00154d7cc37c468c677dcad30f08d0c7675b2027e4cb3cb8bdb31f248bd8ea5c0cecafebc4c78d667df4d7012511ea3254537e1cb4b24abee82224564eb0309700c6b27a3bbd89d5c576cbb93cf0c5ee65f0afb0aa63a3611c5974f2d8acf754f81fdc208013de05205067a8613c219bc0054d685fb3c244edd11e272cee6f42072d4a21a5ee9896fc448cef241c0c30dc40175de0bba7e57f36997e4d911f18f9d0c9a9b01aa79ff041b96f2a60c606863e6cdc6370f7e01a21e6e75afe98b7674e58e7d32908ae06c883333cfd9c5abbd0e1a2380becef2e8029a716bdeea48429f51815eb8379c3bfedc4c402722f228c8ece3f423a4711edb709ff6f5f9d4cf044da4abd18d051ee63070d15f6d4a0ab16fe223be232a87cf33f64a5b1fb709aac973634925ba9e65880a9ded4edabe853380e70c764776f7ecbe6a1b656b209a18ac493f7812e3606e387c7a0ef8dae64207863c1a23332df950125fd16c614af15f1c60e31ecbad8fecafd947a658d4c57919f7100756c7663eb68d266315c1a4f8aa9713b8a5efea35aec628377770b08892d553ee761337bd773034c57da33c948df967c7d4119948dbbcad4ee69196d3fd05f5a2836a3e2d76be10cfe47dc7828a031a9cff8d0fd2350aeaeeb7009041a34b982a493b524f11867d17c8069f16b06a25c9e33f8c33ce60f9fe48c04b7da7b74fd0ca3ef12a02c66ed45c8e13641501f2f504fd83c41a20471937fc7d98d793dfc12f65c8293780c29193398282ced4087d6409e4781fa7a97f6abc12dc3bb96c2436b92a8941a1629c3cf53f134c92f7a6f7778db9c79128fb8096d890b333b53e19007ee44695d9a74577e9c5c47060991eec37c3f3550b5fc6a56e9902061ed65a03052c326a3c1bd75c459adf93defc1bf1a8d5777da92bb92657cf54e5c7478697e002c28e7a62ff973696b5692e450549c93014bd2b6b49df2bfb9a44cde1bff4fc02a77aa4e749d59b0023438fe1f04f857abd4de049c023113b705484e1b8b009c7c18170cf7a80c980bae84f10502c640ce7c1d63c0a79c8545c907aa003cce082ea5e937d440cbe6f225e4067078819175a4abfa5ffe22b2444733b245e81eb785eb1c14dcf0cfb45ed182c7310df8a2f241916190a20dc54971c33b35731b64aa406beca07ffcd3514d23a51771760cb3c4bceb93e79fb81e65f91e30a480f5b1a78f7b2b9005072470e9b7e2ff6861cae8e41eeed756cf22e18c9d541908d42124b179532ebdf865c3a193c353a77854058712dd6422dac7d1269a5d926f13753db07f0b5bcfa86a0e4b8ef82a3e915578196541e72189b7c4b976edeef26edfcb57fd8bdab41316afcbe5952a5ae5a94044e2d89b85b72228c6d16aad9d0392a10202093de3dcb5ef97e5100ade6b08feefbe208498955652a3fe1dd3d1f9242520ac49ede10da9242a01b632db72e4849187ddc1d6d6276cd31af7cf6c56aa535156827213f2ba022b9cb0c96be0ef27e30ceee3ad6880f55b4e2639f3083ce1eaf535aa32973dbd331ec5ada982165a748c8a6797bb743dc8108b9fddf9802955c332658e7ec47d5c84b7bf73742f21bf77e743fb5e12b35b6f2e611b571eb0bb24f1a269e66a00b20917a8410ff3a0870636ce6db498376b655c8cf237c675f6b124080cb4a7a26b33b2cc0304d66d0f1072deb9f9646357c7aff69165a7fe4314a0d5ac614f2d005c62175a10860fce7fd468cbbc98a66269fbb87a6b9bfe6c8c8de6df0c27f102b2189dd072e5e8c24c7bdf992e84df5feb9bbc737f76896bd4f25cd29725f345a0227a8efafa46e128d251f1201758ab0734dda9ca47c6a3cb0544ceeefa4c25e987499a8bb1c18775ea50b297f6978696d31f93cb1b9bdcfff1bd1b884dccedd4b09c3255e6c8a4f3ca1d6cd4379e7e6936a5fce5b2a586344ccf3673acc30e04de010d9e624ffe8f5e59c8b800f2a56b9a88f3646147a5126ef2e47d61b600437397ea9aa695330a2b649c36922c381c782533625c6c5bd43077e848418853f101b073cd2849fedb870b788442d3daf8d229145bad0be09fb0ee75096e23276cc056a5c4348dbd1a8d2a3a1862dbd4d97a17fc0fbf76f87de03a51330108090140de934c26a3d782599244cd9dd1119affd12d49fdefe072b05bc92dc3fa5dc7f5ff61b689b22dac2cc3e846be3f62d91b8480dca44b75447636aa6d4dc8290757b370b8dbadfb6a932bcfaa0888e263c5ba2b8aa372ec215ad54b791969ba6163fa88bfb2d09f611edd19567cbc172ffaca33adc1bf9d48cd351fd48542a59536b2d7cfb1a14ae7d29510155d5865c4cc94cafeee55d2fd71dc06638358e40660900d3291c0198338e6bcbd22b65ffd6f59018986d2a30427c3c9443882a4329ec8921008998d9f4713394e5e0db287e5f2e37cfda525fe07b305d0c56870a7e072492dd6ad7e2cdc392a16fe60a9899bb99ecd9a6eead6510a7e452fc00fe31a78b66d6374a940c59f68668f910e3668a14eca239a18521b8dc58871c42c230a2e989b10e9c7b513696c813fa88baec4f48021326dbae1ca534b240269d3ef55312e3af56c0e4b82b1b4f7c7ffc976aec1f4db5dac3b1b16f01b664a8ad4796b8be0ca847990be465b7650f1b6d45401b23916bef89f7c71f994d2cb9c4fed92252aa16591e061f746c8625bfcc45750190dec0e1faabbcd44a9af26ac2e4530aa997336de5296e36246192754e89df22be2bb9a7bc982bad81a8d62c17953ab29e9155c4022b05eeb6ea201d4d58b6ebdecdbf6fbf23c505727ea7c854877d713c4bd5325f907b4c2e908ec931dee818dc94df389d163f536d2ed810cdda9ea3892db5807b4ac7b8f9aa640f48b4f434399f5c431b75dee7d3fd814099bbb93e0d42b3d1ee2093b462e60009061f2777a81f5f2b4abd02cda67c32b45dc11029b5d9347574bd47cb52a895d29be9faa0e28be1f13dd13a17fc7f0da4d65576a0a986b87bbe4c46e550d6469188779376cefa1847ed5622e561987d0bd4e9eb84e221c948be6ca0731dbd7977b481eff3105057ab5834885e8a2d9b829e7dbdefee4a93cc384986ca3740a79107cd4d3c77336b483cbcac36dbb6fdcfccffe25b386ed21a2c682ea6b88071412c78fc63083ed081c550d47f71653e8da598b9b70f603f5bbb3530e6bdba904e36d15312a0fc41bccd3eec98575ad9252d58ab1a25bc6e470a4a2089db5856790bb53e96d6b9798a4f1577980d0d65d50e3065bc39b642d2824f44b1a5febaa0fcf526cfd3b92f2f3638871fcb91e0e121c1095e07b7347dd103e215294a4b72fea6b254ba4ae55e6d713fac2d06f3baded485d1f7ffb0d99fc2f3349fa840a872f3e1b51c08326155fb7bcdabb7e8644bed2aae000fd11b35acfa0bde33244bc231f473dd29b3ad8bfbe6362e43ec4b3a9d69a6602b31fea4d618d91a852a58ce8a0f5940c39491e73cd2733fd857bf5035a9c1c15ed1bbbbc9b66f259ce08da6eeb78e46e209a3cbc1e526d526660589f852e0c7ef07512f0bd45019286da4ca97c241ca4de28e8018009c7ce57663254a5b6f399585a600c58cd578cbcd21194fae048e79a24fba02cfdd70610edeb718f234848b3a7184afdfa628db8b61470d744e1adc0c722c41ae5d98b7cdf297cb3ba6ac72ac8e81a49dafcc9564d9e56a5b2df42e4d74244b7a5300485cf97891a7271b3e9d1a109b2f77af5c70318311144973767981376f0e97083e8e4a6f7f8f1e5de78077f93aadc02ddffa7f623d6f1e38e9f29acac3c915155e41e66f46e59e221566582b6bbbc0a5a6d013f7c112f6c95feecd0c9c8a2db28c79972e5ca24bcfde44c1d4764126bc2e806ebab1293506fcb1dc5916d6294b4bd50c91696ccdca59baffe62191c3b719be5f106a5867069172f67b94e8026192c2eb6c6921b79cf4841f5c252d554082e9616ebd066be044327ec23529fd3a7b6a5bca0e10dab5a3ca02c7a49c24d4f1cd0cdb6baae93109f265cbd39132cbca69f2d131d1a3f08948c5552a108796753922601e958e41fd36cbfc8f90194437836f71a22aa62626e9e1b02a481fba15d42f17da2ea03a48b4cbcead7b810b3120221c680bacc42a664acfad6f9edfcf6c8356803ae218c77938edc47a2ea5e1213c78883d05408591b7910e83fc53d6f7893287088875be6ad5c3e1f9f13d8950f67f0531817c1aa0d57ebef01d096b556c24cb599efcf0c6d42c0d3b62cccb0cc210b54fe9c52fec8a0e972f6ffd7e05503aaff4d9cd84ce390dbbb7b4e3889b22bef3a424aa4365c331b7a2ea4778ad72eb5af6c8daa07ede3de7ede4da665b0192e718f38da872cdaae7780abb8c969b369dcb4c54228780090cf3cbc198075bde6fe04844ec2e5bf578b47b9d4b0f72533d8085d741c4def94c15f913f4a5aef4e0fa0b989406cdc8ff45f7bd071b81303f106a73cb55181f9bafd90082ce1f5d5c99cf08a57fae71af3960042ce3ed5e6297a3318b74ae4859f57fc1b8644aaf0478e7f4f43d464bb3c2c2f9f12af0b7ff7c47d9c8aacf071dae0dbcf6c5f5766136696d0d92a06c2a390db09613b30e25c47842d8307e4e8b00e83dc9e6d14e18514abcaa3688841cd2a6cd2612da15ed8fd0914114837ad2dfc176d4ff0a027645e5630b17c1e938c25c331a8be7e3e3f2108a0f5caffdd2eb3cecf3733bd9471788841741f7e8e3b2e36ded381895d6f888f0bd0c033d85974c5112b01e83088256065109a8fc3887bea477a9099fc7fd125b104d6fe1dd9e82e1c7af0e28719c4f6f2e41751859af546a05f08a1bc64d142b6398d9fbb3b360321a68e5b18bd6f7195bbfb24b4f17ac0694cf4c4107005ce5a6ba19f376253f7b7827e8c213508fb9d7ad0ce5be4b4ec3af38df619780c0b86d773d5c920a94992795acb305b4cc1cc78612ab330bbf57475dbd1cd1202324bbfe8a3a5c4eb7b34f119901c6e8782902db8668c37c6519a948477d45ac2445873ed2c4f615c917953ca8c3b7ba92c562e6700efed7e993c863780b7dcb6a2c02619f9e73189722a91fd95d30f52ee913113649a13206d192f5898f0a10a18f53e3478657a454ad06abd3b26b5dfbf4e105aeb616ee2c94d3347294f7859fa312ce4116b75b268eba1bee74082d221f62b61b55b338b62cbe928f3dd5296e1d66c34fe329d9325426b56f62c1e5e0e219524ed6af2c0bb436b5d4b7be2bcdd1fa2c170563a97ce4e5121191d6f878c24c85c1945004a51c9b78800c7b32de165159252695514d90316c7a1bc6ebfa11a01e082e44316179e9136c685af6b3ca265007b534cd3d6a01b29e063b690f94e3b7726d6e73baa9848a4287bd6db45ed59f69af83d5c75e851906869da36f26db59c5ec9b61b9b04ba643e60e4b56c9b1522b8b6748bc08efa8f9356bd52b087594889c2ca09b3c737a7a76e89ad91dd01adeb846c631a8265de4b5338308a05538514f30098d34","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
