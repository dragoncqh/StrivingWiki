<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"df6c8db613c73e13194c8f90ac34674b5745fe1a67d45a8cbae7dfedafcc8bbd98a6650233a8990bd2d0fa0bc57e4de54a0c737f120cf3bc28f95a319171d7782378c2241f65c222ebf27a91d68dc31e8a697efbd6e2251f6c690e3a3e17183a8b7f2ddbee98084c1e4c1f4e19b2f61eaf6262d4cd264cac7362365b681b419685e29fe5b8c745a5b3f20b46f1d1b03b38ccec4684d3827c756005d47d7747e6cc49c832213e642af3d80997482dcd4ab339aba5c35b97e06bcf7b1e0e787d827d0d5fa54d0ac7b98b67c7896c622dc212885966d78a7d173763747cd9673ba0b7b4b4b1d8bb38307f27ab5127c4b807c110910c580dd1d45f2ef269dcd9a885d494933c147fc14568e976a1465b7237bdb49aceca3b561c94e1a660d7faa79a1a6deb5cd87a37ca64824b8126867b3978e074752bcf2e074a65b91c89da7b3dc34478a82c1f0c87bf8aed88473049b63ee556d33c713e907571412ac03ebbd8d4030b20732c5d3477001057cd9a88002f4f13ad5c06445cbfed2d5b88ee54fc3d78654c91f7a6b8e5bc2ca9ebebed01f119406df2e8d3ec1d0e4f478febab7637268de57dd607718c510e2402c1269a1be47e3d515c31bc204c573f4a8a92e5d06323b03fafc3aa94703d605f11ec03c26b19151968f7bf07e33f422f71fff03de6bda9bbaec3b86e3bd1c0c45a35a3c0217e46991313a1bda81f500ac33d1efcb83696257e1f81050cd129ab52a251ee78cd4bb871200910035776fd783815b7ef95c68605a6992605d1b24c8293eff656371a6ea6fe538284d1fb9d50bd278306ef671ebe39c397cdf10813384ae930764ba8da638f7c7afc9748c890fc7594c461c942a1f2a7d9547ab4fecc7cbc349f3ace378cda5dbdefbc75db69c0ddb7953282d7527519a52536d1fefce9ea5fc801b5fa855fded548f3757daed0e0e42680ef3e932ee43d450fb66eadb4772ca72316f17acb2bf89a94f7aba37b1510a768f3ed1acbfc1160cc5518e93d5b0734bf4a526cde024f1d569a6fccea9684e4efc71cbd4d106c94b8da9fd43a2feebba1e4983d91c56e9b1e24259c18048b43856507df7293b6a0b8d10247afcd794f2d7bc66b36cdc4bdec46edcc4f0bcba451a182402d7d9bc8963e75c70614036c1bad2b70b3e99e1960ced56a7028dd09da6241d9117caa8c8747d2be147c9901bade2ce8181afe26b260b4a2f3097d48bd9cad6697e18837d5f9dd2e98335b5f7cc2fbe3b4b69633cbacce703faedddefb26e4169dc199e63cafbb761a5ac1dd6816912b7f494e077f8ab978af9cd8ea6c39a07fc2c9b02febde972722c89e1db30452dbf8cd5a7b2cd89a2cbb3b5baf8591d9d0bcec3cb09840eae974c65a8854b0dc8d067a9c5add69201ae95b3f8e86869c4d30d17b4464293da6c1145556c5480014a0073b262d999530f9866b86937474f31302556adb9e2fe8d9c9a4e719faa803179261067ab0cc85c56602d6a332247ee1092dabb699eba1ed799a3d20391aae3c75bb6ddd3e716d58fb447d254cf2b75d48daed70172232c4f90b67a860e2b960fa01b3dd8969407549e630b6b8d5e8dcaceec6029429714785d27822a1f0ce81dcc4126414e9955bd6ed09b15f408ac666aa4a3da8d369943162f9161f77ef30bc45ccd23b94ddf8016a106872098196c2337a900d56be77daca656303d1b60194a0335bde670868b5738a1c387e289616964e0e64b9e6d86b43cfc310699277f44463a7db804c11fe48f355d2411119b7d28670d24c814789c22b2abc7804c24399d581831b7b7dafbe818b1f0bdd780afd3ebce2e9f83ebdac0de238b679a933e4c3c33bdc8f8edad0f201550baf4ae017f6dd5394fc2dcacc7daa04e116a0a0d714794eaaf1dd7497bef779734817fd1fe6a1590df5892b1bb886337330bdaea2d52cbd41495014ea1b5ebc5abeefa68ea2147479b157f92bdd82f3e341ea36448f8a9bf0815b5ffac5277f484b2dd3dd1f954b4bc987bec8b4d090883418344c7186ef63dafa74cf7d8daebf13c63da0e1e6ac9457f5b48772fa0b20c1851c997ac2eba1694e8412973466dde0899ceeb640e21c4f1e4e9f4100a1e8f3a3a4e5f75b1bd37fe94f3b7d3e9125f97da9f50261e4e0b5057c1d599c58e49cf2f62c01607a9a557801aed160c9efceabee395cf3bf2066a516be58394b64b0529223a80c241fcae8f89c0996aac77afb4392d06315dfd116a5ada4f70c552f5ceb44fa42bb3ab9f429bf277357ba6e8009fcdf31014ea72c0b52ecf190c545b7af307ca9f000ad486fe09e8d15755091d33047da1dbe525a3df61d2f3702058a020a6d91302f6179b313beb664b09565148d58a6dc885b8dcabe8f0f4da69b7d577b079b1fb30ab748a8fba68b3ad9f52f736ee896b01f4f68f7a24a62038098124d2b9577bc948b6f0489d18c826c9837437e05e3bb2bc70ffcf93f9a46da3403a828a6f62e7d3384134aba3b51e42f2bc9248bfc0556fe6cf2b8f4382838d0b99d5f11c3ac1cde3b80c8a4ffbc62bea1d41eb1c9115f2cff1d3d43c12535ef020a11aead5be331d78f786c913c507ce3169cae536a33592c9d371f9fcf307327dd3fea59843c5901a54286055f039d898fa6c5ef6f4d7564652c3de9a9ac6e2634aeed955ef27026d55db0aae131a64af393c6d190818dca3b57ca05535c9c75c1970fffbd435028a3148967d37c87d21af0939772530170db763035c1bb99ffe1a1e15146157ec18b291b6c79103a5653dd5c6460ed3fc5ac806541530d7fc4f42de35381c94f8b0112d90f1201073de747f0cbf22ab3991136ff18db909a1e7b6f428ba4f70a4a705f4778df2d1a7693150306fd646a26caaf7cc5124ff46ab83c946de987ef5034d78a75039bedcb085b7e367434972dbc104579a99cf323743d88ee08178604a386e6b27150f71195c10aede17ea3e84948f31b7d19bac84a08b80e7900e4a1a82a18da302a413eb5832e68de5d740fa84061386ad8041fcaa0552e14feea342e511ecf65e0ffde9136472c3f527db628ff5b0406eaa540659720551e8df997e8cf3ecd1b78dd64336ae5cfe91d3353b2e949c5b7c4d39f9c4118e640de5dc047d9a94039269f7a7ab4d1bdb419eb2defc4111b9ab96357a050f1fc5359de5b48c075b52d8443e44677c1a1c03a58be95bd62f707c2e89b0828c5e8c7a1863bd2720ea82ee2d1f35790ff9216a8745cd951cb738f7b7a483c325c1849561f5d72559132cd9685e28250fb25f0f9fafb75ae5122fc12799c26711057c170c29d4bddad00c11285b91c4023d7d554ca932ac63272eebc01bb9637ca806ba86f0409858b04c5dee947c03679cd20d461e3eaf6c3b84fbe746067d0a337d523c39fb5b3f5af6a9a6d155ca10d912d9089e7761da6f1d3e6f413e706989018467ccfc95ad370fa6906f1b258a1a99a033c23f87419c53c221f98227d165404b736d177456c7f09e926a96a6a4bf23f2b875127e1fcef3379ff4be03454b0b0ba354376653b6e623e675fc10ea9578b94f525f1d8ddfe16ffc4224990bda01740b6bcb9f6cfd7cd482537a70dc36d14250d398fb0a87133154cd3f40a521a848cf1aa7851de6b7b7dcdfbf2ba99c3ceb3b9467be6f1eb6f811033542e6ae6a39b41d01b65b78619f9171d535f4e9463bd7b8b2d3e728cddea91ff41275b2786540b0aca1264aeb046c9b48b23d4981017dc94e13235259fa524a0fd79ad8194235c8930ff3f5639255f542b97db196761983cbe389a0d2d95070ab26f5dcfbe88ad080698c8bec627de50ee9f5cdf8bc3c86134f194427f604cd8eca6b1b59c3c318fdece140a70004d42ebf34146a94d9aa6207fa20575576f3cbb5de1f02c793a419fab9066b45b8a1a1d43c4bc465111d89e73c06d1feec5dfbe356b807d5fd45aa8c54e1ee9158f19a5740072f0012dfbdb8bb79e56b817085faee33feee58f785add78914577c0ebe67a7b2cbd255fd18c7cb54ebec844df4ea0bc4da8ba38e175b1ed4fc286d5c3959dbba501f60406640f45d8080a1f1608fd45e0e9ba6b9b901725a86500ab60a7d91f7c83991354fbce9edadba723b92f214d61d0cb5c98df7a4e4d07ada3f78a664fbbd3653fc4d545864eab88810ef9fe3f968381c70c7be1089501ae86c1a438f309921671462efb01c4943021b83e91dd8dc64dc80b4506ceefa37635c66e0b23c43913ff05c1b340a234bb8e2948fff3fe8dda34d9f53222111bae7ef1195603e8cf328cc51f39203caa6d20fb0d76f8f47e3f9f728e7e257bfd46c87e846515db55522bcc5e024fefe99bee6d98b3bff74fd555dabb6aa2f06ea0efe6a886b485eb033e91d931dfd1c582b752624b830ec8e2b66ebf3f438f57d9c5b424103bdad7ea1b45d1490fb1dcb55c19d006b029d09774d2b602904eeef9905b930f1b2c9f30a8d6d781623b1ce72195bf57b621580a95c5b2a8df59531156407ad623d9f5d521a72d716174d9660b3e99306ef3f2b2db896ce42f6caf27303f72200bfea921f41485d595cc4085351321e2e34f19de402cd54216a8cb5dc60658057fd6aa3389a788fa6e56687e7a7b3c3cd198645ceb65d8a415b0822ec81ce4c8c1e804ef653cdad11a5ac005047632e02de618e3fdca011da94bfbfadc45f5f622006c52a5e7a27c0b836956385b889abdbfcdcf5fc0fd9d97c12beb9c38ad2b24c3d7407e718c797ba06f74f693c85be0b6c2f52e99b13ada5fcd65f8e3dffc11c4ea9dc40e6fae90d2261ad409dd4d4005f5f137dc11e546b079cafa5a6caa9f8022e4a28fb0c6a2b39f4c2f3b2e65637fe1e24a9db9212362d8f26198134d8032784b8d044861a1191562a527e04974a0f730694aaa5e815f28dec6e6712d172b5b907727efc20f14fa21bb49d096381322a0bc0e08d4cf6552107bf7aa57429df8edafc65546494c93ad8a91cd8ce1c3208cf13f1adbd789e1a021ff4b98e9ef0fa70c088b579561c106c7ac59508624ed81125c14ea8563b4a40b7bd4452df69892475f3a7ed1cfadb60a842e2b34574c8ed2e7828833ff0a9b509990ef41472375bb199e9dc4e3900a5194b55d9aa4448fc7d5a69424ada17debd641738723663a636f8965c99bfb3e25d2246e6078f0fe30fd62e480da8e139394e0388b45e84d56a91e5d1a89447a12f49583091c97d7a2516d207263e4575f5b93a90072e01efd7185bed9a7b63831ee29fc54c7d86e2e4308f660474e737e18a2d7a2262907c7e6cf376b587b9f35f2dbed21f91c5575e5ee37b42d19da7a7e58ea8b46e21b3db7cae4efa9993a238d4d8278decda855530713c2a9bc98ff2439ec089860bf3c3c3c2a0a31dd43a4d13e6f970cef0cf3ceca23be9ae8de253917bddf53c51a104ab3438fcb2eeb0a8ed65edee8246ebc52b46ff6341a7017d3bdd61d405cf80885ccc70e17fe9e714bb7ef1fd882440e88ec40e8fbda555f574baca672ea99f22560a3fde6029ab09e437b6da1af05d61cf63721929c5cb70c77f9733da897b1059e8aaabd6c3d045858bcc458081227b1e08678119d144ecb307617eec4205a49e7a06527bf8e2bc79879bbf95a43ccc09c0dc07824f5122ee9c04f1074288004ed37df1652fd2af0a31a9c68299a00cf73ff69805349ab949765b411684cd024ebcff47a5d118a97c054d823590475be33f3e993d5590f6814d36d7f90d577820a9e9bf303226e012e049674c044545368a8eab7a7897ae10e73d138184a64a71a8c026b4dddb5df0607cf2d44e808b853c866b5da6ec7ebaa9df7468a2e20162bc156554eec029bb5c625c7e06faf5f26fe5abc2bea30a710e376520aa93ce76b3aa48b7b067b913d943140820c4df1783c345314f6ef7d89a612ff6a09626413a30b0b116500a41fdced485bc29d2453eebfdedc4093d1f515cf5b1c9181d5b74ab5f0e3de58b4e5b19823f338e7e21f6be85e77539e60ead1b3d5dbc51b57a0708c761683ff5363f5fc9bb14d7de3bcca4616fbf0fcc16907d135a305757820f6af05700ae924ffd437a15a74d5dc3d830f5b5d57cc9d672fc4a9d029add2b13805d2ff857e9ae87451434ead622c4f05c6d566742e69a493929de994ca81b275cead2f98ec6ac6d2f24d3de923c0c5287419f6cf17c84501cae37bf6987fe7635e4e1a80595835c115ab5057e876818e8315212269d76c688ace04968489cf4db3664f9366e1791df2567cd5bfc521e7e154369f10798211bba769bd41f07e1af8f0c238bb46c4bbca8f1d018af6cc536c9d5504b77dd7284b20fa3a0881ccf0b5305c779d8478ab2985c18fcd5de74dc0d7fcc44b4facc3108e789582c8448941f9db396e59609e788d707abb66df0602e743f5b9611b647c387d3d57bfa84b392e9bd42299611af52b8c463855bd9089e82a546841abba1d82d7bc028f93ce4ed4bee5f0454e8ae64d3348f6ea2da4512d57171a0f44f20d09184b2f1e267332e78ae60cf96605331a03b90995536bb1f61c66ed1a2e2ecb00b6cc13934177af411538c02eaaf48bbdbf439b79664544cc1ddbc6b8b306dc89b5fd3e9be1b244bcff21ad398481a8c2712ceda17ce21b3baa69a6010d69e731eb22af8a9636c04d37834a8f159c154dd140307e926d027eb6e4fbb707d031513b90b79b083ab30b2e882a7b76b6a6f255157936e9097731c800e71f447d4567994b245935d80d6a970da59385de78d5e65c1b38e4ceea7756cac5b5e3827542c624fd9ebffb4163501486e65801e64b8c4d52249b3e2eeeeb08a515fe7740ff45a37d3f7033dccfd732f3fcc19e1303b808e7e395060f0c3866cc5460a721121ca6671e3d05cbf48f1366432332586330c18f5b76880a5ec73d1ea6668837e166160aa5423f737b529316e9b3894f01b90275dbaa531500dc971aaf69fd2df088d83c050457317f9236ff4d75e7b9b7a85b2618aaed51f13c002463c83ed9246d155e1b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
