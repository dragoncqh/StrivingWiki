<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"92ed742b6a1c64da70da35b2bba38f180f34098b29febd2c3983476290e9cfc236ef18e9616ebc2575f0164b59b1e950469ce089983c093bf52d619e08623e896d4c426cfbb3ed12419f0832e87f0934e7e81ca3004ba4738c21af4b6e3fafa4f7b9e423979144ca836ad10caebff424c072f356a346a786eea7bdcad6fa56b925fe02b110b0855a543a6615cef9667a569e166c2ff6044ba7b6e61cac80319977c5e1a5a6048adbb2f879d2e3d0cffa30234fb6936e6d5b1cd3a4eb0c7dd5efc82a7e86cde38b06eaaf932335ab86c8935f0ef9f89f14721b7b7688a45aec09f30aed4f70158ed27af4bbdef2001a8eb5c8d0e785025eb2fc7e531c5b0653e4f19a70269d09dfa1226f4e7c6aa2fdad24a2d589b3a1a2a8be557d8276beb0ac8154b2d96ecb45ea1a9d26837a952c8f2f59e3d9d68eaa7b10e3079094df13cfc15f9dbca17c6b13a6a33ccf45105aff700bf57718bf8eaed87412bdf4cfd50c61959036c9f1d5af026b902addaf60aca16973e122ecdd5a0b0dc49282cc6c1d6b7e616ef47bb33a32b32c2b6d78e0c59af0921bd710f76f9eda79ff6786c0ba2b4a67dc1cb70ff036d0b969e02f51a8d6f748fd0786d5b816e07c9e07bd66ab59efcd21538418e7f30be2b76411b9e393e454dbc2d1e09b878c99a8ae892feac2daf4bd715c57fa60a61375c926c2ef01e2a4e7bfcb08c6eb2731b4600c398f1d1b924b6d4c456c1b8ea4c60fc0e530f12856389ff2a753f51ec04bc8d04b0479328bd0de357d0efa3c671792fe2ed3f059136aca2fea1f36dac7f3b1ccfcf24217cbaa4b521a56f7240477fead5f09a191af97dec60d49e140ea513cd6abd95896aa47ac5900fcc884bc7281bd5c4b0d1c72d7eb352b28c8c8301f75c10a0a37970ede529e25e723f54c08442c884236302c91a4258436ecc3868876b0ffb0f91ae3194422c358c41eb614589a35bfc774bc58a3af9691327cf27e84e318f29b44a6034bdf9fd6a4b1db802a572e95cfde1fb172ebf51276519ad70187e572ff3f58d461cf76f5107adf933a93320ed43e028920220df450ba845702ccac9a74ba1ad7d60a390d2b15d9d1d8972962928c6a1567ccf7c6fe3bb4a843a35dab3fd0048cc44900c6da1d023a0ae59884a8660042e66387a979c8907696e8eda766868a573b7f515fa578bd203976aa9489e5c8f5174c7a8b028fc3aa27861c1ce9cab021fe5de84ce541dd9cbac9473ac92e1e273c38fa621e14a55cd90c7b41765222a079009f735adfb65c4db7e1a8932a84a66bc98ee6782694d3d2d1f4e12c40feb43747f648474f445b40e7ecc88e75b315678ac0dd81c6e2dcb6b4cd9bffbc8d20ceffbfdd1f854550799b167ab60b446e1d1540d2b40dc9fcf7cadbd727ec00954c4bb8707a7e53beac9108e07d195a96fcbd11ed7dabc45cea251c2bc5bab42e7b73fcecf82e65ab54588330283d2dd7df94635e82dc095022e4977ae1bde41b1963bb34a668b7743fb104cab3a10fcb90092c44a7990d993d9107ef817d5717abd010f6825b5db0b9e56ce88f6f83c30d6c2ac9194dc148a72d91d1cf293ce50446da16195cb11632f2f6ad30af25e005e65faa9041e2c9e9408942f66a062219617c5c122c48a94c83c2f2471bc03992f5e57099bad7d832c5c5df5d45189bcd046fdff269c6ecae3adab1c584b6e0a97ebe5f104bdfae2fe3cc56afe0778986bb681e748fa390eac7913877079797dbc36d25185882ccdf2a1f1781d335430540c69f42d5f3fec944dca52a1388694dc861e5d2572b494463b840bf25a207430531060badfbf7ab74356d66e62e4a272968e054930554e5ab14e1bc06a34b6a995867e06c1f9263d168e0b4b922c73de861e32e989f0c3332ff79e553281cc6477ba8eec9bb81eaff60dc1ddb500571ee3f90dea669de2ad27aca3f8210e2cf2e400bbdeb77fbf848214d420509a78206d7c6b87f5241a74afc0fff2dcbb78bdd36747cde722f63814538ce26140db2dff5d70b72b30b99428ba784cedaa27e16c33723711eddae9944f0d4ececd8a68cd75e61f18d34b6b3b27706d86603d9f0b8300ddf26822fea84334191c5487785f5c787ee80b3c0968fb3660fb4195ac9e1f459e644ef81c8079c4e44cd93a80fce5cc3fc34a66edf089856d652e8dbc4cd42e14013d16c9053c0e222797b7dc6da8f54da645ed84dffb8bd3644b77234acaeb51538be72897f094564d088a09bf7e16b02ee814a9e5e94f41f78047db93869b30481a3c7252fee1f314ef2562f00d74b880be2d36a1169907a156f88bad093ffd71e917409986268459cd9da8e225c7bac99836419884dc5fd0dc50a7d686d4396de6329745a62cdfb6678fa22dc5a920803d8f3bf1afb2586a8e838d8b1c595328135eac1e72f7f08f871e315d00429ec8df73e75e2946f39fe614ced4609ddadb9721dbb194062bade5debc183d1d16adeef55d04bcdc9221b9c61a5169d7ab602fdefc43e8666176435a8bb1b316c3f7a316adbcb443701336e8b69e59b6bf9777bf9fa50b214fe14aab7a39a26995a39687f54a775eeebef794d1a2e360755d59fb8ff6b7d569c3914f9ef992fc72ae1d9c7087af570dab88571c5097e4597494f6c3fc890ab9f8fe57357cbaa95b8b645ab6cc375af8afd6a0edee71b139b17e7682a675e3e3a8b625dfd51cec30d18d1204bac7c4c252b71fb76eda71e5e6e1e91703cda8b9fa8d15ac8d5a2c9e74e7ee80af3795f22952b30a04139ae03e8d2200e1059593f68cb5be310aff5fffefcfde668c33e91d9eca00b989d92b8dfbf9f9caad441dc0c338c8398d87d212eba40b702ea47247e07711d9b9bc8e3e568fbc7ada56ec08a785ee60db980137dd4a88bb9291a6d3bf7a692d40416ade4cf0a3deba18b4c2b0e40ba5f452aed47d3d268d6d6070d6e2d28d5a6d01cb0b7a9a9c3878c98cc28979c496a207cd8ddc5acc80e59ad396a8de9569c41a995fc4f9e140ba7588407fae00c11a217158b52cea97927edc0845dc4cbc82c995a831e8c4c3263aac22bcad1caef4588734dd7e59fbf83d6c7d404b34b6ef2fbe23b14562b21869d829ed6d65e4f42b2505767eb56bfec299e3fea0bcec9798c0a7a3e2dd3f22dae54230b17373ce74b75eab42eee282c1d2fad97ef8599f2173337147b10eb7cd3b0b02917f1bed782cb943ff3e00e5675228b3a5addcf52ca29442452ceb28ce75789a42d4acd9cc834c061ced728bb471e2f5e156857effded5ee31e800280d7b6f8ec922bb4d64e25f0daaecd47598af1991f5125eb0c8bd7fed3c1f7323d40a0661ae30f95446f856683786220c6ff6d6b2241402c9b3058778949544adc0ac0a5540e3b41e410435348795b4d82957714b3ebf4de78103c69b830e23fc3982aa8c99314352fc930dbb4b2bff41aeeb18aee78cb795160b226ef4a6d6c61bbf47274c450cc10d127f624676e5231b3c3474b37df5e29e2e73603b1645fdec6e122e56b30ecbf1d1ff966aeee5d361dd0f896e6c1c24c5c444900c71c19aee86b383cc2ecc674a276924de355550d40053a547e44b9e86d5418c8a00dd502a4b670b81a03181c973c47f6cde8e9d926cdbfca766a307ed65fb89279bd4878b695f369c7bd31c675039ef06de9b467b55a337d09b349b6a3f81c0e9f269b9a50fda829bec50f4da0a90fb1eb7959bf1e1808f85d65e10fac53c4ec0e05c22ffa2ec0988ee85fca89f9006271ca893925d16e8af0eb4883a89d89cf6f2aefb6a542eb2c609b30361f49e0b0472a13bc059d3fbad56bae3b394b00bba0037038d67556d7992003f7cee2ea530dc2073e167c55ba74bbd26d2a0f312208303149833020db861d526eea8972e04194f65b14d309b5b542ceb72509e67c20a7a9bfaf7b18536f6ace3e7d5d6eb2f0ec7060a58b1a2e53bce1371b06f50c9fbd2b93b2d3c86c949062cd828c43e5833a8475b7b99d12cd8c44be8782fcb5b154dd22d1dbd94fafd2d95d3f4c952489b500ee14c7d90b43ecd22f2018bd0e9492eb437e146cd65b2a4134ad27eaa41c1a2697d26cba01064563feb501608e6b471bf6da9fc1aa8a6f67b6de481924076a8fcbb740f1fb5201e67ff1c213f2dcf4a9680a3d6c5b2762f68f98569149c86accaac396e1c7c786a5a7a8a676584218ffe327628886199d56fdd5b0512e39c4b2438799db1e20f63e5c522d0dde557b58e5f194066da6090772934718dbc217f31d7af7631b7715c3fd8a476893c2e7b8bd8e2e10b4abe4a574cd6fa2948a036e96b5bf9c4e81f287e56d944867da7ffc4e87fc7e46ab35b4a78cb8c2eeafddff44f9eccf516fe48ca0cfad156e5db4a361328359b222a4721502cdb68bde277666e0d436bd95777319665621b5cfde4f9690dca07c3711eb1d69440ef3d7b820b6ee07b450f407b9e5f97dedbb95063b31025e922da88ff72c1a5d19f5095269e6b61acf501f5b84f9f77028f66b4b9445fa2cbe8c8046526fa637356d656caab3f3ac69889dd5c721810be59e06cd1ab53a5d9c78a730915f39fd4918d9d7fd5bb98536d17cbf395eaa2459b236cd905c9a50c6d60bac1a0cdc084a9dfcc0690567b612437654fc200ec3fbc96c67ed97580b6d9ee193738861b52e82e6545e75a4c8add9c2635c5da03dc5af4000897a92cf70eccfeea34bfe8326bc4ff9f880686dd022270e6c72862f194ddb41ff6f62f7f513a92c02424cc54d2cd82590a253f6249c795786f34905a7517636fa1c259141d631928f9405ace5da6dc15546ce881bc4a5dea7c46ab5c27eb0b1d038c1e8b28648cbeb8147c7757d7a4d8136c6d37a188048d39265eaedb5ff5d1ef9c60682d5a2d20d9c1778c8c95d88fd217d4e5bd8c0fdddb7207eaab234e790e42d973cb632d41902880a9391fc7f4413e65d7a7f098fab7f184e155cf033cc0dcc6a2c1dc7dee2dd94dfa4e5f671434a06585e6db0869271645b9968a9edd3058201fa0c5659cfd2c3b4811efffc8e445fb16c294d04bae965b564037e51e078b2b5a578739164f8e9aaae63fece59a72399d58784abdf8b5622ae77165b133207dbf281c40b157574b2c6a0edbf608614420ccc42dd9f482aa4c5cdb79c9e1359cc92f6ebb90a86c3f28ccd673a7e35110ad021d38b9ef877a5be677be3a1adf9fbaec55335d82b5cc0726b6b62b927b7011d5bacbce704044d8f622e9077c851bac6d2023c88c3f7f965de3bd154677370b60a6600bda6581f4d039dfc61fe31ce7138a71910b292dc4781a3c3e7aa1f70ca18ad42fa68873f462113de6e5c59c1f82344a3e829c0fe27911c2243727a0aeab20c3e2aeae45ff6dfa8dcc6ee87f4d64fb0d716f18aad38fd75bdac7610c397da2b4ff1eee1ae2655f04faa02679bd1d13470f3ac8492c7626e543a6920c00b852f4d76241cdf00e16a1ff160138a65ac3101b92bec9dc8e0ce46fe008fe801627f711bd69fa7d0c018ae7f5b787f7dab40648d021d5611a94c7fee6735a7ab6538d58133cfee2764dc8483c79dad6797a6b5335fb496a4e620397b39ccf82445fc7cf6057c872bcfc35a9918bcfd978ef2806bddfedb2311e9898c1bc827c5661ace92623b258090c64a54c5fad54a0a34bf5816b4e8ca7764666bb4cb0caa612ac759b733daeb8778cf0a78f94ad16f73ed63e3463b67f16ed0e0e2975499958a900093bad7ba841340854692974f8c1400f7447177575091e01a02c3eac48517f3207347202a88f35b24fb4e2733b99e84a00eee0f6b1ec201322adcbfc335473a5fa78cb01bbc315acd29d328768b76dc2ce8be7ca40eb95e7a6d127ad1229d0765a50772e23571868c756b3d6cee07006cca4e69450fdec5b7f8606f12a1f7fb0a5341d31037e287b97f1113a4e2a6c6135ad6bb98ce8ef7b5636f8a920e553dade7032492720a1ef5381ac4f26be07cfd21fca9fe753541ffc064e7eac816603fc84e7570c973d3b6216756750a07108d9a19b240523a0a306285ea23cc80c4bcf91eb4d7ac5b748ca1dea95f2d8ba8f29e713063145274f71304aed5d86253f1db548f4c2fb0df43e3710692500bae2612fa755f09ac8e49e3bb0f9a44f79902437b15880d710f833edabcc47f6e7e0e9e4bc5a22e573d07060d2a883eba7098b46e4aee8baf27b19856b9d070a04f859204abac73087b680425ffefa5f770590f37afc0927eb963d744f326a4822f117a1eb4b4535f7d74ae917bc4dc713dd6d2759cee4f5b73fe2f6f2d6962f2daf3423a7f584b14d0c5023b69c0cf2405033deba723fd429f380aab1d0222d1ec51a1103701c72d08a699825c741de16b0b56d2736abbfe1e8922c8f3d7e4fa1d4a0f90e12c6f03bfa8a840df7577fa395184bdfc00d653cab99ea636325fbff21af9d3aa5dbd79b5b992c79aeaa9078b33bb5d8f135ac69780f0c6642ffdd32e67c9a3943d026d34f1a339f7936c19caf11f42272d865dd139b332646dafc8fa1b788cac09f9d82e49dfcd566f1ce8d9279e84d449e38a678e6b1c08155baf6ce834415f0ad5da5105aea39b428dd06d8e114ca0af9fd3421babb5a0266fce249ace60094dda5b957216d7549cdffa5d8d93c58cdec5e2dc44f080a250e52562f8ffa0a30ea7e741ad19cd6f53a4ba32ba8ba9aa72e232bfa0a9474f468228816394d1fc8ccc565771ad2d8dd62618246da8d63138cd4da3f5347c9158e0b1983137622773c7627c76c03e36143be7a63b35787ea139666feb3ccfbdb38b6f9fb607e60f7f83877d321756f4affb533631902122c82bb21011d713b0404c3f4eef9d8fc2331b0e71bb9f21a1bee30a2939c414f412fc572d674ac54f8b0a7c9fa644afe0647e9a5976cd95fb131b73d29bb50cf0494927a14d97b80ca2d1ffa76d71ebbb9c0d124f5304cdd35d35b39cb0f6c74f684c0698f3864313c1541bed76f745ba4e6aa0d9b4596963ee046a87e3d198b980fae66e2e81a689248bd34da102b44088d70a42bb46cf65697d57fa25325337f51cb5a0ed4019d3d832b92647543eda5aa771c5ae6a556c67ed97df4a8f41ae5189cc594a6f075532a6e94bbc1357392f0e2ac3509013daa79d11c0dd3e816426f7c9676928a8dd2dd58697de653f6bcbfdecca346d17173eebd92407d0aae9838665357e4872438d228c59c6adb9ef398432d348b3502cbc7f5521f96ef76b11b78bee043f1428b25cf8db36ca0ba381f86105ad47c627aef383167e7594e57f1a8a9d7bfeeb062dae209b863db86b2ccfe2748e1863d00582ceb7f0e7ff242a1a4e0844b0456f79e9448d519e43088bf684ded78616fb64c58423985a56664b73bcedbcb7a0b94ae72a1bc81874c0df16ce6d2bdeb0efc3af0ea843feba81171524516f70fff4df1a1ae63917cdf1a7b615634bafe9beead4069e2db95264428d9f143628061432cf93fe0bcfa4b158be51d3e8d02333a8cde71283c1f880f0f9d34a81f6cbcde678a0a10cadd2908a0ce012253c37bb648e1626b2ae7c916afc2ca57ad6d84fed71f1045ebde14110ef171f3938ad64464b7989b6cb9db942c958e29f2f308299b04fa0adc97ffe8ba7745cb90f64f04b8a555370907e94996f9b5af2d3ef8d3c4c93bddb4ec624cbc8df460a225f98df40d4727ae42a7599cf8c362ab99fdf6c3d1d77a1b3d4eae2f1350ca4ebd10ec17a7501b62ec31b3e0684c1ce10ad5dc2cecc56005588ce09d9093f02dd865127c5319d842c7dbae6ed50d30cf213275fcfda49012f62d4aa575a8277ba3675cfd4faa9c2fbcc05b7f4f738aef04eaf2ed57d7aa0c9dfadbbcd827e702a65f35243853622becf41c04559f93395601913e4857cdff090e75dbbfcfb24dbc9647373e6040deccebef5891c92c650a2571ca8cc9502bed24cdf77b503d983cbaa5c6a6e28146c4db90c9a4e7eea4eac6a1813ac821dcd1f989c002a72df32eff792cbd368451b65bce50963751f5f63f0e571c7fbe97fabc6b5ba8ef77cec4b608ea5946d2148ef2992d620317ff3e043413d3e4d134a809282420d7b5466fbdfaf7efa720475432272c97fdf01e218b40e9faf26ac945aa55a46a46534d3fb3f19af1f240fdfe1c35c9bf68ce714f0e3d0b479bd09302a6dbc7851b1855b7cbb5bc27fa9403eda507fffcc1b2da3355258299d3da174ac3d5fc88fb77e45ebf721a092f5a60df6f5399cba1abeff361555b33e6c5f2878864c66fb6957190a14d21a50216a46a5fc5632bd8d846b4f21dccd2e74d94c59358e2bfe4706de903ab50ba0396b1bbe82989468b61238813723b430252e0ac15986eb91531d5d070a5f247b746a9b5651d0062937c739771dc4b98d885c51499e07bda2781478f3ff2e3eb2d5055f180996de2686d0e060855aaca5b0bb41c21a0f0c0b74ff2483ae4011b4786223d02ebf5036c3361d56d7f9fbcaeba56b24d7014bfa704b7fd9440cae3821440f885bbe984ce040383c3eea7799d33240b70bef10223d6fa8772cb75f7ba38af049d1cd6748b1decf595da8116d9050d7a0e0838054fb47446a818e242596f51303aa571a27d284b48b782ed6d08f30e76acd2a00ab133a85756a5877d1df25b17cbcd3be8b67973a3730b55285622348bb714299094a42e9c62beb4961a191045b2d7d04a08a78d5317eb1a502d6082e64b3c0f49cf819d70f2793cb3b7f1a5fd1aaec2c997013e05b99a8342a9bb5e1a1d3c1af1f2b1895a7fafb57fde0ce63c1d13ee95bfe4446c1cc64aafebe948a4fd8a79b43e642f3d52bf47d104173cbbe752b561a94f8877e97a57bc64a29674e3331eecc48e11882d1f313dacf7ff59f647c2719c9e34cd906b0565b31b3bbd8fb9f7686e3a543d3ae97263476d5ccb05efa28b7c760c82de5683e3342a61e45ada91ed48271b49245479101e2c738384818097cec581f1a239da2d8d002afc1daa31cac563628e1694ababa5bb154eca553d41696382a476b7573095a386e4bdf6e5c373ca040fb8af9d4b72875e7914d3cf2330ff388cc4e8913bbd276c63231a98a61bcad10d4fa6e945fb4997a4fda39421f1a1ff765a9e5f289b166d84af275745b6f73ff38984258e23b5f16bd354bf1acb38365c8527be62f859e8ac3e421d223d17542c7d9822a99f5f2884bcc7c5a7c7b13fd71a76e917594c38956c42573b242b433f4e91a9b3fc3295254281126070501e8589d0223fee1cad3e86a31d217c32c18","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
