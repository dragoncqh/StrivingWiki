<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9390b34dc068143b057f20aeddf19c4b5500649477468b4bbd7e4e7a938ab1a7f42e8164f08b8a56e6b42a31c751d64d8e1f1de2701bad770968c0f0e4540b1a8c12471ad5db65a5cf06d5ac1114651905a03512285b8c506630695d14368ed1c16ff249b8583551efb423b8ecbc85175500ef669fa953b090cb5e84a515ae019256353709fd45b90413f97d983e912ed9a2283393e28904deffdeb2ad5a4e1cc8adbad46c7cb9706076ea01cead9011692e62c058cf844299a03d9b16e81171a2d8ec6a5d7d36d25a0ed814741649a6a16a50b2df617001cf35b47654404a50322353bc3d5c0bb970670266df9ef8c444fabc8c7e4b76107940c84df9fbb32ac82412a694e969ea340d74671a9c549b0b7a8fb5975c666052a22b7eb64d03601736c83cb4913efc54e50f95dd8f89b2443867c5340f48c6caba1de6698efb15305cdbb4beddfe3b7bd402aa92b07eb2aba0ee335e4fb19ac530153c6fc806ff2c0163587d721c967e961f48b9d15b759a5bfdccb5e19d3a958a4f053bf7917141c8111cf6e39266fce0ae0c274715a150cea6781633de49d10db0624b8ab744f16c97993ffa006c87b587561e93deb70fec1187722fbce81186075a15017fdb1881b327cf7dabad46ee62055ae42bbb7c2516643990ae06b33821dad8bda6862bc8f01416ea56303392653f4eec4572b33685461305107aebcae14ce20a3df5927b65864454eb6c24cd2287bf86f53f876141ddadf5bc36dc4c13abb308fdb50ac9dbee5889704f8e193ee5e012c4b7128935ed9cc3232df6fb16bddd620edc29c894d827140a4abd47584c34f96dce9a2a622a4ba1fb1b8af5eaac84a9214ea88f78b79e2d02fac932fa65e7d54871ecb92b422f73ab9fb337c03be33efc941b4f333bb67c562a324f58c45c72d83ad156dca9f2e6c8538854b388024e3ec34c2314001636ee98a223e2fd639c5437419e7d3ddf62c3b5aa249fe090a641c0551a413d6bcaa14b040a2d1211a9721717008fa09762dc9fc5cd5052e71980f824ae5d886e74c92ea8792af0e4e7b641c212a1a0bb8a29d7a622377a3bf66c9a6e954df85792d8758a2419b6241a800843779bb7423140286013741f178e86ebf0006bedbd7b182c014ca8165c47849334fa029968e51421fdeb2e2f8e2ebd900614ec9678eb900367b9c82c0f66e022ea3035df79b468c841f57225c7bd993c200b9e6f9d3a027b8186600b72e24332c1b2d3bebf621746bbc4b31ecaf730b6e9dac5772d434fa8b0697d91bc561fc093d9f74dd048404d803a97eac8055593b2e71dbf60aadfe265eb41f8506ad5df5d434b5245540f44ed5181bc1b06abc9d6fd2ed8df4b75a112e3f682e1e0ee92edc81f082def5c82c9864359469591b7c760da3371a995311cbc7693e73e8e92c3118535ab9a3f42da64f6700dacb62d6d2a76d99e46129ba4138b9c0f631f40726b340b1d394f707597bca3c6d39f2321819451a257e8187590b2c9b60fbba9be77c5c398e29afa36eaa12f10563dc4553c7b6e8f1a8bb7fc08955ad15f9b6579c2251663f756b458a35427d16328dc3b1d063608cb3c2c718c111d4c04c3302dd3688bc3f15c79812aa396785dfc0d1ce00cac2f8dc3ddb9f7227fb2f49c45174e454f75031fa614cad47e2a5729c49f80c9480b126e6d51c1b2a0095e602f3294eb35edc343d9379f31566d892dba0bdc2c0653aafb752b60fb73f4556ec9a7b1e0199460f24d5f41ea1fe0c26bf18049786866a37b2a7b15a0d02ca56ecbaba5ed12cedcd4edb060acef225f946d2ca8f2805100f5f69d87492b193c3c44fde20720b242c5638718ebbabcd77dbe4a7dace01b6ff2ab26048ff08b0da9d6ae038b43e9586fd452cfd82759eef537a84f0b1c6a96b4788e59efdf1e4f188da6e0d07e5209171a8a2843e6ae459e605af12759e3f580922337cf4678145321fc3f17f3eb277e79eeb41036e30cddf4cbb8252477e5d16c21ef17cbb7911230888023c4d13b56315871244ae61d610e252a8238cf5f70b2c3e436cce71c42456bf8b2641bca7f0109d6f460fef37139f36efa6898e5cd0f4c33ca828378e88d1e6048008c685290a11e1853febcf26e333643f24b72a34c943bdadbc2d8318cbeece1aad601e7febd8a0413a6a8e16ed143e20875786b7abee76a29372abbf4038e499a8b4d287913eba93199a4255791fd9d2515553650151bf2ace4c2d5a708074bcefad4ba48ce531dc1ed7a35939400f705d6a68f0d990801e12094103e976fba896b2efd2d9df9bf75b6e6ca3fc52eec727c38120f81563e2e704354539c54048e57092f88a8463c5bdd7fd65109d65449af4e69fd2f806a2e9dad6920314ef5238b7fc9b5ad2292b9b7f9836ffb9e17ddab2de374d5bcedf664e515ae69dd3ef337f8c15fa1ba9b1c54093844cab902f95a3704e8fbeebd39940780602a945ddb0b697566d3244098e71b08fd8f315677e63f1918b31a8085968b73fc8f43a412d5b9454660430838a1c61a6538d950928c423584f76eb5dde4fe64543237c500988e6669400d75f6891d7655fb3bf98ea41913b4658b9eff489afbadc3f383b27abad5bbe7c30e85230572ba6ec42633da0d8ac8d5fa5df000106be50dae5ce003ccae247d7eb02e542871b987e9b3f3088c9bef3c987807a84423499f38655128a96bb62a4f750f0d69dda3cf9726b2df706fcacd72ed6f473c1af029eb9eba491c2bae1e10d21b02d91ca83e978168dcdf53b3be6f38296bd1e7e4ab15f93954f615ce5035233df48ee87b344dd2ae12a14e578df5cc37bc7cde9e2af3b7d9379774564159b8cf7c836024408831f1cca14d270ae5559ea79d9928988d1fa16812078a7467ebbd3461b1c378bc55c8313fa1a560a84ae9d18f9f95c5dda1d7286712465842cdc2234e1070059b8dc0a6d0366d08c675430604faf88972aefb46084610b74d80264442b41fa26b84f11396ae4aed32929e88a5e563166aab7abf5536df5a27d623f5523ac4b9b50a614a7563560734e14a877ac7b648a4b89ea6ceec64b200520dac735a8cdc4f94f67776360c2f39a40d9c20140a72a5342fd5ec6dd2a6322e27fadb59e19c62dc5bfe84cc24cad92d40ac6c724276d6f9323bfb79866751038d597cbdffd6301b0cd21cc448c9630fab5b98611592006fa335c53760cdf7f775e637df0474c440299826589488d491e54587470119855221b072ac0a1f6cad7d9e0256d62d53a4423807ce3516e227fb51b928a0200aacd0d74621fbaa6f6d0873c022eea0a39e7629f36370cd6650ea2297265b140c4d52e2537540205c2556579a9250e82d6805ebc7fe813ea1872021c49245f951c3f4f8ba2a35e0cc3caaa7474a27a3bae86ec384131be8922e49fd42e26168a82721e0cf3abf5ead91d21f3b5dc4975d90196acea708e83ee83a71f5886200605bf54f37270fe9321f927f6cacbf2f0890e80cf9ca933469e10baa1b75ff80f2af76cb2040ab2242a3729eb729c6b8c8ab931a9facd9a688055c701d0c10a5d17296713cf5b41799fd71b00151c2c4b94feff48409fbafdd686d8fc5bfec2cee7383293dd3fa37b65961592cf051f2f0ba4b493886fdee1dcf35e1c3f2ab95f2a33d9c1e7c5ba27d8a8dbbbc22fb20adcf186096af20d64941dc6c3a2ce23967ebd691f5333e884d34d43549dfee9aadb0ef975cf0e115e19415d13090c7234b5680bf603e1c4c9755f7f715f10d3716eb869ed89cde51f3f276e042fa001b4b06a4c49838e3c28cbfef7ae24ba97daed072e6ef8db45f0c62c451fdf3b46888a6d406aa86e8c8ebf0f5541bfaa40fe9e45d4ce127d24fcc1432eec43d9874dd8ea941b6e18f13d256fb3f3eb6d1bc18f910ec83f058a42859d7bd829102b52588751d0b16297bc8f65144613c83710baca78c7dae6fd930e4ee0e6bf2ee5df24820eaee5b34376ad4db2da76cfdeadfe46c25dff9cba652b3c8adb01359752e9a4733b0bfa9d9d7eebbe82520cbf9e9a05bbf55b7e015cb64df37f0f55297a55700c8108e7ee53a3a382d72a4498c4870e3774a5247cd09e5d8388029289583a41e9f392b40fefc50a89b3ff5f90cbec50ab8f1e9b7e82939fadaf55a2c0cfcc7bdec048533ea485da181e69fc60bded0abfbc46b8f9f928d79b9de773ab009afc2f257a4293959ac41599827f70d33e077fe8f6f67d78d59ba2e97a96b59b0f73dbe44ab3210aa23bc979d03684ca558d221b2f0faa056b87296d4bfeba3acef503f0d5a8587e4c01a4a352cf7e46ce82515fdbeeb0abe870cfadbf73f2336ab38e5e998fd163903a0a432fabbfa61cc5c4c94fb02586739d08cd9322815b3457fe6c7cb0928918793f764b3055bb156c8009b328fd0fd28b684947ff450d3a4d2e885de2b9a67c59fe972dff9cd1dea62830d9b0fa6029ebec1079170def913ea5be5e13ab62e111ab608c5cfc2c8393bfd3f66502e174f76ee23d44dd0292a6321d3ac30df42b57c37c463a12756478bbf0929b79baa647b7f87e9740c63d8997a9519735b6b782cdcc9cef66ae8f3bbcac28efcba62e7a9d84c52173f8a37356560b964e9efa0b6ab30ecee3037a7a403a4ce01131214f129013c4d55ff15a4f99fd33aa1662424bbf8c51edf74c285e8986c370f1c3e9eebe9fd2acf29a35612ba7e5ba0e38ae4320ab10bb30b54ef75fbdc2d51cd760d3fd8baef98502eebb6e072401b3168dc73d16005611ce82da6b1155de142218fa04ad179f3cc4aaa357472f3aae9177b8532972ec2a496f1f262a6bdd9ddec286bee222fda6c415d6140c7ab54e56dfbf447e1da31c335e5f9904d2ee6bf15eb907c7c23e6235a4603f1513d3e9214fe94106f1f42c6bcc42e9c735e385dfc1f2aae52f13aedd8c83a6c86912bf4923d0af02c49b740f02c08c897746c0a259e94b35c81cf3256e616d67351bcaac899befa3cfa25175d5a8e65917b775aeb5401ea3ed86ce3b8700bb1101c69bfa0e4688a4067a6d5d3f7f749c1618cf4ed4966906245ab4223d61bad919c25ee460473e3d007a04ad452b76ed229532a2b5af3dd7418bd98520cd43baec56a866985a7eb7e4c886225e906d9f03a212e30001868b75822fc785536d27aab6a99d9f68ad14003eb7c5905e0779925e85c1467056fad21a731374f7d81abb80fc313da90d305d6b5ed2fcebc42505043a2395d0e0ce25ec0685096699e366ec2a336f0d73178530abeb6009760718392768501b37cd06bb90137df813bacf1abb304111e3850fbc4a3cf2fb2a2eb98fcba181a074f6f3d68ed8379e69088f5e6167f9feb05dd16672c6db04f3b41c32117d5ee0ce4a075386432729a0e3780db0d6f98b1dce31fbe4555f3f803f0fb6271c31c19efc5730ada588f83a0be21e1cfeefe09465a73852e5ec6c91c52504ef1825ed9d0cd8eb45c74f6958908bb5af1d9ee49a193f5afd0d341b8c1137d9fb650e7bbf816701b8897a653b02c828baab16da3bc10f4e8759076e577ea598a9b3c0708526a272f7f9a312d7f58051c2d440da3668cab1002d520a60d6ff242aa1c8687d0817fa5e0f69411db246349d2ffca4ede31b611b536d954d3f6def6d2ed370a209e8b43ede0a2646ae3e2908f53d40681796ccfcd3519b863fc100cf82a8231da712aaa59d4d041472e2375f4526fa944d6e8bc0396e1b2f7a4659dde56eb11969ca306b64da62394aa3b6bc3afe42e1ad76bb93945ea082b89851315a211257ded2eb69e54fe92f911463e63f923bdaab689807d78d888d12b3acc9279e7a860a53594d854a8f952ed87a0bb0c8e33d735103af0a5467e38db749c94dc9afba9b791e28f798a48180fdb94f24cf8ce161207438b0748a0c8b0ddb644b5ede96aa402491037d45b16988a27a324469aecab13da37ed908ff8b13952a8f7e59a8211b3cc6419d1ba5190562ef83da5ac97f0d1db87fcac4e9dbd127ea4c72d38a73d9dc70847814d4d9a360e315028d0c06dc515efb267e6b6e62aa0441c89f7977ef86f4e8cf8439a567190bedfff5098a9e313e2826a76725ce18f948b4d1a2f33a4823ef8579162cf328955b23893aceb5e8e750fcc37b1e3797602ca93b4d39b363716bf817a5f68ef568c2aec795b59e430f808dbce445f3718901308d69ced09eb57d2079a2ff462f23aca4c02bafc0a17af0823952fd7423444b5f720929caf4284aabf5453ebb3cfc7d9208a511681ab779f2ff013fa0fd0d18ad11e1a07d76d17f55e86081cfdb9065f30cb4ba8333747a461f368769628765a2078ca801db6dbf597fd96f4ba56a4bd14343674ef6c337db32764cd5b84812f3bfe49dac840159cfa7b5afd122a85807b901a7f3d626c3dfd9dcdb1fca6f478955c7d8840c37e7bdf156856404a9de5815e3c16f65d22779916fe58e5c6142cecb0b0dbec93087af5ecb1395a62052c7f079f8f47cb99b73148218bc54851f1ca4099b59625cef09dc7d1fa7f76715e938d67df2571858ff3bfc38a292b7414fe664e54a78dfa7dc3c0246877c7d847bf989869bb85510baad623a64e06740e521f4987752c5a7c70d59cdf8c2f9c73dc6f825b02b4677219cbefac7337b795c54c9f69b8cb63b6b252a650dcb1dcf3a60602e96d37202b27d31586e922fd39f1580029cf7949e1253854fd68fff6f958e907ee6bea560528ed805605367c37ba48dda09c7e6c332e4e295a4e81c89ab65b3f5d09ffa2296fd7b85a11452862a5baa5147cb6abad1074ebe3bf1fb3efb1e94a0ad949fd775c92910edcd19ee2ff9977e3749a061ed7477a6ebc88a94a2e7ad1b081aface8b034a7cea93d0548402fae69238193647710a6c1369a254166de54f241acbd405e2049e9d64863092fbc53aef8b0dbe33f5f9229235a0c8751061f74b41c8f85f99b4c287187c29c35ef6d84b265f568b1af4eee02974e84e27da4e5cb50e034a5a83109951ad7bf76f8d6f4852b58f465fdcb532892e1f6837c1bb4fb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
