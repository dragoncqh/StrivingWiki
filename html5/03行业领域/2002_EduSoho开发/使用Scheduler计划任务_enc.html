<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f84dc339a29882ee0707af06c12e253d63a70385092c50a8fde423f661f2f484f714ebe4cc800c4f6f4b6dae16ffd9c762792747485c381287340cede57bd50a3702d032b58616178ee916c196c8ddd491d1f03cbe8d9054181a6254faa7fc50aa7dc205dc383f8bd11036213d5c8b69a1c5c3d4a36c71448d1edd139df7fe38d48b70c936fa0047fe73c92ffaa8b89ad5c63754c028395b60ec19f9285548325a2f236142a929091e30b185f1af57c8dfcb9e09f14fd667e6bbba72018ba03adca11d80db42010f9d241eef6a8a5cf200c25c4c346fed4dd5b0bc92ed56532967affdd6078abdd91f60ed348324c8b65f7860654d731277ec4f7c8de953cdc3ef0a60ff5e1b3ef8e8e94ae38c0a376be9ca8c43b870a6e02b4efc7f85a3852ae8d9b8905724461169f950a6bdecc3770d4f9a0b8c3df4202fe770b0a0a1fb01ffa63edccbe990784eb1282827501c00a11dabb39433be18aac831030eaae65e29d61ee6ef42c25281f4d38dc364acdad7056e684541126dc3b813c3ed977e9330531081c6f9be8f1c7aa5f74312854c7c20a45838ffbcef3fc06eecd3cdaddebba3e92bdba12a62dea5531fa3e2e1a45b29585218cfaabf5f11cd4fc7a9e6db4d606e9cfad4962b0b15d9ab54fcca3e6010cacbc6ec9848a4a86920a19ebed57f6f347f24b7d50fd54d44c7b9921eac2975c95ee051b96048f5d8a1a8f9f1654f888c1759d952107d0d1c38531a96ee06d0da5c603e41808a4a1e702d08fa460778ae875df7c19cb8b828e8799850c10265ee28edfae116468aee32ab7507d13279bfe5cd1dbe743fda7b31d40aade2b370f750e699056a6df57cbaf25e9489ecc2bdaec2cc71647e4a5aae668c3dd888f841377f6c82f28b5e910ebc87f79fc041e77ed3d2c8bc614602e35bd133c0a0ee072550459433f42a45860eeb92a5cfc58c204d1e16ed50f227d96c8aa322ce8435c474bae4204762366dec647d9c85d737ece35c2460ddc8a3ece1800e74a6fed6a429977e36f00be2e43c7c7f46b98603f4e2e056b72f3ffb5329b487f6f192d95bc5619a182bbaf5749011b530b55582b0961952ecccc3a2e3a48dfe1003a725223315d8fd158be8a6399852594542d868d539bf2d2033ee196dda1078090d5705b4528be3519367be0aa6d6ab047cdc43588836865f96b92b59468a03ff4bbbe87ff6aa46c3bb2dd4a1bee896ffc7e14c9d06440ebc9fbea7a094ee4dc201da306a5f27cb9c30df40b5228cc9432ad70a9d2491c17e34547da0863e3698fb0b8863d59bf6643f7fac711151141531f4d4b2da51cf3d3b2cb282432ac2688ba906f7f3495c59068d5884fe2065e886b632f9296f089c2d6a5fe353d9aa55e73e0b607c382ee65d081f4645ecc3168f973d9469a95d0cc49a311467626f32e971f19a7e34eb86e101154cf73ee28a1a5b5f034438a91406ebe2b87a422831540a71a58a353d4584b29cb4c52ebd911d7c305f3b1a66ee78dde0f9dc49abffe2be62b7cd3a9501c3432f3aa536699f24150b299ff1e791cdb95e34564e50aea0576417425f123f95fa9f1cca41b1c3fae92b147143953adfbd20b6dc3315f98bdd1e8e9f4705db90e2b2529984e4fd5d4ff51958987402526113335e81ea104ad4c3d46c1b45c8084c55a66d8691fb5b17e991d250f8ce940ddc454f3df1507662f6fb0a53d85f00ed167176257f16c10db4196f85f182d1e0c6bcd5554e18822eca54ec927c9ed5089a902ef78c955fbefa24fd4305867225b9854bf717ad590547db5e87eaee79e3e4be404686d6ec01ce68617980fab2912bbe17ad5b76181dc6913ea87eeb5fa7f9c43d9d0c411fbaba693c7b22b6635f438c8a86701ed3c7e740a4bf2ac092c41706f1b77d79caea5c730e5f22898b5651d0eb4544128b64d2a839e3e0134077f7e6c86d53ad5388e383c888fc530aa15b82f909d7f85c6d2079e798a68f1c165e84b5152a0520aefb5b0da8f412cfac4270bb401f01eb1910c53bc6340ea20e493ceb5da91917cebe7e3843a81aba6a7520909caead987450b8dc261a07d2d387ff288744d61b1bcaaa54184862e890e0ea65bceeb62a9491cfe592f374a2f2993100c92fb0bbdae3575cfe1f8c3098e86054ce30bbb589d4848d1f1d5d4f15f9276388368f8a976b6fcf1a87a217befd2d41d24b5dcbe20bc446a468f58e2424e5bee49fae57ee076767dd7b39799833b226d33becaadeafbfd011d61f19a446953148210054f5a0d9c46f5fd6f0bbc11cef1de739aba04184bffc37ee69c5edefef5cd22e978a9f1734eabe45b498d3d0bf7e0a5b963a5ef035b00f9987abb00743b2b1ad383bfdc1f736df3ee749489257b0c207f4b015462748feea23f17dc9cd932136f5dd1ea659f13136b5071c527669b3df9a61d71426a5e5b61d6108de22a0fceace8a022674c45bc632620c7e8fdce2df82df21c30708ddad1c69b971b3251ff98976a782d10114aeaa1ff2c6c052f40f3b7cf9a789bb774369a43ea0e6ec6fae11bed6a129dbe85d90e5963d0dec040c503efe3ef53615ccb14022cad5dd2a9135df71f3a21cd0d18a6882c5fe67a4beba8a60ffd617bba9a53173b0ae1a2f6b2222be7befbc4fe5bb8b11af836b6f12f2da7e5e2f94c4e493d1d99a349ffe1309676de139b9bbb7625711112ea933d3c47b34245662f040f5ca0e32a4c46d35b07f949fddaf4b6d536330d43131f4ca47b66b3011b249e4b24379874c93da67090755c59372dfbf5ad684bc7401457562f9f2a4d385a76919597880b0e1ac49b7585fd73e63e7741ed88d5267bfd181bdbd436590fab73eca60f531f45606cba0623306fce88780de385cdc807c0cdb281bd1400bbe7a3b546356eae9591375cdcae86ab33e62d41a80fb98bc40dc9ca36e27fcd9bbadcefb29fc04709d0317a90e5f84db81fd4b2ed280ffc764dd918c2780ce65d45c48fa950f9cf383bf6a86ae1b8db9758e8bdfacee922fa8d9c5621ef128f4d604a628b47b37ab8dfbd0b3e582f9b23c33c075198612b72bf192998fbb0e568b8ff62e342ecd8699b3a29edb31edb7bd4eeb14f3d0f75607af97bf2fbd5de86e36e42ae71afe505edb60b309f1a5fce425994ce4ff8d1240ad07c07929df02b70fc1ed6df4a8db59c564d55e59d25378ff470231b9c28e0f1503dacef455a96c04c6044b956ce261884a868f89db571e3892b2f738bf55188be44d05008f28741807f210f19757c88247b473ed64c31a263a753740a3f67bf4bddea61072a0e57479b47fa412bbc8d2b575d59a8ebcef4c26d2d1576dc6e3c2ac63056f3a3dfcf409054fbf65d7c0bf0b24b345254cf81b2e0537ce805e23aa187d1e8c6dd9dfd4355aae76983a975f74297c03f79fe7b10dc211cab9452c8db9ce9a5c4a5a98400e70b1644f4f25f8afdb269dcf8b83a01cc9f44404855c2b5367ac3f982f84be33a7eeacd364cd4ac86a4a2a3697b958a939d1f63359e858372d9c5dd90f8403b1bb7658a9a23566ea4077964969bce7097dd1bfdd2c853c0e5a0a7c5896cba4eb40b2961e066b1c58e2395f0659427a63218d98c1bf12f4ae7a3d276bba184e9faa0a22860c149558f71df43c7aa4c0243d5c042c6c300b58e3318f107ce1f880574053d607b496e48eb0e6799f6ceb33260c910036ac93f448ca75bbb265c9b8bcdb142d91fae2b2f26430f627f430ec907ff1ef6e67dfa5af2e7446d4872d81fa6e2e6122ebbc53d6553a9414a55ce1831a653848d62405f52849fa769c8e65b441bd9e76b31c5b6eaf07aaa5d4d8ada0e12ef0072be1fe1f6e176ad17018e59458f2cbc1c8809801ceb680c4dfc026742ce1670824eb1e1aee4b35a5a18cfc8203dbdb05418b98427fcc6a37609242b637592d75da6c3517ba9f8102cf0759aa1ca80da2be5e4a05f7374241f2f1d9b5e054845b22aad8475cb67300771f79e4157626b891fc35238c9ed01f978717a00731c8ad8e767f6c878597cef3bc77869d9f192c37f37eb710ecb0f7832459988b655a816564bf3a8a624b7e361d15b6bb4444c0468c97b22d4b755a0733393beabca08879be303c0fcf17d38867aa75b190bfe22fc2525b3ab0ab10dad5dfab58191be042411323967c976773b4b3df8ff4318a48baa8ec25c823fa5992aea17464fa78032639411a05f89f0148ba7adbc446aea747db3acffcf14bd27833d30171341f93d906ed0d068964a018256c1421d1016e02b458b9bef57f2b5f8cb6bc809bfdbc0c8033f123c2a950357b7045909d0fb2b9f46a7bfb0a421af3fbac7dedf02691fd0583400f16c5717e241c3d0e0ac234d4588a94b72c8c0ee2be75332438a6ea7c22b6b8fe68ab40a771aa884fba98035bbd15aac6f21aa084fe935cfc844f7feb595ad1cf78fed1d832b1999245bbe345be8f741a6f28a26284f051b2c2e9eb19712c3af07d98aa2a0cad74b0718c67089a717cccde58a995f576624dbbda3716e9c1c0ce7cf9e0cf0d03d6554caa577a32566cc170ad281ddde7246da33183e021024bf573d7f1723fca7bd2b9b709770336208521bf2c89cf900151f4b3494f63228d38dc08daee78dc59fb8e93365450c180225f28fb1d9b119f082d82127075b6e072a3bc9fb7b2de0e6593195deb869b37be405a6b24c6d9afa188034b6759ce9a4953ae8adef1ac18ae351e8a511ebf47b0c0855c5ef339e504f0b94b228d5ebfb92766300d7bb70b67c1365f21d8a7563566a998880b166998b754f4de3a33eed7e101972ac15935afc612f28afffcc0342e5acf8512b83a0f2341535c0438a2132186d4440b52f65c46355d6b6af0dc56d4fa730f88d45b3b8920fc6da3dd6abac675f2e8ede9de57029e6240ea400a569763d0c47a2196646f146d4b9ac6cb6a19082b26b938e641375bea6efe587f835491f719094c60e73d27e3c4ae6cb55d8952168d00df2f80d43f3f47cd11fa9d0211a85903a7172af438ae4fb847cf4dc86da68c68cf693af5397704377f2576b67eaee1118f8e4cd68c626f55bec71861d6dbad570d12749a5362967124f9a45ecd8a9531126749d0266499aec913d847dc56f52759ffe4f0050323ee616fc760257c52d3af6cf382f994c0fa33b3340754da59b624f5a0720b3fc0f5a810447600523c78e983ba959ef27922ab800c5329b165b850f691c068e1dc192a7aafc936f5d292f47390e9c29080be0de65bb05e7dedf85c474b94e8448f81ca06a32e3359d2d9e407bd957e95ccd3cc89ff1c79d8c41b38e85d0de6df64e87e328694331e25cc864d0a4412607c18a1a5f4d8e259fbb07a000c412dd8b8b6497e2b2f52b73a170c3e42c7b299ecfb2481d314aa08bd8f17269a7600be73813cb4455b6683807bcaa80f2104a08c1ce8c9674a0c9a62366a9fd729fefec0baecf675aa8df4d6ad0c70ef52b6dab1224ee5d463efb39028f565ab01f2c9c03a5dcc2964fc6392e7e7d6429e3c04a74d3a1433aa9dd76f1982792f0b77fe665c048b0590b2140f4b1a3d84f870f5ecf427e1d89ad7872c7571e6f65ee8851de1d2bd6fb33f78e51aeada53c9f64ec6019db88f98e677836316f146a47a4dc3abc1e7629deda1ee7764ecdd1cdb88bcf95e72f62f6d5abeeedff795824c9fe1b724654e231585e9a79b0deaff75c1e2e65ec896b6fe94aaea2b7345c8be75b1674c1ed3563da27927fa29a6d60e76afaa5a46cdc90a51835e663cfa09ff35f623fbf7143dcfa4b739399540511243bf1c3285f36ce4db7312e3210a3ce5e284dbdb5fafebd88e074e38a384a3d5800376166dfab79dc2879116e4dd62dff4f2e65155edb2ff644d4bbb9a5ff7c0278926426c3f93161876e3bd860a45f0fb3a166b0b8a5a39b4e3ec1fd4331d39617f55f565f4ba160ca79c81f30413951a45274484f1c7f94a4f0e8a887ad0058a167a1e421c53e209bd0a81aaf0a8e7342437fb38aa0d50fd2107b1444b371bc3435ef1c77a5a2be60eb78119ae5d4e0123b3f923cfbad921b4f3c4fb0a989c892b05b2fb8e071a649da1e0dc8c26b381703b739fb232a0adff1825d7e642efe32356430eae6aa51eadf1c8f77d7d8e6c2101243744a1de625928617055a244b71bcec3ee493251f45509baee85c956ae2f0c1422ec909a39dad790842cc1b8ca5c7602ab2ba6cc02d330f6becc3e3d14f24f46988f112dca697342b627e72e13e0aa46c2bd7f9c36ffe6a04ee761faaa2833725647c59c8f7c94dbb15b7a75bf54449e20eb508cf1182d6de42be6e5812ab7267ce09e022725e6c8f5dad1a423de81243b055946ca730a88911473d4b777c62bc2cba3e622195c16c4eff18344f7a1e87f8b11d199676bace7a56bbd3d360d75065fe7b409c049296a6b0a090316dfa688775eace56fd7db1782f662c735abc70dd7c9193974445c034e9d006e2696766091657fd19646b0239be04ccfec83153a3b8af597a8ad121f76701c5448af47f296e5c165049563dec9eb4aa53688e86e396c5269415add4b56a2faed23a14963ed1cf8941aa605c013be57ff4df9e61cbafa7f4b63d5360564feb851d162bdc96208e23063ba1bd23dddad498ee3c3dc13a80afb9ed2b9382002fc27087072f3cf45e861eca7d832ea647c991fc4829b1dbf8c48299205159cdc55352478e66711eec03cc5c42bfe29bc1d5637c7c79dca54e47e56936560d6fd66b73fd67a2151402ae6966531eb81de1d1f036e8e3908ee9e39f8b0cde990685fc94e63a866d4a2bd67704b227d88110ee8dd11ceb2b6f71a72c0d2f21e89e3f31b534ad3d22ab2f0f79b4b395a39739b3cade2cc93f32071abde383caf9cd95deec69a58d4d622d337cd03db5a9c215d608612491ed8121c824bc2327585638fb488013b6c08ceb2cbe8d0c90f620d4784327e33c8a715b3265b8ad3ab8672a2c4f2b7360327186bd0c3d4ac0f1edebf9fea0703a2718eac04577af8ab21be501922edb0a1472d8b4954f38ac92c0b9739fc257615bb44766d738626f784c85a2b3cb4fecd15d5cc83cbb21c4414f59c3bf6cb638b7ff29812ba5a25818701e6b328b857ecbc932de6a994a34fafac5f00adda2a2b5d8cc02328a61ba422552c010045cf0c5bf57767256b9c198a3e508655f5e2315ec82445af51c32a701ff148c44b5767056c20b83a4ed93bddc053dd96b5041233196cdfc67756d0a15e9d32dcc2f71ed012c915576d5bcf102c3f36bf02330bf65906f132c72e223738c455b2b074b9973d4f71139a92ef94c01db9831d9c5e09bbf8cad1a55d669609687dd64428d7de27913299d03371f1f706601d07fd7f4cd3989fba0c0a8ef04f57536f6f23b58339ed911a25e649089c98943107019edf8764aa32a8eb7250f06d0007184db67a76fc20bcf637f0d0bcc8c1dacc2b3efd5d6fc92be4792537b345439433514d7c79324a9a2617df7e088a1caf32b0434e0570dedb169565a296e8aca2b9a992473554469cef0861c21997030544a2e50eafacf26adb5500eccfbd5a5030e2077df52a5d982d62ff9549cd1b5d6c80fe49fef13d256cdf504da0a390340d4ff408694720eed533a9675a8d9dec6fc0b479e6a12fa9077f826d702c882913296eea911a327ee5164280ac09956ff17831b489f220d3dc1125e04bf70a2b38ade33872c2806fe276103eadbd95ca6e397340525709c9257e3d78285943790aa37d8cfbc9d64337d93e11e7cc7ccb168769e82055b9c9baaeb6401ce79f24d4589dfa58cf7f5099c5bb9ec298efef55a2ac8d9f8668522e28e48989bc0b6b9e0824937f72a34f5006a5d079bc827bde0d874685f67efbbb6acbb8d746aab5b08f9c534c148dd04f3e0580c4a08d24b21bcb1d15be76225fda0c5783b081a12dfe29948efea625a414a63317e4468cc8f2392223d37bc03ad8c1947c687f1ba47c52eea25ea9ddb013eb65ff21cf616ae9d5a4c77b282cf61d2ef7fc634bc895d3cc08de769a2ccd903a2cb92f6a5d2e18d9f3e326aae29d113283e07447e2a79096857afe60b024038d1588b9de2031257f83b1dc5daf910d4d32ed99a4fb7246554fccadb4d34a852b5518a9654ee700941fbdb217c4e742922f766be3e66804cca65368a0d0bae98dfb3cae1eef439e0d71e98b02bb4d039268d83ba22c956d6b775954aa4c9d5bc8107653024bb066e8d0fbf8526012e6727e21291d8704630cdd60e6283ee6494fab7df74cf68f71d4e1eb288e07e3df2f50fe16014d0a85886e307120e0924c579764a923ee9c1fc8085a32791d46640479320b908c58bf618ac37d924cbf19669d3c6c898fd3c4ff40a18d333bcc2bf49f55a44c102292db468128e3ad9356c6bf85e4ea91d3f0df62eaac7bda1b387dad44c14d1947520b39abebd09acb51e9de61f4d684b746243ba290814c4dacec492c71f6b56c9abad46c616018bff1030b09d5c4e6a8c534f7875d8a5297ac5a212cee569f427f5b987fc69765ac0c4186330d9e09c1195b05b51762ffe1d6b2500158de53f546788e5acdbf4663c9de3dfc741cce9c75163f6b0aa37fedd495475a70a49e5a5fbcf2e03f59e051f0fa318e7d0f27ef66f1744ed059c465b605a64b4f4e070da64524c56db5310ce3a8be033f77eb53492e5b56705a4cd65c1ba166b5469301a13021b15b9559930e6a0754250a4356d860144e06481705150582e0d728e535f11958d5aad03479746bbfc403cdbdf5414813955c62dc5fe0f20620d83781bd258d5de3d31936349fb6ade1248e5e3c908556c63deacf5751edf747b8f8f293c873d851abb6b6dd344d7da48623815c79aa5d53f6a1d51c3ddfec06eb31d5cc422db9046229c1f4a114df4725f464ced8464ebbc5f0bad56ed1ec8d7d75bbc81e7b67bf1e1300dbc167e9831de90ac201bcb3e11f623c3af08a34034499fad663f56f59b07f3c99a0bcd2d89a8d94b284429f3214b31aaf1c4af4968d4f7fce03b1a7c6ce08850d5d3217c76f5bd3783e4ddcd3271fd1904a46647fc21f393e715b6f6e77d4201ed2c3ba72bf96a04e838b14d2a3def68879e598bc5ba66174294b1241f2a01efaa2d8a2cea8e695782d96f0030bdd470c530cbfde9f283f0bf086d63a64231495c573248a09d1a457617e4204c801ac165661744f5448a02e651a5ec536ea2b7eb0dfcfba11915e5afb1146aa161492bee815757b0cd59bd3da44f53f16a16aa67e31d630c0f01e096ec17786729c4504f2473b982652b19bd13bb1c16a1eb082d11e205459d2fadc7df58a33508ca6b6649a0e3c3e145f74d473f3333930c1735f229dbc2e5e8c37a454f07f60a2635a59c8dd2e5dcc73b1cd625d403b31f9f269c99735a632b8cba175c978276ae9afbd7b458bd115c55410035711cc022996f050cad726c053807eb34f1c7d375c5de5677c4d46db7a956f694b7192488f8bcbe04eae748dbd27908f32aa0c49d307c48f9eb994f633aa51800e6af963d6c27090e4e1d6bc50e2653e45b738f562d5696c099f98fe48fa20d105d90ef3fb76d8bbdc209d4b3b54f056b9f770b49ca9b2c6fa7ec0726d3720f694c993ee32547d376c67340c82e7f44ddc7576720620db25134f3cd8697bed232874d96994ffb601d46f48f3cd609e7e3b5a8f9a0e97a994951844ac68f8959bb25d0d6cbcef2e0bc8f6d775b14b1919dff55e91cc624048c2f27911a4c299eccb633ef09c6ef56bfa4cb759aedbd9b5f303044f49599a8e02522a1cd5364a680202a8fe3fb9cb59a2a7c57257433fdc0af8d76f16a682ed702e4c70533c2927627e74e7c76e87289edef0c204b34760b6c77bb4914ccb2c813d965a8589650b22089b13b714fe7e6ec081cddd30084c4b4490f40952ebba98bf0e087654ede2721d2b0afc86146a62bca9fbd5da89e5e62b6e4f5db4b799830ca4af9876e76165079b71a4369373912a141c1452409c68373d3d86ce0c1e7c66b2270256824b0b19ecc65597a39f99c8c840a837cb926e78dbfb6e3d545656bbaa0ccd272384ccad3917765d77d6eb3b754e6023cbc322fe861e1a27a36c9d6557bf13d14d84274dcc0ae49e946eed5eaff054bdf8dc0ae8ac84059801c984d8f56d452e2e96a0827b8ea6d962b154c661b91796017e59ac6eac57fe70aad1a60be23ffd9d2fb737f252d7492fd0680a06988d424b8fa249b6d70c153720e237b2c25c8fba69a120cf43dee541b8d6b9ad8b1a7783bd84d4b845554e02d8796fc2ab4e354047136a83f805bcafe046518a5dca0c76eefb2b797042f5b1a02846fe0118d0332cacdfbc68a26340c0f641782d71083c9099e3bc2df491788f0e89b5bfd453defa2e3ca500cf399abf004f945471e35ba61130ffe7c2c41dce0e2d57dd53a943f20a6c2d92aec934ab2cbeb288dae4c90bc9484d25946b72d89547e8da5b19b14e3365365b8efb60415bc4655d9dc14f39f8572874c2a4ca17d9e32083ad282bebd371a2d36085a26fb66a4ab6a5f1f6b64f5d3f4840fe892de4094140abd1afb1bace2c0d501f9c4956178844e6da8d7506d1dd35b0ae8341ac8686751da374b0d6a8dfa881c0dc4d38480a55b57b48dd5076a60e758e848ff4a1428360af12443669ee86f4dd8e43b747ebe2b3e8fc375a40fb0a91f06b37cb240e6260dd9675eca32e6c9c85ccaeed129b7137bb9cabea6d473a58d9b5b43b5d8d108b1ef9845cba27613c293316ece182883e63876bd7dc1bc53729e166216bd6ae2aad5ab74288a0439c882560be929b3d6d239e527f1f802fd036215db20e906961a36b43fec7e6f7a864172461c30c70d59da9182d7a901a7fe70c3a5402c96400d556ad579d5c2c41f4171156c68f03622ec3121c70e49ff4ece4a87667df46d086eaa7e3c2014bf8c44b2ed75d5a3f9e2715ceb87991ca42e75655d30e73a742f4336e7b8db8ea63c5b118f23eec8536593611e44856d78b9a743d67c4cc22c3c4f6bdbf679a67b25cdcd6a79527b846efc831157dd0c9ebf98cf0889b6ad63c83152bd19b4b6e046bbff49daf2c43431fa989129e35cefc9f47899c4986d9dbb718f5bfde0b6485abe0fa06ea43f4699642f797e0785a42914ac99158cd6e0628b5857a807597cf6c1dffa4e4b2748b17488cff1dcf338b35a5492e1796cb8ae447d5229112357d03019d1497aab48048606e8b913f706bb6776e94cbdcce10e5bee7be8a22366b901d3b7e1b025862d48f5b6fa99676a4b348d28baa72709531c993d5cf4c0b5c211a70aa5d8c6da97c794e6de0d7100bd1192588e3bd35d14cc4b27ecc4020bfe019227bd70a4fae6d47beebe9e72d226ef7b606bd6043308dee6e32ed533b7d713a341723f106f212516a5d27b6cff40bc90c37fe0327aa076ab802ff2ee073b2674306e93001730fae703890118db62cdd38531af61130dd777384e9084df560d4b9bcd29b28d316de7b08e96ab8a4862bb5074238762205aee2bcf2344cefb5e71711273bcb40e6a1044145273b1336111b394d4914ad9f5560d2edb51e030ca82db74b66cfb8c39c2d6ca6df5caccb8d2048c22d3d892541e31f53ca82f29e9b8fbe359c5a6df9d5e65e4a7c4a98a4c6bce70e74f4b0ff73773caa7c48ff8e8c2b66835edc50efa57608b7c91ef32c7a534f71b92bc5c66aa2f4feee1ff93d51ec37dff055e65ed496bedd3d8549bc550bc5055b7d8e869a560df1308551a2ab632bfa1e7271ca6cfafcc7cd7b8e7203806c9d18c2b37686e2039d3c37f2a239587d6bcda633e4adc4b75fedaa0c89fb03edab433b2ff5263418c969fdab2fcd1bfb2cdf2bff405e526445690092aab88f997072bc6f97e91e025eae7ad4a1165567f047fe95f89af122c524cdbdb558100d3a0e05c285db5cb33e1b6f7cbbc9761b053943f09a9b8083a6e9599080caa76cc76ee7b8182f2e4adc476592daefa9c9b71dc78b78f5e2332d48e40415e0532dd1bbd2491517c249ae8df5479bf58b453111ed7ab3a13b13276d216d915da0ada915063c37134c2987347e6af4d44c321f8008bfd77bddbc176c9ef4832a78a4190e8afaf3554d4064f2cd570c5e39b0032a08d425b586b32a8c8d3b81075ba4e558ba13f47f7e3cb799910a29f40b9d0e3ff1628ac0c7cd2b29a60a5631ae64bdc2bde86788dddd0ef4f9475de4a2fe117b7fc96b958a3f8ac4f080f99698163c5881d7eaea32767d2c612dc315bc43e8fe87841f5760111a035b0786dcb9faf7e86c5b6dacae8e691d47e8bc7a77bce92a79e211fb84570049f348640f4b52e1455ec5f3d9cfdd7fbf9a43728ac0c8d8989622687d964a591aefeecae24322a0dff2aa954af22e40e5481c5847b39116a84da0810e9d940c068026d6901add68d45482176aba0f373f1c4bcf555080af2cc1b6cf5054ddc6d1c89d2c63a260d9e90312df6ac3f0cf0ca9d7a00d1d5ba38b9f9ff97e4561417fadb60ab029edf26e0e13dfc33d5cb85eee399e572342e232709bcd3ee3377bfce7018381246ecefe780d627b23d045ff8143e5d818d095ce4f60cfa41bc8a8c9f84485a462c788821c1b11a6bf66743220a7722247d238c098e20fbfec324e15c67f13a76be98df520c55f4b2b96266a0f0f93b2634d47da2b1921754d3af48d0a552a059d03b4f49a72b069ab7b3d1dbba6665dbe5210ce073ea3926da370879cf7d1f82086bbcb3b89024970a2707262b9298876f37e6c60862bf95a42977bd2676b05b110f125bc133c236eda5ada9b651121b0cf6ef06a221a200132e09288f5eaed95a15e0591594ce23bb3d5aeefd0fa984a87bce65ea2b9ca5d5ab5abbca84e9570c7ae6ce4f348a40a5422664a04f213853923551cd151692f875693ff8255ed05180e809ffda56c1b7f7c263db428735bf1739bfcd08853fc3b1b8b41be62f1056a958b0875116a906263ba32168d82abe51daf8abf231c3c1635b280ba5c1854c97b0a24ec8daa6f983c04b5c967b9007e692af7eaedc6d31fbb3abac86f8c2dcac08cc000d3ac315418f9d94b4d1664a5abcf4c2c788d4ec4657a21201662c9a53e8e2079c42cbb25aed32aeea0e1ec3abef73ccba3f1f9a96580995ed619351e657610b571356e6e0ba0e9c4336786eb1ef5b31209b0881c4a458521efca5073754e0e5439868d267747ff80287a823b4c92320fc986d6bebe2f80f99fd86516c3109d3996ff53cb0252f1e709791e2018a61f26b9fe66b1aae6160c6211f4ac9f469dc97359ae55bfbd3a1f5bda49f8716625e5e425e87ec6fcc53c73229b99387b6a8d8789b3bd00886ece7aae715f60b06d630bb62b104484b0383e16c82b08d56ec29b2e897cce0becc010752d345f39d6966937a8f671ce89db6799fd239b7b0f651580545de065d25e704027ea530dc392f953285d85dced889488cc506a4a817ccffa2b0eab15ba0f4576f2d1130f9308219e4b6c9fd456a71ef20e6e39a3c9fef46af0bbb5031baa0a792e40de79f8b66a67632b3d79b754b806f7255b676e3900574bd1bbbce78533a40ee0133910b4a4c198dcc47b702bb356486041c5153ad1a3b1f54e0bcceec51ffffac236f5402e7cf67f1d33259327da1ba4a3ed7a5badf8a9e8aa083215dbf0c8f5df628578f6538ebbdee9ae94d78dcfb45219ba4d5434f157bc99d885ba1f89db7dceb33893fa95ed839ac7761e83795bca2936b25e413d2b362bbd4a6d278eacbc7dc5216130613bba11dfca9578be9c055daadc8cb9f1b2a2c0534068dd775171bb7530021b438ad8d8964f0d3f3334f246e6ea5151fec16977ff5f027cdac497d1d01a9f78a9ba350792f0259af7921a955f8bdcffcd2549cff1019c212bcabdab2498f66bc56336fa06250ca8214b82026abef2e158a31c56d966dd746e4e4eed353b7c7ff1fa823dee602bba19ee26f8c22bdf565846007997565d1e74b2c84f0502d4de587a5784f016f8505703586e15f1d64517021f71c909118dea0f54f9fc4564e3e3ff2eee45ec26e878434bee872aa30ea3d120abb7c702cd8031d8060c8cf1954822419963145a31f884a63e4758faf8f680c39ec43988e6f6d345ab28b6f8dc6ae97078af927e94b0897b69da73c34da64163f6f32fc0ba3f925910345db50384e4e9c0c712d944d8b44b85fa87c1e9f155e9f19265e5613f4a82b601136d3716c25e6d38de3b8d871e913329620d4951e2e88f7c6f93322d552ae93afa858fe818f3afbb7e0c4e596f16864ec53d32f5eafe56cbed011dc42c1b9de46217b9d5bfce2f6258e9352da322a41c779920774e486e0c0ed3fc6013ae90938c54bd3653057c1f5919535b3d08991b03e9a195f0c36ae60c87ff223f2484c12dc501aa1ced0a3adf08d1b12c2c4527774ae71b242065f414f8f29ca53722d6989961a56d81e4d3cbca2594a10cc8ff261c08f9d204f9b43ebdb108acd61c76e8554593a4c207253c3ad62930d5ce5c74879a0fda8875d79d5b60d4c39da052599322e865a50369d8de90b01de445ec7288bc7445b02661658a0123a7aa7bad0ae9e8a336808685b9167352a45f84888a04955eba6a1e75624682e28c04998882cdfb604cc2484fd4e4e15497c43da6571521ec4a3c942554bedc5aff43f63a0ea8e7d65810500e571ff0aaed45aa358eb1df7e32ab563a35ce8196b7a3a63e1cfacce6cb441edf98ca03bf18d5b7071384e85f3058c44adaf4e9403ebbb8c30e4bd64ae6d72b88c306afb84e51aa25a22e03e06b7e825ddfbd75ccfffb302955cb76e8bcb50a4daca92afc153f0f2df4e6541aaf81867987eb3c7c649d0e976256184718928f627bcbcd5256c8696ef1dc32d0afe2df6717b6deb9d636f00c17f74ad029ce46aeb49e5277051da4a3059cda8b537638fba2f50bbc1a6b882eca091f7c7bb7b7b2a04570615baff3a031afbb1e1a221baeae1dad46da6f40996ae1f20a5124d8beac81ecb1abd95687d52819ef2f7fdc5ff727c6f0082e2cf90b9c82b4d7fadbd3fd9e0cc464501e9f29ccdd3c9dc151ff9d07ef18f0a93bcfed98f8876b00a1d6d7a259f53e4ae42edf975372c4c87c446d4b13d39bdaae60764d5ebc41ce81872600af66ffb27bb571c495328a0c2ee4b258b11bbf0db277d4bc1459516f308b7fa04b79df5e9ce25a847941a67e27fb10c415dc8c30a1f057987de38f183e929e59e1cc4aa4d4f5961828738ca66def662956534db388f3c200eb40b5824caa02000cf615ce6e9fcf23b2843e04f74adfe616505cdf341289cb881d6b9ef004694340dcafef7a095249dfc451b234587afa57e8154d235f5daf97f92b98ffeb3d49ade0eb6a0f7e7e35105227977a42e677016d54e294779b796eaf5c4f91786c504c3cc350e552437f991401f5be5535b0a2822ddab7b2e1f689d9af4292f54ae4550a7c8cfdb7cee81ffac49b1c2c103e3f1b21814a239b754b718dab179c7a4c9cc378bbb3dc94fe15ce456545de79370857e660f7fa014eb1d41180433589061e0053ba5b2ae1490d79a5318faeaf11197388a4c5a3ddf9fcad144a672928c67ce0ffedd5a1c8fe8b1531db612245bbf9b65f4ee4ce9503e8e81f951466a980478c83ffed8be7c590a5bd335d0c8a22cb2eba070dfde3880f7bd009728f3dcd6869efa9c3942b1261f938bd947d2cf3c916e067cf67c6724556f8ec4c37a07e301000d19065de80536ff6c3fa75055dc2e9755f3cad590435fcbf4e6e4f4568aceb40dbfb288b1dab3ca4b1cace4e0a7aa115799aab133397c592836efff55852fb76f5a168c3ce9e0bfcc6f1a3bf4b5442b6e8844f9debc792659c87b3e7758b910aad67029b09081b1366b9bb7ca3272e6769ef6db4fc2dd4dcae15e8f624a4adf79b04a09aeafa281eb9f0f97269eb34b4ad09cf2a9a3367b84fe0fcab02b4b830109cc07205de74aba6cba8d95f498122b143611566f2296b4d524dbb5ee6a220481f2604a09530bb9ef1a3797cb7b0611d7765b52a973b7966c3474e2a83d7b15bef4fff2e6aa43aa23b306cbfdffa7e8e9354307957c913ac6047613af1bed3785c733761bacd46fbf8641fbd6190b25cf2f6eb6780f0284237ba5578489810433429e71b9c1774359166225ad915cfc88d0660f48f4e8a527cfb95ce2feffb025de6fc87b16fac7e2fccd354a3f2110cc17aeb6065a4c24ef44132a180037475c2e4b5fa361e2ce5065b8b397370eafd24f9bd69eaf7e6daef62a847e17c12f8a0c535a111e2b38cafcfab7f3a9ba90e0146d7beb52b7e057e999c3a763df5f088a5bdebab9f67e58a18f1afea9cec49a173bc88427763e994b937d50d203cd7e495d36f7b012112eadcd1ce277c86b9a32623915ca3ae9d2cfafce386e509923ac0915169e8571d77b1afda801bcdef4e92128629e19d738ffb60a6d05c960bdb93af","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
