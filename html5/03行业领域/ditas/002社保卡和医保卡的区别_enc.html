<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ca5e17f46b03321ba3910be9deedb5f6f272ea4f6cd1d36d9cb381a1d39cca2ae0dfe53d41d059ca8ed743ecda03eaf69da3c1ec75178875e6bbf6e14dd9071781e2ba64258a4d63e0b396164b8ef59f1fb3890e479b895e98e6089f3ac55c217cc0a5ddba3bc4d0eddde7e8973d17e059a1e891511336878ba61c2b43435c5f923e3f2ad8f29f2bdf81a08f34cf0e3714604c618bfed77fece26b84028832fb143ec142ef476601b3ecb2470ff14be8a248aafb37f272e664b13099f63519c6519b609546c797ba90089f470d0a052599fcb974f5e8eaa2d3e1e3db9ec5a09b417e80054fffd7904fd97fbbb32c970f43aec1724ee455b00c2b3017e5ddb2f79c9796a732042484258d43d9ce52d250ba64e6e03285a66d727e4155b8273c1f4812bb072727387ffc62deffd706f892ed7c1732a8f9543ccd9dc6a75c4939034257983bf3a7ba2486d28629fa74332cdfb1e277cd459e09822893b0cc017823e70f98472f0e00b99f82915aa64ad16e0dd23d4d24f3f519f40bc05663925a9b2f737790e0f85eacb3b1ed87b9ca9918ad81c42bbdb3c4b58d33e5386053e1cf519c77c3ebd9010d01ab0304530b7cb4b3378ac8390c70bd61dd37e59d79d7af82de33a5c3c0208ff949fcc5627679550d6f1a9223595de82e4c86fdbeff8afb10e8873f14ca63d3532cda9f0d4e9ff5d8e3bcf40f4acd083081ceba1adcd89d4b2250a59a85ed640eeb812b21c775d8a6ac9a70e1e66705362206bce819ea7aae5ed30d4f917ced8dd3cfa86a2435cb22e8ba5181f1888ef386b58ab44095df55d36740df1ce97d683b6dbb43136b820151b1948d831d85d59be43da194b77e6d93877bdeb74350e6e6dd8feed00d975c479279c02fa50287d4b5ca4ee7aad7c8b2194f9166e8f246e1493f05c939a07ef50241748281e2857b54af27fff0d72f575723beab2adf1ef0edd3c1ebcf8536867346aad448b3428aad69b4a84d434d6f2f4031672522282924f7793f5eb67968b1d5d177dccd1c480bdf214fb6b0dbd133b479071f05f4eb59c14c990868525ef0a4a305f92dfd296e453995bfc891acd3469f57609fa6d0d13f9930f43f6e9b35959ae98c850f934d842bc65ff3de40df5435aadf1e7596862db2372ae11c47b71eaa96cf6fdfacb32453dc6fd742ca64ddc7f443022ca050ee8eaaebe31b8beb6b19cedcbf978351340a4cd32bfe11d24a0c6f602673e81e370e20a837b846f3a879781032a29d55418dae2be85e0c49be7d61f6e1eac19197631a3089415e0fec3f3e62ce5f43a4ec1f9d9beb5bed20f4d9697dd1ace3b0c6149c06ca689a13f44b0c75c0e12df05739046dcf8314f0410b1f1e537ec0321505158663eb7e5376ac2e2d91e2048585644032b22d19c2abb548916e7fc84bd8d4a492101196a2f31a661eda986eec1a6cb7a1f0aba585ef2f48ec187c1e981d224c6e4c15e90d0d571a5eb087b25ef3374896d7a4f1ec5f7857856fcf3d99335a972de3d8fbe02b512c630c4e3a3568d6d8669e478e1e3050870919e37865549fd5ad28eeb88ea9aeaf30e4daff0eddcd8d57dedeb8c5ebfb27770105a3ddb50698c8ea2ef94bdae74a1e779c8341c0e6c5cdfc0842d15280a68c20a4b311f4bd7c628f4174ae8f9b4bd1c4514c1459932d2e3178b253261d32facc6d3b5ac20027df9c522c383478c1e26333dcae94f361b361ba6d3c901a92b57a20f9d2f469c1f75e7b08f10a59904dea707b8ae3c3287173a3a99799bf51630b6ea9a2197ecadef3ad3b5b62f19424006715beb03cc9492225601d237d4ec22325c051a8e70a713b8c870bb4abf73b7a5a17c8e03c869978d137287ced1565663c20ff736900deaa91eadece790d7ac1e0a3c94b5b7647464e528c6dbc11c97c98c24f1f31ed81681b4940136f05c9fa9ab787270653f2049558ef7a62929b97726f88841bde116ef342c0465f105ddb6389b3f188d4ae5a1a4fae96383647417d7f9b4c03cab4ba8e18fe4ec72de3e0ee676da7c25af77cb0386f2953ed985e4308adcc4b908b1d63f5eead3ec336d079047bd2415eefa27105cd2938f89d279992c1f8366293b993628aaadea501b0784e3227a08191358cbebd0a7f46990a66ee7f55786d8f7f1f8f1db464c1f7c89f46db35bffcf7f877165b590c9ba299c2a980613f6142b7f3e5141992d5b6bcc35ac762c78ed1e7beedaa0c69806682dbe958cc583cf619e5028b7f7b4ecfc1a14deb0030baa60e25e2e28bc242af23f2b2afc64ef9d8ce754dec295e5c04519cd5a1c72e410d9fe681c4bbe5a91b1fca4895917f199db7cf2ad038c5237b5a52d71fb428921b6e62753e26e58b49bc5ccaa0331c58390bf39203ada438b2baec9fe45e4dfe0864197bcd1f11336f11167a81e5d35f7c448618efc46429f0d43089dda9dbad63d5486d8915d707089dc90069f041a7ab88b9294d10fe6ead0d259a82e79079fd1ac6ca1b60c4236aee8a70a740c5b954ad805c613bcde49a96288922223a7948b9d1ae05048a0e1552484dbc018f86ed8a830c8562c9fe3cc761a5da30ddd9c52f1de2e6182fb8daed53c49436b38473334e74f79fe68c1ab4501984cfb0d5d8c6fdbd619ac5bf4c3872648b679b8622ca5a2bac4e98ab6d60471a95b17508cae3a0fd06c8c001bab5d3a176a44fbf1a3b5f30028adb502e7a8f97cca5414d8d16137590f61915306ab9e7781c598ef02e68d7d1a0a2750be5edd24aa525b0b1175b1a955fdace162df8e47eb084df9ffa80e19593e5b121f6c8d70be4fb66a5679f2224cf9277e9e083cfc6f1a54379004158a2526f442b2b49c07b36e893ddb49aa4ee86ba71bd8a8e3949233c4d313dcae9a24f6d7cf33de23c2cb76964992077e7b5f1f7c3dd4b9d29a39f39871456b17d33f6fb1c35750aaaa9778362ee7c2051b5711d60721cc2cb9e3a6aa2eaf0e5fa357121fa30fc15a250328bc632c8b941c52702e1f5da66acd8bd944f8f36f57154211e19c72df2e4620c561264177f4049743289fee7ddcb7577b5f7c385b46a339e62fba6820dfb14c6d15102c878b10e9b209f46ff8dfe0e7d049aa2124cc521bce788f39ccb0d92759bdd6398e3be31ddb3fb8a52df62e5aac50a178ba2618022fdd2128be7686e825cc09cf5ff346da997ed3179730af5be91e98aa4bf448b3da279cd10416b52a5a554fb399fbd4511453d440ec3fee223e6ef830cde06c786913b9533d65f029f3be17e22e87b06c2bc42810f6b2cc0e1ecf046b5e3cccfd0080b1f996d6b2c2643cdb966388e0e64f972f444dadaa2d1e9f60b5bdd80cc7c137a27ba9970dba474e3390db12f1d95f03c06df3f24e28e81c725a393ad41dcfd62a9515e849501784f29c84ab97ff49bf432c013845fd312ec4efdd63be262ffa99e653241f86aa285fb6f01105cd7aec5b5a1818fed464bbd3fe111ad4f9409c18e04666ff64a32347e308942b7980963a6cd1a0210ebe80f60a74bd12e414b4ce76713030a66cd4f89ff1c2462f79249f4b9c2ba8245aa0e9aef7fc6a5de09a455b5e614b08489a198a397d1c2cff79c8cfe31c77b6ad6272bc61987ffb8628ce13b95db3b0bf9ce28f4f72db69a84d8d4786d8f4685ea7965037dc02922cae39469840b5b02f4dff844bf54f2aadd5267646f8150d15445e908bb3227d46b26b4a5210dace1355aeefb1cee259bea4c11558ca156d1b0a8371867bfc4656104895311e1d552fbd469c0091181ca3c7ecf2a10fb59d65c74178f8a666fd13c1c376bf040c1936b9d74ec47041e3d1f4d7eaa6e1ddb8ee010fc7f2b809b0d5496520977d71f3ba6dd8879cbddc145588ccca77303d803bda956b46985f9bf278c129533d5612c7322771fb29145ed3c73f607569689ea1a5ebb09d8127bf762f21fe0d99f6795e7f8264fa734708004b4c95db2c7324532c57606af69df379403b032cb5fa3b4f90b8508368c07e394f28e459f32794535cb4a180dfa1e4b6f0ac3e697103c84a8432ee06d8930248856d954cd4331067060bc7949def48eb16a286db28b415daf2082642d8e28c071c62223cf6697fbce7247678954d4655100f77b9addc2cd745a3618dccb2f1d14b5fb6c7e0c367d310ece67a4914906162a53ae0b40ddae7e4c9017b34603e039d3639e2f75dbf0ce1ef6b0fb325a1e44936381973460dfa1eb6eb062150c88c583f68778f29325b0206166463add61c4a8ddf9aece9f31b1a2b8da4891e8265615a55e408f44d0bf97205d7b48d978b88eabcfa1ba960c5cced1d83e7b619029ed93274c17d3204c6d4b16eef028cd9a3c417b2e9e8bb4c677717f09c56b811d60eb7f8d9bf0bb77d81f65d6f8ba12643e3edb9eb4700784c70c1f87970885b49777e5ea2c4feb2a58de08089ff52c91453f3f25314fc9f0f8fcaa7bbbe4058d72cf89b0dbcef931c5622fdce666eebf7774c8829203db485dd8cc669c673c17ce4edbaabd5955cc3d50f3eafcc6e0d9a8f411f4b4be700a657a1527ee51565eb206388cdcb107d493772b7bd74d555bdacc704304d7ec9301af6810ccba5fa8dbaa71f345b52d1a92b8b32d495c2fa5a7c76f35aad88e6e711587d89e293964c5fbbe394ce451d6925ea2711158c496188142beb4013b94e753238a4972d9e5aadd4b1825f36164f185bb88e66b02c0c37158fe66b5de6ce4dcb2605a04cc91b039435cdad1eef074543f6b09bf5ad482b9314a836fa1b240497b65057aa2333275101a9562affce8508e41b9d3d0994e4e94a15a6e78f6c3bc4f51f6649410d1473233ff7ebb606fbe40ba1a0c8d6fc476a8bb2763f1ea54fff940f42f9eb71062c077a7e56b1939575dc52743e1b51bd6bdd26e6e1c53ee89a2923f5e0ff65b84ad8a5410d0393b51a7fec5b41ec2962c20d016e566b1397dafa9e43942029cae9638464fe6374204058a6a77ae42a52686854892d2fa1041a3098c484f5f6a0c736141af1b9ccbb5cddc2fa4ea9ceef49d60f1de7f90ca651b2a79af074e49d9855bd27a38d6627c002355a34edd6a3030530a8d80f7455754139ebc8131a101cb23fba3f50fdc826339fd03909f0d746335fd1496534e5d3a0e1606891227f109058055e83601f6e750fdb1cc77d445526507eab0cc0c1c20628b6efadbbf06a244ea06f2e0683343704c6433511df11cd57bc0c23ed2a2d1fcca0519515c7205928940632907231f99277fe965371b2d5f6cdb6651e0ab21b4166056e960242ecc2e6305a88829f1b070d0d5ba88de093f64b6bf5179faed2549fe1786dd8f584fa1429c80edcf64f038e3922d386958969505c4f08dc6dad87aaf31d588aa2ae200337a86eebd1e54d56a5527de13cdbd3778b6a79f94dd49e6dd396c779060bc5601032c249aaf4d8141cfbf726f12cf8f37be86532791a29f24aaf92050f1faa43e94d193567d55041c3351ade30270141581ed1151b40813405dc8c7ab8a2a87e66ddaca70dbf65447d73165c3885330646ddf082582a96ef563417ecb9305a354d722b5b946365483567b8928f235965d0c0ff429e15fe3d67bd6cd3e72932da5f3dfa780cf7fc7af5ac1bd89a792e880eeab4edc08a9ed1b28cc76763824d207a7673341804083f1039d149bfd5a873b16837ed0d845f14c92518a91ee67866b2026108a6685428b9ad2fc3af5b818a0f1412c62057e982fd0ccfa7c938e1c15577d4baad6a2860a60610816fa8cc1db3d12ed1bc9abbc07c821d0e9a0184a878bf62391688cf9acab4e5ac8ad752d5d1ba61319b000eec4f0b66812f610c7a5b153637711714760e1201eddf2661f219a3bbcd6033fe25d08b08831f441a99c6e61249ed970dffb9190a0bc8fbc379aa49e4a1c7b960806ba58a056552a0c828b090a49252143207cc56b831b83f12edfd930e6aff554960d6b6dc26369d6bf82ddc5e415408cc7bd2535b10502f877b51d2627a30eeed19e541c9721a35f15f2462c305ccb08e2aa6418bb1959a24eb0d35fe17dee0fa3bf29b7510a7178ce8a7404996aa5e96a0e4af594525db7fa40273b822a887c2df78ec3c675acd74042b78d29a46fb99bdeb6940f2c72df0c35d9c36ce2cdaa6165a008e4709f563a7655596d98a605becbff380aee826018d444f3597514f8441cf5cdc33910df60d8a60042ea2a83c4477618397d31a783c510fa0397edfdaffa303670601232cd8c6e693e6c0a3a20f7216ed29d26b582e73a5b76e45bd51428decd1df37452bcbc14ba28f1166a9a017d51ae36a43027c102200cb74dcce859cab5fd1cad9efa8413ba26fd617b0c0dcb79ecabe7f9206a4972f640ebb886a6f53836f58f248f92577a7cf579e1f4f11cd066436ce6145354cbdef777ce8ad06028ead4c7d949f295f582cea7281c431ff6a195a3debe221299839a504b76e5a68471673ae2413ddcad82678bd9742b5abe796b49ae894b01b34a0b6195903057b15ca7f8fd3b63364b067db5da9fa17e8ed8ace039f40185623a4267f92a4e3acd057c79db6c600b1a5de897841e3cca7b5b06065ac210a6ff6b622f177018c5d870396361e0ccb1e8df59b713219e1bc90da64a74991e60b84820ffba7fa60eb39fc04fdab269963de8ca0eb23f316e0f61f25528f707c67e039a71d52dfc70f919e60980f735519b7987a834d9f1f08a5d5d25e065fa53ff58194652dfa13605ddce5b9ff7f61eb21ae1a99e1d11646ba8de4ca698c3d10a3aa6a2b536cede2b9f9fa0515fdab0e4eb13e77dfe44a78c252e9db851be9a3f24539044384a93bef36078f734d4e54325d6f4989dac1c2be3a95a09d23a14381bea9b7936e69010733bd2747355b9b485bfc1189b4210224040e190b9afc0eff6a5153829f386a0cc262a57c284469e6a7078c24acfcdf006d1841b16fd9d0c1ecf66a9f9a43de7fad82b6ad599d8b9737f31a7be92ed2534707f8917477c6b5ffe8b39c6c0d840397462e156946db67ceab2d4e4c554ca963dc1f014dad0ffea0b664e9d0af9c2e3d3b870bab98ca4d24fadef68d097d34eba471e7c89e7550cb2b9943d4ec1dc7dd1d279bd581782737aede423a4b4f9e43908991d5807729fffd84d5ea276945164455498e904bfe038b9c34c9cc0803655d711470cfbba8e58dc9fe6dd389a1c5928fa2cafa9b6de75a0730e70977516ace91d7404a171b649db90caca36f90affcc0ced9b650034c0292f7494bfc70f4172364f16daedd6699bee38ba1f0f5717bf590453873daecbb9c60725e90f987bc0a12635553f49f72bf2044524a2f259b2dbbded65b858e49f3b04b36d559d1e0dcf9804407a5eb966e584bd359902cb243880258af51da077c1ed0d125472b726940388f837d09f11f9ddfce7ace109b207b7d2bb466f2c4d909d109bf227fbd392fe3184bdddb4eb84728badb438ee85e8e7c7e71190eb4264fcfae2c756447571c0542e92be104f48af85abeacde17c27da7ee679e748d1dde1a267a21ea532cf0fb2a86629d90c726f1b28e1d9f3997dba6dc5a5dcd82a78b67aaadc6c47711edc2066a5042fb9ee349857a95a428181c581611a8e8234b070da8270e8f847fa08dc6ad0da8301414e76b03a7698994bed00309b7c68db6a38a60834af6c24ac82e1f9324cf663d85424bc6cc561365c7a0bce04e053707e6c7a675e7aa4f814b71af396b120fddaa391586b8784d9f79d51df239f896cd61adbe7b571b8a76e595a4f6765e441c4a60f19797fb26a0a54f2b7494909fa7b79d1cb377d72d601e1d22202cfe47b930d5f2dcfc62188f1e0320b87cd84b32361882f50aa04632ab83b6379fec768350b4f09b354c6e394c9ce5ffd3940a1c23adec68117524201d6d0dd247614fdf7fba97ab2d3ba5d77e0ed0a474e8ca56c1662fefa6025a37808f998a0c2f8d36f094c7b9c795c331b26b3ecd86c7a0bd7b158fa55bd3443c437afec7694d4de8011f3f1a1ddc767e5fb71fb4b399314898b83b9c3afc404f68e25b30e1b14921b23ecdbef5b211fac7b20ca399cea42298e0a62fa492fd29e24d9a98e5356ec410b8227e76600d77bdd9ae82e9b42c8c1e3125ca564f5b6b7f6ecb27a78ef2865b13c53e5f89335aa348d5f11fdce15fc3961f6707d42ce555b10ea0de3d48ad3ed3fa52e0c838a31d2064706577cfc60b8133da5a00f27b218f2414f7c36bed68fafbdd026c6bb5a6695fc40aee4661e65a6d8f0e7a00cd8145e0758e7301d123848c9bfe916bdf54c7e1d8dbfc936c41c782da74a93b897dba374186bcc258da3310419ae1d0fbf9a1dde2083bc6ddfb5a47f9dd8abd49808ccc5f483e153322a790c376abf05436bf790837b9d5430722e805448beee56559edfb83de793f3fa8a7c5f8829711334744c12adc2edefec2efe871f792ef0b4d1c107df9a5146ce1fda55cfe4b498724918b572320207121ff02863dedb1222a3be4227f7a7fffb89b884f7dec49c29be892e1e611fa671e4b17cde4ad438ed0f3ed08f18710e0bd87dbdcdb07c559b3f86c215b085a95659c1d9e0762eb968186f612cd41d8c69edab35794d731723e8a03c5a92560b2bf532b5326380de5816bef71dd2935928a439be686146508265a3aca9b0ce985bf5f7265e9c2ede6181163bbcf1b4177604353f3ea590f3ea1d1fb44810408638a0b03ca9adb06ae8c48684b0f60e874eb85926382dd77cd6264141a79b9ce6f4713be24835e0bce24b014604cb830640c0ccfb8fcb60e285da45a04f0abad83ea115c1257ac8e1c10209689a2ff29f48d34473d818a02c5cd59a5a3f28e68af9247fbef335b1e0d5aead574d4ac11a53c8bb0d00c910ad4b3d885e904bd3e9c4c09fad035f0c1ce9532f8abe5586de523653fff6540d6fe65165efd2bff134ca3d474b0dc8a74e69194637cc093150c49d73d7085e8d62724efe306d641c87d2397fc0c419e65b3d52939d7902add0028be554df5cf9b9c2a562086d75759c9a7e8f00be81a4cc1c7079567b4fae6e957422cdf35b97279fe4c9742bd9be78f1ef274b5e7c69d9161b92df74c0b83c28c7651887cd2b995214985b0490e9ec52b6fc3996c203336d8e4761ac0b5409c30887f204b6fbbed86f3ed20026ee662e01880f0a57ef3d1fecb5679b6229db6d4cdba7bfc5b142055b9a6ade9f78fada585fad73769d0b421016d48420325a556b143af6fb3fc6091e97c1df121f1f8d70e31a88c275884f72debbec6effda6a77832d17bb997beb91d6deca2f28dad9047da84a3cc263b2965cb326219e3be1b606ea5d7b921b748d1257def17dfecfece88a1cf4041f997e01fb21cc818828393fa92ed800d2a1b6b0e40eac067f4e0e5b47ff8ccd05afb706536ef2a90a976eeb04603463f1adb0e4962671deea8c703871873f6d89765fb917245053470e3f4439c548d1950dbc6f97369e0cbd1c8c3cd6a6a92a932113bbeadb0f0bb590c159218dfb7c3badda9c0647c19ec3573626d98c219de27542d621ddd082c3fe49c68e6996b3f17d4050158864763a5db7b4fe646d4cdf4dec4a5b299f22e23ad8bc6c7828c77c02009b01be5f6e0e4a9798ecc6f19751423e436db74072fc82d3a0ab7bde740fa351a4200415879c924477135b812e7623efb112e267dad48fb75b791d551ccc552d8c26ca6a92da23cc8f73d50519b8125a9c50d89df402370a959c77f31995ff71df7f664cd7cc12deaa848672d9c293197aa29c1b1eecc1d2092411b3ce0d329438155c06ae1b2260755c8713fe6a0bfe8d15d02e1d034c44ae8753fab55943b6470a1dd5c37edf9115b0e9d6e5a5294c2598435e7bb1aa346550f557a175c54289ff7c8a65ab617951bd0ffdf8a5f24ea605525761fbbc3ed973f01736844b487149156c163f1268be33a698355d77e3bb635294cc2a93e7e6627da41f69febb8a406bbf0627b301790a61788b52259dad17fa88180783de1e4f1f392663684bbc31808d796e3c64a15da8b675169ae771bd018b8042ac69724352e8ccb961983b7efed9ac73575e2d6caed50fb3f76248900610cfe64390bb9593f5b0e86957e0f27c35b8f88c4cc0d9d4ad6f1ea5c5627e724a076395c22c7e8960ccd8343e52ce6ed36797f6812fb67d043ba0061615d511a8d1db11c104d2213989282ba7eccc1914b2e5e780f677303cbe5bf944cc324d91910122443976fb16c28ddc83e643f2df895292806f726ef6680f2fe8a44debd09235269a7af18c1c9c7799ab5dd1c8a8e6893cc85943cbb3a9f90d5232e3518776b0fde6f879bbbf812aaab2ec2201c873ef450130efa23039f69973ec7d82d8c6cddc8de9bc41684c72cd140ee49bd131098a5361cfe51d33ec27e8160ad7a0fae97edd30e35a30cacad6736b6387471df75b0b580440d6651646cac2899c6511e66c1fc0d9bce4b9105fc1d3cedac5a1186b8401b5c4341c0cbc4ad8c979911d02a1a1c9917be478de1357775111d0610e8a5d880dcfea807387c6882155eac3aba28668ac8c17f641d8d5ec1d981adf1b11e571890e82e57c5a040d519a7f59c2ef68e10588b67f206f085c3e6c158d7a603b93467f0e3fb39ca2dbd1a0f2496f8ea89388126c9029414875d80edbddf423d196827ece7420ca2777fdb3ddcc6446d458e480c4761a45467a39d12e7bf04800e800ea8cd7a0b243cf8a3967216b0e82b6fdb7a68d114842f9e9cf3314a64d37fa72937457f75a1111a8af0df6777f5a0717dcfd6be56a307d5af120401fee8a6aa7c853bbf99ae592c0c898dfd59347992687df4137dd9c642f5a5daebddcfb6a65f1da02cb16c5483afb11d085e4fb9ed6007dfd8d50dea276e4977081fad8ce0512e53f7feb5dab37028e6bda8a8162194cb34d215a702ee933933bea91aecee341e21d0e60afb257290c051927307322b75b38c3242c3f47886a33ed0195e063a62811cba89ba2740f8dea1c72a8be5533f2b3856d065895a01e5b4b51c5fcd24e4a9db44cc499e94602eea4bd4fd9d2634f4db359369997663cddaaf5a201108f3ef7fee0b8cd363909e160ff50e2d9f577f0ba06ec9c8c4aa9ed4f9f2d37bbff1a8ef02c65f9ee979ff249a967481b6ad891a48218670b3984eb484260af1c475a725fcc0429330a0a29cc35e313f3e9d1967a67864db872d2465cf89d0d93eaed64963b63caed62e0157445614035f1e8123dcf071a593e0e260e64a396f71cd414c63614ce187ac8078f7273bf94ddce0f007ed71f7e48cff8a7fdf871f54be3c9013c4ccb86923fd91ae87fc7e6c63a6e4974d5cfbfb48586aa48ba2fb01fcf28453a43475fd24be6b892b89e4d4b8f7495090166dca18b35aa8c0665116eda6c24226471fb8b057c00b901897bb86e5a22086ef9c9b25c9a6031454d162bf56b943b266d9af4f3b8663fb4c07037f27ea1c74e532b953ea3a50f45e74a165052341808cac11330de7bdd4c94181ecaec5d83b521c8b815f1b7c25abfec43528ff56a2908c6d6994b171c3c194a970989dc17f142ff0371f6766bda7fbef878a16d2e2035a10e932f73bbcd9c9a103af1fd0bb5917010959c103c46a4a4277a6b910b15f44ae80f3bde4eee92cca9c38dac33a96eea6480bc86209622a7de7d204f037f03bcf3a7e531c9b1e51019253b2fb7ca78aadb8dc16656a430a31a378e29ce11e9c1375f08e061578c593d93d1c75988d98add56c6de537ba41f436136b3ade4b4b8850201e6d3c27f6059da3cf5e300800411748e493c655f74f48650c2a3c280176150ccfadf70d3eac15132dcc786de1112058dcf1e9b586bdce718a3e6286a31896c65ebaf6c4a60c3361a5a8cad23cb177624a22d6f551c8aaf1bddaac5c4be7ca915dde7123c797c6af7899b3b703c67884642f121950e8bf42b970fe74744dad97125b0bdd3de19aa07b515b570e518bf0ba953d0ce2ddc2ce671a9c6167f832e6dcad32463133c3b62d9aae11ca4439a83cc1f1f48929d73d4fc1b8d95b884bbf6bf756585d9e97869123c283753944d6e742c7291668254bf74d51272b7264cef539050800c70064ffbf59ed8d76c891d6203c46a8d9e3c36d9e134aab0f52f0c91e2ed60fecfbb44538558f26000b0d47b172fee2537d7a4a44671d9eab53531fb1b3d9fd5d8d41011c439d724b5572f306a20266b64867791f95e1eaafcee608c4f934f55c3c430f6cf2f79ab792901bbd8e59e9de33236cd63218707b64f6d17619430f749621ed6264510b761759cdeb77921f39fcc85ea75603f37262d67ed3756d27f2471529263da1d1da80c1eeb7923334652560314b82a4fb8a54f8eee8511fd3de25db13ff6097ce3abeb3f7a7a6515bd8264c110919241eda9dc8eb5f6b513809e95e552082272d26914d4e960f7eac0c6db8f3a01a85611e1baa04bf9f50439c06c06415838883131e659d5dc47598c08085574ed1cd31008a487c4a7d0ce1708e44b8f01ecaf4870f5d3a371a43c075bd1da26a636a5d4102b6ed4b3247a2e65e002886080f46336d28fa9d001b621c73727b07e9afae8bec08d17df28b51529d591512dbecfa25da4d909edb233463ba020f8820638801a90958fe0df27e60ff361a9e65a00990be52f32d529ac6e0473ec0017d754a0f993f68f60431cc88ffa112020e95b64e995e2448d5c16d5c04a756c4724681f21fb8c0f838895137b7cc860843f8ac88643eb53f69d51b4936e9f9290fa518ba2b2dabd6049672f778c6a2834fe8ad1fa4195ee9e35818be2c74363aa9a23bbe84d8b3d2c326e4eb61f207840aad53ead24fd40ac7ae07ff5380f1e7cce05bda2975fc60cddb9fa361997ec6ad53486af6e4732c899ef13a21b0a4cabc7c4b01fcf73e72ff37b7d037d3747769640a4caa5a7537711647ab299acaae107b120446239e2cf6a451f5b527ce73307f86351a373edcb234b16db380e3d29d85ecd5e1d3c434a5a29a6599f6beaea766828b71260958dcb3045077c67a81796d606c44ea3f05a902879b71f7afb4bc464e40ed34bb1c52ed2d99cd326060790ddc52f2f2a09213ca11f56b761522610ceeeae9ad512dd8dddc4c6e0ff364e294b8d34820a1a4818afb1cde47d5c3bfde2a6379171487103edb8339bdbe09175a70bf42f7c2f9e684f687b8061df3f2624896afde0050a51ec801121e6781ff124dd04fb8434eada254503208d418e441c2f9e3cb4191b5faddafe4da5455a4e42dbe60c77e5fc3ce34724dfc9c1c3fe74f7ed4d47aa7bd39fb5bc26441db7ed74f112a681af39f8d0a821925ac41d7696e537c41f65a935a0365fc3b208550093eacc8faeefe71e2c69f93ad27b10895fdacdc525a389691908fc40abff5f6082ae99758822427f409886dc39215314a58f00ef4caccd2829b10af95b951433c739b55d015b8640d7b87466bfe329d627ecc76e9226c3407c3dbbeed9d96fee03f07322ac3acb3d177479ef44ed77ad1dbe3acab89dff2b61b2d5b7b20f080081d968b342d8715745c4c44fd0e6fb68c9a4e8f1fde2f9a3db78d67490f15c455d2f40c4e0ac978a54f8b54693f4a684d3c11f27fabfa861b120352316dc6250f8a4b91fb78d04d397f5b90cbe7e0bd4348b9ee4e6bc06594dc7f3896fce312e618ed57c8c3bde6ed1e3d2fb3fe7ddcc668dbe531cf7d0e9e09f6ac651ae45b513b96ed73c565c040afbfd2d065b08414fe179603795c84aab24ce2653e0a743567151f87ef722f392ff9a99c9acddea8e5239207c7effb9a75abe3682129894c8fdb9f4fa3261c68a4557830a4836794ea91ff1236b7b607fbc93b2b6e72f5a9c3cfa2274ae7dd218aec850c0b28f0b44d305c374a198833bf268716137155d0b8582fdef8666c733cbea03ddcd4c560074a3112e1ff69c1988398288e821c561f2577431154dd81b3cfa8580569dbe9e5316cc399a94ff72348445eef66fec33c554f880e4bcc00061e0038d9a341c4ae506ae10cb01de79925c328ef7514337c913f77ba047edac49dfd81015bc6406e8c771541e6c36fb42e5ed24d72efe919e481015b0cd5e1c4a5e97e4cfe7df72d3d0158d997b96c8d2c1e60e891b79555d03537b72a6777d7792e14431ed4c7a2eff9e52549c8f264ee3db9c1113ab2407184f944c7dc9a43b4975a02bbdf2ab1462a7e42495ff15f52bdbcacc6fe2c0d258569952cd08ea5b2d2e385d5d536a3578fe28168affba4e0139aece1c870396fc3039b72e29efa22e7299f109151b51bb3285f8009f926834af4a1e01aa376aa248cdef0b7bca652808d719fd9a1d07387c68ed8073908c3cf732d4a123c481c03710aa4e49822487225495e9ec2d6dfb83533c7a35e09fe21d5e7e27f5b6db393b9780dfdc469d8e922b2c4ac1ba3037cf4328c0d1c17ba71d6cfd3d1a66f49e5cc4a338ad8c1ac4cd1071e116e446b4379b039188fc7116dfd13cf2476df8ff0beb7f25595fb85e417d3bde9ef5490eb5cb931d48f779e646896a704bb387cd7180be6db0ab4210121b52ebd41af46f70b7700cba1c47887e9db5ee68f020a1ae3feefcc0cb41ae3f932890773660444db53a60b98c2b7910f8707841260c1d907900df31b266d9e732437d1b79e55b75ac8e08a4a6474c41d98fb8e4539649909fc94ea94bb0f67ddcc4e2f7f8d48bed440bb49243a1c3296c53a1f4d9458d1d4b2ce8dcd713edf32cd5b82993d87b614405a54f7627f483945031266b3d82be55993c14dff2fa1e65c0301d370141f8cf89e5abab2f29432387255d89bd26923b07738eca3cb5551a42ed20b030cdee01add4a562c446b58ccd7ce6bd6aea9cc41b895995b60fd39ee7de77f2a6dfc8618885e8f0e73d3a2459b0528c5b7c3382cca4698c1061a3aa5944e0024320e4615acb35f212653bbd53c02ff189bf48944ab12f1afbe65b1edbff45d38c267328e69d567adb32f015bd3ed86b325efd48cb7a917718854d0c8fa7cfbb7679bb44faab2c9ebcf4319758663f6b33200e08739abf746861b7f51c95aba96c3fd150775fab6fc2b3b28efb30092adc6fc78b52a46053c34467a89c9d8daa74c5ce713ff8d64abe982393b5e612693fbc5448a41d26bbde040879fdfe6b5c5b21bd679b60bc9715c90f854a917aa846bc9953d0b745e03988beccec4a9c348881e3bc95583a54ca4da7380cbae31e09c7d1b45f87942c15d869d99a814c43c68fd634004d29a4d7ec10428305c6f20529e42a715875c864f6f607e163be0ed57a21f24c75beb543efd54cb8eeac78499d7cbd359b1ac01e8b49733717fc78ed382cd70d373c6fd01f00af75dd3bdbc9968823aeeb61c949068a6fc52e8790f657bd3d84933de45a069f6f35e3e37d31ae0bd14a4af27ad7e1a033fb4d62d2e032c9684de0d3de32e0840eda23d231e8a91130e2eac447547ae059d713b6072b5ce96e819da85e71f218e91fe6674a285b6ea7f3cc47a39892ddeae00e30ce7c4664c1ef0a5602eaf57cac9ed7efa26146e0bc1a6db1eea9e98790b65bb1931760176a4fd7ada3f0a9c31f6ed01c5cbef1bdc06fef2354cc03c68c86116ca37bc73c58d2a1acaf7b638b051f2e91f8bc8fb80145924107d25acf2cd1490a5dada0d28e81916160b9a82e682354fbe5c624e7ba4d009f850a84e9be9337705452b69830a819904d9f53679e210d578fd5fd9570f04987c739f32350a3f80640304e3bed5303c94ff0ec63b5130531a092f99636987116ad75c8f31c37961b34de911d7de46d9c58b14ec7c366cfb59f9da31ac7d97b095f8aa1eb5bf7c43c7e444604646611138c3f8b6645dd8a31e0ee088e94f2902c176de10fdbe786aea20094089064cd6fff9be9176aae8799ed7b4d798f49e2dd38d3e4850d1e26ee69f9ca84fb66b871735c964b6c29b46e13c9b1dd3a194e4e4fbe51c6908aaf93f9e361728f031af566409cef3edad2e3d249114d252997d0a860400f45a22df7de81550ed8cfbb322272be520ad159bdf09148b01788fd4c227b78f2d51a90b836bc2c779578162e36bf8bc171625b85cd731cd8d06280a88bf6d2de0a820f8c3ff7ac87a9f395a8133c06d2e65a935c30baf69a2a4123d0927f37ed879401b17c970c9082cf38872c79803bc6b128aef7cbe7ae16ddab263556e7c1d5ed7d5fffcc8c74649676c03322f5362c2c1b6407880c10b9ebe724ee94f0fabbfb92276b0e7d65c68c2d0a1cd19937d8fbc706f6483a32e2705c3105e508581b7fc5d4a406c873c94d800c26ec2ca35a4c9535d4d6d11099b441a4fffba7ca40ac1d1f3df741fa8268c49af3a96e5127058d342d446e161dcb0252674b9d5abce6528f55bd37bcb48681aadd773a2285421cc3bb3281d9bc8e9105ba7e406551f2b29f1286780498a326a988d3fbb83604875f597415bd1e0389a6ebc928804b77febf42a3594aca5fdfc471343b5f96112a586db1977dbd91e4d1a5cd134ec7d08c018d32c824fe0030aa8819b778b0be23d8d6da5a7b4ad28c7cbf9592984f18ead6f39ef34b1eb4627baab6701fb9a3f19eb15661563b9bc31453778277105fb24b9af1bb4b79a772772628d6223fa07d2f5b4aa6ae73dc35730a93ee19019d7bc2f3573ff82e494b166a83fc34ca8a17f1a051ed81e3608b7b99f9ed818c028ad5256cb6e444d900709a28041c78da3d5cd02a89eccdf9c498f399992f4686c67c530879988df5da5f807921f74b8954af977c315624ccc146ef08386eb881a6314adba6f2c965e7b9567d5b2dd63edb9db6aff556d6c21d05ba6e0fd75919c133eccf5bc65a2f67cb43a5dab0a80c57bb362aef4dabacc5ea6d862ddbc9dd183ed79077beff1e1a9cf11a849ef1b21f2e7e64925a54e7a61cfd528bba6793c7b5212231252bca0a9d2c632a1b3dedb63935d4edd6d99de9e8f2f5bb62b1e137d93dfb146cfba323ddcb4bbc3629d00ad47ee2a17d19e0d5bd2ce9ff97251dd715f3e6e0c86c17e8ef093449736b25489413604e732932bf763e3f84f92bb8c74d4cb2e92cb10f56e2fd4b8bddb2da993a5c784b6df4c0af0352ad19248bb6c0650cb3c40cc2f013e20c84620ef19dc75366c2e053054a4dac8e2a4a4aa2c79d19d74a9f9091157e0ab63e31e842b354343f0f613accab1a80444412ef7e7607d899a9cb10b660b78e9dd88902a3e94d3bd082325191befe71c95850ce9f4db8731a8340e0554f9363c3364a4caacacafd788fc766e3905c8b0b28fa1307884c90cb5a9a5ccfc4435814b275d89f41de5534106cfc5933359fb593177fc455568405ff2aecd73bee817ba182b79ca7d0c9d31b42cdd9c72360b17bf9f316ee0370768c36261b9a0cf6705a84ddcfd2ec4b2c97963f117e97423ea48a0fb26167d7efc4516f4319be9398d28dec6798fe7e25a15aad711042c9c31203cba7c5c22c3858331319c923bbfeabebe23762c8d88f7a9d5a5a29426f1c361d551108206868cb18fd7e6fa7050578e3de4145ca206dc3f9a77758b2c63c727f90589744bfe4da49defb5af465e7078c6092a244cc1229b6f16c8666cc940237348c957369f175a6f6174c05934adfb932ffb16ce3a4a9c729ae46381283d1bdab39218caff5acf38f06e51b4f35a06558aaa231b58505b2aa139b2e1ad12e39cf9023fd9dd4667d398481a62ec97900e7b8af7d73ce1a24acccbadc958cf57fcb8dec3c556caee6be21a0c3e2a4186cfa56b86bc75f1ffa57b59447859df98783dcb54adcd5372c362919ac5df0eca4e06a63147b6aebbf33ee1358362c08018d67da77e7dcbe89ebf2d2a0e3c40f88ca3da2c0347f7662a2907598382a0c941ccf739ef0d8fab4df4f8fe170ee64a3d7eef08b0e82232842a4abeb04aee80e52ee545ab4a7f09589e1e7feba5fd6ec4c7bd9ce7e603d14245e0444b8d2e679e42377f95a7ff73e379d478a567af958f4876c9634e92acf82055910ce9523fbae9bde06afe7e32048538462a4241a8d8ed46d0024cf635a5aa2a2439368cb9084c67840da6c76cebc4ad82bb7f700bfcf472fce674718a9e879da55d51db1813f4f385a812c2917b9bee39a0627f79e7a88fc3984f8282cc767276109dd8d3335a0067f7d769cf0f8151590b6c236ead22886b085384bbb4819ac07953d30a763794121bcfe0de174056d287bbbc84a9daccdcae1f67276d6859183faf38d1b77c0e2bbe313b658493cf171678823ca7105ad69e76f2d842d234218f9b94c94bb826e3cf9a371af4f4f75b0323f74882e6124292aa386e5db011872f0cf27c1e2d455b71db84e3999b9fc8550a85202828a5153f723f23eef9ada145026a9e12339b564e8d6a8bf6e3b154f047904b69c03c1c41cf53097eec9260213fb2e533f2fc7142545bda90d5f58d9ec68e1b1c7dee84c73c00e25a733a331e1a12f7e421cc844f665bd43f521da25a8bbe31eecde96234550b3c63b312e8acbc2141881cbb65fc54b971f33231170879c957dd230bad6848a7bec7df343e19ccc2ceebe2f99b41d7321b6f2568d3b2f97a647f2d9674f3b3d2dba2a2f1e72d3326965d1dad30c6f899e967774f684f401c3cd5b970729fa392f2331d4c8e6488bfa25718f3e197b637233b1e8759e16a8d2a3dd7b2602ec5a09caa8d29826db7cb589b9ca3746f33016f3f3c030938375a39d0b589e220c72e2882b09364a4de13c6cffe650b94f99a739e231cc1534f22a6f71b5fef139e7462f32c48eb6d90f2fbeab07ff86be395b0f9481eb8f6141ca7ea78e614257260575d7edb84ba2f45864ae6b160ed0c12f82a841c30ad263af2be7ff9130b1de9e91cfdd1df01afe51df289de41fc8a31abc4d82d60bc159e323678b377960a065d55af39c5d9c3c246ca8900897bd7e2b5ed4a807fbcd8a50daad9345c697ffdc7a2e98f20d6f945b27a91fa4024d14ac362f709a09186f941d01a55dd7fc69484e27e3f66191296753e0220c33ee5b24928ec495b2a7cd1916e4e071868e0bf6274b8da6c966ab9dd5b83f8966d688bbeaedd10307643bf8b1f7a244c5f6593a46afb18548f86d3b2bf8ad0b6ffef03ee7219306026afcf2b8b3076340d0018839a3a84b6c93c8eaefca749d3e531ea074fabbdfbf91b596e16eaf39d57c57a2c0a230fd215340630b2ef3f5f4f621e73d1d682e7abeccfe9de2204dce0e57a7d710ce394f8a199f5907e4717f23cea959eac4ff62c910cbf8c73431eae4e265bb7b50f747a066c1e2ec142cb1de029356c4d40adc25bad3be776bb58b991aa8cbe9b7e7e7e7275b342490956001f33565d402cad5710a0b39dfaf71b745718a0fc84915f19a4dea95b4b29b6467b2a0d59005e1982d0487ae3fda14880d778c893b071d64e403895fd63fdb8c979b5257b1fc3d1c20d16a3b728cd05e3fb56a1563c6a607366a36d412648a9ac35c80969004709b9b7da0d907da2c91b0e8639883145131db49c3061c3b35f53acb715cde8a17bcde2a6554a2b9401a15b6878ecd06edc44fdd24f02b32fef35d01cbb21ad0fdcd158bbebc3a1d6223871e6d9c5371aea7fbe1e989db3431ac142f6165f380716cc78f24ddc224999f1c93aebb88f36187eaaddc1c7aef9c110bfb0f0b468e59e6fe0da01945c4d0706ed91b24727cb2faa8960e3d75b99705814486d624ac7e65603229703acc4cd1961135ac7db353601f6b928f428ca6a0585e337d3aaec6ea8089f3e05a6f226b6e7d07e7cefb1e65b73fa4e5f1e2c4ae768867c6a676c2fbb07820a78356a078590ec432432321b0a9e5da7214a55a016a4b907ced7a87ddbc632a1c71e0f12dbc34d1b7d83531a36d61c415e8d26a6673ae83429a3c9b83fc4596230102280f8fc7c7f0350a2694943145b3cdaadaae02cc9673d245745df5e86be900695dc582c6cb328abf3a32a5cb960021e50f7e12a3529588","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
