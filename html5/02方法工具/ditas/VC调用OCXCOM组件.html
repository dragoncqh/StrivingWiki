<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="zh-cn"><head><meta charset="UTF-8"><meta name="copyright" content="(C) 版权 2024"><meta name="generator" content="DITA-OT"><meta name="description" content=""><title>VC调用OCX COM组件</title><link rel="stylesheet" type="text/css" href="../../commonltr.css">
<link rel="stylesheet" type="text/css" href="../../common-extended.css"></head><body id="VC调用OCXCOM组件-FF4B425F"><main role="main"><article role="article" aria-labelledby="ariaid-title1">
<h1 class="title topictitle1" id="ariaid-title1">VC调用OCX COM组件</h1>


<div class="body conbody"><p class="shortdesc"></p>
<p class="p"></p>
<section class="section"></section>
<section class="section"><h2 class="title sectiontitle">纯C/C++中调用OCX的方法</h2><p class="p">首先，接口就是vTable</p><p class="p">&nbsp;</p><p class="p">#import&nbsp;"c:/ITDetector.ocx"&nbsp;\</p><p class="p">no_namespace&nbsp;no_smart_pointers&nbsp;raw_interfaces_only&nbsp;\</p><p class="p">raw_native_types&nbsp;no_implementation&nbsp;named_guids</p><p class="p">加入这句第一次Build之后会生成ITDetector.tlh在你的Debug或者Release目录下，把ITDetector.tlh&nbsp;Include进来你就可以使用ITDetector.ocx中包含的接口了。</p><p class="p">&nbsp;</p><p class="p">ITDetector.ocx会包含tlb的资源，.tlb文件中是保存了接口的名字、规范及其他信息等（也就是idl文件的描述信息）。#import这句会用工具读取ITDetector.ocx中的tlb资源，然后翻译成C++的接口版本生成到ITDetector.tlh文件，事实上就是接口定义而已，因为你需要调用某个方法只需要知道类GUID、接口GUID、接口方法的偏移、接口方法的参数及返回值类型就可以了。</p><p class="p">&nbsp;</p><p class="p">1、import你的OCX库&nbsp;//想办法弄到接口的定义，如果你有或者自己写可以跳过该步</p><p class="p">2、CoInitialize(0)&nbsp;//初始化COM库，干些什么事我不太清楚，反正就是告诉系统你的这个线程要开始用COM组件了（有计数器）</p><p class="p">3、CoCreateInstance取得一个实例&nbsp;</p><p class="p">//获得一个COM实例，实际工作是根据CLSID去注册表找到模块路径（就是c:/ITDetector.ocx）</p><p class="p">//然后LoadLibrary，把c:/ITDetector.ocx装入进程</p><p class="p">//再用GetProcAddress获取DllGetClassObject的方法地址</p><p class="p">//再调用DllGetClassObject，把CLSID传进去，它会返回这个类的工厂接口（组件需要自己写代码实现工厂）</p><p class="p">//再调用工厂接口的CreateInstance把对象创建起来，并返回这个接口，同时调用一次AddRef</p><p class="p">4、调用&nbsp;//虚方法调用而已</p><p class="p">5、Release()&nbsp;//减少引用计数，当引用计数为0是，对象被释放（组件需要自己实现）</p><p class="p">6、CoUninitialize()&nbsp;//告诉系统，你这个线程不再使用COM组件了（有计数器）</p><p class="p">&nbsp;</p><pre class="pre codeblock"><code>int CWebServiceBridge_PayWebS::DisplayOCX(char* szUrlPath)
{
	HRESULT   hr   =   NULL;  
	IDispatch*   pIDispatch   =   NULL;  
	wchar_t   progid[]   =   L"WRITINGPAD.WritingPadCtrl.1";   //组件名  
	CLSID   clsid;    
	hr   =   ::CLSIDFromProgID(progid,&amp;clsid);    //根据组件ID获取clsid
	hr   =   ::CoInitialize(NULL);
	_DWritingPad *pID;		//接口指针，可以在tlh头文件中获取
	hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER,__uuidof(_DWritingPad),(LPVOID *)&amp;pID); // 根据Clsid和IID创建相应的实例对象。
	if(SUCCEEDED(hr)) 
	{
		DISPID dispid;
		OLECHAR FAR* szMember = L"OpenURL";   //Add为OCX中的被调函数，函数原型为：OpenURL("http://www.bing.com")
		hr = pID-&gt;GetIDsOfNames(IID_NULL, &amp;szMember, 1, LOCALE_SYSTEM_DEFAULT, &amp;dispid);
		DISPPARAMS param;
		memset(&amp;param, 0, sizeof(param));
		param.cArgs = 1;		//参数个数
		VARIANTARG* pArg = new VARIANTARG[param.cArgs];
		param.rgvarg = pArg;
	    memset(pArg, 0, sizeof(VARIANT) * param.cArgs);			
		_bstr_t bstrUrlPath = _bstr_t(szUrlPath);
		param.rgvarg[0].vt = VT_BSTR;
		param.rgvarg[0].bstrVal = bstrUrlPath;
		VARIANT result;
		VariantInit(&amp;result);
		EXCEPINFO exInfo;
		memset(&amp;exInfo, 0, sizeof(exInfo));
		UINT argE = -1;
		hr = pID-&gt;Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_METHOD, &amp;param, &amp;result, 0, NULL);//返回值在result中保存
		pID-&gt;Release();
		if(SUCCEEDED(hr))
		{
			CoUninitialize();
			return result.lVal;
		}
	}
	CoUninitialize();
	return -1;
}</code></pre></section>
<section class="section"><h2 class="title sectiontitle">WIN7系统VC6中添加OCX出现“不支持此接口” 问题的解决方法</h2><p class="p">在WindowsXP系统中，VC6可以通过&nbsp;
工程-》添加到工程-》。。。。。。添加OCX，</p><p class="p">但是到了Windows7系统中，无法添加，就算用Administrator，也只是仅仅可以看到OCX，但是添加</p><p class="p">的时候提示 “不支持此接口”；</p><p class="p">还有人说 可以尝试重新注册所有DLL来解决此问题：</p><p class="p">for /r C:/
%i in (*.dll) do regsvr32.exe /s "%i"&nbsp; 或 FOR /R C:/ %G IN (*.dll)
DO "%systemroot%/system32/regsvr32.exe" /s "%G"&nbsp; 但是一样的问题。</p><p class="p">解决方法：1：在对话框上直接右键 “Insert ActiveX Control。。。”， 这个时候类视图中还没有所添加OCX的类文件，</p><p class="p">2：然后选中所添加的OCX，用向导添加变量，这样VC6会为程序添加这个OCX对应的类文件了；</p><p class="p">3： 删除刚添加的OCX关联的变量也没问题了；</p><p class="p">在XP系统VC6中，如果ocx添加新的接口了，重新导入ocx就可以了；</p><p class="p">但是在win7系统VC6中，目前我只好，重新注册号添加接口的ocx，然后新建一个工程导入，然后将生成的.h
和 .cpp 复制到原工程中；</p><p class="p">&nbsp;</p></section>
<section class="section"><h2 class="title sectiontitle">参考</h2><ol class="ol">
<li class="li"><p class="p"><a class="xref" href="https://helloacm.com/how-to-call-com-object-from-visual-studio-c/" target="_blank" rel="external noopener">How to Call COM Object from Visual Studio C++?</a></p></li>
<li class="li"><p class="p"><a class="xref" href="https://blog.csdn.net/zj510/article/details/39494873" target="_blank" rel="external noopener">IDispatch接口- GetIDsOfNames和Invoke - zj510的专栏- CSDN博客</a></p></li>
<li class="li"><p class="p"><a class="xref" href="http://www.voidcn.com/article/p-ahzhvchu-ru.html" target="_blank" rel="external noopener">DLL中加载OCX - 程序园</a></p></li>
<li class="li"><p class="p"><a class="xref" href="https://gist.github.com/Alexhuszagh/c231052cb6e51868215608305fe4e797" target="_blank" rel="external noopener">com.cpp</a></p></li>
</ol></section>
</div>
<nav role="navigation" class="related-links"><div class="familylinks"><div class="parentlink"><strong>父主题：</strong> <a class="link" href="CPP%E5%BC%80%E5%8F%91.html">C++开发</a></div></div></nav></article></main></body></html>