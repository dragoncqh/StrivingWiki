<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"721316da2f1991178b8c6597d433e298b2f8623fc7a29bbac1dc74244b5db56db654eff1e56f459373adb2fd2d8083aa32603b15dd15c12a9de2a986b17447ce09ef2402e9c257be06c124f645fe240d09ebcedd0a3e0826e14b15bd54afc749ced6da03d577a9bb34119275b63e657b1373b4bceab55a44b17f0e2500cd495566968ee94f087938bae097e701bac95d0a17674bdd5b35dfd53cf3dfb4492fea208878c8751851e89e169bddf7c06915e4c5abcdbbff905cb47f20d9013fa5bdb5d385d215254fcac397810b2dd057ac96524cf2df949d73c717573f2e6ad646a3c93ddc4a030661a40d03edaff8e222589487d6dd39f49e2d8b7582e52a8fce3b4be99495aa7b08cd19fdfc4bae64d0929de8267726ea629a19bfdacf61a2cce58e72b14c25f933f40a4453ce029248611537508f4b3037b7669e5719ac4679de125c136137cd2731bf2ea39ab1e47c0b44a681abbe068abb70319d9962ffc819312f7c28ec12bcb728c7bf37441a72610d4a00d5b81e0fc3f33f3cf838671025cf8c560cc6241761eedad3a6d996fea1e596092639213b9fc41418c3345497efe2766da41f8b89455a6b11970611cad16ef3a1787e4075a533bd5097fdc389512faa656fc82fb42375b9c1e16c1de3306f21846cb005f2c5b6aaeae5099d14bff3f33cdc891ba1b0191d37a2838349892394a5d021ecb2a94d45b98c8151d257fa0569519f7ee73172219d021f1ad2dca0525127dcd6a51c74024d0844b8708cf034479b28365cb0868ccc495309d8aacce3dfd94d8ce61051734b6d0f4e7d769679e45bb4d9b19a62f1b867fb0f688d51cb7621bf5eac1f27bf5459e00e541e44dffeda01ca20c789ac13bdcf6055f1ef6b837657e7374af8098709a1f4206490afb24aeae346eda3f8d63cccb2981a1ae370428f44dff2097413930e7293e68b18bdf9e76f1520d3632e0ea186b0bf6363b7c3a1b99d57b66e58bf51c1de78c0c911f11cc6180cf3f0327c21b0fb67fe661b853350c1ef4bbdd0256274d11f1a5d17d6e9537233ed369ca25d842a14425caf4d78a91b00196103cd055911d5f7a62337ff7ec00f48fc3700130ecd205c504d2eb2cd0668ebe17af0fac3a598e5058ba80cfe84b0eef623789943182bb258d2fa727bb836580251809ce96a1de240debefca4a38fc5f07ab92434122c031db4e0cc0b6debfeaae5d7502e97e1ccf1ffe6bc740ff7ae55d4b60843ca6cf2f5857de70849f8b3bae42e033659d863cfc89076a34eee1251bda2f6bbb5f9802233ee158579b7c45f74a8fc183f7c949887bd6034936c5f050657d653c13bf210278f0fef19290fc702665e61cf43a78e4c824196fb3817d13385e9204aad63a80d18d275177b097f2f2f466e3d1bde828ab39b997fd5d6cdc8c75631a58773d89fa9d0e5001fb027cf20dad41f2f4dd413d33d8c114996bd5681c3a28479e5a3b18d1fa30cd17a4317c5259cdf8995571f64deff3a7e2c54f34cd055c0d62d22cf113472c0476e5467e4755a192de6e69de32c859c87eb3fc96c5b58b78695c5b212fa44a09220119a4017a15611c9ea32c60f1d81556b9c0688414b6f8f27b1f2601db37f433b4d27be02af6f48139ac7193c262c7d1cd241004720cab6153abb827e3c9d6be67580d759a322e63ea777cb086440c50a98fdb8271bc343d6bb1fbd6a4160be0677cb609c7922c0a565913d3da73bb03c8b224c19b302bfc526257a0ab9db66cd7a141fe7a08f79c31d4fa446d3847f90976fff641818bf6bbfbb3d7796be1211573111cf37adefba3b6e4072ebceef01008a7c9baa505bb9ff7f49ebf4ecaff6d513322bff48762f265bd029bf265dbc65e123877ca12d17c955fd21b6449a2f6654886ac992ab392a44de27fca43ad2053c21e8cbb3013e445758976378b2fa93cdd0893c6750bae61d638da3a57b1cf0ea1e95c38bb041878345d8906ea84398aa39e9488b1d7ca1439f473a29ced0eb2162826c18c5451c400b0e9068dbcfcb1dd43d9f56bf17e5a2d47b6cc2c2e30f7c35522b34d54cf802dabd852819beeb3505dd54041afb42c4148067a0eece0da3c227f4a7b27cc503ab7836597080084f22fbd297d82890fe02df9f73c99efd5f98cf2b04718ee302faa7edf575bc649f741935690bef4130a9f6bfb146edbaf3d7ad8fcd0eff8284e692a0dc2181350f4ef054c9ac9bfa20560aca28dd251648f5e748c5377666ccd779bf8d6ab85174f3957c9a6546cf3a6082c65644fcd204820e9f7588a759b7747390ca2b999c1eae79c03da856b32a597051dcecfd44cec0e7b9d4de31b8582222d1c1c9c4d1d7995e9cb3324646c42811ae2ad99c8f1043b3e60278ba42fdc80bccd12c62df308926b307086888f16a554c3eb42df893beba55bf40864ac044d4d096d3b8f3fca1a9fe74c6567f1ac4d97c1acb24792d39cb0813b75b8be45f2e317c59c01c4b6c9b570f239d3bdb128586885700c1578fee0c40007d34acb09021b28ac97c3f843071294fd3572a12bb50b009963dcc59c4e90d6b740bf30ca34680e50f3ca794eebbcba80175600779b8573aae2392e61d8d923e393e2d19dc0a1a4385cd9cba2c0873dedf6e4b686e0c3e24556d9489872a6b7eb6d1f565a35a2fc646cb1971198ea62ad5ed80ba703167553c10fdda7282514a7556049f43886facb62803c8ba0dd2d39f72c5fe56594767321f85bc6c25d3174437151fed070fe81070cdce17032e960240c3255c94132a0974dc5d8e334a3ac31195da889aa4d532f2b062423cd06008144df31db061144233b848c1dbe696876a5e987f451a8f04d043249148aa8e6570cadc1f1d0496744a12cae4cd94b15873de41c888754c8b6540b58af98814e7f994f57e5baab05f537425d6aadfb943a517c823a86340714368ad1866ca57ac03a5c590e6dc3ae1eaee621d9d259c8ad00809fb0bd31b3f1371e9529ca4ff3e72cbc68ae6781071341ca31777a0035712f6b98ed67d3fa19a7922a2b39f9ead91bcf75d107745206b861865731a0a591c768e885260f1544a22be42faa18f2d4525e1ba5362671117ddeb9616e1a96f36d9fdda0c8d7ab36b0268feb6d05db46d1fc979ebfae970cf7c5c5f703a1e7d9493c5203eeb6f804c86a6c390bbc22c2def50318ac9078afe76772e3a05dacf3c566c5bbf6e96923bf1090845966155a234abe4ac2eaa007dfd403d3f96f4cd605b8ea9e64e0a51642e3cd8cd87d907d5da5b72d6ff739ae68db63f44ba863bd5dca51a66d0f051823b14a911a9df4e77e890f3da16f14ab4f1a5c36e09aa43c5e0bb32adbbb27e46a7e9c8337696e75b665ea61257d9c29abae06d09fd154d841ae98fa8eea7d3caebf8bd1549425edcbb4166484b1d317a74953c80187c01872642d98b6f200123463861a62ef79399449d0601d0229c6785d166d182eed5527c312cf970409baecbdebac36d138ada6cc3b14fd66ce571a09817bf393969f91492fec0bdbedcc9c75ba847d18a2d50e857a14112821525d0318c11a97dad71fded15af04a48cd578b2f29cf1d4502f00d8e9e83d68e5037c26e8c69dd772a870033d523426384a4f84eee2d0818105dd65a1d9b3a5ec6c3db3ba01f9786375e4fcaa6205122d33f519cff657e6906fa4199350faeb17f231394aee3544a6ff6e37ea19e7a7b9f7398a7214387ae559d1a95b9c92064bd1eb3d9df8fa28ffe8cac186994f71a9768eaaaeb709b79e1e75e8ed210cbcfed1ca7a7a5a289d937da9582cf39ccaa35a66ab022406be13fc2ea19cbaec1977d2746e041fede5785ece78bd7a176cd5fa247c10133898a8b442704e76cc50157f8648c100f39d0ef70cc6e75d0e38954f5e5e748bf70c780487186b0b110f261405e83e42e8c2a07eb91a977c8e91c6a7bec5d72a4f76ba24a0c1ad0f8306f8953e1ad9e90576ce7d152c3b1f5872963cd8f05014e47500905ac5f25403d0376cfd449b9616c620202436dd9ae84d43607e7c24ad91d37dbb3caa16b9b08d0f60a6986e41ae6446e2db7356e9e7b89bc4bd81590340010e586667f83e2277e563ce0b07a875dc9498f9c8e79685636f8f4488b6eb9669c3867e9cc52e70cabb211ef02947499b5fe22357956ea0ce29bc4f41f130c0c46fe5bdb42174df44df7ff8af0f8c31a09960605d7e301d54e8506761d2ced2de3c8f134c8b640d3f876b8da4cd9423f270cf3b50d0b702fa8558a1bb01d788a7511af6c4eb131882228e811d9c19959e928c3092652ecb1828526187814d971e746f6c09b37deb4fefe8dfb4603666bb896e199868623e9c47100c6aee82c534af5b590127aa72e398e6de4192f5a4e8ddc2d74444f2ea03d2ba7d7ad9b402bec1d34575e63bf3c865fa7b22cb615d49180ca6363eeb23870315357746e97f7d17781a5bff42b92f31602b656f88add132edab218e0bba72a2fb66bcf02e7d50124db770206034cba864b48da488213ec3043a73fc0a92b989c3e41f3e198680399c11a35cb9b267664b3f1f239baba64c9460bd20351e8fa075cf1e6b6e252756d0e77dce1aefa5c741774f9194eecececb47ea3ef53ef34c430c0ed40a1a7ad44995d3fc0a6b487436f5bdf5b237049dbeec6dd1f4bea28c35c6f61a1e4bba7da361c6a0ffb63fce049c0049614e5b456f8116c3e5a15acaec3c2f8e807394047e83b55d0640233451e251b408a3a7cf09e01ade46c043d235b0b840a7eec330dddbfe4f62f1e7535f3d74a4684c854772800b447cd6f84732714a7e24a70fe5455a2bc6f691261bb8581d6c85ddfa65a85accbafdfff144f6d0eae0e442a955891d47c4c8036483288dba395b33dfb14caf61b8088fba585f0c3a2a60716f067f2e415a02848391fe003b1b04351fa9af7f8f40a83cdbf4435fae13f382c9b5779ad6216ac004015e17e8f4a1fd0e28dce82a5604471da3998d468b745a79e8460e3a6a2af05c75d39e33f5c0c2a9edcd8503efbe262007e232060d2c70691c34be5241ef72f4b83317a99d77d712ad07cdd955c51efa089f132482b6728e753461a50cc219bbfc04258ea99d21001f3128063c9ad421d13390da06630da68e7aa5347a8102d993b5645f070321378fd60005f339f0c16812051a290d80830bccb0e10d97380ad8293f9049dbf9c783b8b7d44b38363bfef718371651c28787bae34c14de77d163b714782959073955c104b75019f600ed6cec921b96912ebb2b929617e30179e390259db0e37f60960c90484be86b72c5bafd7f1ab7daadbd1c7b82976c80c387223c1cdfd216a9b5574de170ea444364af21af66013995030f80a013faf0fb7719f3208f6ae03caeee9b73a533b7c85a2acc55a18e584a2fca61d5721b3c09b754d5e72e160a796d6b75f4d9457f845819120290917dfb04070ee3fdfd1f74b659993d923794de754690ecce9ab7e07a4b573f24a70e24a30fe586fde859d92aa36f806283fb97c8368a9380f5b3c8e80472efe2c20d3d8af506fe173ce0e79b21b604a64de56e294d232f044f53e6586da30dd2550e268c4435ccb38af0a63c989f2f614b2edc00c5aad926207ab7e1759ca61f8012794c1d47b500c6a9950f41bc6f3d4358242b80f49c861a14ea8fd78ffca6e04871c94bb322d9bb1145de5aa35c6c42332a7a7fbee8c48bc2ab9b4d1014424517457dd33b8506964c0a7f02e23d0e0f397a52c4cfe50793bd7f21fb1946596294752212ade3e996b7018dfae1df588dae31bc2f19b47a2953e6fd1a180cc74411440b4f0cbe2d45702466e4f5d9f261d8c18a5da7edcf79bd224cc5bb8bbeeda38677ba7859c281075666c54072ca0f5e8247b8facdd12ec104d5e01097ceb15406b7c49bb7d4f8c47995966afd861a7b5360c1fe210e7b96981f99bcdd1d0178a92aa4b551938f6e383400a739acf790c9625168d648695a07287caea68a464188f9276413b9513f8052904e5bb162a7a29685400ae4bd15e2c630d37b992b4fa4dcc0a7664a205ad165a085f7d240ca613433c6c65994faa11bf6aa30b9707aea069d20eaf9cdcf6c2aceebb6162009c0e23f96bb4b3652d4eff0954d9c96fd13eaaa34101184c054340479a1cb3060a844b18de49cb7183f2035e6239dcd92d0cb57bf20197d5295e34623b8b2a28a3111f24a0a21efc5d54e8e4d83d824fc93af637fce4c8de8abd1335ca223dcab98b6d08b0c4918b4a9dfca696c84f97c9baf953f3375019e39fd28d30a46847ac1c57fab8be80c25023e04a6b63b208490d822cd9d31c1f3fefa9dfc547638a63db78dcc962262bb2a47fc860c91e0816072bba8bfd86eaeb36fa3da64cb243cff2810a32e7663a80ac6836229177a67a5d6a74b7dbbca298c94bc56441168c2a00af3978df1b8342d176d245ef4e768815ce4a46ed23f9f36ede3131a52d09a696dd15e706cb65f45beb9502cd114ffc993a947edc37ab69081e12d543c2b9a241124d4bbf16c4e652239a6c976457ef13e07bb0bbb24d9d7cc7d830809144541d1456b8fd423c07bf533c5fe7e66d7f69c617330a44a394da25da3c46ccf6b094a309ed5ce0ae44a20efd0f4ad90c205c0efc44dadf33b9dd408373d79d5f7f5823fea494efcef9d417b563437e41c64c979a3914ae99f116ec0680e12d25dd07192bd1dd8d4b7c99cd889671ee74d046dd8961e23b87c0641501bceada94643bd0dc54a808b236ab82bd0f5c3fd8ec4cdaad07f0c05904596c57f02c52df1342e816965fae68eafa6ad13813d75899171a25bb74f7b10a893eb141d1d66716510abf3b6caf037317f9e4b8545eab14f8ad561e8db0f67ef7590332630928a6d1af62560b31eda104bdba3a5e31791e8dd54a23f3516c9d62eff162eb626f569de5a8a2fd6cde028f4616c06d4078a4e371a95076d29417277140260b92327be0cd0f673823ea00b74f5590254252510e5dedc8f119ad4764ce20aa22a2ab802e3e437d70fef14b94d1a165d744b373820d4c033400f367e72e8325b5572dffb4c8def32e87c35fe756dd8594fbba967e47f16f5e4ab896ccbcbf710d5110a614e219ae677e7ca7374fc379719ef669e255aa6b1729015f5e2ee09af2d7dba1cec43cd05a562ff10d60181b1727c0fa6b84bcdbb663aae6e66fcb1e146570bd06e06f9079e0e8095f0f91b599ed5d72afc5f8e3162457afc763a5947b0c8cbdcef397c0c7c3258dd599699ab0f8d49927295c695319bcab4607e72f25754cfe228211693679f77e83da0e5c64a49cd497fe429832d20a426055750e80941dcd5109693979f087445f73fdc066b6c94efba070ce56d78ccefd2c84315ea47ffa657ff544d7dfee84b76b3c8e2c7090d95bf2029e4818080cfea7b33e03e6eacc57af9687f85df87db210f00a0b605891c38b1b6e8f311b71bde772d504f69c5585729339a03193a75dbaa92882b2dd31b0b5128f2fb80f5e513bf8973ed40dd98963d3fa1cb3cdb328f0e8c8fa9cb95210f3ea1809f7a3c82eaa290863b7ff9cd408e66c519ae4314b5e1620bae044589fd63ed88eb13cadc24da30d955ef62b83e7cf288844867ae89144bf9b142d19e379e1aedfa6e667c0b2825c7272a58bc995064713e7528486fe5070c598c5abb9ae6c49479a48f5b1134cac5927c88490e067793d303aee7cf67f3a3f3d752abcbaf7861dfb6b68d971fb2f8b3d56b086c52c9d871289ed4a1e96ca3d119e5108f702da98c9984138f9bf91209e3865cbb436ebb943dc2006cc415463daa901d0ef8c66e47aa844ad45ba25180c8c503aa6045edbaea07b6cd631d66c4c98d7b2ff75efdca66d820792e1eedb804a474203843d9318685094fc087515c09f7692f4bbc02d6fe6a4f5591239f882a142d9ba96e57d4572321c8b09ffffc0a03070240cc4efb8c57ccad9a9ce89720008ec1101bb130d26a67f585b65839065a922931a3b24ceb120e39d88468a38f1ec55849b91cbc58ae4a1f33ce7beee22112cb1e44e68bd8467f1c332e11acf29d5512d7d849f21b6df38ab930eb32d4bf62854a600f0b3930d8d61f2ca06421babcf84a5b17a932294911855b752ebcc02c317769d2c3bcb0a8d68bc25752098f0c2d1d2169eb5b91d6028cbc24e86196fb4a46254f69338cf0c540b513ea8341ad882a14bbe8a35f23a4dc962ee2ff2fd8ac3e330cec2394af3e723ae7155ce273a2450c4e59244c3279c5f2d5f0cc665e374aa8ab809ed7f4af3cfb689b76cb7962b7f2bcfa4bcd0dcb6a09bcf159c3a49b55a483e49f3e51fce105a30d0df6835efbb9d9c51131953a7cddf2d8ecb96d56f7d3df727ece34569b12e2ce6ffd7bfb6ecb187d924ef662a04001521976b97baab8f8a5e87aeba4c71fc1218a6242892e8e9bfc329d7cda020608a4e7f74785990b1c947b62171e1bb9e2e7d5ef2ffebc22873c27bb1897279eb8aa5319e013327b66bb593a7c2f109671d33a5b1c33f43de89d1f76567c576b51e18f8dc3318171254b94d27e02154a8d4ceffd40626096972b851ffaef0504e1b18c36da02f14872f4fb690eccfa0a461fdbd76f6452246c8be5f111a9e78cc6c67bc94a76915eb1752a82d6c3a9c1784a72b5bddd523e762bec3b9c4dcdd0a0ed08d20a6a91dc18b52c0a48a0c4cd55b6bdb4a9eec55dd14cb9d3424b83beca4c978d7a46246f74cc4d5360fb5cc2bfa8120453c5b0e75a51dd56c0ead31a9a666ea6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
