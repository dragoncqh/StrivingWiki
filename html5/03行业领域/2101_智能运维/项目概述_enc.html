<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8dfc2c1e0af32f0516e68c94b232825259b19646b81f0ec405f4c91fb7b5ab1bd53cd0e2bcedd95749b92194320369d574a06d199683a9d5afa590ff524e7ed9767a09a8a8ee659839c476deadaaf16dcb07f7857a9ae1b1578343d8a272be6591c9fccfa33ac31fec3fb6e5319cce42ee68297bd5f63de43a997be71a310a1959e57f67b4f21fe282fd700913cae7ac8cb29b962ac91909051fa938e895e7c1765c4ae48d34ff678efbb3e1d6d25bd5f33419469f3d27773fbbae794d8cb67727c975dbf26cd3ed7457c4abdb0024339aad066ee4c155e25e550dbe368a3eaa65ebe84df5b1d30c6beb9e3bc79eb4fc16960acf37ac47738204749de5079058be2dd851aa711f8f5333cebf16158eb9ceed2285f099133908dcb08598fe72d58fc86bb1450398392026dff7f90396538a57244ff4640926f40264a070e62a57a6bde5f95dba7f0e05e4ea1318006774d0cdb55d1c91e06433546f61c29151c45c4c19902f75c4a01cf8385d8c21a983bf17aa30846ff61584b60433188f5689fd271aa5d252cd8eb1574f06914972a3d31653eacb112d1708501568be2b3983aef2e22009d2576142c9debea5c04897052e4a359342666fdd30863e02a4d44a6268f64e0a47236b96a57d7f59a66e8abdf7b17eb1181b9b7104d25baf1114e32f32cc539bc2e452bf633ef61187eab7f833aea670a06390bf576f2b3b58fbcc35937cba668354cbfd244e0c0e8fe9f0b852f2ec8dc9907115a5e8c8ac84bed0182aeffc32c146c86b1430e3672e525c476de5a43b7c05e09058ed8479ac83e0499e24edb55a5b5e8cf14e717920be217811336906bfabd8137c7147fc67fca520776a999bc0ea998ffd207351340c795ac261650a592976e3176e32b502ef52d0677b044251864393f2cb7db1d60a17b5ec64c058c8010e47a758ddbe700292a6da88165c01ff2eb8685e9d1fb80c86d3eea3471a7bf7f7dbc53ff440b19da3860bb01a763488e5f5cab26aa4f38adca4a3cdaaf8c5f81f5e05ee27030b7065532a3131232aed019a5fc29a78161dc83458d76e3f4e95c3f981149f29284d839ab772be7d9b428342d54391b2250781bd61733015cd210c40b5489460c8e6dd6f35440c6d88f920d3858bc017027aad910b4730210fd4492c1e0eb399d819d8fa3fdd0e6d87bee4f71182742b0bd4af637035b444b27dc1d83657d5a2594339bf1bb57cd93227dafb5a75d266b9dfa46fd176312410a55824edc4eb9c4a7ff4473c8f15eb2bc7050e9c091774e4aa428edf4c273da717397b2251f229354f5b926c5b98c31a426d9cb19531e0f87c84afed263c84e613943c4f61daa555c6d16d693b6b4bcf673d46387c7767086a8350e506bf815cb73de76b85a8f1c2d6cfcfe9e1b38bc4ef0cdf0c77331f6b15ab9511a388374cb41178de7f6266765aa6239fbd6fcbe28efb168091626ca4573015855632525ad74c90852527ff1f88647132577f86972e9454bd7c6ddbab5a96b4c87da5122e39e55300520424b9b03695fabebe64926ea0d63ae820d844b0a12a12a4b1b644c4776093538fe8968b20ba4d4eab53d356161e68f72272b34d99effa5c42884037e9ed8de1ae3affddca150e4ea73a24b32e584db4f75be475b0a375e16a3afc98517f6d7ede5047227130d372b9834d9e6621f6aa5dd0145473eaad46a809ee0368a2c21b662795a34aec8aa9904d7e6b61089eae6bebf94ba6851d27a5e1437a52feb5b47e1ec314a4d563af5a0aef1ccb7a250b9c219b517991e642f6255cb1405122fd8af6407944ec2d15658006eef9ee7b8a0548fad1c95d9d0a32d5bd7606fe599485ed7f74cc0031136342fa62266699cb2541a6355da1d03022973459670ee144c07e9749eefb2f787adbfb30de68a64f2232116e7600a8c70ffc3e470a481287fb427276f2205b92e02d7e6ef32d4227149b3c8911f8cc3a588378464df886ddcb9af5a2049fd6ad28de5411b5f13e71ae03df08245a6d1447c9ccdbdd90ae979afe21323eb13b27de82b7a26801d910658b9c5241005605addc5617e634f4586ec6bfdf3d8a80b959785a54815f9e4b5bd61c61a4e515288bb47d720a0e2abf362728ce499c78caa9b5b8d245a963c424512a14cd4232957bbda3b810b60d8d060da643fea01ae06e85c5e535a8ef9dc1d0718551c941dedccf4621ecdbbc9339c4874a7afd3150fcb78dc2fc51ad2333a4da84c9ec2f092124de1892a4d61b3ab2b0a70936e3a93220fd9cc5d685137fc2b8d43280d940df752e90fc7da8d2a5db9406e48958ec860446bc91a10e534b555bf3413e07de261fa2781ec516c551f281bd7ccefcf2bf1204f66f981a3ac75b3951a4009378d8008dd1c6f4ebc7ad3a843a1a15a78f15dff9d052b20036fc135b232eb5e8021a22c185ae0d01cd575646d4bde119b83c9ba071036233139959e77c05e7be703f2b135d2577ca8617a028d1ca91f49a7d2ffb02647723867195aef77137fef3cdfae5cca91725275ec485109497be6c63e4648f487f62ab6543dd95fbad9c26c8f9445d07ae30d468357ee28f58948d86c3b33cc6152ef63b7414b818d3106ea36f9a06430f58530a943ddd7f13ed77c6b652e8daebbd2e2c8c264a6af8ff90d01eb07dee9d8d05e0b4ac3126f359b499533243877314c8ea006445bb344a3d6d8682e607b597739809c1c4c246401b4090e7225c7d43afe52b197ebd17f2e2195f9e7dba74dd39415e679a1601d8151d46fc665cff94ef81793a775b551dce7d7b96dec5e35b6285c3b172faab0f8b3e0d3069a7fb2beef04ea2a9475b46890fcfce38c51202bd2793e44ce80aac51c4fc053b1c7d5e504e2713f2614681d89d70a1cfc2136f3c2a2e91fc795b4b0816415b13e599853fbe6b5d7083518fa25483d4fc3f36e2edf112f7382d0a5c0638def79d6c873f8bea7c5b96de8baa22533cec01d21404604aa108a2a31babc2ff5fc55cf7083a5eb6dbccb94b7f05631fc73d59b742e66d01ce757022c037e0b68dfe988c43857c2732fdc0844c75bc457dc5d0b1f2ed67006b297aea7561c49c9902819faf464f6f96fae2236aee79fe7fd6d7895886ec6c9079dfb4863c5440bc2ba64eea8051e284b2437227913a702f509b88de379fb70dc570689764002e21575fe2a5b46d7c8eea9fd4fa6f6b0eafc2ef406218f261641958a66e521c32c18410d81045330655b04ba2f1231054608db6155014cf5cb22153c1fbcc5e3017f8e13ddbb2ecdf23efda8d4865d4051e8c5bf0be1788da1755032802285c560c505eaf822e09a66c6953fa42343d1875d266a36f055a94dd543fef234e98b35673d43cfdb259a34d9ac9550fee44f96856de61184d3a5d36f686147ae0fae4c4df86ade657779d827bc8ce7237a7e232f7d0b380b6915b8b3e5e72d615d9f8f9b12a077e27e519c3b2635f41abbdcadc519aeb603cd9ba180e31292b9200e4a2231efad4d8382e5765fe6ee20f59fd4665fc62861073031981d0a0280683fad462c424d534870cb505606cf86ac5ee2529e9a6979e4eaa6877502dc8e2ceb974a0f860f6d55d1b951ca02accd1e2964cc6bc708ff4073dc3db8310ca30bffa2f805882ed467c0cf7fbae50edda0255c2dd18d93cb40999b36aa6dc8b0b21f3bd6cdd755134dd23e1729f13cd0e0564b33326863520684f161b959e0ec3324e409faa841e3c373bc1e4967b17d1f1d06952a90520f29fd4c0a4fd392ab65c5436e2af43d0b3a8d316d68a4e2fc442d319ae9a28e2f64f32daa199801da0e189291cd0da063b2437ad16294cbecdfe7b2d7969c5f2974de5228cd5fbcf4d5b8219efdc0885dcad936d9a5fbe74b4c9205bbf6c6ac073e6d5f6f61716834745f12858ef523f6df443b880b85dd3193e1d475366f2e74d977df7897c55eef94d2e0d0257aa0503fb9892f6bf73cc2d557b979e81dd9bebe177072288fb3a56ad7a1ffadc0694243c1dae7c720a445aafd3fda330a1bb2adca1342bfbc92cb9a3a71a8ec43965fab99ab33e200d8d16c53db14fd18860340e85f850b5db3070dd182d8aa69edbc83671e37ebf06833a176805a3b2ca8335402965aec0416b1bb4440f349d80332300929a9ed77044b2f80f21bfafac37537f21e218971200a1a4c3840abbc90c801ccd52e11a847c30dd205e0c8cf93337b31cb8be7270cb69c457b76af035ff4ebbba034c8a35a0b554ebeae8d3baf74e2d8f3f37b23f22945311fdab685feb503b551db9e857b44394a0abbcf5c45e2d75240a8cc83ac547b4321b3d6445a5d9182f6f4a6372406d89bc4faf906e64f5e492808ab08e9895d9d2006125f55701ee105292d28d1ff2b64c0267624c1efc1a6b31061628ea615e5866d38afddcbb93fbe974dd416aa3ca84d9260c98b9c9c0a6f754cd0002f3c8e43d55b6f113d18c51927e6992bc4da9bbb9f8bf8c470a899fb782aebfc4991b4f19723843ad09eac5ff66d6b3876d2037e1a32b40b0e5d8ec96fea35538215ff5a248ff60de2cfad9ac3421562eac2ca085fcb3ea3f6b109532540de7fcadb18bf01a3b622d1b7a9e90dc18149a0d972a9464816faf6c05348c0e6c3ae39cdb7041e2697363edccc64d189495aeb2bfe8ed05f18c19a966f5f55ac95f37e17ae2122202d393fd3bd4580c6a4454f3eb9e5ff2eefb55b3dbf4ee0460e8ea35b49b217e7b258a9ba8c85e57762e996e4fa21cdbc29b69a3eb41efec3cbb11ca316418c85e314478cd1df340f96f3a74490a82fa8c9ad77b409453ec04e22635a910ea89794e8c67b1967738b123f8f97e1baf20c6dd28f82eebec5a61dc644ada32eec346f76a9e8faad835638b3d3fe9d1d318f3c45e965adf71e4d5e8d5e93e84eafdeea233df28f75c319e60e7efb258638c3c5178ddb1156b7b213e90806bd5a765dbb155e3e8d6cfd180996be9ae4f4dcbc82f2b95c034749c5f5360c061961fe1e793c7dd7b89730b7737da9b1ff7bd4f01fc6fe55d811a38dc0a52f40d18b7552fc175d1950a8bf49b5c96d443890632a2c7ed306f7d28d7736c5ce113caaab322f074a96beacbec7f5fb38b91d32bef4aa7d52303a254b12e74bf51b37297c79db38be801adc445189f2a2c7a8ae3fb41c7598d673e01b2a2b10d6ed6e546fcae59a2f9f3d65cdfc4fd980a9b75bdaa742e608f179445aad5ec9e741356f3824ea6582c8ca69b7d84c6fab409b4adc68821b96d679e92051234cc8000e273395164890cd1749793e7eca67c82211c6e40b678b0b63ebbe515017693c0eedc4eeca0a33b3551b3808921e292d0e4d21fad7319fe1065a80b5550cbbb19be36942d90c2cb35f03af1330939801fd4920b8cb24a0ed0ed7d3e461f114bc513b4fc0cc0701461ac9fc73b40c5f44615cf0b985662aeff42d97c447360c542d9608dc61616dde973798600db5a404b563c7b5a0dc2bb511cc3551bc994bfd52fdce20fbfdc8dda7bf233e9059b776479edd119559a2aeb4901dd2657f548568482c19ab043d3fc47833be60cf4cf993a40456a8c0f6651fc4c6cbadd655661b47583a121c45153249f4f0a35b6850f8f18a392a0915c7364a69f30911540c27ae68c0610c930bf5d021356af24b4b8cdbd3a0e585d2da2a4ceef1f2a9c7423a894b4ef106c1c15e31da13da36cab3d2ea2fdc31878a7591c70720262cd0bf0e8c4e098583626408794cccfb9c1d9c958a6e8746b1a3c285538e2194e1ecc33f84b6219329ff654e4ba712bcec526ea933d8723e6733a8b8a60e365b9d0c3a39486d644224b8eb43185823f045c745f886115e7f54fcc24edc877d921f7a118d10ae6595f8b51256d10b1e64aeca341856f236b9c0d2715c9ba3d3a787383bae62483dc988d816fbb197122ea64e4e637f1c75ce33406273bf83f68d9251f44ebb364433b753f6cc32a630c1459c986e703067baaef313c7c92707574ddc246df22f04c2368e4aa7d40daa4db92455783c1a468bce99333f1dd432d1ecde202f527540dfef19b1e3fe0a2527d5ec0abef774efd3401e4bf7a99ea403fe0ed407290ecb5cb57216395d5390822cad6a33594dee05e327dbbfba20959cbea68959506e3928e153c15324e9a60837fadffad37acdc4eec047c1119d817f2da2704d8432c307264fff8ce25578d0c367207938461bf749dfb05f340de3e0859276a65a53d3b9a4657950a109553d05249ae699d3646050bd492893ead2b2a3f5885270565886419ba713812ebd7859a1f67b384b32defaf1f6ec60d8d05b9fefbbb6640fb92096d805bcdc15544ee114d89f469786691f5bb198596648ee2996da08a5a593486d997ff34297aa4cf6348c68e888ad9d3f0eb9abbcd25cbd7752d0ce939162e3c80f32bd96cce12a0ab95a23b36fcd15dd26c36a44372f6626e20ec84609aced82a37d9281ebf7493ee871bdb862239661b281dc67bd1550b1c6b14bcb6162b4f684e195a102987b9d66e8ed783f9227144a0cb03b04957dc54771ea8ca6fb2f641eaf29348faa14554cc78fa1cd4ea514e746b9fe20f2a6723f9600742450a86760b3617bac8c47d273cb0bb3ad1d11aaa75a4b31fd726ae4d9426cfafc58f073ee2d22409aae1db7cf881be2b3e2e88497244a4129f6c543472cc446ff112f3c778893c907d9dfdb86d9f7d3defa7b32309f487b6e56b51e5e43288b293dd8221dafba8133f299d3e8ef0f3297a7854e42406e77e411dd441b124b12eac3943c733fe3a9110686d6adbd873dccf54c82128ff1ff817ccd45d16dda685606da5e713d1ff1efdcbb232f901ed9b2f63aa99d34310357e7323834ebd5a0fe20a2a7250f08b6b7205da1aa8235918ddbc780a06f75b22adb640b18c03ccd8a343f1ffa629d5ef60d6eec48a6c6e1af57c01aebb39e443d8d0933730c1395b9ad88d00f3a822267e7e754ae987254069d28d7c6e7b95f45b46a390fcaf227848442b911649da17f24413c482dcbac410a3a9400c6e67386ab441b1ecb0ce35b358f1910570465695f4cf85f48dc7244db2381bbef5c78c4205231e008a103cdb33c0920e477a384ccbcc6dd2441fd436510bff5c8911e0f1b964d59a80fb757ec1b5e18684ad0afd96a4c44a7a6cf6ce8dd71f84e4917c93f05d94475ec22c95a0effce0e34091f52d1822c04f43125ab24b23a4a7f2c5f3dfc2d20b77418fed0c75d8d97c3aefbf8f46d9666b9d471e22a8b7093cc4c00b6ee0ea41ad202d115f135ef626a8d7fe3950c3fd0c2f192a55c8bec5db0b5a2a858598a7e85a93924bb1af4b80794aee3b25618dba8754f5e902f00ff31b658798a3e40880ee545829288db5340c573064c44a03ff0a6e9c1e2f5630fb429740fff5fb0edc713ff1fbe5fe6d236971d63a30e9a2455fb663f599249c0b8b5020fe2df91bfb4e4581ea353f1909e3fd737c2ccde71e706c0e0ab22e9f70f6a18276bf3c6b404351db9b4a3112157a84b041b2c774900138dfd6c067ba8c5ce847e62a0462cce6161f4b1e97d67cfbf6a19b7b181116611f93637f66295ab248302154bc2b3d07698d78f74e3b915c939b31bb74127701ae50d54ba2ffbd1d6d304873fe82cc8575db87ccf1b4d9dd7148b173d1fc3ede5ebc8f7b59f3e43d9b4aae99c74b02217e0c6e4c61e8990229c9d8c3e4b28c5e9100c28c07166af85db07bef8db62ac0fee7ba4d05e4427e34f8f0be010d1ce57052d06e1cc9f289fd4059bf3bdaf670ca8a3a9714b1eabdec802cc065fced820dfb88f114e5fe63ee63bd5d508b2e9b7d211dc0afb7c02a8b8a972ccb29ac6dd0cec30e125d455ec0f5c849ccf258b6c43890ec68aa96c47845b5dcc2aacd4e3e62337703a4ac647f04665656cb23e7d8b704ef6fc7ace67ea019f9f9024549bd0b8407ab9227ed3c37510b458e8d8429c1011b22cfc0ae5ef1c853914cb207956c90b52493a3a0874fb2d7304498afb114a7418c7653680509314391310ccff15920b25fa8f8fe7194091e2290bb313bdf1cf295cf1e1b8fa8cac4f1460dc0ea44fc571314441baba73afe557316911f6962d3a0da96c6e4a969e7ca4f89c586d9a4d62d4b625988b18472647649b019655e92c3c57365cb37d8f0cf559e27af3f95c570cc3014581df7f867c43182ee05ccf8489d43cacd4b5bbf7d9e4cba12a3f0a5f6a642b62f62dccde6a2d025b59510b7f9f9c56d751c87b4bc391642e2b09118a390fa45e07548dfbe23a2c97b52c826a39ba33c60dc4874ea0249d8a5f6addf9ee88953169e3436694128daf25f9b8af4fe8b1a1c367d44073e37079725cad5e3861f7833f4ffade188895271374eadcc27b462ffa512b445cca0d5972aae583c829c16c1faca163dbc82ce218ed871c8fe2e127582eac67611507b97bbde0b2655423c565be775cbc6efeeae105339006f2083ead42f925f9d8dca55545dd80da159523d33886a5d9dee1781245ede2a5a7d5aa9d33f6db462fb4bb82ff6bf1f614fee8235f98e8148c5ff7e8a3adb413d2947ccbcde646241b44c7f964c4abe448cc588034bf2b99e2d7620c60306baf848193433a47f116197c98992d751d84729e8ca268ffdfe3a82cb4086b70c297421feaa037c4cc729cba7f66a4f7d5452d0a719a0262b030027201c45182cf0e205c7785b7c9ea86fcee10d4a0f7d8dcf19303330dd6acfbd3d029c88ebf1eaeeb4f78d3d4e0f412637a8a34987bdfb8ca2ad8068e95aa4558aab0729fe2375f6eacd665937b4a1c3ffbed27d982ff73dba6209a73d86b6c3c9d04423ec4da0f4bce6089e2f5b4f612b252831cd22b404d56900ce9a2571f90bba5ce51f21e49035d61e5c8b77335d41a7bd35787645dd5d40fa282e8ddce775771533f65ce069ad029ac55fe30d32be4766d9c0541a9494ad75cd5214b72c41edae230d70c47ac7fc442b9da563f9bcae9492edfeefeed89df2ea8493d92c686d5408070ecf5c935f9d8b79e1b36b224c8a257b31c122098e1b1bd7c868ca0ea8b33296329c73e9c35de7ef60c19ea0623a103f97a9417f0c48b71b329018fc111777cb9c114ef284a927eefbfa5e98b1194229689b85903e89abf35a011af27c05bc68169e21e8661940712c5193928933169c2f80a876029d162e5cdfe781411f407b0bea9fb131c5f1462f48b550917386b108d519da745f344c6e5caefac5a969ee1eb1f9f1f2397692f3094cf9156698cd113f64f10c0f2bf5aeef529d598ef8a5bba56caae043cc4bfacb11169791ea8a5d41f7bc5fe4fde87230d321f773f300744c1fa2a23eff7f7b6d0eea934faab6c33ae055d72057b6224fd96892a6111efcb915733270350ecf53f5e14778aa06f1fbb416bfc5e61aa27bd74d8fbd8c854409259d4bfcbe9fe30caeada4714401632f211d3be57996fdd012e3a7b1723b7399f43262f606362fecb4a1476c67e6555e4466cd5be8384f2a33cd8a284106f27b3eae57751c4d0e6209c4ec29d7d03cf017bef0d1debf5b72efe86d1f15301f0538e7a0aaab1165f9a2e8457fcbfbb00c425ddb87799ba880435169a445e2d400842eb38282aea7447b83d91a1a6f124e852038ef736b19112634bc7a48a4280a5544722ebe42ac61b7bbc5a43c96d04809dafdedf410affaa19a7eed8197009b937c479690164995a662f5ffb64b4891312eb3d9b3a0803e5c29b0245c3a84177298e4c19862cb4556862bd4b7e191504475b6a53b6feb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
