<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"49e37afb70472fce92ade732ae3e1d8252d2ea7b166ba2b5242f23901fb7fe96eec86bc1016f9d4827616ef8c73f93f37b2df893a81c0edc9f6b859572614517a732a7257454ca843e1b14b3f4b633229927ff2863fe5ec77ebaeb10e87f1088508289a25f4b022a83d7d386a53feee8ee540506f64e93a36a04ca3c271d5d9db618cc68865c07645748b7095b8c0ea9de329a2402954cfbff74788bc2bdbedfa6f3bf894ef6127381180f2ce96d0a8f553e9e59fd2d2b98fa4e871997519fd109107815fd4429e154202ee0968123b5eb070115956d20cf88afb35ce130f19c70cbcbb038434b9c431ecdb8c85eb852fe0ffc148e78d424f726e45048092d87fb181f629dea4a1420bd340263c539cfdbbf98afe689147c0f02670d2ff13b63042c72b3d328b53b84a7cbc0a9ad51dfe7a32c75f9062568c908eac58891d6b0eaf85c58271c1d74865282f7a016ec676a2bb37e8759645899b8a5d8936ca47b07389dd1336e5c5e6e816d1fbd2051afa98d3aa29dedc0a07ca70cc827f2e183776aece0ae883353fe56686c39a45e121681c47d99d1b4cd36f4ca7fa3f941b0bca6c5bfd3f94ff801ba21dbcdbe7acd3c8fa55f9206f6468eb483d8042a2552bb1d225d9bf966eb99dc697cb70ef11d75c6ea91495c100e037b55d8c7ac1aec9265733288d9b13537b4c5b797e49f5575c1bd646bcb218f5f9b8cc6d6d5a6baabfc0cbec00436992f104572b76aa4dd65ecccb64e958b5718fdb8c6e130237e5e5f540bd60000768c0806681f6395d3cf4ec4f288900aa1dcf79fba5c331c7cff8d2f8d1c4e3a33c340125ed07b6c4a8a2267de871a9d46b67aadaa86f99ab9aff8c284c3d0885a8d608be210a9fae142d9bd0b04c6330edd32532b97d5be5a082a71c4039c6ce33d40ff738850516bb23031009c0337445f3e7a9d038c7e08208252157104ba0e5278d42fcf90836abed51d727549c1ec012dc57c8c584322e1d12a75ea14a94eb33dd3b4c1ad5dfa5fd1c1f110ade1919849fbedddc04b27f4ca85adfa62817a3599e918ba340969a602ca5d9a2ce1d74eb1a4573fc0c463d3cc85e0a960e86db1fbd52657e06893dfe387d374a393d157532fe155d456251eaa24080311228c6f0db795798c56b96bad1f53cb61148c86312d567a9b6cc130605b923ef1e3c04d1c63c95799be2e5e7b7971ac272061378b1644e16414dff13d867cec1fbed407c90287c302bfb7ec80b9ce62b0577f39cf3132be0560b941841092a1ecd597081adbbe3220d6c0070c39e5b45ade4a4dca9fa3864d3c4a0c7acdcf00a33494eda2863f46a500605c8f80cbf2b4f4d4521ceb3f5c1af8e2fc26091ab936f731e0bfdeda2359e114560524521c1a6ede34ff94a920ec43558d732fc2030fa073436acdce2c107a156accd0dde22e64664e2a6ab340ef82d1d174948c3b1ac90850af19ffcf7417f6723c677c57454c445768bb01bc4f811066a7652dc7b54922c567cbdf3db3f3505427bb2387178e67721f1d893ba1c725304bad3b51e0766c25592e33760a74c915df5c44d6424cc55b565f55504d26fa24672f92e963d4bcf954c2ced60f6221e6ec2a8992d2b1cb68b51718a3b6829bc3b099003bb7e7ad9ba093c47a7bd3cd56c2e4296193ed3ece0206f155855997e8861e4c873ac462a42cdb3a0c02b6b77717cbea8b4967960dda8aaee8787524d936b0d6b63ac4ff85c4994839fc34cf32e355ee6ff841a09a0cc53a23a0d812e8402fa6502ef4f2b2568ac933a222da4db2a1120065aac6e39ea5cd6b3de12f2d0df12a7683c2ef52f718e09c5a618746edadb8f7415c2e889ba10ff1888f2276ff8a91f40ecabbd4fc2bb4a9709e4129970050756a07d9d1ccead124658f57d63d5e0584fb134767c4aab20ea369d08c264706682a032430765aa7f47ad48c56d5066ce561d4a249ac5c1973b4ef611a2855af768dbfdd2e354909d509165fcf4f9a925079ebfa2d284a666adb852e554075011e22c401c3ecf1caab503966f0410c8563e79958c0f36fc78de8f18ea9a6d44e9753d8aab0e55455068a0b10adf9428f761e4b9dbd67ceff2878933f15847fb74b638f2f1cd234757ef30a9c9a98fb8fc7470fca34a8759f1bbb48607c6c806ea27fc6312cfc773853b1555289b856340141fc2963a896a37c6d82bde2f74143f24f8b1594d108dd37cc2a4883d0389d52d680084b8d5f721e70fa81379c96436e7dbb55370be69b302daa0d4d7df204e00ddaf1af8513c91927ee21f61c16ec8c205cb8b0bde2a7538e18642f327bab21f693d75cb9b2697bcf2511e573e1c397b2d881fe504b8a18f3c921b7d77b8724b699a5d0ee897a4daf4adf1da2602704fab8754da327656f2f911e03a66a9864aa80d1e7fbfa4e07f21cd61efca8a31dd83d6e4b8f552c638427a8e444cd025a8c6bc13cf225daaa98553e4e8bf32593a8a99d73f687c8c0aa4bdae586981ce8c601bb5df704b35c69477e59300bd49662419470c147de6e92f86238ecd35e657a187c6e2b4fe828cb34b01ea7312912d7239a69958b78b3f0a8077e6561ab8851a8cad8a3f6162c1f94acde8ae9121f9baae5b26e09a3a80c50aecf7939776afc865b031abf51f8704d850c98ea77fb07a716fc8a26c5175cdcc84449ffa4f6414cd9e97e4bfd349c232834a87e32fd84a547f0a1a93a2b7e4c2d0d5dba9e0b724b9a87fc8f0ed6db55e6b38cd61550c33417acfe3517f29b65b1f8dfc0c57887e80fc3707446e7e4cacf8f4cfaabcf43c42390720679cbd9a7073c138c32d8f21ccb2024b00a8717e552cf046790144c2151a3271363fb99f9587db0d6ab075de3ffba053a229a4819c4614709b9786908b9688b802aef26292e637747b44f4aa491aeb8f49f90eff16f9dd81b7e5f2b91d8339ba42a18ff2694c11aa49d368b17a0081810cbb1627712c1af29c8c2883801775a305deaab351458dce1d7a648770dfb202f1fafc4e431fc51f8141c519efa79d760e5e88188ec0dab7439e96998690ea94813d564f146fd8b10ad5f2afd9249cdb8b68b16a6cc8915dbac38ec529efc3e4f21cdd496f7c27b0636dac7dae6200f57737fcf470e04f1b8716ff07be712901a450b41c7c0a2f8fbca89df6b2cd4672202457e2661b25a94cbba828f724dc38dc99e7f5be2d2c27a9b8fbcff826c2d64f8235dfe842af3e78ee3d3d6cc2e0b7bd5d10ea70a9b0a439c15d9356a5aad80ac5e84627f3de877e2355e56eceb3731148c372ba1a6e86c5e39a665bbc2638d541c972b241e57dd7c96885f68b23ed6e9478dbe2c348bf1510e3dc992fb15accf067cbc75c0399f71b081341c1734ed27af44d2886419624140ea5f81584353068a375a47bacc1057864dda6f5a386e98fcfae936f374c69988cdb2d18f5334f0985410a49ad683e935ad99e1d53b009a845b10e34412343b96a2392e90be7f4d3fd438c6c58e1586ab37a2e26da286b191ee705ae15f776dfea52eeedc8b92317b353d6741438d49d19d95e8726bc2af5534ab7839ad811c8c885abab5c5a146d822fd8169a663486b1ec55295ae17486bde2baba5ee4c74e72c017f6a1207cd4351dcf3986517564b52cb6a561c82f7d6122b4f5a5f348c1c62e88258a98d21b7d306b179ca6bf38c7f9794bd2f9edf0d5e87a4f90ff03db9a48f49b80062a950793c31517cd6b55ad5a00e56001876ee4e33bb04a0286d8fb98f1530db2d382db73143c6f424d0157ba64e9ba22df193857dd8bfa6011d34ad4a63ff118eab79721dd8c531e21bc3afb34fed621c90a87f652931ca7b3165a45373162afd547b8b14a2d3b419169f5f1c8c4f2dab7c672001eeddc36b522183be5e13895bf4c573eb54403216038472d4c232a692be7730717b96aa081bae092917f0e75e80c302c98ab64c1917c6c7dd149874ffe337edd5e22c63693539f4a016d066079acd620ba44f6346e248729b4ee53e136c9b8a36716c938e47bc897fd1d56005dadb9f0df6087a078ab0b5dc42ad3707b03aaf5e90aeff584146aa40489143da893ea4a1427f12ccfef3bed6aa796e1076cd1b75543c70492b12431c385dc92051c1fbd0d75912a003ecb4f03ba973f5b88cf68911efda98e4fbb4e939371f8edf749acd4cb16d2c8e1cea3b2f5886d99101ebac5856af5560acee3dc2f829395dee32f5d28516c91d7ec7a36bf7d153851ada4c16e51812b54a4bd0fdb174209f54fa514ce47513add82271728c35cab3bae8d44e8101b7b9b5a2d8e51c757540644f898b3b2232b08f77280ac21b0571ecf8d852064d12a2a456b4cd61469cf727062f5e87d9dad149f1365b0c908b47a010ca747cd81fd0db496c3b5622df9113547add1f99e15255cd2c7b60a77a252625c5dcd1d4f7421e8fcbdf57d3d8f7356c07a46a2a616a6e1c492b846951c193e67bf53a9f7d4c3359dd51076d4ff567fcadf9c2d6b09e81e7d4ced1e3ad82035314caad8385837175da9afdb6ba63d5a0689c0f9e1b885f9d6cc3a3acff68eb058f03bb52761d3ed3210a17f7c61c18ddb9beea45dc6249d0be98f315069ddf7681ffde0fd74824d99bef2c729da371e18f9bbf6abbb69a48554384e329fc083c3a9f32cabfa44ec24980738a12b76346644db8d6d53485788edc0eefc017b8dfd1b210436bf65c7782014cc30ea02d585af4e607e396eea6be73f893ff2fef226e7252c71bdc7a4d34cd8463a13434cf7a31e57195c27842f3beb5ff8d800ba6a8ec486a9ed92c938d92090ab3d68e820857ce1bbf24ef587db36dfe4173f0a87071d90a6e7eed5512eb8daa29794109c6e31a264d786d571c443c592afd90533e0c58895390461e69823b06fe972c2ca6ca91946e2e64bdcc25573cbc642e0f54ac703a410868e233f13ce16fa7fc45fdf27948df4454ea51ffb8dabaf8a66e8d55062cf62be0151c922fa23d2d31328a63b449dcdcea706516a8a7e04220bb614e8f9cbeabb00cfa5af888f677155496a17b4aa3cf01788bc062975b5b3697e079b2221c9b945e0171b089eb57a3c4cfd973647cf227644cb0dcaef127cecc3b81c5c58fb6ad435a05e34003cb75d6e9f513fc60380dec397d336b200319d4f599d44da02ced0776fd6982c2f1e621da058a5cae840bb6a70cd303fd5ab7805db6b4ff566950d212dd8a53b9a925e5797f88b213264496c569b5b55fba9a08ce423dbf56aafa988d7e45ea16054541400fd99952150e9e086e5739e8dd4525ae3db4cfe443bb705db0b5afdbf82d3922b0b399647823081d37463ee4efe25226b0d4c6015d4fd06fa616e34da97d564375f08c94baa248c77f30dc4b66fc33827fcd7decdba53cfe17c9799672680ff6fe00c7b595ade5370ab96f5c11112f17fe2c462a830665ad135335a153ad2a4d9b62077544bf016cc6708c9f25717070d4cd5a8fa84a3562c1adbf002bca06962bb4e9488ac9c93f218fa54a84d4a8d951c23969663e958be573d451c5974c579f1efb548e0ea0054ec38a064c708f2093dfb76f6563652ecb095f358d0b581fa4473d8f823c0a7d06488cb1d94cdbfb3b194ccd51ade8fc182578203a6ff2fab67ea3696b2f2e4806b54cb2f6b3bed77b8cb32f163ce4315d10c77abdea5732b4535b417d1e09a795bee23154c4f6a564005c793f3de266dc86dbf47da4215906e19e7a5016ae3e7db05b87a2f4e4aef6e50f57bf0c3adee5acba6b1c76a4d3f7a005b58e197ed95f2cbb67dd8cef0c664fede122492895b0b774c7b4bfb78bbd9dd237f87b1a253f3e6d12b00b0a9f54ac454e8b794798cd566aaf4117020e71fdbac0be56cdb4efc5ba6706b4bd67172cbe520e1027508e8e7f6955be4e8f9675f268d745b5c2218377f62f9f752eaeeb981ae6d34e158b27b1679c9adf275fa4c44e889b2ee0358a1db5796ee89cd34e200aa725dd366d2fdf2265d488418bd7a806a33964ef972b5f9b9307de8e7411984917978899d909fa603a82c9c7ed4b7e18a0484168d9c77b469f14b3fc8ebd6e63534268d58d9fc5f93b24adea13ea28af24e8604db91c824343196a1fb5d7b21a27c5ac9ea146eaebbda2faba628091a19e6068ad5cf79870f946ecdc3b0c01de5c7f0a3186c53bac369ee6397854366f9e8f33c71b50bb916b448986d05e2be7db0bb40ae17e4f76ade0d767e8f12bc76c06be1a4b14a2c4ff99b2dcf6a250f8f7b3a16ea062654fb0cbce955645d65c85cc25a36475623a8386eea2b73420ead345a1c4f111e6749f1038fa030e7b38eba063f76b0634bafe51caa66612481f376e10602924e0621bd9f74ed668505f77d7b33f25374300b07c423e31babcffd04a0724f0cc0624d55f590f84f5780c2f33faab1e38bdda1ec879cd9192727b267af6cfdab48487ea0a5ab290dd5ee998d236f3154f1ec7fa68544e45c3f3cfdebd689c9212ee69b98358068ddbe67fa2c58f664b06bf7db9caf2a15668d87b475e2985907b0944ada5632510b0d7b8b72794a61c1ecad7bd3484cd6f7a19513193b9f3bcd0f3a45603caf5b809b60d0f4f2693ea723d35eeec36567194f016a93dc81bff112331b90fcef86d45252e365d53829561e038c07abd3bd8160d52d117368c3ea7ba82441bbbca518656f82da52462df382294e87b6a5e5e262ad5fad25eed7b2ce26e9bc24c00f62c6be0f2218302e3c1027534eb3cc21c7d9256964f7f956f6fc185318a507de4836bb3dbc1a7b917a4b7376ea75871e4d410caf11cd4369d916a219269a1c9d4a38da32882e91a787909e6a7ce57a3a57ea692d1b51ae2fa20e8be1a7105333959dd60c53d1ac83eb789ce866223f5d846b66568f18a6071cad09a0bf753dc2bf6f59d8169f65de43679e3b4b44dbcdeac5a9ed1478524c0800f0f33867d4d2fec34348544abb70eef328c87a9eedd705f2770a105c1c84272fe62eb9cfc2e04faae75c334d5241b99361b4553ae172d12d9255804d2169550a83d336d513d26ff2c89f74238292d9e779abdbd3a8360b4a6533e691761ac2f24c0657371fd10677951fa52b9e12bb82a4fcfe2e44d4319edaa6494fd97b99b31c7b837d26c02f5eb97d5532fdc7b52c075b9f21033050935f28347e54b94e0648dff0677af196bd36aff367a49161d2cb24eb823a9cd79088b7fe5e79ae44fc1d4855e8a8782ba2f653398ba0c4313fe0bd54ff960b3ce2aaa604cf0cb63f67a1788a29322086dac1fb7e291fe2e97aef3d933d64dfb9161d7e3f197b3cf6696a013366fc263c11144434fcd24fb40fc1cb060edc7b1e19791864de8a88c82602d2418989e78bb45d2909827b1d02084af8e77a2f3de4c1683abe9f1bcd7c8fc192445e89813e2b94887d4fe7f73a25d08d6970b35454f7544d90f26f524455a59f3b0f8ed00add2144ad235896d0022adc150fe1126b27c3f0de0d7bf9cee330da664cb201b81265219512fde5ae7dc25c267b8d1969728bc4ed46ea1e1972c7c8e22fcc845324c15a95076c7f2b35dc0710768bc26f60a878fc9bb7f13368c8d0d5145dcc91ffd7d3d24ab111e07c509438ebff9a870147fb49c19277e843ed7d94b6737314a0b246228432fcc09cf6512650895c862fdf3742be8c5c7079d6f3d125f38627d46aac22b72ddb921476059426391b460388698a71d220c3b923329f74b5d778a7987545f42a74af760506dff959dbf6edc55ca692adc09a44fb9b229f68df07a8cc700eae142b3dce1910b6580af5a60b17a82226d293cec7e0c4d72a3cf7eff7436bffd31fba518e9f0961d4c29fa8c009203dfce6adb5308549cc363b069b276b3ab44cc430eeee1c4261f7163068ebce26f0990fb54504a485bce9f78f1b4ea4663cacc828c55de635c7301138b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
