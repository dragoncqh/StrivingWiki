<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4f3acdd4b1db5ac84f7905d900eaff64c568ce040615f4f43e00dafc4e4643f91db60f37a71ad7ebe44b39d1433671ae97b16fda648a0888f45f6eb1b33b775c15503f6ab90274871ae14e2b141e96ed73194ee2b29980dcce7a8c5aa47f2e59b4248d99827c53f512267016a2ad187da2432c75a92c87d69cb26788a8cbf8368eb4538cdd9fd238d9e13e9efff8b278dbe15f8c5526673a952349a51f823fdb17015a39a8ee22fe5d7bd3058a70a7cca77651788d6c20f36bf3fea3b3dddb0bb7ba4c9a090ab9fc74975f045f67bbb9911de4797f81577e1b128386c92d2dca32e5302c25bcaa5bcac07591786327d7f2d86f5c685e4cb707923bb4a7804723a0ac20cec28780ee05dad589ccb22b3890e41bddaf331bb5ad7933f68e07f1f75b5dcb55b93271ae84db8832d30f02426ed428068f1489cc86a29592101e3f53e700e085816a805c4be6bb236a5f15a1faab0b00b2642c0068140ea52156626835b619638939da12982d7a5ca345b9cfc9e2fe52b27d9872d01409298654e3b78c287d1588494c3ca3c0e90d1d1a42403b8dd3fbc00abef815bd0ccaae29d68851f111f64afd276e929745bc7d60091ebc2cf498b700cc53842be9102e41e994ed840520c14f0388ad624b58482c78976e1077c553f2c77d6a8d0efd7c39c1db6bdf93d58f782622f1afe628b67dadc7a3beeb3fb0d4cd9a891f6e567371112d894f03217e108a9956f6758cccac83211aa03775ca08bb41fa28cc8e7e719b104949ce67498fb131dfa40a3d5f172e064ea2f9c388bca4526a1205108da14d80fea4fefd999532c0ffb065fa83da88ef5eb9d16ba7720c1e66485029ffbd964721fa31e3b260da4fbcddc95760e0365c0fb1679f2554df75489794f28601ea46043d304f24093070b9694d5c561f2d1d61e240e48f0fea835c19ee16c479c82c49c8fcecbdcff347bd164fc906d8eb67e4e4a74de365ca439318578209a8f8125f443b3ebe252c7ba2094212276aff794374a3f03f8339952b85bd693a93f9fc35963bcebb3a1160b494bec3d4d7cb8f2347db4a121d570c208a7a7fcd117e8561b18c98a32d90ed2553fcdb228bc55eb9037371492ecff4ebd3f3a50dd18b6b6b3cd4e931599ee3570b62efdb5d8a952fbe5ec0ce807ba3be36488759d4e4f2029522dfe1e293c3de4b90267998b562bdfeeaa70baf3d5827acff7ee774f7d8e60338ee002b1eaa40f12e4a711e44663b2a9efb57e89bfd51c4965888dd542336e3803294b930b9bf1d403320daf4a0c153cd6fac96a73695d30543a1fb7ef26d7a168b9c14043c02c6a8649e725284a65c60fbe6024e3227bb54dfef29d8b84daf46e21855e112e4299df4ff37f1336f9aaece0b077bf2b4a2cb481750b7e8010d098ba2eadcd0dd84a3a685ebf364e6e04934bd1623226bbf242f73646d1bbd3f5fbb2f7cff741d276d12762c21562b53f97bc003198e50608df67ccaa66babd09e51d194aa0798cd6002aa5c4314aa4cd2c8512e6185b9d4c8fa5ee26cb545d798338e3816958f04914c62323d3f46f1f8a57e2cd07279b729255f7c923e7257037664b2b7d6585a272dc6f8a1826f4b413a5a3757eea9d9e64feb86e65314aad644f0e882c91fbf895e48355a608462e3cfd5349580fea8909bd3787686008e678f8266bb3de752144bbb9901f71246fa958cc5c59a070c8cc5e67fe55c1afc06a0796234ac5f54d0d48e9a42cf6d086b90372b7bae7c8e06ad251340d86e584684aefcf193b6db2985e0f8abd07fff164c1bea10dbb5f2eee8d9fa43fc1f57e8978a9333fb4ef2a1894ca51eea8c2a925cea46ac0c2ab2f7e12e8d39fa8f018dc41ccb57af8e3a4ac17767694c8e4c9247a2c1b45049a6d97da328447b53237d5bd143d872fce204331e189091efab556411f4b0875d01046f2257d7a6aa87f598c57119d2fa6f51fcd106632a59a1a48c7aebff32390f897d80a5c935ffb71a593aaa2f42284359da9faed5c2261146f358eaacfaaea473def7a5b6ddee17eaba72edd0a716fea326e5a8e66882e65e2fc075602ffdb4e48c78f6740318c25692b17cb67f53e298fe7ef7eb931d2a4340100b41b126e950057a6b41e9f3408193116eb997b858e2f4ca457e2e4adff4cec1faeed338ccdabe90480379f4aba626c230b1b7cc9942527d697f8526d6cd917da428a4a00295b09804a0f9542948ae6f70f7518b8a1898174e7ddaad573967ad90eb8cb83e04408b6fc4d71dc92c72f0656af5820994cc095a722fce71b69de856916da4bee172ffaf11afe2a621f7e976eb6c3943c64c08a95060127324c03e3d84f54b7a648ce8edac086512606ba3272bb496600f85ad027e441817f8621d06fcf801d1fa1f46ef782195642bd32a9abed8db116bc401a7337f63fffd9d24b18976cb5e6064f6a89a4b66372f997dd11ee5cf64e7991d53ec0225e60bfa90027215f2071316516468c53b7e1a2d95b7f353d5bf452e97a36b1fc6abed5f1511d2936d8634316598e324d698f299329d3825682935b2b14c8b0c6038e6120e5b74d91acad92c1fba1f6f132e6167ceb220829af68a0f01a06cb32197da8100ad6a233129f75412a196520282ffaae6fba507092bb8f6e33a028ef52b05bd5e7b0ed4fd8c4e37105076b8138a3db135e0b3aa3ff3c469d3799ba7c30d8bea8eed898d5e2277b813eeb82b9c8e27eabe6de21299697026107b6e70715bc9595fee29c689535cee7df169156d2f91b2c5645df8620b213e8f65c2fd1fb713831c0552c11742dd8ad368abf2e99b84f5ce7521fe8e025fe135b0f8fe3ac1183ad3035a64eed9453c566142e735bf6395da2e3240c9a455fd7723ae3fd67f6ae1402d264fafb401cb3cd61fb3f737a358845e8caf2abff1139f1de42be3b53ccfe8d5a3b87fa8eadb358c40cb11c06a1b0786d0a5da2cee1b04a66b5dc87f05ed2c3a1fa294cfa489e5ccefb12ae2bb631e7fc941bfb696f152b514598f6731087bba7883087f3d826f05a4a3a8fc63e1a5682ace388927cdcc6931ae301037b2c5b55934921802c97b97b68c1b896473cad8f2b3911466cd694ec033146d4af26d5e5e65e625cff9ad2e802c29b17912e4a9dd10904a5d84dcc7b6730601baa7857fef64dc9c51b9ac60d08499359e4947b67833ed182beaf2ce3cce5087e7a4331963e998f364bfa9b7720bad5128af5eb6ccd5d714a8c53d5786dec7629d6251d9d5850b49da2400d3fcff209c033beb62228745021217c796ba6d5e8e86cbb42e78431dfc584998d8a03f6739e82c5eded44c9e219d5985e3d9390f4f2894fdddad0cb0beeacb89c4eafd35941f6234ee1824da65344b27f07c79a10f8dbd4b7e7e7b08df9876c75890bb83a7d55a005f5fb1ad007c5d729fee0877366e62817699671811786c35a7b6004d0b35f3199802178b33dfa563d46d02659dae5b26fc0fa0da4b396e48941c70a87721f20b5f1ef481bfeefca0daf9bc73f737010b07461bd27c674cf20cdbf27d99b8b448a62f58497bdc49293275f726c976c9e5e9580d99fb3c18270ab6bd49b5bb0cf607973b30d566a75e6c1fe656baac7ae78dce0d0fc3da8c385fb1acffd498af882593b4daed3b7be48551ffff65e95ccce1f33359226edbe8d60576de3da529688ead9f3c56f44f97cb9fb723ced348072913756ec1b254db0841d65ca81f6a4887a674f17ff791a0723aaac26c4ef0b0733c016434bac960c2617716282ddd38f04b1f3761598d98981f3efe5ea257f3645972c8c489ca47478bb7768f6e9ca9c42cd2100e8029408c1e65caeab8330d5230a02984a0f091730053de56236ea70d82c7439f6db13501e97ca126ddfebb2426b326dcd4af03e8f5900025098814dee1a5fce04132ccfd130505f6995de3a9e55cda3529d00270dbfe62d072425cd035dbc9684622fcee646016db497190062bc8f2f7c4539144c593a9e5cc2a02b7cec01991894924b0be1dfe9bdc08712018e2bef5d6589dc75c7a10f9ba3bd31283eb65066d5604b040e8a3587db2c6e7b0fb15e5f8765b385a6daeb1dfbfe5ee908f4b92470a6b0b2b85f127b7f0c87a352c194731c3f62099625e3b5f2df938162a4b3feef57a9a66402d3acd3e9ab97470c6cd0bc9c6fdc252986397b4e13cd17751f992cbd252258b77a5be73922a8f09bc898563346c640d5029d48b3150643f1ee87e69deec3bff74443346af11e1cb0c43fa31135c9153da958f37adeb9cba1bc3aca1bec7ab50ed6e8ce57e9267ee20308849854bee126415389d324ae6d7e2c2acaf03c181d9b14ff9d6cc7813de56cdc306bf0c3818d74ec2fa8dc6136f463d772ff8b48a59ed27535b8aaac48f7e10c8a6b53f996e5385f926ebac7c6f9811e203383f774f2f77576c6103b7a7709888f74338583d6509515b70510726e3c5be38adfc64f00a00ffc957f1e5b9d9cb70b19465564940187cf18c6d23cb97ff1de2015e1e5d0fe2dec056747fba03f045d3170609696264ceb6da5eb2e8a5b9d19c2c06aead8404aa6ab441c883654cec5f213c4a036c05e2748902665d0278a1f66937571d3c8493b1a6710549cf1c733488e9b4e14ecde94b87687c05b8039eea9d6eccf1a116ee554f2cd713f31a30d95ddb67f8c1a24c2f3a78d44a1c911adde65cdf52799e73b97ec272f865eb771e270f5d321c951d61430435080974aa72acc4214244e03a34513a3808d37e3d7d447395d9563e2fc48f1896cefb8243e78cd8f8e1ba5041ad50541691745d975e62cf2b0b75577884187baf91f8b88923df8c55476556d3a9f88ce9d3e236f6ff95b6a48a3fddea96b551b36aeb7ecfd1eba9323864b5598957b34a82e8b204fe6f7670b965d12ab9f5597fe36d92acdd2edd8d4e4a2d1d43c06b446f9a20f5740a91c8abe6a0f4757683840a334f1d0d6585226563cc1b1467530da6364f1565df335c3d335634ca751db4fa82493ecff71343ea44cb382ca8db3570ac3831ab9ff847c4f8ceb2bbfc3a204924aa491abb1a8de98f95fbb34cbd994f6c9e284f8d8c6061736f9430a3c1bd704f56b7edced0d7b525135f8bf9bdb1f5f1b10517fc75cd38331b82be92c4fa7a90bb571ea4143ccfdcde481e9dd15690a8f35d6e7414b35ea123d7cff41c3d050d3633bba0853ad18d6b339cb3bc5feeb4b5f61bb04f1d2ab3cac6e75e721e4f013e7db71248cd5248732156eb2bb1686db57587b4740e5bfb1456e8701a0bc136fdab4587ab2645fe861c4cc4d587af7673769d7cacfe3ffe51bc988fd7312b651e187bb90b77aef535128dd6acc69030868db9076168b0ed43e5c25f79eaba1963d73bcdaf0af8806e3e5fff70b0b39760ba96c1005eba536dcfcaf4567bab6a72612424ee59a1b42c9f5a2d97ddef8dc18384f5447ab40ac6483a7509a178a76e18b388d41adc2683a0612fc265ab1cccfd774f00fa00e51d54e14863be5d669d0cb0491efd03ec2ae1befb5b45fdf015ed423020fd3e7124766d9b3baa965743d153c4472c8c64fbc898b3443e2828349c1a6f584e846a6a8658fb274b84d88af48f8ed56a6c84df76972414bd6812f9870fc49bc9238ca0865ebc9f39c70ce34bb7499dc64cda883331e78dccd0435bce84308e03550a01482096513890865f4003043d06af45ba17ca42add3c9122bb420943931b636cdcac4d388fb1112941f50a2bf028f2b678fa679d8c10cd46122eef5b1ae7c592356a45d5fd7260573e3382491b23fe0ceacffa180479cf8f1aa13d1b5703d433c4cf191442a736869f41100c6e2182b6eb6c9aa87c9efee415e1eb82c6001e5e61e432e189a457fa0487b0bdeb66254a9de8a628305b4d9d95ba988d39e31bf84a48a30affef19e616e5393858b153b44792be4f6ebdf8bd97a7c136297613aff84b11f4866e83f2b544ad30f05a75a76ab76189146127eac1f57cdb848b9dc5a46947975b3c6126908b21b46a4fa8593a8c256a051ed9ada9f8fe948d0f3458967dc420219bc5931b75d4a6922d8d5a7e0433648fd8306170b5c4b3ca7605bc9743f2c17a9479551f2d773a82fadaa48d195076ed7c1b0218fe0d02cd22fc22fed3eb33dc8f1de0ef05533b0ff58c333cec2d070261dd51c0e9ef90bf517465885d541166fbb1fb1a5dd1c3a1906982638218fc1657187f3996919741ecbf7074f6cdf9782b565130c3859b9bdf128b77d79824898a8d24041ad549786d1d661c70e141325f3302374e93c9b7eb9b7518baa77899f9a150cbeec45956ad65dac5301a9ccd136d750ff21f54055116de04e5c697ec4068f1a9e76420b9102f9c9f2c68be37ec1d9c49cf949105e9e365ccfd9d63f5b854d35ccaf45a3b4ee3320e29036a952884980604cf88d6a924e5233e962d31e541199350b936f0f42eb0f0042c2a735bd80fd4e3aa66abea8b40a66a7ededc9fb52853edf3e6eec4206291d676f94f7051037f3547d58cb9a5ba50004d8e67c9567f134dbaa01af606f9eff5680e4291e8754d90917274070d6f31294090349a80e7dae8a391a19a09f5cbd7370780ff6c7337cc46011e604f2eae60fbe939d34c7563499dfc67f8ba9e3d324373a42e54d773bf26a9e759e3405d4721515614ab28e543ac8be9e5299e417cadd578b647b50777d911ce85a005d3e3f51b5bb630f618116a226225578dd7b2daf7d388cfd0959fb6d2feb0badc10a48d17c474488512867696710f744019e0d9ca32d3bfcc467abbb8ca2bff530892096826a4cd5f9d397c62b192b157436549a18ddfb760b872de80f8a3987d6250da03de2dee616eef1e0e457baad805144365ff21fc4e902afbad86390c57c829853c5ab57ddbbc64072a4802d57f1e30bca918ee46c37a17ab83f9f44eddd3298e8cc4f4a97aeaccc9ce3675b773bff1035287c15cefe6f93592b703515c368e8294ede2f541efe0f037cbce23ba25d8dabc555cd4e15e1f62d215907dadd3a128dd831a4a9af9642e219f7b3f5adb749adbba94a8cf43a28167f368fc60f95b60844ee89fb591bbf049239ae4c179601b488ea28864ce7befd76edf558fa8254caa4e58337486df8960c2b3dc1621ba818e2c151a4ed6efaa465f0d35026e600c33195c3b0cc1733f83f52f17588b1b6b186c470ccb78f89ac596d44c76721d051476d22b4b9d5c63070b3db4d56e7cbd153951a02137c5dda70ad51d2f57a23bc4f491ad8806ce895bb0e0dc13e5a5b30d95bc7f703c051f80b50b0fe2e2105d271c9733b4897f88cada8b2740388b3e135876744de2c0e5e4d7b703e18cd84aede65cc1b10b2deda01bb9f312cfa5a5fcceca7f2a73d8acba9a53cb5a5d210a1cf7ad78e0bbec3307ec7bbdb8987f8751c2e058d3e9dfed9af6c3aca4da80c85b61847923d6da103fa4bbefc6838ebbbce2411a1926bc35810b33fd3d29c0a78298d3367c10d70f716abde13c1aedff06c6d03d8020b6f117704432d09a5ed700c512e3b6be94b9f22c53e02c51293f5eea37ab972518ebd3f6932dca9bc31fd83a4490788a4ea4136f7617c76b76a3de9e4427f4a53fe7ccb72fc0a81a9e3ccb9f3d4f149797b1b50f385667a82dcfc829fa30edcda090be2889218076e9d69f738ef862177d524f2a990cc86de77b0ea3a5fd21c69dd9f9a41175be5374bf192ec9c76f66d437215ae75f7395d12a2a626fffb8eb20b997b4e1395e31d44d0595761f59f13fddebc500f82782dfeba91057206aef877f890121afb6b0e3b5d8f1df1071815db4d2a61d3bc79b36e1545981e7a6bfcf7e405333de93ac37e2df063c440c21e164fa16a00c4fb72707957df04d2e0999769f7da33ad91a3276337098d5e11e94d162c26bdcaade25cde99e308234cc2223237cc5c06146d0e0e1719facef8680cf39bf2a3b737874ad953fc9cf77e857288e50f3f47dcd004e2d6ce27be48960e76ff37c3e8289095e6021575a7cb9478cf544937c95d2e855d69346b5507823e293789248fdaf3af7e7cec9fff889a1cec1d0ebc634d58f252aeaa70a3f0f556b2840dc0b637df5e483489f82c54f8431846442c4b2b04a1163b2da21738d4af1d8b0c0bedac9aae981082910ee93532bb6b37b46d25f12b371c58875b55899d477fa73ff1db75bf325557b9dfe793b81bb2929fd7aa1063d6f497fa97f6defdb350f84ce7ff47dd12253e9d07818c0fb00511073db127bfad76578899b23a2d996f42de8f8a76e52819f0ee870e30906a05ed52b1318defe1742d7f6679c77f24c6148ee9677a81d9ad736449e01beee3e6c30ece32c0749ec0e82d79cbf98953e4d3bc2c60690abf9a699e024b67c299614cc691e18fd27a5bd8c2710eef69cbb27870b6d79d7c7a928a97d1d3c1a4afc0593378cac17201e69e31a041bc5f4d3dd1c5bb425567ac4d749b8002628d33bdfdad6ec616c367b3452b53878376bf088b4f9ba7d815b423b51e83f046a1f229ca957e1110170b1caaa2fa94b17231cf4226821a91b86cae76cbfac13eac734466cfbf80331d299b13b272efd024db212c3b525b477b0484e5cff3626d1aa3fc4d38d42163bbdd022f452a340c1608a68094a3144353acd20f7ee454b3904ee9bcde2d9daef550398eb9334c4035554e1604c8b965b60807625dbad0fb4fc0229afcdbbbe25fcc7fc895f68dcbcfe81be3115f3f8813dceff30b3eadafb9440a8a3f5a345f1a51e2b0d9887059c2e9d355096c00fbe916bdba073d265d6cc1c30454d187f1b32df8e9c20cfef4aa9f0998df422ffb65d9f7f3b9dbd8fd7b19d6127b72980825d8d364437ba52e3b75a3189ddf8d027a8cebf861f65281d17e57be0bcefb9692c69a8d71c04624dd9436bbe1373f60e583ba856f50391a2869404a3d3d232fd750c80f8f312377e23d628e55fb8bcd8e8ea06436b2f664c07010710894f7d922c21c80749faf8c8aba85fd7a3c4899a83c93f181afe50a91ee6a1ba0cebd59c719b864aaed128fcdbadb1b1307744fd44c0348a7850b04ac5c59109d6067454c29a402960e5f5b34e624a7acb733c58794073f1387d53ad4e2e5c09e16f93e6b017a86e2e8f912ecf3f7c458dc8d7e580d9caf47925101a1f9f26043cf67fea3d213424c6e08fd819ac7e7aa44a6a641a8c3a3dcda3193eaa8d8869ca124da2371e5d69adbfd273fbf6784ca35c48a8d0c108b3f02f6844b05b9382b27a32847fa70f4516a4380c4c240a2228a62fbb068e821ad043befe679d45f460807c47d2836f4da373ce68791a16467c03ac4e6790cf43c7255b43626b6e6b3feddc5d8608d5d16d59c364ef3126157c46dff3118d89bb6cd35bce9d263ddaba036e24abac2a09810831eb30472ee69e00d679e558caa71b87473ce10f242283be7b4a7495a48b42f5fa5dbd0c89cbaff410fc3084cbfbbf2da95617370ce9aa5a432a5751b4dfcaac675a774acc3e9b616f0e3c595f77ac213534c84fbcd97d33f95cbf60ce26a52a72edc20b581f5db0c93ffd4c51de5f74cfc8fca7dcc851860c8ca6793dfddbf4cf9d50812d0751afb3ae8f2e23be65bb599131a3b137e382194d5273640c50a0fe6a353412c8db6e68b3f9c1e3680bca7c0beb0330f8ff44ab02d02db25655022083de49a112f4777ffd7c7ec186e79e5d77971725e1053f9c0e720e26725fd44abb1c429624364813f65aa82230c736b04e12e5767db9f3c306193aa96022302dd435c16748e54f3ca3455c1c53540188e0bb1fd36cf8bb1cc92bb5d3867b704fc6f7bac453bee99ceb6799c4a3bafd5a31c613197426f49d763630de646d1f840f15174b12ee1b8772a5f902516f4f07057beac12e2df9382104c9f91a2f0ce506b2f3676e0f68557376daec85665232a09489e77a1ca8e14fc5d93ad6e46afd4f2ecf826a701202748911d370e34e153e28242e3642d142f9218c74d36f63a3b6a935f1c3f6b9413f176a02fb3a3282fdff3609296496832b873d2f609e9869f0a6e5cbf333627c86631bbdd41bc18e8566eae31eaffe2d4300121fc94264f38d138d64cb38d81946c2bbd4d54c91be55a31152f2091dc57519cb3c55ebd6faf05e793adacf88ede68a00345d56bdf1ff5ddc6bb866f8e04eb11ce7ccbae2368a2279f527f695fa8765a8aaafa77836444e3f84e02647312c67336026296fdfec78ede92eea1135d4aea29a9a18f7fb27fcc145736f1b2682ad870135c3017a505fa6f1fe0b084d447109f3acfa25575aa5d1888935d3b35eff2b8b0286c7dd911445025f7796089db0795b85737cd7c6510abb7d3d4c7054ce4d615268c203b5c8002f0969596d67898a7bf32cf8f37e45cc70cd611cf14c3ff9a0c92592fb1e4d27596864668a449ff19cda7c2229164a7c52351db3688b8bc29f655d4a625752dec321a77e12ccc2d3feecbc5f9f36a94993cb1c97345bf11c317b435a593eeab106069f04a949b984d8bd15e5e943b85ba89ad3809888b5cccb2022ee4f45df151715df3ce9aefe1c4b667772874d1f1495ef309791661cdf9f19e1c0ff33d5aed1849d24baa1eec19f840c2ee2d333ea975787a3d6dbe24b12579936a6c976f5e105881ccff664d1b832d8dd92f132c3e46c35842b4a60b63c317c7eceacec2aae2a6638a5936e179126e06cb5be93f05948eb480ff98dee997308809943ecc93fd8cb4e4e80d308343e32e30a1635f855179c1cde73fe8e27eff96ad10996b5f05fd06b38b73c05cb6068dce8278b36b3c5788789cb53fcb6dc7f644d0e675d128db92eda78dcc2f18a83aea0b9872755d7f140d5152395b80fb56320ef865a6c3fa4beef31e7e4cf642db9ef686750f533e15f4b825956e77f3e58faa46ebc6d27754c377ac589cb42cfc3aaa65ea80d655b49520fe51922d175a42fea32670de1c917718af8019897a5abc0fad2fead2eef010eaf24fe02d26875c0b9c5a503e1d433f35df0596455a72df3e1a9424375a4653e1507dd48a1f0510b77500f36ad42bb51d05feeeebab040f01a91d0abe8bfc3f7c74a9dd2dc6aa9632dd180c9b6ebc37571a9718278b17c6bae83564a1daf08ef65b341a9616b5d646860016fa89023de133b03c790c23ed0791991922d5da65716422c1badd1aef5d361ea2f05c74be2e91b784cb06cd4b3b12a500f7da36899fd6e8f5084f9e07f72d069de311f99b043093de58fd67fad20bbd513519cee4a6565e20897698b06602799879d9ae437b712f01b13a03fb6e637fc6b727c693312132f0eebc41076aca127629c1efc5a4ea38a30b3fbe7173c9df2bd7bfb15d8856da77358730549c8f3ffe7eb62fe83f3dd64043dd3184e6b11f64377d7e5b8049bf1bdb3f05c473ca13b8cd1a0972289e663d83f593a0efaadd1bf54ded5e407e3ecf4abc96a255fab0fbff22f14f901f5f7e7303ad57d3be37e426ac953d50bf2764b75601ad6c79a322a0fa38782fa5614856425f7abfd4407c6c168c63325a98a90e20ffdaa5e0f9d8ffff5b6215fbc0d929531120034457329863317b43fa2343b0e883ba84f5605aedda4e9a222918c7c61604b2053756560f92415ff44996fcae2a557f0a10db4b8c2c31024df6f6c8ea404a2339b489d258a972cb591000ccaf3f2986352e4038d8ad58c9dcd33f89b9f451d27054a0f246d5e6ef6881a1fdea83a2948b84cc5a4300dd424f00b8a79fb7a34ca5edd42c70276e8eea7953beb70b14e9909ff5b033044d517519f7b618b414084f9e65e39b7d12909ce5e9835c794583b4ee0e2a99fbdfc39f2efba0e6ae193a011fbda7b226c96a42a17f406c1af0d9ba2c5778e9db2fc52ef3a14a19ff00dcae70066509aa07717130539232802f2fa6f1b1f6421fea153d4b3ce23e81e279b151e4e3f8f5cc35f4e5d42afc88ce47f405cb10f24b745345128dde3ff59f58f0d351bcaa5ee91bc6e8b86b0d47181c1387f9c47438610b70c98c93c911ef7c52ebf0798da0726745ea858c2910a60edb03c0f39f13cc6efefbd4d657e9337d95b5703f32432fcd8a78860f7464c2d419877fe33bf78832edf9b5b062c6c4274c49b55ea8ca0b6f7f24284fa71916ba70a3dd40f82cf78ee17992b7149465858d4eb64e7b6f4436e4173491c5e4ad636e9501f6b60e784c32e5bc6c837c5be84760707af5a67fe939334f6732db9334526609587c9b50637d2f14899a10d90670da5f1357ea2de5becad42aa6c5634a27a5f6bf27ddb944ef4aad7373f70e8e382c15af0248fe725c0ce3737c2e39149f80f5c25122c33cce7082cbc09b21b98e236971101029c4753ff036fb8612281d74a02843ac7e2ae6e108b6182702f44120efc82c0fd1511458ca3087ad7f3a38bc27b0868e69e09cae38f1eb3cd80d2d02a07d28212c1d6f9e0d4e22dc9b2ab1c121aeddeb254739ee24078c667d4205a5df60717b2a25850ec8eac95cef5b82c083e959faa1794265b8b79cdac4f9f7fe0552ea257b5f8ca4447ec36c84fd65cdbdde36d89de2b63be33effff0dd9c8782fea89c1f986bc58ba1658eead8827ba8d1a3dadebdecf9a540bb2d01fd5f4dabafad16995673fb370ffa00261eec8023ba3bdb6c579ec136e91f0ac8059f4fa4f2d2490181d71777fb9f98400c0f3e29e6930c0d2c8a9a7a8f2df10c36521cb96de03b3b507adb4f9fc94088fafd85f0c9cd126b0beed7201c2d6640954b33ae1ad1480e0af88cc5f1e4f715a56ee0cb5541dadf42e5a81c539d6a7c3b2b062370455a9b24fcd52df3b5304668bafff1b7346ede04906ca00d5938b59982aaa5e84d85a71f865aae22c8d16207332b85be61240c1929212b8e77ad3ae87eac6b4e8606231107ab2a7cc2ee854d69548f0b5fd93e3bc0865bf63f273402ffd700b18257f2b5fb4793404e0f2821d46606b2f8bad684ba2f440f375e84327c98025b0b5e6f553aa5ac7af9ce111ae275b23ccdd91a7df4056f540d4b163a340928fc3ab72f1c1d02682550b58d107cc5efb9afabb765b84e3b856b59797d2de4ec80869eb5c75efc9c6f182e6869cacf26b698ae9b0bdb21fa29520fc8e69c22692e73136cebd5ce53139eed1fa427057c878875b0379aefe940473a6120b4cc0bc2e86fe83ec508face8762ad4dee263611e3154ff4e214ba741b6e3bb4be37089a1e8b830ef527006238c5cef695480c3c66224f0a9bbfd8184caaddc9aaf127f0434de8dc9bf194c42f5fa6f013bb75c362db23738c28a338fbffe8897694c284aafb32a3d13db984d2ad02b11108252ee0928373711687559a457c8b36af8829df7605efa2b335ac2287a43912a23da8f0d785141008095329d22d4bdb916abfd339708deebd327ca7bac1e7e4fd24c99a6ece2b7bbd7ae9eba145ea753c1effbd4b7c375c5fa5a3db23d0509605fccd7abc46dc02493e4b9723b4285aada25018a6222d3dd53d930880b40ac35dc285071473001671ff6d7a48cf9fdc7c2b95eb100fbb0b146256ea6f23038c34c594776651d55ccf78acd65089379716f1cf23bdf6b0f50032870d20b8d9f944e2a2b44a6abbba81fdb4aa10d2598880d542fc6adc2b03c260c69c361380404e09cad58086d341dfbd3627168629baa592969f03397e8fab0ed157e6f831978a5deccd29c97ece31f8d95a52f2a857bd4ac55ca662db83e580df45c87c8c309d163fefbf8ff5e1a6c7fa49e82e229fe54fc94a46a0f3600ee691a654398f9c09b2ce7b952a0e3170688760927a75a8b70e01dfaeaf6c7b3cfeb45d845c5ad5d101aa9f13238de9228bf2c71e6289bb33ec34653acc1ce2bd5490cfc06f6bc2080fdb14476c45306cb6fa367d0b613eab3dc6f2cf575b3b1ba79771574fe07abda7097981c2fb74ecf69223181696b49f9b6e07244d71c40e4aa6dc7d834be185f81ba3b9b87ac27770f171433d9c9953b741e7cc427d87fe53fd10899798573e1afbe3c82085f6cd898088e58671f14b6886a862bd947335ab095b1ee68604aac1dc3958cd5a04b9111a096918799137e98a0df3efa7bb342528c39f221419d1d738916d0c23680bfcaa0fd094e5322599f5de7970b062062014deeb1cdf458108349de1a25795a8d1f824db57e39360f88f2c4346cab66029453761e33e55a6caadc29b90d2ea34fc14b51753204156cfda3b6bacc6bd36697918f91d7a8c29248e2d56851f316a51f7f055605968caf8560cee3be122085c4dfb05e7d766b73023ac281168a67688be5b8a1337d1d3567d9f4738ca16da6320e6121f3ab789f047705737ca1d4e3a0e15fa9831dddc989a180ef8ff815f99c5efbbd6103f10fabfa533f9bc6b30f97dc06cf49d9bec6d9a2ae8c9be96a3c47c6af66e97b81e04b26c69c22ca1bf6656200d41ff8752e475e6dc6f0c0a23721bad97e1e9290d58ac00943876c327dd329525a074ca2234dffa618ef9552a3bfee45c3f87216c7ef10804c615fe288009b240f2fef4879cb230c8bcfbb3902b24290ec9c007e20e50493021b59c4fe849fa3b11a5a76d1f3574eabb5fe39002bf56590a2f1ee3ae8593bdc49d691300761068ced2169c89f7ad7d5b8565263010dee72a127746b07b561d0bd4e60e7e697a8a79dd3fdaa3e7666acfede5baed026a790d8e8ac9c690b02b15399c3489d0491841c52360b4edc668418713493e7bc7d92a05863570814c5bbfb0c99338da91481daa1b3a73cef51e4c46da4f41d6135cd080662bc3a4fbe4ba8f827e0feef0255d351a42c8e35fd7bf040b42022cb9edd7aaed82221685206d136631b3c48e0d17d02fd0ac8dda942c9e54eb7ac3686bfeccda5be82bda112fe15c466659b4856cca77232281a6abdb53db2c06f9ecb40b7985b3f84a1ee327b48bdcfff8c2dc840546cefbe5247bb8025f496fb7cc81ace1d891cf2ebc80f2cf25f9d3a2079300a754f6818de6bd02e6a76c123394233327f21935e58d947156647b355579f496acef5ece0d6e07f4968269d771f6c81732d7d81117df722e9cb792df8fcf219f271223b8674381ee37168db71c067b6b0a977e35d0dd81efe41880dabb359bd7b3ec19637e3df721ccc197d1cceb01bd84170d90b21047129ae58b1bdd6e18f06ff5e3a85d1c805a3dea6286299663d067cd2512f762fba5eff051cf49318a1884361161876bc61","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
