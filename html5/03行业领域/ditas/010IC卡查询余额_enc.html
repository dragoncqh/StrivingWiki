<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0b131b008a7279424658099c5c72c6e53ce598948301867dd471260c4c53bd7e4246e17efd311c1411fc0b15c5d1e551ea97b39f3eca199a11e09664b1105cd05db876c30657c368745e3d12ce3c118df5bcb77a26c2796bf5cca6b6888b3e7a38f25c00528d6db506327cbafb7224126c670f2f873cff13e2688183727b70780074e5daa9e2f7ac7566280b1454590783ef866e96654a2284efd57b9b0593cc6cb5fb57e50f9abeb6bd9300a31cebc653b416933244ef7ad43aa2f5b142937abf3f490bb1517001de2949e9080f24eacac639f21ae40c51fb9486206a415f0f5561d08c1853e58a16da757bc0d200fde42500e3aff342a31262a41790eaa965cf4e249570673fa06d8391f007100c07202d1dc96773c3fa98a1b5c769e922347cd7692805ac4c25939440f79898307c61baa0401b01c723dd6c806472f84a93fd80c92c5a5e45e46597c6df4a1fc2a603a5d7c5b3cbec22d1bafb3723b2a684920e6661161631ef774cd6cf768ecbe584c4477fe73b704005abfaff7451bacfa30c8d4926e4bc81068f61239549b383037320ef05fc1e30abc02901c6ccb0043b84b6267c200edf9ade392f8cdd3eb2a7c41a7548652f89e72721be1e340afad08020507a6fa243ba6a8cd7c8cb53a44b63e31d69f644d7e9a8124f6acef291ef47464d04d3ea020b342f0f77e1cbaf8ee8517e57903b5c1fab6b23b5acb2f31212506b62f1b54ad34ad8ee48c519090540df54e19f794e7fb03039d58e851557888f6747d94e31328cd7f3f5ea23af8b45228208e691b66e8c3c646b3af03787861f8a2bf1d32d1e6ce3697c558e96d14e6a0041d694532a862b62c28d76f5249cd61af5b37990c74ae1fd85a34df13ded39be7324508ca15c9d7babf4837ec56d3a06e9eec164bb0ad90c9ded81bb6974aced24d4ef14424ef4721947f984d09ebed3e6d6736f17235ba73239a068148993ba7eb877afa02620699fec526b29ab580e755d184ed9be2bc0895a31055c536da1e3e779d81174f267414566080298ea15f198484712795b6da409c0fd8bfa50c753492c95f4895dbb093139611b2d8e8cdd84f141ed2b7d27ba0fab796b67bc78abbb7d436b154ecbda68a8a974c1b3efbbd8de6718dd8d8b760b60badc6775bda49b0e67e92a5a61aae2edd4ee77c84279f3d730a4772df76b787983e3fab0708f253fc6c4e02c6f22dcf16a53b2cd7989dfcd164303009400add55282a5a5906b88cadef01da2347c65261dbae942990c901ee041180d2a6e4c698b4dffa9ebd8dae900540b2c4672107138aae1e3c783c2d9a855f4ebcf9e804de9e2fe442a8e6763536dcda7ca50c9aa28f9c0bb3a4df543baeb4cc9746c224c293e4b4515338c2536d381fe87d58b88124138668708cc08bfc6be8aed370dae0b200087730a23a5dec35215568d7230624b8521b8ad745e559e92ac517efcf565da2e8a02a806d450bdb565e1298fbcb90889f275bb93209eaf044bf0bccbaeebb4671dc1aa0cbc0eb419e03afcd5789496e24a6348d8d90fe3c29d9d1821100fc38107250520b94e6f55b002b863e00a88134d5d2006619db5c17e601afc9c76d0daeab3e7eb22a190f02977b9565f6ab4c9f077f58390403fef4835ccf20c4afd4423ccee38b88c3bbd86b465e6eb001bf5a72eaac3e398eb2efe0a7f184ad276b32191fb74ab52a59ce4133f2146232e98eefa486f2de50d79ee3723e317ab4dc63318d793388c2fa20efff05b095ffaa4d8ae91493685948bfc6c2a2d540e82d51d2a7018a78bcd48e25c916d40f41d44c9ca98f132c2e11e135dde9c4d212701d7358a08ceae95f894fd9e6450558bf23ac32fd80d9fb69d4912d14576a28c38c30d232ac4fbcbaa0d27e6e05424075857888ef8fd634455f47f57e6f7953f5fb05e5c9e3067847074df321a55ca1c5fb1b1ac8796437499a7846eda98dd6d3432a59879812d52b09b8d8e261604ef428a0d6b1ddc3f33c1436f0e4502563998f52fa60219db3722773f506757283209142172a841ca23c5a251e2b8cc96762129e562690d1b67676586925cdcfb8bab88071658fd9836220b71a971610ff9377c70c43a19029cc83a2d6cbdfd05cc7998f9810dddfc5ea8add8c1a561871932281df3f7e39ab6abe27b3c79712fa7b11af162ab7271e617d03b7825f864ef126f36a35d3d02dd3ac5b50e2f89d82b71ab7e12ff052e1443a317dcbf373d84252308c33615cbac40e31ffc362047cdca7cc60fe55890584ad441b7248ce555462f0a951c2fba734e7c301f7a9342dd025fb0088124cb0dad4e547e0f02aa6906d9ed0aab77eed6d8ff1fb9a56d30a09695bfbd4f7b24c432f3a911ed3991f7f8532aac8ae4db1a843134397f0ee2a9149a909de4cb2d16514710e42af721e1d9fc9af4acab81873b5f8c47de5eadca9a64e06d1a78e9bf8734c4f2e1e816c4b933c87e0c5c2cd93936630585b5c00e9d8f67fc0eb42d125bcbe8dc845075e96bab86e65d70f5ca216f22f8a72694c376897ad804876bb6f8b6ffab7674a6a04c58342055f2d43d807cc3e602cfd389b36fcd25ab2b96093fef580331b2b6f5bbb0a8a0f3a2dc0aa24442e1fb1e6d02e795aafa49b4eecae2bcc75c6c2ae4ef3c80824e4ca129c044d70d2fe4c235021e2cfebb9915f5942a8f03c6a0b80b5d5a2a57d7b4cb460bac6787a7ec14ab05d1dd70f66f05cdebf2df956ea2d3f66d15715808490f4ecb6dda52290446505f7de82c89d8edf4493c14b8ec5571f5853662253834c9b0a8991350e0fd017dbed8e634a9f7eb9eba5aa8e3350a9656de2691ced46cd8a1234f364ad5a5cdf14d42c7287b0cc4a9a385b4e90f08d3c96532e59af9d83801e05373539359be4488af926d113ab1262a37284f7c60a2ca8bc751e9d2f1d48c4b4636f95a3070c2eac90bdcd73f5d2efd19189ac5b6397b770d505a5f2cd8cf9cfe60608fa89e36667fb16e4742ebe2a545cc7f8139237f2f1eedaabebe55c0842390a6f2685f231710c4b34ca2841511d84d10115db2b05f3588b1b2f99ed73eccb8c5044a8dbc2a13f2a5f8dc5ec9075ec2d9d9288e660142163ec96e8ab6778457492c76074c7a37acfd06ff47119a9fdbc5a48ff5140fe0d48f39c1f4cd4a841540b97fe55dd18c5ac3f5358eaeed398caaf8cc1da4f172cd82f0d508f719eaaf0f975c3f4495cdc7cfe0e05a5a681647a88a72c78ae4db0f818a00db68c5c3d9b000127f4f9bd04b0b1bfab1deb677fa10ac8c848ecdbba9da0adc9a9de38d7d1192a1b08d9efb846c12547b78e6130c12c159f4df9f837a42df0f78ad2a65484951e0940c32a9663f4f9fbf6c184f372060f7b3ad630b56a46a122984753b3c02d3669d82e415ebf9328105059dc4b579e808853cc59e4f50c0e84cbce5bff9be6f89685499d175bcccffe6a71e6d96b3a8df69b6dc28efb481d73ae22996ee82eb454462033abcf2dc22cb991cf442e1f9d66f6f9aa9261facf3e1fdb1f3d179e8861f7256e48d7e396deaee045972b01ab6410cd62a887668fc50a355ead5cf05d785954d0d261e96263dee52816948db43825113db4c8349339627bc0f883848079ea24f4c108bfd9b44c6dc54ef1f48b85c89024d85656d9e6f111e14e61d55577afbecbbeea9266309a465b5e9f9ae6483b8216a4b426243b3e29f0c2e059f1d5a94a90f5de31143dd0a496b0a48910ab4256b3627bae565f888758f5d1d90b6cb85e508aa934be636f33f4b49bf2fffdb2d66fb99ee7ad1e42dd4eb72f5d41a6cfa25daf551a4d8eb7f13f0ecc545108ffd35967b06d0c85544c6e8905c9c09483ec0ad313c936291b1ecc01e9d145400639ad8d7591b079c160b39c73e5388674c77a1be2257514bc5bb8088184345b28451d843f13159734c807dbc8cb2b2e3b5798cf8e022a2e1860b2300300cc6bdd0ef403c0aae6ee84139e1bfa677648f3076175846380cf0250053af04a6b8fd38ad11bbb7d9bf03b6d0e553f883211ccb07527f06125198c05f6c3ecb36910652974ec904266112e9bbd885ed14f888bffbd8077ef608042193ca37f4e1ea31d05546ba7179dbd4d80e0ff99a65dafe1f4755d7b1c03bf508cef015c1235263b5bfe805d61a33db67768dc9c389d1fd97914eb556dd98ea39fb2e8b990acce4afcd0facc1bf78cc3a3a0be7dffa1ea31d6306412f098f1be9ac9f25a7b954bb8ac45c2205b16f120d548cc54acbb9930eba81d646434c4e7479c006f168afd4e2fef60137eb6c0a2c652e1e91ea044be82d338f40a0c60163db16859b188652a1e7a560c56d1cd438f7f13ccf19c882f28617903ab0a32addfb502f68cfa773a1217382fb0a10b184a6dd9918c75951d6f51fe1a06bc17f91a39b635e3b1a782c063b1e588ea492d56932b77fee257fc23c4ecfc21da849c409ca3657b6ec3e44d4b835f1a394dc6d0bb135491983af3c9b5cb9855b42be218ce80c30ad6e76947fc4107741fa08df04a4632c64b27b22a8bc7feae732629c0bbe464e4e12ca720bb51114ef64060219d083661add1dbcfe789f96bd20e2ff88d69e5cd5ab9b66e6aec2e1bbe322bd7e127ef739624186ed8d8f2ad388b7b6f6f537b84b153d5af62bbd83544cdf874514bda2d3e000e301a72286a21451452508be36deca9688a4d1244070c3396298acba5053b3289190f2300e6c5ceaafb750b9d8901e834a4646668e3ba70624ccc6ca297cfbcf138fe9f6fbb78ca1cd0826971e9035d71c44fd27b923e9d416c4cc0749ceb4e3884acaf9fd3f6e613a146bc850416da8a7dd7dff3e8a59c6a32fa8b0b48d6695d68bef1dcbac4adfc96b004b66c65ec43fd48cb07d54f1eaaf46ed7a48e40bf14912b0227142de83624f04cddb36cd54f15b3c9b37710934a7fa6ba1a87ab7158bbf1e0f646e6cf2584d5c1df577b9d471ce70153ccb65fde7131a0312f7892e7e41fa7d2c29cb4822b80a6063840242b39a6dc1ddbf8eff887d6a2e40dc5366f1599b2fdac985e2bb8c8cf23af75447f7a8c0723878764f19ad67ee448080059ea21626627c1377d954358dd6f31d2658a2a160ddee7b1a92d51f6efd15786a52c8154db8c849497393260cf0923969d0d9ddc86989e6809efe2d51180bebe3f9309de15355463ed32188f428f628b3a1d851e0ffad127af3140dadbb390eb96981774ecc5fc461ed72ba248a5fda59b7a9f1c89119e38988730dc25f8cb09af910e369825c158df1ffba74da08230062395fc3e0a7a6198fb7bfff418ad187c0b0897bcc1ff2dafa6a005eebad657b6d07618fc23c6399587427c2d4cb51171959636df13ccc9d310daaf8ef7f3434498db47d3a1414e0e1f60ce22eece31267d14d26745575c6586b6b1cf705d8a0b6d7d4c563fc1347eb96b72e99a3aa269a7c353fcd995a087bce00ad7d1100f10ffe3d4a143b4f5b0977bce13c7ef11220159fab13350d2b504162200a70fb04ead92d2ca7bd18610633457bf228e47ff488602d02ed1590b1b8c994cbcb5ca40f78fc3091a924915212c92a97dcced78234fa7295e6a0346cb62438ff293388e83da06b2b0ee09209e58fde00ced8c58732096c12334c78c9d253ced53ba26ef93088fb7e40b94f5bef48fda631bf31f43306b90a1e3a0aede2f4c406235f90582556f207f0bd6246f4c9ea9b2b43b5b2bff5515e560d9d7ddfa64e54a4d29d08e3e62f6679a6c92a756fac798beec6dd44d091104b7e2ab6d47bbacdb70266b469de15e2e22cb89a21fa6f2c9dc17e9d9747e07df15ed670ec608b98b12df5b061e37073f55e25df9440cecd296f9af4579396ca6f7de62b4749ea06444a949038f328c6a90c892c931ab1ecd56ac94f25bbf952e56dc1366d52a81f68a0efad8c883be8b7eee67fb714d43e788ab9cf37e439e035ec147fd21cdc9bc1ea12d277326156bbc1afe93932ec4bb139895949018f541c4ca677e1e035ef6884df587ab13a669d38c3e683fee5409415eabee87fc5a4900156646ab0b7f48b2d84b8b3229ca618df0ea1b578232fed307f9a8e13e40a3a4c6dfb5f2b2182d33f53dc11ce986eb866865384336d5ba0f943aae5ab3790f524d276b290afed8b179a56f426fcf29cd408905fb7d51cebcfd8f20c4b93386b8de8b83aaaaf93576b6091bfab9cc0e717d5369649110d8245dbfa2e63fa12ca1e0cab4d8b599137264aab40f20e31fc2c00afc26175e256015b9d139c9dc2d8e0ced0e7dc5cb7be9bbb26171b160b45561dc41687abb7cd3ea58fb23098d5eaea15aa7101cab936a86946a7f78367dfed4f2a45f621eb942a5e13b0ee0a350c3b18d52f1d10e9acdf4ecea6b8e487dab477daa6049ff720fbdd05fa47f4fc51502782857c42ab896eadec67db06dfe624d4113fabbdc7b5df92a2144e3fcfd55548781c9d4fde07bc2315d8fd86bef6ca4e455057f6dd1307587b0ad172da84df87ca049075bffd5939e7430cc6b0acde3094fafb49a5d886f2b68af189b8b0a2209a31cb5f58a9ec248c52de7edd3b8d33dcd1a65588471aa4e2ca6847dbb9be1b0f52059def79813ade36d0c3aabd4836524acb14afc38ef77fbffabb8d898456f56e348e597c9373a82ab10ca7b6ce1051775d70954fa07554a29ea7d633d003cdfe67e83fb389255bd304dab848de70373d60d8377cec267fdc7a79c7da48f8471b02726e6173f81c346a72b4b425bd304004ec3663c81b49d8c492f955bdf0544da7f4995182a7a7dbc2afa87580ba6f9d9a143dedc7087eda34e4e477816a70054f4143e15d3501a7b5062292d6355376524e8f8c62b45a1659e164fad60f3d0a2d19c3a402e9f124b0f9942a39b3b149b52f4b063b1627f1019e48a0f4f24f1473a2b0e9d94d35de79bac8a85ddc0b720d894a663c6ae9795432e8d4b5fd8c6ec25a3a6db7800c0099f219a766435bc6c2266d8a7a074ff528b597220e7ebd686af7ba20fc2c3153a256f31e16c227a4f42b6fb2844cc3a83fc5c12895b553459ae75a3d9da81964d689383b83346389a575cb0f1b0884fb3d0be21bee8a42ac895d061223ece58f605fc91d9f75ca615b883688b6c49b4eb3f6e0d2b0f1284eb560da83a89681ea7912cb0d0bf69ece70a85fa44921b65419c9c920a4506655df1f1e05cea0fa72a37d4999c5690a379653e3b64f15510302987cf29293addbaaa0a2979d3f556c9a24cc1cb2495868bbb1cbc9ac479ed8829decc7f0a246fed519fc1f70efc335f5ef99c0aeb30ccab9630def9e1e4b6def091da369298436ca2dcb7c4ef67c6fd507c085bcf25f0284c0d8593c48020ae606356a82dab41397793e265aaf77ce891fd1f1efa40b3985cd92e5084986468e0ccf4057a13b48840d67629c635c4eb093a16b9a289bf7f874857bb22dd0759f9a90c81e52bd84fc5196e9fb634d54ef0ae013ca374624f67528c2ee1c7a8fe0be6ad159dedbab8491b80660554aa102e44f5a6749735ac608f9243aeb1e76b0820c8f56dc84fd17bc1017a0862e7317a8ce0b7fb9dfae9dea94c5d5d9565497277dbba06800dbf60ab0ed66d10b086b843d0c0697cc6279c03141a100b82c60569eed556ab367880ae656eab966f22f98c7cba5872f58476d827d4eabcd564a2aec2034376dafe8ef75802fe6a6fd6b2db74440bf1ba878dca05ef7ab10de7be46cef7ceed71aeb5392d0316aea242ccda66943aa3286e666fabb78cb3490b601d7f287a4fb925ae0bf785a45fce9bff46b27789155080bfcc9ae608083abbe2e5f3a30b0f263780e26d4f47713dbab29e6e30ca3f1dc6788bbbfbf8f3a2e0b422084f8fa06cd158b691a5ba689d0f0be2404d52798f9b0adc9bafd3ae19242639e900faa08a62f466c8570fb1d3fd25b871cd0c29bf9455351164ed51b64e7e15bca61dc7a50861a476d8ef57d6ee2b9807fc56c125f7dade39b63bf7b477f34d773f643366c884374a823e62cdfe3a2640cfd2f0abddc32ce96e590f41966ee47c853cb023d936fdec8a9d2947e80f1d123a232270979c0e33047b6dda9ad2abaeb2f785cb08bf74c74076f0f9b33dbdea53b50f3070ea068ee1c0a0a3715be6897595ecd359791ab8cf45015f7640e586841906ad990ddacb20abd509068124b376e9dffb12ce14ccf3e7b527a9b500286ff926927d472a98e9a5b1eda20aa1768e1a91ed207f7963e3668169bfb549c5fdf87aab0b5535899122363cf89fe41598a484fd54c7090639d229d490d15773c5548c2638e0a2bdf55eb7fd6ee2ee3a1b8f034f5073e126580d3f5189929decda9ddf99b1fd85aef9a013d093a3bf9dc8ede628dd02c9c79634612c5d1727a05879a42cec37a3e67bdb71720bba7e6135a7bef393dfdc0d1fd82c246aa44cf29375be5db9d494cfeeb83d11a3861180b32cd17e086132a3c3899798ca46e7d515ad1cb8b2dbf812e93cf705c5c89b5910e2882bea88e4859974cfbc9b49126de55c5c1596e25b952164d29d71d438c1be72943e580931443f3c709dade24a4e8a71ff148a492ce942b1a051bc0739ea341441f433be00d25d74419cfb5f59c462c411ca679a7fba99cf5fd51174c7c4eb90c371ea9ba7d128427e58779256168ff59b1bee3bfd84eb1861b4f7eecf31954186c460d84126b558f729b45b5053427cbb858badcad4e53092ea8ca4a5828015900d3fe0320b13107fb3885bbf9023916fc00b5dcd6b8569a3cd9ed8a348139c330563b2ea5601de1dd2f09b1d388c13fcfcb482fd94281645d37d882c0f16c741de8ad8cceb97a6f82faf72e24e134d54c657d56410f7f2aef817c14891a19462ff64839deeb4634a8c71016d86e0f42c1cfb349a9b770b6d1786cf7b6af9d677440cd4faa5ffb65f53588aad522f64fae6952d85cba677cff7a8fad0291ee4c2fd43a1b11f73683ad838265668e0a1b1d6b012c8c996fece718d0a7e5f962694896b0acd23f254c8b31dfeabe3f980cbafde1c12dca739d4917f6c554f00797440d6502501af08d4bc747c77a59ba3c97242a5a59eee120ec8962c426233f932b00c04ca5459009ecc6430a2a39834e98313854af84afb157b0e78685f8af2333534ab65569b9b2c70234b2f493fcd6aa10c101756c121b8cefe3738c7cd29406a4e3e1d78f90ca14a981ec15c3eefeff640cf268a69b7adb4db3f5a54535d0b7c00fe1df8c4a94160cae7e04d42f7efa2ea4081da08d8b3276900e1b0c80a32b13a9f12d5e4e013f68081fa896d1bf45910b87ade8e69e39a8adda38bdf4da10bb1e5f2200b3265870751f0028c56ba4c063122b76fc509b8dcdf66bc681d4855b1b06bf9c0755aef4b9ea8566af6d3b251f6b0c2989f9aad5a9c12f4069a9d1f92b9d2d679f8e3dd00fe85f2b1605aafca9649cc4a837038ae2e7224414c1ac9767dba954654c9a48c50826f70ca6a13ea4591fd65d322df2be3bf478d27f4157d5e9074f02c71439c7bd8fd2171d0915a68b26179eeab297e02648b1a94724c7211427f3a9ad758935405495ecf0fc9853992c14e08a634d3d060afd5367020e2f5667465f503b401ad8096320f9edae3449f0d6430e7b7884af05d122791122c98a39d285daa635e11b1d34a70048d42a827405b6ccff9236a5febec80331d84cd679de007466230b1d62d1b768f1dd1deeb00f7d94feb6051b04bfb1a0776317e8593452a29890bc6bb7f20ecd1d987df7c371b1c7c0b07c3bede622f7b26778b5e31238925da697e4d5674cdb571d685da1370b515c3ff0312895b0758fc91228f4f382c6e978416b96018036b5d2de8df9ea0fdf3262c33f6a65899f9e9069f7d9f66d4f58e31b448b6f45ea3ed02b92f8a904ee57f61495e07b343102282cf2318add7688607618f9c1ef9f30fe429e9b7d367fbfa4b9eefa9b47b36f2c91f168101e07f174d6aba0eef532f97784443671b229f636fd4cee217ca66998035bf45f5cf9ea9bcbf090833fa2fb8b44534f03961d3c99ae20a0d6fe65299fb881984d49fafa3e332f28fb4d7ca052a64551d7a31b72e17b02d210202d475566578c56acc4b6aa30b0e5706250d3183ffb7a521ea6ad62248acad5b4e4f4617f8df6f7ff1a9bcdb2c406d9ea2b0770e1768c0a8ba79bdf14b7b68bc582d27508a58d867faa1d89d410d50c51aaa37c43f68772efc96249219af8e4739d61a59675ba6baae28397212ae721e1af6eee1ccc5d7c9475af888ecde49530f9f9fb9eb08bc96b2ff3d47555dd3280a1427141c715de96d188528abeb66af78ebd5c34e5cde1b0dd49e63aed294b5955a380830215ff786dcbdbf1644c2ca4afbf4e525b2cf22f48e03c9cb25710a36140950a6fc005310eae28bb49b45cf1924eca2767ab5fa1eacfb9fee844045b198f9368bdad74847df61814bbfef8d55c989c20dd6b17bfb6ab678e049d18a455822b54b48a74a63589537fe697631eba51325fa369839ab908ebefea5f0ee5e26f133c2dbb6281e167069ddf1196a02e2151864ef0d5ec568c189bb229216dff23f7cbcba753a27db8c618ad23e586e85e24b4c20d0a8e3b2d0ce7df68deeb7b9ded52fdf6c0783c5152b8426020912b2d489bab387febd32ec2b53c47e56503e7baa89d3de555f30451debd4d7d8040f096809247357ee689da9bd5d53b66937cf4b6b057175ca8b8297ffd0e202ba8ac257a57040a204a104d0a1528cb1b08f3a106ec0635e894b714399ef6ccb1cdb984befade734e2988f37cefa60c1c9080605ab1b37ed9cc03e02443e1ccb71dfe65420bb96058c9bd5a83fe7dc5149f30634f35a70ba50bdcbf76d3ddd205c4e62b2959b94098fae0581e44ffef1917b3f2e981743a84811c2680511371997533ea5f1623284db629ba1480b28504efa3a11b77d63820b6f720625b7c4eba3cf84fb008be7e3701e81f0fd4159de9454975584a045c06dd9deba900e14ad5bd862eaebd3cf6089e4c013f6ee1df527aaa8356d1bd9dd4d7ddcaa317e85e5408ee00004253ff27e36d6021624a1ed577d56f8c084adf2f9b15870f6cfee777c86d418b462975d72b03f5972ad8a98f22c49dcd1bcace48dbb1c1866dd1b308f26d9f7cce77153a918a039c93e5ac6499f58ecff61c623f7179b712e4bcf4cc81df72408e9a5ad001b54ac50a55686cfcde1706b892ecf283762c511cb0d06e8747397080f383c97f2be8128f182bc8f9df66d75a6d51ec451b13344f1c75c9dbffa7f70a88592346c92406759481257197fe7dd48e946dfcbbaf794e9319728c9ac4838c6535e5c2fb62f2588c0a0dae5508fb4c17aaee6167d509500a383cf97998afb1a5d42086377a7bd80a28ec57aa4ea796c026ac85ac9772dcd6c9ce2bf89f0beb486fcc1283cd33f17a34b8c1fa71074b6a4cc447d76a0f6a45d99cd8e343198bd9018d687cd55335e4d47464c81e057f2c521b1308f206f94c9a257b77f3b418dd7bca4d7e82f96026553f7d045f437548645d24eb9c7aac50c79639e5dfa138851fc12008948ae7179ba21d23a6a8e21d01e7625cdd2708ea6a00c3af9fc59bd7b3048e2cec01745e58a39fbfd6f7c0ec7c906d072d623bc217333c9269ba8a670e1bcd7046544cd34ca4a29d750ad13ded50f46a0ccfc87295a990ac31f05229ec1995d029981d431727a4a645658aba3857bc0c3b6dc055ca84a7ca533f1b788b4be10a7afed49b8716c89c91119ec4b4e3638db934d4f944a08e18391fc009133ab7aaea71cdc3dbefea7edd5cc3d872fe9ad0e46e7cd1bab90e082ea7b4029976075e7673e7b5fd5a0b94e1bf0f6681e0a715e02593b6128fc2cb6451769edc1db836a1c7aa313fe05d33ac8d79f9cc89dcb4493fbf95c8b69d079d9ee388514c593803f8dc1498fbc171964e0e0afc9b9ea4dabae2830705dcac39109942cdeebf52eeb5a5edd2e6d7ac2175c29f8ab5c457f638351a84105d7ef335abcd1eb566ad6facb4ae404ded87b21805af5a199fd5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
