<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"088146d194425ec64f75a00980b6081ca757bfdf8e7fcabd125ef82e1d85a1cbd587e35aef122c8ad15a8a61178b13b57d36d2f2bc50749a991b0a9e4a80c4acbf8afa8966123c3cafaf7aa8a81f02a23abb3fdd8ca80c07160d5cc30882be62322e5a7d88039f71ab9e4bf94db74c95c1a17e1a2947bf842cfaa063c24d73feb77175244b76bd6cd941a08b631c71da3c7281d4b31b0115591add2c0449fbd280174fcb455c19172c4dd4f10e02f4faab9f1e0e8df74d3c288e4babc1b5b612a3199bee9d3749bdca9b319dbfbc80a0f6b34f99f9b2843279bd5859169da142cf7e57ad630d49fd1c1b4b4456e58b0d1cdea94f30d2a89b529e359baec098675ebf7f503120216b451d7264a25a3d9fa629020456799558dc04df74e9cd058d77ad4dd21806b619ae97c1333c6ab9faa2f6e8ae11362ccee459e56422f8937273c2595f295d045243af9c86246f0d7957afc1dcb82215a048948de060881a40b0a006c6da7e04a9b860bb451ea78eaa993d6d787710b04aede26e123c606919520a3c2230ab17c47da89fb981639411e77bd4424cc0b7781c92b14395b55f442df03c2bd9a26dad49d88724c90b9b906a4393517c4cc914ddff4c325bd1627408a3ab4531dce4f6afaac58ef35e8d234c2e1971c0e41f2c5454468487c17d82e976245fe35f0c02be3c9f57612c0324d6c6ba19e9462877e224f9245c8e201e36d93eae8e14fd11c2f9a92d728b78878bdb3fdd0c5498f16a6b991c410a5f825761056725f9d18778807ba74e42fad53709f6ee6c60e10fcfa11990b2c00f04229bb9a0ace29007facd7a828990ad0098b46c82ffe0794f6a6d5c34690fbcb4d689c5d359b2c4a821c811bd1827391d53ef247882dfcd05ea3d74ff38d583fa520eac0af99f32fad68676acc947360af34b08b75957e7e8fda4c607f59164ec555444c43938bc3b40c888c7420d5fc5b5ff74f85c557c0b780df4d96ef09e8c12679bb909a766cbc41d09d4fb538bd4f7a7ad4ebca99d6d000dd4fef7403e1184db14870ba4a1d4dc647c2a1cd91de94904247b8cea749b94f0f41aaf1ab2e47a6c30fcc9ecb712ab78fa852dabdf7ec73936f3f35739d86c89ff2470df5d9d8aac08367797c2d118914abffa83b510f5b4e0d3480b5da02548e24fdcf4c9be7a1b20e1f819baaa0411f82c5362b25dddeb93cc3395f6bf96788e8927043b1c51c2b482af0f2ad18ad3e51746cbea68e9cb3b9069ec626d49b77a2325687702eb8c0b996d4efb87e14cf109e29d8c11900d7cc273292087349e9062ad92a825836e155faec03b75223b953e28145deaa799144b6140e96eeb8aefb28da1a70e34b7af6fa5628eafe2f2db25d97728b6d5b9de10b57edd27db791fd007522d53d5fe2262d7ff4ccbd6f23468650e827deb2790565c55bee8083fd1c0676c2c19570ae876cadea7169f4dc039bf35974ed298729b07fc24042afdc47e149811b4ab3987d6d5d5f1a0cad7710337ee54dcc62deae056aff9e26277579c99fc455a1622678ceb196c9f7a9693de574f11f1aece6f9b3762788d1934f585ab080adfe9ebe3043103ecf191d628c8942b49dd21dbc2ee0d98218d82438914a6ab5555869980fe3d6ee3967f3487a801b3a6f37e943bc5770d84af088899212dd7c28b5f5e4486b388668fc73c7a436c658b5082b185cbc0a59ed98324a4da0537cae44e3e0722d71bc043a8085a411b3442b10a8365d8d9d9103e7aa4b04da4d046faa2ae0cffde673c136ef2fc271e20bf0bb9f94584ae082d60a8a2982e8d42dac01203469fa9f288cfde57a498d08ff057d6f93bcf8f3a7cf06c0a04fb1f3428d6c0abf4e56b06bdfb23be54acf2d990333a2c3ff08f841241957f23b351997c94f8e05765b3c15a61010c77ecc1518ff0a5e1837c589553bc33af5f1e5bf7727f2a894effc2083953ef26c8d9ff2d9f712deec4e582ce71b74f9f5c500f7122a9311ad575f9695bcc2fb1592f649767f5ef99d86e34c9b9bd0880e22934b0610d7005422ff5d95a9dabf0cefca622ef6a6d270352f2021bc8f9aef3afbc1ceb5a1ea3d62a2ad8c8ac6d02e947fe51042de2ad838799b5804c019aeace000b120da13b831bbeceaf383906fbb1f9ef61fce6eea20bb5fd3f5e2f74217740d5a70bde4beeac28b440ef7ced3799930e61eed4579cf11759915b7c92f78631197fca2f783eed2d4ebfff338b6897e7c07577447034c87ced91a4a9aca046a0ac993b2ccc5d0d1ec3408694d718abb6a6d88e5b5af629ce2a3a55cdae51057e9abec6ccb01939de181a8ff7c9089ed2734ce4e97f1755ee25ec09c50b1f5e944eff7c14f2e9710d5e2df075e099513f7676455000bf35702aa930a3cfda71d394b520924d6cf5356e8efa857d246bc3e239017256225094f0a7a93277ce05b099c10726cb5641e468a043731a86477645726c638b040df42b2d1a90296096dabf6740920cdef382bd375f0e88a27093be0fc878aeba7b4ef7c2088b8b2f476aa5d1f516fbe9c108c00aaaeba3cc065ae2227a4576c024524bb273cfc6ad5f3dc15e814b505007f06f99b79ba73e6eb2898634e6cd4bd22824b04ea4f1c693fb6cbe8ce68aeb1ebd298682e96a7e6a34912be5c9e05b07afaf98084fda6720fbfea7c19cc408a87fefd9b98102038ebbcdd77d4e455144f998e27e8d4d67c2fca9f8f67732c0177fe8114cdbebb0882daf27e99108f985b076f3a5284c8ce393c1ae79fb94470fa66c2eb396795436fa1218fa56ebacc5d42fabad8151f6ed0cc378774daa2ab38d003ac6dab11701ef70018f6a9ae1b194bb32ed152c6e7c0ef10e5b58c3671f6b340cf528a06b890fbe245f52d0951b126945f3d16faff8f6de0f2713c8cef5a0165f8dfcc8c05ebfd54a452983c717a47935696fee897dd6862480efd11874243a34dd264dd46e61a2baf579254b95af6b2759de5216ca7b160169c154fe78f3e0d73d1bcec8bfe1975e31f39597e8b646d89eadecaa4a0fe82a59f8a2ac947b7087763fc20ba8601a2c788e3840225469e7845fd08fee67c3adf6dc1bd8010649cd4068c8120b8da1b623b2d3c84f93f7d4f87812e57748557f0bad84d3ccd39833fa3155bd3ec1a2ecae67140bdcf8e3a36e6eb91c223327b5efe6a83df1910fd199e370ea13ba3761e94830e27d6295fbb2437612eb130bfd06880b4fb5770418c535f5797a5d695a7ee5d66f64b2ff784fc5e378c80b21adb3ad011bde1a694e30e386d4056075657e956305083fa95a4231f365f49790b0d5360256169c4a8a43a1845e78a18140da2bd5d0c16004d59cbf729cf0ba5ece44e5c82fa23d036d2bc436f53d93855f83981490084a480ce86f4887e731a03cca0ddb88d4d2e6091fdbe8ec4dec3d5a591e2c7411ac31073ca0a11c9a6453543f5d858fad69b3779b8bdf330d8b2cc0d0904b6696794e84312da1051b0f4207ec1543cab00d165cd4013c90bc441a644d18e779ad0478c6ec2f765bc8c84c9484425990d922da02909d2acedf1db163690d7c25dd782b38e4587bdf7df29979e9641613a0a3099610481706122f9d0930cac65652fb6b82beb5ed7c0ef11182b43b67c47db886293090836cdc517425a14c0b87f05d119238a731e50dc9a8373411b6397a7e1b7ca6a7c99516a1c54bd066426faccc56cf29355cafcd23a2bcd1b391603f87d1ba9ff647440ec457244c4e7927d3477c78dde71e2349506930da000eb94d1494dce310358d507f5dc3efb8a93f636089a239eb45442bbda9e7e778ad57323fc6506eb715ed88e913d57d04959bf11e388472e2883a48b8c3b11b10920c293d2e827809dc74f7c3e35e14f2ac7f1232cbdff17f512ac0d4005cd087846cc02bb9c45cfcc40658dd66685632201e4721a776112cda65465f85bc9dbf403ef7f6f37ef25e423d9d4cbd4e19436cfdfa19a967a0d8c230e9996484b8231666cf625527d230691fee5e613d5162153b0d1885fc4dcd303c4d9317d62a27b72ac106a854f9bc6d24851ca9e1eb2ec93f08bbc3995c308ce7b9e6851b3155cb32dfc5665a7611defb5ec9fcd313084f8891eb6108930d4d4d1cff624c94a12dd2313f067283bc883735ecd1dd6e1670f40afd0804db23702f3d6cd59ce2e831f67c5707636288a0e1e22a474c7aec70b0923539946fbe2019d3ae7de371677edaf9a4cd871b4e8791747c2bed16d223f7fc772d1bbeb0fd30ea3b75fb1fa49f6c0205e8d35da480181a4f199bbadf064ad60bb300206123d939e0a50bf974e5d58856c83738d7ed8232491daa792450c56ff2b47102f6c0cb13d7321b8026d53b5e082c3ef548e0049964557e5240558ad53f893a8cc0cfe3718e1a95843fa6e1407196c957be6829317386b405900fc08e088015d5b33cddf7b953dd2177d73039049eaf62a25c9eaf1462f5788af266a30eb107ad49b46d363e6a16ea8c6e88637bd0319e6e338ecbadc566230e63b4d94fafc2f282614a19d82d9bd66235aee8fefad9ce24cf994718fc22cf98ca78308980be87e34115932bc50acea8e8c058b1b53f484599df766fbe6c417da36178c1261e95f068a11c3a17cf9bebcd5035f33bd2f80d6b6d2c60888db94e8701b482fc3b4851b31f50707f9fbff73218eb5145a414ea7bbed7712d5f7b2c615e00b19809c5cfd807f619e82f7540b15388c28c24b355d08f8077c95d297c53fdca52a231b1eeac1680ab2ab8573da3826ff2c892f246d4395b4bd6bb1bb5f1c37b08251cbb3174a191a7de05228f6cd53ea435a560c77d1326a5b2ec5da363a33c08266007a7e5879079be7a93db027ea24a6c00b70d23ac553267e8c96dc33da2889f80d3ddc66b0dff44259f7e0dadda8e0f00c7391b9b01a5077050c1a7e8e320f3a9f0969be17506e01d91cfaf94f8174f829a659eb9d48ab6337802ece9cf7f721aa12b73a184be44aab9adb440b3d4fe81d1479458de0b03c985637fd612d7aa90581627965b3acb44202bb1cd28eaa21d06de854cb135659a36991cac3485ad872a7babfc2c40efe2eef1968fa45a3423eac6bb6c859f27335a31fa14b7828a7286b305a988c8b346223a7f5428f3e8a57d103c288552999c7152e9e07ad7f1e8222b9ee57bdaff75a9ae45713a2e58fac7e2fdc5f6de2e888a46fe694b375a84b56495e97a4194d4cde3d4ae2df583390b18f0fc70b7fcefbfa480e203d2a5cb018fc87258a105b0bf199005ad221b8f80504345b73edd7dd3317a1c5653e9c5be21751800b0c2bc70634b9c831c88eca6e4ed477c1e260a6917be51d09040c6049b363640e004c9921b550f45706dd72f066f7207a29e2e9f7e145095161e0a8611664400d03178041e39a488d28ca65b2ae1dafee1f6b32e622d56a5b6fb48ef2cc3bafab4a51484ce56e107916f88e90c084731652a01630b78769877f0d9e39be4e3777e22cb3123d64d8365a2d33a306f12a536115ccff8da6c4f68606867080cdca13cdab95e3956658b4da6773cc08e942ec4a02a4e1456cb10b1a601448255c24c2ef87c341401fe44a173117e21808529259a6b2ffe6e1b497fc81199d8a42c6e8dc77e623730e3e94ac78e6415149ae5c59814bb57f86ac81101cef2380c71db2ea3fcb1fc3a3e9d7df8a7f853b2865b434e1622b075f6b55e3c40ed0aba7b5ae8d4ee5c1faa22a4aa3b706d73b8c9fa0c575bbae029c27351a853d531c287e76d35c5908fc38b21969738525e585c9f5d070c0de4e10e5790022a50da8f618257c5d992b673777b482ee63a73cd6ea1d0b64c8caebe2803ef666328c94781884822aeae741d266d8667e54e60c8fffb26274c3bd52138a22ad7a1423cb0877983285da038a552cd87c21c7aa9e9505bbdb0dec1595e8c526983dd172fb6ddcb72a03a2f3ae40d0f5c8424e5bf5e54342c791b37a95bac192a7fc68d080e9ad23e7bcb0bfb648b43783dcc4e68b92cc35dbdc541eae47450f553e111fd1a5dc25b91b51db77c9a5c805986db03d19444fa16103e10b33ac89332ddcddcb09fae582a01ae176045806ab74014483a417309d231e8b22a280b1fc8c4f13aeb1ffd99af219928557225840384a2479ab673d20681f174138f431aedb6a460605c4f13db90c177a67db29a006d186e0130bd9984095586999bca41de674e3e53c6e51a3cc5d7330684a9f69c9ef7ab74e73fd2da086f6394d2846345d861a124c17c28b8ce32e9fc8223345a2aa0517251582dcbe348ea45443f9758be33afe9ea2823001646c1ec2d7f9b64343954ba064acb6530625ba5d11fc39f0490346f0ef782138c8a6e4fbf66added9542cd8f20e560543fb2f3319ba44cee5c1f94f5816298c677b50999905a80db3f21b8b38c55d51dcf8218e1f9987b487d8ad241ea3295c08a9ea8b280023f77b64b30222041fe2f7e139d97299361a128cd82ee09f799d9878efac1e18e250e3c1a0cc06f761b3c0c07d011afe0f674b228d88441d190cf383c8cb8f33816a0bb2af55fd84bc71a85cfff7cb6dcc11b1707a6bb480674a95c453bccfc247264c92d2e315e3acbf0c863eadef01b44a2f9e12e2fe5c59a8b0647facaa5fbabd4286ff032106d7c7b325994ab1256a4945f35d4d4af8ba200b15fa3c02a12fdfb0e9e5f15be0c58bbad6633885fc10a9e28a17dc3621fde531c69965f87bb1235e1e12e2cecee9400eb1f9784a4769be5723a05be5c2888d2cedd8519e4ed6f9b236d1ca9a2387ebae1e9b8b2157aa98f754a8ab6fd629db86a8f4d10d1d4778bf0950570ba7c1116380fa13148a6a9d29f7b63d571de51420efbdca102363a8f8916d82678604700062bac59c882f694c50563dd0ea170291f00115589da593a18de439be62ed4afc4f898032eb541086ce984cffa70ccc796ac1b10399421fde6e92e0e38ddb99dc8bf8c04650493cc61fb032d750c7540660fe28b79ab7a8e1cbcc00706b45be011f5ca34d4aec655fcbf80c35745a11cceca03189f5ade3a8765838ed3aa5d3fdf82767cc6e375c3f8227d9296277695257c714024f8308de6a91b93fe1bd12adcaf76ce6237c8a2ca4dc1d230fad7faffef1986cc51b9057bebd0a77162891ad2d99e0c52bb5263bc36307f1d552d4620558886c2598a10f32f7a60e043c68e6cf29db7e69de43c01e60a4d74592b9873e826f81fa718ea5f7fe41ee55e49c87fd6eeb64b2ec8101dd605c395b97ecc5dfb266f70d84d67905afd3aa486ec1ccf9cf6a7e8bab1bbfb0f4e38d13bf00f1f6b9ec967d6afc49d908486f5443a30dda50473d415719b882efa4777a95285124511430b54fdaa6e02620911f4191ca037144ebcbf3114a1441df1a92a73e61323e59cae67c24c02df56bb480b2f7aa903eb893ad544cd46db34f706f44ecc3d4f8da48724acaf9c2504ed2a2d598397302a3541f00cf99d06832c8969f1a050193d87101f712a91dc326bd7a1cbe6d43dc86da866c55956dce2cf350d3faf75541998a8ca0919fe4694fdfa9cff0ee2b3e7566e16a5e882b1e81576425dbfb1522e1bfea11aec8f42e88c563d541304d87a32040583c92bfe9ccb3f1dba132ec145f8d6c8b22f829954bba0dece3cdee7d0d0d37fb7e43043b0ce03b4b7663fcf7f226883a47d6edee1ec9b3ad41d43bb43f15dd2786a2212e45d0b4ddad2d32f6c5006f977ddae86e8704befde7fbb0525e0680e5495595df69a70ead950ea49d7942379a6d0e97354b9f0ae2b07069dd253dead8cdb75177c15912f5cf4ccbf1dd2cbe629dc13a70d8b167986d4e33b7cbf3d984f5da66d64de5163c950d9e8166e959c07ab2bfd5e92481d777e75d0cec241a7eb9e8095cc09d9e991c9b65b9b492acadfcfc68190da76388938c61f0d1a5bf557a000d158db05067af263b96df453a69a2a4580dc73b5d8299e810a02ef3460d6204fbeb6b5a403f255c5d3ddc714d574b5a33a11c7e2a6dd62b247881fa5cd27d167b54a6374a20820f521db44cc78bb4a891b0fcc8cdf26d3cb076ab6f1f70d3cdca9b5dc18555e5c04bde9f3fca4563464c1046e7f5482dcfea2fb9134b78bcba35cd4aaaead1ea8a8f3850f88a368101928fa9b5fc46159b07c7f76baadcc56e931387b48260697321e4022820f0512360c2c97927df107f47300be6340a8b7db8e2915419f298d09390ee2fa0b918a3e8971c1392251afb6e51c04f863b8085ddc925a0677af83d24fbd8acc79b42b52efd6135ae989cfe63d4403a73b5e6bb35079f06f7cbfe19bdb87b46f965008f3e4dee4e98804b888d0d68d6622dea5be9fef466b005dd27fe2de345a12a7f36b36c71dab30fac8b6a76481b3f5410ff7050698f01f71d7415149d60ea118b40085d0fed42f7e8f6c24ba15483d99b7db5d6a9ea838179cff290ab797366552280bab511a0b6548a97a24905756556601b6c2bb884a272891b4b710b34e968740a242b0bbe51697812c328e3917435ba7062b0c18b324f23c71a9f9168b91cd26e9533019c3bdf2c7c79fb9d52ab23155a201d51e63434801a693989e18f7104becd8a8343275509a1e4bd4e4aa22312342c133d8c2fee71daaa067967de74ee62c7834f366289337578c47c868fc830aa4e9fcbbf612cb8b59395e92ea9b358703e123b63ae430f79c7839deef4596fe0bfd091e87e445d6ec706fc163242f9c663fff04af48bd588c8e0b07648bc4b187447c0b08e025ee8cec8ae90254c123f036451be82f67f8c219ae3fa1c63566b2f507820818d5498061f6b676a2e5b15cbb3bb45cdf24da33dec8b4bf2872e68f2929517409a9625009bf3d2fb7cab50dced32cb5e2ad3dc81be09ca1d34d26faa6f2fe64a50f7225cb7d052d05f500e2ca2d56e4a15eece9085537a53b4162ccdcc8683a1f1aa5751b3c47033c6c463fd5de22013fd15caee59c02e423931058010578684498ad4b4249ede2ffcd80403a60496f2add21f1c3ff1bd4bd09a0be99f1f5d725f035c09f733750f53e967ccd3e9e145bad086d672495b6335c5805373fe62257e6fb60af24cb9328093710ff77cc37300caddfeca73c1cb4f4fd34dbd1e51a3e1bddbd24c2633c47eb34390d1a7832ff3fd26e34643f79fb9b84ac6c8d17e075c8ceffef4e2e9cf237f4ad54f23db99a3d6e2defda512968a5486ddf9acda40aa6971e65a79dd25eb31b8b2375e5b81f32e2c633db77ec0432e104dfaada68762aa44c15ff947c801c4bb954036363dfaa800c6c9a3936f134e447b96c6f590719aa40eee3f0ae1adc74107166ba16be0a058da59934d8defa03ecb1e3d5203064b3e6770af99faccb9bb887f38beb8f73fe1ee93b6f2f36eb2f2002fef8e0467cbe648f45c47f363289a18e22d46c2cc38ae3f98ba26f37de7fdbf12e9a0e2dd34b8e33e4f9adce1b83090917641f3bd5477b3b3c998e832fbacecc03f4dd31173d5ca6958bedd391a13b6aeceb221ba4fa4f8ca4247f4944a8e71ad9c57c0bc8552e36e656a85c7367501aebcfffdb52b23576f06a7e66c11613f294fd2a61a0c98895a25acd8a5eee78617554be2b018e4a91a7309fceccbdd3c6f7d915cdbaec5d00b578c0dce5463dd0c2bc51a6b9cc9e14e11c26427aab3a41e0c59dcc7bc9697d5293a519810a40eff758e7044084a4d25320ee31edb1508abc8689a3e8a768dded00c8150fa502d1451a22e7d26473a61b747566874c0b86b630d65f25b958777835e49d00c2061a4e020e988ab05de13c6a2a142093a993c7468bf4533a304f1882a5b43ac62ffc7d8b203476414498f236745219a2ca9d2c5dbdc294573a0cf01ba7dffd5a6c212d93445d213b11b61d36f13bd6f3b50ce4dfda865187a56e84aa08d64869f7b78af749073839832b6fa29bf3e7173458289bb4163ac088d1b857e93e1486afd320c40fddce74c2e6c74daa6a1680ac70cb42ec586b368bbd9960228e951156c233c51121c275ff91a0cdec07a50a66ea332f76187e396454a1dd2ee2f7e26d68f183319545c2109795d948992edbbae45f9df6cce9ccf55745f59781ef6033673f8c45f31f3bc2f7bca8a9291a08e7afbe382a684b34fc142cf0a5ed474b42600224b9ae888da177b18c18a9bdc2a3b51119491c35d2e8ba336649d8140f385704a4cce3c558a7ddef00e3eb65c46113ab8e789bb34432485815e9b4320eb6e89d26daffee20c839f852d7c2f1dc62d9891b7ab98d1708ee668271fb03a580fb5431070a53b883c69ce5ffc14edbe1d2376d7a11daba59be0bad2fd0670764fea2f0ebebcc321ac7019552b6de2c81f091737ddabdc8d6e90397d7b0776b7817d6a55299358f2891e32ffbec30d94b51a5de9100be297f0f4d60d43b47ba9b5ef901816fd72e27bd8d36d1f9ab1313a0ac9dd5a3d4f08757b5383722cf633e4112aa1e8468a7fa365ca906af2921911b8fbfac8779619ef94f4de89af12c5b62c68bb2b0058985a5e52fc338250b0f430fcafc39afb7f655068cf5eb8267ddd2380eb118fec73646404e533e0091b5f3754badfc70accfad90ec2cb714e5a27d2a928b6ffc6e2666997684185b40aba1fbeabc5a9140d5c860b5e704c0384d86e2113de3f7211b5e6e1444b61868ba567e335ee074881736c7fc84a4d16cedc5d8aa10b50ec98a766a17ca205560f0e4e885cf908b3dd6ee1a1058c864fb1825b75b31698518e8fcd20a3b21350264db720b8c309476abcf769c99fb151004e08d65dec015623199c376c83dfebfd58847cf3eb6e4ffc43572ebf6c57975fb3ad1082eb951e03000f77d76cbf86caecf29d94c035acda34f35a6810b286c4db41919532e02feda657e5373af858e28f12c68cdf440ca524550ddef020b3b5e60fe59fe1852f1156b42cbedec0afe840923e6787251db75eecb7d4b0420c0fc8270c58c8c052ce925955f069a85580389388591b290ace53f327da9e3435c013f97c7871b77c80c40bc795e3325ac82bacc329fde3ad0ca4299034475fc07e3b7acf8b38ecac2e498d72aff23f7d0789b22c7fa66b58514f00b4f60dfc29b7da9e94782ffe3efd51d9c1cb5433e122f6d23acea2e981f91bd3b089a451268d577b8b8c621f4f0bc13f04692203773d135fe4ee094b86f5229d05612a1d5f7ce8cf7da85a7ca8f7f3ea78842047f5b84730a49dff0f03c1895b71e4535b4c9bb7f13da5065ce60a2bb96b9adba321d6a6b833607ce17a17a1e39aa169ca489fe8050070dbf01785cc8218c07e19ac6da87abae8e3cfbbf0cfb23f697251bd952852b88a395033dad1ae1eb198577b62286ec11d88a3267e0b8ce3974364539c6193e44e0c53a1b59f8314cf9b6e4dec2984c971538e9a723d3138283f115657b0de5645a1bde614dc672effc44377ec2a5a0c5ca69c1352506df4551c63361d306c1347b206c3608011041e0e349ffacd2eaa28f8a0109c7122bdd9ac551a727d986d6fd314dc2667824c327affcaac2e23b1059735743dd05fd2d473784e97db41380c356789839321360f902d2991daa6c3543e0030c3ec4cf0e721dc823f5544d1459b0752c8bb74f83878dd6c4c0c4575d10f1bab3b7f5dc4dbd3270079d80967e62b0f8f6fd1d1aae9d9479003661662757e005f1878578cc39132d8faedef3aa51dfda730fd1195603f76a9be0679f2583286a6c190b78fcfe06a284f840ff1e9fd5e07bb9a60d93da8376ef45fb820eb20d1ae7aae7b483889b801ad9d28fbe17763089441906b10ff91f3254cb4b511233e1b547b8aa2468727e2004db930f1bc3e5f65557dda399e328003558ec368d48db33880a4f442917965b43b8e3fd1d7c0d463b91172bdee6a6c51b52c8cf64011b76a9e0c23fd14261bd12e44dbec1e0a2fd236e9088c1ee7de5df47d8ed9604e293a4c3e168df9fb76dac579e39b83e23b1669b63da6c579fa2e0ce2aa263cb4ed143fb0518b372b37448a7b353df2a1a840b3ebc45ca62749bf1b61de04bd5ae9353161af75637ba109a0a128bc7d91cad16c8182622ecbf5545d30f82b54b48ddf2bca36fed0bffd25f2aea7bd517798e5cd2bfc453ae3a9230957ddfdf2bb55f6e4d40bb8309c8742d21a7a89865efd0a98023cb6c4ccb47730f67e47ce8e02dfd5dbf31fb85080fc2eb76c3a02661e7077023b3938f199d1205a2c354ef2c6c241c2232b0f8d86e059c765f57dc1531793879eef4c36a8be3b503e598ca9d8c88acba115552fa2b1ad7a2075960d22d4be1db0b612eb6b88acaadf7842ec419081dba12c15c0664495baa3a84d00cecac49c9399e0fa24a453bf9435ef74f3d8bb5fc0d177dc232c917138b655081d08e469f413b31abc68ddbc6c61a4c5d40d610780ac00116820b9a82d731c574ce5432865a5dda6014fc1eb3db0ffcdf23ef158e5389c2ec8ec59225ed44efdf8851031d725733cf6f72e95f1ee8b3e2da529b7fae9005baaf4dcad3c7916a8a12d79fa18da60095dd86c863973ab1a3b71c48130f5d88623820b6e75559665ffed5907b558e994c24baf891f41db679ed95cd444b3bf7f00141862a9cb3c53e4f1e893198facabac8bc6f42cccea641791763ccb47b170a8e993c99ce4572cd9a7ccbd800a2ce39ec5405f6efdc2c495ab84397af6fac569ac4382dc680374bfcbb063c86c80bf7c94e9ac00a621da6bd015655a8fe4a64d7d26e6e40b6647cff322ea25d33484f2bb78f1539a4be2d115a8fc890705196fe8b83a9e660db0a4aee78f7552554c2265596094d6e33c975b1d59c9cefefda63a4b5f23887f10a3f95036d74d8dd5d1755153d8428db695e1c4322d31b288206b30ed112613518b9873bafb017ee74f7e9d5f1723e4a9ada7b5e3de2367b6befc75f24255bac48184ff1a72f8bc19bec3e471fe066d5db9f9e1d8a039a097bd23622fbefecadd1026f2df6fcfc149216d5ec098a6bac34e55895bfb4475fd8343a7ce8a1297e47a7bf01634129b56bc5acdfbde345037274683be8066d01219c0495df3d1f78143ff7ce87cd57ac0981fea6b7ea381b0c4a535d5c74085a88d91ed3ed477c70026190bbc89f905155fb0bf07d36544d043e0e349571cfd7567b8d1abaa13c2660244a39cca089a65065417f7a4c92bc3e38342f9d5283a878067bd0e5af183b97bfda21e542673646837609dd2268ec5d781d951772a88ffa8d04a9b094077bdea5f97a27b55d5b214fe6a45c5c2ecabf8a552696255ba919e3ee4a34d2accc200aeca2136aa402ea830da69fad79f235b72d007b0cfcc33c828e23cbd5caff01c5bdcf6096b523b45b78afe28bf7741074c38bc53021e0860bf2fe7e6ac4bb10ce85d4b188c21f0dca024ee3697821cb2818990b373de075f2d01bbf5185b60e2fcef20f3c6afea7abf498045efb0c5f26ed715555fa145b9ae2fb07ea72c6ed3199c4921b51045bccd05de902e4a78eea94cbacfd2f98149c93856ff18380f7d8d234e1de0806b3575fd111f4b3d71246f71fa4080492b26dddad78c764cadf5e57cd010837dd7882c518ce1a0dea14fcbbb5b3880fa7023c95cc80fb6fea0c8141fed41f7b30d95a3bec0e7b1974e2cf626b0720eb664ce505ef9b518ccb55644ad04728ad68b4b0c50501b37561c19e9901808bd91c2ae03eca9c908b79346f9426f0c16d4d192db9a5aac2d6f5adbf0a889ff521dc834e81f3cbc56f9aa30320810c158f0d598f7983b8d22ccc4c3de3a4fe2a1ee6c53dcbb081eb83ee90f2be8e3a5114a5daffc5640c5179b1f18b811a14a4fbb4fec076edc390617aa51a7ae12867469d40d1cc4b93e86907b81ef1a9805321e153efc6ca71bfdf935f91ca04e8c42ca4cc4fa92b674997210ed0d711dfcfbb91dd3e480562f6edd69fccace36f90d04fc8e7c6492449a8595b033a101bc6dcb96c770d237345efb6561c31a434f043b2106bae3541eac3f8de4e3d2ca86ffbbf5317c4c5053f3ee8f9a0e8301c319d2b3c41e92573df2bc77fb6da7799b58ac0769808f4d587cc56f976978fd2811f36c9c574c95f2c6b555924f585ec4d605f83d0916a8e5f4d19ea0d6c74f351afc99c7454aaad3d615ccf914dba452ac1b4792d51b8b3f3bee68785d12dd244e99646fe934d725411fbc09860b66d7bcb332b15585199754b792466bae9173d13b55529c07847726bf469698f351a74adeccd960079293ae9ce52238e67bd162c871af4c61cd39adebd00236833a446c99ada01f02ae70a696b220a0961753996ec88dd443c5c0bc2a51cd2ad737369c2a1b6ebc5f504de789986456dcad6d4a86c0b8813c948d4722a17f390641b0a203f9366342a0922efa35218a8c3616f6eaceaa2e077616eddcc0fcb1fc4264efc7c6ebf8c6a251a4ef014e4029cdca64ede6762345d44fe2e371a8b4903be1f18e5f485f09da2eafaf97855c07a4d175aa1886c7068dc42fe6b1097ec577ec2cb113dd28aa28c229af743dc575bdd26add64ccf74897703e6f31ed451a0b17cd743c54edb6688835582e086ba2501f53c2dea8f0a030b9386a027894d380b727bbd79769844046b4010352c1df34373b5f6cf8ef76f5dd20c6b436c53da1ac41e50ca0253fabd8e3d571b141d4ae1557ce266830d32c942694eecbbcc6cc0bfe86f2338c06c2ac28edfcedd382f35fbeab4b707944bcb55a03d0cb6e38b208cb2e9db3afc1e8cf03e0971a331d6b6b637e99114461c6070406e1d06a7796da6b219fda666099c91df2a8a690db6e604f251037a9b1c1e59d7969e9c183e6c7610a1d7cee5d51b8a542f4fe9b8ec998609e6adf3f4c48b3e093336589ae51280d89916c3a27f787405e64e50ceb02ecc6a27c017243b9c19b17bb14baa8b81eace80499d65e3a719ede28f42fa0446228b872c2c89cfcc5895dedc28f0b43eb5c050cf38054b8c4e824944095fd86bfde9f6c72f99e93aa11deb11cb5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
