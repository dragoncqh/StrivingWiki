<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bd5cdec18864d5f70783d7f3b6afe9967eb8c6cd0659465e7b40656b294b8182d8d47a2d141194fd9053e0472ed59f39f2f0bcd5776a08c6ca900195dd7f60a668556faa231ab42a9a6100bd52e637f8bc7c1aed24346a16ee27ff609c3dfb90db4ca60ac2602fec56b7e75a81830c45fa51e5a601d24d265a8034a3ef0af8a090e0148b3e41de52d14aefec3f052b8f48cf85c7565dcb810a57afec47ff4ddb4db5e3e4595c90abdcc574b655b1c9ee6cfb9277ae2eb3b054049ebf73acba04fbd8f6774f1b793bc56e8b6125b955a677aaf2e13a78188760e4d1ed2df92da2d4c693149dd5db8d492ba31730f16136170fc1cc01a65ede62d4bdaa0746f468da7e2f1ff7d481e1522c5b93ab7adc057d815b511f777572fc781d467cda89b48ead174a936c361d7321ece6a1fecce84fc02c168ddc83a1552955328ca876fcab3ed247389822d53a4d8aa4e706fd38e33e516f22cbbdfc7804343e384e1f42a88d6b7c0db5d29bd31c5d650c38d18fecbb7cc55dd1c9345d151b1cc3d76485d6a18665683cae0be677ad9911bea6c4de0b634570b100074a1f1a587e091741ffecff0e267c639dfadb03b3892a3bd9ab55c3385a2bdcc22c8667cb0f518cf9929b1cf38b061262fe94c7e65f530d02a8b09936bb8e2315aaf666bba6addb0f8d931bc06ed4724fe629c380c99e5cdb5aef0a63c6e3803412b2a836aaa80817ccd1cd3263ade6972a87dbe5a47fabd5e44e9e2a513734fa81cfaf0c08caa77bd041b6df9e9cdaa2a31b01e124cf1a5aa9260f01a27680b54045c82118b7eb1ab3ac61c0db11168b5d5ee09e6afd456a86352e92c976f96f488c556143e14266470312e15207930bb24552dfde94822d12d720492eacd3cf89146c6f7c0c311fcc16da44d89319695f01c447b77aecfcc427c350d5bae6dff88ad6aa732d41a4f6a7c78db10a97dc7aedc22d70ed0b49dc07935d54a0ed13c29acf66da0f061d611b8489138fec5d2c2105b8d1d2b3243e11dacd8c8ffe58e2ec524f71d6a0a274a5c32f4445673e678677b1e7239d3421085a494ffbac48e4b0ccd0ac930d9faf4ca6c61d8bf381467692dfb9d398113432ced0d891aa61acb90ff65baaa1108a0d045604bbf46de45969a39a271f40545e68e8e657063dcb9c4cdb08f3a5e12a1c6869c3b3886f1a25428ab57d90937752c7a0d42eb13b0bd672ec6d8999f893df3191f6c5e88de97395d39693088b277da8ad08024bcd96c389945223e8aa81e9756893406f53eabb1b83ee25615023b0d68dbf8a35532b6bfe61c8543b6246f43232bff473214adab4da4c7efd0449ca9ace0e89d21a4f70c91fbe3fac0ea042badeaa714198f1a6c80dbd05cc36de1b61556e8e537c25c836db15518641858c28165024a333183499f23fb0fb2a5c4e5f956392be4cc9646ed6676ee1de6fa6f528eb776a438b19c11a5afcf2053b7f65f4a88c927a617fce9ab02ab1c6aa13f230b5c328e8e01f5427484b267931fa3384ae98ec58ce328dcc77ae71411cc46c2d5fe7738ad8e9f13e614e41b5c16dde0057a9aff0f79a1c0edf4090a7975b2d27988700e3446f46cfb3ab250370ef6cdddf01e11e4da6f2321649fcaa8355b42e48e32c154c5b01ed5d328e523091273e7700f1dd2ee9a537838911dd546add8248ede95f14fa107d6c8bb67af6ab6e9d42212d418c62630b2c8df219a0015659e7d478a43a3040ea413888bc5dc7ba1e3d75f81d4668fb8874cb7b10b9a9b881737acacdb0d879b6e61c2766c03fd11f0643c0891820d13b114b28067b574439ae9e334f5ad2d3f68cb602468bd790f567cef338f7cb7d350f7d07ea8bbe87c02dbe63f511352ea417669759f1d8594fc9551cd6b6dc6af9986885a48400f2bd8ed159dc8c16400e861c0191f453d4756d1c41048b8fed7f501ee3ec19dd5a00aaee3d8fb69112b38542fba07c07e8c360b5deeab84cf3f72394a8d5d470be5ae8ee88cfa9e6b99dc85ae5ee71fdaa3a1aee653ba1b99ee814c011d00fce9a2a8e24cd5b3520367df46b06d1862c13b0d5ae662304002bee376299ca0552dc259d2cffb8b763395d1b838978ceadc559824345ce7cc2b693beff0f56fd5b71c7ea4dd4bc195f738da91e0d6da3e8e60692cb9e296fa0855b62cc7ba159d4308db6c49739e2faf295ad2d4e26762f883993d7cfaa8a7f5c9d566efcaf23263a20e0452923c50ebd06198bb566945255ef4fa74073792bc0f6f496aaaf869f747571fbb860b16d459b3df22a815054ebc335f7ac9994107b421470a24cd017db74203c63cbc56621df8b483c71be734d8963c9e93c9c1f3ae748a7d2ea41e48e74d41970a250fae4b317031a50a4b6b006d86ac67c0a5a133e7ee78648ad4f207535b3e173b15004e0912f9971a13363b769a5842e647d9b2d04a301fa563856510b6a80b675ea930bb2e2c929fa3efa2b72730994d4ee3e81fc77100e426f2cd976dc55c53c213c88fe9e839ea0951f2b07baa5ca66c1590cbf33bfbe5ffa8a5ab59c48a43ee3c303a5bdddb0550f871d02c7e9c272091b4bfde23a950d43efcc5038e53ac30457064b56a0d931731a21a3504acdbe65be470032b08db08fe74745e99ee044a8b3d2127b584835d7a33059f1a25eb711c9b5100e7c14120f64d48f603fe8be0fc0675d9d504e9266e23887c89904cd7f704bddc14f636c585f288123a935297a8aef67895d8553a06d83519702cfcc896a513ed7c6f7ed5793a1e3904bbad2c1b7de2107354da0e65ce02439eccb148c414fe060b0337dea464838acc23cab5dc9f9cff77d5d1db508a9cf1dcb4214f4c1db6a52287a7c5f6aa28c05eaf69698608a6497d18d053c27680b75a2dd843ef7e3384cfa57dc08a9c077cd93bc100d6e434a4603737082b855218dfe6706572604db906617c17feb0d2044b080eeaa0515a14469d7a1d7399d8cdf81e48c1d3c1c7f6fe4eebd9359acb6eb66501e0571c4c24cb5b19fdd03dac0c4d421b509e8e531b847fc9d5e8f8b1bb0e1b302710feff7834887047485c66519a76ae5e4782b3c840ae19ae80a64fca6691a909aec9259b1676953c4f137f7462e005adb7f13e86245485b55c63e66eae75efd42ab43a8820a7cc60dc5351405d40c2b552edd0cebccf967a5c5224d2be89c4cd1dddbb909ce2b169351fef9b0c64b50b2aa0477aa4322fcff397bc51dbcf45ed486e1a078f32e112f6013d278df2e47baadc096ad5bdbe8bb3104eea2f76649ee38a84d825471dc417bcc6c7bec1f64d01fa08f7ddc212f21294037a719370533f8edaeb168c1f3ca1b608d04e11bae23309fbb83baae253954b67f45354af2a972194e5c14a5fe4f766391336e79a864be4e95bebf24a8b2e14f28731dbd9a3390f6138f146d377588ac991cb7837edb95b544ce903917b458d2e3a76c24f2d2ab12359b67427ea5c26d2f0c955d501225433bfbd350cf95fa6724c836ffc2cccd0ea5bb19400523652148ad754f81abd2800a0d61bb13a9507848476a7050bfde59614dc13b4345e64a523600f75591b465dbddb8a5356cfa54f9c8978f6dd2cb09869dab4e56e5a6a7bff9beb0352c0068c682865e1f1ec2723db0f1439d236bfbfaf6819f0d27dcdc854091a4b95cf61175828a6fc2241e1dd03dc774ea353035ef2bf70d0f457704ee650f536fee897d1858ff43f4ee7a7c6a1741e90499072f553617d4302e2728283f5f2372c12aeb47e6ef76edbbfa7792148e4b0ed2787ab639cb86b1b75b35590fd02628fc06d6c98ef91f38dfc26d58bb5105c42381bfc74895c5ff899cc0a87723e9b99bd0c487c1e8a8419302261183ffe351eb4af094286e2f6c653a5182976503f1380fd1a5a8ac757c20b653c644d73c1cdfad9c6ca8b0dd5d5bacf629616b5722a1a886d7313e28ae5efd77949b0466a0824ab436afcd5442e8959d247f3d4276d914f7fdbc2579f9e6cab59f45f18b233b5c6e725aa99058c3bf2d037ae09ec113044e8af497f83b9a991069d3a8d8e752e908cae1da7456d16ae55afcb113b2b5a054863a3cf2bc52f33dfc967a67a139a667df4e2d731716c7dd978900ac443a09cee5378d22f5ed1b1721e245de478c81e0ea455dfddc0ecd5d7d8abc05062570525c379fdc638ac343f684e0b76079b67d9fbdb20b2d5ab11a52f076c698edae7b597097c7dcebb8573acd29d9a4fd5b9b5d984e22a0de47b8610528a3d0bb91ed36c9e0df81402b0784fb2caaad84714ed87875f2af43f8af8782fb5dc33e0596b5391788178d41cd07cbe67785b42b38ff6fe22b4ad61b85d2eb26f66f2719fb3a6a3479243d9e89120e1cb849e51532d953f729a3aa3ee35621f8d9b1bae8c86cbb2b1c31d685fdae5a7acf0ebdd2f00947efd85d19f8f74b32fb882998f9fbf46b85b9251660219614b8427d9ca819249fa3b77de18c828bcabcc6a70daff69a637f0972896cad9003ad3773780ba1633b7aa8d1b6d1d721927f9d66ed301afc50c063b7d08b8d0159cedf1fee33aba708dacf2a9aae9f4603289ea6f1d1f551c0e35b2be8c7ab7f0ae5e81b3bc91ab447763d0dfc30f40cca27a08598f83a5d8e8a21556653f6e924245e90fc0f5c091d62f606b202986b97b4a4620849c664d68c114d08670ec82648a44b67322ad18936c6574e9de2f6267f8dccfd8faa05d275c6b51234dcf311259652c4ebd6dc5b87abe8fb6b6075d8837c2182787758229462cae3dc16a766bc02d3f5b679a572c3298f89ceced836d7314f00733e7f9ef8823d3dfb565e6d9baf39ace28f37e9c72ba5985188a0363e424f1ca569960312a9455fa139997de299b6402c1d6988d5d9c52f8c04449abc0f2bf65b4677d3ed85be2854518344b01009a6a28e4a3a6753f91769aa2c0c9653ac57b309cb38a333207e502336d500ca34fd5350bcbe4725f582727ad03cc87f6ab1fdbce870fb949ee243e337938e52e1189c7b0455ebe52c32d2806b03df7bd976b013755d52a6c4c6141e7ac956af634c01d82097eff387cc484b09635bdf5cceea6b9dc6d6ce24245f2a39e0c95dab99153f23b1b41ac60b2829cb374f38f86e1338ca9abd6700ff7c638d57d981cc26dffc63d2400d58896a075360ad3047c489526744164cc83f6a36c79082ff4e9df5f91ec3e6e411cf7130ebf51e064838021afd55bc5fd3a19ed5036f26c345005c4e0fa35054482eb388c98cbefe79bd41d49fa4713450db23a0b25e4ad3b67d4ca2f5d12594463bf1c019535adfdd8181ac4711eaabd38f57b96e8a1224e95056781e10e9c1485758122d6f7dae3360afb2e3fd2d0748a04efba01800a8519cda312c169f9b6aa0db2a0808678a995621374279fe582d13c379ecfb9f5e4a535bb63ef091e0e8d1680994fab83e63fa189cc9c939365ab956e3c613f31c1317ac31cced9c66add04bee2cda353a8aa7cfe7e724ccf1c580b585aed275dbee3a963b78909a9ad83de7e72316b58c4ff7a080190ec6bae8a57143e83d2b9edd0f14675df6fb2f4adea1f41a45f394df84455630a96ae6dce7ff0889ce2b643f9e583763c4ba7ed8459176a9f58ae3fde2c06189def21c39c6942e87d96415b01dc0511070c4e33a25c94d22d1d2cbe7359f9fa97ee0b23b4ac5f0d68916d2a22f630eb2b1564acce200412f8a7383f58c6379d48aaeeb748596c93c1728a25cc0a8f98d97b30006835504eaf916aa96928418c04e61ad8aec8b83159ab155fd4560ff21fa312c10b9da1d4ae7fecfd97348d94082b516555a1b1042e44a8dda9e5efd647a35568d3c5b2549d61bf1f9b48698304494df69bfcd274438afa2d53ba2fc8e9eab7352152438af293d7a479301eba85c1b12a0e3151fbc16218351fed45a44cdc7e49c32b2a1f92c503cc05edda37e4056faf5026ba82c5c7c1a362f5240e94f8bed3533c226155c92210063921cdb3f1f8a1032e50af4ad7b5873733f73270675cdd91ec6a8adbe6b3fec0753d5b7008543305225c0a0fc935011845fadd42e8d3cd1dd752c393e014c52085de1eced253a5cf706029a8fa4a92ac95bc81fd545693faa79fe54364803f75133476fc94886b8df0ad2dfcb376263b67cb5e2e1d675283522662b474603077f7adf4e49af0a906eccd1f8e2909152c22114a0e0436aafafb51992c5aa65f19f7d9c287894b9b0262dae14323187469ae8df98bfcb427534b162a68a2f61d6ea66c6307670833943c13375bef9f79ca4dc95b00d22b2d4537d4308e6f696da49fe12145b5befa0f0d7638bc84c923a4df1853684a45dc0cafa3fe60d6423a79ea0c017c9ea041e9d35c9468551e9bc6826679bacad15b9edb6eb61cf8e8228bfade666fdfddfc0d714d06288495c741553656c3cd615726dcddd768e5807b9ba04d59239bcb84b66fc3864f360f7e662b2fb07468fabb2061e993bd34c2000dd60ba236752373a79e39e5e40dcc5bef35c58f6f6d1faa893efe2f723027e0c027a7881056e8a8e532ee4f33e02ce2dad1a954781136b0bde6b6baef05e128a63582d50ffc4fd66c40ec66f5554cd59bf85026f29ccf6a099dccf77ff08faf3c99a91de9329b106259dbbabf5ff3a507247f05c97449b21e55cc5bd133d7176dad25ef83b4f58cd386b1fb51916a9820c51d8b0872da9523415e780e70904f9bb0affaa6e4d74a6f14cb74c1e99d8993cfffff9beaf3b2c8f576e981301955951ae3d85f244f3d6424ca700b77d7aaf39d4ef6f20cc076e7617fe4a4488d494d1a5cf0531dd2a4c69980d86b3d8976c9b5b8d0dfdd2393b74f061f76e3dc1c973e88ab117e5038bf35d4f0a213fde62bd1972b7eb48f5414b7ad797cc88904e04f367b5e8623d3328794cdc34719a0ab19ff82fb6aefd88bd21b6815eddf2beb4181dc63c1f15853854b8efe59e698fb616dfd4b4ee6a48e1d342210c92bd173eaa85d5b4b6a22f0c4f515c56186eb0a0d901e0272434df7cfd9792fbeed7d1d7c1428244c4317d662cd3c44bbdffa2c161588c24977612fad5415a0803f2ce4ed92d45a1030fff7e4bf2831ea13a089ed8e2db455d1fe0ccab7b4e2e674de0c58c27a4309f21f5b3c198809267f3ef98691ef677c0233a551be3c7d932ef5c0a10bf815cdd6c694d826834a13c1cc93f74ea5e0ba1fc3518e599e6d7984d31620081771293e238b51bec0e96a37fbcff8a51c2bda99d7fbc308049a68697e288985efce692a4c77a8eaa4e85cbb6fae89edfc2232bf8a10b9842b3632347b125614a04eaa9d8081d684ebd920448bbb877fec95489dd93e8f61b4e29f56dc3c05a553f4fc0d88a420618a5df5e9b29419cea2ac14d06c6368ae1ba4c0497e755b800b87e62f81509359a9ec51e27622aa069458ec177bbce148b0309067269570d5ea434d584d4a72cf46eb0dd1abfd8401882e3c7a34464742548350d8915951853d660d1bccbd6189ee2883d2a1ad6c6f16910b647863587987622a69936dd09131cbc119019efc51e16d8015d67dd616d80a08ba14283e93aebe42b93f33e2ebf57962ad743376671215ccddde6af73ba2c037598b3a6bdce2ba26991cf8dc300a510946d0e0c670b0b77260dbd5a24386f24f388a4130bdd0f84f043a7db8c6498de257fda4690f973e38f7bd2612916ed02a576461b440f1448f2269fb6d3e8e27911a9b068462e51983dafe270d035e27121622a3ab0b5e2773094072bb5060df49e5d3b931d70936af52aa179bab1541e12c78922d71f1a0d4f84183eb2b2bb05184f2715d22e698bf1f72cc23eb33929efb9b880a25199132a3c5075ca315a4d31ee58a1eda22bd9a2b24e969eeca2ce153c08f226da2b26a86fd4147d80b6f95e998d5ad82fbce5c2ab0c5d42acb34d1ed5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
