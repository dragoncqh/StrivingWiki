<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8b56073580815a7c7f4adf9503fb62dee65ee1e64eba8b49062d26c96161b7e9283d7f4b16b4cf179d4a2647e4516f3d2de7f48b0ee058af784eb574dda001f4e7c555f6bfd6460fbc4e5b3c750bd065be2e6dd18f4043014db6ae186ee2e7fafb0cbf9dc58b18757f08cb852854cc1810885a2b8f0af20098bbaa42f27cae1ba82305f9dea0d367e0b90977c784fd92b36533c60b0dd0c1decc87bed2f72a9b2cff44478be1e5d39c32bdb59da4b67b2edc8a577dc37419963af2ae39f774ef7aef1126d0d11282856ad42552c94736bf773b565f55d1dad31d44466a1e799c6249892f23abe3ecd3365e555ef5814bf9062c87443f2bdc07ce55c54f1d4312dae47835ce2172d5f52425925623da404b0ce0b18925bb2429937b98bc364780946d220f4e2294926b0535dcebd93b2dfdf2dac90ca909adbcfeeb91318e7195817837af6a8854158d945e85751b95cedf9722a0b861da9e920fe2bc8f207449fcf09ff70bfbdeeb9a7e8bac86294965437a6350415651925ad091418fe448a40647aa8a358e261e74d389c875079fbe6ed94ab495af0b690d4bda365029abf48d2c942939b7013ae6f09c00e85cb36b20bef7c2a0bccfc05dd1800e8ae6738447578462ae12bbc68d4ad4f31c7263520c6a08afd548de46aec6cc57516064800c5d7ea8f2b18f69d3505fa749a0be046bdd4d97a5b7fd96a1917c20463ee16449da23e2b34aa9627a9adc82680aaf9ea7fde7b7daa51cf6cd17906ec94ce17d7510271c6f0917e0d95a1a75f1533907aa3f9b020bf274064c4f49555f6339565d3c9055da416d833a6edcc9b6f8737b0e04aafce73b9be47b69de68b9568bc870521a6800d732fc9036681444c43dae69fb388cb6ade9f376e3a7b70f2416585ec1bb404b4cb2648269c730067f1fb3a24cd9f085366b07a9082067bcfc356b26f084024535625fea18cc7b705dd84298d637d2afc725c6b2a1eca470332676d08217db2a5a76b40813398961e38154016941e4196228a727505644cbaed33c49f8f7cd37a77526c06c180c34f4c791e0504e97cf3626222d4b89f2c518613522c2b810edeab9baf75691084e0505ab5da0e810b835c3016c0f02acdeca4d2f76187959995532c62b2233b65c0311e1966abe445fda53f3bfa36ce829b8a723db4da21cb4f3481e11538fff989d966acfb39b113470ab9ec362cc73917a9b026837c6db5729c0401ce28fb33711faa5a766231c08479fdfe663a50551e9ea8f5a6e8cf0d445960e89e33bdbdac989b25ac88f987240a130cf935cc3294da2362103bd8f6321fee8798c6c02e285533ffec27e762b4e217295ba22783b01af50d8098a65ee606af75f4e5d66eabb086a912983d757217ceff69b9c725ff9530143fe00071b1d2f141e0df6bf2aa877ce44ea012c562999bb60050749d6baf96189f903b697eb55ded256b1a80e8d011f5aac70051fe7ffafb4cb6968d206598114073c310961425071a1083be6c98f187b55f7d628ad2595ac34b59559bfb54db1cbbc10a71b16599eb8761218378b7490f2dbf8d430c52a0c21e35e9fd6bed69d66ee07aef9a9bf66876dc6341e55fa39ae7a30ffb9ad05884c1efa0727b89af6646280c9d6cb36c19663afa005e8994067a2dae999ad985c96f5363fdd385044fe21583682278d8cbf994698a748d0ec7b52aef0c5d68052752094f00da8839075f3ea08ae52fed1944c40dc1691bf4a84ff114f331329d2e0321e77c62a93a7d5b2beaf37a2eb0ea43e23e03df8731b76b5394b9c4244dd9cd061e968f00eb7df8690210301486a7c4a8ec6d0f19896f87518125a8a8b14f3f3375269a4b2236b6eaa1fccbb3adfe556a9d3a93684f50596dc10fe6468c5453cc0faef8dfc5ec09ae5c9e06bc173dd4f7befd0766e0f583c480962a109f11987b373b6834d573eaa97b86b9928b7a3ea20573bfbcc899dcd5980f3c61fd88fbfab18cbc34f852dfa477a8bd904010002d8eca9cd35e0cef785d5b97daee5d3cbb6be33c2c11215bc6605dc510c3a87b56c0c2100bbbb01c1a23f60718834501e57d0753acf92cbee720d368ed871bf947a3bdf032631ae5b946118c491285d90add65a6c694d98529b0d805f09c64638819cb95969234ec9a422bb4f36317b53e473914cd3ee6427c22d042360a524f6c7ee635b69615b78b740be0453c934b427055eeb601cf1a2cc0f52cd2093f8e7a7a041d322910436deff204b07582536c7e047faede9be1048fdee80bf961bf81872b7ad69ec971da2fe66b82cf253d398af989e28063da6a20208b0c3609be9c7f55d8639c0325721108ba64e2280bf8d5b8db0b9102e8efd4f795c2856e5f865cf36039b567603505d7275e5a95a154256cfbf9451acd87add0a93613754a40aa4a69317ce0911fb530fb8ad9ab1fe5a9e1c33cc678cccb5bc271034f0bb4f21e27ff029d7705218c962d5d4461885ed41eac9310b57f0e11c6b58f1281694b51e1a4007398dd376641e9c9221755422c45a10acb01200b5fcff0378a7d40e6ef64c2e36ba363fa787fc2bce812ea800e6f8b12d5340850783851e9af63261d86b80ee21e4c26d5019b305fda169945d2a09aabd5497afe840d37c19ed22559c9ca619723469677b8223f7966dff3456ef477d26d242628d3e2168c08e5d82e5c4ce1daf3c03c6a64f3c748d77a7f811fa5a4bc929ded5093d958783808d56831dc9798c36a6d3b3356ca3bd0d21c64df39e932d30340b6f33050da57bdfecd6a3617573fa1de65df6fd49cbb8c75a7d8ceb6a6c88d603c2b4d8a5dded5d04729ea8e495b6b5b2540bdec25cab40075c7d963f4ca6a20a16012a1192e4fd366ae76383aac4bf843fd8f8df4d8d9004ecb045a08b394d11d27df39dc3ec08eb3b67c0f9a85b6307aab16b2e00b02ee10fea9592bd6e53f4bc1d7e1636cd74d7ce1ef94ce26191874b5b4bfcf57a2649b237fc00f52a428751125315016ce9a4c7914fe194485b5d6ea470a9460238985849425c324dcd41bea3b018b2475cdc78cce2614b8c5426fb48f60924ed4e687c355fd6f58f39c8e030cf30e813b67d930566a41e76a461f8b3f63d81c75f2ef3d719602206b887dc98fe299dd81e5a1e921437ec45bd1e68e48ee62511bb2ed56eec642a16d22ff53f23c91efd4d2c2842711a3152e91ecbe1e9391de4a646e0e3e2e21ffed3c5729bb465270e2089ed42d6f0c6fa89360f294b3c3e5680b2161485b7d0b3b43beda6a6a5cba9120e343893fa1b7a39ef6f87b8b463439f1c01907cf4f7095370db03968896c87e27a691bb6be9f17bc2ce460fe9ec9b8d13b112dee0392a3dde1b95a660a6a09673dc3714e672a5caa844cf33c4cde2c9bb62a173c9e3a689949fc49c32422d74c4af89c483201b29e4b0a80f0e5bf4cd60e9d339497e2bfcbae15bb832f75ebadd6f0be1aef56a5b71992bfb9d547136a997153174778b565d92b02b81240b87623a419aaa2e5df2453f631fc77e1923a622f65b588daedacd7679cd447ad19f5887e000240fda3db4f4bbd97bb1d98c4fc54e92ff42d95a58d4f5edf3ce790a9f2b8a55544b994d93bc4e416af37469bb930ebb4cef95266b028c2f2d1c0378a2a1e476ca252425d0e06536f5ce22f57f7bc09f366931d3d1a43d20aa9d2024cb3c3905128e0135694d5c4f019b064acbbbfffe272d7606180e6460512ece60336264192a31a9d2b8bb93e3f737e1d790df2b833b0c0431da2654f40d14168e87c67b27a1ff5a316c065f5bdbcd5a4f6da704b1b046e01ad0fe459465d7c5f1260489ea4e55a752b408f73c44b5e11e3b77a705794d3bf35d7b421ad41ede37a2fb8235cfea5291ace9472bb731b28efc1d8b0293391a08240ecd04a262c625fee5c7869e76e8aaacc3d4d929719113a7a11a5c8898ea4d8db0c0e47837b126be1088543de735e68f30e6c86925ed5223bbadf5bc5be2f10601d13aa7e442b166692c23024387c9df18d746bf04e3985b68e478d56ec143f72030df23826a0fd375aef492c7d2a711ecf5b7761a4114cf986ecccd0298dfe406be567e8cb7523d9aad6b0c7e461593fc4028a6b8dda8f1326aa4e635414e97fcd8b6fa386bf60c764586eeb2afb25744430fccd1b4dd073c73391509d4966fb2b4de9e71f43f3b4aa42f17e4995a365c98204c8537fca36a9b9678059f0970f794205f834fc461a59a6082061674913eb0b6e2f78868564c4dbbd98be597d86d7532c62afcdb589476d5b070e1d954692fe1ea75fcee3f299c68dcdc295d14fe3011d359bd52f812c7ef973db4b36edb529ef20423c5da39dd45c8473621a246a711dcb3375c09cf9fb3cb00edec974598692e6d6da03746d48e8c3ca74d59f0c726bd35840650db040fe2dcac9b7c01ab59527b970abbaa6df78ca7fbf5bbf227f13a7690b81481f1ce720e69c47dbdf4f5a2f60246f1f2319f62279e123eef01dec69fd9ceeaed36d03a0cbb6a8c1cf2c234cc14a33d5b6e4a94672f8f344b0d52e3edee2f6fa9f54e4e44b2134634ca73bdd709c4d069f1a0c65c8e70383682d36ba5960d10d4838888a79edb01e48890e9050a8fd8c46766e99ce02c1f8fba5c3c32945a0a5b26676113d9ab6e96ad780a0193ce01cc1254ad994b6e1be2c72cc1913dd3e4ae6269f54468edcd877f5ee59880784bcd6389b601a86400208fa4bc0c18bd50974f622a4ecafc857e98e77395b2165ca37ff3367b1fd726a62591d36da1c3673f98544bef1f11a73c2370eb9ec90b3d7f42e30d58a35651d36ad66a5da220488ce06c08f9af86b01aefcce555813d682bc50643f3dc21c57dd8022ddd8ba498ed2bc33442e364a521f76c0f1722be92a9a666200744c542d3774645b174928a789a26a0bb3737c19816c1c7b8d03f0642597e55b13293d9b1d09e58d7aa504be215f312d2177cc2d395ebe92bc98d53120832bce90e967eb1d8bd9fb9e0f2833db91444b3d7274cc734c9175f8dc71f3613a159c34f3072cfc7ffd02896335a12d4d54e81a7f347886a4507b31e6f2dfbdb02bca2385a833278c19696197443fdead0d5a5da92c81e8f3559d62383277191d110d4363773905398e3f306de70d3b4fd9f6868ececb0a10cd888793b7913a669b09391e80f712c0375b0b12a530687c2c25d308723b7e6fa9f4d08259a47d18379d081046de8dffdca6515e8fa9e04b17d1c4d3fda5388693ebc4ecacaa13bd277231428da2a0fe8f82815c386743f8925c6070e8a6fbfb2a6c886430e237e91dba1a772ac4a940e28b87f2fda81780335bc9b8c01148abf4b3f6d99358e8406915c3458895a6689e3075a24098d00bfa7b297b398c1212fde036f31c9b6e8d76bfce48b51dfa04467b53f666e4b59b51d3bd151f0efb11746780f4f04c86686a16fb4f1959f33b13eee1ecf9e3a4448a2cda408c99d56178e10583188581fd7ddb93b948756108acbadd2e38ebc3ff48a9a9a30f04dd8434b5f4bcdd5f5431a853d0f6c3dbac875e795ab7a39afba41081e7ec2a37b0c177bee87185827135eff3c5cf84bdabf8b25b72578db32cd5b22927eb8435ffe6d01bbec8a18f8e86ec838b3cd5a06808202a796b48e1aa71b1eef9705c16e99161ef1f37e999cade8ee79460ab93bee15bb6d8f731cf473c99b5f1b3df4cfd1edfdb794689f1f830eafa852da96056d8f907aff3fcacc4b802f0d0b9b79d0134dda46dd74af7c5f99c71a125f4d2572a093481f5189367791d8f3cdd5e88a38e83ce3e79d545880943186881659ad5fd24ab715da92cf940abd42f5d53b08ebdaa18cdd6188ee060f59397870910a72847b217f039af3e65ab30d9dc7e8e22693debf3e01c81f0822540a4c8a43edfabf006807935ff1c3749bfb0aad2c696e42274e2bf3f8061719832eeb289edbb97bc66400fa2bf6ed203efd7f048721320555b068a8fc9527c1a1313d008aa528290355d2b74ab7883c1b04a6d571c7d23e44aaa2164a14f92ee472e906b456be60e3dbf0441ea6378a865210ff615255cb058a43b9274e2e7376727f413232647274f5bd79406978eef2f2f6f5092f752ae8e53a705a66bceaa58644f43c7199f91d02a29b9c68bffbf2981d38b52a44908568b4cb757684f02632ffb8edb371af270c404f628c49161448cc931cf4305f712268b9b764ef42d30a47e74535cbcd2e4659ca8dbede68fb096b272b1be44b48f16f7929bd3947cee34caec508e2c091860552dd25c11d38759ee58ce49e557249dd923ef34a9f0512b08e0d4baa86651d80e20c15011de82cb6484740fdaf3a7006d6e0a07cc7392964fcb6fddaa0464c6f866e76ff5b5fb43cd83209e384c046dec85a52acb207e442dff034ebf60d5660382e4507da21c04a28dcd0e73f459dfbb58c4f367d089a5a7f6e89d12e2c92669dd2a4aaf2bcc11da80ccc871214cff198794abdec7390c72135cf0a2c97cded84d6aafa1b90c1b709e104cfe1538fb871465b618625f5a332d44890a756aead8ba80a2c3642b363c29c7d552a7d73df5dffad4765afd58796e93d45648d6b07d505160d392c4dd2d4d3f80ab49defc3554fd8b8043212c273de4d0b2af3956f08be932d74ab4c8d4a1b280002b638ac5cffdd7f416fed1cd48d84ec4373866a89ee554ccdd72d8151efc20388190970de7302fb7dbfa0341b0782cee92b07465cde50dbe2b6e4804056dba8b4793a5f02af649d61439cb2a67a20fe416f618a166738d27f98428e37a9fd3def7a0fb053c6d0a1c56dabd97c94acd4de81a92a9aa191d6c897a0129b8b08c3d24c21dc3048bad1c99b19564be464959ca59f5afeb56a8852c16842a03fa81e2eef87c2c9be0f0d1a2ffa09f537fb5bb5b78b8c1bab1c6033a6321a9b1c4787cf39aed999d3041a93093a92158388179c33fe95f248cd4a35377d1815653ebb67856678af095ccb6ccf9b340c4bef96e515454b63ecd48863c9184bf711647d07ffea2457dd2ff9e9a967427346ba1c332304c40940fa78f2b7a0a4e5d30644f2afb6de1571b04a31c29c9d5e32f21a9463f2803b131d2d7bfb1a16d71a1f975451babdeef382ea41e29b6d7f2f46eaa4245fdd6878933538843e9790c972cec3cb6fa90e0bfd9122213dd2a48e97f17c14bf818163bb4e41da90752b518bbe172702e01c08c67845e8574ed7f36eafb154d5cb78a4051c03963ea394f92b0046d337d68396e80c514b21344bb3cf19d7a955fde240a9f4f2e87215c26a022cc7312284c5a77e721cececa1479e4059d1fa9d8e7148dd1ba4dfd88cdb39e9cd6e66fa3c64b96a6efe15437361a73d72582b2029b1c688d891f9663aa7ee8f6edfbd10e3639e9a5db4edf7f7bf8baa46d2afc3f1e24151409c563165c188319eb66d84c4341decc1f24925c359f76703813da9023ac890e77dda681d947eacf7c1aa80927bd08ea4dc0e0cb148096030053260caba3cb32ce51666d42b6dd5d5770fae36255b81d19a726b026f4d199e6af7707da00097057573fbc3c1e8229d13948c92f2170529161390d76c715e6be4392c56974ecd64f38aba49f8bbc3c6420184bc2c745c53e6e150f735dd4b0333cc16fb4448bb031b5b5ba81e52e9ff9b2f4997a99b324683279eb3deb1087dbda60992de4ae28adf8139157d9fa0d66933593f3381468b8aeed232dc2648f5adeb0a69d1b2ca8218c87ad9c7f76136b35646f89abeb033a3c7acafb375d69a64e8d270f659aa7be63836c9536f76ac1f365b2076d940ef30b77aeb5a3d2b2df8dca8e914cdee14ed733d6ccdd2d65d95ab771b36f09a59701048a46fe4d5d70fa93779cb9baff0a4e5794ceb46f83d7d122daa15d330ccc866ceca1097fccbe1c8c2ee1b5bcb95a11eaf7424da6269f5f7c35552351ccc7025b5c39bac8708967d30449564c0e4d3fd49663b2826abd7d4056c94c51dc77ffa0e42a9aa6f239e37b98ce16c2a31db94416b8625848d8a62d445d5f3626872016780933ec6044a26ec477af7d3f634f906c35400ccee64a3ca0cf2066f8e82ded55587bea7d2d520522e5f810f0322634bbad34cb71fb70e63c68a2d7a1f791a11bc7ca5f5efd74224025e5bcee830ce9a17fe77939d9e44538c212baa542a074afa873fdd97397759a05a8b2ebb52201bea545fd4616db570e91ce7a3c04e612736938e4570ab5061cda8049865322fb1e396b5cc6a823091ef6aa62d60b2c284bab8bd650a542209820754156438d4b4ed60fdcd3dbbbeff590048bbcc171efbeba5ba7e2b68db7336efd8ff5ac4faafe47df499bf941ffba5b6c0cfce6febc8ba9fee7e031b487ae9fca8b43f0f5ed6bf034dee9750c9df999a2201d6ba59cadf8cc8f003756b2a9459487c98c056713eb5227a9fad21b7b23be8f329e1374815919eecf61a60ce7bf2e47b7a690c606e26e977a18653452c814e7ff11fd63cab88a6e24085fb167bb0e9459a7c73656dc2e3213482e9952fe404ccd8ec32466f9e0b8aa4dd5219f07c03da512d50a7523534ad350fd748496ba98cd1c594e2e37cae109512e47a2386b68f865e9d8dc17f41ee5bd4ecfa9ceb22e87985efe89247aea9388d9ecdf328428d14af7658684fdcff231034fc74cb5562972b129387b601d7afe5b39ae1413ba0ce29ece148a7122e86dda8f83c70d4cd9cc04075c0328bde022bafa1e1c8a5572f35b500b4f551ed6c5d37dbc32437c3e244bf15ed2394073bb52003fa6d53fbe45da9996c7008a8115785df8284a41af289486e1a85328823e50c4275c3974675741cf6e2be3d268006c56f0f6db90b9dac2bf7efc3bcf20bd2f55a3dd796c72934bb4dceaaf379c8aac106edcd51fba89ef9c59c3dba73f59b68283c9388845aa376340dd410b8307231529020e7bdddc88f51d0ebfc314dd5d05160565aff429b9d36fc0f67fdb166bf4dbae71bdb95247018772935e06314c5071f14f0c0414b849ac102905f0f3a045a17cfc46d3e2d6ce9cfb90beb7acdde87e3450dd5b15e6860c351b62c4f88391c9ac681844eef0bd57d40cd445ed216294e34ffded1dd8071c25d8103e6a1b012ab83bdd3373821258d9b76eafc62238ac7dad16f716d424f097c30aef8db7dd0fe9a2f358cf755f9c14bab470f2f8a2b19b1bf5d9cc6a1c79f0c81f69c162e6d361ed48cb83c23ffd32ee2def2404551257094a7715946ad319a95da02de2d81be0126be4950bc5e61d5948ca66f1145e3caf51d7083fb63e57bb5e53de461bfddf20c4a3141e1c716584d30e24737942789d0ba3cfa464e81823625d3c3ee46aa2f521d9b0f6fead47ea37811a70acd606faf0a710dbac6d30270da315397f5139503d94a932be23f14546ece7f1875ad5264d43e00e5dba9edc6f4dd4e016aa63a6faf8d66684f3951b45ebe4207d70205eb9eb7e745c4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
