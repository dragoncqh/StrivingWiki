<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"216af3cbb07a3cb33b9a8f9f4ec77a15f6807130b4eb67ba694ea5961772f7b7b3cdad8ea7aaf57213844dc50da86f34af0bc0db2cc54732475dcec6a27d40cadaa6e54e5dc3363621139555e22dad5603fec1d9577e53b9470956522fd52524a7ffc5f368d768caece0b783cb2440ebfaa0391936bb3f33d417594e3609171712dae6af82c25ffd50c6f70cc8f2a46552e84369127ded36a4e5593e43bc66add322c475c8869e9edf55742c87bea116e5fc60783fdda106f25c5aa7fee26e5eb0f9a334a921cd2e0c80485b6100b3c0d57fb37150eae4c83dd11412070e998729b48fb117a4e441a3233c8a8949000f69677db3cfbabcc8664ae2bcefd4849531a40b55ef6ffa30b64aacaf92f4f88b840a733d3e44efb1e20f8a3300a0b060a0c22655b013a3acadaa4be995ef709447d4f0ece6e36c655e12c08644faf7e5645ba3dfca8f243d46cc9ec71d4914981d8be2f9ea640adcc968cf96b06b09c8a6956f2d4924626094d57040b7437708b100b11a1e5d79d048d5523ec3691ab019cf2f240b287ca995aeb628c83f452962709464100f989e45bcc81ccf24bd1a7782ae0c14a048e28daf49fc0f2030d7b0819c978abeca6244efa5ff83474332e3aa3644cbe25eb94cbea716f2ba5020ab12d729a352328f1ab5ec00da9f070f90c00bd2b90b6bf88d9132292b8eaadb26d827af262fa108779663c79683df1683a7498ba3162d51ebf96db8ec0d89626b0ca915980e87e9939966dbf1579010f7d0bc0bc71d5e30e1c3145a6eaf73ed2d2506657a93599cbd4e28583e088d379cc4435ae21bb2a96957499bae1b49382c91158e34e0b5a6975fd99e701e45b26ffd8d72049f30b8289b5ba8ffed38bc08ce02493c56f0e2e9ff93b538a31112737d44b89b4687ed4ed677c62a2a94751066eb0959ad4d11cdd0a9f25cad779e1aead477ca625e4242c827644f1a068e20c733bdaca074d3d19f2a081a3364662dc1ce940419f926a2a097ed1699136017626e6d1293c67a492fef2bb7ce556901a3657799d4941eca1c6e275a2a817e875fef251e95109a41adcbe7762e80799f1784c6a91c6d4465d69a089c5d1fdecc88146518ca3097f7af59947b808192dd40112ff1b6737798c603a63a041d457118ce5944e5e5f8b6c9ee905aae4d3904b61449b06e6970483eae55c910816180ec34d8311c7c99522ade6bb8572c2aa856acba622bbae03cc12742d1fa871d7cef4e04471639f8f4d9df30d0c97e601140a396364c7e29771abf37bdbffc2526075b1357eb0b8b4166ec62c0d145412536a922bcf26fccb5a68490e3b793cd5de81cd599ab34179c1b8d32264dc625f81e3accb45e541a258cc89d8569811af1bea67e53028931ef8b01e89fdacc77e93199c20792d9a3c7cf13d325988ca42de464132fcd888ecbc594c3b10d241277641227ef1ab10c3a615584975da8923dcf476f7f3c76792c897c90dbe488d6ad6cb111946a7e9d10f102947145fdabce1841b8e28a89b55c424d372523bdf6cba9b3dcefc28d3f2fcc2c1d512a6fc4bc646e4ae6d7f5ee40b739ec14251e759df035535b42f567ca6935fc5ada25c4cc614fae600f53ab960c5d1f4bc49d5b088fa285593890120f755eba86550b24054d7a7a64b229d2cbe06f767f45a5f7a2cfad4191ef79be212c8dde9b2e048b49dcf34016cd288451b81c14917fbbbe756bb0817872b2dc0d11eb75f3d65800231fc6b11acf3d81eb415c2ffa8fe142dbb6a76792958892a5f1cfe19a6dbd3668d59d5fcdf0724ca5e0d67ee0ef622f323fe3a06872c8d2d47897642c1361217ec1d38c06e27f9ac42b648aafd6c8396d59cf47cd51ba4242e95573943af18d024e6d9a34195110dc6fa3421cd804593ad33d26d25100e466c61df6fc2b3fa7a5da52f30b10960517a5c8f57d6b0817f09524aa044107739147c07848641af6ab5260dc090bd9482278d6fb7e4682c6b7169f5df65ec8d5a03acb3e4b7da08fe9ab4532a34171de6e5bee6b87b699dac325cca811859873d861c18b9a95c1848feb3fd23cf756e241dfd12df5847d37ab52e31c545ddc2cf7294c9d089f5330234a66d78b941225700a568958a101a21b2ea36401643d439772b4e43c80af35dbd3ba8fb1d445c98c2be2b59934055b33911298ebb40e16649a299c4c4fd0c6086fa35c3d198188bd92997848dc2a1bb6dcb18e229872f966c26c4e85e095a497d041a78f64c520bed2f827136d715b805645ea0f2d8a0ecd60bc0c53c3db75663361b847d54962e66b516077cfb79e17d3d8bb2d081708c192486a4d80beaba7acbb4fa73fc50ef9bb17688066e839e79e96de575142b94a4d97a12e4f04127a8a1171a271026c46af64288f2945bcdcbf58598e24e8b984eabfefa579826790f6f480e68526c4f26635e5e737354f3b12b1dc6e237a7b4493f2b500aebbce38b6b0a52168e56b23825109faa33a030b383eb216ff4dc74f72443d16e451b20b7fe638840e963a4952b2ee9731a9559e3c2155bd2845b39a44b50f4fca1d1271c7102bca0c2657d1366cb2bb0a6cf5b85e324213a9fbf910e72d3afc97e100d4a43925022cc5c2999659f8c1b150d30ea98b488b59b6896a9e9a160d8cb1668a5f0b5d4d3917ed7b6cb80bb07fbc0d6640c20087ff559808e098e4612268cbfb27b99a1ff37d702d100e36473ae68e982b73ff8c889d71031a5914411cf619ba4d217915ef905533740341e567f5cbbab17a4959c2d36a201ee8bf3bcc0fe6877d095bb7b7f4668b43a252622fa7c653430d465090da7c43aba6a49c88dbcea3e41836cc15a0e3a39f286c45061dac21569b7748b4feb1685f373c57889bae521ef649fc630992ff5be999b0a305bb69a5d23f00d80d6cd355356246c8d09a81d61bba2bd0aab441740558416ceda1e1553d522b64379f0de4165b382fc11f22c6cf3751219f15778f1f914ae89df6180920359810b0e4e7bb9dce58c4587609c82d692a06bdb5c75a0a70836a44e4e273dbc030dbc0e17a553618df5822d572e21cedde74c29ac766179c226b2e66a6b847b0f240c2691995e8ea3ca02e3ce0059edf00054d55a9f1f79a77517368e74b7c10c38c93415cfb67d25d7525d92f94e59a9cee3c09f05731972ea516e2c77966b03bf6ce240c51e2da6019fd754a21141cfb63709dde9f5ba399b9ecd300c32a8d115003ad7e1a860e23cd67c1f203053df74e9eae458a9409e9aecfe75df187f6030c6ea5b6ae56c01ff56660e57548ce613be3b9cfb7ce876af3e821617ea420dc3aa0a7e80b1ef3b26381d0c9e696d3be96bdb1b1e26feb4d2db8969860a46993f4cc07ebeb770fbe38df3acb22dfefe6894df4f4ca63fd69adc39957ac11b6b9549ddf522bd856b847839fc8d95148f95881743f65a4c63d46e2325e15fe1dec1bfdb0b82e7d319c723b1a436a00384c38f76c6dd946ad0d73213314cc9b733ad233e4cc99fb1c5258de9dafa3bb73f7c9cf2887e215c5e155a72bf3363d65195eb8620d589eebc2c9423f2344f4152d74a9c6d8ea98eb6262a3d1ee8ed8f65b53d89855183e76ce5b312ea56a30feca2a60cbb1bb5974249e90d4a68a95f6401eb2b8e676940e74c2e291508689c75477c3810efb78a4a1afd70f05f442a4b66288c07c625e880766911045be58ed56c665673d2a0233ed8ee3ae20a065b6e3d5bedd5efeacb6a3f397715e9c214d387131356c62f54f56d75c2da79c346555b2361c5c88ef7aa13498baa4a4f351272ad4d2bbe109277e4a8145a4ca098de161cd04d0b1bcd45fd6f8c7dd0b4461b05cb6b27c0938aa933bb11978e6b291bca20e8f1dd16b3f163529a62e133815d59b1e4fec5de41cc831a62453b2367601f13f5f70d79e230237dab501bd1c4d7b807d043e9b7d5741f0b0b333674d809a327edcefca484dcf9250e9238ff0d3b742a4f4eb685b5b1ef9112414f57a76341b815db3a6d3a4e25883214ce955e8a60695113de67bb31861895911842cbaa2f99a477cac91c4be9a8565a694cf6e652d35d1e3628a54f7a5159e12d6606447738e01e56775b9f2808fc39a619fa54e8e9a2af43dde6f0bb5edcb816e454fcd3a80fd0cdabaab987ea8ebfef30f962cae0882519b0a7b38545d7587e8981bcaead353dce93ac4e3ad81deb87bd6e1124452496c3a6d78f39b1fd8732c91948f512e01ef5ce4d7684db4696ad654825255357508f5ba10284f647c31b54f3e70751157d76f2f99a045d33aee56cf4d881de91eba0d730d6c0cbbe8c70c7bf7578ae945a96c7dfbdbeb7d60bee6b8bef792933ce33acc02600c7f1e34d0347d1af710d9e2d7bf4750de5ea39aced303f95f7a22c144355c20748c6ede7472feda3fdedcf12a9d3696ad27a39ee9f0209e466f11d8658b77ab4d9849a055cfa1aa2f3bbb32e21bb967a8bc76bf2af057ebb5ce4b385417f09d25607cb2ea76e86f9cba9b2050e98c86aae606625f3c516c7c3ab6ac72ba30f2ab9517627b4c6aab6873024487ee789db55a9c1376752aa0a143cf9e75e616204b479cacc2f2b3a8fbe5f36869237e32d4f487432e7abae3bb188d7f700a10cba2ae889d3531899781bfcaa67aff74250ffb0d955fdc6e506e042e769f09e8fc3ccff0164b01c8bcaef6227f179fbb2283931f993df3f3de01150b2cecc734dd045d12d6d12356a14d0192372f9aa2076e586326405a4c5b1d9517e65ab36f73e2e75606f682cf51e9aa284d17b01248b765f160a898e45fedfa54648ff6cbdc7949392b49e6b054cfdd15f506a3020caf9311a3f184dc234bf239b026ca8713cbd30602652ca5b912f24f59cf0be819bb290f19ec89098ba7e3a1e99d85ddb28664facfc4409399543759353504850945a3b70011a876f83701d4867be75665e125d09931bbd9f8c6d23c6ca4ee5a832381904bd78ce6fafee3243ae3943a75eda5767c2198e0fd44e5884210e8f35296b3f628805a02934c2b7a2284155a90b540d64101346caae75dc46132b0dc724c77f601269381e8d0f29faef9ae1ff05fd96d9ea1163ebc85d381dd1e1d4e0cd155ee6cce6054a75fd47d721b3396ad2b523e7454cef724b4d84d341679886e2d286a19609a881ef64df978032841bbb776c2773d16aae8bf3458e7bdf2270228b58e18037f82163a180d058a8138481e1953f18c51c026164b754f7a1485eeb6f3ce945267bd98404eca7997178f41a97bf46b8db4804516f4b0407991c477c7eb7d074f2fc11ab1fee68af39db4ef94a3870d6264d494fb73579afe6952898bc77ed8dfbba0b2ee15e10abae589a4ad71349ff75d51e7ab6eed3f1ae46cac79eaecca6ab9b3a844892684199ed2a544e9e4b1ca3c914c211848e48a6f48d73d8cbfbe275d412e013b51c49038d7cd8221107c5211502080a926113c3d01d13711a358b59e80c19aa98effefec4ca1e0535ebd2f7786560fa77df74824f8c63cad0f0a4124c0e1e00c677c997465ca98d21cdd8dc72476b6f2ac186ad205075ef35c9bc220b231424bb6f655982fe466165f78537045dc96732bb31ac8f3c288f1eb4d595b1a0adf37d56fa3bd49a5c073bdcb985c7744da6d3116c6b39df7603835fffb760dc110ff7741b758345c26acabebe79d69316b81c7375d2e24b51eba87224e86f60e5f7fbd5169d513f10b005b159fdf41d0510016fd2f123a08f62f63434e93601adbbcb95e3fe2bba3f9d329ce26ec735f3eecc6c33736d28b6976d7134814146d6059a2f47298128f0d5212a086a012e11d755f7c871e437b74fd7928a781bf708c0dfd26b120e70967c0848f5f6594747bd4ebc17e4480dc99009bfdece35c6c5febf9f41fd4ce57c6781b2bb6756bd7ad7234b1edfee44d54bc57db8e5660d6d3b19bfc5d643ef74f687cff5c204bb9ddaef6fafefc8f189afe07e3be4307613d3674c4c94802ea83842c52ec05fe2bd1bd7f696d2d340cbf507f036b8790447399f2434d434285e9b932f3429fecd88cc547fb7ba5df1cd4e3e752e22fe75b9d3c75c445883f058822000ce4caea0dcb42617d92c90226039f0bdeda7563d436f1c5daef754c50afc97c4c83a6062c2b506b0af6f74929b3635e74d9bf3f8b0c603a26b878747e32819b2ceace284291efbc022232e57220bbde48753493bac250d30005b7584d28314de07f27a175c20ebac40ccff1dc00f4929df63ccba99a7f50e3af3676ff67df3e64f102308df27cd0eb1212bc7895ff43f6f58896694bb1c0571d8eef63cfdf3ce85b8b9e25315335a90e13d826997c41902b2e5fe68c9842592eea432dade942a52a916bbcf4596eb5831d36f36e0f0b4ab6df4e2537f2e7113cf3fac815a186a201f27b20b064e8abaf99f2b0cb5243846ff79813ada510167c5e969bd60de7c7804af9616374d9d0bc9e848b6dcd966f99a28c27db2ab51b0cd023e32230c5ab6ef6239781b8b119589f347401a53fd2d451830348096f6164ea84b0647bad911805fc30d1e13ef3cacec03162768fb20217bae7ef225e6b4c46f3c89191f47801fe407011ed31102e2f11e879cb97e71a76bea96e7e4c0197291958942887b275babb8374cf0f677baf53bf2c7e2f9e1fa94150dbca5dcde58ef32987355ffb431e4bc1968c5ba659fda523638ec50a47905ccdc37371ab7a6fe4e12535347a519cfd3e5149818a2122c0dd8b6bf442362b364bc4defddcca9a71ff8da746c58d229257403b704badba79a52e0cd8e3e838f1de9bf6a3531048d7857489d899496d8bbce4fd444edb243a29cf014f601d3741cdde948cbfa85f46059dbd7794b9c5ce21494849cf7cbba3d631f555a1b6052b68e6aa0c007a2d3e17cd42547443c9a36a90c04944d292599544d824549b57f5818bf94e8fc840ab1f225c9a1dbae5475d2ff624176130e9ccf2b2783752d6e8baffd82523289d6140fe58c753e60c5d5186f2f6aac8fb61dd1754c7fa5ea8f806e0056e4b732db780075a8b6089336da2d6e389ad0544999a9ee2d1817abf89c005ed0ca3319b5ff8117d7fb91cc9dec38dc1c2d67e3d2976d1a7934cb798082665299f31e677a361602bedcd85b523e51e3e16723d277a48bedc85d0869ed642eade834ae3573cce177f732acfeb5099176b0f7bff959b765803a748ed350346110478b1d95c18763d35d87b9f0a736f57a06d172c4f7e783cc7b2c123caf9a0367a80a4a375278ca3de7c1dedc6984b09c3844c63b329d112fba4076167caa02bdaef286dc0fdc9cc0028b37afa901f7a6786fd7be88728585383ed84b71f90b1818efb6fad98dd855b19811c2fb0dc459c73f91171100f7c63769ee58d6341077c21313dd68dce6c7e411b7eaa22e91bee5bf63c58816fbb1abaa24472f99b122dca99846106bbd3d58dfba8595f67e3ac431f26dc70c2b6727ce805c517533e0fd0a32c945b35579f67b38a20ac302e33f838f8e73ee47854b974ba7828e8f12e8f4cd7ac62b0d49fbbf0a950368dff84a7f7447ef9279484dceac82653027e83d6864b5ba8b188dcd95194f04ff73cfc8e81f1b606b154e702174651da132b91db34270191ecd6c957dbd9cb6c171ae38cffde8d309b562dd2f9ac9b2653ea6e89857fdc02fc35650b45177a294776ea1c470f0c0687b3ccd4696d78fdc507520527566532f1438fcea09c98a6376070f243449b07eebd1cc5770cad4b133ee59ed9f652130385cfdefab3589e7e65fbed657ec0c52ae1655108c668801ceb58b51f66f099f0a0b02ca31be2e41af1fe9e5184a97676ce25c948a9b21356e146eb15b9a000f6b5c7de0c85461229c866cc3e3c07044f23e9740efebf1507699606adf041d2bf7ffc264223d74f64c540c9513ca185ff095632cd4e879d71db653a1d9dd6ae5532fb14e332612879064ba89ed29ce5e93889d54f3cccffe3b029b2cf4edeb8e27873d747a0c13e22937540f8ae05f69b165239127afc6eebda02d601320257f88bbe946ebc1689095cb304485803b05fa2a9e980d8376aad78b66fdb2b58eb1f3cad45f4b04d385d215e50cdfd2c6f756a56e2a361f186adcd0400086834165e678464d6f0ed8fec247fb5118037225004b1bf20e4ab09c56de001c08ef398997ea0d1e8781d1ba7d130e08f5f060fc5f0940ea5cddadba5cf2a1b18785ac89067fa286954d158c3e76e9866e3a3727b90441a003be0e0fba7f697e0053b7995f117875205dc853658f983c5dacbdc38ee93b278cddf5019fb5c60694332181082befd24f5e19cd41f3978c07e248b3b1ded20cde5f4e50d411f2da56f8fe12efa23095126032025d88951a4adfb7175c99b9ec346bf5b8ca14bdb9fe6e8588ff94a6dd5c788a3d80c456365e18738f495c8705bf429823afc243c4c8d8c2b441686737c4cf370209c1457deee19646086bb6ed5769d7f138b8ab394fdffc86adf49566010762c86f06cdaf68147a1c22fab6229f3018ddf2b8ddaba68f37f913d1edcc51afd8b564ad5257554e4138388c37fa468ddd22dd9ed12cef0ef65f3cd67b46b0892790270d2c0523cc3a6cd1ed56c57efe86231c28e51c1b53c71201df336405984fd5c208b1a22e4276b9b352d4c9fef73eaf9c7d199511a7fca5be661cfa1d3b36b0fe77b68f881bcb3bcc52adb302d829f7d8939149fbbe4a30e3df827231c3db1c95f73dc19fce4e7c804ac2e5bca7f6af086d6637129c6bcd99783a125ffbb35d314d20d4eae855467895e6fbec1aefd754083e76969355678455aedc45a414cdff91abf323295e74fcc2c77d6ecdc784eb6eac2e80dcd3089c28f06e57e92a29e17434f1d7fc271ffbe2c2bc436cfb80071eec232a06bd7747ba12e0a6e4d796f0b8aee9a00071bc1523212e1485a5520b614870acb01bea90a9ae886cf32774e301d3b38f39e207d167b63b8fb2a08f3424bad7c24001f4fd59977c0ab6a4163a5aaab5a6bdcb722f7aedffb8bf746ba3b917d9e013ec1388486c1ca57230047a2ddb3f4b3f9acfb33ac5a36321cef105b1480e654999e2f5123ceaac751c9b5ecf75c6a6c5fc8740c5f03d608494afb47268ad440cb58ed46d391a5e11aa3406f7ff5bb1ce9d0eb1431d059d044263764764698b84ed2905aa7a22b70ed0fe5b5aa2b4cab2607a007aa58cbc74f237a6d82de255e2be8f398272b4af7a0c5ce0004a25b30dd6dd3352ca197d69b3d29b17a9868cfb0799183518aa7262d22ad748167649d0d450d1abd5dd207cf266fe6b419ef0b6a809ad7a1b1926bc85e8d9d59dfdca93ba9ee9eb6cef291544b8f4de537cfb3d0573ed5dafea23b7dab722f8cf44cc293fc0d9e9809b9c2724051547c9c1b425cdf28b094df6bc6defe384569e6de30566799a932de59aeb15c1dff809b9433a73e5c92facee48b8a55d0743ca518dc59c2d98425bc7c6a9e47f35999164676d346f7755430e01d216644bdf087980937aa9369c246e43140bb3789d255795959c1fe65c979d9b7948550f4bdc5d3c98cbe41031c7cfaed230348b05c827dd15945f1f6374ae94efe608f200515af7acebbf21c377c712499bf981a999234d0e6af2f2709e85585fc9eab1f444f420c240040aa2744c143695b730a745be8aeb8fd2fa5543d9565c892cedc19edf774aba2fb174d0134e11f38670067c4ef43daacd90f0f010ca02de3c2536381fae0e99667890fdd4a28080cb63269a274e3633834f7b0e72bc3cf5d8454c0a00105874e4fb1cc147755f984ac2a7f05397ee99ab6e8b30a222774640084c3cce9cb1e2f662a00b4f195e984362ae758bed0ecd187c4e7ef6723922c3bf1a486575b64a4f77c49cb5f942d1cbe5aa08b2d18f7167de0d542f439d998541510f4f8897b87fdc3e0319e1736a1c4c26d2440a5c98a6f12248805991eaedca1fab9d2235e617034c9a6659270929b4d84a5b8fbb9cc665aa721c64f28b24f73d2dc8639b3b4d8ab318e5005eabfef4c6fde77bfedad85f639b2e07abb56745ef7a4e778617abe9eb260","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
