<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"23cb149df23c32c28865a1fc4b3ac4b7fb625f8ae1eb1616435c28bf929458d72b125a070c6eaf65f3b4deaf3392b814c1c4ad958a9e6d8e7e23413405cff8b384dcf891b8162581fde4d6e79dbdf1dac354da33b54a9957cbe300055ba8a3100b6d1fcc1e0a041825d37ed5bf07682bee25664ddbe597149a25e15c40df0e94cda35a6ad2d701476a93a1433ccdee229ccbafebe26a5302c9bff4534742cbf7ef5a1877fb1f83c9ab4a9035feda0ed42c106e659a5fbe72b1dd3670b5dfe766b3c96fd52248facdfe584599231262ec54db9510f9aa983f33250fbdef38ee44a1c077c0809235289cadb31a749e4c99bb14aefb744faefa4f414ad5d8b391132e5208b59644cbcf9e796d8445d127ad693e965bd5d5f93423073652666f69957d714ac59f05caf3414aabebb37a909024c9a27dc61e1d38bbc26427d59241a55b1c4dcb61e056eb8eab08adcfc6ab66057d8ff9968c5bb5cc8dcb95846cd3c1c5c7b100e20f029353931dbc262df9b39507d7e6c8b3698765ab22cb44f69aaef7a517f459ec2ca2614397c3bdb7f1df35085dd997009b3a3f07384f3b77042a342a85d58d7dedc07b35899491042e7e674a9703aa916f88c244a03dba423fe73d852ccde99055be3c6f0000ee67ded8d20551ed13c439f220966963792933c8692ff466327a195f44e015583b44540a0b69709f81018c36a59e8475da6d45b403c9e3eebe588ab6c556c5a8b1e282007142d196c949229f4250bb80d0a65dead9c621405f5e6150212340eba1fb0b187b94f172b9476713604183f6e3b2da25f227eba479e87882f943585a2eb9934fbb99e6f4a4e83416d338352b5470f52f818388d377b2ec465b45bca06d2cb01d9091994b9c92c20a90ab13d074da33d1bbc5f7aa85ed99ca9e0709d056e6ecd87ace8e2e2def67abff217f347d614c93a6a3554df200b826f7944dd090c17cb9b21bf0099a59a7c7769c652fa957c626c4cfc11fb2671f4acd5ca0bcd2b400d6d83123ffccdcc72a219aafe3146efcf950a05a900d8c5bf8dc85ac09d657bd01cc65b5dd70a1ac35daef91aa944180d1ecf95c330736349ad2d379e61b8e8d36d0181ca9f5ef2c5e35a1b2b3b0e86c4cda16e1cddd89a7994435ccd8dd3bc0d2e8d8ce9cdbcd57a996e3d5d062233edbefeea5e9681b22cd3f79ca73c7d5566da6eb899510b03bdb10e0e1055ec0255dbe2f711de3a268e54686fab1d99bdd70430a03205d2979713eecbb3e14b0cb3e72127de44356109bf3c525155d2705c445ff1393d9dd97a5db87324df4719a1e637fe1d5a858a038f0f0d7543d280724ee58eef460160e2ddfb22e88b42d31630ca97adb71074d049e9d416379185ab4039bb09227fae7fd1dccfa79c353d038319de5cedd7a197eef764d740a37c5ce446ceea607315731a98ef63cc6cf68941547795621b927c048e2f13f074729d8f5e87785e965f64fd1c2213c6cb2d7082a538557b619bfa994bdba0c05733bf3c7897589b10adfcca70720bc58438518e37d2bc63f527e9ccac2f45e9ff23515c91bf9859c8f2b751abf8c43813a9c5a1c437cab78e50b83946f7a3f8737de505ffbf13e04ac84819b354f5448ae74f2f98caa761ed94b3f3f5d5b9042713a86b2bf0f9073ddb65d4d7c25d195d776ad398b66726cb59ce503d43adb9edd633863166fab735cd2df9ebf00e720ad84217c4922399a8340f97f9da6a5f8f36e085a803ca7a42e25f4be26084b73dfdbf22f57391e2e6674488aa61820020c8166b627da65561392397e2bad7136a0f86a0af3b7bf244e766283dab4784e6deadb00e824659acf89a9ffddc26b808389b2732f2b2223ed43e32121dc150b6d5d0ce684da8345cc208f09a00aeb1e5a5e19d1adf3d288350e3571ecf34122e7a16d3c68592b961a5a779f02965b448741bc5254c1ed356059239624db3e979bdeecdbdc8c699e445777bc21af2715b95357299cd0f53fddf0e815f92793839819481c57d49563897905d7f3fcda53c893862ec3110f4efa70323c640dabca6c03b575ef62ab50f61cae87fd79ef17956fdb2c01f39564942d0bf14c12658e3413b12d55bbd2a536fb4b8ff3d10002e4941b3030c9c59d86b21ea9afb91e15aba4ec7f3dbac16fd9fc2983ef2005caefed76ff9ba1b2dff3375d51173183a165fb91562e953246a46535d72ac37d1317f062e175809a8171dc4fec73762ea67ea0801e7c1da8a916d9bb0e96fa04e325ea17b1b63ae72ca7797274486c916278b9c4e89f074045c929ccde4f4b094ca9d459ab85e1f1e9b79d2db6f9aa41109b3a581f3dadd7c03e5602d940b47f3dc5a4e97d8abf6970537d90da3d3f8fe2ee80364f3b90e888f28a7dd021ec222508b8526b076b079d5f82f779b1d5d10c442521a4e24904921aa03f6ee401626d7a16444332e8fb9b328f956aa3408af2c086cd2d2debf412066d3d8bd98ef54dd14efff3daf913cb2c636b338e87cf0e02536f4ac9da4f14ad771a2287e10deafda91a3c5ca177c77f3bfe007e10c5c3c9f9ec872299ca00c0afe3015ba9a07350f85edf8585b990553645a3c6a6189b4febfa898706a9af3d21d8346a9ec0e90549bd785ec07c54142660a19f758e2453444600cad3d98a17e57d5df5e7cf5cd5f99c1a6f58fb6535df9b8fec8ba0bf9e5fd2b973d62f4013bdeaf71167f37ede00d770bc57d8cc2c0b1465806c25484c3e4cb66bbb4848a3560b2e80d8bacb7f2dab5bb2afd40d415b4a4f46377aaedac43dfc0cdc6d4e48a72b3265cb61086a94b15403ddacbf9061121279ccf0c59c41b3f5ec5f2076e6e569c72f9bffb34c885aa77fa4609d6158d1a877e8feb45c7e03bcddd536c4a69a74644561414ee1ac75d9b69194e284c8d982bc2832d7198d3b3fbf2259176de5d87f456aa35da3d9450b8ba776306331fe848ff213fda49bce28687ab219d9b6b074d2d5f3b924bb60d2d623613e2a7ff78b7267f2caf279497292b3f5bee025d437df4bfd1ee270f673effecd4590c9abb01daf174403783a53eeebabb3acb3497efe422a7206dfe062739e3a916b8bf059aff16a8d96cc5980f4f2407432deec076bd259cf1a7798d594e4f7d2afdc385749004783cd5e548d8b92ff1dc68ea63941e4fbffc9e834c21663ddda95ed16e18cd5b301097e140cb435433bcad2a0c0e428394465864008a623f5a4d3e9f89fb2da379be3de0cb67529322d13d829bae1f56c549316662054b5bf28fd5f661f4bf8ad214f6172f848b925bcc18f6bb7d467bbe78953b67c95dab3a5b33ee515e5788b82ea9ed464984b5120d321056e084231cc25a41f69afe4f7b3fdb830190c0b0b66629e5f2a586459c8d42ea22f318dc3faf3a4561671bdf0a151cf21fc5145b8a266cafee953b725db3dd327cc364a8a1e4789b57bea2cb35e19a3c5cc213b82670dccb3b003ab43a274a92c28ffa7dce4406c35a667e7e1a6cec39b6f0dc352075ed8be1542bf6021287b826c0bd4d75c4c214197833123b60b7261c40c3b825fed4e212f700077097509fce38975c26c40097c2733fc9b36c01f3de2dcb7077c9eba993c89882eb934eece585bcce1e055f3ce946f4ce91ecde51f7a4126da2d06121409bacb48942550f96fe8a5666d61e90baf26328184e4cdc9d7d5a1f1cda46d04aa583f130745567f394755c70bc8b457046c7f07373d33808d7c8ef2435980b2b58076fcaf22245e84c8800e07a57ebba1cebbddfe12145d51cbdeae68e32b03f968f6efd5a3193abdaa57de02d7c38e155f43b782caf94cd3490130a6c2857fdcb1f7e0a841ad164d51e4408e5c2b97e387248b913aaba2f271fbccf39d3ebaeb6d182478151ef8b004cb087f6dbe72a4201bf373d23b1f8d3cc44148effbf16546752cc646d5373bc141eac9ae1bfc75528e4cab7625ab84ec7767bac83819fbaeee372ba485d80b7fb199600cecdd9699c01caa9f6b09e4e4e226b891d4ae6d60582ac2836f352a60ae7738c0885ae62a0aa40d952f1a8002d8e794a627f4704ae26cf9cdf8fe2ade6fce1659288c418d1e0f0a96de2cea1fd8358a3d2a71804fa8512c5eaf892cbff3cc473ffae88a019cd6b47835d16c1b3490b1d7e1e6ba5993a13b753f8e5cea2ff42f72b9385ebad38442fe5c30ddfbc6c9104cc53a73b486cc37a4ebd2e874917f46ba21642796763485c9e911a81ce8a3df1b0e8bb564e3f21798f9385684764a6330f0143b56ce9364f6af0c78f1530d6ccb148d7444615b386872a8ad02bf22d2de9fc71f7125aaccf52475644f8f8746185e7a688203ebedfa2ad762e013e0114b0302e83193131ac48ecadb9fdf9052e9fe8124097d6ab48197a58d39c9f0efd1c896670c39eef94c8efc9e5fc92a39b7686a49003d5b3995da0668b048231dc22582175ba3b497f7dcd0f2ec711f7ec9eda779d46f124d85b32ee564864b0035b17e0033ee57b8928d614696c891035fc69b2f948fd28443e19d7aede3384a20dc9101a921585a7b59de6578cab6eb6ca6897d8f23ebfb3e7d27a7d257d0c6064ec5cd8edda39d446d22b7ab22d6b242b17ecba65b72472225db6e00c58536be97dd6223545eb169cfcc726a7b31e12e3660e04ec6aae0a37e4bf09d3b4a613ad7d816c574be5e0bc4a6c661bdc5cf3b5739defe9d8b058ef164cc34171bce81e1d6c1d4c104be7f4ed413adb2e3704134ad63605d31c8deebd19e59f5f49baa50166c90f8485950d1f064788bfe68448815e935b3bdd5967b9332640a6caa848a5e5764053afa9547f15326ca8ba96737443e56f4607a848f6c41d1cbe08cf892a9eb1bdb74547d42782bb8b2a5df68a87749ef222eee5e70f8234ab985472674f35f9a59c150cfc0f579941de4961e9705d9e325911e1b95ebaf01690f2d26ec183e9c1169a400fb0accbfa46e2618b8e944f2e9af54c117186e64fc1f8a962ac588b83ea5a46d72332a48a19e64e55a4f42ba7ea0f4751d7ddb030fe34e2259a0841888518c6e3ff37cd25e19e4b67a569bee9a07fa313bb63ea098f31502d807735064853837145d2bef5edb3911153f087da1612ae3ffca59bb662a903a0e72a37023d9278d6725115592bd0c616747e425ba010c2ece4dd2523bc3eb6c363d0269ba7c0ac0350843db00b477cb595b3b93e9e119242d4d11acb3379b65fd6b85f25fe54dae82b2249085e84c5e3bc3075e193e7891c958a209eef6eff7479a47ddff2e232c618e490a22e5fa5a99edb4b1054423f1ae734fec1cce94604dda30c631236db3fb89de161e8e887f42f5e86194323ee25f8d3c6d825e6b566489826c077763a629fa38953ab9e5b626d7f8568209fae18dd275c2d8cf7ddc418b3e1b0683e33bac13c608b6747f578c051c75d24bbe2fc0e5bde60b25991db8cb3619617ef1cf95dc06ba590b2836973c16ecd35c4551ce3746748455885a6479fe794794a70b5fd0b6ed0ec8b97d24ed21af2c13d507d7696a948a2d97a6557e997d2cfbafaf95f9d0b3808dc590916961c3b7ad57e5fda7a3159412160f2d87a6e9422c527a86ce85de7af5d8e9d5b7cff4d3778eeead22f680225823fbbdcd91fbbf049730fd215c80ab2004dc3c823b69e214393615c8ebab54349c78b4faf3d4039455ce938e26eb9cabfbd7bbc77b57258d5108a80e4c7b336e729b62a82191a75437f70c5b67308a410ac176654597024de769bba7fb57ad70ba4fe039204375ec8b7d724b20c7ab8ab7436767dafe367debf71ee253975c7e9ac897f44ef371da83ff349b9559f31c8df8aa808ae3c0efd88d973d8ec87be5cf447c1ed174d4cd7e187f12163d4dc2a6c49497a6547b7b0e79d4ea848ad869c1685fd8decda85c42fa4a76978da3581eff309cec601990058e850dd037b1227414d8a9cd562c1b23007816abec099f4489ac677a81a22d65b2fd9b1ada53aefc919353e8f91452ccbc0195a1cf076bb3564550b9baf59868bfdc3f33945ae7237353d5332a3651dc5caa73590fe8dea38412892851dc13fe9ddc6aa09e2b7a01bacdd344a29256ee2534acdcba95f00c1ab442caea40fc9a2d4411844afdae37315f7b76f1a9912936e1bc36f0d73cbbe7a9b5c4a6f38d28fae5d15878582024bfe465cdc7f929a8c92c8ed8f3819f45c7f01ce068dba8c8b2cc7519eb506b611abbc2dd760d9823c4d6b599d2425c65ba34c952d91e3b56f30e8ad711c3624a002a387ec33a76a7a12d7632322e026b71c8697ff007d5cde9000895f81b3a6fa83704eccffbb5bf1f564fc570443d6eb12836dc6a0568f4711ecb06ab58f1f39444f1505381f39da25391874214e6c10397e89b6345283ae128f793f7180d1c54de7a0ecbd9568390d21707c5065bc861b961265145c0516f003788b02beb8eedb3b23c0a5d2ed7965cb0f5dc619c8a542a24769291fae584c5642db5325ea6d42e9fba6421d5a4622aa2d0141513776edd27cd1e460fe10800d5599f751a7b94f3cc64fb8bf59e7b9c35e4ee88edb4ec27d18fbfda64ed6b4a0298cd2d67c42f6a30f810929d0e6eb7029ef28fe9d918f24af4c864a8a9664128f0481dc514796ea107ff5c23eda7b1783b33b549d6b807f80895a55c8a63ebb6c7afc97d1476de0b1f220f0228b84ff04b5eef48020c6de08e55cf89c9e401ca9f4c3cb5fda65c08daaa99b483f1c16dac3837536f6e7ab71d5de13093638a9fb22a56904c7872495c30b3d5a83eb9873b01fcec9467d49a5cf7756d51d33ac8e4e21b76a48725107481948a50e177854bced6f22e723c8deb9a09536c75f9eb27e29b1d3bcb172e2ddc7af14c264a4b074ec9368e187b23eda7332121594f721dc2722c7df469937d94f441f222048c82badf61809b5033e3b7b50b0a776caf92a87b1d7d7af219f2d13652a97cb7f267100a79b445b1e71524c30cca64ed14a7fefea5c1e9af7cd6ac8a595d164652a6e702496576677b1ea4fba686a276b27e8353dbedc37eab9899fc5112e0547f3baee7f5461b2831946b204e416c3f7e5e69506d94d734c718ca2f3f846f56fb083f19e239cb48b86ce735e69595b774c4076fb2ab8c48ee7916a8932e0f10e979de4fcfbcba387579df919e2595de7f1e5a1b0c4c8fe3bf5ff25d1d8ff45cfd2c7b94f2744c674e4b9e66ee5d975d1e582c6cc0777661145be5d2b6f3987a9ecd98ac584885645d4bf0f7452f39da65e30599b81da97bc2b970e9c07693ce78139c72b9fe4a970c9363cf3edd72e95348eed7ee12f0649de62ee31c9b3e7fb5ac5a49a9295f0f1f1905124324666a21368abdd7765c3100de730ba578cb188cd24af77a22483a38dd665879ecf121854dfdabedb27aaeab194effde329c58d81ed8002ca8d0bc96802b27046ff7679284e4e8a73a55c8bb79c2182c56a30d968420cd77d4baec4b7f5905126135e0bbcaca9b6f793ef7df01fd67827ad4c13792e12e37e0d14735d69177417b0412d857b18c6ade770717c8a1e6c022733b925de7b8a3e46879785029e9075156b94b7c287bb1ce7652b64c57420672e820f8a265209e91f4ea6d618de9fdd42a2485d189a6844990e23372362db5f0df2f75cff9d2604b0fb3de9283a26e98d102fb3c1793dcbd91b4aa41510f8fe01bdaa716c34af91deb839dec6878b4abaaf6523322c155c8d319e4931281f68884aa9079280a348fd1efb78c4540a4f40b8768955ea43efff15283f2dd970fa40ce8ded05ff643357ea0f52ea6ea53fdd13d08ea4d04cc0e3c8b0dae4e0ecf712707a6318880291277c2e052b8e0df592b444012d8858098afe0fe844efed9ca072a4e0afab11d526108d414cee18b0996cf61c657fc5b8c3db49caeebc8a1af7aace8ee6e9f6b3f96f29409c08d6cb94dfefcb910537f859003645a431ea9f7ba66bae03665b9f3bf849046bf05ce72ab2fbd8b9efdbe63d08843da3c374b4bf47202a880b1d7899d4d01bb69c2c7969c9553c7b269a9ccb87c9d66f65541780210faa3fcc90e8669a6c05f8588cdaa03b484455a30037e8dc4c50f1be852241d77d54fd31aabdc9cc70a7aa7bb6eae6b254a9e5ae52dd034139e1dc43e09eb131aa944cd45f14eff4d14ba0c2cb45880804759c4d6a71f5c1e454e13a2f106fdc1653288b194d28e84eea689a0b239ede3e837905693175aef48b597ab133d641f369100527dacd218b161df862f88d834a6c7099f9356e3756f61bf9bddade903460dcde5e3b43130f1659b79ae4699a1da6e3436c4a22e4cdf1b028b47c356af5ad54e97dd4c4ed7d2af97620a93a1651854e5f28c700c4885a89502af1bb8595f965f26cfda866b1dd01b187b5731a4bd7aed6ea118503d768d5084263c2b5c798bc4e9ea6c01d9a17265c3e91f95da498b3f72cdec406ea89f60baedbe45df5108c2022a8aedefce92af97e6098232711d2d0e0678e8a8ecc56b460873a217e8a9a21917c58a0811e06fb198530bee6a35861ec7a9981f2582b020cc0307657a83c1b1a5d80e4dc5d4ffcd16d1d928ad2f37d104d5fd6db9278ca0ced5ea4975a72036354f4f8bdd5d0f3d65a40c492dd5e03176ee14eb856164372dc8c07a74daf1e9594a430508c5b08945284f0fcaf11701e5d0805c2a53ba2cf9f5d0c5c6b52fdf015524a0a8cd4b28a9b8e8f4b087974eac66ac17e4100a61c1ce7261d559c91bc6fb4fb5abe5f8325858ebf03f8206e95c8609007a6e0704661829a95441ed8b027ea7855a55ec491639f847e437fd6f67e97e494d6902b958ccc27cc4c45d7d764c1b506715650858555c2d19e7a854c65e82162f30026c6b4469d8298864a10cb6752233f28d48950acd0597bad42f2f3623a6212427780fe2b2a669344da671bd8fd5d5cbca3f9b13ea9f4edacdb85bbc7ba1fd046a69a4b9ae52d7e10dfe2c74158bc9d2396133a8a30fc252841eebb06686ffa03d86b0bc99e907bf497afaa4cb81c10a5941b619f1e68edfbca22d126d10b91f6f5d09f4d722b5dc5c09a6d0edfa86a1b09dfab4296a57e135ed80dd31d46489c0a9fbf436d183399cc7cdaff747510510e151caa1943ce25e84c97a90843c7d0e464426c29ee39da8e973190f557f4ff7d6048bafce0f78f95ede9cb12a50241d21f5384353ce58ebd5108dd728c85735d2f7691d7b3d13af76744c974a72ccd9e9a4c173a57ebf3eb034be3b498eb420643fc152f6079d5cb7e83f2a7d4ea73ae2b55fb3fe8f171e24d0e43b259a338e03c3887ef7965d4347c0c8a3442e9d4d45cc05afc4854dc2b0f4f24520dae77e97ef2e79ff9e6761687808eb60145b53a846874f19baba942868725d542b44a1aabaeab98205b0db29d8a84efe2e339f7fa89d463f1b34b0b78cc821cef7942683aca66b884522a31e9108d27121ff92fd43d89d6086b611f1f8c1b6d3d960934cc7c219146e505349e7ff540d99e945563286450c3dae025a961332d608aacf775769ed7485c1c6916b63c3ec03939cc564c838e69e2ca7dfdff3342061b3593f57a00e857627f6cb1a52a81ea69325721ce96a4d3882b1e9cb2223c38e578bf4c7cd215dac938b9f89e6d4b05a61350f47b2e2c5a9bfae977b568c42c5789fbf60a0137ffba7fd16a829d34ef0d75461a6e9ab25ffd19b30c8d95d6b02210cc43e5e853e42da599797a38dd3d13686a96344dfb6e81f4acfb054926b743edf1eacaff184daf27179458f3c2757b2e266b4bd85ccb381c96d422de0d83c624e66f50108c49a444ba8aaa838210b4407950e0892ad3b1efe9162ab86f4a746c118229b27b8f4a4095ef7b4b450cfd3e3aaabf7bf28417e23df410456cb5c9fcc00b5bfc3c827c3f839c3bcf68b3ead86531942a058e3e8c479546c8847f3ce44d4865679155f18624acb36fdec2bc01332e356922db2347e1b2b7ee4d8382a474199918c7eb93e319d25fcd7b597bb710db6aaee1e81bdea7c43d8c30adb83da99fceb4e383cd2197f7fc91e93b95c9695a537944692d2726878c53d043d570cac7352cdc9d71b1cc1b3e053e993faf127804e0c0ff92fe4b31cb2c4b3a4b54b72c37ec31ea13489f6f3e5ecbc0e6afd8fd698b166ec9180468aad7cec223ffa5bca226dadaa11bf089be493c876271e44e58c25beb417c2232df4ebceed1fa0d0eaf851aa1d5d9574e9d30691adce3ea6ecf05b93e3c5839c13728d2aee53e9290cda3de40f74f19f83ca055a3bd0720262717fa3fd4322b797f4ccfe3abd79191b3e424d0ea01ad112750b05c0a390f030733fcb774939f130a9934132eaef87a4d6dc8cc08e0b41d5ee27952f3f7e342eb94c36bfeb9672cf3fc6a32d1b13f3f72568f32ff165dbb9e563ecf5e7cd5eb00d7273ec9e0c1f6c5f41a567f2b1381a2861a2e924f84297c0d70e41fcda6f13df2e1bf706960f4b5814491699377cedd1936e1c6223c210e79934107ff66ba0577c0a2dd96b69b3d87377d1109a714b7e988a7336c3ee7462ff84c92e5b9605eaa1b829af1b6b0fa8c9feb4a294fcf2204c80c95c08288371cfcdbea919c76b6e099c3358f9be81ef8711447d55013c333e9951aba97fa66ff4270706d9399899dc46fc8eceb6c59e606100dfcddef14c064da5e8865ac3b87c0ca8393b6528bb792db95556fc68bde815b18c44172a87bdfb09f690fd1f432e49bef2a2a9e14a4133a34d07a6a915b73e7c24f27daaacc63989c8883d498dc21d36a5ee0acd2ddb667da4d4b4052d0551bb995dfe6f40352516521b5fcbcfb9253d9bd03dbfcf23b3c95c391543bfd6dc39623e0ae522ce2aac9b14f5f953862f0e84988f65a4ed2b6ecde86beff5c6d8e8009d35c8762d2146071c42c22ba1324f0d4b46c8e6c610622d8416d9bb22cc59eb3bc5c4a8f47c6532e734be3c6839a65d906726b6c932132bbbb99894c1fdb901f6eb4be177987e0d9d75ae153e07c8916a4a848a2264befcfcf39eb3060efaadf69efba647f838a3e6cea0eb40a1fe9cc05b6ff3e145295ed516fbc978b1e285327215291b801e50bdafcbe009d628631c41a95b66472697479d08eac03ef724c06f981f88a23ecadec6a5587495f30671cd7de8536a09f5b0175a720a741b65cc65cad6644a4a717951239d4bbf00607dbaf620cbdc692b8a0de67db1326f47ce7e7ece7a804ab7df0caa6190699c817d58936f2246f9ccb9e2e8c61728a80917a4f4c7e111c3a2eccaf2ab88e7ee25ac916b7dfdc918283f6b71e294bf9170b341208d059093c816bc59cb251194145cdd2aa7d8e78af4fb8c0eaf82306888752fcafb6a09e0012781912632ae95e634fce161e85b461d66c727c025a4a896ecfb8f0ba73390a8a7a35448449e9664b305cf7abdc1b68ac9999ff59db88e97eac5f5ae148986806db0f8032fbc5bd14e74462e2af61aeeb0c1e03ac433aa2ed1805ca6cb3cf451d8e89d4367651c7f17e3d77d7240e9c48da81d3d21ec7a53c76bbac48c9aa9c53c6ad802d052d69213322a3deea266e05a95a597778f5b72ae4c898baad1565cbcd870df27f7818bd1f3b8f285e3f16f345768bccb855043af4ff04aa5b8c63fa566f2700bfbe75fe4292b88b1899842b6a52a9e645a5a9fb2f6b7c7a4db3ac7f1d4feded6bf9cedb6b26394d68e80ba02a2192d9593769ea35dfb8c19fd704113336d1b53036d037e75c9d48083c2e306703c0259bd472c32b8122dfa8aaf1b7c37015d9c29f60cabafdc9b860b12a7a3bb10ea1e98ca776d77c1a127101721226634682455ce0d313440e1feb2021eeb96d1eccd01264e86371c351ec5f457a25b2f82e48be6b4353a89d68b1c8a5f3f51a20cb959d7c5c557895e5e5610c145664b81441166e9f6b4eee17fdc39fb89ecbfeea1bb4a32d75a8b32b4b43a540bf59fbc87fe781c2360871a31b498789c3896bdb5a5cd433d7bf25a8b34cb7a310c077d32a911e8e545ddc143baf6de55264fbb0bc88e07ad4d6dd25c6514e6f156efbb8aa248d0dbf8e5edadb1f9fb24b7f6f4e685f4513c3b2b521d1d00369602364eb221a9fea9a166380bb189bba3b622ec9ae7a4e0923c7ed5ac5eb72a0dce35dece62e4e1eb6bef0f5a6d3d465c9d0f81e3462d2520aabc3684c66a8c23482b3a7cfac14853df734c265eea2c01f6c92ae92b21221c0df2285a17837664e9130270bab0e3598ea3adbc68706d59a0d92be01e2f1c186b0043215fbf32357d38647f9346c6fd5d4f15bc2abd348c0bbcdbc4b79068b55aa8561e5f4340efd0a674b7982380c8f6c54b6ba597fd297f7a0bbc7a56c45f0d68eb9b52975df5b1dde49ba6c79a8aa0cc3178e5e3dbfe31dad7ea955283535c558ae17f248c3058edca6a1f98c999d9b5b4565543357260004a4a0eaa24be7113d5d2063a7f63595775018cb527026b4e7a62eb32e3c73198a53f8e0cba95aa22a1c025f3826788f4a303d91d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
