<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e8c1fcda18c7bdef7b617d348117866945e5efb49e7fbed7dbf124b465f3f4842fe35c7ae86720ab763ff60a29e84578e788f00152fb6a51ff3222fa936bdb483c94bf06b37605eca96227991b51fe77bf7ece4b2d7e430c0fd78a06688c91e04038ede926d7658be8216d271c5e7496caaf49e6f96f3a81cfc6c259fbf1e2b5ddf23d80389c774fcc2e7a3f45fc9640a6b5e03a6fb5b4738e9d49303ac1d8a56f9835f981c93a612065c7cce614794bbdb0839cb766927b3de1a06683b1caee894636c4877048bf6bea10adb4afec6824f4cd4a743ad372964282f3d4cd802924357a472c0bec0a6183ba21b8ca3a8fc0124ed0057bd47f3f6d9d19c7b3b6a6270345ecfe50548dc044d739254c95354f9585a9db189f90edc225d5d8336aa89420c8920fd387a68c4a0cd9c204649a3af71caf8050548a2f8e504cad84b30f236a94b79078af6db08813bbea50855be86ae577de2e76ae0801562d45431dd1c40237b3d9d0a952e2700df453f66620bb84292d214c4b99ee64865269f3afa3625f98e9d240416bf34e62b03ec3f4285b0d54ad93856acaecefa8df4660d973fdebfe82f8a1050357e14fa98e993e7cda23cf9cd38d04189c25a852b95a91ca2aaac65e8d0e32445ec1701849c56d83f302e4d1421bf63d16004f428cc14a456e4eb587fdf6cc8fd1547c685af34a9d46403cb9bc365975888a26742c4aac35877f67929c2ae8caea81afdb596e42089b5272c7a154f7f3bb8018a1ed060b52a6cd7b3e0cd3ef17d742f50c0ee770a9bffb36d5a1e22c0899577ef3000aa0bd9748709687b2eea60a65f1651db1e95b854ec60e7b37dc93d23f5d39bd7744b6137875a3c3d9d3ffef316b97a1e88cbc6accc3b12cffda6202b629b85620df114f4850aa3e68004587de75edb32efb0391e1f39c1f8b6eafeb3ca9a02eb1ce21394f78d1153813c1d4a9b49879de335825672a1aaa69c1a5dd8e812b875ddbdcc9786bc4f133a00caad65ee7456f07df57fbdc6ba105db3ce117fe4e300e952ba73974c89c629ffebb68bfe0791f17a86aedc79cfcfcc556516d9b12691fc90487c8545ab64a1b96e3e118357a01b6c8e06f96e3eb20d36c77ac735bbbc537cc810f3222e341155bb3f477eb07e34cc16da4d5bee0527f6b614cfa695279abee1cb0be56da8fc142fd88d272028736712edb171cbd3841234e9463581893fb9cea169166abe36611e7b936e5a140ca9e13b214187fb6560066f3e9dc6173f335558b09cac5bd4f73606532a572a20f53b136b4bb431eb81818e467be4bf9cf4885f649058008f17ebad11c5e88c13c3823f5fc58d7e3107cb95ab9771502de168819e252aaf25e929c52de0e1b793ff443a87779c44a24767e0694b3ce3f226a97911f66d9e581f6a889fe2c32cb8f2032188c688d73ebf0cef17aec00ef2acb42400e1a19cb28eed4c3a5ab947d0a1da35a7d7856fa00c278ea73c008b3523aa238700f829b0ad78d39512e6242f3fd8bc8409b2efd9eaa5e2e47ac653a8f0a1b02ac5ebb4bc3ec49a7f65d2e837a14847e722c53c2bd45e10e7a57b402840d2dd670d0336553a7577b2d7899fcab84efc42e4d05cb47466ebbfe548a2b964c993f1bb88fce7eca061a6c8dc8bc1750bb7db56e105d27443e630299c2d76d83563700dc86bc16869b4090258386c9ce57d66b7d8814583c1e5f5e7517e02965847f1d1e6912ba774cf9c6dbec9f0f67a53b24cf6fc292198c8c7eca24396ab2da27ffddedc6465522a2f190c592c7f556351b4ff64836032a1054adb048e78ee6dbfd29a14e891b7a07509d5d7b39f198fdf31a6ee1ac09d7a107bacf5abf5b8a8f10ea05b58eb34407d82f240b7e6dd91bfa9ff986fc4ee856a324c145c9204a90c6b6a844045d8a29b44eca0adf3c057f739e15b19c52a6cbf47df51f02d4b4e5ab8f3692e4512032a69269b958cc43408a306bf35e0db974117611d43de8556ca556256b7ce5c1301a62e48551a163be39191311fbf086fcb0d9daaa68c62933091d090896e00259c5e3d5183064ecee05888902f86ff5df804ea6802a6a55d6ae761f33b590f378fc2b006818a64841d3078c7ae1df9ea3c560db3e2233f567debbf8e4b59598efe7dabc8811fa0d11371eac8758780813cdd0c75641be1842693d4ca58f2c8bcb9565da3ff7dffe89ca09693c6b4e36bbbf62104b7fd42800009b1326d8e3078415d2d138e4558a3ce5d4dc3d0b14bcb1cac2ae3ec2798c9ee043e64e6c7122ea2b93c4e093e642c870e9fb9ee3ab210889a9d40e48e1580bd9f765bd1044f040482acd87936fe999b66c3235ca7a957daabf4096ab828e476f31391cb43fe8183901c7639ce8ca579e605b9ea687895a952086626b3ee0fc9e7192d2969507cd1058f09718768457dfe16d51c412abfd0055e92d67172bfebac617c1221f98d7cf1726390da9fb5971ba5bb3d32ae6763a01aad62a17f1039c85600ef1b64329fa5422f0c43d9a992fcfff0a813dfe84502b0ef49fe64ac3648a5943f29465dd191a4a593ab4283194872ae100316aa794ba49875be4cfd02f8e82910d254fbe7fb664c1a658a11b5edf9b3707fe47b39ce6be9e7298f8fb8b2009bc941df3db77a549f9d408cd3fe9967b3fde82bf064707c6e959af415fcb58cbfb8aa97386abe94cc62b76fceb0e0468a36fc8ae74d73dc2b4db1492703c827a0de79a42030c3aac28e239ab97b5e4f43d9f5c8d1959f3a724a0005e3d551f0b5d7ddf5e1e48eb0be830d4214cdebba8b596e5eabf260a63b679e07e8cb78a3cdb3b8711c0ca351eb9f203699ce1051ccaf7e6866ac2f247619014cff8fd609ca24e78dd30772f4e1490229be913e23971d671046e92ebc9742bfdfb8def6b27e3afdd5bfc848fb909bdcefda5f03ef790326f8bc1bd240f00b69f38d831bde6198f19d7fa60407ef27eaaf5b8894fe17e5e498fd882ee34423c46eef445f363d08cab6f156695f1f3e12186bd7ac3eb01a4d6081212165812f09a5e22e8747508695b881b9f99fee7cf7a9dbefb4edac15535cc835833943c15c723f2d31559919cfe078234a6698f118e5952de0c20bd9c4eef69bdc9892367c7428b0e4a6bf944f60cf530296daea791b1fbb1580879b6fc4deb9a2fc0dce49a6b52027a6743398b55c844362ea67ea913de57e0d13fced0c622c21749e36f284646cf48b4d15977f6ad1f4eb9435e2fbd10e88373790b57a789ab3a14553f2c63475f02a39a07eccb1f134022aec9cf09215f3e64cbe57bee01a409e3b13e0500fe1a226115da7c2a2eebf38886dc8ad8da3fc41396d53300a716d51fe8701983b4fb5aedeba48d189110f5af243336b8be7a41d246efd6f0e3289fb5f931edd631e631266bb97b02d359e9ec47121c6cf71f6f1a2a99037b3eb6f95953cbcab7b33c60ad04c0f825dc8baf77413daacefd89a595f8ba175c7e24b834e37c696b8d103a026fbe49075062aedeb21fb7f1e96250194a70ac0a406ef64ec27179e1a62646a4ada20cf840b1275d5feeb0747d55e044cb108e013ef1b53087732418fdf769d6324d7a1b09afd0539805a771fc7c9c5bea9745d85ad1a5eef3847c5ce0336ca4f5bd00dde9e74ada3b86276c11e1abeb5106f4a227026cc73f9f94d3fae36c7a71bd7689bbeb50a7d4646b1c5ee74e96407697d5c4efbaf37a475d83e95d0b01de67f23ddfb9bb33944f5a4be5a07fc8d296cfd3bc8a5ad4ac520d98cd32516196edc309971cdeb64e357163ce382c7b060f98689ee20757c6edd37ed33b005c7e1048f1d7b02be350ac07ae2e2b70c3c77be88a7a1e3c2021e1f0e1c67af841763157b1ffe59c823228a37805d528250f748c4654a502f31d71860065d35315cfed352ea723a2de49b29640eb4f884155999a412af5c32add0dca4e6c86773eb4c2e44eb18b1f1133f166cc4db476a7c6299df6d9c04ade52f56ef299739e7c38459570694911b1668ced6d185757ba46b2097cbeba86571c2f171f7c634554605c55d23f7bbd56bcbb4e05f2d01ac676a8b38805206524c4d265cdeb181574c142bda39fe21aa6932fde6b67820c73a5bb141829a907d8af3f45b5c4aea3fc7d1cd85e63a20b02adecdc262fd55a8f2aa76d3cc8d62281d34db3fe212dea2acc71e3551fab9c9b583a87749dcc3d296d106715c26d7a8f466bd2f1217b5fec3917a004aa76f1c7af913a04253f6d296a84dda7186e81e48ad00eea814ae822a2d936de9a06e478a76ea0b113c258e1a5c4a1cf54324ef6c3caba360f069dd36fddeb7780d6999a974095ef686e081698caeef98843cf0304d70f1c9f77adece857a1684e96bc3262f5c8739294396ee09654b936a5f0db57d52b9ba35ee9fa310c3e3f043a71c534fd6a296dbbf3e19c9047569fefcb3dd24ded834b1563182590fb1af939ab10182566441ddbe61ce180650b2f22d8ecdb8acf60ff50503efad9594a97f3bd0415e1af1cc59c52c7d2737086e1479a967c4988cd8c679db7a28849e64c2746baf92ace5e5953b93f7160aea6bd670fd7f115997741362ade85468c8d446584006e201cb88840577ff83a5b1e5ca872bc12a5048fdbc5fe83cd5829955849cb590b4c721d36ed2099f8801f2e6b4450e54266fd1d47cc6e3b21ac92a35c1e61f3f646f93ee9c259c85c8be8356457fa9ebbc81a3fcf1a04d99df9a5bc0ec8bba80903fbf5b60f1211adf37edb893ba0b65c0642f9ac74e6eb64e660823c0c60a1189dc8dcd5d0816840c6687b98902345a32f7903592e9025bbc724f9d731fb7490f14bda6c8fb17a882131bed8fe5821297c1d165007d406ddf98579d14b6117650cfc0d309d3aa7d7b4b7cd3e46451e08d09b911f89e57e4708e236f3fb8516314a86f0b36a298255aa8b22b4ca00a892dd38fd1a2a0fec0864142f9b5d5d4db78172ed5ce6c8638d43309dc8d261ad57023fe859bddc6c1d9959f524e132cbff78bad4c8c84213274f83d25f32af937a212710aaecc48913a4d085ada2d27e8ebcff2508de28c130cdca70f0b38e2f5e622eed669dad73bd8abd9d1cae8e9f2360cc9f2c05c1587809959d4e55b9a24b82f13b9b5bfa22b83547c412b8aa4795ba769edfa174b03e79961f2089be18b8f99c4b914bd7e940ff3138ba7cd4c01bb75b553c379848f1b64731c78ee7ebc4ddf10cb9175ea9e6770de6e671b0644cb08d48df1ce764a82a06edcd0cf43e117c8971d969e7019c17e776e9e7be0ac19b7fbc0c6cba9a98460e13fedfd87d588de8c126ec3e8337b326effff8a3e08ad66f5ed718890b4d9c2e181d55bc13af271a2b8008e82ce33ccf2d56f200a6c4f13c7980ea1176eae78289129e349f88674646038116acd32cad6bac6405e5110caa1170becd8d45ce154383d4d98053e147ab5468f0bf05faa85ad7134167877c0ee9aff3b91c643a35ca77a302962f6adb44c29579bb18b3693c2c3f0b63f5680cceda9dee0963e10564f4cf19e9dd4739b37a729e415da70580470afec1cc2090d39334c004c1c72274c8a83b770d8b74d91e7e9cf57b572ccfbcba81f2729f3d08ac955d33f25458529dcb815678a36fb58e231b43a9e988a916e1b0227f769b621e9613d9a76db3d6ee515b68ac53f300c30601c1ee6b0c7655dac9f6b82e0955daf23117a72b54c03758231bf8bbde8f468e367c32d96a859f3394a14477e3deb658c1e09b860161bee65c7baa0d8afc5db213b83d8ab884b5f208690b16dab6c0541339bd610d31db4f4d81360df0eec7869bf60a1e79b47c4c7c07976cf3237d7f20b998ea9fa518354eceb5f7d59c353be803cb2b353d4af58a09cba721e90c0f6c5830d944fa3a2232c1368198d80a6452cb88c4e7eea77be1d5d9bc30ad6682665d11bd9cc8bacc73ced40a8bed1ecc49e9986deb34d0da0c9e349eb1a05db59412f61b5660b494f1e579a8741575598205a129f4d8d9042de56cdf09eaef6883700108ca30c21b3611b533b7eb7d5d250cc100f288d782f72fc37969a831dcb576718ef2f503bc193e5623396f80822ac3ee9c0c2dd35af64e7171d9fa18e62ce1da9304be116f9fcf233a337cd7b4e309e278485ef01d13eef4938d3a212d3273e70bf09589a40d33e94267ac9da6510ef129bfa917d7a61db7de1f88bd2fb162ffbe8fcd94e1eff8af16e7bbce1629efcbd7e52f6c6cc5c42fb381c4c10bb2e20453d131625e7a4a9cb59c56342da1dda0b51c2741586b481a21c848859d146d9beedb7ab473726303152bac8a78100e9e22df395b99f4d639c3f6120eff477ac9749f925faad8c614dfe7d8c08b8a8b01c219f562aea07057cfafc22c2903fdab6abc2ec70b9a9cb651d59540dd086d277b2230307575d52fe4112c500cb937fa76bfd82eac7f6a64d3af412e5c43a02f2259e6da033c485041b2c5a8ae4e587a951a308847f2e894f3ade680d99e777ff80b74a75e1a609e5268b6f6b67b868e706d7170ae30eeb8507382c97bb5c3d5aecadde2f714c70b633f70c77726df8bc143b5a17d27c7eb7b025dac3e1cebf28507fc1653fc93aa09bae5c0f54f700199317dfa8ea7551f0499530bfc94dd79151fdbe59112a8106c753fa4d3fda0f82611864ffb5b9d591bc0efd6051720f81d5a3e6b4ae483a50f157ee8d84a370e1082a525166eaf17cf5a0d9b27d60dffbfa6d7381b32f2ecbf71110d412451f00420ccbe5e84a410675f7108246d6573d272765a1a1ea9ceb5a42841046b80ed6bf2ea43c4e48486257a289aef8ba8f47eb3446ed3b83231d8ff02797ed1ac057a7cbaa39f6d5b0a2ee67e4d2729a9c59c9a9aa345ac80a67c4e179e0de6ff730e641c4d2bdc42fe9217bcfdc65f2f008e9530fe7f9be78897753855311aae860e00a58a623f6229a07b45ae78b6c36a9adf388a01d2d88c41b48ce320afa1ff2b21bd175d3dac10eae0c2249891b9f4ab00eab80c1bbeb2db4c775a23382a4602dc414adf04a70d58294f4f855d2ef0744b3cdaf31823de34e25623b8bab66f36083890cf2ee2737b7387213cf21ea9b03381be5d94367538153ed07bbfea89e22d42bcc7bcecbd02b50b09dbf8e4a11146c0bff81c5409ce05b2098e9db2c628355079edab96094e96106bca583cd14a120070e5243b77cef72a222da15038fd8ec7869f7be688980c8bc3d491c2961dd176af68ce159e84aa1465fa3816964bee339d2d6364283e5e523c288441af6bcdbbf91e78eea7a328f67956424a95cdeefac45e562a43fd1693b28b002988dd50eff35ab2b203a36748f75c391b3596d54cdda442216bf3e9f9736fcbba48bad54ad8ce6c3f34bab6be220ab26e348edbcc3402a63c6c198fa710d922366c272cdec12a44c790fa0b4ed4318f9e560a2bc464abbe06f929a5e9009436ae41120e10d859d63dcea9b864a65ed08e20f027757547f5884641a9964181f5b6755ca0fa6a7b681d17b744c3b99ef4aead54a48d903574b73edd4fa8cccc58778d1688a721f2e1e370f939183aefe643e4d08084fd094cd178c4ca47f6a86c20ffa9f9d71d7d4900c8ea21c5242d979cf28135f93d67d07fa2354b1bcafc1f4c9501a2c1ae76f364dc6a8d8694876854bf2efa4593fb69f18a210c39a654b18207869890d3dd034c2958b1c4ba19499e77de9a4a69b626a1181e7666b897a567159d0d015d2479dcd8a9b8990d36c5e91b47e85b6bde76aabb543c6d92bd58529ed7b30847536cfbb29e7f8b9e1f2adaac757510bbfe3ed4d020c2297a8bc92f2364e227171f11d5ccb84b93d3b214f024e771910a54667268c64a1cbf74c49c1645f687a223da66147eafbe4e8349dea3192f915337a777a8ffa17cb8bc085748ac979be7b1d974d8e9410a5b1207a88ad22f6ba922e665d5c786501804f66b67fe2979eca53656dd263a5145a1fa585798b8da7968a64ce4cf5d31bce169fcb8ed4c92e98a8f7b2d9d59ef9aa94c9ea416e827ff3a72c79122bfc27ac69e9cf3dfdc9c66e34b6eeff61e5c327b5001b8c94cb3d1afe99d82bf5a3667453ff1cc7ae894c19cb50edd54ccfc8b32da22fa9745ff924a4be08350366b0354b968e9f30b3b0dbfcc743de32278bf16cc844973f9f50fa29ad3ca06f919c66168a932b8e019b8ad3d78ed9d01d2354ee792b35a27da0de1c4032a35a0fad4005b2a0a65d03cd934aee2d322efcce0092903947bdac9df2d221c9ec7de3e46862642e71a89c3e14686ab790c70472ab3a0f3a140fe3a73ea37922545238a001cb7cd687d01b2c9e54a3f09715759b2fa31d9e413325fb4c3c0a2385f09ddd977206708f36c9e122b8052ed2ed392b7072a310336b4fa69503af0c73ca539f6e28b96a549dfe9857f0591363f029d6532e72aa813ef48a1e7abc2062bbaad7d9bc2b65331c7b18bc90a28b8db1ee3b208fdcda40753f13cd8799a3a89053f41b5a2bf5209e2766d06bfd658d4244b0e4cf71d16ac32d3576fad730ca2047602c42a2cab259024652de50c2c8d527a4bc28e2dfac4c9d66c10a074077977b2d830e902c00fda54e51d7a1a57bbb8c86fcd0d8b8aab0ca63c60201a6d54d0087907c0e29edc8f1378d22b006d3797db0d70863520f368ad512d41b9e3dbe34638ffc7603ceecc0c33c877c32c53ec142aa8741f7cf10e42504085f741a1b6bd82ab027d2c6104209761f9b94c6533e0948c9697b88b4599c1976bdb997f6430461333ddda10afbd12df284d0be92a54628539e7857d366e4e65865143fe667c4495ea2a38379b7b5b4893a48f190e61cb33d4da33384dc7f9e832f145efc73ba97ff6171819be40ebbb250ee649be6bed24b03188e3a98befa0301f908b1c8471d6eac1603af618826d47cc48fce2d477a6ff28a574868c338bd6e332827b5b878e6d4646435fece08834902657e9a5340de9919c905a04217b0e9dd6485b5bac63d61b0c11e78efeb205bf3dcd1de3d76d3a77ef7dcaee3f3989732dbfb6b3026d64d2bb39113b3814529fb206a01c4ef8fd15e84a48b3b0c576a58e2b7a96e80d6e240c0a8ebffaee8e0eb0e740745f6f70a5702da7151022829cab3809885e6d0416e7355e9fd8f5a092491d5e05a6ad406be8f4e2911353861b86b0beda15e5fe4443084ba5b4ca521349365f4f286c5b5c7afe60b087e8f296959292f872297cb2e82be6a159d83b57bfefba54c9b656e1049850854fdf99b3f31c063245efd76d5f4474b0ed75c97026f7c9f46344447534d7bc016321e31fd4983d86833f46abb3364fd3c794e6bae43876ab00941b5d74c0e677fcb4646a9f40065ce2dd1243f0c5ffcc8867c0facb8b35f4ac7f95eb8fc14237ea58c3c9f50969f8320d468e89509f33ac15ac7ef25c483c81799c5129e4710c1eb4ba3e1b195ddeb725a19b2462f21dbad4df6030c02b26d4e11bd160fb66a9aca2dcc1aee65ee36286e78fd938e6c0c60d3e49ca227bbf9fb695a7102e076ae3c77f4837df380198906f0c2a6f04760d81910d0d34d5dda123f50b947718cea18dc91661ce61aa163b0d9bd8c3558a2af6e75b1afa8ae310029c8fdc4581f1690669d46552d1221641bfae3b02f54bca32a6ced21bb4fe4805c0fe0ddfddcbbbcf51e3b79f79b36de7e691d5fe66950f1e156e4c9de92ca7c7c988b809db298e0234af0a568f82d7ff8a3c32f73ab4c0228f7d49c3e3eea9db137c04adc5ff2bb3f6f2556091e2ac71c23ff46aa66fc5de811c64ae3e1f0b376df2dfe502ca629bfaa25d2e330ebde957fb07f4fb44a0f490647172c0f07ae3947b04ceef9328e75cd64cafd9ddbbbb486d619b0d356683adc4db11b42de475c5cfbeeb931bc74f689e83a7d57f5e1a7c249b6da24f9dba5739b01baa943badbb9d319e267ec946da7a0f227bce800f9aae254b45705b33623d61fbaf1cd2caa52bd0331b3710e92884137ed77c240790be5dc562c254355f21aaae8a8b26b4183a87c3162e6306927708ba775ebd11b508688333ecea37c142f9f67957075f61e76f85e70ff797e2f5a2f01669e59e3229422365405e7f287cafa6236062d539895ec4ab30e335fed91ae09f6fd1c0a20a469edb3bdc1687a12cda07051afe0bfea4b11ee12236b948615c8d8f69797da1312ccabbea9a1cc0bddfe57e252e176302f44e8a31cf1535435b50f9fb9ff885ad25f4d3b60389bc04ecc82b6fadd2cd350435846548291addcd80ddc2c0fd49f9257da9dd87cde28efd9be2346310e5f8e4647a8d7d2e10a6905ea4b514c44e8bc6316aa496d145360fbfb9c3d3b0785a2c4d34a6a9ff23f12ae8da06ccb33806250646b00cbf0895a74d1e3cb1211bed4efd597b11181da7debf2ac198ef1c877fab541f30e318e44c077d32aa03c870e31c88b0280d07dfcab3becf9f47fc400701abdcbca7561d9dedf067bbf0dfcd1fe807cb7eb2f4a95e9da0531ace24074bab36e7e554e720cdebe9687b60efa58c7bd78bd8802194a9d9f10f52e1084f4df5d606804fdf8687431c27ffecdff6fb060bd84e1b6757eefc6e20fa7d0f38867f50c3e37f6a427a3eeec6b287815fa59dae9cd2bcf5deb3aac77248ec813f3c8bd5add33638e3d65810160ef4eef9808baab0a737ca308d685991606f9803f49d01d8f39678f9ff1002188f1082b75efa2b909d7ce036724639f17124ab7f7de179c2a9f6dfd37250df25fc05c6e33594ed0ecb9b5fca8d75e5c97855fc9a7ca93c1968f39bb40ab45ddd4dafe9ea2a4a3b8bed0454afc579b6c6ec460ecbf8a76fd53c85609eafea602633337390680d61cfa8517a8c73772bad222b86026a3f7d4d05278685ffa811bddb9c07422567c857c9194b0c5bb78d379d0ccc00fb27509408f55258cd14384d70fb4978aa97010b84881e677340fcd81baefec07a9d47b404e6216c78e439cf688b680215d16a4e8f4b2e0f8936af11b036872c7f419c71bf08857983574f26a3a4aee6adc11429c7171f1d779a9f3de833dd310a7d39811576914a06314b9d69dc1269382f8797ae68eab1e0a349887e5230aed99bd1619973946a8e5cbc2783fdff4c15848ab7f5684dec649047929de51af197f6162b25799a9d38df4637c68aae9785e38953974ff2af9ff331014d9e3c89bfec2dde19ead5d09c56206a0c911bf69504b93666a7a1bca0d775fa56f393940d757f2137d58599e6b4191e94f3e385cbba698a839c3a667dec3ad511c41ab47d486b4421eaf82b36e4397e06a11430f2b4b2ee725fb9535a2e6a13a3501231717ebed74b67ae6f3139a0cb2d7b0bd68e8cfbe8a2cbd4ca069c5685e6ece8f8a54d02cf569b2eaace48e9a09a5c93a9003eeb540a1d0d1a87a3336dfd84c3fe05edbdd7a36d6779ef0a90c627544b3d39eeb16cc1e80304bb5e66abe799f4f8bd32d52d43728bfcc12e7bdb1e3be7313135d70c9c0fc1f33d1ae091909cee3b4075aae22743714a7432ab88db3d2b2ce9bb90029b9b8b5327bba31350f6094b10d5d352d06b65625ceb4000d7686ab74f97ec36129cc2f52f337507aaa875db4730db531fa51c3fef5c51230d39a74194bcbaec5c4318ebca3ec227bef3104afa2d9c5c9bd424b71cdd99100003f2b9e602ae8edd0b474ccbc0c172d70a6a58d92622abdca218176fdf0526b47da74b1cefd630bbaaada609182e3368381ce2b8566fc39e16e0da6587847a3025c7173a47bc2a78e5228e0a01a7d036dfaff578c7a16836f5208127c999f9f2f205757f854ecfc15a1929730635330c98afa4fd69dc2a281db6c40d41be18d7e06f0366920e735c39feb0a13537059fbdaef3f6ef70c7de964020947d9369fe37df29c17baaf98944a75811900a69cc003a0278f6f0ebad7ce70b4de22ed9e8a83663ce8174dc730ad3d37123edff7aa402b2ee2c543e8609aa1fc12c848667ce181387353849bf2580890916f2fa9060a7baf1f553e7f6dd28dd37a435c5a098763dbf137a147a33e9f1c3c2f313a93db3093d86c7372db0b886a3b991c6fba991b7d2be8efc48f481325e35ecb55b5f41e37c58b1cde9d1e0ce58a74ef2e26831acc4fdaeab2de271b6660ec0f6608941a36e5be924f48bdf899288b064090ff1b777d84af26533d0a9a5d82d48dd1fc846ab7b2df8e78fd6f6aaa0488cdb1ce521228ff6b637fa5196d131b6575dfd4f0a272c10a83e1a1cfb55b9a9bcec44ef18352c83c39f6b15b562f6e657f6c2c71e9056d7a89f63c4b7c6d94d22e22624ab0ca908b47b0b14fd64b6de9bf082d63efeea591b9595a077b8a2b5a8b91211f1134e3955c98774c57df4a06e4aa59146f7114206094f1e1e036fc2258eb2e15a8fa088164a5383e7cc1fe9d312e04c5ff8ce7796167448557c027be619897a3cec57a2b5fa0282e6ce43a0a475e93078886e2c66dc390306462e00ddb9ec46df725361d67cfba46c0c89f4fd4d41bd41b15fa328f973c7ab68b4cb5f18eb030bffcaf0931ea0630bb9e4d9fe2e633529d55e60671743a7adc9e98037f47ff326608a3f453428c6703c5ee1a20a0a689d252190be504389aefade63872c9aafb7762a67871d9a12e330ca30fd11a99d36c2759504d784e59dd9445bd62f75487a2e146d91aed8835bad8b6c2205a71e00f0987533316be85c43144c37aa676fe52e9995eaf303647e4547b4331850166d1b54cb65cab033fbe9b3398f28202352762eabb3a070a1b38f4ee95ee60909a7aa335482d239ca6b6657840201ff2c7240e5eb7036df249702f900a3bfd9da5386fa145c601fce78c61fce60a4bd9ca1846f5ee4a13dd0a0118ecbd987371245c229f03e91ef25e6a810d1271f4f3849de429de89a87b7361a595acb1d737c145d8a0ea33154f35ce9e4a4749026538bcabec2794ea07a6e5bd2d46db77b268a9f3f76a568e4425349cb90087000327a6c4835dd506bf901fdd2cacbeac0f5185c355b3d19993e561a86d1ac6f111d68586c5f0a90f84b021b7f2af749f3030264b5a3f4045876bf806802bd1dff0708e9b2c5218f98f2472d1e57fa7c816fb4669dfedd3d56c9aa7c18625fd6ea63aedee482320fcea45c00dbb1e80b078fab9aa28cc51ee5472be51946a0e22a88c98c5a86c95d54913f2908ec0712d88484ffc61ba9c5e02ee6e136b9bd7286057c844b802e11b9c7106b9d0c11f3f59756780be47c6c0ba17eb62be17af240636b46cef9a6b4a2ce623f47b2fbeb48c806f696002f84cf4ae6922e4e664bb24b56b26e24e1f4772c5254d4506a8d7a875a701780b80a67a5f535a460ed833bbc90175491cc7893d5e019fb96847834549ec67f163f25769ca111f3bcab16eaf7afb42c12a796d518a4e411502b3657edb20d14af197a5e92e501442fd9b87b47b66a3c9f68ddaa1f9fbdf3a8331fe12f42d5113340771cd8c67ae9b4bd213579d00cf6bd8fe4d8ae0e73e59979067516835038a9f2b4b76f37b4af78d27bf3aa9fab0fa4072d79115c07621a6f70ce56548c68d90ef407b70da522dda0b02ef5958386e6f350ee5d09f983f53cecd8f7be21ca0ff4eb5b4d23609f20cc4a93b41648d46991859c7a67ea5a825171701bec6c5dd3ba1d0c64dd0e65aa8f3118f725ddd9daaba0050fc20ac74c2eedc5bea5cf780fa60fb879ebf1af5839f50f69c3c839cf3835152f264ac5016991a3ec9d3e2415c74144d758c09d24bd9e96a527e62d4e2cd19a6168a630b6592993341683ea31f665bbb374aa775ee1d01ecf75e54904dc6bd5f646be11bbb5084430ed1f67d7c9e966f18531dad9cac5c5d71f0a2d254a29bc30a45d8883c84328e1cc00dfdbe37b9d227539ebb7b203dffd191a874c14290551182c830065b6c131943f65dd24874db0d76908e4f57bc5dae1b88d7c82155f99a4200bace12804cc9a6abdf7fb6e14a8cf6ed9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
