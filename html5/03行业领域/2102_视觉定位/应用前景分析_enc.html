<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6d2572fd3287ff26c1720cea200199cb7e1d22c532195a42effa8776b5cf3ccb728e851a5060aa6923710e3703c6189feb886c2d204d11eb6d227d0232adbfc498527ae8d7dd6bf2bb4ba956b99f2bf3a0f33e77494bfd818be7cee585a01641e2751510a1d633a55909832c70a56a6b78598016a20ce6ddc2650321994e4a826f004600a802c63413efe22aa14276593c9183ed63fe50f2aab671956635b4b00e41f4d169ede303785c1779c944d99044852ff85b73c4403407e490906104b902ebdbdb59578dcd893138b7ebb62690944a3ed66f588eefc62e13d789232c5a32c160f92b1c1881ba23857c1c24c40fabc47a100b0b719201e7f85b4f8546bf6000608bd669d6ea3b345b55672b2a4a25eaeaa055d93219e0f469141b13892de25063091835fcc2f2a65531e91acda12218ca2526ac626049f071d14375f5388dcc68e780a364d8798c3799596b09e424e3f793f2f5fad12fe766ca6c5d361fde99f54e5f89954759063c33d980fb3d7a2d7f08767efb6df11ff8654399d2a441b0128e014dc050ad6e08dbdd733250b1977a066f7b20d8e4796bd273a60faed9bcbb207e3d2ada0044e4f44eb1119387e4ccd1fe2cf345601e959147a243ebfd5c6b2e0fe26875070068e8f8c134bbe80abead11100ad7d7ee74a80bdcf61323a09472e7b2c05107282221958c71c9c219c702998bb47bf7f0ec08d2e2fe860534fb78a79e3a69f83c9e176084bdba4a21ea547ab8180bbadc169c614c9a2340575ed2ed40d423eb99ab16af97e18cb4577dcc5be0aa4492a758ae47b02c910a75f43d05f4f922ddb7a1af4a4bd78fee6cb9fb26d2ac6ac5d13cfac8b8d045d861095f8609ec75f9084777e6d59ec3a394306e732621f6db06b3398b69a5e9ff08973dba2837d13ecac41a2e72f8d1256cd2a1a69f940d85dd64c0381e32d62c1290ea90ca589d1e50e0556e4415b64159cf58216d2ac7f75318622adf3dbf83792be4eee711665308584df7b8c68a1c1716e0fddf6999fb666d0bdd0ace73770c4fdeaeb178a2d9fad60c090fdc548e064a2489a283e1659106b687ba702d9d9b7f001321caeae7c1562986306dccb889c7459add0dcef6fdc6ed24d056bdf60b3941e05093ec4d1930df11efbe046e08190db172b725df6142d75748f161c28c74f277fe11c7d1422024c18bc87e86787f2aa25db0893193af47b43548b40ebb720cb0f9cbad883be1f642332e41c66e920b657fcb19a676fe36b38c385c73b05b11048f7bf16503040fdccf5d9b02c23b9b2d4bf94adee9b71863712a76a00777e583cd85f7aa3c00f6acc8b1af320015027222c77616dc33ffb2265d441dc0fb1a19499b72165350a7192c7a2bf249a382f1d18363201d6dc2599479076072b68df38ca8f005f6926dde06f75828f5ac9a5ee73d400d15b3c73751fc38c9b0083997e075287327686deed321d361f1fe6ffac714db552550affd20f3cb7d135b58b087b0b82ac17788d188acb033610ef6f8f20ac486b301560d505e8061838123996c63fa428a85ecf845395b19e69bc3c5a3657db0918b7154790fcfef191b5aaf16067f41402d6054cc9e3013064397f94f3e6ac3ef096d16e79ed4b8c7fe1f0e50c3810ef42eb8d397b16fab78cc2f8a85dbad06a705bd197ee36412f9362d8047d3c68fd8c8eca94082f9b5dfb1cce171f7aee2a7770ad9345a4680a77aae45d88c8a14e0add01531499a0922b7793b2783ef7b0b450490cacae54600f8badbef8e45f3adacc6d1f8dc17da8eed43f24363a598e2a91e67f4f1e1dce8829c1d9dec4e2a7a4730c0565536609fbb5414d1015d33c3cf171f8ce796ad03b7b572838098518377c02c4b47eacd926ca06afa3e6271fbdfbb7e560186c90f9e2a1d68d4a3765751da1f5b7fae0ab0f3c2bbb096d15dfa3351608bb0ee4c54aadd118b2261dd4ac6936355634abde074f5e59a9e74d8797ee203c032f34cdae903cf05d3be61aa483ada011c61a4466db1dbce9821aae103f520bd316e5e072a6c0c60223b4de1f36e0478c0c3642d92db00a79fe1a245683151c568c0bae39af581eb1f776ae3663b6592517d77a0bd8803e48c592ff9bdb058bae3bdac77e7df284c5eb9e7cdb0c2f52200de5f60e4aafb28399659b11b66bf87634dfa9bc422d1f7ec145e5603283048712b1b3ab15a309171fc5e991c897d7ffbddd2dc7b62130860e3619d3eaa9dbe46d0f2deeff27bd011bb3200b0c1350f23469b91c4dfc8b68ff7d68ad86c1b2a1dbcc5dc57d47d48096e3df89d86a910fb9ea798fb4324089775c735d8e8a0f2a9668eaf9941ab75730c8963d056c7a621e4fa6906417fea8b10609ce606ca9b13d928fd769df6a2ad78978364a4bcde45331ce5f7820f7c1d229c275719d5001e0e18d5a287fcc0e8b0625f86a8583952c5c13ed0d46d3ed68cf3af478b4d02cf3d9b034e9e26cf02f84605180d69f8d44287af46f3bb271da3c9c243671106d4a5a4ae1e3e82b5463d2d0a7801294bf11d718c967389c437c9372b242832206a3ac07926329b2c47070dc935ccf20d505657e1882267372731e2a082e1f7ed9c85cccb229d7f9bba3a29af5af3e2ffc7b7f116ae8c9f641d837cfd8ed5fc434c3a1ae6afeaac1a1d09255388ba071c5d8203f51ab0afd33524ff8614837b7669a4ce296833e3215d6b1a3cbdba653da2a2bc776132446a08aea9c7524d66b4aa02e9c070bf7fa470f94992505ec4e77a86d91897923e3315e0c782e9778aa2540a745fd5ff21f75eaae8060f0ee7e734ff403b1b2d990325b7a4eda2fb2919ca946b522875d13a53e97b0616fb45230b8f646d500692390f0d69edacc5b5a867738cc4d78ca46558d505cbf936eda3a58deb7ab7c960bd16ffcefd5cd2205ba2097d19b0f48df5ade1e8df4716e30f8ede9434b9aebb2a197d1a0b19a7b5e2fe40b9616a40bc415810b79d1577349300d7376cda6ede147ac9ec5812cb65990b1547c21e3ba0f3fb91566a8f125aea41b265a282c34425be510a720b9b4224afa886241555488d836aa5ef345c1a51372def7e138772ff2997ebaa45d2fbb5f26ee4fd5870aac047ee54e930a1849189f82a4682be56f9967651a3ddf0a0bc09ce17ca38f6e474632edc13d51845578afa39c5e660657df6baafce5726233b605ae5f39d40557f50ad05b5e60619a4604ae4ef80d2c08d200736d69b7247c4fbc6936dc9bc14eb1a59b4160b00e610833a8417fd5b720fa275fe623165155a10c892c93d0ddffb68235504cbcfccbce1ee7ef4bd79b24f25dce6c76f76f310fa0e3b16bfb0857e79a71dc7662d80b19fcfad267cbb1cb5a4bdd72dcb089259828aed501549c2dc634d0b25dcd6c5faab24f7caede5811db02f75773ed79aaab35fdb84958e9f8269ff6db1005361fc11f253081458b3da4e87bc1babe95dc86c4bb3c29c7fb6e6ea7d5a80d4c03549a522d1c5f826572daafc6b08b082a8db1c14a710abcea83b296bab32f911a0f9a75b601910abf94c78a69bf42a5be86f38b4b90ea78f244e6e73831c7dbcbf6667dc3968e63482a67bf13632df1cb3a383052241442067549a747cf00048a4e182ef2ab40fa70f2e9dc16ce4528f69e2f548816208a4af10bc40a7bc432001686f3c0e846aa32e05d33242c30698d2f1137801494f8dcb5de37465c1a86d0484663d853bdff13372b4e3699a0361c06860bbd109b5fdea1f350f583414d490385f3ebe2fc9bde7cf2ba6b7eecb921a22852f323c456208e39a495755eab0aa2e310d37458ecf467e20978e165d7d8adaee7682f33bfb1c883971833d44644d7d5940b1f9a0c91d56e69d0bb7766c0e67683b4cfb564841923383065321927318d6bbb87a638d7e9f6cbb36689caa4f106bc4611c54f448578181ef70aa97d3d7964fc3286107d6d3eb6222578b7c2eb38b0089dd82680e14ad31a9aba42fd84d5e7526a85f0ba95f6a29ab7f4089f8789f089ee07dfc3b5a841816de6a25564140eb211c9d5be485fa354b428989196738cef8c05c802e3ec344d7e0aa39a3d587d10fe978efbe48cb948c9bb66918271687db84b093950ac1a4546a184ad0e33c5094842196579c7a9d76ca7d35b4af100dcd9f2a89de235709d8900295510b6cd60ec7193c59ca583d084db77e7b3372f99b86c3d1ecb8d2a102bb8b25a71b0ed7e7af72bcdb1427e88ed4ba5fa6adb19d95d367a72822bb4a6547f7bcf731d06476212c5789edf88386d471cc9ed648004e774c0b264444a7b1c4b066e4cda81c075a7c841ce8af3d1a226b7e311a959d19e838c053d772b7bc38d936ff745a7cf1b518f3364034b1846819fc8d64cef73b92d8835ef4074ccb32f63271015a711ab37cc52c8cb710bd866cedd3f8c3847bec2b0adc2e3d369e1800cd1cf5cce1ef287cb348f443fcb29fb9a60a618d6a80cf652ddd850b43d115202a1c68e2f2fc2f9658ad3b45e933e57d65a520eea5a17f77408594a7c25e689f7907399f1e3be8bad4cbcdf6cb5ae66d2bd6587cd5e73babfecb22b9e2b28b9a09f49d04236141345c130be3f94470a42936f0366710ca72fd853ed6e2476b24f269cd39e0cf1b54e3b54ec072c386530423337738e55a7c33a859ef4294c3df2f75dbf00af8193da855b8bd9b31593ec87098ee698e5baf32635d3300250f4385fb5499493c7a0a49ba06941599c0cca011495e2570592798307d44a533456297f29dc56ccc557e1747860d16fd1f2d5754b8000c70e6dfe126be96e83cea37b7457135b70b8d9f54d25a271a1586d6983814f024b3e331b0392e8945b461c2fb7cdedffa2e1a13027eb046a8d577a7778b7bcb1832a788144efaae9cbdc38b747291946fac33ae9ab4f96fd218bc6f4ad4f253afcda553e388c331ab7de0577c53e0574d52933a4da0ab27eae837c074633390a9fb6c39d742152445ad60605789f6b92b909839f6e7c8b4a71f974c5c848d07d297e3ad76378544589f8d7aeebb38876861fdf47e1fbed971771f0e2f755ada153f049919d264bb9546fa43078fd09b0d5caa6567db9f30917985d77b4313a1fbbaf801e858d817e631342aa0bf239eae03a47b34911b725a2cb6997b321e4ea5ec29df900b7be6c5b30b0801dee52cc17585d48e8bc38ce426c736f3fd2394e9d24cb09c368f321deead39d5c5a087e22944649f1fbc54f505f797fc579a5d8512202c8d30d3815eaa4148932b6c32fe3961ffe07ff16180e621ea67ac2fab8c701418fef57806f43c51a965b1fa6fbe6494f6715f6a7db4fd0afe81443cec44b9c3676f7d798b98ca233766de526312a9908d1d9141ae8376dee46ec47152da9c717f2cde6b8a7a7419098f559cb7c6cfdce4ca7118041e651fb54103bec80d31af41d585d47b57d9c28ac2cafdfbcf3cb2b839d8426faff8913430172cbefe44acfca2b2fa6b6bd02541fdcbddabbb5a6df01d0416bc1d8ae15c046331f73ae7339a407465a30d03e489354c3913b48b520d668869f5c7ff8497b934cdd664224f9e26ad2345111fad4420303ddcd35742226eaeccd155129f56d5f601b1cd88171bf160d9a2d9c867d56c9620e66eeae491635cae902f14688fbc6e596c5d95622dd80b81c49f6625b3aeec11e98a6404723885ca1989363aa6774c8734e03c5d7227025a5c41b6ea87948b18c27a85b9e3e7af9a80208fed6822c619fea1f412e571afb72debdc58d4ce110b8cffda340727bb87f49d0b9925ff872b94e9681fc83e9ce8f2cf367859716a4846ee8be1d4036997c84c6060955257e8fd181a85aa3a47e95c9eb18c3efb7f3cade0ca1fe30db05d899935ce04766c99db147336ac7f296fc4a957ad34eba4cc6efc01f53ce71bfa98615e9aad97d7218dd7edf0ea65ddd67ccc24c50a332cd8f95ddceb80bd9d31d468472852c9c5f26ffa0488c49c3274bb044b396cf94f8ef6e2d15a9ef0e889e69fa75e004d5afd5403420d23b06690ac2eb71791eaa0e4a20fdaf88e602a9069ab995cc93e6d1159097971273d60ae447f693efbe89ac54c4e6021da7d25daa773234fc6486a731f4a194a0560ec7dd2cf33c9e016cb7822bbc92a394f16e5f299d4a0d7fc2999e93b1a4a5ac61b835c07967922e1b5be13574511f0638aa965b0886dc1f6dc9442c4772b8914c72d4bd6a54808ad2cbd724232492929518676ce762e9356a38f3e0974035c72abec6590d6bf9e93bff961a56c7e6edccb196c04f6f0904d67f7ad3e238f75a22b3ca28dd2980414eff25e952caec9e4bb1bbb0aff2c0654959835bf756f7ae7f4c6ab46bef782a68cea9267e5f6e6cbc272a78ddf8fe7cfb011ae782fd2410ee9086c20595446d298c4c1d38d35276d72a5cfa5ef7382e3d6340a2dab848cbd100df5ff00189fb42dfe4e10dd2dd0b2bffd1e415ab8974660d2c9da0883e35ace00a5ba236a25b0bb43d117ed1797e30d5c9cb893fbd91c8530d4e4a1d2616a233cc8789f6affd491a06b36cb00314c58b2d6c702b6e02aae187ac8ef0bbf3452a0b743c858b2e66df60914f6c1426477cdf6d35afdad097e5bfd25f42a585d9b62174fc35d2b3d5e39dd49085946458e01b663507b09933d58ffe76f2e7d9f9ea8b9b6d8b3b002716d4da284f0b409588afbaa693a28d83c616e0849c73ec1829e8240e1455db56850aef3c9d3f0734a16c8549b2bd9361b30f28ba562915ed04f9eb37679e5133ad3ea8cd4bfe2870bf95b17c3a75d90edbf21c21864c56b0a812ca3e784882b368e7cfbe728bcf70385261fafe62feb50e70a3f1fcf8db0c95872a86702dbe2a784b451c650e919c65d58fe862283685c3e527ee6fbd5a11a426c890c3e376c7aeaf490437b54774fe5d9a26a5337f801a5f06a56457a46c1b7ffb076fb6cff244ff69505ea68105823aa743d830e4f4f484236593f8175e7cf502df6888be9e4956f7a33bf1083138e3900fd9c5905161a672323db08dc917f6e5cc8c707b852c1fdbd8257770b723ef847d67e0873ea3d4588bf2ccf3ae78dfb476b5fa4468bbbc3f3dd6b3949f13456987d31745532a366e8b20c114895790d0efefbd177bdf77c32abe042ee89374c7fcceb4c032b4c21412b402a51d2b2bc495bb18489dd466d068396f46d0825ee53625d8bd4366699b92c67bc15506e1b3edb5701f53857574d940d4ca028d850bdec6125e079ac71c3411214170a23436c3906fd657e473f2194615910151d4e812dd929b1018ab1a58bc4f4c844b3306d2763198e8d9d992c0dae81c03beeb361c03c8c989a31695dde7f297049aa42ef9056a74b1dc245430c9fff317c7d4dd63e4c73de7acf4b5971063bbdcaa5c35a968051571225e48b08634ae5905457a837edc72aa37e9a4584dec7034959d47f7ac4e08bfdd6b9d1528d6817b5bf878abc63f4c5b96ff66e7f82c0f9f86eaa57ea37121cc3ffa1cd4e80e12ff82a826d6c50e1ffdfc90c5ecc7beb4a01c708c2b105ad7bd5383948a3a60f2d178d5c709f5f5dcf00ec0215b00b7c3231b9113a38f883d7afe7608d230dd56ad602f0eaf4f5b1f7459a831b73db4faeb8eb359243989144deec935a71261bc4f5754dfc6a8c05e99598e86b61fd1ad12884f11dee59ac4f630712fa299050a5e218854f2d292416c1e90d0fb360eacc8d4afd5d39b1a70c9a2a3f66c75506c4a239c1df2e57592186a1df9a85cd4989f3ac41e1bd386f00607f805a9dd43d04d916191aca3b4cc760dc8de375e29ba7feabc60e5fe41b5df0d81462b81485ad41c3a39dd9586c7306f2fa2f2a33e69792846f0df50f7f4480a82cd4a4068a7049a39a86b620a1bd16645dca5bb678247745a2ee51918c658717e6d27caed50d0679837adb2fe4625bd66dc3f4949eb9e9a2bec056abe6071f31f7aacd47180e63f2cd9388c81291759b04b3cd2054a3476c1af6ab3fe88dd5e56ecd96781414291e01d567ebbb3b02fe78e54fc8c3bc438f93e09f3c15cae0437a071939e4ae6a6138a5a8c885f8dac19a532aed022091496f408deb162ab9f34538b4997390d46b372a4f71023f79f665a28369b927bcba578fad9f901e3240a135e8b8135cc88e10a43b6924959679ae89b2b6b63e823a1f066b8c3f32a5f979de2d4b75bf825b1a97e1a6416c17fa4ed621c152c22827a6b1daaed33c94016ed6424a487d452a7866dedb12a6f37bb41c47539c41b4472e92de367bb0ebf908caff01751bcab9986d4c8e88b725fd14a65b6fb3915f73585696f07146397527bd2e66b401935004569b8ec5d61d0d7f4fe136caa85bc0f458ccb24d7a47a88618cdccd2e170a16ac3fb4ce6b88066b15fa5baf3732901a1374099421209eb35ddb842540c826fa0cfa4c679024eb877509eedccc26c1f9acfd4ad3d461008c132c71d8bf82c8783098c2e75a596f5c2066894acefab74a05136b506c7d55bfd5881961e5d8c6b2a2bf762a340b440d486094531645c89d61e44644348a386c5370967325988726cf9cd60990764c93a0b426b6d790fc785619bd4547040dcdf7723d52718f86f3bdaff85923f36b9f1663c1c4e912d0d240ec7d2b28ecfbe8f775bd31d609391db4aae7302e458c67ffe0a4fc58ac58828c38f474ab7e12589864b3527d9f50d5a2431a22690867c4f4226313ce6dfc115bb83d65e50baf8ce5006068e42fae26c1e90bffb8a650f307b098120393a8014d6de75598bd9b7ff9b2149ae8245fe9539f53b96bca46ca065c5a08fa92f6cca8ea099c6c1fba6db03ee500c25bdc36172353f3545c8e750477911d33e60b82de0e0aedc8bb431b79d115cf20074a85e6b11af9396402b3f8460d15b55799e27e45e02946daa436ba4ee28158a346ba50ff184667c01bf70cfeb0d55c583e46660107dfa2e5d451ed2dc501679787128e57d715a55bdfc84e0de3314a20c2994210bed4e949174db5aca4cc4533c2ac69f335899e30af1f57ed6ad55ffaf0b4ffdd79c0826257c761c29e6e2d16290bb68c6597ebdf7942ca5266229c914a03d5827e1825bddd95b937e2d76217baf839712a4ae06753878df886aba5d400780938e3ef810a25dffecf9f787895bb0883a65994449e0bba85783265f149aa04dd41582d6a85be322d9797f99bcfd5452bfb6c7fe5435a13ac3f4adb7cf7e76a58a357780b05d71bd5fa1e8b96aad0fad41f13ffc05f0f9644966cb5f06124b258f353a6e9058d8e3e99f7e64645fdaf7a57f123aee9cc1f2cdd26023e66cd7c96f275525254465a3f4b247cabf35cc8b63ac987a42ca5fd688c3950eeebfb1f1258ee7d394d3898bb0f96cb39da14a3df4b8c4f0fc1f2c5124b3095f8dd607b502b7315cc28808a2dff4b8f7d7802e26c9c591e7571dede3d626a8e19dfb8f233b9893d5c491e0e80abcb2d252d30ceef2cee820a3abd516dd974dc00c36df061d490289c4bcdcb03d2a2f1c9433e48b100f93d32c9cb05059c8404132b854f18cd59cc8a7ca8e27925ef214b6ac46d30b7fcd9ea446d5737d43665fecb83b8915e1f915fa275ca05b37e3e19bee12bf6dad77b66a4fc74015945245a61e75df9ae64150e2cf616e4869bd3e6e114149d428b961fbc46b3ae57c5b3c982771b8eac9b343cb14cd9f49974c709b41684072555dc15b3439d9e3ea3e03cdfa10eb2e58b0c56d2ff126fab753dc79c7ee318f5575f07a45afcbff88dd395342da1f3aac7f32de5576e6f9c6fe93ba9a85d17d10c76766e98dee72080a96e23d73f54612ef5738278f5bd1ca47532e0a7adab3b64f8112e46397220b9d06fcc2b9a44397adb5de35a112a8feea079b34c34e7d3266e9e66c95bbcd68e5bfd6de06c72181948855e6ae25322e5a4c56ddc355751ced3fb17918e68200c04cdedcc469b47fcb2d7f26fa3f5e8cad2a23a954f8cee5a2b1e7c83ba8c66dbe5e9e22ffaa2949c2d1e0cfb17c1be0dfc88c04f420d89a4b070b4580a125dc2ce969351012d7b40c984c2ce07411a72c832b221e3debe013e1ba67429e82ab136e6d47f7d539c18738824df62f9b5d43e4d21891782a3861f42762a70e39f569d0732ebc0c9e49cf8a65f8037ee9683eb5815b898973e1698db9cdf2ad7be887a4452d635e5f6036ed7490fc27733309658588e68a39a64d186e589e8bf28c922ff4b3bfc5e975dd7ffd4407a6b6cbf5cc93d508c5ea9a84b44d59d108ba5906eb2fcb2eebeb8140c31f38cdd74bb3582fbd01dc21f4345a01004f825543dc7271b9f5f8cd663530d431c1163135a2476ce6c9680ffc9a0d0be9e90e18ec3d27f8d708ff4d87864e4c880ed0cd2ce99cd93951210c89c9018820a0e9c2483344d69f087704b532f44e0ce402c535df4e53cb41259e418c7500a97d3ae420839ae944a5c589eaecb55b122ee046fe872b4b1561bab20d8672629e4ad1d3e68944dbd2eb51dcb67b0be7787a44ded4e1ca947a57f99873ac599215d3165585c7904af9dd4426787842f781cd416b50d275e9ad0d32643309cfeb0bb39425996331ee177b22316c2aadc23477e3d5289a20be9aadd50dc936dedf49f4bd91e0fad97c4ceb8d63c15a73815b7ef75e75176b1146c6c7fe9c3e49ea3bd4a28e3e52e850dd9a6e7fc3871e954d31eb906ca7baee6ea94a1aeb08bac5c2548cfcaf56439e95f1efe0b00f34ce1f2933bb0de8833379e81c660b7da7dbf96e3e6a3833981acfb9f9b0d0deb18a4b0725ecbd8a72582da98e62f5b765d2ed637033f9b98fc8a31fb659f2fdddd55cdc1e921adc0033b6a74a443abfd660d3f80ddbcb855f6443357ee23a388826f84ddbafc5412b71426dbf62b96066380c5914583758f5379f284eb785a503b3fcea297f9a4793a36d9686198403ad360fc6dcab3ebaf0028d08e3e69f89869b05f961b04e312a765948531f218f5201592ce12049af19c937f49cfb4a6942deeb4093a5502327a1294c74a572a5f497ee9a531b0c2789e3a57fe0f38a6585c7ad5872bd87290b1afb1adf28ba77ec218556ced500332e33ffdebaaac55af90b829b5534a80a78ea615b173650409696b80b5942bd404d2672c4f6c6a13dac3d4f7e868779b48ee703cac922ebdfcbb250c9ea3956e38945b3321762d546ded9201dfb0fdffa0f968a35d85c0884238a6e0f8a6196c978c7fec91258fe8bf7335b8c663c54b29ecdd90d6f35de4a1396a67c72084030e35a7fb11104a61e9d87004da794de9bf79d4c55977e1826f67885b416181d631d37205a279b792e073208549b8d6063d5f3ac05d2e955a216d732bc4af6da18eefc9b26297dd806863780c0f0cbe0963d0ea4fb99813a3f8efe886d7cbf7cf071e71aeb7ae420a2b78d314e2dc38491258ce8fec71b379f3191541e5e74dae5b2038e7a4aface7604a0e8f7e08fe9514c4c14e4ddce61a93f61b142ba3218c758e5866426074656c37d9f6bbfff63250a0858ad25596554647fdd0e7dec6ca3694fdfec347f4ee553a3275734020d961f341d0d35c2e4446b344897231cf4aa48d1f171d036bf0ca0daa4fac674ac03ad2e54b3dd71047e28f7494101d91eeae0ec01327239751b1b1bb287134ecf0d8fe082296a8f56da8a9b10b262994532024a50707de9e9a255ebd1b87e6bcfe0afac6cc115940c02ffffd209d3cae8442d80c1d2d554b4a9743bd6fb1e6d7b4a6996be82511736fc2195c10e0cecbcfc80c69b8e140adcf59df8c428f0c0cd2706a12d103419ed7a0ff50098a49137b1bcdf4b4bd667e9c90dfa0e12847801ff894e12197d74daacdb40fa27cbf04fa8aa6294630fdecb11ac5eb8886248e73866ba4b66cdf424521abd36e45c789c71902cf1ed259046513c24115dab3643167bf05512c452a56abee6cdadff6d9be886cef07190bb45c44a66ff14cc4698891b6400757848c192cce494483447a05e1f3c05f7a6ee70e2571898979a4ea5b9d3b7e228de34c7811d998a9ce9fed531b319b6fcf768c2756f6107901be2b247439914339c189fd26b6930d237e3d47976bce23febdad5e3c0c439f49520ca81cfc2077a7c526bc1d4c1d08a5be75d68cce568f8c90001f454aafc37d9b43ff66ee98025c4b7954d476ec45d250354c8b21bb43d58be9465c64ffb01b23aa167b6365c82b1faa1333f51e4be9b36295b0a7a53b49fa79b1e0fad96431880f5403c06396c1d88e6315838fb9db775a9b0070afaf521d5355218be560f47a8bfcd5f64ebcc68435406467466dd94e6a5fa5ca59fc05aed5187310103606a13066b7732d636d4ab0d3da52e227e4962a1200ca816d203a0b7fb73a3608985ec8daea631c62a18cc9440b26481c50d38a34c1b415be95181585f6673319e705add75aa6e77adc44858d4879eb4bb3faa06a5aab12b190d63a671dddf6fd1774fe25f69e11b741623eda6f66ce5fc0f8056f44c6479e64f078213bb10baf7989e3db59395dbee299748b31f506372a62fe11660a3efe41c9d24100904c4363e190a245999a3d5be395dea2ff4fcb6887ee349762b531727d946ef9bdb6a67cfd4f64077a3eca2843386fbfdb460dcf46bace6e6817601c698b87484531d3646b45ea3be87a569596e5988d43c1befac2d76d66346dbda755af436b8346e9f81d2ae6dcbfb43e2d2fd422a55972b8c04454a1f57ecf96be1f51cab41086fc569c73566cab8e477da66a553bef5992e9760e86e7f279e5f3ef9e9e6e406d25c86f21ff6e8e37373e47ca0d5d64c06cab43acf62248def79131c7cc771294c7ba67e66686fbbae108f0ba1376aef05d4034406be000bfad4a9704f43ecb0acda7a557a99ad335ef6e0cf86eec680f6f1907de0b4a2abb47e9db04612b32979cb0f055480c622591b0f91d9356144d456dd8f1b2528ed809842df67d27f4449c6d36decee0ec0105dc78ab962e0a1d3990c85aba1f52aab654aa63abb37657e3cd9ffcdfc49f596826c1a6595c536173ef69c7904aea44bb6c6de5df05a3aa5fb432df7e90ebbc0087c2d2ae7da2a33921e24ceac79b6226527f48c54726b64b27a32c49d2edcf608ac27eb5ef318855e2bd49ab04fcec32b71b912cff32b04b41fda4e2990a9d474be5c0743f0eaed973625d1703e2db41f019261b8e5dc7865cd632694cf9687fe0ccb31ecd9ae0f17938b9f39e2c29b84af4e4865fd71ca02a1e3fb49ea3a525b821e755b6a4c810017f89253cf6e62e16dc2fb0ddf34b5cc6734275cdf32cc7a2281395fd75a0051d9cff17ad27ded67ee025460d688030bd8ed03e25e825be1549a691dfcb0ae8128125bdc2a7ca9b7ddb2306d2b2bc6507683bbbda847f909f8f6c068a344aeac06263f8a5a89aa69af79461c895c120234d6c26afdf80ae50b626d5eab46b0a3605b06e461f3f65d368dd6455689b489c12f5d2e159a08a8464b353658d1d378813d05826c4d9183dd0fa5e49f66bb6e2b4f2c2d9d65bbe3f91f8982916cd5623166153bd136a5c88b92dc76f010d6970cb7f8dc786b784fa459339165da4e68deb386bc9d7195d90dbd2faabd0ecafe328ac6d842d42053a93000b362cf5cbb4e5cc00cbacc564c944628ae21f3efbeb7f6e59b551c2146c3dc84869d0f33d703f079420cdc8d6b1c13dcd68326016445c5ce108742aff22d5d820bc9b71b60deb29b9fdf4dd2f88c282f5b86feb392fc3f34eec9526ee30823a8465f49a4be352a2ec37b154c41e269134d6c7efaba33da98b69ed59974bae9ac3b00fb5b33985574a243d79f3f416b44b4423423a0a3ea75057f2bd888bcec1699c882f595dee01167be6aed1c8cf5e6de87edcca92db9479a6c4b120132512956c98479c698331eb7bacb7a2fd45e8d08c3c63a36ff78a7d2c6e3572f9f1a66f407f3419ad07cbcf5fd29196be0af70b60f7237c63c14c42b13a7024335855102c5c2ab669da7feb8eb4e12fca07c336762cd0c5eb56c0e070f63333c1d360e9fcb325f805ccb95ffd878c24db0b393c9635cd7fe77fa1f30b06a71edc16188a466a593d04e22a81dec152be32e2b278801f2a71fd3ed515bc0918dff6840e710d0e32831d8c0130a6f8ae71196c0624f76ff1863c2ff53b348d8f9efb934fe3fd08daecc13ab48d6af4414b219084ace0c9bd104e2438fbafd14b0480ae8a9182428206ef43459beb08970306dfc2e372b2253863a3654ee8ba332a941cae5bfbf9e583ce9d92d0538a9f7559117178904c2d6b93b60ae6fd76cec6614469a930c0730e3f04e7164827596547b26112c0cec4f46c2f19636b67b5849342b944f185b10e6366b958339c088952c7bf90e1556513bc8e92bba5607336fd878f38bf667208e897279fd64d8f7893dda012f6f83aa14b013b0912a8e3225244c8a0e00049fb36f2690eb63876af9644841d1df11d2059cb899a36591d5965edc6ecdde0329b1193bb26725344982c20881e76043ed4a07beaf6b9d522e40c9245a5434fdae14554479b65b44fca20e5c230c420dae51a46abe7583b8f5aa15a4e9995710b08aa9ce7a7f16b6814b4afd4a7c28e40541057168b3291cdd0864b37514746586b656ea54e94aec8c3602d37a8f91a410375d7f8ed0cafc510619cae7b45b38dfdfd66bff91783023a4059906f380f6a3a771e08840ba5d5a97c3ea2ded6dbaaec0f3d7dd79a8da0c55e808c5396d2a1f5eea9a0ac9da1392e6cba4cd18ff2b3694b4a1ee533d08f60f784ef6b8b01669e6a2ba17827ca62ddad0109ba65af90615408b9dd391f3b01965cddbb624d089e3a6af1381c7dd439e90e9d5c8cee2fb62421b12c5cd172d4bf91c6c447f87e7877ab8c7904fde4c242a314348f207fa3640cc7fc83f75b679162228236fa0d07c1a6da9238bbbe2ccd3e9da3cd7bdd874169855d9428331ee168813044c7c39ba0f6c09327184baf64f5ccdd50294b6676d0ac025f3bb9801ff5a457ef8df3dac72b3d011cc78f382bce4770feca2ed436c2114df622e3bf37a69e9c1c99bc4b67534371da96fedc2669bf7f501a139e7f067207a4b98f88fc1c8190137b76fad14890037eeea578a78cef79421b300826d05f07158c39d0107b3ee6f9a2182b2c3d3aadf22e3bac76ce90cdebeb9d9581286f956a920814d082c0084e677855226cd917ff7e7c1311fe171454de3b824a63d4bf215653b0840c92d385a18d1dd55917a6e2bc1800c18eb336097e8e4fcf538d98c5fe075e8844332b79226d20b7b1c8177fcb89476fc89d6cf871ce569e6080441735196acd1ed6ea0bf138a49137b7fb6d2d1b59d778eaa699b5c667b386bc675d441df053cb977fdcd947a31b65d520d36a91ac6150eee47ae7e939f33848f62503b9ff9f7b4845f3d16b39055bfb24097e99f31eb7299fc5acd3e004eaa1de4b5490d2d2f1a2483c7d3df2c0a61f2927c06e0c3bf896c002d7f1121cd161bd3258fc6011c8a0e7f77de3618e0d77d16c9ed5124db12e73f76f1a5828e0dc9567d5a33b79f802b316cb6e708e88018c211f31516d291772623bb6e8844f3ff45642e49596c1b831c6efbf28c04fb33fff9b75450f0ece4841f7de9adf5871d05ce69c5146ec5fe8d12533078c3df800bb0c1a50557c56b557fc2457f8942b99cf42a365469a105cb1741612481159b8a610c2478ba7d4e6146b7885bfba97acb4979f7690c77577a831143834de79a5d0c128c642821faa977e1d86644a64fadd83401a5686b651792bf543b6f2c5b07a76c0364cd7fe5f8944f703df89359875a663647390b93c98958061d8b90bb4ee96262d6e0a2f046be114f82f280b50d849a5f02975f934517ad8ad995a5bebec51f0a060fb890c9a000946d164ddf84d40d97d183d8063192b51ea22be24c81bfbcfffc800e808cf105ab6faf4aeb8c2cee225dfd491742fd7d932e26574cb9d4b4214ebc1b52e97f2e62210b87d65fd40f8e9f6da0a4f06da83938204b9f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
