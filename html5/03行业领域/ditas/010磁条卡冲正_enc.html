<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7894e7b4a9f37bef9ef4e35815212251d5378075f62877fe43eeb856cc22763a0d72c1c6b9f4c6b1b171a58eab23f4819f4b09d934a79a6917c0ecaf5a54d2eee1cff5ac4d708f6a5ff988ea86f573e3c22e64859a2bdf5286c74af4c3a3298884eae0e8e6499817752dd4f9e3f87ae186ae0e6276c2672ba3f4e4c7ce50f99915dac07ad0046c0f91067e322b95c97978152d1e97d971d0107711399b120d0d10c4538fd2aa206987c5f4eb7e5653d98f6b213a97959f98939172fb94559e572ae7f816b42204700360cdc299423c9b28d1a9f637025c38fb5c2c92472fe79facb22e080452fbc72ffa391510e1f960ed7f68f7501232eee2b02ef6681d914be22910645e419eb1822a249ad6f6d112b597e53f0959b8c829c16d3e622ebd5c3241e83564f3e70d4bb140055b73dc0b8fbadf767b730462c55ece94e26e346cdb391903527ae62fa0c5a0e95632061fd2093de33f7a9b053595c711c8e0d812b6284902624358f1895ed0936c2aaf6d6f448e883c6274a475e91249f52202a4a53cda4f9041bc5cc6a5a79202c70acbc765b6f5a9ce52d8ac6a8104cff6efef014308e9bf74409ccf81bba608854af0184d287918d26cf9d4df45d60f4597e219c27140e788ce22049948212324fc16c8d80973d5c360e67f5309435b1dcfc80ae459a2d5e8362a0d9f8d89842329391e2f7a693276875541bbff9a2ce79552a950eb40485af7c4280b17d14065688279e84b7e7a3698b219bd849993b555cd7cb821805c560c9e7ebb9a012aa4b63ea0d780e8f473ec4f1876d15e50e08702cd7b65c4bd371044d0fe6a4e29bd8c03a53d43a3bf6592339bdd0fa82a36a90f3260fb7d1605f9320e7b71e1dd21249043dd59b158f115ac8e885060d6ec73fdbc5483d9f4ddcaba1c129d1ca3a0f36a3b6824fa02f6250247d4892fbfae667845001ff7fcdc0de358ee8a6f8489b7f84e3766aaf83de564d238cb3e4ce46b27549785ba62eb8aaf2350b1ddcf7d4115cfd7f994a141d9805b54073966b549323efad7ec2835afcb7c148aacd40afbd6f4480a6bec013ee90a47a3b8e1e4358b170b259c1cdae4ed8a9f63ff22a6f1fafe0d3bc1ef48ea8e85d1471495f2ab797838be7fb8349c69b13d0022ea9275ad5f742e5958b1a78de40c8832474c28e04979d09543cb7fce56be45f4ddaa9bbef36fea4c5289f0464f6544daff3ece87e9038a3fc54cbc9b9c38e5083e2051a92938749d851530b671d48d61d15a61d9d959b33e63ae55635a2e0171d6feb191098feaedf79aad39769d2f0f8b4f93042bf1270941ef67443441d9096334443d1b74fbca036b57bdb98a8499a0bd432870a0beeac19f4c01cd1c6c624829ddb229ef130059a37f4751fff18858a3cc0e2c96e9dd73d48a33f38fc45b283f63f55b336a2af08d84578a591c727a2300c2bd99c9e394d85c2161978eeb5f6a32a9df253d970db254ddb0948082087d1ceb24c5820ec7e81db67e1323c82dcd22e8e1c98543950b5fe529c304d11a3b1c7ce9fe6093d8e06d004e4667416a5416368ae534fbf7a4f89a2cfe1ddc87096c7fe382e6fd607e1623552a761141f59953b7aa22f83abafc917b9b52d8820ac9e09315166dbe591465f481f4914d3a98464743ee5218f340b6b61f16a442223b1e9656d7091eb8e7f5caa6ce451b68ad19bf20a014926aef3bca021ad980a3cb78ba84c856addaf8997556cb8d598fd13f5284fca03788b689484984b67b704bf6f54df9fc1787c246ec1ed57212bde011af3e0c22aaad2e0027d62f1bff06fafd4948a50c9d3f78dbcea6ed4bae9fc0132140af5fdd0125b1aa0e4b5f88029b8b55e06ed7fb212a2c8d7b8d3d3289291114ebe71b7ff0565890533c0215c7d83d4f85aec87f1bdc8950e50162e00a5dc9d6751d68b08dbc8228a568a589d3526e93471c96d459420d6064073d16de99f950d950c6e9c39efdeb76cb9df2c8d7657175f5ba167d5b5757d6c940cc3f2e4576d97e1216d7a0c2b3359838248868e9825840692bae9805b3e1cd1504813a4b2e3cd2ebb6f97ab6f8d0388a565081f2e045366e7d90edf2fa8e8eae0b66b77f639f357317bba2dc47f4ddb55b6ccaff42a687ce18582d20622cdf0452d6aa6cc0a92c6f570bc56af912a1b0570f8bb83a4c705ef29f1fb7bdd8fe69c7ae6a6323e0b11d18469e6e8a728427066fa71e1bcc6abc4fd8992ff5c17a34cc5a01a88906e70a5c7e48dd7addb92d04a936ef16b7a569cd063df47d809b4ebb42f6aeb0162a1ae97d9198c4672d468ba035e75cce78e49ad16dfccd6c7ea027790494ca2384335398035c93a70196855abd760569c39fdaf79b17733e5c7da009d30b307f5d14ee1463ad2f9962169600b996f60f2a94a8b03db1642956c5f2052f500ed19caa9d476ac893053b10d05227812cf192e18b87435ab31c5eb778b52f9aa93a639bde466c328fbfeae498159435fdc40e37720e0e4b9127e2659d0b1b9b79498ae9413707474fe1e49c5d8bf7fa4c5c66079151aab4c04a0d6f40aeb18d03d0f809909dc90163e61c6f025f4ce551811f29ee1dfb9a3f56f8f7acb39a4678d064bf329e734aabd886513e544b7d53f4083251b229542a07d79eb78334b80c7b783e3d4325f9adf5e960f3eca77c35e9a6eb4de14a28d2d6f38bfa8c3298ddac2ccd0a12de0f49763041ccf8ab8ab8b3287ae49dd60158adde5a9292182d8a230368e26c3797db0ecbb34bc7f0f377c3651efc59ba68dcd090ff2aa8a4158b6c48bb9bc83a71ad10d9ef284cbdc4f03b4d5a8c07a5ed99c732e90086429778453101825bc328a486de4ccb2ac253710561b97af4ed91c0a0aae1ee17879d06d19b5cf45f40cf67cd884a143505f501dfcda278e1dfc3db2eb0c88bd292870789de93c17441fb59598e7ede349b4dff5d553c97351993702de7ad92619ff91ebce369b7bb397623bbf8268d70381750e8bb00c94a7326e157f95ee8d26cc1a01ef5a647661b1d832f67267994a1685378a17f1e4b30a1cb996856552baf4dfc9ef835861d1ad37da71b8515d6f2ade82cb0a39006bfd1950c49bca019c2570b5a284a33220bbc09157f20f2d20bce6c6ef4864a6c3cf04a46446cee5bc95b4034ac65163b0f408d7c84890b03004f51da8ab1a9111e2ff82427f9ae88dd2e0d8bffaabba9c35ebb01badb7f9a66580725d7671c34759bb9c0a06ecca6415913c53600c4856503cffdd85ae3c90bd68192db8b5d7d68e4341786b6d5e5cf1e8f852a7b050672d4dc8a06a9b262f33e7e13aab36b5615f57d40b4c521c290033f2a2ab62a652a2685b5c961aae54347d2e0d276bb1ff6c5863ee1448cc490f74ce56e30947965ac72098eaf61bf34f2534c263a79493ee88fa409a187254ef431ee167c960a446de5699068736f025eeacb381860fab067d96bfc8f83590210691de23d96dfca592fc00d4afc99271b3069ba59d148c2f0980500dd4a82add38dca95a4103bb885829c0fc1988daa7e202f7b7fe514bab910ee4b9466385882486b57c92f5af3565c6cada9f1e3efa121374ae4000723131c4e4f7a3b49784692c1310e412683c43bdff7633c43010120b709ede320350c66a842b01612361d25eeb8503fdf4541dbfb3b1b262d229aa5284b6fc573574f8857a62d7a480b9fa9277fe9523f4d45c93e6ba9cd93b95abaf87f26c87b690cf4c0c96562213881b9950e73359c819ad2df33ddf3a00d3d44067991b22a8da4f8df8018be9138fb4a268834eaf09fe264bd958b608ff592793e1f20d9c0ab9a00ea46537cb4bfbad0cc4e90721bfc434c6fded965e6d028f4f72632d9008e775f2e942f04877a417df7260289772af0eb1732b6e2453c70602b60ccf26536cafe80bd16171f5b59674c999aad541684c176c4ee8866e4ba680cd63c2cf0fee24b660f8fee437adc20e2be355a2a0d98ac5c78a39b67a8e3ab2562c9184ccc8eb403c21a74795700dc9dcbcde055c1148967e8a54ee9c2f441f6f365bce679e6c3b1fd17f691bca01168f545af7eed675ca5332a1cc32b330e115124f0cb18b32c25005cc4afee7542561ed379d307948b713608b3333563feef8066965603536f59cc4bdd78ca10fa062e60ae7fb0205a279f021831d09aad5eaf3afae803b1f19739cdf9ef9e0a20c7f8c44421b82f558c52f926ed571082b994f509a418f4b86e7cb2718a7edb2a68d81bcf5cae5184f88ebcef0223b6c9fefbdc26ef185038be536577e559d619497c21cb1ec37e98a7458b4e6774fb7ea15a0483041f538a995d66e82cf8002e0a9294d9c76ac596fdbad14af435c598a19daff8832d13827b36a46f3c9ae6974493518c3426349977640df595889fdd4289e71f1f9c2dc6d091922100fbb627ba1e0b0e8ca81c72284717343037a6f5ff691091382ae042fb739b8f10cd18e31809b35a941d0d5db0391bd39da67bfe1b0295476b503694049ca2541dc98e23a11741cb8fd6c799fd6d782145b3445d032161aea8ba113478f7a598bfb7280ec10abe7ede65cf1f19fa65797ed41da0f2b445ae1b0221acbf1fe374193fa299d9b7957dd3e24bb1c2cd58fdc13e0d23edf00939200238422d25a9932be6b5235e2750983e124afe7bc8d0d850fa04ad5a2c1c27c020032f4a5423d0a5103d17c404b41b1ed601f8f9a2915d088df2f5cdfa15d449f86cfedaf6be3cc94adcfcf93a36c7d7832bf8fc41bcac784ec056f8d0b42e1c0b795fedfe8d56004363ecfd6fe496a19d9cc42b965ff58169a43058748780ea0ebe0164862d8a131c6eba1789e09a89ab19ce49548e6d65d8bbb5be48beeb8eedc8594a6767a017061d4d735f64a0968494ba243f01462f0c8a745d4d1d712082ed047599543f54404da35c37eb97d5425dc8ac21baef47cc11629c686027ee461e01a3063c0ad2a21e05fc76117d8ff0bdb9c352f2bb5824b88738f912d1bff50a3cb0c14cb6d57b8f9324867cd2d842cf2bee27b056c3d2d61ff62836ae4d8b1194c036085a747cc6b28a962604ccf5b38b2ebebb0a29b84858b0ab321a98573bb72535157e3a944b18135f2da1b140857cec3d0896e08e47a3d70b16d3934813dd48695505034ea1de603e970accce78863afed08d7e5ed25768adee4d18898488f664d76ea3a845e2c48c1f08d6fc566e499346bdc288bd9b742c11d3ea18bc2c6952e2b329920649cd77ecdfb014dae282827741af9ac9b8249bf6834a66222f755a5fcdda94f151b489f974fbbc010d34bf1535c0808d7b34491f551cc5a2aeb95566866691bc300df4bcbb0e83e8534c0a9bbf85e9f5fea8191b22de473b87763cdfceed8e70833d11905aacd7dee790131aee16351b374daccb1f6e0ed377a8973abd93d918b8a60aefd23245318b12bbc07952df5dfb3d9ea28becababac397093c1e310207a2eee3ed239a1d1d725e95bd3e349280f016bf82a0a2c34d6617614ae4693cba033158766e6f41fa74df224cab633098ad4754275cc592c98a5cc067ae3682de4535e82aec29105c9cda59c3b5f7ac806859b8b3a6d7a9eccb699a3b56e6f8f73f2a8a74259160b66e185eccf816530efef34598dcebef0d9eb838f08d990e3e1ab8d5fcf58f02a63389f0898883c7d968c81d26a5614848d23422694dffb4be3740e764cbfb7f5b9606071dbcb952afdcde415f211b5f0f854ead67bc4ef8560c8b11c463ef56a3a3722360c254025566eb4aaff64c02b5f727480d06b691447470dc69433fe85e80a0e932bd2427e5ae3a1277ab6c13dc42b28944882235a7ae6285d85cb545a89d3b956bd863d4aa16495472cb6c1871deda425c431f3e196d7bdae057f543ae4dab9507a52e0acef12c0df3495782f79657bc1521c99a059fab6893c3b71d8c2ff682a477f98e36f8a77a4a55e022fbd6947062cb78240c33b97deb0794f010081951939c3ec1e8660544da1ad81d557796e6b96e4e1f1bfe7946ae2beb81bc987727a4454a49df7933fa2a7f5e257052a56aab715e1b8d1214471cc607d662d753ff8ffe9aafcc5ea098d09ba62f5a25f1dc77775f221ebd37b23a32f8de5aabb5de876af740899ce111d484279565e38b42777aba95ccff46a8625c6042bd7ab978ed12c3cc7d2d52cfec39b663f450e3c72bcea8fed587ec0bbbd38eb99a2a8c919dc2ecaa364330246758897408fc95a328f1e8fbf13d5a928819b96f73b4a81591cfe5382f2afb74ded400f7cf15cb02f0531b55b22219e1516812d42210a11aa55eb88361f162c990df8f36c0cb4e64ad3cd25cdb461b30d8b5e08ef0ed736774223392d5fe70002cf0a442705ebc646aa83d132c33fead49e1d34f7161069eac7c27d87754dfb1e84a8312db2f7bdb114cce0780a8490d3b676bf404247b1be8e7e339b037a29e66821a0cde8855889172b51dcf9eb63c9bcac48fed00c4063e26e6f4562eef083a636e61054b3078998f2b0470a6bd0ea215861f6060fc0fab4c13fc0ece48aa971c994726ffd0bcaf496ccdbcbefce40050032367d8180aafc278f08592e4e4e5dc5f38ca74d89cec55485288c02bfb5602b7677fd49ff21b0e133a1784f389cd601fbba1391cdca1c3fb3a4fbfaf13df2eb8361135e0f8e934fe435338b060de70e5da7cc1f74beaa3c75950987cecedbd2b732e7f888757fbdb45bc92c9607708aab9974f35f1cc75ebf2b00c6da1bf1f422b91c509e3086654a024599657ec7d96f29e1bf5763943994e205622779bb1b5634f5b25efdcf9aa281f6c4c689e7274a63178827b3cc642802c0ef76611fce06a04f490492e2ae1455cdef75a5004e747928c7a57284c90dd152486a763c467ebaa34857b00c558c3cb6b36b5f098621058f3dfb7de388ae0d9c04b670ad6b7594fb82fc872b6ef083563bf98bcae6ca863c44bac4c9f71efc2db68733a3d91859273748785b2f65d2d20f259c496675677ff3a60abe456db8c91f77947548506e51f103ee258019776271ab7890d581c6d385a8c46999e5bcaaa9a9106a55960ada6d87eff791f499d2538e40ac22ee35398e970f74e26e8a99067cb8e256eb8b496c94b4aa433766072cfd2f422a8164072d12366d10ef5c9439f8bdbb446d4253f25b75da25cc3f8994568d9522c5d78558220351adf29c97c96caf852986288e05a05fd75f2bfdb9f0d857c1cbe678c08b51f9619082f8bfce40ebe672d8776919a81b9fab122c06314611bc18533ab1c137012442500e1c6fa4a9f5a9979a8ecac048ad077b7b65227f8b40ffd46b6da8c0d6f78b1909d2a80faaafb87291e6723a9fefacddef37c50af117e9e4ca3aae0a6e845b48b29d7f733b5050ad32ca1c5f5c0a5c9a0da5fd058e17f009d536ee22c9cdfdd100d3bb5167fe0fd407fca686bc10cfe93e8c652f3b69515c311be8a9ae5b9781f48c07f79f219649d145025658ad9c24b483c37c29edbaad367ca9d608602a9388139e36fdbcefd897ded27dedfa3b6fee653c389aed835baf38a22ae54ce8aa7a0e6ff6731dcbc888e91f3eaa78e68a86a0391377593ba6a61ca53e4c7327c1a3633ff4e926301931aae8e5c68de78bea362b1bf1feff23c092fb16dc0d9208c0bb4c2531a2edb4b5a037016607ecd63ca3f2319ebf25bef7c2cd51ee0eae90aed7e0002137a21e40b8be257c98af835a6a4db11b098b26ca3a6f02212852d6ed0884babe856afa53a94b49e5ec6192616d3c1fddc3826e5f691e4dee0bb48417a1a74b6a62459e3a5202fc3dea9a0919b82ef8986146bb45bbb4dce07aa205ab3341f94a0a1afb615e01c1fb56ece11f2c73515ec33cbc55bcd8c0e15a433a744cdcca32f106244d8d38932ccd02b051c19fcf43a1f467d9e00cf2534e6505edb415aa932fb9777b778eda7ef92522f5e8b6f3bdf58489fd85922869bddf558f1f27d5093ceb14c50a528d80310c3f43e8c91ff93e15d2acbfbf409f2eb39848012ae230fb71bd016b6f74db0ae97519bd73664e3fc093c3d1d93db6b803babdf25ed6612ac81b9bc8eb6f19d780460cb4c9c8b25d40faa1d796e7b81f53d8699e9251feac6d689f1df860d6f4644c9d4612d30f33aef5606011469e6069a2ece01770765089f5876ecb420297745a6747aee6cb9fd14aea90b2b5137019385310c9d3b535b4296bfd6a1db91da12690038373f9c0c1718ce026eae4bc14e8ae6499bc5f145a4aaa3e8a5ef1d0d46b579ca20a2bacad3d9ea047706e8591a1a2d1efb685e1c93f95ec28646e35055fbfe8c1dd28b5acb05fb6336b9b5a7f72e372c78b5330b23fec856ed526fad302372b42cf28d4fae29ff0328044bb537bb79bea0722e8b3e285c5f3fe4b55c8f34fdd30c13420e0dc11b88d198dcf802b38905dd13c15f3eff34e5303bbe0fcbedfa09d7e510c8dace227b5f3e6278b02dacc9f61b9e0bcdf73af82aa2a57e5e37843ad18d119b8eb54f7b8d7c687b7f5765a36f76ad19337c6b48cefbdad64fdd125800e2a7e3c500caa9634a4b83657a3ccd7a0f11b93e946011d7143d05b300458aeeea430eca86ca9dbbc7508338e5eaec2f551aebb02cd198956a72c19a7d6b1a821995dda30862fd210052d9fd201513a08927e8075c4d9f3850d8f35254ed627779cec2a8802ad3ca89d03d7f9ca50eed12a32e3238b94dd651fb00f03380133c2f68f89092870a93d0c2052e78595f54029423c5c65d97e96e4b67ff27f736fc724aab51841f2b323e7735f9d880257c1e927845f311e413b12092cbbdec7a3c97c227fc502fa1cf673d47d3ba5c57eaebfb170967d2b9708eafcdd9bae0fe78d64d3288a2164d3eb8195151cf3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
