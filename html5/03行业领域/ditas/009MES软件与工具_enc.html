<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0624b92db68820947d5f91f0c60469c5ecff0c267ebf8dc4ad5e53c068f01faa098bcb873e3d22155b9034d801fafc4d7dd1672f6b9f4199a6f56c5ca248f8fb6f272a2560a04f72f74681a374819157c5228995e46d5ddb88028f0b87768fda3c75cdb53bd6073894ccaa68bd417a1ee7ba66e18aa7df4d4758da8bfc980278382fc0c4ab225766d0a156120060763bdf3881f0582f70b55fd84ce3e70ef911fd9a6cd27cce25d597f3bc9e90be7f6301097578096e4be9763f733c77e26024bfbb01d6aed27d7b0b0164d055d57d6c816c2091a67bd7597b155faca93060c6a6ecb5476222d1172490d69464076dea43c3dad1fa5da1d723a8ed6feeb4fbd24637f4506cdead371b4a540a812b7fb7d521ba499b3e84bdc7105c05a111d27d67351c500eee5308856caf367c1d8a0e600ff33740e76d175f0bd0818be8164d28b6a3428364f5aca2cd10e9cd019f90ae343bc48f975c324456a520e1c3f3c5bf18c02b271331fb5f9972275b05ee1c6474aee2bd271e1624e9f475cba61720cce440a83f098cfb8e96254e2e63ddd95010d0fe5a676cd095d646610f9acdcf30e327921ddbba5ab6e5295b39008a4f515336e457456bd50f613926d053d289443c4d50d03e7848309b5cf2a0b9a2606c30db0ec7eef52fa346ff828887a8bb942725ec1cb3cd9308da852e5f4046a204f702fbad276409d374cc613768a68a1bc8d8604732e67cb4a641c82287c8bfb793d393487c9c4fbd0de0d966d551121f420470878ecb155eaadd6007b5d19a40864f0d6568633b8425280cd8bc55a960a709897503e27246f362bab29890f32c2a0696d0770289a64eafb3f1b74060347353e562a2d60188dabdae4494e9402ec0157512ba64865022efb1e0ad5f71c3e9a3ed487d63562b007415c6eb2295aae29cdaffcc2d6014d19845f805acce6af31358d18b7f343c4fea038a9224854260a2c426b6c2ddcf08d3ca84362ed2d573a65bb4dc2b0f1b902f0347ac1a86100543fa5f88796b8c0c4011c594ed970427fad61d7df51e5faa90e80a75a340d3d04c2c1adb139ea9f20e5eb6dccb39878cfb57fb7f34d1aa98ee6ece3e2496827ee50dd4473b1ef1c03ad82aca5dca81637d77fe9aee3fff32e6737d001358856f91e39a90ab7661efe36b01de965aff13c9e3fa8006873262678394deaf41ab6a6b15c8d6e3157ef77fd319a95475f9d17894a472b7de18ace16813de318556cba3b37b514406d29c7c90b7a2a2a8bd70137d07df3a454df2ee704b4dcf5e7d0f64467a8ad4343ef5d70b0e169a4228f010df05d3cf1fbb7299cfa931e030a2c57ce3342721c763e0594b6f85c2b8ac14fe8187a0b99cc6a9b96efc08b5cc76f5c7fb078daaf9b54a1eeb1635c410d2b6c84ade36f92ba82a8d456965e9e22f352843bb9a18d28d0e05f56ee4dcbc5689dc3ef06574a40dfc3ff19f99f3195888fa1df49cabbd15bb4a57739dc7e80850be1668420548e65059ad8d96ac4edb824bf0cf49e9ac2bbe749814e62d41438f073bf8a7aac878fc71e3dc4aacf94509db148f3adec27bececf8e5822c6cf5e9b16ae24e500ed13852101d1d13c7f1fd2b4527bdec535713caa4e019c147e758e013ffae21b6f24222c5478297d14d615a29b11dce973931fefb54af3a054989869b52a1f87842f3517f92925eb85068163a7f89fc20e3afae911a19341e54342a59dbf48515fb10eaf8fa2fd4f48cfe4a3e174720a58ee96410f85c06f1312f380ee84232de01695c4b2ab537a902c8013fd4a7ec6a2e702c873edc591dd48cf955a584f03c00976759cea67192011439dc9ab5d94170f31ff09d0b4b8d4d19a434337df2f69bffce2218543f202bf788e5f2edd7608a954b87c2097ae8c5ff4ef1a192f4e7c33e30e68a0026e65b0d91e12de7f1359afb99dd4c9c9176cdf99c6730afc35a5de8f7f910212f1155dfb371dc5e0256c8709103d0347b9efe7630b525fb7413413d3e3cc719aafcc4257da5ff924baac61102d7bf1a8ed521ba9f09ff10c318afff61496372c67e2c816a1ea0a2761c9d044ad1fdb4377120c75abe9cdf502b79d04866efe0b77a022852f74230e7b5577152b93062eaea0a2c844ad9f61a584061cd5f9d3931dc99d9624e57e3fe9c060096bcf87f0e86dc7a75e345917a71b8579badc1566737473c56bf5d733eba271feddb0b890048f9176f139509facb9093095edc88cd39ff824b1c97d1825390e8474fd1e880c2422474c22c5aa7c0843d65d269c9b8e9011a77d3228df6f3646bb5e1cbeb191befc23a339c2ce90ebc8897c399e557e0e2d61c26297af759792e622d7af762ae976431ab60e56b9848f91d579fb366355703a2991ce99aa36a6d1e8625450dc9e8e931afa905a5f91e451e4e5980ddb3ce11f2f0dd8f94ea4cd05f32d43fb06d6ed69fdb217431048fbbf80973d9759dbafed301812fe9b5a05aba02e9f7039e130bbff690418cbfb1f1c99071b7d3418253c4c891c604bd445395910abfd0ac936d0e5570c2cbc44a660db63d0d2ec81f7cf4d7b9e2aec99df5fbf0c598b6fe46ad75e807f0a9992053aba723565e649b0abff049722c8ccfef61dd5476ca1803eba2105ba1c995cf32cfc928022bedadfffab5cd8176599f5d1f2131eba2b0bbddd9972f18c4ebf5881bbced2c6dbbc8c05b795677b49b958ddd2ed5b802cb9b47d431b3cde289e40b63fb027b0da9cca54130666995cfed6cac018022df63ba494677eef16e79f97fb5625d411a2f25b8a3ec8f7dbbfc0a0779bf183a1e602e797c9d43e061702a96805de87cf197e48778a3bae5fdb31498b5f384798dce3fc38a829d7421c3920542002a52dc90374517b8a0c87c68bcc82bd1240badb01281b4f3fa2939dcf43653328d8f5edc54efdac82f128ae22be2d4fd54f162b4687a025ab3cd23e7e08e86403ed3b11bcd1d089375b53e93694182772def416597d6af661692f3facc753647c1b4424aa24fb7ea159934f9d7996140dc1b5937567541171628cbddb6b90739f468bcc59baf8d915541baf01c0ef64772ade13316c64b50c293ad143f594f1f036fd9f1e85a160b6dc3edb6b3a53304ea9216d3053844e057c260882264e689eb7c1242f85a0ac57dde339689b44c18e89bc81595997edc7cf7a84fcbbb3ed80bde6435d38b58d3eedcb32ecda3adcfdffc3e793530f754dbe827907f6775796aae657d419847145fd09b30376f7ea82e526f88bf6aa7c339b28d2171ddacf87c9172fc2478e2cc2e469bf23054d4601d7e596c0860224e9da16f87c221fa4d78c2f060a57693e10531b876494d5323b575141c2b700f5aa0cb00a333f6afc87f01d9024e77d0ee54a32fa4975bac574e70ba2eee46e871ab51f9f396a6e852c5e0d7ea75eee79113c4b11eadcafff4089e8f4202b07eeb543253af14dc6f5eb6646c99083c66148d2756caab70fb041890bfdb05bfdabc665828c7795d9345a126a7dbb292ce03720f70cdd0bc1a719f921259b2722044af649b3ac03152bbeceed2a5218926247dd663e067a0fd33e17f933a7600e333468545b08618200facd046aa10d11d2124a87d26b95901e417917a4b8fa8cff90455cdbbc7bd9114fab941eacb5c2390e05e0cb7742efec42f98c8585cc5f3e2048ded2086b2936befa3b12ed7ab4a5136eb334dbfa7046778bfb0f68a3fa0c652fe68cf78c282486344c06873fd60c58c7febadb90cf8d1b27c0ba1d6e63570d9409f28c10e745bcbea4bda0c8b31dd93428c29d1048aa83f575faa58d9ae38368088be0a6e053bdcfac014bee114e934fa5e4344522a37edd57a1cc752a5d89431c70c3e498bef7a94c98e369267b5fdb84a2917943bf98a660fd3732b2230c24a710e7c93b3b3abc1ed9ec1b0978059de369f9bfb14e0b911865f58e0695356cef8832569bcd11b12cef9d7f76a629ee539d282723f41fd4f24ca818cd2b992530759b9236fee4d6d1235ba61f6acd87858e001e47edd7a22eb98728ec508dc364aff6132b605342fc08344d0f15a3559c3c97793cbe49c3c0aaf6536b06e40ef9b6e67c4e2eb95d73d0b429d107129cc59755c9c7981b0c4db2bb46243c1ea5dff9d5730d266b64708ccfeea0d3905cb8d556d02b0a4fe9363a87b29c53d3bb744a7d05caac322527e15366549bc1e3e472d63f7a8e2713709dedcbceb398654743cf74278b72656b152c59f313415d5ba0863b512655ae450405dc7c5079b49d322834a59a8e9c35d6897897248e0737065700ba631fd355c6ceac71ebd4c14809f14c45a62d69291b7957c51b59b37c68defe6528e205fe8409fc7295712c870d4f652dd6dd5c53202799e753a9f09789de2c7e60fbde693e665e4c8ea35b570851e8633f36b5750862a6a52727b10de4b1345832a66a88e113c906e282b715226dbece85a61430c23df4534704cfab1209f66acd001426d773581bd6f91e391de2809b008e5654e66cdb9d1754380a7c7eb6a1088e399d671a91cf596c80706a07c908e8dc97a16d9fdf40f96a6170fb634e4b43b9723c862ee9ee5b15c75f5912831ecfb430f844401289f3d6b9ba723cf0833040a57eb69045b8018a4c03f4a1697eb11b3216ff143b7b0d62249f569231ed03ec64c2bbe68dafd028c35b84ad3529f0d8db3178ab00947cdcfa36f80ffdc4026525f4704e4a3206e6424b93a4764ab48c6fcbee4b6ab333a7b838f6744bffec9384a5fa3df7438c381b5dd93cd6411c204097a803e6e1df55e4a155ec941a82d608d3168608b58c4a59a9ef9ddb15613e34340a0771b2257fb69888301b2cf70cf6e9c79572213209a427e097edad4575adc398e7a001f6cd578f6fcc0f4cc94a6dbd890977759fc91264ca69125cc4ab0d83c62e79d2f09cbdd42d26000b3be473c180aedb23e9b7ba949f46c6548dab052ef23c6973604f1eaddbb6d843e7837fb5adeb9a355f72333740477230f7931f74b9ddcca59b4061e8c64215e808cfb5ec9e56f1d6bd0ab671098aac4871a350494d8203ba9b13c071ea4d5a05eb547abec1d21cd9fe0763837c9d73995e192605afe70c07640ceab6cd90ed539143980eea9a6e0b232ec6c4b2da80fd6b80fa22b22792801d9b4b76dde5de553cbdff768c3b0adbd68230f242abc667ffb8197b3ed59dc89e1e280d69146d78f86d59e6a3eb7bfdd1ea39d1d978d0737943b0997a904053d12074fee6d534f8fbed5c32f74511449e0947898334adbb880dd05bbed8ef5aa3f6cd4ff4a59cf3f02c1514b1c4c18821440f3c402a87c910a671f220f1e06a44969ac8c5ed658574c55064d9a700649bf7a508f1df0c74dd4e4a7c579c4c1c716d4d82198ffc4f682d87bc436ef1fd4dd9af628ca24cde7f4daa1c69abe82e3351d2bdf9dd6f3bf901826ac6600ed31dc7d361706cc7e6cfcea12dc9b198dbed08560d15a24e734743dcf4c77d361456c3afdd2a130384d9c5f2d9abdd0df524bdae059cae3118a0fdd6565a270c341789a71f88540bfdce144bbb9a03138f69a55a5f46e3e1ec2fce42bbd84649cf7b267da03e79eb958500d01a16fc6d851a6821c4fdf5441af7992c7235a85a5bd1ef9ae75088332c3f3c3beae68b46b8b52cb3b1803e655d63a936bcbc5c48bf9a5294081c818614b52697163d0d722d0f7eaf17e5dc7a6130de75520b9d4a188b1a6ff08e4a3208211b923151dfae36b5a1cd5ee16d65efc3314212553bae066bf6fa3539c9940b81175e48f3d30f3dd9ea79aa9241789a4af0166f3a07fdc0eec55bafd10d3df8cb08930aaa2034de331110c3710c7846022852f4248bcf4d094991248cf1d8bd66014a8dedb6cbcba181125a0ad6576909cbb1e31797bfcf12d8e1119865923c26ab0aa9fbb6fd8c8cf1685d0a72838221901b04add5fcd7d563baafd8b3242fe6b1ac33ec0f7fd6556a5056cd729be524ce22f7fb218fccb79cde53f67884110411f71ce52966b464bb0cee50dd9c92647062fa0b8f4445d31c9218b0f9976e897541860d2eeca587618ac4b500561e0f90c140b6a04613e6cb2897f56c8da63730c7a4884fcae914f946102ddd45459001f629950fee4843746c0f7736877853cfdfb7765e130ea6b9bdfd62f62a178b016399863a0511a12dd324d472e486e54c951f397d004c2e7ba3d94ae3df57aefbbc240f59b6397461b3cd4b41f1085fe12da393a712b17a98f0b139fbfe710a2bf5b3e6e0ee19acf08c25c5e9fc5998ee92da4fb9a7801f8d8ee854b88cb4a034a396b77333feb0314875d2515e067639d8824371d5d5d60b1623af2b45834d28708617a145b0a39188e016424cb2155069484e7e9e706b96e2f526cbec5d5bda78a6c87173d80478213766f1bdd34e264f7d178bd1de3cf62624a268266e49372fc03031c4f0bb6038c6ea00bec5eac03d3ce50d85cf07fa2c9efff6dfe611337111b9883b4fab60d01dd008158284fec0d9851dc1bc92b074be48e849a0071bf7749c43b2818008c678d61565f7ad27390948a27ac1ea1a1f3f5a265fbdffe60233fb01afe8d7605cdc2046322abb791512b6bceedbe4b5af93839f2b5132872e78824a09a5b882e94313534675e24ce7583ac58dfdb851d5baef1647332b0ae8d478d0a7a4cbc95bea31117793c67e5dd331abfe21ef546be361d9084b30484efbafe299eea8100e8a11e999d80763c65eef90e91e4b067bcffbbf68821aed3b09d5aeffe908dd0c1fd11c08b81f82ab759252e2b059b7977db3190bafbeefc06ba2ebf6e9c09c91104cc2768c904919017d7e6d4539611d25f54ec49244d84f76459a89d9c7041c640e62f0359a9559262bd933973e298e5dbc213f4edb377df0c20da759478978d78498517ee49dd8748be11763a53e6d6ad1fde4a3b783c7cd3703024bc412c7b417410370fadd815729ec5551122f0ff2c04e45e233c036513d7d6cacbf45d169cb18092aeee8390546f63dc1b4cbd7225d5dc26430d264b6d8eb0f7cc746f41db41dcc0cf31f181bc532bf55354225a2eac6efd3968adf5b080c1735497a3fb1f8cda4a6e412f71b9d233ec7afaa048d295fd6b130735f763878721ef55f19beb6a3cc24a607d985a51c87290499aedff35c6d3c65014fe263bcb7a5f4e173a45ca96406aa0a6cadc65a3146ad9a2eec412bc81d0ce76558cef89cbf550cb4fc92ba598be878b7c1d3a58b3a028bf9b6be0434108c4d4ce80c0117347be8181fb6431f3944e91a056ce46745ff68e2b5dbd7f8ea7baace2b17cb077479d38c81106aad0fe62364a2197175c35d786a9aa57c6f2375b1e32d4476df207e650595ffe548e0c26300264ca4bdab694ca1a7112ff656f1d3f37b18b7064bf8cb105daebe14411a1de5f113e2b18c3b13ac3f0ff544f5a35a39eecf26aa4c332d74a34ea9125765eede7779836fb8fbbe1fe55b45c2bfce2b2af9be98355ee5b32251a283601f2619524d0f3a107dac1f66f0e80227d596e85a32364b0a0bc280167d8f2b7664411b76e5c0e37ea8c84ae69811fcd01e438dc584e39c2850440b4827251b98ce749d51cccda09fb208b9f5742cbff71785b52b7d948629d00608c2fbecdc54409a0d549acf3bd357c58d9be0fd0c2863d6d3449e281ad7d73cc7da9fefc850ba444c8e3d16ce6877104bcff3d69ce6c18abf4c5ddd5cf1143caf6699873958565d34485cf3174bb71ed9f5d16f5350465a64071a0174a87a8613ab6a9a67b99f761fd10e92ef45707614d502df739b0f753c9f83ba0957bed375bd7304974a96d22129b9e349bc7088072a248487a51bb396ecba7b2ff09f1bc7ea139fb5bea796881cbeb7836c55d604b9e1c629d58e8270b12b11f718f70f731b7a40cfbaf27e97e6715a02ab1491301563f6eb3a9b8db3c6815e96d814bd7e3e0472f1c345433bf71a1e06eab5fccdd9a5596fe0993cbe0a8e1121fef48ca057c36a6614628759bb521811dcfc264f0c8fb1da3599fd07d5e3559b96d8a65a60191fd397ba72978381ee86b997b824b45f0e2338cb4b8ba4a6a39dd625441ad5a316cf3dc5191ed270734dc7d1fa3c7adf5a653e1e9c217f5311a35efc6917349e3ba267b5eb3d9a39d275f06a6a0cb5479c4956ec864788bdf2c536b49554f431136978db0b7a8bf3eed21600f67ee39fc5df3cdce8810b623fc73dd186afec2f4b1c57dd83f0c281e6757c55370a5ff092d7a6237590f78803275e0d2fea87c3e4efe3fef940e8030a0654c1c450d8bc5d9136684cb7c22b534a08dfd81d6823ff5e1fa7cf064fde72436ed41c5039ffd5eecf5954a2ad2b30766841320c6ef6be659351189d12dde84cb7f473ea50943e2d79c935a341fc4a8d37319230d1d337674d7e02dac5c73a38873b10fe7b3a3fa08f3daa7557466c38cc1d8674146c49d315b8b80e7636ebb100defc23e41fa131b3ae3d358b78bc84c88435da7d531106566e4eeeda826cc60d7a802edd0d5be58468493626fe88eba9bb317029e3d3abca4a8d5fd6b315e69adac15a228e1e67d29dab944294e4ed848818befdd3d7652cd6ffc07101b37eb57d4d169e4401ab79b39eeebfedcfd9570681b0b42ec0dca265f8bda036889622436c0e5a5c5afb0c2a9d7a235ffeaedfa9fe6010e2de6e8f712f3f1e0793fc1ec49966c4e6826270733ae7898cd9384702cb385ad2845a7821b2e7689e1c843d30fbec92167c12f20c8264934643f9e96f58c2a2e944b417beb240ebb7d669d08cfc241ea14e1185e4f3bc0266dc426217b66c83cdc8638b63034a01fcb1b7d5b6bb12ac0072cd515d7e020d686a80940ed26a0e6a528c0e60c5b05ae138084dd4fd0bfe2a3a045e90822661b592d93277456608be4c722d5f76d1aefc3fff8efea59a9c383941754fd5f218bcbb9962ab3a7d77c5d0a2824613cb8bac2881d92d0badc8968d780b9ea3498739966c2ce4f813074f557542faca0f67b7213b56fc20e766b91505aca465339bc538ebc7545b398e129545b04f2cab710da93e111b0db4d912726efd4d2c75aa22d24f3d7c59775c917ab97f8b7645bd11c667d3dce9025455ed354ea9ed33559952505efaa0a1ddbf7c0e810be7f1083928e3979a5fd694caecd6936c9543e1cdd9900da57ea8958edf10bbada390a356d98f4aeca9778495d9057d7d850584c4c2c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
