<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"090dabfb35538ea4362049380765fbf0eccb3c55a033ccebf02079e6f6885aa33b4b397af2b3bcb6251247a9349673bca22d8706f03231fd75c43c526dea96fefee1eb14917eecde7e72b135a51748636378493a35c4fbca79af0e6779d4c3def3cec2a699c3ccb477783c2598087bb9211930d43e863cc7c30a01cb7f3a37a30fbdd8929e287616b01a4bd9029f3e0ad2128d27ec4901cf0470cb2c76c8e8318bbdd00621f03a6da5294eee46e3ab8c24c8a7b6f85afc583b8980a25a8d838532dbfb17b7e7906ab191b060c2f5a8a404116a6f1edabca85e28bfc6b4e4579c67675cfb355e295e50979239fe0330b55442dc6f656de889222d8341cdef6f70a0caedb6f3b1de60f7a5a3a6009eb102f94562a429ed00a913116635fee72ad524e4c4bec32df5a3ed7ccea09edc77fa7a5b7e30612fe597d4ce9a9520ee3436233d07ea4a51015ae352db57016334c7d23c010328bdaf3914e4580a2edc1e7b425c0c0e0906425ce78a89a22e6f03360be77cdc94d17ae8291c7262b754ab91547d26f2dbd61c4d97e62caeb32d2f9328e315f2ee3a7629088167a04f212754da51af359284d3b24deb9d509eb50603c04aaa2068da6cf2e9643cede69f5c5fa5d25b5de6884224d3935a98e9d0fcdbdc80b1016e4aa397db02531760a6b798e0643af39b67ed4ad4a486dc61f4992da96f999e716f4533a348eb53d8b391dde1f22c4dac6cb57186150abd0de4b1e0ebaec5a1a1c85dacd159a68e697f6527de515c1e28a63e9c2ebecd72ede5acee66f8e37a86a13b3c7a1031e7fcf89be29774d7d001054e999dc6320517dcbbb61724e2bc02a3064bf4ab86ec5610ff1e919c3a66f4aa4dede547ae8ae3689e16a33960c1aa2b7793cc0cb48172dc5a90085cf1237c8c2b365089523a65384011d4931d1a2afa4a2fb6260f80874159752b13f68cdb004c88286de30d8798fdf7b709bdde5e200cb1b362119682ef23e59a8e4edd3d4dfe2b884d6f83ab556774f5250160ed6ae2920707b9226b96305a207b5789e5fc1aa2619d687ecee46877672f07fa2b4d3c431bbfb679994eacf5e09dd0e1b8d4427045d3214f0876466b40bc3ef030fc0510a057acee211ea481bc8f90c873e8eeba497824753287e60b546c6c2d2135194bc82c62d4579ec779837e0ab30a696f0fed0c51c831d83526dbc0290213eaa14436ecb3e728909d557ba0a0eeb09852fa0183d9d2f8fcc1e07f4ac35d54202e4766a23057103f51421f1c4cd3043a41658e54da264398a242b67b5a1622cb92a978bfbdec962b4359f92c15a39543fb25888d9defa8f813f99555e9526d8bc5de33b1a6d096e11e25a63243daae6e6b2f99cae771fd17eb5419c7a8bc58e2581e8b60cb32483c2a20ad1db05a4075b296d23392c7b4a013625b267fdbee3d919f170b55918247bd72e4e46bf53a6c8a4fef27c409ce7d07a5cdaae65e10bb23bd6afb65c5352f7ce600d9010d4db3e0e4c76214e90e1471701721646c1d909bb6535a63c572e56380df9adc8a5f2026e62a7c3ed4ff0481bffb40e927e97142adcf197721cad79ffc06476d7fe0692b2c9c58a28d0c3120787bcac71060d68ea89c6315c33b8c859e512369b2c0ed39d6cdc04447c08a3c51aed8c50357ec58cdf2d697dcc0a870c573ca6dffd1c41f63814f79c7bf1e5be1cb9c6f54baa3c87b7a9c1db5db3ca0eeaab5c3f1de0ba454c54b39d5cf9a207290d52fa921f832a7309b4cc39e53288c0dea8015b8ff64a864035ffc608cd26fc7b1c491be0ada9316574540e2aee2109ff968205fc66d72688c76a827e7e244c674f8db03110ce78704cdb43adea286d0debe7cb9bd7593ce2bcc9baff9aa4bcf545d51cbdc1e753765392ecb0f6169293f05dc8320e3864bb356e1752c3699667fbb4fe45c48444069585005a88879406165a810f65b9a1cd1c85ed2618c1e6b4acce4466891395b0d95f7b75d0e7da6af3e6815d3e3a6d2c813f0405b56d652210f89ad74804eb627b309de28b6113261e6a3cb76ad26a49c15f1dbe2bab7a1fb23d5c371490fd57719307139c6491f5a12d71bba0e96df926deebdaf5a20d2b1305b1b975e69398b19948dc600fbe59c2734ee666b8279adddbdd82015c010d00fbb3bbf6a93f8fc76895ebb9d9d0f573b3f34026a7deb0f12f9ff5d40610d242c162d63b337c373f286097064fc35705816a31bebb0b200ca1a3555bc716f3b9c9285e81b1d8e1b22ccacfc4668b43a066ee44758e6bb3a62ac48eadc1c7321bb7a835b85d0af9b5d9db1b0602f25f09e69781569fb4f8432f66f67aa25f405c96f1833153642431aa9db6303bd379004eefcc86341fded28db6e1eb48a7629695ce73459d9e4efd7961c06101c44abc91a398672cc15333c6696ed709e9fd1794363bd5848193e846f0f796eb4006c0c0a3bde98c2451dbe1d53355ace660674ad17151af5e723e92e5bfc797d788ab1f0ea3f4f5d72ca3d731fe7af633cdaebedf4b837dc94866d3b68a954a1a346c94ff8405ba34581576c707ea28fe1d00f828d202fee84efc4229c918c4c282a897c975dde3a98904438859e559446b95ac3748f971aaadb1446764bf860c0743d31f0702f31fe9031ae564182363e876d10f6ada61b33368d4bf753a50415435995ca6b3ac560efd962203771c2bd30bd199f0547e747c7b275188e091aa5f24dd24ccfc8dfdb096b2c4567d63d2b7b75a565e639cb3d1a8dcc6be6b5f1713066d872862872116579157d350e3576a7e3636f1d8d9c9e34e84f56db5a334911e91996ba47d789b7d13605303a8bdfce97cc63d496d1175369fa5af6cef39df41c78dd3074507afe2565d55d7b001db9abe1b3d293491f5db445ff02ad7a8e33c60d18ad982beec01fa28b4e96e6f1377bb17430f970d649cace39d5fa2ec8caed365aaba396c71c2f2e9ae7b379d508b1089bf7ae21e5555e31f05eb985e163f6316b961ea0504aef1a51b4c711f8bc90748b2f88c04b8e96fc7d8dab885c3235ef4cae2502ce44bc57ee6cfffae48a98be858b6cfff8501674290e17d892fcfb885ff37b218640f1c76b4bdea4ce1b61cf5ab4e8d71ecf91037bd71388fe1cc80d852643dd0c15104aaedbad5fe85deb9bb1a42804d9c8cbc44b17f09aa523dbd2995c5f906ba5378e817da5f7f88eaaaea9cc7497ed1d307975fff44f5300d526b61ebfe03941bffb35ac5b3f2f733d1e9fb06021da9d7e35f53247f9c1b3e6b624c039e42934d476f0ce127807c8b39641e4d3f0bdb897763b4d4ab78754120d3e966e31d8daf63a564dc28997c50c48b87762261c43906d07c2b6b45103bcf4184b74ef989f8ff2b2d35eb8c116e5803bfcb65771424838800b2a753c4a7b794fe7fb8535317cb112b6f0200d345273503e3d93fefc457e2e37ff3923d0eed0fffa9eb5b3c6d80885a4136e0bbd753db9ef4eb2bb168e62b9544715f614c2b310ef5549b9d1e16ef201d5b88c4f6515f675e02a85b2c81c3eb2466f9e9e621a5c244a8395b8209186df929bf6a21cbb9ec1c3f9e955467566501120c2660c073d1c41d55d3d5eb7c4245e32888476cfb9796ab73be69fd2eaeae7244b266f8c454b1a91c0f78737834ff308be058a1a7cf5a4db73d29fef2ddac00e33016ea80015fcb170062b747992fc9d9daeb962b2a5663ca758fc1a6c5ba9cc84d32f2a6aec28cf1db36d084d4fa0dc87c5c053014a6580779240af04837b32f665ea4440314d2089a55a897fc774a7cafa66834820c2c9567ce44cacd181e139af2a69321b59bb803989f90cd70ce423b960e8c82a6a9211b1b852bc7368e3bedb118a608dd624b2d866ac9116c149107be03ab0c665064e4c7522538564e2d70da2943f58e54acaa8e05e6735b0255fd29de820e41efe0ff0a05cd03cdab6b699086a7b21c26134c5ca0599a71ec763c745e3ec77d2e92dfd24b1e2932df1d7e42eb452d86a8da666e8faea3a50e2b2bc7bebc8a99f085fcbed9ac05e9341beb5be2820d3d4e364eb7a22ef510a2a2d69552f267891494a0f5a7487f48ac228bc3d1d5f1a4bd8b7f54b1a6834768412512bc1b36a88162ab26649229c957c41e946d704a00412bd7e02684d83fee538556c0a7693b4e941242b2f11ee5e6258c4bcef9e45183af8b002150635ffe0918a8ffdf0016caddd226e6fd6fa7bc93d981cd4f22ba6aa6eed162ce7b44ffb74f34a4f93f62bdf76bb9c415190dfc9042b8f3cdd7816bd3c508d18eb72da10eac5d0a89ac4a41c7b96be1c462cc094fef3be528659f5b547f51ac3ddec0d21f817167c8b1505e1f6aa4ed6d6307d6eba1ff3e1c5b767e55241224e60e522b4f398f169c051a4b7c1d0f9f9297fcf90ae4e360b2311c6099bf72b8ec1d3a594f72f8d688901d6ce6d0e335a9769b54c74af62005bd9d40fc80abd4dcd5641045df0d0ad8288a2be9b2ae2b365f9cd174113e7dbaf952bc4794b9424a26ac9c6541a3a92439fa59c40a6a30f03b576d2193d9045117981b4046b4b67d0c89d49be0890bd314e54fbe931afcd91e6ac1c905fe2e6bf5abc3f7ce21674f1a8ce9dc85ca8291b45451d802cb5d2f0897f39a74149cfc9e5e4c92f6626f14971819a82bb7a4614bf6f97f7766a1d4e9122aaafd1142bc4feb684ce9c057765640fd8d260a11bfead3a4a7e685e6c8924067dd6ce7965f571150f5f66c01473c1e0da12dfd6a0b8b8946b1f77fa9f1675bb62fdca4537cc887a74394f10a86f63e424b3f059f6fc222435e4ae4b4dea5bdc3d6328c51d0a07e42cae1c888e2bfbaed2ddbad863f3ced3aaf6e3b809c3f36531f63e50ff786e96cdc5351c06b4b552587de86ee33d9e4a366a7b88ced6f26827fd6ab9bdf2d017297cf32d24b7e5e8d4dfba8fb9d25d2541af703bc57260149256c195f232e98f82259c01757738b3c191106a48e44460fd1456465ac4300d60638301447d73da0f1ebecc5951653cca21e21b6a8ed73aa6a9e019786cc2acdd0d86a40d88acbdae3b09b17ae65e8518b38fd68b1b2a6ea1b490f9016fdc35164f1e5eaff25a8acb9ee868fe9fa2fce44caf1a8ca26934133268320dbb45062264e1534a282c0e4c10e1f09c95bcba5f846911440521d3e4112528b510587e651a89fae7821b53136cba91f26c2aeac63c59d7d1b47cf9bc2a1025b8f61f8845b4d2b088534f4f4776cbcfbf324f756b517e14cbe02ae106d2bc3aadf60e6be16e47db3c7304918ae487a5b607c8dcdea59e284a1ef03bdf2343ab49223c5da9feb045ce5136d26c39107f8b184025289583cecd501cc98d81dc3cf9c6065ec380e7621f8d45ae8afc305611ee69d848204f3e503a7114765b64248260cb67bc08d754cf71cd3a5b8ba0f63e7cb0e875ff6bf671c64d42200cc47c9ced08bf1e54a9b6ea59c0424ec3cad0d99a5c543b3854f46ef80bba0958e1275c36a8191310a4b1d81245b0dc18307a23875a33a85d4300adccda157296572ec0ffc18ee266168c9cc9574d3fa9cd27a19ad4002d8d5da2b50e22a06ae0f1a0e7f0efedbe6aed16279ac3954e5cbf539ec2dccc7b204516198b245ebfbee6614d5a0a1f20d762e1c26abb6216b553c704e6eb688cf00b20d088915de5fbf3579ccf51ae188dd20e1524758ca804d28076644f191c2d91daab7cf32d2aba32ecfcaaec84bf59b5d6444f6cbfe7aacf2e4dec1f563761d9ea9589f9bc2b597c637e964ca4540fb9502ebb59a545bbe79a7517ed88f64af2c1e0df1da970008361d5d28b78742e4f33fe98814d4f87d3605a462fdb14df2dd5c4bb469202a5e731ae654626fe2505eb0fdfe1296f7ad867537aff43e7cc81fa2a00941554dc86eb5f0cb7c509dccad004dad541899c015cf8871c9b83e91047010f5635a72d0de170d309ebc4f124ad96a509fee79d07ee58bb33a9321a2d0b0348bd3c9370955cf4e718b745b6658137b91b9abe4582f9cd1f58e520c9410017c084f08d9724ae1b4645516ce56a8b10548cb5f698ef12ac383ad22b30e566ddb0886c1e6aa1e01349b87a1ecde0c76112c5921e222a26e55500bca05c4c89e3d44e19e8edfd0aeff4b87c63d18f1b573a16d0d9ddc1ffec1ccb4df2b38eeaecd5a834d8aac2bfb672fca93518c09d05b0883668694a396dceac3554d5e1c23cce4ef9e5179ad830e6df3ef0d08394da584a87e990af76dd0bce7d1a33f2c377d2919c8be0376170453887f628bf893b0e5c0014588d0d87399955ddfa4d6c62e115bda67651ec16bb63495839f20eedd3511f7fc797700506576695890adc06356f90ca428d60a1f54c51113d5914feb86aa8aa37538dd6bac8fb955feda610d268acf8f8036ad9d9c3310663d7080c28c21872cda1e9848a9d6fc207995a6b4f4338020c9417d831cbc781403066f11f331c77dd3549fc708f311c9e5f87be556e7118129900510e0a0a20d3c4598861811b5bee7e6a6c874eff4e6e45993a99a5f65eb8f9d3f48754a2a45230e480481e5c24a5380af2873fd639cbbf55632bc5c84466933c055c0c9bda74dbd4d2541c89e6790591b2ec88f49c0128c3bd92571845c2cf5d6350f1b4c8c083d2e1743620ca80f7cbba7919a7724446499d1680188df5a5aab40a464173e2a1c5301fd7ef469c61e4e6b7f36bfda0db393544b4a66198acd3b235fa58610790b5e5439826d1e994ae4cc60cca9669decd6ac1acd128371961ef07efc58fc14c1b125ccf3b91e5e1851f973c9c8d59e1b57567e1c9341d3c50f8c0aada23297b9b96d527d906260dd29dc6ed3aea114948dcdb99ca58e85a917bd870b3f0975009ff5e8318f3afe6e10a548e295f84f4f7979a6c7056809b316a3aa630ac76f66403e7e41f0f572376c70538481e8e97d0e7b6ea65c700b98e7834acb8c3170ab513ceae48518ca55b43cefd3ecde540290099a3794c270913710ffefbbd91a15aac54deab8200c28400016a2579d334b5b21b20f18ee3acf87fff8e32ce7ee3666575ce9b05a2af71ff3b26fc53a67e9b179a62c74829547405c17475ddbd77f0c1ea1e09462f71b207017c34cc2ca12561ca4e5f4785d8666fb457a2eef5aba8c9f59b0d57e04cf00dc9a32382775d1bf4c67611bbaada0f458bbadd79edcfd77142e34463b788b547f8e5e5578ac1aa83dd7ecdc37b11d808dacec9f87f22a9707ffd91f967cd3eec281a556e61d8f31876d6b39b18b938b01c73e394081210602d088b5ed58b4e9b92164cc9d9574aa49c64169036cf73ae7994e99b301db1f61bbe8173846e955d1441eb94fb0d0873568f1ef131f2f4179b0b2ac0c462f33164cfd2be046eb8a3692c9e8551cd5faadc64adf280a836d42bbb942c0516f12724816d4e72a7c16b542774ef88a49abe3ceea3607e90250c71a553acbabe69e2bff2dbc6fc768abcecbe1a352c78d3c46f3f825bcad9e46acaf8c6de528db98988d7d787aed97137d0fc0582e176c924666cfa6211fee7f9c86d9d58377cc6cbe36111b7b43ce5ab940444ef","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
