<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0abe72c8d9179d82089f1493cfb6c0743ff82aab2e82685500873668bb8e1336e6ff53c490a5df60f0b136f5b984250e3f783b3bcb6986b82b50b11ae33676d5946834585cd7e404fe08715148779f595ff2848908598515c0194c4e872d555b0db256fe3ea7567d1ba8c93477f6a739c31c73afb0edb99cff5b5c9d4bd90b740e3d3e2bef8c958ef552b5fcd18570a189afffecd2398c9613b99ff954059888a408305304c478f3ae172248efbd299c5a37c279f8af1f53b4164dc6dfde512e49e16ecdb527a17597303e33e89290fdeb3b609e95c279f5e4dcc96917673493bf64e80adfd1a2761acd7126d67ce98be2af2e4ade1519861b6320f650f1517fab68eb2131b2dca2b02558c577068d4142f38759b452b54cd58daa8ae06df47cd7e125e91d05195be2731ad48b7c2e3285b878f381ef107713dbaa3a4cfbcc9ca2b219f14a684edfab1a60e560a32b49daa7faf8dc538a698a787f8a203673ec63ee31d3f3778778e8dcc98054fb3b3295d5448e81de5b2c59a61db8f23d7b29f20fbee991e976883ccda9f32718668a878e9a29fc63742afbd98e8f06687319da83dd59d27876e38b243167ffd3c7d79aec1992f300e8c1e5024227b057c447ba6718cf429fb104a35d58b6eb9e88fe6de7143c5e0b48513a344ea5ac7bbf93d084517b6e1168722370ddfcce07bdf20ed3864ba8666ae90e27f43d497acd0dfa9e10e0fac75cd9adc85651b76952355bee71309f70d6dc1f6deb79d5a6f238dcc5019dbc18a9f4536252fe8d406c7f7437b46320a8794236fd99cb6a92e42875d66120232fdc4f648ae72910fb3690e532917172c86e050f46de95764814881d4d1fb8fae9130915ce463876db86f88f83c90d14ef598bf6b1324c335b39c14c16320007c317c014e2e66513ea33452c36b22ea8b329c3202138a12e7d432c17178c7ba45aed9c6b8e64439715e2ceabe2f525624c91b33a693ddb428cc8b8ba146d1f6403cedc265630ea1f561defe23f6d2cd618a06727306cf8c3fed45443cd1efa9ebac101868a4149ad8350c72df671645e4cf592ecb1c982b4304589ccdecd91f7ee628250fdd5eda90e892935ab478cc4e77dd8f9ad981927e5714b304ff15965a44b258354f3f182d5b1e5c09466369e2b5b475625f090cdbe5d7ba0a4cc1da07dfeae2d9323b02397a1cf07b64b0b0b959702d29572b247985fee23099278540bcb44d9f811533a734128d1dc7cef88e069976da96c5cf774f9e85e511957ae5aac3c4b07af03eada810fcc7ba3337b5df76e40e4e9ba4191141cdd81d99fb2fbf7677ae73ee01ccda234412d5f2312d9d18b8729c11e342a9096a92228310c3e5bb8cb5cbd892e16e5b94c0ce1ba2edbfb3676391bd7f798ed9922a4a348ae19dfd45015704035acdcc29a6e301fd44ff0e8919da9bd3025dd8ed7e0208dbd1d510879e5f21f31b30dfcf54de7b8a1307ca717aca90072691076031748578efa62a443cdc69569310f335d42ad23b6622b2724748ade4d3d8926003abfc476e1c5f483f20120203ead73d2c9fa9228312235b4a7441fe51c0b44c54038b6b9af165258aef002b8e468cc6695845c9a6f986ab837e01ca55f7b55d1e607a3082c88322793a5823961c4e54d311c184c8c264e8f10fd70f4f7e8efbde1a06fdbe1e899fdf1c3ca820e2e4812e8d148aa9e316117eb5d8e71875bf83590450cd41257e4d3b1bb0be4e5af3b7b4dce2f833dd769eae4def466f73823fca2a90b286b964ab69bcc6b8c6c9a7daccfa664ad4f6e514c2bc9b65fdab2a322fb24b223bb461ca2ae5333e928809f37d5609966ee400bed1895568dc39477523f7da5a68dd14b51a623ff6a37ed92b894e8d483cc440656bef376cbd65c1881414f12207f2df9369997fabdc325305ac5f9863e3ef25ded0a93eb4125e2f68bcb75124eb1548ffcc08249b5e048d4595975c5a0318e7f638bab64946d6a7c08167d6bcc897b12934d63d80b47755d3798990bc85e845034582e411a3a099676dc1e0c4599188d5ba0c03833d3237176f5ab6c9d3a9c79cd46b93457ab6fa4b935ce64f058bb0d260fbea020586f7b34c8532174314ca712242f23fd20bbffee4cdc8b3b2d8088d35133a6f20a75386f0266fb37a546b4cb732555fda02303aa8f93fa93c4b027cbb4517295198a1e5195b4fd4e203120ca9b8ad73523da036231426072ceb404aae50dab43dc71c3609d6be384466c3067bda352229e8a285add0414be731e89826782c5049bfaf852a9b6a05ec6f8550fd78d1101ff327132cf4bd36ad91b12287177d6305f5900dd4289ddb6d2801b0e22f963a920a964c668008a35fda2fd7ac1acae139d8c2d36ca68bdd846f9977646f4c3941ebc05813e8664cca0945caf3bdd1108cabc14eb16867d1072b596f4d0ab8ebe2795ead262c09341a6a759e6881ef39caedb9d7b545fcada7c0b4f763c782d0d88ba8d048cb2007011817a916fa6d42b7fd9fb8a7ba835dc851e998216884834603b572bb4826f96ef2a925ee726601349c7b0b38341a89661e1eba8f57bdcf59b5ad058b28d9af87ff70cde71ab02e016cbb2f466514b41cc4713485d8298fc6235ab2cafdc13d00447b07cc9e37365936dfe3f2c9e0c992be830f83aae916af2204e305145dba696090747ee3d2f7ff7edc92be7783c6be6e53eda5d737dc05bc4004ee843af1bf62a8927fa76069835bd915699d900b0060ee05076a21d72b8bc4a253fdf529db390593ddd286ae450373e6f629c7fe500663a4f7d00fff16647e1445679fc484a68d2c1c6134c74fd23c05900ea7ef5b80c501485d94d9f1c89c78bb3f5adf34b5fedd5f2d8ee9c48e1a95a844afc6c925c3261fc99f074be1d09f0a892bb4ebb5d2d16755b1be54e62e1a4ce34c7d10df405904b04f20b4e6846f9e9fc494f3f3d83ea38d0cb9e7133daa7f9997a9bfe7b808c0d27d1cb9cc5b759fa09b117149becc9ea454c4f27aea4a8643e05bb61003d9ff915d6d60c9a79c78e40bfdb435bf681930e5d9c5f695e80b9dc92218ee253cfc720c4700c7b3ad96dc13931a0ee8e0fc2490b147662bccf291298059041817843896970022c5bb17110a9ef4f92eb1e286544153252221822c3be114511e01726ba75af20887d772f624eaa38301bb5b2bfe2f8e9b3478ea6a798aa1171c96cefba3ddd6b14108e100d37eba000994f1db52e0fd19794263e81205b33126156b384c782ef93b257363bd44b1bb088525d017e6c2f1149a6f3b9fb695c5379ebbed4fb15a219dcb3a664399ae2dfcd661cc46e32694ce30da6cec8d824f0621a49f35fe695a8fdb23e0eb236abc2a40473c4f2e66630c8ef940e7b7f92b8c417cabc1f94206c221ac57413ab9b4a163429cf6ec33b797134c7f75d2afa5810ab623da97525bd486d86bc4452cde763bab00f77686a0ac4af7e7c265aad915d6ba931daadf4e19fc261502737724bf472d3ffe330a6c814e16e5421ca0335fad7a3a729b203caa89b8c1fb140881665043f1e22d629b0548864632465d7701ec5cd3debb16d7d0d7866fd8af482e8946509fea02016d96f2b96c802609886efe0b712c607edb31dd007be87bb68da2879cc9b0f049b0a0fd713eb33f1792079bc30372a199c749809cf05b104e812057238ce8bc82a36b417b085b80045d00efc19d70605f9336d75da677c2a500b67e443eef3de928eee213de805af741a6deb41781250739c79f3baab16e1d21a07f716be24d81bd5bddb1534a9ac427461bd6b83b10c1dce37f507bb057dd55f8dba986a26da58c58c176fc29f3d271aaab1ff10b4e92ef8c948a7695396ba12ca487e445b3c80ebdbf09a5042a36b254d393599a36f0d04953e59e668313b6e6baf247971113b4ee0e844ba62dd9e74a27dab5b405bcdc1306e9ecfa96fff95559673242fc55b87093ccf323346e24215221565952662b7fc1cfa2484a0da6cc3c0d711b2cf5bdf0f2c069adb8959177ac52bb617c4d942d6b843642cdc2840ce8df551b66bbaf503fc808d0d8d68152593e469933f7b42519295f333c0ac403f1233d0a59fbc50339147d678af4cc276ba7c7f29a229cc078d90ac052ff93001435a8d4f29e3047c2156b639fbf55ceef10285bd97d4ec13535f1a45a27e0a9bc792fd3a23eca165b4b3cf95ce7c6d3a3ca494683512f6dfd12caec8de224ac673d5b8e4974f52fe2e2dab8ab2479a6acb6d5956d026c5b479727692cc581a22aab77e5e9d35ff29d68e29f14fda3a6142808b4a6c0188b71972d0164f6030214680eb7431949165233546e647269dd15e9c61d8d2ec59c6533f5b337dedb98492fc7affc5c7d39c0d6e21495b106b210b219634dacdce792a2adac275f151f1d6a3e902420feb72beef7c579bcae7489fef9e6bffd2abf5b8110aea389aa76ee775a9873b5387ef8586f2e39665cfe58fa7f8d48aeadc19cbc659d61ed887501f2a51daa8ea6db1fced5429326238958472329b33735ab962965579b70cfa4e8317bc713bbb8ae092112a88d6337f819c24a7fc4783b3bb2a1b588ea3ce26e71955a286a6e10088a9d57daeb44b2a4c7b5ddce2e6531bdbaeb751e867eb2739ef484e06778a54d580cffcfb2c62bd28149f47a21fcc8edc8dbf21504a8f9358ee60d6b9da23e623dd34d6fea1db2bf28b7c9f918de036603cb3801a122c052945dcc70541600e2e2bceadcda37a114079368f132304794616e355f67b9045bb86117cc2c028792662c4c0eed5f20768699d0e3b59a60ab01abdf3c4f0c3626e7d665037a289b81ae59a8dce9a7add10e7d1a24c1fac56d13775f825072b511ed9aad687b4acefbff591ee02bef9cff0209b7271c71c0acc6d676637510ad12f4564b377b0e24524d16035be09f000f59706f5d68a60693934c0164a16c61f8436dbbe174b31f1e2eef1a61ee46130b11796fd0df3f9da1a491f11201175077d6efc2ddb692c4e10d7968638e60b5d5eccf9c349c015e1daf20bce89b40a93e2715dc2bb98f8f6ad0b4c9fb1783d8bb7329a0b7535905af856fc28af98433fd761c907837f6f0a70994482ab4c20366da1e0337f7a374f7f103e3bae44c1a8b91db5df7d570fc261e389e98a0b31f1ec2369cbc36bef23d025911f15199a0239cdc57579d33ed691acd93d23d77ea3652b1bd97a6ad92a17fb544c6c827eb2eee6b34cf3d088897977d31ed6c52590983b9cbde8b42196552446f1253cd5dd7600d4d78e03d263d6f2c889e6e59c19428aabe0ee145bd99ccb328cc0fc4aeb0c11de9b4b307a432f3838a8388485eb6edf887f3292d39f4c886c5312b0327419450b0f39e4f712aaab057f83fa60889bdb4e8d507c5290a36b05a844d596137d8bf34958b9c7aec560f8982f0b33066ec5f9971fe7c9942ab25f282ddbf029a285ef61bc1ed448f7445eb6e8c0d98af6116ac34191eb2eec7d14e3cc769cb738ad2397b60b0e46c2912dddacc51ebbcfd93ed78625b4f2911c0a643825d0832a57de6937aec4a9dd1acf77e2d35ff0f637a00def1c9574e0bed07aecc202939476168d7d7a8162d9771a6ce5d2cf3778643896d58f407c1a1ac78a3d3afe2279aa0907fc50e27a089206ba46cc383dbf99bac639c224cc8b428ee7afd048dc5091ee166dc9f4e9f4e53d08ee0a90621b5b3e558458fce56f474c3242ce7cd665484c470d27bc3f956a676d28015c23930d3901448489cb3e5ceb495070a72b6e00a599412c26b552db9fc554e309b862b76c3c3dab8a7fea32f30674a9b33f8d274a81faed0496aad071a7a9f3c779a0afd609ac6e1eea4d77ffcfd08a0af90cd99171a93cea28ad73d2f3da293e23193ee28b4a2a044621b04bf2e6fdd5d4509191ec0550fe09a79098a702bf61b86446b04ee203bd3ced4b36a5b466b3705a323d04ebda9d39f35b78416fe2c816f01eb201cb8f87e892e6abb0a3000c0425eb676e8a1736c629d6a781345c0097adf555f579ba084bade63c001b7b75fbf3a63cd16d15c2f6412827c15430fe85e4e6644c4ee273bb90a51269a5edd4380a018ca136949aacb18c5f3af494c6c87e7c33a08023860af7b8aeac479232379c38aff2749eadf45ef30038bd51b6d7a847e02be1026b37c325369a4583de2e85ef66660450bf9186688ba8150b4f79ed0a7857fbf59f2b2563b87ac99ac4a75f25e0ea666bea67a1fa989e3274eff0e3c7b24a4248ce5ec1309d4d2393172802878840e2bd2e76acf21777b1afa859624fed496c603b098e64313c9910ab17a6c5f599edaaaea2fb90a05d48efbcf279f5842a71c7a64cae895b0e21688fe806777fd259e79aeed9702e61650f983d02c1c40e1de42e05e7e1d20fc9c7288d916d945159c536aa71a0b4d2d752c5689c49c7a853618b3d496fc301dae0ab3fd361e6961b6aa8aa3752ce2bd713de176b54d154f3dd0878364a4dc64e07510162ff4947342710bbbf88c1b70e95a9c4164085789316bc704d99539e98c888f662283291d2d2c65d4203900a09eafb67ad2d6d370fd0cd9c82ca7fc972fbc6a8666cf84b6d8adf29348720ca4e8c5c03662261c55ae4baa1810f75aa21502ac7fb3a3495466d7134e2287bd2e3098414b87e82b3d645ebfe166a3f0e595abbdc59b911c7f9369d5cd17d6ef753c906ceb6d33086109bd45f4df66363deb4e64911d4e46879ef7f6e910305521e4e6994b7a535d6e8558aace8da7971778b358f5202149eeea6af85e99bd2b5c016a13b92e70bd242c43a0f30200fefe66bd85ac693cc8d78b0516b874d6799ded282560174072128393ee940de1d164bbebc29cac8ba0837c559203167de0e4dda5c59cf0054383812c673e9ef40201236168cf1ea9ccda60958dac084e6c87564ab0175242b021137a030958b9633b987284d9977e788f6e9a3bad43f28fb4393d20b331a55bbcca4e43d834dee0d6d719165d58e6399306758fa69bc97f38532d94a1306cc7227266abb02f107e56fd024283640a2da924a10f2c9794aa658eb54002ecebb3769eed2845ecb14e72585f5bd1165e5363c709f8767eaaa4c2be2dce9b658900e7f21f526d8d4ee347c3b81e668cb2a81716a23a98b4867a2c164a92249287c9d22858900d25f7c878136ad3c3d94956c02f0bc8a60f60a30399393c21dfa0a6bfa6f30cb5d232def69d51f6ee3671030664ade62d0090fe99bee610b92169f727a9115add707500dae108403ad4e6a941f10fcdfeaac73247eb8e05db7f1925e6404f464dcf95c1c9acb2b1458ca7d36cf7430f1dacb6c171f6be9a3be7968e93bffc76f833ee05de27d88ab6eadfbe865482f4b2e30ab822b2d32f24f2e7847fb915f74bdce6730ac808b958d5fceee3ed6e29e016b6cb9cc3bd8f50dda4f1a0c08d032c68440bd53a57ef3b8552e94783116f0890c8b43c63d32b710ee51749643f5db936f2c25e09eb3a56512717154f4447103a1310687a43bdbe9f2edfb0be954622b12d434ab3a98fe7303eeb5bbe8947bd9b3d4c1adacf8dadcfb9a7b193f4796a87832d9c639dc15cf3ca3840400411994cddd4f2f3710b119a84ce79e2d2ee9af2a9ab3d3941c446b654a284a457a9b77f530a02158ea0f2487687ba6a1591547e320fa3cf30244a3514d01410bb6a0c8822ef634d7a0c625cec4913fd5d87f50a75b13be07c1f3bb8bec1665118c3766fdd5685d4f417a98ef7a4169f398ca254047b2a60ec80f519eabe182771081442e50d29b471a2b407b52efeedd8aed30876e3539e4e4c0f4fd3234ea69855b0b4b58ae32e26792afa6e5cf5c60a9014ad04ca7051fb39e97b5826a656cc2d05948564ed3896c97752a36f057a247acb1f2894daa6d55013ba9dc595213287996c5a7e7ef09da983747925cc9a4c85fb291dfe8bc5d1562e0c8736aacaa285ef36c3cff2b19458a871cc75c6464807fcc7dc1c411ffe4a34b2b3c3c2c5c1cd93b9979f871eae76863727363ee2babec950feee0d0a2e739a3000b9c2a4867eb8df16bac6d68a3950d56fc189321fbec38424ae630c997d924b5b6da70fcd42f699c02e1ef2ee4be6aaf64e63bf5933dc568bdc56a89abc6700a2b6ac0d62cc8cba9a014ee3caeb67d75485c4757f2c10b8322383d6dc6d36de8b26c3667de06c72be8f36b4609db4e0150bb89056b8bd17e13045116f694b3de73946127cbb660d1018f1c581dab4db6813ef4f451a421eeaf0ff7ea601a74ba14831499727cfef0bbcd87602c3cfb187cdcbf50955f46681bdbbdfe5a22b4427c5279b191fc4ac11f93d806100a2ee4abcbb7733abdfa0fd5e56cbfb56184b62ab5ef0b2be6f8d4b7077df061ab57f2d44f8cb453ddfdc5123ddcf0e09904045f864ea3b65f50cb9f7d603e442767a6dfd1b2a2cca4c6efaeb59b6b202b46d31eff7ba818dbad8e0507c4fb7c66c00d72e5e31d1ca2b27e7fdc055ad8cd10c0ba325c4a1bd7c4b7a08339eff597bb40a0b13da11c7a272f0e248afd4894346b57fa070605d3679654d9556a24d0877d4faa54a359c37d9e256763757184b85d3efea8e5fb5b077077cf66125c593e19d116699e91cd3c4487154558b29d82fa62c707cce3c1ad9b9ae8519058ba75f2a54e08cf281ff6b7778c22532f997b8356b2a71e2e0b56855d427c2b225dd15d163687c9a6f1dc4950225be90783df53d0e2c3aae69fd0f7ebb61c5ec3c605551fe849d2d15c643f8de3829886a2d17b8cccf4ebb2688702a399f318e1b31396c05bfa8538e890ae3860d8f1e201a7b530c6c687b288e9eb4abb38c3690e87e84a29f3eeceb3a3a00c3199a58935817c9ef3db532cd48db5e9dd4e578830272284aa58e175d848bf6ffa17e9c931c1998ff7c9af797b908c7e99b2c49a44dbfef05a7d9321bf6ef3680f5d6db470ab955335a66dac4204b2221340c0970538657fa37adb734b1cbbcb4f027c7f8f471306b9ef50bee27e0f02bca6cecb77b2eb3fcd5dfe3ceaeab98c0d9f10b04c2b2e724fce41ea6dfd3c0d85a15cb12b1192d667f3f242f768d84158748e81487c93fb2cb52804b4bbdd0d76873b2ec537a23a81c2bae2c756ba72005e7109d09b8d0081d4ed69f2603708d8e301128c794050a9b26abf34ae09bfdff60af7368c4cb4ed5462741b93bca0846b38bf3329e2edf872fef4ecda5fefd2b858cde743bf5def74254623ee3fb3c09cf2d01729a00547a69df0853bad2941fc47570c42d03cacbcf5b21755e078ae5d9087827e60d40a78fb7c4ee75a697a1ec805a3205fa77d36af0649754e96322455c4946defa4d987d5bf597772b1ebd905a10f45a0824b3383cdda2ffccc8ac0c1e334a13ff4590383af2bc6b23d2fd9a0cfc54ec321517b2299f2f9ecaf2c99d16b9037949dc52d5543cd827c747729dcce00a4a4cbc7c88e3fb64df74f307cd54f964ba10c21e226b7741ec70eabb08f82d7a4a869bbc959eb257ff2c2562fd860d1310e923a6a195374e5a07d3cfdabda1ec317e163be53e4887878ad05abe6581a0240ee809553a26c280140a31c638d6e5f76bb796171fb33b26e4dec1266b56bec15ec00dbbe24281b21629ac6fbc6d5398807d152ed7f4f91c954de5731b0784f2e06336595e2855335b0405fd5823ca26debacef984a49ccd46c81517f96f29e32e50231782827b4d53e7a6f1e2b041aaaa876731978c107745fff06139ee13a454e83b2dd0cb17a4a6b803725a2195b3934d8da6f0c8e596cf256b5446f3ef8eb357eb28b1b8032b30499beb4e57fc50b7e753df242bcd496281a3f50226a03c2428f7f2c7ca5c27d16b5438d57ad1452d49281fa53ecc443215001283ddcd8ebd261861f7bc38519a6f83dc73cc3d5c9a73d2f40581f95b4efc533af6c7b97659cc61c4defb2f4ce1630a4b044025b560c8cfcd00c1d4a63b44d4de6528fe9f88483f61f4752e5c7affa8b2dee8aa730f306898d513b9f1c02a074f6162db87257a6e0e0c2444c7af18c4660ae1c1264068c0a565dc5f0af1f1fe31ab29ff742e4029d024528ce","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
