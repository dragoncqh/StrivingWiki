<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"20b88dfcf193c585e320dcab1fa4a671d53c8e22c2bdcb5090cc9b684b0677af2cc72507dad4c55d83b2cfa0fb1530f75b7d12123b33732a7352b0ba7dda3b80e0d723fad3e6b0c26979f7dc4c5c1cb24d14a9a35e37272a16679957e2106ad682ad2b60d4cf91296533e662df5cb5d8b04a2c6977d8814c3834aa3355013cb1c27b6771260efddf2c943ae4962ac31c3a1bbd742081b95d7925fda1638be24782015e3e194a3414245beec1db285446e1623bb06af7c57e20cf449347bb34e5faa9104e820524c7a8f19ca04258ce7cb8ad5e98d9460dd28cbb1d8a84682244a90a28cdf94e2d591856184bf0f0978a60335becb7e52b7015a7e528ca03c30a4b92143bceead9f6da38f73cdd03321f2acbb1dac6194aa17c32b0f6cb967f0abb02fe259c01574caa3c655933942547e37cc9daf854b9ef407c00f6a5f69cd958023d94eae32675a9f80670d57f34cab4fcd390fa476359b9e2962857336444908395a9b05887fed91607793164d41aa7bc6ba6d2ff4df9396013f412ead9685b88c1a1cc3bebab9f449cb1c5de7d824794b76baab26d1d092c51c9ac74f33fc67003ee3bc1ba5006321a519d6cfb33301613a5317244ff487cae91d3304a27c48ffe85837a1836b8e57c46596035af41ef0a384cd0d0ea18c9821e43d79bc85a4e480a1c89b3d34d116a0c83ac35ed0dbf8867451d312e4ac36f57aa66c2712f45240e5f9174117481e62862631ab6c7574e62020e41b48230414d5c9692c983bc3f90f8b1922bf6d5368d4286c0e44feea039105df7ed4161e1bc61f4302f26969eafa372a562b6b192485c67f045be803f1eefd1ba998b7edefe3b9479fabbe25ff5f9a65d3ae392cd641bd0d3cfdd35603a0cacff88d594415258741942cabfea22e33c1c4431d7e7a66651283def9ab47e57d5fbecb51177fef931c8f3d89b5cc41ab9ffb524f0818a957ec099283f9aef8ed9ffa29e3c8c1e2e731979bfc4fe061f19a78f9cbf014f93c563b3c478a26f206997c70b776a335a35e82dda40592a04dcd1d3db9f2efbeb2ff1f79a4b2ff2f4f3d2325122bfb6936f15e60a6aae6ecd05337ff573d2cf9bd1d233f554ae4448df30523cd8cb1422c40bd6bd5fecc1d999fc4fd1b298508c4d35987800f61f0ca98edd69e535d0b37e2cc52eaa2c3f5b07aa7f667feceb1734e8f069e400c83bb5f3740b3b491d45259c846f84373728d3ca5e327493fbd0623d888dd48c20900ac3013344ea54cad849b8e183195a89a2e7e5526232309adbf3a6679715ce51533be128996dd26b713a19fde4268eeff735a07283c565e83bbe8b1cdaf4a002b7502e911cfb951bea92f490c103d48169478810fca3572edf9035c2857f0746c87efc52dfb4b0b36ebc0e996c1eb8ded1e2ab2e356fbb96a9a133f313d8eb740d2a562c0d92530db15d1c83f553de073dc86e4a7d66a4fbbe75d26e2bc42da53fb39102fcc9558e78da6e646a786493a4240638556dd1f1d5b91f84aa71865e192ca8e5c4b2ef72a905da7a252ec652102ba5e8aae69ea40537e85eb4fb49cf8f7082c0232ec42de08bbaba74e3e8aa16f35a10f482e75c119da315d6e858302a06822e89775fe9b7ac2dba9dab4902b7e0abdb6437fd8683d1807b44649d994c6fef613561c0157d663873608753df3fe7620f6f515e0a9d14a3e19e9dd93b0f9133dc7d37382b351ce130b3ed87e5a85fdcb551cebe659e83ad4d43e48405aa3bce480bb5afb763250efce865a52e10e8bffc02bc3d063ff39298e65f215721e37061fd13f0eaa3c4cfa530caab0c90f87a24eb410f77055f2067102788f8d6c10fcbdf8d04dd57e4ace903177ad2d27431cbaec98a0e48cdfd918862766dd2b0285a1f127fb70edf756c538ffcae803920e3087bd0c5f6fa39e244aa6643d03b809af6a5c41709cea2c11f69e2213b6e6850f4c8e8f7b0f33b64ac3217a118a5d02abab01248c671cfd2cc3f184d1152827d70cbefd94fcb3cac29792b4b553d00751690666949da501d845ca49de70575fda3944a96a78022c36e63a057ee6f8c7659c6368dedf3ee02d1b336c67d5c4f847d4a6f63ed2248392db08a890eb939dc2d3b18eff69f22347faf95b50e99a0d7d2116c0ca48a02455ee2d62673b0809823e2b86e54c9d8b5c243212d816d8a4ab8a8d7f4d46b3e698d884e20c4dc860706ab7b292297b7fdd108309a1634c3f1faccc1bea7a95b7e4cabe957124c35c2d2f0667d03d8378c8cd6d8090f9b0f4336604fe24d0aa4a3cfce460ab61e87b709f3a9efaf82d7e3324cf92bd113471dd55150844426f9fcce8ada426e5db7365e32feedc16e79a4db9625eed9028b51b6b0ca12bea25fbabfa567ef090f5bff8b57633bec38d98b8bfd1254a0e961ae2028672987bfab60c7eeea784874d9b75dc1161e218acea3ebd39e837cc257131faafccbd3750656f6f4106dc54dee72c270697186f7de13b37e8f44fba45d28fdda47f33afa9adc2f181955fb0824c9eb5e0ee72e5cc3338a725a8df320eecd761b248528971e3485d8bdb617d405bf6b178a295861a7baeabc0db9f26c7b6e76ff5dd740cee6d483764cb89260339d102842f40df21c618358e416e478f790530004b97c95e8a25c44f18dbe4963f0fcd6781b8cbd2b31d4134bd457aa379603b6b549fd220d735ca24e93b4b3310cdd123dfa0e23daceed96ac8519e9af611a15ee035658bc6d40c79968e9a23e8dbcdafda0badfe6d5db48249f6b2b829b3b30d3c4a342972be404c21927fd6fa86b71825105cae1c760fc6b9957c7dda7e3ec8c4e4b2f96708e82b3709390be37a2da33c3770dc93d5dc694f3e45aa108d204aee10a7f6e66bd40b834c060aecb52e10b3866f6c5049f14cd719e1ac4ca31c5f687a6c4cc6e0e95e5075ec7917a95d1ce755a063fbb3005208bbbeffe0323ffeaf8198cef7c9a02a13e74d0d8d1c6c4f527a983a05af9e3cef355778078ac198ece9b909cedc6bb8f82cb9605f2e011c1191bc6fa6d38d0278d277dbe09438146bef52e9cbd3fbac9763b8eb27be383cb22e946cca2b9738a4b4c8d77a0be6548aeca7ad55033a96baf2b369902394a1e47036c7b5ad58d8531f5ea8832cac1dffff6ec6e8fc2ea56061fdedcc49324ead39dad93a5bc293d30a75fcee6af3caddd077cf761b563bb78f90c79e2829a005f3a6be39ea4c9533ed9aeeb9a5eaa6aaf4c73fb1f3317898655980305e6fb4047a8379c36e22dbd49c18fa3a5c54c4e8a6b276707f1953570ecc1a642dda4d135f2125a2f0e42170d01fa367b6a205db96699b5ab39c593362f141211a6e9d74832f18a875adad65c7f2a3e88ee2143c705886ab67f8eaf558f23b27f3152932f21f33a0da33a4dfcf17ecb3eea004cd77a4eb98dfc0452d2d031567d2e394a09ae49a2b426bf94d756e619e42430959be0e098202eeb9c799a596e60b989c6c932a9e11a68d74c8b4e268901e248e7dd48edfd6d2c29bb7bc4abc9ea3c641817559d88ff982953496a3fa1908c22b1f06af7566fcd572d591bc3ce56f8ffbaf8cd64c0036ee426b720386b20c067bbb9e657f74fa3ded88e673a5eaebdf02633f33be4c46e70e5519cc3f90715064436dd5ca807436e66c356bbd2742dec50f0250f73d8e06a7fc80c4da62d7245232626926a7c66eb3362e1c7f2d3d9f0117e10a10e322c5900f9f5147cb49e68dc959a8f0760c656c8c6d7bd22bcce6c9c2af92ba3936d51b36826966c865ad446bec8ae51aa8812f78aa65b06b12049fb030987c3f02a3a1f5061091dec696775d81f63a7f84f71cd4180cafe409261e22c331af5a260f2656b7da41019573379009e87d2b34359efe9153633455602c0316a953ea3277a4cd9e90d70feced1e58fc1a8dfe10acdcccdd119ed0f2c9df4585147fb37e193e4ece9664ac46a0fa169b6e89b94b4fb6dbc52e1608f874eb867102b9699868012e0130f5d38eab26f1e2a62e80061d7f7ccdaf37007692dc8c9fa4b142ed5ae0d985d5c4c2473764e0d2c5372120d3a80255a3ad6186e3593d0555ef98be301b633042547e232b72fdb94433728c641309e0a5746bfe589542433643604feb3602a0b7ad47397e22717449b59470d43225547f4eb81969a719b553517314ce6441242e6552133370232f88ed3ac7a88c6ed473721f2e9935e39686fb979a05cd55c84d8af0bdaa6e25e35af81f8b4c165d79edc058beb913f407153d63e5ef631d467a547383a798598561892b76f67e2627e232ab2081bdbfdb0ec1708794efd4a8b96e40f90ac3420c5a632872f400278df255967f3c5e58ab7636c0ab3ffe6f27f863bae720b0a1baf8cb8c1932b94c869af14434d4a6353368e66147f559709a29fed9938d076d88ae146966830e032258f3ea68d48db6bc590cedbb807d1c59aba40f1e03787f98768b7c28ff454f887b0fcc2f21044f4fcd3a3a7a14421aa36f99d506f1ec9316071db901e6acc3bbd959bc09a89e1fc75a646a3006dfd605ef2f2f3eb133728ed9b9006f74e698c6d2dc38d7bf7d09ccfc63c280badf7722169bdaad899d16f9179390d972e096545ebf6932e449b83cd5c248b043f0eabee24eb52bddcf1ade3d90057905353c12e4309d71ec0037fafc7a4e119068ec8523b9d383d27c02050a369f1f91abf65aa322041aabee2a9142f576e3bd5d2fb7ec0386533c547f23b7b9422244ad0bdaf5b6125718d011d9722bcc20fc6873ea5d7cc97b6c9771d8c5713ce3b483b4ca78312764c0a5df6aae22b377fd55bd080e055b846bca8ecb72e6b1c5acc5b53d4c693ffe96880fa62a6e58d6af7a8871f759b36a0db8196328b6edd9dd4992bb5dd63e48bf1e00518bdf8b5917b7ad233c5e52a3f3eeb69847137c77891169fe5ee5b6d6e784877c04bbef5078ef3339a6df2cbd580affc1625fba301bdeda58dac6a30cc6d42d7b75fe9dd1287630402e71f65b9a1c93d1ccd27c649aaab5ec3ffef41d5d02b8f57fdc5d28c6094a0d19547c5e0906c54bad86bbbc9b4795672904144909f36ca1152a3da0163b2b54c8af7f8a648b58bc457b6a9aed7d5e0961a400cb7865e7e6aa60e976fb7d56d3f358b24c52943b5cd2b7414c18eac8155ec88cdd17af0498bfea0ea01675190ccff35a23320ecf19e8826ebd0657e8367f7b2424998ce83562338dccae9f928490f39065b113c2f7bc4e857277abe1187cec27a3ae8bfaed592ce31ffe529907aeb326bf1948418d7a556b73da075f50579e8d9201756c0cf7aff0d3f50727a3315d0b377a15974d7595c8acebd2ac7f8c6540f1fbcfafb35dff091c57d449ee9753e75c96ba976c829f64189b191a6425706e16730c6dcd673b80545322b7255208d2fb7ed47dc11cf31dfbacd81546df036d464729d8d6726230a25492055d84138c57d91c9617611fbd29018c911c4c389bae10001e96d14ec1b92d886f1e6cdfb5f20733a26590739f1c01d658c36b9fa4434ff2489358fa7efbb3b84d0ff7911fbf7c1c7e05a3c0e2418afda7f8f2a7f761bab33402a9218825f67d6abc77ab6b6cd64fcdff87aa8bed6fa029a434993ff2fb2cd9fbe67732d48bc45e327e238a58e4945cad060b710b90c7e72474a1c5a1cd5074f746557aad0bfeeec871d09c80b26c76cfbb88df2766f5fc6b2dfa28a1b7dcb33721435f9066435c2b39af4ab70a5de1a55368de3127439003cb7c11b2c136c880578ad0126cb735652d253623adc65ab3bcf464d60ba23f72212f4ffb0b2bd2d9e2ebcc57efa75964a0ee73e0c3c67bdf42f7af973a1118a4eaa370829f7aa72b86100282487742e5bb598caeb26fcec441ae22edf31d9f4efb084d6f5b3e22772780db8071ebccb9dc1fa34ce748d036a5f9532dd07b732be81fd53cd2de909dea94dc54b3fda4c27bedda1e66400bdefef3aa94478c7cef8a828325e8f87c19ba8cfdf8b75ef83ca845cb70fdae99fb88d70188c5fe312e466ac50235a67d6867464f8b81c52ce2bc8f46bdaecfc6433dac9410b72dc554076c52fb52e177ae23baaf9f9e981e45bd6639da511083836fcd5fcc02b5e39f7dfb6eae5a462e7a7d8ea23838c3ab569ef2c8f6eeacc39bf5b8c7f2d08a2c127693a3b3791e8c7ecd1c33a661d5d62c629394d155378705c1625addba4a1e064ac2adb5d13716b3ed290b71f30031e7d5991af22a39e0168e55dfff96c314be18664469ef81617c8b1192a5bfada322162cacb644f9b618761027908d897802fa2e2f4dbcbb6766bafe85f544f6daf0f9b7e6048a09a15bb91e16a0c366510aea1183ec41bfffe9cfd1cd52767cb8a490466e6bb5b56f0d29668fbf796e183b2b24ad32478a8f08d231ec41a990d808262f729e0128fd84ef54cc1b5794c057104e413669f1b52cfa42ab11518d7f840ddd3ae9b9b34ad4d904f67ce703692f951e4152a90ad3ea15bb82b15be86053b7b77657734e57235605f1f27bb755d193aa4d5c92c8359f3aa2511f82192bdd478eb27dc050a6284d02da4efad3190537b28d85a5d88aeb2dea6e624fe63058e76731f8b2dc919a6499801b35e9d8005ad26fc8df30c62b7dff7fc2573094e19a68385af61f49bce62484c20939dc04b8f490cf3c62471ebd2821ce33678a6e530f573214e5c462bde32d84da7f606078173b8a8ae3ea7ed2c89cbe1efeb258abf0760702f4251d32cc7d2ff505e201b975b95fb7c74876036ec08594368ae2da0abbdf40a2ba652e396daa5cef812ef8eaaed9aa443ec61aeb476a4bad561d704fad5fe4c1f1413b03846d8635005a235b596ca8ab0966caed4b0b02262feec2e27f729897c53bb82de006cc20c632c2002c527f3c6bd09ddaf0b23883f455d794241a333320e90c510a50297c10a2ef6d49ce51337e2883df20b16d0dd3b71e0d861ce17e28f048ec0108ec2704d32fd45d1006f7df59a1cce6a2c4798c9e2560f15940f4a8e30e99f93b35c1b54cb42710dcb41e3552b53204e25973aebdffc52476472efc4c98886872ce082ec17fad47a886fd8a672614fa30a329173b7ce0d971b6844c9413cc67c10708272df2d642d7b556582279989f9bdfc5eabcd260e5bedf07203a470eac0355e830d83a84c13cb89404a9f0547c35919925e18f5b8a9fb8c3cbfd5ebb90809568bbefe40590826c5fcdf3bad80438629336e42df54059fc49adc1d45bf5c69c2fcf89769a61886860ccffcc859983011d9272d23cec559a398bb2688e4856cd0665ca7f0933ce6dd45459904ebe08d0787df7a5c728ab4607a407b071466728b1b10c65bb74f397645b92a56bcf0d30b9e9f43bfbb147ff9c3e33920d70e730689656df32cb4d4c0276d04752b1302f61413ce15f3278d6ca422334a0f12307c51a7d0a77b3d07ad958974d257783879bb824591a296abeec828a4e7aeaef764785e0df37dd3eb0250d058a38bcb6d5dd33aeb907f824bacb2d8a08d9346a6a0c64d1c34250ca850a911ee72140b6f7e5c01a3324492dbd7a450b75defbc90925b6d1c1be1fe03d094ebc4383a70f576704a871b66266e88f6c89c7440b44e039f099e8fd0a6707b183f755215d8cf94ef13bb4b0cf29d0e299fffe2451b94458de4ac802fb569f382a3a68c44eb3f8f2b20901f738f55be42548fed8072be13ba37af717e177254fba93161055361d4d4a90524a52322920dd74392785b8c95097e46a8d294adcb3440f7bc007ccf4873a28d0cdea3bc75cfea0e086951c1234fca47cead1a5334b4574dc20948efb11e1e8742812602270587e35ebcf2ce1a839bb757731683f9e1da4b90d4792a5366e81596abed54f45a9a2af0153a059aef97d6c066cd8eb1e480d671e678c6ac58bc4fce8765fae816347ae5ac3c76815533f56fb7a6b3952db8d433096b385de5d9ad5f1476092f2233bba36e5be5b68f9c74fd20801d2758cf3ab872eb79e031ad5b77ae9b2bd6c7aa95366f8ffe949f5b78d70c07f4b882aaae14b4400406d1a5f1cfb8acf3cb1d0e2593583f92b70a54fae07d74b499ce0b504b4f76645f99d7950597a3d55a247c00869ec83f5fa26f1e41cc901586c64ae7895b8e20e99e7c9ad9f8095e112f7cb4eba7cedd4f0df0c7cbff80ddb02245b7a059b25be2649d663ceffc1cc17a223a7faf7e67f977a4fb55c1fd51b203880961b2ff1d7ae3f9001937184d752280d1d846f8dbacf3eebeb7e9574b9e065ae47f4ddfd2aa09caf5b0ff59ce75f8f483c715293de12aa4418fffca39512ff5becf9bc29f17e0bc93a957a5ff48174848a154d4512116fa54740c91d1328041dcb8a13a6b936159e3b830991da8b12e21f4a69afa83c0529788e723d457aebae2c5bf3d16118f0c5118db5dd23349ca850cd888e8eb55b2e307f85a2d46f46ca89b085580f750f5aee8d32f84a4bbfa70e81b35041d8070ac5f5c71d6e51c3893fdcca6cc8269a5aff471896e27d47f349c9bea27f10aef9debb1b26bff3bc2379fe0032583eb5fee4b1d60b3003e1d40ecf6e6b8958b687421da531f096e039d1b7f1759da9874475cc3d4ed8392e121549a3bc057e44a5f6749488207f53aa212862b6b36cc3cfd45efeca9bc53a8337b0697b6c50058243e5d59085fbd6e8f1d10cbc543622533d97a5ddff1a2afd6650843fce30695f549e697d557a8d8245a4fe7f96b85c3e7ba16865a7551f651fa749731b0c2cb1e54d07192afbda3ee10cdf0e5025d622cd78f058e78035bc9fbe5791be9374899a2bd8b1bad526a080d2a10eef6eec5f14660e9accf6b0572bbfd0d97e7650b7f508e341cdebc75331390b1a7c79e0b9688e79d1aced506ac06c7c020daf0c6d023bc55d6935ac3f3292455a234fe93616524e841c51d92056644d445bd81a0739a33d25740b07239fc1a06f1cc39a4c01555f511a3ca6f25dd3dc8c774889eae4ad99c3499fcb6dc5be7b619c9b8f84b11f547d45fd7ace384c7bcecb9be0b8c77bbdb4d82e4ab8f97d6b9e2cf53ac874083689dcc538aa330d8f9c82a7119ac7668c55adf9ebb4adfa829e7f322358d6515a8d66dbee694f3198ecef24df8dec85508a5cf1d968303bbe4b9140a4cf8f744d4e1ae0987340242608833b916f78c025e45c1f8ebbda7ef732dbd0f7e7d48d19b014b7e864cf3736089ea8e12510d35831b78ddd84947ac674e79f178836e45ffaa72cbe71d052dd4554ab1fcaf33cade37fc8046495f60e53ff16167886a408be7860fffab330c6b6bdeb6989968f43d4755a3e8481aa5ace3d4dbb738d3ce612c70992338f1abac0e9e95ebd57cad7c9a7b4a807b0f31355ecfc455c7724b095a67226d2756d67b483b7116425e9c6848f6c4e1af972b3ee0aa96e2f5e2f36352d478992cd8157118c083a97b92199b900f7af8df0cc301cf5cfe6b2e0e72636d8db162b4b0dc18fd268ec4c5f13d4a885d5215f032a5032c74cf8e786bcef2e99983887ca3d2dbe587f1b70089c97041db1ecd39b54290a807d7c689b17f8f113221cdf9b851205a8ccd44e6977ece481ccf685ce03d9b246fb02055ba9655bf00bfb16a1b4428ff2781d2bd337e4ef4ebe77a26de950e06121a6ce795da679630886d61586047a4bc740722e38f584534526da8eba8bdab799e15acc9ed9418beac3009d57321a1f8e0707bf09558a8324b41a1dc8bea648aeb38ea55e3783ed4516d7bb0a94e58bc4bff802052dba561e097693a76a39ec6dcae7b1858577c57d909780bd9cb5356cdfa7141dc63186b2bb9fc4b41cdcc8e5a148916c10c94a40c99a45601894a3ef29e0f91ea88699f9128e0203f02b6dbc5d8eea3f966a1ccfad290bc5ff2d21e606f1e3b51f4c086753c4baa2d964daf7fb473388c950d18e053b0925848ce1bd6c70fecac78ea5b1fd6dbee6308bd4be21333250f79d87244acecb3be630c1a558de6d1a7c566014bb3ca34ec458c60518f93c66a015020bdca0663291bbf250158045af78aefdc0818d27c625d11d12e296adf1479133592ece83744c7eab42b660fe7e518369533df7c6fdbc3e4503668226a5c72887ce7826b35f67768f1a0f38ffa76962b1852aef229cc6faf016550a4c0c3c243f1fc8c7f0f0fcfae4dc47879679363827b224b5208a1fd9065f4d0bfb7274c218bb8c6c442893c076fe17ab08b69e0420b5c3a075a272014e2c4555511e9a8ad9cce46910cc0036c3d4a54334451c8b5028c38e64da6b97afd5dc456ad3d725494f6caaaa2ce6499b62b76d373df2f788d4971d9d43e740ee6f632ab65a3507772f8d7e217779449dc0f26e16c42b38d848e7b75a89d2f2b0de60ed0241a5aac79a22856a2a79fb77aa5371fc5060fa4b816877219af17fd45ac54ed1d662f7ce8935ecff83aba4167ad59cbb86cfab083405918f4d622be293a64e72fd74e990c549537a235ca75b01250a52c9a81b0fe44877a0b4af084b6a1dd6a434764e1e4f03746d88c83fbca717bdd76f31e2214c2831cb5e295c948487562e575e8db02d25f906e88e0fa8c20a69821d45e0ac93dec11c526808fce12376158ebcef5b1e1a6cf7a952547d1dd563cd671b5dd8157652aeb01a5604d92b1877031fea80f2c95053746ce08da7b47fbf2ef564a400e92977eb8ae2cc47804eebc271e43cb341c8c7d9f40db9123c2c9361d08d4bf511f9e0a28b100487e99accc921b987df74d926051873e6971e23f0bac3592cb32516c4f63c71eb3fefe951e0e72dc40ec0ff7da28164b14143b70e99e2ac1bfd411c92f1f43ebbc6c8b9bc117c9c3039c2184733b6c2dc8d7d20c73054316b230d81942a26e3b61772f5af7f48dd4529e729e8529a3803122c350521ca20f90a126d631f7ecefb5940b2b5db704e63fee028048d21a1cc433ed239b06123d3bbb78b9c9f3c159a0214231a60fd9c857f8dfae8b9cd4d88bb2341d6a32591ee2c8b0f8b2fea52aecb6a4697169bbf7f1c5d4f18b9c3b0d72a579f25ea6958cd4bc4452dba9775586ee31ab65ce972f1c56b1645d46fd50a5242e79aad79ee9673ba152d060f4fd916cd08282e744d696a7d3ca72704f6833bf7282cc8125dd000bfa6efdc55c0a787740e9eb5ca93d04e06ad42734d9aa44d5f0d1af3a6628dd61b73a0f126f62fc9e2559940562cb28df32866a528c37de27afb03b2cea5a242b4025ee21d76bf4221a34cf71e86f0d8d4c20ab1ab000386a0bcb145a0099c65bb950d9217fd7385cd83f44be6a17ca24e1b49252bb2f6c812fc770ddcbbebc4dfe9429b0cd5a05cdd384abe5500b7bbb21d8ddda7fc45a84043e346002164ac3334ec19a34e4f69024536f8dfce8e35b1141d1440a2e7a91817ac9fe979b65a2467a7373f2fcdb7c075b1a170d43d4cc8d0922c9d608b34b43bd6fef1a5bd28867c8025ec09a86b29fa10a70a71c9fe61fe61c3f8b24189728c9fa8f9f88bf1ea11d064734aa4e7b3ccf344c460bb43d6fedf8be489b4076ce4c576edf677e595cd619b26a152914c759418c61d4386048042e437f87a32590b6c978cd271d7203670a2a83601f9ead4c80d085d59c31c45f1ba470f95909ea7ddd2f82d0f84b424a075e03860c75d08c0ba52b61e35c53171c49a02dd2b2d7762c4a4a39b8ae77e40a365236656c10f24c6e1bb47ef42b5b6e9fa793f371c9342b70de81067545dc78238f0f4c16a17f7660b4e7d62b33d5df2bcc38606ca7ae93af513bef17373fb28e33bd61ade5892d9d48f1cdca71b5aa2c6f2a7c7664fb4228004408e0599c6440c1f790771d0feae5d187ffc92cb35b6274bc11c63a9e27d56599eaff358da47c6b19d9b9458e98d25491fdcfe898d273ad17576d7673fc8c32327abcae70974e613e0f6684b7100a2650f3f34d20affdd189d874611c8418ecc83359370b486cc232940b2df1a43f049fdf57663eeb67fd57d646a151c7a7b16c9aba8d9d74c23882c3547eb8a8168080e572bfe2b6db5d118836a1036ffdc6571e8dabd17167a298c724ce363ce29da012fcce75981e21ef20be7529ee4cfdcbade54161b74620b6236ca089cf651827238428f9128028fb9625f0ae4fcc242c02be20e14b64fe5b1f80c306db5664f4933543e6d703db7328da1bb042936a5380937c9502a32d9d94a250896b3828c9f76ffa32f7be6d8f5ca15b69418d05581da0a9ebb2418ed287348293c658672a20a89a6b47022813d53631523da11d476794382fa9a20f99df7d5cf4dbf2344bb3f92710a9979df5b949a68aa2f0cc10e1303a8afa6f1dda84e35a0d65c9db7b463b68024c3e10a06f82b9eef0047a4ef1894177dcb15ab155c4394124bee8f9db9364cbcef4b7be9419722f7e3024665999f290be518265bbd9cd5b5ba35775947b81bc1efe009104e2610bab2f3f179ae281dac85810d5fdcd3c8d5ee4510d66ad46a0910bd92ccc33328fe97ffabe5fcdbcdcd2f5b3d60efc6163603439b139edf55df2a668fb9f08f7d633c4dd085fdb617ba6246c87b27aabc2c7c1d8c32586969b941b5b006cd9eb628bc532f5f8e34bd16f9fc0823d83602716e6ee72ffcc47be5ebdd13f67321eca69690d27c3a14156993a6a3bcfd5f0d41a734a63d99d58f3f005b943d076f5f29645c75f462fece3f5c6a2d14e50f162f8659a149ee78b260e62e803a1c776df3e628cd91ab3b9a670317a63619915c766365189157fe87646751580dca9b33595131e8ceef52399331d235298cd09542aa10e3bc5e31093363bee1c0d252a76f24fb7a865e49dbe91444d215b1cbba047bf37d7d828b48ec3d7e2c56c2ced8b08f9a1b2087d2ee91ccd47323a3a120be5299b2124547c3238d8d3b939f31a00dc0c157f4be0085b4e0c9b52c138020f23e3cf8e0ae759b0a691fb446bc0da7c0a49a8f895c36c09ed00f375d750b6ff7d177173cbee3a7443d1eb2aa31daf65d5527689499e07165e93e8bd65e9d66385a1a648dd5f44fe2c6219a47b2d481d6728c983e33770d82beaa81d862417e49acf60ee6837acc61051f99e973ab2cd822da4c006564038e44fa68efabbf873e17d8f3a43fcee64f84a99d62dd4ac25c26f2ff3b86ab5c2cb3b21d390ad45d73db637d4e05138e9347f60bbb46c596598fe076368a8dae9924b6337a57f0e561d711eb6eaf72c912787580bc7310c153552128c04e427620eef7049e619f03558eab31773784ed1da68e68464a38fc3f51b5842c111cd5853e1d4d696a40f584a95f402b61272fa8e6fa491c4801f0e6dc0b3d0a20a54a78e76108a4b0ce4fe38890e60e094f7a9b6a9628896bcb94520dbed6be5f1f94593f42474f6193ebecc442886ddfe51dfd0e3463855480861aeb1c3b2ed04f0b7e279d5d62f784c20df3957c80c8a834a99c95a90ac75933cd9d1da18db5fb9501f336f8321a96d336b9a2ac02bf08a313cef67c5126ba26506533a574660084d10816995b97df72528150d3ecf83ba3d427cdd27b4d917e6617fedff096786fcda740c89eb613d890775bf6d7555ddf610207c032a634f765ba07174417ff2c9c6a7195f42c1f97a380f83e671332dd762f75e1b09d890411dc09c5eb477c2d8d209330163aa3686b5c6dcb1594db2d85cc161489f1c1e5b24b49341237189f15386cdb62ca825e214b9229b7e957e54386bf4b57beeb797c728c41e1ac1b85c3837d14de81ffd10d4d58d4e95b2ff5bf3717ce18abc5d0545f499380f455e09e0bc59afc4fbbb621e221c789dddfd985db1b224160a9b74b1082efd17316dbdd327ff90cb23c1f0ba2bcefa8ee7779cbc0005159a6db4bae3461a9280a9fe8d751de0b504cdf1274ab0d589d230c439ad3c879f58b05214d5d9613cba82806f5f048e35e9d35f674879653fc6bbc246b61536a0b5a5878336c372a36a8d169df184e92ff82a6a356e2a0a76614fbecc0e2864b929fd27f2215ab2c8b2dac07f2a1e548d7c394ea6c98c467174353163c743238caba22cb31e1054da24a1c849e302377a6ffb0aee6d7a1a70339440cc9ad932a735ff30f2db2c86bc84ecbb8315bcca83d88487109d5d6ee0b6deb180d885c532bc17a3f6633507397b04c8693c791005c55fb4807bea430fc4c0b9822ac5f60967fe46ff422a05e855eb9032b97bd29ec8744a1715ba4266b648bd5f396b36c5046efb30068241b66ee3809a4ee0bbc79bd133184717581c7323cac2cc45d91b0bae11e1b319ef77a61ae4557a52faa9182a4d9df05803e48178bd75e67adeb14e02a546a2f3d6a9ff98400102380802e892873f8ee9bde73a86897c15ee","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
