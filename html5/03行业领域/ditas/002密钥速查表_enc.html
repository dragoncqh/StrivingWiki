<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"031da6ca4890867c06ae9eb5700111d6ccf534a06ede294c8e162a68ee6c642c006d87258079a6a0e41a82f798a77eae2d435510a2dce2382a7dfff11b09221bd7430f5d510283d902461adf17fa9de1561208eafac44f3e9c6e27dd842bd1dbb608017c51c67dacca49c275b8219afa96f1b902415bd52b296938304d82d8f5dab8aebfeb4fed9f93fc46ff7d92889b5f3e1c100346aeff23ae6b75bf230e99d03a6cf422026d0985418faa94ce02ec3695b96444ac3aa4c8a669b11332c22aa0c583b1a5318a3960aedec374353a924c9bede875cb683cb7d9f3b86d2a716631a4c914b2b0e1a9c6d330040b58e515bb604c1d920ae2c96b24f70445a3856bd934e4817d047dd21195e8ce3929ee1eec8108e633fdcf6f504f157f0135ae77714815dc5f1af4ec5a84558f155a361044738f35992a52ef5d59406673f55ffca11fac6fc8ad47093792fe789aed340287dc4c8e09f4552380e345efbc721672f274c40dd0448d0397419a7af0330e0f3a3b9efe95ff5509d3d91f89de0f3d73637165db2aa40abeb50cdcd95a44a75ada58f33efc409fcd2fe24f2374a23e55d2077c201c7c31be2fae6540a482586086537d2298e80efb4a723bb89ecb98eff7ec0b45af2cef2619d590434297249503eafee73242664cd7c0bc19327b181cd9db76f1c3150968facc0873e29815f6a8811dfa1480ef8fed01b79bafe220fb2fb8dd9b31e38d89dc3e5ec6ffeb7a02d438664cee89c88ade3e8fa170d3f3ce4cedbc6190ad990fc9127655fbbc74626aadff11f3765bfbb7d56488fd47f85259dfd742caa52d18f40ba2fd07e0b4bf46521026a3f62b560d4830ca2f03df279c775fbce5431d207062e45711611cd6b3cebb1942f1c35c0c4dec1c651c657de1cb629ff23b302a771a8d02fcefef2519cb2df90d2e3fc64abae3bbfd33b4412053b2f94b900a283b76aaa5babbdb43b06b2bda3f64ca3a02eab3dd8912d57a21fd6339189896d8731fb1b029d7c53c956f356afdf8ccadb1df98347c2d37c9ee0bf585cf3b434ff843a3328087bab7e38a4a6e81cf851275202ffebac0f369dfbc2909c2906f076d79d1bf4687e0a6708b30b4aae77fa0de935f060c7eff413d77cfb87b41f4ddd746aa96fe2c9df46491d1e1403a735661ea5701db316a5fa260b9528c436ff09906f9627055f1d483f8b9ca821376e6da00d1bb420dc39785f0825e0bd1516ee8f054a1e6e221aa5a43f24d479c4ea3265133e3e85bc0d1e53e41de1044f92e2176fb34c0ee154b05d5c373d21c01d7f6b49245d9a20f1654373837df415016d4211bdacd7a9f5c58027c16872c36f1aca7adb4074c26bc0d98ae6762d444ba8a247e48f1c1ce66e88b05ac27039492b435151cd4be1a560e0c7fcaff7f317df8f36f7296fb04d4a35dd58b67c260833d011d1177fd59d05f72968920308f0dfe5a721e74393043f02bb595befd827f3fff78ead0c3ec01613b552f12265fbb92de864261c5bc9e3c45a7b386905eeb75928bf9c6ee13a8ff890a7e4eb8e86c64786ba65acf65d01a5318d312f09ce74d0f70187456734da01d866c4e56a0260e6338ad50f438fad3326c57e9d3037f899d08b686b6c8fb09503575f2be570fca5f27625ca82b743421e7b80f5f145a50891c61d295ec069a94a38b2680c306e6326f7e792087403324427e76951212158e1786079b270f90d668c97fa4b092fc4435705638d8c5f0e070dbe3eef321792c549fef510c0c65f72f5ad96f6f980c3f04211682d0320e32feadf8e051c848f698b0d3c2818cdfc66db2b92dce7d1346673659178e61f28b714ea57037d2f9bb70a46cd162ae4b3c88761d2b3852d842a7440f57f1aabe2cb3838ea0b88a62ce57e07273611b25b6ebde7aad9de8601554b163e9f91e3f88823ea42a078a7a08f7eb080cc6d0cc14ddcb590b2362fdab162509950fd1c98492cb704ba22e3045754d36c528125852c8709ac491f6570b285671f10dae325a9ab4d4f3389541583affa1ccd9bf5ffc23467d690c56ef1104ab14c9bfc7c62f42d8a7d63547a670c203a546cc1743464fc029f0a5a0e86798689bf122b58da644d29bfa8724ae4cb0087a4aac321120195f41a242bec66817c115396b5ecbbb386cbd617c7ec0d337653e6040f691556b6f7bbe4e4aa1ab1b621ff0628f91837611297f3868b917a1355ccc80073fff83ad81b85d5e85b53dbb1e38f4c115d9bec94e8d8379d7f29ddbe0ff28c91c81207b9d5db321e2ea97f7dd1479106a8f013ba238d13ee303292b2885be3583156a515b47d9a6f7ed0e22293ff5c5a5c25123017bfcc108ff3233fc08aba64f23130673fad27c510bc8ac8322a59c7d040b90730f84c24524884e483c229c5de0c9fb7ada77eaf1884eea3d5f5085596808117ddbaa20cb4d592352cf1c351d47a4b40dc8793463bd43ddb3f820d2b37f76f519199ef0a3de5b8d1348026456adf8b6448cbc903c609930953bd874ee89fcdd59999de7d03f6987291a12917ec1b696055f4825cb16ca7131ba11a1d228a2a7cd66f7b9310886dd52c875187b5bf0cfb0a56b31b9626902f34b9f8b7e4b9c3be1f9c68a18a9b9aed2482e3f084ade5b8fe15ce8fb7fb21c392bbc607f0878e8f39b6e0705f674ee8216d28193aef6cc25af1a700272e1e0b60c587b2846f69c679c47c55dd406d890985077998517add55741afefef99fe8312c032c57c3ed9d03ee57cc2678ae81b76687ff8d2aa10450d7c8b2c9a1b585d6a1587610065d0c2c5b744b4648fcce25be1821280bba5679cd642da00011c7a5d7ece89eb2a89746d924f45b711db991d39d5b57fd7016ea5d03b567eaba31341eee8b87b55459dafeeb3bbf37897a9b5b824f8ba124e8d10322c8cf864e519a0fa28360b787765b482c113d2a0bd2b68c15fdc6f0470b8a6dc881ac6646ac7ab34c4fa0d34de5c126a42517b8f6875b650afdbaa3d182d41a72a9f63c662dbe02849e9f152aae8a230a59b78eba587bcd8782054f70c60c64fc2eb854416ed086c76f7b8468b39d9af658c5decff8e4829df3cb20ad6842d972ef5e212a3fc00475bd38bb7a74cfc4af5c069db1424b8d6d4248e2abe1c3bee77fee1081830ce15a0b6641ad3cc844991cec8871dd4ae1db3143c965eaff28ba8722aea6c480f7a39cd6297e7aab3d7f195bc1ae424793fcf6fc8c1a86e4b570e31f772bd54c688fc9fda06dc500995ad762ea2b716f17c9daf0fc1cfa216dba209ee1569b799a7be3ada9fdfa05ab0907ff0a4371b1c30462695d086e31ea6be51dccbf8a691a6d6c75e393b5e47792a8fd951c57f2ec8d31a51fc3a7561630abdaf822fe6eaa5dc7942d76a5a4c9d360f0d87dea60f6cd76ba8eaeedefc1d8f436bfd657abba89d20b943fd0f6e71e4bbf6d9be9eae4a16de97bf77930ccc587c187e560e41c8a82c6af25ab7e62b344cac25b9885bc701bebcbac6460475ac1d5f1b79696cf1b8b3f94b3e41d61649eb74a0cde2056a5312e45d7b0004c2b257e889f45f04a5a82fc3b1ac787ef73317a4aff02d4352fd523e80cd1d71922457425f9bf4121a34bef45e222e15daa9a17bddac6b658b49cbe3de8efbdc3f844dd058460316751ff6d1e75b94265b43982265645123f5e8a5da0f4f11a095b0e2af879a80cf39e73c47a54407470f75f588ed9a8b957f477df264fbe7d3255f359d948562992512c749f8560f6be36b36d5b1c0cfa3480233f6c86c5936a7d2dfff86d92b3ba5696aa0fc93a9c2510ef345e81f4752e7cd0c19c334393665a84f99db51089de15f1fd1411cdaa6ad38f32ad12274281dc088c2fa48f03b2b0707ad01033770e5964b90a8de1dce59498102149ac703434be5f991a3925f1718e69c3075d166a5f18a8a4ddcc0da1964e66c568f0a02c71b03b1fe1ecf6939d179e7e2e245ffab072c6f1b1af7d222f10f76ac0da5740fe7e0a48387c1d520690eaeb45d5436fa49df10d16171a60b88978b4b7c89fe1beb6b2aea7b7f0a050f69a7ab6f5112a46226acf3492ec1773c49777b45928506f2678418aaa32dd044813009fe892d4f6bad0aa05043ba89dc69054d023aed91ba0454141972bf085d901f9c511873b950ef4bf503ddff089898eaf81093ae3a7f897bf9b437b83d7e9b1313af01d4f79b0cfcffefa7e7138670423d4d852965ee4b82be2864108014f9f1c5d2a5c681a532b3083bde0203c63cbc300a0a47df1604102569a39e7826c37e38434e0cc1d4e24ed6e1ebe9c5c41ec6c3b0132b0a7a5bd042b0527945098d660f292af644414888710153b648be75f8d911dd1cae8044b73f891453df380bd232cd4f9b4e77dcedd37c6277207036cd67a782069416e57fa401e446ec047dbc6186915c6fb3eb7dcbed60091b6aa1eacc580a6722f2fc064ab5d032876adad2ecdbb409185691f107faff82cd98c8114f42fe86f7617141c08932e67ffc1c4c282f0d603cfeebaf2f8eef4ebaa46e68a8c5bf0c0401f95133bdeab0d866fb4541e60596805e478b81296bc085fb8c48a6f62c74ccaf33a6fa2c50156cbee14f11807a7c2f9467ec58968298b631e595a47bb1fbccbda06ca19b9889fa4862f5e8af79a4022bf9b38f127b71f0966890ebf35b9cfce2be46f5a613bd099ad3863046b7c1fa4233044fae3611c5148d3e5811f820d2af045dc0cda0b6bc38df45ce5dea599462406485deba80dcad936d9e11cdc54285019e62992d9e1029a109d33ffb143016a826af97b1d3633743f5a6aa1553de66772e8fee42589a374d4c6df1a396c9c37432c52532d85ee9709d4d3130edf115ba57b89fdee736959defd95ee499a0eba2d34a70df31be69117f3082ece88267d14c59b16a490f0c371db8a1ca8b3cfb92eb6fac7890e83bd1ce9b8f33ff709f501a79be6610714df67dcc2da89647684b3ebc808e07aa0a19f22b613705cf0035a5f456dc9b64af258bd16c76853a66ba46feca657daa5c3c535a412cf8c31beaf9b202e144fd01c3907b31e9374934c98c04fb50961b74d9a6b9b05a3a46b13c5d7977f745d8bae662c2aeb60d57231aa034c856153042eee6cd33353df7f929e2fb11cd244a191d6600056da196b58860cf87ee0dc2e50f333fb69ed74caa08ce70804244713305f261ede3187a385405b67af18e63d8e5da3482ce74fb38171df6f2a5a831067ad0275a0c00f1e6b518d06cb941670d245bd375f94112d7712a666e9354cf0317b682bcb159166cde87bf074acad96ea4bee06cf4d9acd0c9e32c70b7d4ad1f1a1f3a9590b115bd92b172cf1f532294828d69b47fd88f9452ca86acd9f328c0cdf451930265203d4be05c263b25e4b2b7a8b90f34ccd04e508c65cda66cdc6d7efa9c79abf094d2244fe0d428c85a9933a6324e05061b616facb613acc02d4a12517bedf09c4a0883cedd49bfa74bf140d72dd9df25bcfaab5cddfd486d63f27b4fca40442a6cf0d9798149813222f35d3b6294f4d2084a583ebb0045441f2bf334a4a3987cde67b24ae5b9f73e1788295d60e27b291ccda0bed398d09c150de13457fd58ee288c75ecf1afb148a02f7e254c976c40f7eb20645fdb2ad459e92d170b5e7e0c81221fe709b1bedca79a98601d4173180da3693639486b434f1a58d7d698ccfa578483a54c36abfa2df3cfb61b5fbf21563b5449dbc43bf57e7da07f612870100b3ac72965b145a226b40c15231847d5f9f8b35cfc3e55aa3d81343b30cef11ca96cc4ba83e7b2c5cdc6ec086ef96710351d0ce69f00490932140e8033dde8dfb2f0b7b04ec1d7202dcdaf4a2f60c4220bfc500c56ca06049467857623067fc1213442e22eb5b5283839c63f9616a36f78e3d4f200e91b70653af4798f8bdf575fbb0d35a285344346b14e3bb227de5d6c5e3e7f4c4b1ca41d86f61952008287270c388f8a45b693108ed6f8d4bf5696a8a404a4aea86e831233ed9159d4564c7565afbdae15c0edcc25060c964922d8d4bb821aded65afd4b9333ecfe599d6cfa12d1390455eb6ca7afe23b4b0ed5f636f9bffdf09993be551093d997510b592f402bec2c15056a988b41451b4652536184bbe01dc65acc541e1c845938190aab11c1e87bb57a26219c96bd071321ee82eae5cb401043c31c2fdc963d02a1173b8f81439bde209830b9d3117618af453efa09564d30e536e620ed0edbbfbbfeaf61cfcf7903b19646d469383dc2cb9638bfab290a44562f9de63651ad1f091674b97ce6452500476911b8f1e027ba5338e5458d0772517232cb83765b9eefec8d088fe67f6bfba2344a61f7337d651baa26a9cf150423e1ae657d46d1d3d82adc3de1c0c0aa78b8e6f939d89f336612da5dadbb8b8cbfbbcdd0c68cfc75d1f34d4b7326b85c245bb887c53a5a6262ae51833ad1136c6be9f09711d14df0194d7ed8a4160883cf4a1a9e301ae51724751f358f57f068d08a83933ebd25567e488bcf59573f229e1bd554123cf15a9b158833967a0756c4c216dc1143a2fd04c510fc5ac11288f3f0a536123d54d8bb2000b07def25012f89da71a56513642a7d30e243599478a697b6162e619fa426d155bb3a5357349ce3d82ebd49cc5438534d806d246d6fa948ae54d3353a0c09923ea847a1bb315062d1f69bcc84a8f48a35e84d2655ce7d0474a76042b9fc85df10c343995cb51ade36497e52f4a2ddad48c9c418789edf22390c2589044be8c64edd0cd7f18ae16cf7a5e44dfe8721e3e93cd3ed00aecd6d12407f5889c541a65ecf3ab9945b97db14c527c212dc51799178235fa2154bb0916344a35e5c35cff8adf68e4d76c5c94a1a143aaa13ed69668c63b51e3a467ea22b7948634f3b65ef49da970a4d65a46f364c8cf8b8e804e6d257d5cafbe4908af9b4550227ffe6fba591592b856efb7b73cccdb7a81ca1092704fd7645a0da25c1e4b96e78d37344586efc6aca99ad58137af59785f5fc2515e163afb6061bd0b6a9b9dfd2c2552bf5c194473a7dc82d9ef8fcf2953bb6ad942efadd8b45ea50faa84d797e2967e623446ad23e8079de2a22c1af4f6c65effea48868e02daf3d4253dbdaed77a75d075ed2ca6c27d86c6e80befc09928c534481a00371ec31f94731f1346d0941559e3218fc2ded0931e3f345d12c68d9194c1692a7875261a131c95d8b78a89fc3f03de47b13ca2de68dcaaafad62a6f035ffcc902b319466f498afc62e8785f94dbdc2fb3bc8481eae716ee20825e744023eb7d8c7b7e5e977d14c2caa7b38c7af6dfab4f9f04c94822c8d743ad50f4a7b56d02c92a0af4067ba29812c63ff8af527c001b54c026d6883213dfde09c369d94d1dd65c87e563cb906f09d8ac1c520a85e9f926b7e0550c6a4ef01bd573db7999989fe7c1e83f744a3c919127bddd0d310e5c8e32aa7c75b287c53644c3ee989c424ecfca596c1a3f5db901c042eecc6b5d66dd45955375e60ca1e7bbfb963b7dfb7e7c600ea4d2a6ae33382a68da05fea9919b6590e705913f6677fa17a6aba8a4ac3f81ce3b1122ff7fdf2fef4d0e97ba5ee9025c3c8565cb1784d8740753221765ba0df2731fcd61508ab202aa74bc206006f35a4ffd2f1b0d66e08005c733cbba113be1baa14ad58fd21125ee2d5e4f3906787172910e0a69c389813cf45a97fb9c41bae96c1ec259cf5daab9acff521258ad8dbb870137f208329bfe3c77dc59631783d05eea4af2ada6934a7ed470dd7037c4ba28046b1db9acb31d04c487440c9d129b106a869918270d13a29d75206f014e63f61c4b58030291ee965a8f3910dd1b1ca83af03a65e7e5143e5a62bf9d425fc3ec0e35b4124b14cba69e8356b1e1b9dfe311fb499e39970449e28c77c208af239f1c017282f20cb81814f93e06aa410f41fff7c4b3a97a519f216dbe402098d8c0ee7b6584abe437f77069833d0d75edba0f6e3327a5d13295ce073c862c239af1dd08b3c1db76d4f91b8c915a60edd2b0b636b822464e1a9707783de6e5ac911538952bdec959d38b2ae370d9bb10e2aac408816b75ba2990730a5897fc319e93c6595168e66bab14c09a861bc7e36f960eb606baa86c1bed8e3c70fd8a83c731f9eb9e841463d2f56c4b4db686d3048f37f3bbbbf704579c24c936dbfe21730c6e25ad67feea8d08684f2082d80b191b503a9a0b284990b78ab4f780cb00ca0a06f845e0936f1ab5aed8e7f5a2de991f2d57285c7fba4c7798e134b815ed026ce9dd3b570806e7a50a65aff100b93e678e83c5af44efa4912bd3f91689617652ad147371bce6c49b456f49c12fa81fd350e59d267dc83911032c09b9dd37804941ed915c86684d918fdc38c11f1fc3b0a16978eb89736de9c0541294f5973efcc1d5768dde3536e874924d9f6a77da346ec769fb765a6007698c54ab306456824a12a0281bd5aa4cac8eae46b0aa38500bc7c3264b99540831c9a36fb466c45e32e3dc1d6ac2463be641174c2bc93417c3ec0bb09aafca731299461ee4f7e423e907c0e454ce12fcb6707505a43c5fd773adff207818aae28729bca1c71a2f8168f21fc6ee1a59bd6dd065cb558193c0a7561bb6824197c2c389a9e185fb02094bc45f436f6f12a4abd748ad1797d82f89d10f5243e3f9a6853f9e749f840f840766f80d3c1a00e4f50dfef0f9f29e7161d4ecee82b3106c79c55ce5c210cf0912bf94938d77a165df37dee4bdaad6f8a50f4d046f6a6f5bb2c678314617d380419cbff029531c69fd6aefcd33d22dcae7e612348a0ebd9f0926c7b623dad9dc7d8c961861efbb24261720cece1ae72e966c6f9f723ca649a84441c113a9aabe1d59a44cdbd438b7784c9ca1a0caa8c5c6a5ea45989049b938b390a2a573fa68964f59ed61c9fc53eedd25dc840c644918c3df432e61fc2d822d4e53fcafa2924294474e450cb4cec45b5834db67e08d9bb1087b68ac654e184b9768d913a05f0c4b4beb0946fb5bea56c01f5d72b45fe88cf390dfe401e915f59f9b6806dede1f66692a81445d8cd0e4267b2ca769a7e2083ccb92b25844670c634f730bf18c0ef95f0e4458672b40e3fa53f0448cf6adf61717bf95b78ac9c671ed85ef077f298829108410fd646b3e063e081097c367073c95301a6e0053da4eebf573d553b5601eea6b0dd8fa65a78a701b5a4b1590d006be1a37f895d37cfacffb68fdb8e1d0ec2255f054e2f5cb244d11e3f32c2b285f658235b81b58eb0cc58c073208ddf40ea3c1936251a966ba28450fecf6140b9c32ee8ea50f09589e0e060600b880fc6fd82dc05cdaa6c741a63d6cff09e7cc87156c21853595d05c28216c6da7485de32af366c79862ce2c5aede21e150ee6a7b76ffee83efb3149d239bc0de8787b940dc8715f2fa88b64db5deedb3f19178b51cdb75a88800fbada3974669d2059db1121c5d1534ce2b0e0cb8d0e009d0f6c83459f8266e5419e5383e37e7c59626d18c1a2b4cfc63e85d0612f38892d0f096b313b5344724725b2a652d75ff36e933279bbe5f669d50116ab52393b4dab47255133ae40db1f5353b72dfd44fe786f11b6a1f75e096780b10105dd1e1441a84f035c7be106e1626733bc612eb9ef1148bd0acf6183530acb542321fda604c981df46f3733477613e6d34b4b1aa0907ab2e6ac24cfd226e5f57a7e6210626c6aa48bb7c4028b5df1769c0274f423043f37e678ccda435af2b90bd4035a44f089651ffe5589728a4aea624615cdf4748199fc5c7e5eae1524260cbd267851d499e6e7a894d1b74be6908a0ab24bf8b3a1576a8c400c0b584f0a0e10f193309cc2594e1cd1193155f959d53c0a4b0388d5a34ad7eb2848409f56f8de4ef03ff02a2c6eb682809b870eca8a16fe3e12ac626965fb8a54e879517a3d0e610528837b25247ed6073eaa5cbf464c4bc12e10b75988ab8b24c0cdeb129e348e67e48b512d4f141b79b3adcc548323022f1c6d447b3c98a2342b717246612a3ff3759671a8454bcd9521cd07629fe14b2123458322a63642c6999844186d1fc8ce955a4311e973e21176d032e712755ec387ffea562c446fe39a2e92cd3c48c96bcafdd500756749b206b6b95cd30e6cc5c0592ad8b3992a4a12af943fea420b8996db2d4c6356cbefc0da47ef23166bed193e598b7749abaf48dc54af8e197c80a0dfbbdbf3b7fd129ac4fd1cdd2cbe649408d8eb97f677cb233edbbd2289d4d30370c75be0fd974cc988dd39ec257e13d3212b3880f79d91f866385727ad72a5e0f6883611976d56c1845c28a665d1cae531c652da96234aefaa42521091da409f22663b591135ba4c7e12bf412b34fe7d4a1b05bbbb437d24afa8f6acb2acf42d3a5408f1d7fc0000df544a3c83fb8df855411527d0642a2322cea5b86ce187eb28b3511845e0eea4e9c6e4ec4ab63f088f662260edfbbf57ff684f91e5d17ae315088fcf1c5d6d1b438207876aa563edba4106442bed003e1fdf87028fadc83f05eeb225d4377de0a684c397a14b1b2563dc69fe75af39ce3cf8435aaff00567ce49809e4c5f026a84854b31cca87b9f31c2d1486bf38336e1f75a15351ea0f8849960c3234a1a74f8564d6a90418db5876f83f39276a4dc33a22236770145dee0224550d12c2782e8895b8bb12908b205b5759f0f38f47fb2d125e54f67ecc0ab276bcd9ba224ecdabc17147c08f261c3208af7ad497d9719b549e110f69cd5bcf08ff2f7a74783bb82a760741d4fcb95a29942cb28c2a218ec20cff73be8511cecd6071161afc30418487cb73916c3b3eda66504da139113a1978da2cfa0dbd3c1053ce095426caa0308cd59ffa4b6e6faf4be3ea5673d113b533a44ccd493e0a2ef6a9ba650fe7e65a308c3c0e71f78847addd707cb16d064d7c9d23804758d0cec39709d1fdc22e6b862bec8cc957d23c6606152be83bdc708c8275f5f4c4788028e230b7cab8cd143d6942709e344d6148ee56c6c125ae5e20528e4589f48ad03a13f3ecb6f16ad6ef5f36aaec3703d4413fb1db0e0bbff11dc307eb5abab2a915311a85b81bce78476364d2f2fb6710c0cc6045d97bd0d00be0827cf06ff98dfa464ad075e81573cac49647e5db705000f466501318e69142a24b8ee58b3009b29a4be65999086f7a1dfd66463e2fd4b7b1a5d56a607a0372451f9d17e37038169cf41e174d56d05237097df9de2862ae5fbb30d5edea4f876e1d071dbeb8580aafeb0e8f664991227eb76cd8d3bbdd471574b481e389d1a34c46e4f5e9fc6ace79147d59f697fcf4c9c50a0095d6fa5b9dee142ae05039a614cc89ea7892de70407d9e4ce4c21b3dc6da50ca4fa2f877f9110c4286229ec3401f007de52e109682ad8d124318a13871d222e2645c5a816b4293eac4dd2d554a4b907e34d7ac7a8d38eb1f5b111345e53931727fa1068dff5ab21ea45b5e923b2c6d813213f55c2aee51a613cd66779c669f9fb1f9383f04ec32b42a97c05fd5c9c8b7a331cd8848353295d9075860971cc5d7872117d05a567d76b5ff9d02d5d355e3bf6393b209308cd937b6a1e2d1cb7b7e76def019b00ae09987045b16280aa6f8e04b5e4bcd1a0517620e12d176cbf3e1541caaaab541fa7d11de31c732d8a2ed96fabf57464895e6ec41e9040454d11ad66730e976543d678779bb519c923f3e76dc0b175dd7695dac31fb472fd000e3040e6cb1aee84861a159877efeb88ed7adfbceedd345559926fcd097fd9cb3b7955edb5e72bee681940d94dc537f703ad51c637ce7651b21f5f50a7b712f116a7d035062f583f3afe3f20f2ccc70ff4af69da78c8cffb515527fafa13fa0aae8af87190cf45c3f68227a110c8337097c0574a879601595f48c5472ebaffbaaf7bc82f34161f75f74b7bf3b1556eceb261195023c1de11c77d40f15cdee31c9ac2a3d9d5633a9945d7e4049cb9c458c0187e838eeb8e64f391fe90ef597b54b0f40e6306f6bd18c3fe13e1f02392e70b02a0d52182cb66d44c0377f5c6b18bd218656959747014e2e2ab5d3ac936d95c98e98171c9ebe2d61827d69554bb6d0be29b44317001101d1c26627e7c26b14c6cf1ece4e68f8119778595a3ae4c868422bf37459bf81321c1c3a3eef55f1495c9c90fc953be9cc5e7947003a12a90047a3354c61c02a700c53779a65d7537560cd71d9b789006521219f76aba2e42de0ff7c30154efba7b410f46de7e0345dc1eddf03db34997aa1013b4c609b9d835b1538613f0bb3fad004ba70ee50f5c49951e852107bdc10c79a52bc2b085cfc0b5ebe846c41889865eda88b73d0b85e4e15c13342dbbe34a8d37f04e6b7fdd8242d3ca204234f19457475067cc6e362c08a09b80d89eadcf21e7501929154a516512cf27af1aba86ab7a6fd3b87e575c8a938eb2df8d35b0787ea9f19ccf2a60e2b611de004de8b79fe487c2dfc0ca16e7caa844460eb7d34cf6c91569fcafed296f17071836efd4524ce9eec3a1a0ebe8a5658e2907fe919495ef3fbdf2f988ee9b45ca735f8c51f2c27531d553a46e9b4c6d241246e304677c0b46156668ebe3fb3e6decdb3cb1d592a493d69541324b9d1e04f2d9973a8fac63fa579de2c6735862d86a55f81cdc6324500eb4233f670dadd7fa225498a4ce76407d5880765721ef5f6743441612d21102e10e3b4f6abf4bc545790053b01d524999526604428ff8b5f5c72df57251c5165072c7bdbc2e739cb9d945570bca4b505394b5b5c7b532920ac99dc1c9f45e3d2a3a3fb070bf1f22f74c9f7d160cd70b0c09992ff3c1e54026640920050c22e24844ac155f3a56389e0f15a70e39d179acff4523b08bb5078bb832ff9fdf5a10bcf5dc26680f2bc0737b560fb0e1e8e6cb27c4c2a3f3caff6290e2e0c339e1cf6261e756a3bab70e784e2887a6c25cb4604cf9450b10dc025ec1bec2123cf3837e8c97c83c4f5f8daffb3508cb3831a5ee50687a89c751aa917153c211f626b3d503c85366140e56eb2de1c8ec2427146ce9096a509d5c9277c13c68e19e82c5c24ab0e103f1b77cc0390f94418740633f391c72336fc9e72b44f4ecf9009c224c06890d7f01649ebcb96f83a6bc40f478dab4d64839f19f726b1f76abecf81376dfb6b1f4b75968db5345bdb64b5c042c1509bb6efaf6aa453cc55d4b1b6be771a3bc584012e1041629d0ba71c5059a53ab6e98dafb92d27cca547fba9a4af237f4bef95c977156c48ae8a582144b33823d981b4cf36efafdec2b711b1cd1e82613423f69589b103e368d75da99d694f47d78be5aa4339dc908d42c82a0658d4da7d995e757d978302b4635786ae77fe8e4bbcd47d7baee105a1483c1849f49a5c2d9a2abd9888a898805511475f9e69667e36544bbb4757bf2a7043339da139561e1dd3f41e1db3d107ba10c1333e422b75e7bfa0d56d14afba06f98055b3deac3493d624996053ab9589a2e91c4a527235ff00ee1da1a1af4f58bbb378b8bd6db93569cbeb9e84d50afe172fa0b22bb5cc0cccca72b4d1d59ee19a01edd7b6e2324915eb3a472880895c0a888191a362fb26eccf1031ecc1e6242c5c925c49866e72dbd7c848d5f478212ff80ced9b9c381526001110ff9be738d0d0bf90829155cc9b47802af352c3c5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
