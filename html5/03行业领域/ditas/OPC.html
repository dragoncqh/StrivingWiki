<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="zh-cn"><head><meta charset="UTF-8"><meta name="copyright" content="(C) 版权 2024"><meta name="generator" content="DITA-OT"><meta name="description" content="本文介绍了OPC UA和Microsoft.NET的技术特点、技术背景和两者之间的关系；同时基于未来组态软件的技术特点和发展方向，介绍了两者在组态软件中的应用及其重要性。最后指出，OPC UA与.NET都顺应了自动化行业构建大系统、复杂系统的发展趋势，为实现企业监控管信息一体化奠定了技术基础，采用OPC UA和.NET技术是组态软件发展的必然。"><title>OPC</title><link rel="stylesheet" type="text/css" href="../../commonltr.css">
<link rel="stylesheet" type="text/css" href="../../common-extended.css"></head><body id="OPC-88C518E6"><main role="main"><article role="article" aria-labelledby="ariaid-title1">
<h1 class="title topictitle1" id="ariaid-title1">OPC</h1>


<div class="body conbody"><p class="shortdesc">本文介绍了OPC UA和Microsoft.NET的技术特点、技术背景和两者之间的关系；同时基于未来组态软件的技术特点和发展方向，介绍了两者在组态软件中的应用及其重要性。最后指出，OPC
UA与.NET都顺应了自动化行业构建大系统、复杂系统的发展趋势，为实现企业监控管信息一体化奠定了技术基础，采用OPC UA和.NET技术是组态软件发展的必然。</p>
<p class="p"></p>
<section class="section"><h2 class="title sectiontitle">OPC UA、.NET平台和组态软件</h2><p class="p">来自生产过程的数据是工厂自动化和信息化建设的基础。工厂中的数据采集系统负责从各种控制器、仪表和控制系统中采集数据、并把这些数据传递和共享给其它需要这些数据的系统。这些数据消费系统和数据采集系统间需要统一的数据交换协议才能实现数据的共享。</p><p class="p">应用软件之间有多种多样的数据交换方式，如通过中间数据文件、中间数据库、共享内存等中间环节交换数据，应用程序间也可以通过约定的方式和协议直接通信，如通过DDE、COM、DCOM、OLE接口和网络通信接口等。</p><p class="p">OPC是OPC基金会在微软Windows的OLE技术基础上发展的一种数据交换方法，其目的就是通过一个统一的接口实现不同厂商的软件产品间的数据交换。经过多年的发展，OPC组织发展了OPCDA（数据采集）、OPC
Alarms&amp;Events（报警和事件）、OPCHDA（历史数据）、Batch（批次）、Security（安全）等技术，OPC
DA在自动化行业得到了广泛的应用。</p><p class="p">随着自动化和信息化的快速发展，用户系统日益复杂，系统规模日益扩大，用户希望把从工厂底层的设备信息到高层的企业决策信息都能够有效地集成和整合，在工厂各种各样的自动化和信息化系统都能够有效利用自己所需要的有价值信息。充分的信息和共享是工厂自动化的基础，信息孤岛的打破是提高工厂综合生产效率的前提，因此用户对数据的交互和共享的要求越来越高，数据和交换的核心地位越来越凸显。传统的OPC技术逐渐显示出其不够灵活，安全机制不足，平台局限、实现和使用过于复杂等诸多弱点，因此OPC基金会在2006年推出OPC
UA这一全新的统一架构来取代OPC DA技术。OPC UA彻底抛弃了过时的COM和DCOM技术，和OPC DA相比，OPC UA是一个巨大的进步，OPC
UA不再局限于Windows系统，而是跨平台的技术标准，面向未来的网络计算时代，是以SOA、WebService为核心的理想数据交换技术。</p><p class="p">&nbsp;&nbsp;&nbsp; 1、 OPC UA</p><p class="p">OPC UA（OPC UnifiedArchitecture）指OPC统一体系架构，是OPC的最新发展，是一种基于服务的跨越平台的解决方案。</p><p class="p">与OPC DA标准相比，OPC UA是跨平台的，提供更高的可靠性、安全性和数据集成，能显著改进企业信息的连通性。</p><p class="p">&nbsp;OPC UA有以下特点：</p><p class="p">&nbsp;&nbsp;&nbsp;（1）扩展了OPC的应用平台，把过去只在Windows平台上的OPC技术拓展到Linux和Unix平台。开放的基于Internet的WebService的服务架构（SOA）和基于Internet的异常灵活的数据交换系统，为构建跨地域的数据采集系统提供了有力的技术支撑。基于OPC
UA标准的产品可更好地实现工厂级的数据采集和管理，从PLC、DCS等现场设备，到HMI、SCADA，再到生产制造系统，再到企业上层管理软件，都可以通过OPC
UA标准，统一进行沟通。</p><p class="p">（2）OPC UA标准使产品的开发和使用更为简单。OPC标准促进了工厂自动化系统和信息化管理系统间的数据互操作能力，避免了非标准数据接口的复杂性。OPC
UA产品的开发比非OPC产品更为容易，因此越来越多的厂商开始开发基于OPC UA的服务器和客户端应用。</p><p class="p">（3）OPC UA定义了统一数据和服务模型。包括：代表结构、行为和语义的信息模型、使应用程序相互作用的消息模型、在终端之间传输数据的通信模型和保证系统之间实现互操作性的一致性模型。这些统一的模型使数据组织更为灵活，可以实现报警与事件、数据存取、历史数据存取、控制命令、复杂数据的交互通信。</p><p class="p">（4）OPC UA支持查询和通知服务，服务消息可以是二进制的,也可以是XML的，这意味着OPC UA不仅仅适于设备层、自动化层到信息化层的数据交换，还可以透过Internet实现远程的数据交换，能满足自动化工厂所有层面数据交换的需要.</p><p class="p">（5）OPC UA比OPC DA更安全。OPC UA传递的数据是可以加密的，并对通信连接和数据本身都可以实现安全控制。新的安全模型保证了数据从原始设备到MES,ERP系统,从本地到远程的各级自动化和信息化系统的可靠传递。</p><p class="p">&nbsp;&nbsp;&nbsp;总之，数据及其交互已逐渐成为自动化和信息化系统应用的核心，自动化系统将向大型化、系统化方向发展，数据整合也将向最底层的设备à控制层à最上层的决策管理层的方向延伸。OPC
UA是一种能很好的满足这种数据交换要求的技术。OPC UA的出现是新时代自动化系统的需要，是Internet的重要性在自动化系统中越来越加强的产物，是用户需要统一、简化而易用的数据采集和交换技术的必然，是网络计算、云计算时代的SOA、WebService等新技术在工厂信息化建设中应用的必然，它符合未来自动化系统和信息系统发展的趋势。</p><p class="p">如果说OPC UA是网络计算、云计算时代的一种基于SOA、WebService的新的理想的数据采集技术，那么.NET就是新一代自动化和信息化软件的理想开发和运行平台。OPC
UA作为数据交换技术和.NET作为软件的开发和运行平台，在思想上如出一辙，在面向未来，无缝构建强大、统一、安全的自动化系统和信息系统方面，OPC
UA与.NET可以说是不谋而合。</p><p class="p">&nbsp;&nbsp;&nbsp;九思易自动化软件的易控(INSPEC)组态软件完全基于.NET平台，全面支持OPC标准。下一代产品将全面支持OPC
UA标准，将继续通过应用Microsoft .NET，基于SOA和WebServices的数据采集方案，提供一个公共的、集成的、安全的数据模型和设备通讯环境，从而实现整个工厂层面的自动化和信息化管理。</p><p class="p">2、 .NET平台</p><p class="p">Microsoft .NET是Microsoft耗巨资多年悉心研究于2002年全球同步推出的新一代操作平台。早期的.NET作为用户选择安装的选件外挂在Windows(98,2000,XP)系统，从Windows
Vista开始，在Windows7和未来的Windows系统中，.NET系统将内置于Windows系统之中，,成为Windows操作系统的重要构成部分.</p><p class="p">&nbsp;.NET是网络时代所需要的新一代计算平台,它改变了传统的计算机计算模式，取而代之以网络计算模式。.NET技术的核心就是以”网络计算”取代”计算机计算”，突破了“软件运行于计算机”的概念，将软件的运行革命性的扩展到网络范围，可以说真正的.NET时代的软件是运行于“计算机网络”的。</p><p class="p">.NET功能强大而统一，易于构建和运行具有全新客户体验的各种各样的功能的强大应用。基于.NET平台开发的应用软件，具有许多基于WindowsAPI的软件所不具有的优越性，主要体现在以下方面：</p><p class="p">（1）网络化的计算平台，基于XML、基于组件、基于服务、基于协同的理念和大量现有的程序代码可以实现使用传统技术难以实现的功能。能以更少的时间解决更大和更复杂的应用系统。网络化大型应用解决方案是自动化软件未来发展的重要方向。</p><p class="p">（2）.NET在Windows系统中的地位越来越重要。从早期作为外挂选件到目前内置于Vista和Windows7等所有Windows系统，这充分表明.NET是未来Windows的重要组成部分。Windows系统中大量新的技术都以.NET的形式出现，而且这些技术呈现跨平台的趋势，未来在Unix\Linux\Solaris\Mac
OS等其它操作系统上运行。</p><p class="p">（3）更加稳定可靠和安全。.NET应用软件能有效避免传统Windows程序常见的指针问题引起的内存泄露、DLL噩梦、注册表依赖以及编程接口不一致引起的问题。.NET程序具有自动垃圾回收功能,统一而简洁的编程接口技术等都能显著提高软件的稳定可靠性.增强的代码安全机制比简单的用户安全机制更可靠。</p><p class="p">（4）大量成熟可用的技术和功能代码，易于快速开发稳定可靠的应用软件(RAD)。WCF实现了统一的数据通信框架，WPF实现了统一的数据展现框架。.</p><p class="p">（5） 扩展性更好，发展潜力无可比拟。</p><p class="p">　可见，.NET是新一代自动化和信息化软件的理想开发和运行平台，OPC
UA则是新一代数据交换的理想技术。.NET作为强大和统一的网络化计算平台，其面向服务的思想体系、面向网络实现大型和复杂系统应用的思想，都和OPC
UA的跨平台和统一架构的思想不谋而合。也可以说OPC UA是.NET作为操作平台的思想在数据采集、交互和共享方面的一种体现，自然在.NET平台上开发和实现OPC
UA就更为简单。</p><p class="p">对于自动化和信息化系统而言，无论是.NET还是OPC UA都具有十分重大的意义，所以，组态软件作为自动化和信息化建设中的一种重要分支产品，基于.NET平台和全面支持OPC
UA将是其发展的必然趋势。</p><p class="p">3、 组态软件发展</p><p class="p">自动化行业的不断发展，对组态软件的应用和功能提出了更高的要求，主要体现在以下方面：</p><p class="p">(1)组态软件的发展全面进入网络计算新时代；.NET、SOA、SaaS、WebService等技术和理念将被大量采用。新一代组态软件将是以网络为中心，以.NET为技术基础。未来的组态软件应该可以方便地构建可伸缩的网络分布式系统，通过协作和负荷分布来解决大型监控系统的需要，也可以灵活的选择整体系统的架构，实现复杂的监控系统方案。其中以网络为中心、以XML、网络服务为核心，实现网络化计算机的协同是未来组态软件的最重要发展方向。</p><p class="p">(2) 最新IT、通信、控制技术大量采用。自动化软件和办公软件、ERP软件等的信息集成度会进一步提高，自动化软件系统和“人的大脑系统”将更易于连接。</p><p class="p">(3)大系统、复杂系统和高可靠性。可靠性是自动化系统的根本，系统的可靠性一般随着系统的复杂变得脆弱，随着监控系统规模的扩大，对系统可靠性的要求是前所未来有的。</p><p class="p">(4)用户从自动化软件中获取信息的方式和手段将更加方便、灵活、安全和多样化，用户体验将得到全面提升，Internet将成为网络的基本部分，桌面人机界面和因特网界面，即B/S、C/S的界限将消除，图形的品质、无级缩放、3D等虚拟现实的动画表现力会得到现实应用。</p><p class="p">(5)对软件的开放性和互联能力要求大幅度提高。采用开放和标准化的技术将成为潮流，开放的软件接口是用户的要求，也是软件适应力和生命力的重要保证。</p><p class="p">(6)组态软件的传统功能要求更加精细和专业，功能呈现组件化趋势，针对不同行业的不同功能通过功能组件的专业细分而不是整个软件的定制来解决；</p><p class="p">(7)软件的国际化视角将成为必然，有眼光的软件都会站在全球化的角度来对待自己的产品，提供多种语言的支持。</p><p class="p">(8)对软件的易用性要求大幅度提高，以适应信息爆炸时代用户在学习、掌握和实施新的知识产品的快速要求。</p><p class="p">组态软件经过二十多年的发展, 目前正在实现从“第二代”到“第三代”的跨越和革命.一个真正的“以网络取代计算机”的、系统规模更大的、效率更高的、传统功能更为精细，模块化、组件化、基于服务和协同理念的新型组态软件时代正在到来。</p><p class="p">4、总结</p><p class="p">自动化系统的飞速发展对组态软件提出了更复杂的要求，如何应对大系统和复杂系统的监控挑战，是组态软件的重要研究课题。</p><p class="p">综上所述，OPC UA与.NET的高开放性和跨平台等技术思想，顺应了自动化行业的发展趋势，为实现企业监控管信息一体化奠定了技术基础，采用OPC
UA和.NET技术是组态软件发展的必然。</p></section>
<section class="section"><h2 class="title sectiontitle">OPC的对象模型</h2><ol class="ol">
<li class="li"><p class="p"></p></li>
<li class="li"><p class="p"></p></li>
<li class="li">OPC逻辑对象模型包括３类对象：OPC server对象、OPC group对象、OPC item对象，每类对象都包括一系列接口。
OPC Server对象提供了一种访问数据的方法，它通过Iopcserver 、Opcbrowser、Ipersistfile向客户提供接口。主要功能为：1）创建和管理OPC
Group对象；2）管理服务器内部的状态信息；3）将服务器的错误代码翻译成描述性语句；4）浏览OPC服务器内部的数据组织结构。从OPC
Server对象的功能可以看出，OPC Server对象面向OPC服务器的技术细节，基本独立于实时数据源，可以统一实现，其中数据的组织结构与数据源属性与具体数据源有关，需要从用户处获取信息。OPC
Server对象主要实现IUnknown和IOPC Server接口，OPC客户通过OPC服务器的接口与OPC对象进行通信．IOPCServer接口为OPC客户提供了方便有效操作OPC组的方法。
  OPC Group对象的主要功能表现为：1）管理OPC Group对象的内部状态信息；2）创建和管理Items对象。3）OPC服务器内部的实时数据存取服务（同步与异步方式）。从OPC
Group对象的功能可以看出，该对象面向OPC服务器中的数据存取信息，对实时数据源的依赖性很强，需要从用户数据源处获取信息。OPC
Group提供了客户程序组织数据的手段．每个组中都可以定义一个或多个OPC Item。组有两种类型：公共组(Public)和局部组(local)，公共组可以被多个客户共享，而局部组只能被一个客户使用。OPC组中有以下几个主要属性：1）Name
：组的名字 2）Active：组的激活状态标志 3）Update Rate OPC：服务器向客户程序提交数据变化的刷新速率4）Percent
Dead band：数据死区，即能引起数据变化的最小数值百分比。 OPC ITEM 是非COM对象，在OPC标准中用来描述实时数据，是客户端不可见的对象。代表了与服务器中的数据的连接，它并不是数据源，而仅仅是与数据源的连接。每个项都有以下主要属性：1）
Active项的激活状态2）Value项的数值3）类型为VARIANT；4）Quality项的品质，5）代表数值的可信度，类型为SHORT；6）TimeStamp时间戳，代表数据的存取时间。&nbsp;
 </li>
<li class="li"><p class="p">OPC技术基础包含了两套接口：客户化接口(Custom Interface)和自动化接口(Automation Interface)。客户化接口是一个OPC服务器所必须实现的接口，它描述了OPC组件对象的接口和其中的方法，适合C++和PASCAL语言设计，并可实现最佳运行性能的客户应用程序。客户化接口没有项对象，它对项的操作都是通过包容此项的组对象进行的。自动化接口是可选接口，它提供的是一个自动配置和存取过程控制数据。只要是支持C0M对象的编程语言都能进行OPC客户端的开发。OPC提供了客户化接口和自动化接口，要进行客户端开发实际上就是对这两套接口的声明和调用。
自动化接口封装了C0M底层的许多实现，使开发者能比较轻松的进行数据访问。&nbsp;  </p><p class="p">开发OPC客户端程序常用的方法包括:使用OPCNetAPI(OPCNetAPI.dll)、使用自动化接口(OPCDaAuto.dll)、使用自定义接口(OpcRcw.Ae.dll，OpcRcw.Batch.dll，OpcRcw.Dx.dll，OpcRcw.Comn.dll，OpcRcw.Da.dll，OpcRcw.Hda.dll)。本文所采用的OPC服务器为AB公司的RSLinx服务器，在线数据采集接口程序采用VB6.0开发，使用自动化接口方式，通过调用OPCDaAuto.dll动态连接库实现。</p><p class="p">在线数据采集接口程序主要应用OPC数据访问规范。OPC数据访问规范主要解决服务器端和客户端的实时数据存取问题，OPC数据访问规范中包含三类对象，即服务器(Server)群组(Group)和数据项目(Item)，三类对象的组织结构像普通文件系统，其中服务器与分区、群组与文件夹、项目与文件一一对应，各个部分都有自己的属性，同时负责管理其底层分支。接口程序主要通过以下几个主要环节实现:</p><p class="p">①搜索OPC服务器</p><p class="p">DimGetserver As OPCServer</p><p class="p">DimServers As
Variant</p><p class="p">Set Getserver= New OPCServer</p><p class="p">Servers=Getserver.Get
OPCServers</p><p class="p">If UBound( Serv ers) &gt; 0Then</p><p class="p">For i= LBound(Servers)
To UBound(Servers)</p><p class="p">ServerName.AddItemServers(i)</p><p class="p">Next i</p><p class="p">Set Getserver= Nothing</p><p class="p">ServerName.ListIndex=0</p><p class="p">End
If</p><p class="p">②连接OPC服务器。以上程序实现自动探索OPC服务器，搜索到OPC服务器后，在搜索到的OPC服务器列表中选取并连接OPC服务器:</p><p class="p">SetOPCMyserver = New OPCServer</p><p class="p">OPCMyserver.ConnectServerName.List(ServerName.ListIndex)，</p><p class="p">③创建一个OPC的群组(Group)</p><p class="p">Set OPCMygroups=OPCMyserver.OPCGroups</p><p class="p">Set OPCMy group Pouch=OPCMygroups.Add("Grouppouch1")OPCMygroupPouch.UpdateRate=1000</p><p class="p">④添加一个OPC项目(Item)，一个OPC的项目(Item)对应PLC的一个地址，如下列程序中的[pouch]F8:19表示pouch节点的F8:19地址。</p><p class="p">SetOPCMyitems = OPCMy group Pouch. OPCItems</p><p class="p">Client Handles(1)=819</p><p class="p">OPCItemIDs(1)="[pouch]F8:19"</p><p class="p">OPCMyitems.AddItems1，OPCItemIDs，ClientHandles，ItemServerHandles，Errors'''，RequestedDataTypes，AccessPaths</p><p class="p">⑤设置OPC群组(group)的通讯方式，若IsActive为True，则为OPC服务器主动发数据，否则只有客户端发送读取请求，才读数据。当需要采集的数据是累加数，如统计产品的箱数等数据时，可采取IsActive=False的读取数据方式。若需要采集的数据是不连续变化的数据，并需要全部保存，如每一箱产品的重量时，可以采取IsActive=True的读取方式。</p><p class="p">OPCMygroupPouch.IsActive=False ⑥读取数据</p><p class="p">*当IsActive=False时，客户端主动读取数据，可由计时器触发，使系统实现定时采集数据。</p><p class="p">DimanItemAsOPCItem</p><p class="p">DimValues Pouch(900)AsLong</p><p class="p">For
EachanItemInOPCMygroup Pouch. OPCItems</p><p class="p">anItem.Read OPCDevice</p><p class="p">Values Pouch(anItem.ClientHandle)=anItem.value</p><p class="p">Next anItem</p><p class="p">*当IsActive=True时，通过DataChange事件触发，即若PLC地址的数据发生改变时触发该事件实现数据采集。在VB中定义了OPC的群组(Group)后，将自动产生该事件过程。</p><p class="p">Private Sub OPCMygroup Pouch DataChange(ByValTransactionID As
Long ， ByVal NumItems As Long ，Client Handles ( ) As Long ， ItemValues
( ) AsVariant ，Qualities( ) As Long，TimeStamps( ) As Date)</p><p class="p">Dim
Client As String</p><p class="p">Dim value As String</p><p class="p">For i= 1 To NumItems</p><p class="p">Client= ClientHandles(i)</p><p class="p">value= ItemValues(i)</p><p class="p">Next
i</p><p class="p">End Sub </p><p class="p">*存在的不足</p><p class="p">在实际生产现场的应用中也发现，采用IsActive=True的方式读取现场数据的时候，当数据变化较快(1min100次左右时)，会产生遗漏一部分数据的情况。</p></li>
</ol></section>
<section class="section"><h2 class="title sectiontitle">参见</h2><ul class="ul">
<li class="li"><p class="p"><a class="xref" href="https://blog.csdn.net/yaojiawan/article/details/88990351?utm_medium=distribute.pc_relevant_download.none-task-blog-blogcommendfrombaidu-5.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_download.none-task-blog-blogcommendfrombaidu-5.nonecas" target="_blank" rel="external noopener">OPC&nbsp;UA&nbsp;的本质</a></p></li>
<li class="li"><p class="p"><a class="xref" href="https://blog.csdn.net/weixin_29482793/article/details/80673967?utm_medium=distribute.pc_relevant_download.none-task-blog-blogcommendfrombaidu-6.nonecase&amp;depth_1-utm_source=distribute.pc_relevant_download.none-task-blog-blogcommendfrombaidu-6.nonecas" target="_blank" rel="external noopener">智能制造还有多远？--谈谈为什么要采用OPC&nbsp;UA？</a></p></li>
<li class="li"><p class="p"><a class="xref" href="http://blog.csdn.net/u012252959/article/details/49735967" target="_blank" rel="external noopener">OPC的对象模型 </a></p></li>
<li class="li"><p class="p"><a class="xref" href="http://www.cnblogs.com/code-ming/p/3848818.html" target="_blank" rel="external noopener">【干货】如何通过OPC自定义接口来实现客户端数据的读取？</a></p></li>
<li class="li"><p class="p"><a class="xref" href="http://www.cnblogs.com/opcconnect/archive/2010/12/17/1909032.html" target="_blank" rel="external noopener">OPC Client .NET 开发类库</a></p></li>
<li class="li"><p class="p"><a class="xref" href="http://blog.csdn.net/zhs1931/article/details/7699849" target="_blank" rel="external noopener">什么是OPC </a></p></li>
<li class="li"><p class="p"><a class="xref" href="https://github.com/mpostol/OPC-UA-OOI" target="_blank" rel="external noopener">OPC-UA-OOI:OPC UA Object Oriented Internet - C# deliverables
supporting a new Machine To Machine (M2M) communication architecture </a></p></li>
<li class="li"><p class="p"><a class="xref" href="https://github.com/OPCFoundation/UA-.NET" target="_blank" rel="external noopener">UA-.NET:OPC
Foundation Unified Architecture .NET Reference Implementations </a></p></li>
<li class="li"><p class="p"><a class="xref" href="https://github.com/convertersystems/opc-ua-samples" target="_blank" rel="external noopener">opc-ua-samples:Sample HMIs using OPC Unified Architecture
(OPC UA) and Visual Studio. Sample OPC UA Server using node-opcua</a></p></li>
<li class="li"><p class="p"><a class="xref" href="https://github.com/robinson/opcesb" target="_blank" rel="external noopener">opcesb:high performance ESB (enterprise service bus)
with OPC UA </a></p></li>
<li class="li"><p class="p"><a class="xref" href="https://github.com/MikhailKrasnobaev/OPC-UA.NET-ConsoleApp" target="_blank" rel="external noopener">OPC-UA.NET-ConsoleApp:Test Console application built
using OPC UA.NET official source code </a></p></li>
<li class="li"><p class="p"><a class="xref" href="https://github.com/rzvpopescu/EasyOPC" target="_blank" rel="external noopener">EasyOPC:OPC Foundation UA .NET Wrapper </a></p></li>
<li class="li"><p class="p"><a class="xref" href="https://github.com/gilesbradshaw/OpcClient" target="_blank" rel="external noopener">OpcClient:OPC client with OPCLabs library uses DA UA + Reactive Extensions </a></p></li>
<li class="li"><p class="p"><a class="xref" href="https://github.com/kishor83/opcuagw" target="_blank" rel="external noopener">opcuagw:OPC UA and IoTHub integration sample </a></p></li>
<li class="li"><p class="p"><a class="xref" href="https://github.com/SoftingIndustrial/XMItoNodeset" target="_blank" rel="external noopener">XMItoNodeset:Tool to convert Enterprise Architect
UML class diagrams to OPC UA nodeset files. </a></p></li>
<li class="li"><p class="p"><a class="xref" href="https://github.com/soarfox/OPC-UA-Sample" target="_blank" rel="external noopener">OPC-UA-Sample:OPC
UA .Net Standard Library Stack and Samples</a></p></li>
<li class="li"><p class="p"><a class="xref" href="http://www.cnblogs.com/zjoch/p/4216439.html" target="_blank" rel="external noopener">OPC Server开发的几大境界</a></p></li>
<li class="li"><p class="p"><a class="xref" href="http://openopc.sourceforge.net/api.html" target="_blank" rel="external noopener">OpenOPC
Library Tutorial - OpenOPC for Python</a></p></li>
<li class="li"><p class="p"><a class="xref" href="http://stackoverflow.com/questions/19796184/how-to-connect-to-plc-and-get-data" target="_blank" rel="external noopener">java - How to connect to plc and get data - </a></p></li>
<li class="li"><p class="p"></p></li>
</ul></section>
</div>
<nav role="navigation" class="related-links"><ul class="ullinks"><li class="link ulchildlink"><strong><a href="TheCertificateGeneratorUtilityIsNotInstalled.html">The CertificateGenerator utility is not installed</a></strong><br>The CertificateGenerator utility is not installed</li><li class="link ulchildlink"><strong><a href="CouldNotCreateACertificateViaAProxy.html">Could not create a certificate via a proxy</a></strong><br>Could not create a certificate via a proxy: Input file was not processed properly</li></ul><div class="familylinks"><div class="parentlink"><strong>父主题：</strong> <a class="link" href="OPCUA.html">OPC UA</a></div></div></nav></article></main></body></html>