<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"822a38f6340b8cda979da6d1482798869952e9c75bf671ba2f1542ce9aaeffa709d8e5d315767ee48578877bf3b484c3b4949811d3226e9a5d184508359725accefea65484ed2a71927ab8cb9e00e3cfcd74bce7b89ab204612c6a55104a56cc1c9766c04764d4a073e974b4601a7a0b50ef39319ac49f908505a040f112f5b71346de5ada26a953bf4aa7da1146b1c6f9491d7a71255cd6d9ba03744afa51ff92626c2d790c95a70d76a9b8a777d4c7e30f26ba59216257cd4deb2c759c496dcc80329b493072132ae1612571fab1720c7610fe1f96b58a9558ee0335ab8dc792d75c08f208a97cc1f4a5ea5d54f022792b802dcb81f48b7fe721feb1b0684e1d55497c0307489649d9ff91edfd91781f9260a506adeecc3eff8b02c365687928f302b0dd7fb054f31bdbef07a8e0883d409d4da78d410352dace4d07e7121e7a38929a1d339495b4403d0835375b4f1f036fe26529cb28c08b2dc28a4f1d7c3a5c10d84d775db4ded032ecc7b35e1bb0a744a031d7cfbe6df35da79d569eeb903167c82791423eaa5e96115720fa2c98d4d8477ee2abe3545bb854cc308602f80804cde54be5bf0c6b48bc8914a0c7afa37c916ac6a1d05ed86bcb25704a793cc1890fbafa98b57cba9fc82c597cdd1ef505b3c82e185ca47671cac6c73e2c4b15a81e0918d50ccbe8df9eacfb660bed2b1033d0869e40b43476ff5b27ed89e5b13837d445b144280903cac28c2210cdc472c741d0c7dcdc5bc19f3cc9be84dbb2fdca3854c8ad2f60b40d797f4537bd29f0190d7afe11d7e035974798ae92d79ca9d573ec732f7f6aafa70a3185860b8a23b1bfc82e06733f2d8b160dc8f716c9da967638cbd1f71af2cbefd060a0650981ad2c5f5644959fae4eb6632a7e3f2a5ae290a6c06e48a73c751aa632308799b5dc934922d42db4972e90faa06cf7614244eb449481cdaf3c5329eb81e4e39e5686cbacd531bf3126998a85db3eb89092cb8342d7fc6f1709a50f007084f7344e9559fcc2de806e5e7b6e5cdbee2e6646eab77b6987fcff5ac2aee2b8274d5d2c2966547b003d8bad93f924956585fb79c278fa9162d37569b9a6657dbc686ea35fd1aa95edae6c6d70461ff7f50f9a82b6f951e0196d698a62591150d7d4f20d332cee9bd23bb67a260c72ac6d6f2070ccfd6d653942f329be41930e324a6459e8a12584e84de03358e3e4da09ca5fa36ddfa571e9012c9d2fbb060db3df07ad5ed73bb97bf9c20e285eef5f27bf8b9eda51d37a7c06f60f8dddbcfb42818d05d9deac2882c778e3db217982c93498bb2557a0c90ca41ad88886806f737800c2fa449e9435ab986faef9b3eab5b0b0b572a04d0e1b45084c39812da8ec4b07e95be521107eaed54d99bec20d0f59a6f13e5373fc4f5a18f653b32a8d365580c5a7b9bfdc5652d6df99366fb9eeb2e133a3f86dfbba68113fa96fd4b405bc437412efa571413fc888b148c9eb5a48565507380a61203675f93a6af4cb959d6138561fecf955dde1cb5ae5176a5253c4d551c7db987c9a5af0fdb80b57f937d306a9a9eb6d7b0eb9a637c99c44739dcd649195b463446d85adc68c8bd51f763ef60e55b3c8c7545fc58911ab963883dad724fc4a426767a77095f817eebeb0adac5a338059daa8d7bf50d966311e47efe3fcd4ec0a10309054ea4834be4b037177f154386ba3dc3f7c891bea4aab7f463ba67f6d1bf4ae8b6d5d5062813848f6accd28f28c7179083e3f311bf4113a32f6a1307329e881e841775be5f02df740e74d2910883c1086f561276a61d1ebe6bc0d3827a2efe166e58904ae76b6b482dd1b107867784cfe3f75ff147819fbbc777ef04def67f0db24cd23228c9f578d69376a9d500ae4d9c884f723f14b31e105c85427997681a27b338f9345ab2f8e07795525bf8db7c748856c05f7b4f135357e550577d0b64aa33133281346795f898b99afa7703214f7c9c5dfe26c491730e57e3b7f9c92a85b3053686e201bf5f795b5c7952df4b112bb307c47ea5c3ec6f6dc5683b8f0c87767323a83dfb4b83723f255b628125c970e6bf9928201b52d2941d3f94b8cd6340f9592a4ea2ee4915998a0d850cc67e514c40ba0bc32ac671393ccf9728c9d6649e03288fd1fc2fa6730b369e1380bfdce94ea408062fbd520ebc70834585ae5062d45f008ed9966a64729cc517ff7ad42a5ab2c78d55aeb5241836677f5bed72ae1aaa5c5d3f3814fd4294352b1536116944d25c97d3d55e55c2ca0c4cd69f6fb30f57c39074e97125ae8425e7e20a9ea66529f7c1a464fa7e010fa5d513c8aa76de769e69b3ec4b763c4520cb72c050bd974defb062a41ffe5fc5693a5eab489053661672c4b6057b1125739e50557ff374d47700b12c0d0ae9f4bcb8dd5a7c0316dbbd37070c4fc5702d5205b1e30b0070c615714438b7d92d0201a25175a086db4ca6382edd758d8fb80d293f53386cdaf18687bc93f903b2f6871c9da7d9717e0f2a000474cdcb16f66e0c7c1595ce0c2735bbec2a14775a1633e2fedd6381270f8573fa4f20adeb459e28b4ef95cf25fe04b2a5009f4c4c952b1f65e881e46d30e9395231cb016f113c722dd8bbe83f9a112a3934e2e56e578043fd2db5606395f5b73c03a3af758d7a2769b93214f92745bfa3933d13de15136758fc7bfac7b65a0bec4ced96fbda6623cdc1a3d0804c9cfc46bd9e04d3d3f197023aa3df20cd1f13458b895cfd7ddb269f02acb58e8da5a0f0ec9ff1c5775a3a916c3f271f936c1eac939f10cbffb86806f3654b2d6031e323c636eac7121adc38b392bd161c0475dd41ecf54671af68b416cc0e07d7811b92e41d8a93931908d2af20dd2d9b71096b101d11afec177753f7427efe26d5e68d78e5c0c588fc5a17875529535133cb80af7f58ec23096c23b2a6d9aa4c60c19ac22f5bd9900caab1379f38275997f72f328d0f2175bae6ae33941cdbc75c2ff8a5ecb14d475e545d53ab634e10ad3fd5e47d0e3a9e7944cf766f9a8c2de65be1ec6238110237be62c5faf2aaf3ea9f055a6073816915869c57369fe56b624be04beef5a103ab82dbef5466c179694baec3201657dfe881c8bbbb2d89f855578da8ad50114c0336cf166fc395afbaa6f83a5cae5c543da294d04fb797c1a55d5755154e9e6741a47782fe4511d2d2d12878f9cfa2b6550e018bc56575290d31bf64a86ad14d1339b9002500b95e5f5db1616ebd09dfa065fc7a9888818f815d1d7394a8e37dff3b7e57a15b0ea55dbfde11701a83c7a125758b101ee3ed7166388593701ed12ad96e2e5d79e604a63ab60f189a8941e4653f9e6667abb658c57e36b2048613a0eeed689fe0beb03cf269b0933f2c8f216258846bbe24543b15edb9188237db7366ec188475262f5094d44071d32ac9c2e7882e1e8a224975f07429c24657557815893e41a56272db0b472b75ce04228b9e1253c6d6d7e85b9d42f1737dd82195cd5bb246972ec7454f5882087a907edf29def2c8aa1b7c7d5f2b928af0fc10e5b33fe8a7bf3a19857dd8294e8f414015511f4b0d547a001028414fd52e017818567536a64abee01255d0a6d5cf6ea3c320d9f201090fe56be5099dc9af62151b3398d25a05467c9dc52f17bb6e5694b02c900c71569fd7cb9bae2d1256d8b0911a787ea7ba52044a638411e19b8759ae44f8f7ab220495fb69a9c2d5fffd004732842f9a78e1dd22491244f00c02a72d7da64bb87dda3a5d8625ac669dfb0e31f2d657934fce773dd63e7e710f0584ace4be6d82b6a7cb21e646e4a06259b794cacf1da3ddc88fbedde1990fe57bbe70e70ea3981ac599ed74381677848ca70827d104117e461f642e5af6862ed9bb95be85e01916f7ff1e65d2cca5c4b02180a8c7970c3bd3dbf4cd59b9058d2dc045e2ca2bb614e757f0911b46e19f6277f0cec772d65f3e9c3b96e3614f09494ddf1d220b77645c3c0e47df0ba4c51e6949a30e7a49a33c2a65c8b54f5cd15074a887ab61a9c6434bfdd65bb8e33b1514a1a0043aa06851c9919a4c3df58825f48ed4a68ab926d5c71ad2bd44b01bd31c95a0419a1ecb18d8f6cc103156186793f4f116efed61bcfa78a14a7ae4cdd7585ab607a6f291014c0e1ce6e99b660ce1daba035dd846e2b507ef7f36de60258d33575f3295570f555cb55b89c68ef9de61fc6ccf1389662f877ab3e8ffcbb2b80a79c8e92a368a82fb0032ad4ec3c65608af07b4f9a1b70b189ae4346dba0bb2c7163cfcdbf6c8f3d18441ded8431afeca53e09fd5c07628e4adc3912d0638938f598c248b93978aa9009d7ed14a85bcbfe6220c5528f3bdd729acd4158604b88c66c8c5bde862a54463be021f667302b239b26f99291c9b8d43ebdf7290bd5210b1e6f6776732b42f5b3985e7d1adbfc5ee10f14b8178a2e97f399b39f488ea9cf57fb79afb66ccdd9738d753b979957478ebdfba126e1ef05eb14b8186dd8dd4f8f6edc6e44705bc0f07e92890703d74355bf9d470952cb835e19bcc0a3bdcc8fbea8acb1dd30eb9e8eb449bbb11ba49414d3263378e536036b80a4efefbe7b1f93128b419ae887053104f486f2599fb92fb415949eaf0dd0a8b9723b0af268c7afc492bb154ce097c467a8650e811057892d7847d897f654a7e17d3912c46a3ae54a44df5fb7b4f2c0250b4985ac7c61ff627c42336ed37cb6c36482272bbd09a0a12e91765f1fbf68b3ad5e44b48d427636632bf6c7a223b38ecfc6d7c883dfc785eed52f9555e1854c9908d8f4314c239cd4a6a6915cc2d9a629f712ac24ec1f94b805918550d36d19ed8d7bc062d920454d24c5f210f0021560bcb3da48ad50cde8867293627275815bfd63109725fd88fb3ffc04ef663b272484e076b12777b0268a80219d5dca82cbc2740deb0efba4beb1201a7cc5e608b52151ae1a190d85adb207bbb93fd8e6557596e03cc327e88801c538d33401c6f4aafb7eeb588001e4b5e26d54877ace340ae5bb71104f70f7b30b3f4e0acc896fefcc171eb04147ee10642b6890d5801881c9c814239c30016d0ed09db18ee876b911ad1ded935283a9312874475a56f4ab79a4c5c96d1ef99b867339dc6c7fc163f8d3dee9bb0caeda1b32c97105b49d6fcacaf0e16032aa945505f34b755cc60de5914f7f787cb4f5c7d72e3861f3075667504f4a56c01f361b050d5a2d163d88e75ec662b09ab9646d39f575ac015f8b78efc81b35c873d84eeda7205f76ab9423449b859cb56f25b652873eba663af397eb2d85e44f96d85dc390b1f8acd4fd1e713d1def452edade482dbd9225d0d9c7636dff1abebca7d5a10d3ef788be67b746da48e6c5c26ce4298a289db17a849561b96b0e0a3e40af4a6cc02e00291c747891552352346d9b4c7e9b6c002efcc56ecd31a13cf0e32ae4ea607fccf1950dfdb79b9a38975422eccb8969f9e6ff0b0840fa1809380b1c8392a7100981feced5ef044f582f9578330b49c7ed05f795db065044343f9cc5a19e63da2e40998c9d90d03a203ad3dec5ab1f272c01b2d7edc060537dbcdb87690ba0483644dac28cb7a56850ef94d0d380862ebfeef9330dd8ebce27d26ab78b243eb833e8610b24f83e847dae6c1438d5c136c500246570b6d533694a5035bc6678dfdc17fbe55f578027accee8ede15f0ad88dae11fd8a887025dc32af8abd8eb9abe053cd754e3bbf876b7d011f549a4f848b9d3ce90212ae1dcaa7183cb30e0b3422526bc355ecefe311ec182164574013bc5ab2dd3eead4ffb99d1f0827138755d7e8fd14fe3d87aa157e7257b5c16a428f65c8f37290d50b3e7b34f16db18e1fc1aaeba61ef73339208c093e3bb814d3d305f3794f32808ff8daf9a6d372a6ae209d3b77aebfe68dc34e17c84ff2eb3c8da64a41fcfd2e624d5b63b752cad08197fa08120f3a6f4b09111add987c785b17dfb29fa392287aa66d2ad1a56633e8f95aee7192aed5483d2923375a51aac16891d4b4cbd32e2c01d1207e7cc497aec057e2c106839d35bdb3a8fa3a26185f363aa9a0b2f210cf2da278f57ea06878911db5ad540e20f37b04082ca86bddeffd69859d97b89deed7e4251273919fb804ac6fd47199f0a176f69f3868ccd5de1bb22d0db60a0318a611ddf60ad166c167e8ba6d51313035014a3f859182e8aaa07bcc17a45fdac5f06b2e79d18209d73f9ad3fb6b68de13cf4386382842b8a3f674a44ca08bb55f542d27b2b7620146822dc9d498a27c488e21136f60072483fe3dbe2d5d49971647868c77393fd24c9b824dd4e59d27acf699963875c06d06542a88d81e6c0c5c0c56b0a8420ab9e8270072ff5785dc7770407572fb9ffd46244705e71d4ff81904ed44dc227fae2c72f8a16d88969e51361f9d9651847fff6f828587d5c41497c552384c719f98ae9500aad41690e31dfdaac3847927eba10e17d2d1c92a7cf4b3677e3a036425c70c85426e88885209303b23bdc6fb09b0f4cbba4546af76d87c1a1e19fb6c778459388fa99eb56159b818e577f1cf828d162bbe3c3f48a33bcd7b40f43bfcac8436ec3559aa57d92b3ee1d1fe012aacd852953fddbd20a4e7ed0818c546ca87963254df8c864aa618388c17aa669a0cfce956599029a437c91230d4844b2621e5684783e93ed075b6aaf7b7985c1ab30e8bcfe9088953e0104acd168aab675f382d130bad2e9b5cdf6fce378109b270814f8f05a7936cf9d6e53ad5500b1cab1a3751098d387a48d523dbef540c5263e0c2a608fa57cdead7b8ea0a9b6fc79d03958af4582ae5aa11acfaee0bb7fff72f34efd7502d0265ff51a4065360df95e4cae7ba9b59320c950d63434c13259f9cd1245518a0c564e1bf618bf383534dfed57cd87837822248299edf9ca6d4e2460baa8a8c0cc332713d6ea76f401f1453e90b2248ce7ea980bf8089557539778ce4f3b6728b6ea82d9996ae86dfe15c25fb89ee6e31d44648aa9479f2f1607f9fb08f3a575baa9ccd880494a61fbbf078be7617a07b85c9e7b5c30694f5d603dcea862564c3935c96f80e8fe7453d960e819c07d1f686b0dd6ac144e72ece91bc85860b66644c71cf06a0aafc428d42a7cb6f65217b1916cb28885867297994ae663fbe048a84354798d0e1d40c789c82fac426a88ef1b55f31a3afe379da55e417c58dc2256e5eabd122011e8a236941925392db501211773cac0d53148ee00ace6d97cd50ef512f4c290a0badfa6e7af2e1dd4fc1abc533605024de7e7aa89f25937d67d3040dbb35691ba4c8a0d41c0cfbb22bbd7c202a467f4390258d7ad0eb0a0cb6ca36eb5371bf0d0abb22e97a455f1ca88ecf1530070ddd56647491d41a992ddf5c4b0e92954631bec62d1d10a71caccbe10dfa483ffc16a6854569362f8a924c52201b30b49d2c03ec76067283cb18f84aa9292d4be5c81df3c569d0ec805172d818c67f3105a967dc6248ad3f66c409bb7c37af848bcefb65f79d65bf083ae9ad0bf97976d86533a3359168ca59fd89ba1c796efe402bbe2d97d13229644dcded9e9d4982f47c77fe275d4420efd8d3511fdf386d77cda44b24700442d543c94886711d78e3b1d2877f2b729d0c61410b628fd6e3f8c8d98ccef0ba2857ef39e37b2042183042af6fb3a6ddd6db94ef975996c4b1bf9f2cdb749bdb7c893dedc18914732f13b6cb05289d8dc1fd8926d051c0d7ef0621deffcc812357e2f003f3fbbd6f20e7ec55f91b7b2911458416335ba319938eec6009933e00c6336b4ebe2527cd7456f6accc7b917381c830ec703fdd4d5ccf9ce3bce62e19154136435390d449424764bbf7ba8a1b7becd7382fb862e04a9a89194db0a599fd52a7fd406e7acc86132ef94c2bfc31697bf62ef95250990885775d356afd91f66d68b37666e6cb56af265c4561f56acbe319fdb459640a2bc0354fbe46f5c6003ae09fbb803dd177f944f722fb4ddddad208537e88bea4393481bb1c0682441df15068d43eb1809343dc1bbccee16f2b94073d4b2568f373c2786721741e6bbf4b700f04ac541db27b00b4c79425c8c0e174542d2a7a1ab42fa3c37a5d72313bba90ee7a09f7f2eef62f7f7a46b3f32f1e4bff2faf7a0623e75877bfed043cea446261f21ba2bd68a19256db626ff0677cfdd05c38caa428d9a1f2724bb99899f13fd27532fe32e38e3b5f0cbb5025d0ff637a699885024fae3ed04455a7991307b441cfcdf7ae9e75b73f73be296403de033872f3f3e6528af1c8fc340a3d313a7660b565355ed91113c1a9e064bf6b5d7d41a606dacbea509ad74c9c386f51339d7ae872a50252bad175219e72e07ec64e1474cad1b3a14ad183e913094b7751b77b2e56469d5bc5d3447e3453888a1408824ea834650d2028f353b8b4eb7f8bc5ac9c3104484a5e3131d2392fa9d768cdfa45ad9c3b932ea4c91c952356a1963b9f772391486af773184f4f02f1a6f18097e87b2ecbce7e0f3d5c08b630351da43ee6bb8df9827b5a965df84073617af19f5572896e454fab90c96cc80aec6fa1fafbe4c48b053147866c9ebaea9359126a5de7465a9027f527244fe61bce09bf7d0f6f88ee673950c2f2752f9c005df1bf191767912396cd5e6d4cece97068c7d8b91a2ad10a24cfd1ab7ed9f16582f3736fc760c97a37b7d92352928c1ff87df3e652de6b12b09ec39f8c10e3898fcde883bda2ac8b769f0228bb8ba365cfa002965f2676c0eecaab6fbc6a68377c7a0b921c813bb20813298f4e881b5b8ff701271f20f6e9a9e7450347ee312bdeb57baf43c26a92db9c45b3b0362ea6611fca9d330ded0a7527a685562be3b20843b4ac833058e788632234ff7042a31ad727652a63ecf271ba9d001cce8b2872cf7111a9292d3aeb2abc00f79200dc50feae1b83f34b461c32ca61f9a173197c5cf28978a7b9634d8d36150b782a2325dd94ef241757f588553c0d133dc9d3538676a73f584fac37f31e1c860c0e45fb6a9f31f998cbfdf5a0b8b8cc0ffdf5fe7c2b0396a92fbf594f071e4f42b867a6ea7d58915a68d5ebe552ab76ce2e99c0c92c2ffae154134dd07d6052ef0107a969424f76f4ac4e3242d7ef92a9cdd5a830cffbfddede81790c4d21ae95d9b8b37d969f91109fe276001cf47f45fec100bfbced4bcbf97a61f45f8340be051e21e7e7a399b6098cafb48210bb67feb2d2e877b3be61fb590773467530270214dc76ef87eaf14aab6608c47b913dca5a9516ee69e23c307e9e9dadfb2ff17a199061ee4ec894376cb17133723fa33638b7b705e549c56e0bbf296878992719df5484b3a015620549a7d4a23a8f3046567362a6a822b0c0500c69dc6ab7edb95b6eb5e1e78c227d760b0e2d97c21a1a8c034adf3720a7de946cb51b40a6746f0ab463f25e91d447b420d5ef8b5d552c7ea1ea781da89926d481ed401896e2cdb974b13fae5478a3262abcfd29b4534bb1a6fadceb14c608969a2f96ccea7ebd22ed0c436ae44ac14b077b03a0c80446fd9267cc956edd8f227e2f197ff540382b09b3e6fea54f44fe9679d12976dba3f34e182a88cf03053b6795352a2026c87d3474bc70756c616f96f0da50a5afbf1b1a9e6194765aefa456384553c6c957ad06cd189306a771336bf5a5f0c17fbca8ced3ee3c75f1519386e5fe42edb26477e02206ce2728c332584fab6a5e4c32c75ed65ba0cd5e3e5fd02985f1d031fbf525a548ad0155b3a9f905f2d0c902d897ec6ab6756cb7bf6a30940cbf8c4672ad3510f22ff557bfa8b93a70c8dfe117f60eecadf711ff8ef26bc513ad3dd4698890930148bb1d658a0ee1fe93d70f885da9733dc4e050faf2c4a1bc319f0d6e99d1cf80eaff78e8faed1d2f43c3e63bed6e05dbe13c79de5dde639038b53a35f048f2dcc5f2e850f375d5c793c818078919ca1424213a780665b10413b508ea60b4cd8bb7acba4d3e73d4286d3e0b9e54c6fe1fff91fcf688c9443b63274e7e25255a36eb43b82d6f52ac5cf1d0445a35162b0836a5b8dc3a391a6e2372857233a5aa41c4fbb2dcde880bcb963c027c7acc7e5be4d3fa9a4dd4426545f48b76fafdfa8e0c39349c669bf56eb20ef9b1d55c82f42d6bd232309b9cf6fe2dbd90d1c39f9f47807b414052c7d82d9926bd0ef3e2cf732f7ad4b41e76eb93903016aa3874472b58e9fc0169c8db7a19643165bfe0ba51a0716fc178e9eb0e26680aeb409fab859200f5f0aeef2a74cbb033a3e982ce1c09e6a5de0471f70a2b46cad73dfabadc86179372e7bf5b05316e218f388dccbd796e73a86783a3c36bfdd8687ada90cbadb349904f27a3d71b3a236a6fd49f454704acdd78b863370ee2381ea19b7bbf9c96394e5a509a2c5f3b733898eb7f3c35a5dd212c2aa6783490f1c06e5e89cc06dd2761193dc27b371b3b492df06a8c11dc704e429a060f7ea1764fa584ef128bfd69b8787c0248f1889c54705f665e304eafdacd520c6495088b2ce245717db53f0d9b6fe79b7953af93bd4cbc61f09e83a3f16d01f30f2917167149bec0cbbce7ca9b54b0aa943367cc26e00e8a41aaf761d3571880335fd4869c17875f94c23d864d7dd09262733bc1e80d43c8013a00458e4073509faf59f467cdf834dbd3a84f57d86aab3aeee9a72c264631d68b4cbadba609e8f422111aac687cb3bebd54113aefb1c0abaa03eb2a776279bc3bcf58f4883080d0530fc8e3b5ecdd1406d2d5dae796339e4a9ca768788e69d1d336c955e8696041486e48743f2f60248d67ffeaea12bf80c0167b163a01913aff3252401e12c05326036ed5d230e1db38153b949578964dcc180f1b79da79dc4e77fbbd37b39cab12c9598a143ec1f26943f1991ba599f9d08241ce23b2bf48131e8568e83aa0db7dbe78240e97a8e4e1392c649e9d9dfad8e53bc0950e165e42f9f2357a1fe8965a4ac50526d40037f9a4a307445f6dc144290ce98d4db9a5dfeec02ff8f1f33e2c33ddff41f0bfc621cbd5539e07ec69aba572fe76b0e1310d5d31a664efbdfb36694466049d3a75ff465f1a495bd86d2c4a8197f778d7487164d66ca03aa27dadfd7f35e3e8020a34146ff35910e9eff8678ffcbc32e7274b9539bfa3c77b59ecc67d74a8fda7e9d8595cf822cde695853d96450b22a1c22b750fe23b22af6eb9aa8a2d155c58d28a6459a3a1bd4e58c069d64e7e1b8cc63f3fe48480d1a5da2fce9789072d1632765a0978f98676bde85aa5e28fd80ea60ba508b3b62ce062f0557eefdb09d3ac9716d1d0722d830ecfc857730f446d642a4a8e0ca75ca182f9c8bc00c5dad8b05a224323f29151774ef23b602b71644761403ca1c7269e786342c433abba179ba621a59fbeee577665fa94288d582061322fe8f521e6aa2488e9d132b2c29501b1f3bacd58be3daede384d30c340f7f3bfa3c3bfbe92e66af1d243115b51d5a4da311e6d541b2596781178e237cb32921a6e11bc805cec842983769137809f57fcc5788a97a14227aa9e28d766a05e67c341e4accbaeb8b273fb1248c84df0dd71c42cd6d563d4fbfd89b46b4bceb804841e88523ce73ec292a99668822a09a2286e942a72d29d4f9903b293ac51755a803aaa468e4087af27f3c3ee4756adc6cfd7260bfd48d911730fee1e2e34b3359daffd0b7154cbf5635123fdc71cc1a914c57d61d6f44822965025e107a11e0c33490eae91eba9f68ebf1e4dbc7ebf92dc95dc6f160825e78ad06a133a1dc9d244e720a0de2624eb313b51d0d7a3e4067606790e38ba9f2ddac7cbb91373456abbf0ae9f48e9973ef40061941fd4a072f4ae7f7037163a8eb06e4f94294dbb58b8fcb260beb87f9326af6c8bb63089e9a5a0f3d585af0dcf657ec33d80b2a1386cd9a983b45c2d51cffc1eec8cf0358f7cb5348123cec4b7a4e7c0e345a43c5c3a4977d367103afabfbe87517aecab9f1da7f10654f027d35b617c89213bac7b626a77d7699e578635e7385eed802500d4579f497b91f069df092fe7a79040052c437b2dc64e4f7c1f22f7a26e320f457ba3ce7a406eaf1ea875a77e31847afa1ad4ff234032c850b6603dbdcb1d78e6f509e5c8d44bad3a90df4ff9acf279bbfbfda8eb56d6f9b1dd9c57a06d3f188de1249462537b65e9c6a0781f272a4fae8594b680b7b92f68c4337dd4389098c90c06a46f03d7c845979cb88920f2036fabf427458853ab0b92b511406481e14aef21f5232a977f5f40509c4699f76f2127e394e0a0aa3adb282e9ddd5135824c81c8e93ccf5a29f89615a2630cf4bb7f80b1a8a041324e850992030f4bf28ad1eec9964c2215186e2c4bf77ffa55443a223cff50cc37e04ce2b32cf63ed1d528aae9ecf71442f9bab014cdd42518eebfda24e22c5f229ec8c5e5b6f4191ec35bcc36f416c4b40a2c9e263899f37526b0ce4ba078fb57ff5f4fa297babc86574cd60fe29a56dc3353eab0d1acbd4be43cb91769df6805d2b0861278bd489ed90441bc4e5fe72280da81f826b88db92cb85579ee5c78059da1bd23cc24e0f35073e63a9f9453c852e11f7d3b58bc44174caae9b97e320bf35ca3eab64495e99b30c7ba0d87fbb2c16948ebce0cbd98b661f8f6b3d244c3e8ee455ac60a95eae6e94c5d653c886df8eb7dc93a3d203195b839f5ce8da278bd194bc5f734f06a221e9c22cf41f19ec57eed7b5dba706169f5fcc81ab0cc6d47380702c725e622d36a1db1698a792f09c6b884111234ac1fc591b5bce1f5cfe4fbe513bfd2a2f34b7dc6359664fbb6d5cb390c9c9ff93350d8d30fa5217dfb161a47e686c6ed00d4b263da1d43b3d8e4cfecc066de13ee3fbb2d0ba275b6a5bc254571f7dd6ea05f273e7757872d6f083f4b24c28c83e28eb25b00677ffd5f408a17e7bf3b56fa687d2cc5eb57d207e732aedae346c03c11492359c03bf5800b443f8198c750d9fa6f5804de0e63a85d8b4216bde5fb84b52a657e464039b2e782124d9e59984ebe3b4df9c1cff0ad86aeda4ebce6b568df2972e3d65edf6a537440c4d7656d96bbfa0de57030430731bf379ad78525d7c48072a442e2b94c73125a8693ca5768536fee8c5121babd0532cd1096d6c270b61fed009fdfb18a1dc816f3122fb611c9e0781502090e3c1865eafc186108231211a4657e17a24b5252a45f163c8d6773d823587e973daab3bb9458a713ff03e42fd3db786fcf8830f14d334cb648e2d96e48794b5c2c44a793039a8acaf44aa5c0fb21a6d04af1d6a881cde82d37aeb1613881cb442c5ff4853f62fb454a546dc47d0ea3c5c3a2468193d193bb641d85af2e318ad686bfaefada79e7a67a44740b95231310153d81cd4d7d07b10b9c6ef8597222791556c8b6799be78e92ec23742f1c4825dbf0e34776c8c31cf1d34c082df6c6ae853125c7b2ce354a229431ab292ac797dfa56f4a20ebc0a15517990d48eb26c183c8066d2cd08d33ada26cc7a27ac5330118c207cb1c1bd6bdfcd1c7a714ce7cec76c6bbdf22ea10534d34c3bedbd8125e2f1b7f49db86c54418a8f8aeee3c3847e8dc4e13f0c2a6b99030d5a4947faf99d4731211c202cfbfa759fba46fafab07c4e6ee60962c6a5399994f6067c5e3ac6d74fb3fbb374a322a43f020600faa3940c45d47c253acd2f2b7e2dd5e36b774a11c8f4175914d4adcd23d1ec3d6753b839ee42570349bdbc7704f3aff57eaee7904d109121dab88fc40ac3b7e9df99f7e6ba0e0fa19b2aba5afbfd2b0e7c45ae820cf418a01973dc369fb023f17f4e5bcdd8cde26e8c28e1acd7baccc083662d23266ba2a002bfa7e5b0774a1f2536efad16e12b3bcc8c03c8d367280d3cfe93bdea31da8de3966b53d2bd86180c38c94db6b49b0ecd06ddc51cc42483555ebe7d0847aa0ce738cb62918c4466d0e8ff72e859096eaab524d0be9d494fe378b09de1efb45f1685c1e89fecd888c11ccff9e3ac57afa9a245803b9a99ad0560f8193114ca2f70f0b7d47dc8d361f48ac3631fa4b1e9fba4c145f1a4cae55e04101bff757de90f4a09d192c6c9a45aa41b0a072af85a842afabc85de9d1b44366be258a687d079180d18d55ce2b9bf395f24f0652729e2936c13edf2870ca386d53ae40f13fce88a1683d1dca07e3e134674ccf4c11d83b165ce73e4c7ee3e013f09384501ae937c5f4417579839cf9f8485bc77f1cc1a2bf14d6cc8bd19ff2fdb2ed96d855f65e543e4c897780c2ffbe86a471eb50ebc57e062baf22e52fe6cc4bf63a7fd0bd503f77e34c8aab5080179b4bb0bf1c805d83c24633332b7723172a7c31b7654b6eecf5b0651e28c88f422bbf0c82b53381cd500438d2d16c2c524bab83531a68af51bb46c4cc99b01f813d01d25fcced5dd3824dbc07d33db178785d84eaa349f7a5c44fb524c4c1cf13541cb8b5c05511c1b3fa609b6f7aca7a0c4414dca6c414d4c45a79ac2227a207fb0d7cdda9e246c68c0aac74bece78013becff2ce2e6636ad04effdcefc862d9694e66c0b517a6afcc2a21b2b95632b982d06239b65a570118adee7f518e7d94585307583ad98b8fd9472b7995355d63ac1c7d18746d91794880ed8533f23ddbcc2aa53d306c2fcc6164dc65001970d525c048040a209b1d56b7781541cb72e14ee3d9375f478a7c820107e0721a0c7c0672df613e4ccc85f08d009e5fac9ff71a59eb68ddcda9777f418b5783e4660aeacffb9021ff17a5663784c2c541e8a075d3fa69dbb2e4e0bed244ae6488723f74f7ed665fb5e99c015984a9b7119f57ff292f608325d5e5f79875e3654d82bcd66910f072bf93c911b48cd28d2c608eef750d4d39be638e7fd544756613cb332ce02ad38c4375cdc63bf03ba7d27f9e815a4d73e2b6f5f680182db2f73435a2458dd77c27a26fb5a305c633adc4ff2457d996086ee89df8468ae7ff3beadafe28deabe36850501ef10237546df2ca1ee1ee3ce7840ae2c63ee049d35acd187a04831629bbfabf8c7f2d9a1cb30e364a125e0b423bb9939193846671455228d82683dbe6594b6cf45f1112e97757730062d78f8e6b03079348f3c04489aa9cbcd02c2161ce4c517f4d50990bef4299f010c32f30219547a2a116b4f750b58c1048ff72e5fdf05e75516d7d87c8a1d2bd3f62dbf6e27df6e7d608633e71467460ab005df8cf0250761f66676fbe0dbec721fc8672d00b27ddfc82c9db8da76f468e067ca4570ce0f24108430003c23444f5c0210fb5f695dace9833c190d9c898552dfddadd558a653330fa44c9a704837beff5fa11b610215e9e46742f81611c5bfbca5eadfdfb2afbd223a9ffcbf9a149884599bb68c8810a621824f3c4ec5764f51bcf3ca5a62409bf48777b13a51147eec05d20ab0af3125e895fa2a38a16800c13becc8c572c586c313f1e70e5d79e1eeab99190baa03abe92a0c1a80d53cdc0643d1f1f8c32af83bb453323f5ec205064132c9ca1dafc560b018f4dc22a018aea91551a8c88520ccbf5aca25c02b1e5457216aa6f5f5a9f71b71ea801388f63bb708ab2a240b420477361606b4b53427e6ef3eb8182b8c0ea9b8e6bdf844c29804b45f3902348d518719560354a1c557e93902b17e12434ffdf4545e976340252280e21333d6f095f21c38aed96248f050413507b07b68a8eae05f5619e13521db8696fad0ad7056a068fa9d72ffe88cc390e6db07cd77b1541d9d5494181b52dbe07539e25a37f68d67245aea411e80b6db05dd578cb3d9f952818d9c0940f886cd628c3344311064dd2204a55d700691d8226856fd7ba693a351a861db2a8711c56be297129bf1869d6fcd5cd90ec73ea03cfeb392ed82362497a253ab6fec70d2920280f4afd5b55de50a49ad7fe6a2d71ead6bbae3960fb447333611a379cdb05cc9d8c8d0af586201f64d989e3b243ffaeb041f8bdc09d94eabb82974e57bf7ed1d53626470c3553e295f76ab0ac7a84913072dfb601f22e5c0f320857d1ea4e3e49778adbf73edc9b7c9ca03777fe2fa4d9cc749e6820d72a4809497deda7a43373717b46f5081b82f14601b2df09cef24b10d17a7037ad6de75d031b66e0a6fb1a700b1e664acf116c5036e7395bae760dce4fdbf160aec0d630dda642b3f4750ed0aae60672d358deddc92245a71cdae940f08a536178dfa0ed90939027b37044f637ed5b85aed2fda23dff68093dbdafd0a4a3ad9b031b604ea8e9592d3e37e002ada377ce9919d2ac02ce18cab0cbc8a85e790592dba9a6d0e28b3620f6320b6b2e4d5e0d1caf5f704f9bb6bf5ce2dfff228bbff9f2d3d1ca482647542d57f5d6dcd77a981e9ca769abac94464009962661941b1ff843e1ed15011382211534ae69cd35faf4cd7b0e3fe3361f6aba71a8927e85dc9b53e626dbed9b1bf944b0f65964099c3f96f58e22ffb017efb6c4e5195f58ee177233c79034ac93fcc89541bf7cf9c4cf612b36cb8f6aafb686b91d1d284c6d05fe1e532a9d20ee63551deedbed896d2798237696d99aa6b78d431669ba5254b9efe5af439fa8b5a6cc5ed48f0a90034b964f4553c94b9b009f88c15bc412198a02cf682200c5eee0401a00f582ec20c44472fc6978fa701b2f280d02cc975e456259f1ca9ad4c536b7a7d24eb6ba0d06d0ce9ae77463c48a703a0d8cb6afd67131bbbbc11b21c675eb2b6c26bcca50155513f36fb80b0446ccb70d7fb49e5ba6507d31883a0b8eb00c299a2ee6d0fd26a5089af4ff6caada4c9df35b5d9a4be2726f9c1c98283fb92bcf136d4ca075c9ec360533ee8832caa5fb7e93401ae2c4aa518ac853b932bf4388e2a217f7d7327a137fad0cb01953e436582e94e8877f51492653efce03c67260abfaa60c0bb41ae09e83bed156156dda64ff11cf269706e068f7ca98733cd2b852d5584aee078194ff37c8efe415b87bd2e36ffdba51f4a4d45c94f3ad30b722fc3f91c0405ec9c950a1e95877641be79b9ee58c1a4cad8361e7dd8e56b04bb2977d42f17135ba5c863c44028895bf15bb2b95eab2ad23e3e097a0c5d775973cad999d5040dab55df89ef602b4b282442177efe27e0e79d3b1874cbc257892475b833929f667f9a61ff743aaf42a18aeb3ffc76c668f2128a85bd2121eb64148b21082182eaf6f76563b23176542aa1dc9576b1965d50cafe9e02e25100083f7277fbaa6f28f923842f06bd7a4fbb1eb7363cf595d189de80c30a2456c05b73c482c5e60ec296e9cf5fa9959a824eae60b719ef128f8163e5ebfd6cbd9692b4d3bf1e1277289dcefd937eb1ceabe726c8ceb9cb0fc3ad80105d26bc4238f3a547135f5aa3c8bc1fc77d00fcfdc5cb8d4167ab411d2ec097de95190fb45cbe8e3cf5c76aa9c90c5011b09e1202fd4351e656d84913fee7e18f30bd1d24b0ddb9e7a5a8dc8d0c4e11cdf43190b7a79100f3ef99c764b74d1bacae4170ec8a74a137530d921bc5e64f5909943687f682d8b83d5c5651c91d5f41b67c26f53c40827fcbefb3994e3c2696bb599bffd27b4c69419f6a670a12d06ae55c34203c58ed6df5bfd9db3b9fea8d349bd62d3db5ddea9d9ab20ed9b6702dd4917ef50cb8c6861e3d9a49ba8dc5d52973c859b25ce4eb570ab2f3bc3008a9b4a861475e155f50b0e6cda5c57436b1e3db95e5da65439cec1667cf7bebf215c21cbc9da166d9ff81fcbb85aa061c0afbce25135f43bd1e1497abb5582218ab0f63bc16f09315afb8aaa8c08fd18c18d2ac17dec1065e9923e35e5d30aa5b783924fbcc7953530bb8c033246f30a38772c34127fa9b6c9cfab2bde806eb7e08517404be6d7dc6933661a92e7b03829ec0e7cebe30de82c7c312771061fed33c8fbf6dffaf1f66068bdd3eadb1dd51a089abbb2474ffe1c1908c21659243e7c4e096598f4da7e2545e2cb9baf9e5812d819f722db41df4346625070e25072443c2583ce6a19d95ba6216c8dd75d243dde6a2f679eb7721bb44ac2641463f160affc21cacbbd419a6544089426eba266fa399b751c7114ccdbca458c1c7cc29ca9c76e135e83c5f21efcafd109efdae1149af33c841a62b8bdae9b7972c10dfe0c2105682b2560e4ddd8088265a604db6f21c70b65de4e36fd2bb3c97254a26e01cd57564461d893c6e75638464182c9c83ce1fd2a66830272a902b0e9c13e4add642e2c9fef584da490c6ffebcb78e4268d0481034eebda764e936441034589f2ed4a01c57e352a6bbf2f2278ea7ef2534255079ffa011dcb32525b3eb8e189b677eaae8dede39f7cb6ec80bb7dadd20b0613faa1ec081bd4b62df8364292b5e3d81d33a215d2f5e37793d583f642b0dcf48827dc481c4adcbb4c9cba8823a6ad2a9fcfe61fba293149181860ab4a4f94d9735edeef140100546ba84c5d1fda3a763238a51aa05e5fe16e3d21cafa8808db8e9707dc899ca339a7421ce049a71d831a7f7e68bc9950e36b79ebe84884ba9c16a9a8f05b6b854e7c2de1eb2a9e84e900e7394e586dcff173aeb0f5f5fd49388ff8fa1f4611f283af9843058ef33f4dacdacf26d6b89cdcbbd2fcd51cc947e1b32a8f24b3bb580c9c8466f908f54e30fbf96888316e911f22d5526d84357ea8921bcfbb72831363e13dec0f1b4be4f28e977eed15b556b4d3a811dbd723b5f4800b5ba628a8f2261387efd76b7db47b167b5041aca6097424ad0c7b41c12490f1193438287b1a009fa13dc45e444dd72b6f0f45594274ddd25e563a3336b77190e0889c3a938a90e66f21048d72968559d745adacf7d15cb11945a7cea45063e8adbcca628a9fc16acfd7a45af20f3446ed15df6a3ff4147af9b2ca3fcf4f416397b6edc2c646133eb0a13eebf17161f52a5275b2234698ba8b938fef01b838c66d2e6ce16c19d8e29d26201bd29a6774f267d241553c7c053804bec7905418b655110791b910fb7ef132b796c7883b096147abe28c9fe65664d8921108d2609a29b6b0168c62adf374aa11ae2486fb75514c6a299043794f3bac7575da4dabae8819ba6262accbd3a4db3775ecbd366d11ea491da7d0c0c4cdd811181cbfe9747bbb439ee29d7993647a7fcd23563c9ca040e71d58356d7cd9293e02e34f5affb5680f8af9cbb3c1880dd91ae341bb5d213875454c80267b71f28373f4cce374118d49cd4ae5d504912239e7845f525d91fa712838927750bde14f957a91c640640c32b36e6bc4316ca5e165174004764fbd21b69b455fa08c82ac997fa325e83e9c6ecab1508d14d7ccf1a2e4f4e897e3562527b118e3375bd43c2f9fc1725f298831dca9f2686fbc8b6c006d741502798aa845ca00432c578fdad76a76528eb256656e697b4f82fa7365f6aa53b67d179b5afd9a26cbbd21fc70b2bf8ca1443ce51fe463a8b1dcdd0098e2a37b95c055fe939b10ad97e534fcaff74ecf87489cc5edef8fe468087ea317dd49ac61faaf5d1d02188d88c3f960bfa54b7bb5ca4b1387","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
