<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1518ddd1a1360209708e0c39c26933f4008d8f77b52d032850079aad37f0ef98b22310f787955ab5bc2ac8e79a3f23574a0bf470b013161eadac5d9fb9f95ca08943d860c37f32ee1ebb7f0473dfa210f82bb2eac18e9d8d517bfc3bed7f10755b057cee9f0afda6a229b80078e42d4a0fdee6907eac61d2aa8329cff08e383c91957aa049d8b402a74edb78a434a1e49cab735e445092b78eb242c77be99d9b395b89626b24c410afb4357c3907a4233a987f43e1d79a110d5e0953dfa9857a093250f4b4fc1cafbbfd0a8a187e90a4ad8ebfa155007a07bedec96b036a4dc9ff8c7447910a883724888bbafbc24295ca07ec5bec3759e38370ea0334eac3b4cf4e8f276109de5867e8d1c43ff8e8f6e70276009d03ee42e3c5dab7508405fb70d60bde6706fbaecab0e59dadd7ab41a8eeb5b86182c54e19d927fcdeb988d02a00845cfc8de85eba6cd58d845b2977a2749f40b39eaf4ef5013bb2c09a967515ecd92047d322e4b264513daa7487c8ae342c0261ee209d4d4059b7c11a3a0fccf9b169d92bdeb4a2aab970b3d665c1444d01dfc291060ee63c5b52f1c29cac472ddd234a1af72b5449bf80b67cb5de6f050226f1d7b308b2cc29947bf0cb25ed8420ee089d89ba879ac6ad9e2bfc2f79351f12f2706ff0ae58f999928116dd489a1584fa3f5077af38d9a3da09d384ab341bfe49953b766d93fe5b8bc7a48073ede25b84ce4ed822a1ce7445cf02335014801018b5d6bf557f981026ed22c427ce1fbf9b99b586a26bcf5a6652ed3ef41f4fcd35941f8e805597414f8a566472416a607a6e3614a705bfadedfdab80c7d13487e9f27db98657ce6b844c57ba9a4ab178c6caa8a62c29ebb7cfe0644140516fb0c87452750a0454a613371695af5e4b63f288c20ec6ec337215620a720e85e3edfabb4710696fbe3863d50d9c173a6a7f7a3db3512885d45d2769124b12e70cc5cc27d5d39de2f804ec2bc3b199856634edc16733bebfefdd3a886c209770c2bf9bf256a137f5c4b59241d12d988f2604326daf15cde07fb48c8d7f73e3c440c602e38a287d831cbfecce96d9c35f00c39ef63e9056c7fc2fe70a95403acb04b2905e60c035c106b899b9bb748f15333c62acfeb5620ae9bf10b7774a772a5cd23df20c133b9757a90e5eeb42e843afc0e517ba48f00b64e997ef0daf624106d5b99ef7276313decdfa9e743a7336096f577347612010cead524fb7daabf7e796838a3effbaed5f107b576b606f05f72c7749083f4006592c2aa25d6a11f7f82b956b6d973e593d0d0743c8c3510dd782af7db7e325c7ef0406ec3ca8f29173d4d19acf8c4355470e204a021bc8697a66e4bf5d6d1b9880d1c2762d7134283117e70466a38abfdb033799ba5d44f4ba965beaf372c1f95935fea1700bbe4e9fc98f7318ccc92d7dc1a935fc20bf9be7354172b017370b46679955cc23d92143a4632e811ebd447fefb8641f6257898bcbb067df142bb89581262e16c9010336f4b44fb385ca25c062d69a0b751a88d14c38c90f0ff51071e673105974870a03d6d8f5bbba4592476d0b4090373611245bac0ed2deff3a0a8d73a8ae640e91d490ec370d6b6e374666a41f2ba01724fdc0dda92acd4cb37c3a949e46632895fb6d508af113c92a0470f9c9c560e0db4a640d6723680362e8d3c6029b12da86c4f230fc841cf69b13476e288d047e2c217576d2081c7b5f6e6a42a16d8b000d505480d52c528b7855951ccb251fad9e52fcff6ce86d4fcbca1b5680e1dc16dc7adabd763e6bcd98ea7577c709571040a9c6cf84eba837e25183443c4e66962ac49badcfa63e23157c3631d9434cb0f872ca001f882fce6f97b8cfb26a9a0d55abc33c960e8e8b80fb8acd4f335e59a251b89e752ecb66cca599f2e6860724a383000ba94c8a5f6ac8a66129aa789dba785a7bc6e39a0b8a10729a3da9144777fddc1da6808f467cce8374339ce17a67ddc01b7d4001856fee8172adc0d5a82a56a0a0e23b9bf153e5b9baff1918dccc8fac5d9b7e91c12d1f22760336d4520f8f571d806a0ae70717011f940ec0ddfa29dce3a5ed5a70cdede819beb9bc75ccf6c42201d264e8a9ff42ad0271d4afbead96c86b6918016391b57332ad31431cf37227a6e9c746da6a6ab1c562b05a4d2c5dec250eadca509c5d3602b88218cb72775124d3ba38800823297aacfbdf348877d2c09c2575741f2c9401294c18f2140c790cefa22dd5356ae5f023215d613a3d9a18b0f4a8629584b7a58c4dbf238bdb1cda5ab5cde9c60a22d026c3a3e72b68694363846facef010a753aed9526b6f4cb989dc3b93fabeb209143dc2d03883876baca6590a978b02c9a058fb0f5c27c548eab825262824d107649b897879939a65173eecb9d08e9baca926d291ca03ab023897dff40a8126788c4f57ea8fc4ed3e9c48a0a03fb61bccfe40a7d5f4cedaf61bd0486dcb7b4f02f90fbbaaa69a671c9717cd1b51727be02744592cde2aa5b66b9e05c28a295d08cdddb723285995ca7c214c74d6acc51b5f6b631f940bbae888a376aac71cbc63e689e393eb89e85e77b415525fe1c18cf0950d52477436fbf8cac3bdd93cf7d08e45330e050a6f6a39b2eca30687ce45bf081867e1a8bd878110259fcb308d60203c4a9136e52428469fa2a044bc02329decf1fb9e94c598d5260d1a5da112aadf9f1e99661e29e9e7620e78520b451c98cc0f17a52b7178600408b8a992e6c2c4fdbcc49562641e2b399f2cecf0410465c7a687c537bf2f882613ae554b84f20ea066e71f92c25d63a86c3e982cf499673a0c3739f6390c6d7bcdfde767482c300df992d96c867c4339ef87edb010d7a1efa316db0682c52824874ff4d6273aab46ef1da7bd012be7f0f86b939433eb64288a67bbd381e585853a83a60b1fa43b20a0681fdc7a94c83089a15bb1206f3490d63e0f1f45792cc921124d74266108c5e2fa249451cdebe59d5d25f0bd1c1c31b8202e8825fc5f05cb5a45c8081a60298b582ddc111e4c84726e3901c47b8e4558ec409077e49a57a542b1b054d7d1e65aee753ee8a8572a0263b65e0a0192876add8c8dd462ba1038029f9b79bd6844b8f829666575ade0279a904cb41b4a52645556c1e7485a0063bd0abce60d53a7d8642aa75fc79fbeb2f0867a70e441fc9da72a5ab9457d1c42afca8b9177237e2819130735354cc27ddcf242f3a6f3168d8e48b55952369e1116aa630159322040989cf8a2d43513e7be95130b9206f3132280af4ceeba9aa5a447665a5a5b6fcd12a426f7f927940ba2f5676aeb0a96504829af82c33d956534561389064b06a347a36effa26b05570be83e1cbfc1615061f346b78002eae1cf80e4cc261619c5c435659aaeb945b6000fdc9a1a83c701275bfd1db0c54b8d34234ba64490c8fe8865456d7c894f4f9c37b64bcd11f45b8456944459325f546ac7bdeb07715328b2a919068ea6b878f10b28d315e946651b780f50b96baad9cf5cea47f8cb92d0078982d687ad6dd0d4d68d40507bf7968d4821d0210f55e5b52f40ec6df15e2d6cdaf20ca5de6e7fe7e36a54ed0ba9c3a84eb2970f492aa6660f815172bab83a978c92c69900474755aba4b05dec81389cf21ee614d70ca2624b223382b516630efd4d727b9caece0bed25627b2a525710731379daf84061f621de65767ec333130739c2e4899432298ce4c2a37d0139e8bc130b1dc8bac6b79c6605dd941167fa97369d359ecad31175d7c09d78e7a6451c0120cf71b6164140be36c9cebbe21e3980bf1db15226a14f03d42483e5b1407d7500d9401ed8fa58bcec6d5963aafbfeffb49737adcd3b3a7ae9ffe9311661da7fc5109267dd29b1a278c9f55270dd526e533e494714baf00fb6882a5a4a12948d46300f008d9a0181a99edb075ca286248238cde070af4c31a9bbf14f0004fc0d35e3ec1d7bcba0dd489e929b3138fd40b70b7a1524d3622364568c3745d03c77254dd637cff224204459b8387e3918272605a8998e6051a286c3b79a5bd5c7314f8ab80dbec23e74ab7ffa3f8c9f40f4b4a9639b44c476c4372b4fb3d361982a100840753b0174fac5d696382a397ae42228caee78b775f7dc9d606dbf8fc2fee351a1f5de0092ea8da23be18ab8875677fcc303ce4ea603912259844077948519d110acd70f703c27159787841e48faffd14065f2e9117d571180e81f55a9527793dd07f0a284863e060937b1da8620106b8d8fa8f63020934f453f3e7c45aa28d40c51f274adfa4d14fb765cfd0e1603687f1e11e9ef8c076ab7b4a36ad108ba47a89eea35f3b429c0a1b6994a82e2605b911c1af10ab8e4faaed7a110a7b17c5c74e2abd24b5e258ac0df945871240d459974d300aded1fdc7dfb538b8805e93c0443da48bd54f50dd1d00188bd80161ad9007718ee54b4cbd2798795c2755feab2b7e3835b4f1c4452b1765455e4b734ec0925ba94289ba312d7978069067fcd3afc587cc4430e27d071348cfecce8e49ca00b4539262d83362bab880e59cb2858a83649ab0768ade5d31d27738a0c2c7c7db11511deaeb150bb72178b391d8cedf1bcc526fd0a86a21157ff467e693a83aeb4fc79e9036a8bc7878cc5cb15ec060024a4575dfabc1f5aee5ef75bd5976e645b473e5d0fe7c390f69ad5e758a5976d8f454d27f24e251c9594f54e81b33b4f6227fbe393077664d87addf207522fd0c52fd5ee606959176a7371390c29a5d5035c9564d2fd624095a0aa979337590a90e1b243e0f4ea53bd16b2cd1f9bc2ca3478a934eec3cc47fd8b575ad329869152c2895d502e873655dfc7b2bd3051c499cf3003d43f1265955f64331b173d1521c48437fabdd5c00dc5a8691e2873a440bac2a5ecf3fa07dc31cba90f8d3cea12521660dffcf995392b9cb0f8f1073afcd9ac0b251186d7bb9bfb72532ebe293771441142a83f1865e000e32764173a8bf9c4972e92d6676a9cf9d0944262e6e239c615ff7ed87fcd6ad9a8762eae96363a17773ed4d04b4d8b15590fb32aaf6f9b6549d9ebf1cc6b22b5dea783a0822a4b1ef36362ab938c63cf03b5a211d34698885b8b195a4e6a972562c7e7d8db2bd8bc607c73544a088171550f5ed05a6b18ae887832ed27f73875574863100b2f1d526c8192d3eaf85150a79d534bd3602ff1e598dac1a90f966e441fa2599f1bb53796e940aee59012c96278c3251d03ab6ba45b7595e9211dff005576a9c4c4a74cc090ab5f74803510cf610f8bb4f332913028058fdc869ae2ea521b175a932002defbd03d9f186aa3b5e681317706707d315faa520fab0434fd5ffb5b52b02f7fe6e76e7944cbb687669350859ae505b03739ecc156afadc29f9f0b3313a646dd5f667e147da8b5369e93185f85cebd491223ec1af39ca95c8af33e984490df7d33fe6e420f62353cf925620af80a91f7d87789f9b1c71f5e42633193334f2e22b52eef2f5e9b6e65545eb478ffdc04fb6e799b78686574fc931dedd10247db8de19f07c69121f5a84c9d6307a92fa0a1fa2fa5d5f5c8341188c2608f36ddd74093f5ffdaf1331cdcd35df449fdcf0d8236422e9762556f8b347685c8f5a3e7ae84bcbc21ed24c676d7be2c45eada51fcfbb26804798982edb5d969ff27be42f11fc4c2ebbfa9314f225d39075bf0d875c512ffe20112cf74d53aa3ae08ada2d2553a63f3e91a2a7a13661ee6d854955a18978f8d31a6834414fa93fea4835bc715edda878ebeca7181edb7b3dc35a0d0c0b985845aba84f2cba6e7714ba597f7bb51357253d30c961be5a63fb07cb1f3056ca45cdf86b5a9bf6a81c8e722457b7882712e4561436eca94527fb3357c3b922fd4b7ec080f5b2aa4b55cea4a8a42f1a6df35e8622642d133f895eea4576fad3a18599e6ac66dbd3b27a213d5f7fbb98b6d1a6b7c0a742ccf55b1fb546596b8e946cc2e8b0ece8f4c19ee84181b70a507be3f4478ba09aae9df3ada7d53ad6b6f5b19c311eb25041c9c2b444620b89d5bd9665b7b150cda12531c31754a08c759d6b9bf4f6a2c120e1190b694663cc96bb564086ad0ee7a7fdc5af22d1b8249ef11db3dbf2c659efad31848ff496a6b843bdd359ee27086df8304846e99103fbee7fb07bbc5ac4a07cfd342af502d2bb5909742036a82850ec001e8383e6b1783d537a174c9c86d155600c39c19a164013ecdabdd67a34944f345a3d3d520c12f3594d835b2f461791f7ed72415db1eb341f4f42da7a55a8107d09e204d2d19b5511e56b295e8e5bf96177fb7bcb3a3c81b536befab3e3730121b2eadeddb51caac189a1a4fa249480c706b7c026a2cdaf79134e188e3a8a5c3719e1eead6e7bb311ea4bffc8544ebb65d12333ee4f7c3b81d38962b5008f31f4fad090162c4845ec345905858b02a7fbd66758cbe8d1af4b171c44aebc9eeddc596b5394e1fe6bdf88a146c038032fa0b886482d88041f8b3b645fbeebf76a1099a273fa139b664260c17e504b13225fecb70b804f585804ec5bfab3655d8fe807b1f719658760d7b206f0dec3bbf1269e2ea0cbfc066369a1b04a22977814ac806292798159a51de6dbb7de0e3bbfaecdee651c314cc56ec308398d4813432eeb6aa7234080ce56bec6fb29f120482eadb55b429dc39218537e9c297d12ad97615303b81acbefe33e7674874d2f0c9e46b8a6f1f4a030523f11769aa80eeb995cdd12f4682bc21e8d6b15d6303441bdbdd03aeea3b4665961edba53496aa95b1d46cb571b27032caee6800b826e25fdd6fb7123859f82de0ae5be73459b901050418acd8d1e1860c20ab38983c333083bf62426bf71a9c9782cc48cfaf66225d932c2f35d35083d7faa6d57047f9a2204ab4c17f5a5b87b868918ffc0c70512bc1b4aa3690a58cbfdb04305d54e2e6be5158c2b1a4cc0dcc4161a87fe2aa1554c1a8886f014d77b7c7833504da2755b21b9f86031ec5df6ceecc39b72181e19d95eb23b57986115efd6bf6cdd8ad1f26c652e9b61805fe5ee8667e4e71d946cf16df5ee7a6d392006abb9a0ea2acb81c165cbf7e1314fe7593f967cb9fcfd8de696a634d09c7937e07b313c99026168d5c0927bd4bcdde29f053b5db1b0b15206463fd0073c94af091f4def22b27326d12df79080db9acdd4e6b1682ae97052b9a91ad2e1e2a543d01e25eed4efc3a41974b2737930aa3910fdf1d70e0e31adb4ec5e25eed6d7014d698ee1e86c35822eb2c6e80efb3f575bc5594da6c54244507ceb7143d04387388412011aaefa373e1eaf0a2feb014f46ba5e1e142390796c5a1ab68f6a039e2962203631a9037e86a97627ae96f89e1643db04da0685096de59c1d86f05f459dd5f3bf99cd782af2035ad2ca1c91d6510e0252ed451e2134efab107bdebc8b2ae526bbc5fba98a84c18f6a25ade48833adbed39b4eb5f50d32bb254f0fc282f42f0c87e658e442f9abf044dab12592641b5151bb500e80256acb77bbf441f906134a6976415365d0616919ac6a19496c0071f829124806ac402c52cd0b11f3a0598848cebc1283612e2beb3c5fa84600c23661082ec0151fbdd3b17d60c464f3c117e8dda72ae6f75a0ab7111a90c1719c0494b41ab34449ab290b000c395d7a38a634b1a08608f6b3950ab861f9831e147ba93743c43d8c9ceb51283f1c13bc9efd3f02ca3f341e7a4be9e498dc1fbafd9760ff01defc1a839b85070490f28a99a00cd87d73a6b1dbdc87b46b4eaac6c6c0c8fd73615bf645b9b19bfd78cb8b1ccd9a5f9cc9ba41926b859a0d8c6e459fd63e06b92338e1c8c056294c31dc99a77212463c7e7592dbf7fb0065ae887d379226d9720957a930d4c6a91c5f7c830d148b46991aad10bd5294a91d51ae04e440cddc04f8ba16cba074e5133bc82efd564caa1ef65e78e3cfa6c2b1eaa6668d6800d878ae18409bbd0658d18e3f50c2b064a074b032d5eaf13024cfc3b9f8b9177887cd77d364dc384605a0accefeb049d33571a21a4b9d13f348c32895d4b11e5c03bbed936bedbf1d61bff71afc2cb613c8f2ec8ea53d8ad0770954d55590ca84106160e2c6503399eceee767747d80d34d0d3925ef3d4cf9fce7edef2de0f64ced252eebbeed025a11ff06649fb8918844b81ae95e01313957644992d87bb3aee9842d4c7f06c938f59cbd93f8864200e969e2af50d79bcf7414e2f052aef1ac7e612600e7d9eec7ecf5ac93355c1ba57a647ad98b116e3b65b83b511c54ba65b99645fecc9777d699ec4afcad02d341c0f43c325f26de6ab371dc05eef75ef69836deaabad54d1143cd9f89035331f2e5c3dede0b775854d4c21ba36157cb7fd032e4860770739e182fa5b97076ded55c0c024274298858d9ce6fb86e2984527e28357d1cabfd452e8785163abe6574d03e0cd411177466726634a9c41dcb06a59da7f3bae831eb136c970e782f96f34bdeaa6840204b8b3fd92a4082902644dcc2226c791a44fe8c413d2406924eda411b80888f33444fc15613c8c229035d5eeed07da49028612a5b9f8bb31a37e1ca3a2a75c717dd6e1d3a25185de5636e185aae8cea0805625d51919375e704c859faf1ac61ba5ac880f728cfceea73b7c8b05abc9e36dc0c0913c5ebc8c7f7482b5a460531eb46b5a3ab3fb6b5d9e01ba0a8826fd2fe9e71c2eccecc03d41018eacfaaefca3868980d7eba9e7d3cc889128cf82b7df37f8330c54b6cf80da2c10ca763ab225575567b0a57958e2a29e72480972d90e2f4e69f988e2ae033fb27622bd189d2b7110c13d88295678a813a9eb79fac38620a0db2619a94c6bfd1dbbf2cf59985fdb457f380f9fa3bbeb7b2c80b81bdba70f40c64734ada0b926c4f33332d9df2975d0041efcda5310996fbd035fe5ba525763baeef9c9147c3df408eecc5ccd5db914b01b2741f6b91d67559a1bf6dc79160c3816ccf27d33d8690f8d3231b632b019685f175bb92356363626901509f8ce17a14d4a7a3e687aa8ffc3d9680284fc10d553d90b973636f20fa3eec7fde42bdbc284c6ad5287570cf38cfadb0ae143b909812c4a9ed4f1c77e27a9fc705a809bdafaa1fbb8fad59750ad61cc4ac4b3cd960fe2dafa15aedfecafc012e30db9d31ef1483848ad14e431a190aad6cd264887ec4a5a304833c036e780cf3b31a9916acc42f10395940cd70129a5ddd7b6fd2f7481b6428f1555578b842c77b5f9ae43ba5f01694e6faf4f87085aaeb859675181f1e3e369ea42ea3d96f386ee9dfb3f237656e455a3274b67e58f90ba008642d099fb0dc514f5950454f1f1264925fa944f45875078044a9843b9453f2286b7be01aa8de8ecd89d815ffd690039e7fe174eb5e43a8f8f5107d029d006ee32fa53c3fd71b7b4521b21f5602472678eab214e20cf8f25ef00283a05b5431a9407a32cfcf4661de23de578d64e4c373758f0fcce0ffd80e9a51eb2c7da21ff3fbdd7fde3fceb1352f939183e0dcf30373cb923ba1bfd8a559bc2dd72a459dd066f4389ceb01854d6eb7d03237f60eb3e37201e30948f4ebae15951a55873794dc4a5a0e8911a7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
