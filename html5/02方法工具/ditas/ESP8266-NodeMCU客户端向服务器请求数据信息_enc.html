<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"344b55b2bf6f957ba2567c603eaac8386740bfd48015f53fc3beb318f612c927393ab94af1a18991d7b100158bff53e18c9c80beb13fe1884c085308dacbef1cd70eb57f94cc1bd8627006f1d11450f127bad8b299466e17eaaeeeccb7980b6bd6c8b2ff78b97320c39b853224ade8ee6edfc93c137dd2d74a1b8a6af8c283647e8a608948072d427fc7a2eaf9cf5fd26738bfe55dd3e613b4aff6d74f4e1f0b70deacb9350be5900e8a988abc9af78a67d62ebe12657e1d695bd84a5ca2ed493be680dad174f6fd552affe26496b2da3d63e48da5f97707788479f3043f5464a39afa6025a7524aa3c1f2a569903ca7e0364f66bf30e14cbd5910ef56750cefd5dec880d2b55e7c0eeb8a3ea326f5b94c8734ddb18025737b563b98c355617be80077405e7173eeba0d3ba2aac13b3a69d7fd3a0df6b0620064925e39ca4a8dbb24ad92fe1c8dff2b71050c31028eb9bacd2ed7251cefbe6a44399306b534eb3253ae0bc78155bcb5377beabd8ddd0a2b7a7afca0e7ef1c9d378a22af901a127175190a0d49c3e8b5b16dad127697c630ba87cb3abf391fefcc7677877becf77e0bc38c0e52e3660a77d8e7e02cf47f24ba77e98f798edd3108ce8f601ca8167acc75e57a249402105716d46ef5bef9078b0e3aa7c4721f0fbd04f42bd5bbfea2478c8763f5c61299c79a0a06971122d1cbbe90bacfe782e41600ad7a55bcd7732a0011039167b2b52f6d664245aaf6688309120f4371131accc8e9c0fc7b946317d25144021a80126485b77f41d40655e828a3c9d42e8fef63ac25d71cd02971100755b56e1db75ced2dc46e8645a0ae9b274ef8b9115c54049e10e09eaddab5698a291000a2aa66b86e627b66506a08df55c26556be89a29356d2fbbcda353f8e6dcae5dbf52d750fbacc10524e16809db29d783351ecd0c348beaecd5d6b0b4522c178098fad1bd4406cf06a6e98895ca921e433e085240b73b437ef743b74a9570413dab54650b62ec66c8f828b27bf5524e280abe5fc63b9fbb7e92ff72f178642facdabddda8aa81aa13fca634c008dba22444ee95d30f7004810bfe10836f6af99322f0fb565a7ecf4cdc0a6032c41557689970641f79fc2b22fcded6ada70c141d0f1e8a88d148c053d4363074df894f0394748b0c546c335784f39aa03d2119774702e9c57504a5b149ea73bd4f45b70c5d9d42e29d6c8cfdab85da9d15f45e4aff2c62a7ffb15474826c967a4bed5605ac47e2440b99c01d014941eb3b8818a5c7800573987eace95ef88fce4b100dc48818d6237ef757ae1bea935c2f99ba431150d1811f03d9154db3e2844fe6b712f7a228f3089887c1e8eef3008603779217b1396bf4cdd7f583e2cfe93876fb76d3f63ddbfa3f47b1a89e76ffd798011860f18670d1c97a328c3ec02525ea43e07c3b5b3c23dae1f981e6d9fca95fa77f4f13e2edac58f382afbb913d3c64ab1f5edd99289b06fe3e036762f15159ff84c0ecc49a662f2e00efe3a314190d17fc4fc47b0c41e312d2e78662787dd1f5f54d34964e61a8c8d22b45a6706d13773c7cc9fcd37f9d5cd29ce425ad43ba001bb3d733e06e79d0e2fbfdc5f74a051c16bab14ebbd7965d6f553bc04ccb7b1016dd47ce49f7cb6170ab6bb5d46684ad8191a52644accae757e320225830db1d7d682b72c13588c6b4a0b89b8b3174574f6fc6376681ec9fafa22b624b3feefee7102327c6309f6e8655fa6bc66dcce163b1b4242b8d812316b652ae6fc61759ac50873988a2c8ffd560e2fdabd87c8f5cf65df70354a6e5cc09d97469a4848dcbe9db1cecccfdfd041559f20187809aac03881f4147736bc3ec32633fc7d3d973812f588d2a6a4d234a1685190f426bfcdb939e3db9f9d73223dfbe488a08b999e1166ceafa25697e31ed4e9dfba826d71984440345a62c09abc910b365bd5390aee160eea9a26bc4e85b2835ec88f308a0589177b655b86ec3948eda77c884cc88cb84e2e65d101ba648ea86c8ba96a0e7add7d1692bbb8609aa85b4927532d62ece713e4b55c1b2ea4e8e4df4f6e117f18e5090913fecfaeee06e4a85ccebfea6f4ff1f6e160087c01f22f1892be825966149344f7e73087d5f2e12f174ac887bb70ae2f7d79af2eabf136785603c6f22f90460873de926f885db0926cf1811d0ed21d0fb11a44c01a283c0f984af5f0b4f4fc9c185aad09769be72c369f9e3e529ccfddcb0eb210da45add4904d3e74858fa2d925a6b0f6a59a001d025e0f671d89cddfba23cda98133514838d912d727f7e363b7e8f022aa3f1a9986b7409475cee27b8f9211159978bd6ad65517236ecf38fa5dfd7e996eec753b18e31b1a0c1e34a64fdbc38f72fc6f53f60fae9d6c25265ed9c0f6cf1e7fe95a270f2b696cfbc4bcc636cb5cee19a1aba227cd706ad20a1422ab706ed6f2f76774e6bb906608f234c347b24fd263c22461c6b9f6d89f416a6c77830138bc5dd67fbe7ec45abd94028b1ce77dafb1f4cbed51d7d491f4cae23fa289d63710d5b998d9d9425781f5ecb37fb48d862315687d512607bca23d8038e7f23cd42ab9b346268fcc5ed4c27cbd2a11c727839c352df11561289679347b0515d09b7ea40f080db2c5f6b6f12c7403404cfd4ce7fff8ad4f2afa560dc806bdae8514644e405f663e7f69784c6e3f625deb93f474e2e91e5044e360bb799e53706dbb9848c8f67517ea11ef98613dc21140027311f30a8ef3832f19362de780a2fc3a108a41c729e4423af0e8ffa16da339e90b5f305154880c4ddfa67267c417e5a948cf9046f226c6696e0a4b017da581b5d733dd0ae40c60556ce46ec1fb1458798d366e07f7279755ad6f2c023e1f0fff23116bd0f43b8d1084aafc1e5c20f517cb4294fee65ccbb48f6abeea3d2c31140b922302b46eb437d0efb3173a51f141c7ae4718e680dca414a46c868715be8f524ac3d49f7d03624c7d93d25ab1300fb3d1d71130476fcccd4fe21ce0b6357ae37b76591727be42fdcdf599427ac4202354285b1907040d31c6e56ceaaad8a0855dd3177b7b324d7ec4b72b138332743412cfc6327ee42735b566a4f95dda2ba344360b19f5a1e999e38d7e9d5267b1bccee611ac6ef7112ae85088453e39f45b535a8946d884e0b9ebf47b7850bb07129da58c2a7c600e2a6865c91d975044bd0d047fd83dcff15edee62bd9c5b7fbc51f62585a1f1c2cb594ea0e08e0e1cae3aef3a22a2985e896a5537e474b617a67088a25332cea20f1de4ef0673297c43cde65babbfed9300d5760ec111336d686f74057882686ed0275edaaa82a1574555dd8890ca67e1b1b4ec35d34e3b12028d9a4774d85528e6055a2421648ca51ab747a1434e1dc389d89d19c1b6c031b9c49445bb87a912a31b6a594268b053a3bf8f0e27ae7feca973a7481c07da81ef5f3591f18ea9dd3160c08831a043b014c9149910e98174f31384418a0b834be8acbb694ea02d3bf088e215966c05b5d926823416183aeab8857c57668668cdc83a74f04c13a1002450e516466736d42d9f2709550c651cf676fd2a27c87907c297b3da9b6afb35a7e40c42cca7a5b7b08598db94396174b0670c5b6bbe4b9e9c6c003916f8b0336e0a0e373efe9a0b40256fc135725a72b3dc0cf9602520762e926aa6927c756706ffd5382d275101b445a51db5d0a976dd7f723003bbb2ce78fe71d817e252c0b703a672f621be269e92c697fa8d6fd73cef93e1174811687d7860c29117af4416c537f967b7513fa7b3c6f40963cea33aa9fb62ed3a1a5fa1ab3256f2e3d5928280ee316b8463681fc2ec25ab3add0e982bea304b50ae9b72399639cb6ffee5d5b6d05dec2bb289f7cd5b6c1cb5f30aad5df8c9025a6c9bd1582139d9aaa203f8b0fc2f8bf5802352ae5b4ad17a6b197b24e7e9862332504e5df7cdd98ac08cfcd4c34362557f4db88f5d41bf1735237211e18d237ad0d064d0e9d8df343e0768810936361bd6723c8d31a5e445bc974c893699f00e652299ffe23b487804e86a8fc934f14788c5a2cef8c06bef4a33e1df1ffad527dfe82b831103fde8d3f33b88a90bbac59a3e00ce8d6e3e79394d8a19a83c1cd62dd7f44fbd9909eecf019f32cd236d5f8d66acb5da2b4d266b934f2efdba35adbd5549249b7226e2d64d7dd2e1172f55d492e280f84738c9b7ca7cbf0de81c34c3c30cd5df7ec019b915dc3f4bd2c9df2593654b3392d4119101f91638008c0675ebfc4aac3292b8ece9ecfa69ffc9e4ed92de84ab25e31857b540ee2432cdd09eead526055e624655012a22b075e71dfaa4f1344d39b3f568642a8af3d557889f66b665e84ec97107e97e7acb444c8633e4de35f8390e066ec9aa885a66260bc208e005dd225fd7e5c39522bb26c149b199b88ceff687e157ed321cb3fb2565cf49f2af7b81f68b7055d3690e95f60afbf9f2ddbe3da1b49cec9813360dc15e7b53662d6c61e531e1cd2b9af989e8771965457951189908f08fe3459261b330917dca1717212b4433be5cc36310ea445d6906b9acec08744c1e94a7032c4018a3beaf700d42b910139ee07c8521d1459b5861cce1302e1b3787cf278605bdef6f2cfa33c316784fb14328efcb5305f1d22b22970768ae65e61f8af38418928ce0896194049ffe20d6c8ccc07caef5b463b1691b82d2b680ebf779adf2568d1cc52e98fd8db9dd20cac5c1a0676e4ce3ba7a41b81e272b3e571fb06aee134038ea141709e4c2345304789a0c0b11ee36476ea3eaf0ddde0b878bbaab7aa49d122f35b682054ac8d14adc42ee3fcbec8999140ab4cb82ab653e8da5efbe990a46a3bf4f15fd59c265535171da083be3ff08b483c1aaf1b1de8991287a80623087bcb47195d43b8c22c35062ccbd71679b800631bd13133e534fa3d979389de34490c77f59f434f9f9f82723e5506a17c216fb9a2b7c2243936296252eb2eb5be7848daeac53259f03a0547c19a403ea7498df0aef5cf8883a0d737035f8fb1ea10fe6ca7759498853c27a5a56f5bcdabd4b7370a92e64588bc6ccd588931103f2c086fb4552c077f7e78ae7913097a910a75a09ef5527633252e434eac490be9e2c6cb33e693fa34a8c719982c5d0eb3a4e9343f5c65cecc9c0e6d6a0654ce60734c1af5abd37af91c61e9c0306664e84c9d73fa5dcb99e1c0d5658a4b254e2978131328eb59d7070df374420d0e18be59c8f53b49e4759575a73916a7aa1c380cc6493f4e6c94bb231186213a56465317f88e500493d8d8f76d92959ad1c55442f8f71940ed78447cb319ea351da63b4467443878cd32779cd6e5722797f1e8094bad547efd37219a267085a4cf4bdbec0af973666f11decda78e142b0f31364535b5040a3d40048b6b799470d3fbe1f4e84398851de0a86bbf2c9712fd2e985915e9cc7683dbafa377679ef8c83f856144dcceedcc918e69316a381d3391820be6d8b8be63eebcf046978e64963e441bb1c8eb342729c9257199233eead219774e2a725efbb1adbcd2e42dcd6ede493ae7aacb22ba8809d7a5668cdd560b1c84701b9b50c8492d5ec735bbc257a5056f4082be0c3302e264d081db9aa760cbd5add66f57132458230623c08a3598893b2887bf1b2ca3cf2174b4eedd1112a5ea3368d1fed7f992a65d30ac0658b38e9277d71d4d2f7e500c47add49068e6b267db98502dc600483dde319e7545c3f1ffb0c30a940ec480d2b55cf614a45329d71d4c8e4caef7cb78a0745e5f58265e80c13917d57944819439dc1d872f4445c2193863247619a6afeb80f9a42b342d44d43201597eea0413cc4d96a53bf3a4dd9689f1b6724bccc06824c572df2652f7233852d91f18f8fa2fc7bbdc08187b1b1e73acf8f65f64630c567c45bbcbabcb4df5e45e8b9e6c18a904bf2530f69e44f6d3ad87862e87a4d1822939e251413a1f84c4434e6a8bf66cbe9b2a6173f5618da642c851e864196f1118d6aff9b66068303bdde597c1f78a6807a5336ea3717934db023249a671bcdc2c985be9fdfa51aefab541f91a9f873dfc7f8f567f87da27a87c5b0176d399e1c0d026885504b32a351988a058f8f7e5b0194fede3004ad22a40504f35a48026912455a40014061e5b3b8682e2ee1d427d8deb5899f973a112d5676a454cda5fba707fac6184291b67249edb09c43ee9a1fc9a2390a126254bc83406b859dbf0799d037a5dfc85d29183f2d5bb29ee2b203c3cb4d0843cfb66bef1ddc06cc7a00dfae5cec90f0238d5251ccd8d30a62ae1ea55cf8652c9adb4218f9cf23d55096435a5eeb6fef679a4f356e56b735dd41852e7230f87753b06bd471ebe8efd69423b0818e4ee8eda12469c527d912cd08b19d8d332b137bc7afa67668ed0786ae686e156133ce79f43cc2c4c0bda38cbc9237309331aaa662bf307712e914d9249489cc2f130f858fc4144ba4f56528ce0df579ddeca05859fd6e60e916c8c077e332871ada001253dafcae4b0ec81a54f5acd105ac44c15929c4eb42c01a4a6a2f1882611a0f0a30e8ce36106b808dbdb767a413e466f492015480303238964bce8b58401709f437a324ad3ad6af0c587f2e087a92cc922b6542d6dd9554ea9273bafd05bffea3b2fe2d35524c498a14d6d7df58a022056a9c5c5fc86156ef5d4dc2f537f75df1da8c4aa9e11688df3f8f060628c934d488fb323054eb941be21dd70842ce57a6fe5b9331a736255df23b1a95927fcf4e56e2b6b6a02797ec0c753934ba6ebece17d94c5d7c20022e0d73a44cb74a3c8fbf0b3c2d8c2c5f56cd640236005b6f7afa0c92e20ee013fd80a896e6828b102b1ff0bb900fe26e5f97caa5c78a503d82b780e4d343acd778d118277b06d639bda1374529242eb0bd71c4349fe9c259f15bbde5f482f176fe53a57a410ee45c157a59c3c8ae5674037936c3f286b37ab53dc80a45987faa6f8811310b3caed25e2c1be7079eed949617be40eb3f0b30ee16b93c89d26889f053444ab94a3747f4a3d278ad5c4d65ea8685db72c2705e37c2d12fbcde8c46d4430d316497f98f4490b9e52f4e6fbdee0a24815a17ee45400aab6579a53a8f95aca86d8c37eb27fa66c0a88c05737e682ed57b60fe9efc42ee4ea358a4c6f16e67a3f6d9f3643b3e7fa590cb5eb9d6bfe46c75b57460197cd817dff74882b17d53fb0d22ca316e87932cff776271af644ea24b25c8a702d3be3c0b7b2cb4e74d2e5108655bc592aecac1c8ebdb41cee31b58ca350a7e7eef35c00a83e9c8702c9e1e0454971d45df5b3e85f12dbe35b4054473044fa80e2f79a28cfa598ea575f1534400ad03ee9f2d8ed2a10f6da5a8d702f11a25d71646d901aaa6f09d268631448520af0399eeca616e685be44cadde4bebad36fd7cc66e14c3bc374df0e76ba90ca5cc4f271f0f13eb731c798278bc8ab0f32259e7c17bf0b6b38ad2459dc2cc01448facf9e1e04d5b222d8d7225beec061da17031f4d047ef3262fe384eb3e5fe15a02adf38bc4e0f4220c109a1e55fcc6bd2d17a4451b6116f96dcdfdb39cefd26f8add5c125e6163d9fd4483dc3d89458b7c76b6ab0e02bf187b13df2de9a69c7102903d6a2b155f2c77c8a8a658d5746fd7d53a9a785611d2a813117ea732c7b792a77cf99c0a079f72736739b08101a605b9a7c93e1e210841f4259c40c58e3c096c91e687c16d4dc42ac84d9d992facdc1395d512ecfbee53e5279486203b659fe3e89567d3b956c60631a9a93f860bf92e0484932579421a477234b6a9987feb6b813ea883b9e15e344135411b97a77837879e03245fce90c45ef327b598a01d71c6f2ce0655d86ca722a88dec9fd67743961bc07f12e6b2a83becbd1259a6ad3e8a8d7637d6815725bb83d28577446516d494162feb913a89d92682d538fc6c08cd0a2d6e17b95fc936fab77284312759987d02fbe1c2d117fc631648bf1901ff765a760add07b97f81caefe9c36561b86140b219eaa8ebc47d1461cc2bceee0493b39fb9bde8f40eaaaaa1cdb8d665ee4822990e0c1ba4ef63ac8320ad28646fbe5132bd0cbe8513cec04781d1fb41025a93467257f71a566f50d94ab3f861379bcdd94e2a055b0a69977d2cdce05545701ac8e8a3031e86c33fb3ef08e6bb4d80df356b689249d734f9bed2e4d8ba0131e39e02f69f8e981f89fbd7d5ed9e5c04f4754f9c24da0b5c8d3c8636884da8feb883742279829d69fa77e85427fd4fbcbf44a515273ec8ef1af1d2e682ed53365f640b7e3a315a9db76fd058f38dd08122616c8fd7ca2b72135e517f3e625af57d519362d9ebdfdaef764707a143fb6649e398c969335bfd73b80f4995b467155c8d0c6220382fa4b5571bb8ae4e951fd61a4462dbfa83ae94dc92e1e31e9c957d1884254eff1efa8e925f0b7ed3d6651579139495383e6b5a14cbbe455c4b50f25284daaecf07c20291b89426107fc4bf49a39d5bb3dd0481d70ac700abff320636b2c5de51c2588820044d3505c346d4df4dd2d93efaf237219b98c3dab55d9e30473a69868052e64e788e49bc3d71b81e9c689c8b7753a50af6b737fd9fb37b58035f3b2e8abf708d47b01030ebc004bcdcf788ee3cc41147a12c5a3ffe7f24aeed88100e2286713dc57e8d6978f9086bea3413ba5e515d2b3137c27898f844f304830094a977a6a5483744b1d9becc2857f71224c533030a884277b5c360adfe887a0a4843d8076a51b19dfa732de1a141a99ad2a214656c406328ffffa66ba30451f0f407c80282ac346f7251c324896700a81e5d694ff95b97b1fbea5396f08ead9cc48e18bf774dc24e605362c4a03ad85dffc61b0d4de87145d4d166ac7b59e1fbdd367a24d7c43760c5fb3554004bb887e6a3c08c2ef743f7580fc176f6b8bf0d8bdafead18063260ad4125c8ff5b78c51449bb48743ac5e56a84eb2e968a53bde275f6a3fe1c3abd33a4d4098c66344bee1f43f85e59d508f6db958136ab13f847ce24cb0eaf7d1f521be85f420ad6d9c19e8ca30a1db1e0ba3bb65a57bf594c0c88354e408e8d5fd49519114adcae704242542e366d2d68e98bde44d4b837736cce737ae4ee62228b386bc858b2c3cf529ed1852d6561d1b8081cebbbb7fe26d7f65ecb6c92044a2e5a87e33727b29fb36d74947a66942e7380c0ddf78f4719043e7bb9f18bb52f271dee2c8096c1d1ead1a762ad519433089e4d31450b482656743210d4b08a14901ffad27d753a1d99a4ec7982c203871fb46a5a81376cedb8691a0a0b9f48f1cb1af659b935b19b5fa3b19f2ff35ca693f6649dff9eec096ff046662c32d1671395571e8e90d2517daebc03b4c784e2d2b8c5ee83e45faf44a70a32019ecd10daea0a61419b1a9ce53214216b5945d4f49851802efcc0c8251c46b5d99a804106e1a2c081859b4ae9ca71bf8541a053829e9dd5bd155432eb02ce96b260407cbce57bb61af9a6988b99974f782edc1d42dc66edb78eeec2390fc9794a323b9631d2f2052e9bf559495fa9994d348546696126edaa92b01ff2e723d72c0115026d06df7e82f27887477dac2a79ab9cdcb014ddab9767f9afdedef9f08a2a32e400536afe3ade51f59b443618f84a0f8632f7227e92861f1852e06847159e7761196a6a3e256ab9273644521352acce165c9bb5fe94ce654066cf5bc53f49c115780cf54f80d7f140e1ddf9cc385c0d7896c91f1f57b9fc61741e44ddf061c5c0775620ea0e031278f07751aeef0a31daeb122c6f7613fe6b278ddaf0191cc8e89299608e9efad009fb9738e5e05439cdd7bec7395588d891b0fa86beccb3412a29d8600d03721a44a2811fc87e1dd5c54632886446d60d3f487041523b83199f73418d76b0a511f7454718e510e6af69e0a02c9d3e1be692879b3794059d7bd6646d366591fc03747ebb0b187a08f5efcef82ce9551122b3808698870961d8ce077297210625c36a17751308240a6a184b664a7314500f85c5471d7bb109e87fec6e9c2dc75faa9bbb6f34e71f2a2a1755b82285cb382136a199328d1712c207eba5e8693238c48df42a47dd05761d9e218b58bcd0f7b54c1306be8c5aa6f87767e0f924ad068e8b19c6d82d57ffc206e327ab174fde4240245ad97d285cd9f9f26c480684afea4dd37d87fa734a46a62b415b59a0be4449b7800ec7dcfd91218027265f5cf1f69f1eaf0c72b13bf8fd93b6e563c697c50b9ca3bae9e0625d870ec0f4a637bc9b639358de28fa0f6fc3671eda8723a134c1367c43dda64d1a8d089826d83e8c2eef2ad2d095a34f42b1c07b259f249ed1cf0103a754609b7230ab9847893d4061c0e651cb508f2ee3d9420ca000c40234d6cefe4a07ae49d26926bb5dc37ec64e4b03ada182acf8622b8cf933b98fdf758e04a76c1c1d9c48874b96ec23d65a63da25d2f02d58d66493ba9ec0e7e4e2c8582b8ceac69bfb325bebbdb0dce90decf13b477187ab4e918018710c809b16d5cc609948626115f32ed8639137332517dbf43c36e820e55d9e9605b1947bd72e7a53b12340b85fb39f583c5f73da4ccbc00938908579a48e768b22119d3e0be8ffb539ab9545bf78f8a0798a90fc5ebcd86a5557ab829ca328956fe781f155346d50b7a435ef5cd377b28bc18309f93bf8fcfe21a8162d56cf7b32481235684483b8915744a57852e826fc29a20c12a2ed2c37dfe52ee200494d45f64fdc8a84dd93e294750cfb8005ac9f909ea0d8e56f61165c2203e66a2cf646753df9af155316abd8fdab73bef9fd8db7bf7f0dd5d7748a683a24cbd545b1a4f319636b7b465fb1f5837ae2a9ce93d47e9a55243915a54ae7bc974cd9eb6ddbfd5c48329ca27acaa75e9565badff5dcfd7cc6f3f8497d6fb9e1a036a1b46873db62b92cb7f4dde4af53f698f075144b56b590a8705039320e11fd4d00d5ed2be4582e90fd68873a6f24eb301a740dbfccda5bb5dc47d916c3443a414acf6418700ba9f06bd35e6002fdc107975dcda81e014debb65425da6e787b10bb6b8a5e3c0f6879d775188529783e990660ad11df9c15c75e6d0746915456b3c7fe24d0766d9b3528b050369ebe76413b2daacef346f686f1b24ee0bcc4e8233f67de3266edffc94664fe3f784253654d937afc0a7d66202278b625e635fc72dc919e474563c4f30bb3cb6a68a4a326bae5a3cb119bbfe636dfaa0a4f909bb15c2b2bd3a41f536ba990883d5a515009f3cd329239499ca77248ae616ac22f8aa6685920fc365efabe9f7684a725359eafafc0d3f1bd2998c885d6a3be75c6032b23d2c206881a3800706a476a52d5167ef965457a1c29a3d21463655343c6e127f06cc29b2d94768a459ca4a522910b12ed0a50936c307729de902d51cb070655f44bf988d51f1bf5f4af42e2dea17bbb53ab892ba239f35a9cff42dc38b165f6559b8e8a6d423e30795496ceba49e92018ca2d76c14671699dce11082a54079d6bc54b9edf14abd12338044c51770a51d5eee2b3c0fd8d864e1cd999d417bf6b632d442cff1efae962a42b72d5598adb80a857d7ddf60883ee485acce00d18ada3359b5576859158c424d2b494dc58b7aad389aec1d34a0f261b502e611157597cf5217176daa8a443b440de1b700073be1643336b47144ebc71bb9c80bd08bb48c91bd91fec1c5bccc5ac3f1fd8a8efb9c69b4f7262d7be25e85f802f82b1a705c37780d833b6b6060875301ace941844d3d8d0b6a56c12809bde70baafe947aa6b72678add720e259f7af66739c38edbd99c7a96e3705883d242737be4c39442e965911dfbc4772c20bb013dd274088d76082cd34728b2fd1a8162ba81858c605251510d8d33af9eae25abe1b4f1ce55721d61143b805a7a5c142db83ce7ad3fb7443cf5e89dc2a1252b41a87b56a15d9cfce453746c2dcb06fa287612de16bc6c764562379ee312922939db7d24e292b195a77e132d108195126cd952c68d72c89e0df8efaf76b8a12861ac8b57ad28835181953385373de0f92e244d790f6ec92268db549b7b3d701a282202044908b0e7739ef9d5bf105158dcfffbb68f71ffc975de39572aa3fd7c11518e29eee0b465a0be80ec06d81f3d40f8a00c538772647316e5f654f2494c5a14598338b9652620a3b0b0c0063569efc5b4f301cc0a0802cb1911b31e5cc849e2e5c7f22ba6e3ee895b4ea5af9afd704ea99fc14a64b3a43f91d498a2a573d7cf9aca7ac3dd0300840ca82c340f9d8a49ef660c92543b94ddd4a71825b3f9469b3c845116f446a382f718d1d438a1f57f0ca10ee260be0bcce6c13ee7d0ab08f31b9d84aaa3b03e41f1f9022d139b484fc378a5e4a5a64c6b102d31c2ae5c260ed6d5cfb806e68626d84165b006272fb523b430fb5c8ba163132b06b0bfb4e04a277d03da260fc5db2bc1fb290da1ae6f51f9ce81deaf5b4675e8c53b8f89ecd0de0b0ddb82a1af49e9b6f2de43aec1c398b754021ca5f5e6a1d9ab9fb77aa26b2805d3ad25c34332996b5a3c6adeb8d1c379168155f6909c9a224f382cfd77119ff5f6b7e8b873710f71d4da0821a08b6965f3be573b6c3c7ecd7d5db798fd881da44d9d5f3589129fdc3ae8e91f59f9aab8a26c85743434bdc2b05533c708fef1bbae9f983a712d7281a1c200267ed6470931a7c00d1f2422dbbb23b86730b0db0dc4fe10859885b4311229715e78219cf0ac74ca97ebb0f52e43f13964e16388cc86763d79c71f730fc9d2db5974e6ade76c845e017968aaffaf87445ac5d9134a28f6a4152d6045b6ea2c7965d183c780347b0a156104a6f5442297b1f2bd99e43f96ff552ea7685d1f7314e8f12d0cdd27cc3dbb58e070428a2f5d573ccbcf79826b261041f2be554b8c77849d0e13a00713859d992cea33a1de0337ba757ea68c2e4f12582e89aece222a18872a08c361366c7af1edff49ac1e3e7d47af4f4ce2252d0c4e765ac786f3559c1b92ec4f75db2cb213e7e13a7d39693c2dce04023572a249f808d8f81d2710261516034045917f1a35e2cf47a07e21159e1408be47253fe01072f347e518e71cbf34e9e9a6998aeea330beb27673cea7ee313224ca76825c61d570cdc972a02e974b6e7c0bb42dee5003ffa30749a0a2d3fb56d4901410dfe100e0d76115832617daf16b6394dc876242c2b0f6cc0ccd5ffbb5628c6dfaacd6bf3a96d060605562e1eccd1a2f38e2f783dff5a12c5a15cb09a45a86dccf9dc6949dbfd8106f3503145f64c93ada6d08d08d3d446c7dd8e64f0b4cde44febaf9511601592cd8407ff58da9884bcde5a841ee2c450cfcfc60210d59e4da1fc6698896ffb366e53037244ad6283a0bfb11017ecf9d48be4bd09527befdbef74e849945fcd830e566560128cbb4d14b1d27940d335745861a6ae214b1396dbc2c0e60df7493e5e6d651ae3979f2ebc870626568fee29df809e897f1226fe663a9f0eb92397989c2ebf1317be95a538a5a2f26ed60f566083419097d0094195049b4514e57b739a1b37c541750caaa9a550d96fd36d7e356655fa212ab12ba736a0dbda2dce1df2629f2ec28bdddcbb06e6495da7a9abd5fe867d58743dd8931ffb9a75b93a0daa5cb6ca8b09a003c63573082fb9f79840c811273ffaa3342ec55661481f43d34ccc30722f1fa77106e5e284d59402f7afff505e9ce042231c415b15583c3ec9cbfb2f7189a6cb2c1209533449a25dd7e50eb0ed81a72b1152aa0a92fb8697da8d002645ac5db5eb70d23d57eeffe1a3117073edd79df2f30f2d0de7e895cae590d671587ec0d88689fa159357b6771d58a8810f0737f2b8cea0ec58c18b8ce5eb7daacac7d97214c54221cd6344de35a5152822cefccaa7b26ea32ca9aaffa6e7ca2dc93aca4de4c66b2acc06013a60f920bb17ccb19e10c3edfa792dc84fa8bea0149295a5151a7577855639c0a9c23bd73d397758c8b63403d93759683335ff3747c8028f4dfbc99105b7210c19d7eb1503f83b19e82abbb2fc3c6822d070d3067fdaba255bcc8bf1d996e0880f08797307cf6a61ea3cfb7fc4d7ebfea8cee5e7929e653fcbdc7611129ca57dcb8ad3bdb02d6c76d1c3dcde39cac08758dccd00364895665fe581e50c3e5e59c9645817cd4e0fe51d9204907b8ae9db2fd4b25e12fcd1581a9e451c2ae540dcd6bf1f04d5e214288038730e4347585525385c6c3d1245a4e0b171c85564ee0d1fbb01bbe98abf3740a30fcb15d493139fe0616afaff6093b8baa2f0c4818126f8c47850e94eae90ff619b93f9fcfaff62e11b7390dde31cf9fa15cbec18b410a2af933a3d721c88eb230f469bc9bde8e5e6ab90c2b4896a3efaa35cc19635f794163749d101ab4476e56bd2b62dbe43bb2bb0e191efb82c14b65abea5bebb062bfb52da9422f6ae6062d41b89f0466b6ba77050c97d6a3530bf9bd9df345c5e0498a4fa65cee3746f2fa07e6cf11a9448b987b88954b8664520d4d2473c8d5798b98c5cbe95a0b138a2e1aed7c909a574424283203977ce9a1cd8e4ee7baee4f592b657e18c92ea8bcb9f16ea0dcb7b5467124297bf63811d5ab4541a72b45a5c5f619ce37491f58eff7b3826adff1dac59b3e07a9b3d008d31019cda6f8db23186dd839db2b47fda5e475316c5a15ad274251ea7d26c55b4a2dd1193f4cabb2014719619930d5198fdedea92dbcfdb78b044a83a1cf0b866e7e8f5dcc3b4960c1e29f71f9deade7676f955cfdf769fb32af2bae75380ca35abc63695eb68d51e3558f7ce7687b6b5e7ce10a4d214b90dcdc05379059333ff5a1967809d5415bb5f95b33eb4c5e518d9981acb89fdabb4752bd31b1b5fde4e14f01c8e2f4e455a3d59b781c55e1508423ef012f9dbfbf0af0533ecf7c7ca4f854e2736920fe018a0c37f742874ccc05fec6aa90b8cfec9bff5ed4393671230719fd10511f69a8dc1eadc8adc2c42d1810a142dfd470f78862ea01df963e978803c65e874ae93fe103b2fdea63af89a548fc4af937536e99a2b0ca43b55bdd43abc1280860b2afc4ea2b1815dae55289ca9b18a1d57bbc1484955ab21b40137256301c982edbf91f83d9f21bb5b2cfd0d58593cf55a0a785e599ff2b64b5cf0a24a04f82767accc8aee4397b1c4af6dd49b3000214041c6ca73cab094624f105cc31129998ed068d47c8634017408b63e094bac383f90316bdb61c7c6a46c31afa2490dab0af13a39ca4eed5776e6df8922e62f3af37be0c09554f30c4a797f8dc16ca0ef7e14490a92706f47b0078ab1566acb2f6a30a22040d3d61e55ba055a3db6b56a350","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
