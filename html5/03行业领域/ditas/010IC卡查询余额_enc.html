<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6cc09f1a7eb1ffb0478a4d7d2bae2e9cb99e1d78a101ab4b471d82d14ca739586b5680ba452e9f903e01c8e931d40448944233da3557ecc0b7bf2889a6e688bf61ee663b99250f808fd1cd4b20bf1d1dc6e01006edf096ec3aaf88f9459587ac4d8f7ade49f73cb8a71ec770a5e90eeda7fa565491beae39ab0bee29ee04141bc2d51bba01c6dee5934ef513ce1e137e324dfab885de9fe461385a2c6d08c747e53792fe032ab76f090d20b694e5225c3ed31003be1b01c3a0fd7c70cd5ad00bbaf4424e5fd7fd2b848b6399ab0a25d4da8f901f17c2ad9b876dcba2af7d5bb2eb3f5c3fb943ca2e015fb305cb7c047e426efb9715d0be03f8fe5f221e8735ac6aa59b902a5933b722c69e8fe7e12603b0177076b06737d8ab65f462a26a6e9e93f66ce4a17561ad6a4a252970aeb0afa57241b8008bbca95f844c8465f26589b2e4a6dc35a24c391587ebdd5a1813966b4f77bd55c3c8d3fec5201b9b5c08ba42f9d4b1bf3d7fd8e284c009c65870525adff56bbb9234680c208901c3529f8d0febfad6eed95b08c60941541e890962b2ed7eb4413244c5187c858e3feda8d178a5b7758a8e0fe5bee398694e2eec911c6cb18c8488635300bb1a9b7a4ac5cfa38683e3d7bac0ce6e779eeeb80f451fb154ceb5f9cbb490820df4050cde00b5505de19d3092decbc03a801f77cc62542c9f2d579291690169442834274b8731749733979e93c48aaacdef2be0512ef8b14f737414764852028fb6256f9066cb7e011e18de8e7c3dc1503a5631cea03349adc0bc3245d0ba452c138df366f778a5c2dd314f7853a478e7ba07add3cc6fba4d38deac5138e03561f2b61d56959f3a8c45533c8d4e73dc35ac980b5a6996c9ba8ac9b2e2a6a9b8c4c466a19c4c73b0dd75c366d06f1509f8ffacbdbe1dc48447e3213da55907d669ee0ecb908fc9ea78b615bc48503b41886af7c4d5217f0e784e41a742784fe8db7a6716a208fd4c9850dbdec3c8a044c1b0d5e794adc065610b43550807ba0b9c98b4620306672526453fd4d8bae6544fc0c10533a29b9fdcc528e6509aa2ec9088b87a82db7a00b2f326ae9cd67443d5a6e7862bd78ba64565e53bef7e3dd3c63df99fcf4cb1b130eb9cd4d2c1120926e951c6fa156647aa1b754418eaf244c194d3e4337eb69f2dade69a731f5176be0e50dbea743a30a387b275131b5f7e352697523c6f52c305f31ca7646f39270323c7fd19b562c4544608c94fc70263cb9f38f5b284652f39e827232820fb9e177489d7360bf5468c904e17a5c4726ab11ddc9d893cda89fa1df02aa88a25fe8df55396147f98531d2ffbb78fb7c7758fcaae4ef4643dd04609598f20f4ecc08fc832ec308dc9c8723d9a5433a66085e07dbb7b2445007b9de9380f066f6e54e33dd320a106ee68fcee31cee5621b4d5815dc562f52a5b8fd02b57386a13d5e081d6b8583dc93299685f5ccce17784bc658c1e43357f34b7ef95c6f71991e4aea7c2fca74565f568027000f3c3c7e1b352c9c9f4981e1804b9a97cdcf679f37d165078c4805c33be017d2747674814130647043d82f31dc2a9e58fbec0dfcf6f1a6660f5c8a496bdd8a97ce996bc1d3d9e2a2e26eecdeb5c0187ca3fbabe8157bca1a69da98039787092d8566909f756e298a0ce3b1696aaf11f562001b737ab0b8bf9c178fd458ccb0965a00faf6416fbe71a31cb22a7fed0003a8f04e31e718442a6adc8d76ab114c1e9af802ec9301a469ae1d6d6b1482288ed417dd96b0d63dd52acb29a022d8c8e9f1867a559034b65edc04838788de543a0230d97c9bc3b28c09b03da8dc81c9a06905cec7decd6d562a24ea48fbd20d43fc8b6a305fb7187a4557a01d1e4bd462d2d41a38b1afd621d2c3fc48a314ac6f5d849f47d2b7dacaea2822d50ba53358aa8a67a7e60164271c23968eb98912044f10dea7315e62e01c6cb1e34319b47dd934bcfc57ae16636358732a0047f25382ec5d1296e7ace5e03e8c4e16398cbeb9416ac027cf5d448508719346a147b89a12ce770eb679b7a7b664f7d215e48cf061be6e2faf4e901c93efa3538e7b721d6184ee47d66b92462fdb8651683ddb5d7ebba17c5d81abb256dd38e23fdae097eda940a578df3096ceb9011b6f7495dafad5ee66675663da2223b2783930f804e8fd7781898713f146496f8122992d0c8acdcbc2d9bf5606e17d13dac3730da582873a5a3619f223b7a9700af2167373a521492db1edeb10e908110b3a89f7c708873f965d6cf00805f020f97d98108f7adfcef37f6153bd97df169564f18a510cc2b3e5b15ed1a37030e73b40dd6828969f5d41d5723a4665ade4ce76b2378f7898dc33fa84e497cc43a9e42b9c1b26dd58d67274b166d3e2fe0fff26c6fa3578f94f0fd144deeca7340211a7b8404bee576e96efe8940bf380b7d4827dcdb2b26b91e72269f20fe7b620dd064b0bb669bad6ea9c55bc5212a8173a9e2182cfc0a35462a42e46521a187f53233199a7ae23c88c0543bd623d125b9532ab38f581f2059e31bf366eda9ee44ff46af63632efafa03a7ff4d60c8ed763921b929b88810392136fcaa67418289e3b09e686970d9ca3b040007e07d0eec0a9e9858048618302a6e4e020a51f05980294f70b8c8bb9e4cdaa7a3fe802b8ecf8de23111a946489cc3b708e7c096eaf0eec1901425dabdd18d21c4852310db49f1bc33b5b319e31fdc26e2968707c86c1f6f9feae55a06debe1082f23a4860c41ef0d780d4e014fc7ebb8826b3ff4c752c3940a07a595a3f621b885e4040c44b2d3460f94792731131298d0c35bb2f564b5952c65dcdcd05d122efb46ebf0b5ab0ab54b46ce3278dff5511211431fa987fb75efbf674bf144ccd8671b7032fd91397bb7fe5e8b452e67d3b014bd84b97f8119c0fa4bfa469ff8926d10a31f26bde9d0bd0eb38943c968f36b9764094fa2d9d343722b124786f6e46eba80089a857f97427bf735ece9dcdb73213ba43c62360cc9a642abb5030965ba1a1d242cc08af82681ec82396df12d42d26216df92ccd66f0fd6f3db848cb35be32c94f3dbd1bf6709c75bf563d7037f81e8b95f0070e62ad0c5a81d6e8fef6a9937a0829d8346f10529e51b672196c9c73a3cc1aa5becf814c93145b451f2e54f9dc6a35dc5b4706fe6f2b56ae55dc16ae9ec00c39bc7b64d6d71dbd10b0b48d9684e28c2ba1bdb721b944ced513c507287d825b238d3b72ba040ffea1f2373387380eb26d6b9bafcee78d09a19b00b4e137c87aa18001c31a5ed03ec93158d1efc6f09f76a4a609f33f442a1e9055d443710a00d5426210aaa5565a6dd484a3845f867317554dd01be560898f66640fe31160908bcdeb3dcb2eac909d1496fab2dc6c7c7465559631113e7e03e09f9940c0897c5fa0475d7d09d8fd41223f6956440e3d05a1f836d826d187c4fc7960b20150e9b3c2145c70b004ae3f70e6158e89aff62954722e06db9837887198eeeee15166c411eca314f9a323c4805c1c86f181c6fd5dbec6a32bfae7aa0d6cfa97536e37125ee37007a8a518d28d592c34e4b4d517568744b00300ba6e38eba4c17da0fdb16014acc5f785b49962ea392467aa84c1e66617df5fe51de03200a33c0cc5aa3a6dd9c79568d210f9999d1d65babf58d4e3d37c39fc61e7d934ba1d6ac041c57dfea032b1d0dbc3e0839ae5fee5e7b419eabbf4d55ec2dcd3112529cf7fda4d020cbb9b2fe519fd2ebe91d702ce779084d08e2707420ef33be125c3c1d0f0188dd05778fcc0c52faa0df581639d4d642182c46380fca157c8dc283d3f41bebb2c25912155d48e523e11d142af9b11e0f7ce13089a6fa2e1d5e02ebbb8eb7850c362be43e4cd6fd7f6d51ebc7ea7849519c98c871ef7cde62bb625a693d3662b5f51c668e860d85ffc6d6d02cbe2df28bbdfb1cbbb861468e038629c10a54c6c7d4c36d96d8252aae8aa348b47a6ff064afd3a7c8b696d2b4e1df80f3c896545522cd3c52429b7eef7d9f5c185c582fccd1bb3c3c6f1071c3c97b28cbdf9749e085eb963a25cebca640724ec8b4e079638dfd1cda3fbcfe9c0e8cd78f05a797044dddecec7669c410894dd704d821927b7926744a31c91e14831447c2847d6b84b9c9688a4b9b12a7cafbb1bdeb89f5db8e9a347f3eba4a0433a1e5d6cc1cc7a8b2c731f1f59097efe7ed72ef7b77c43540151f5a796382fe48170b6a2c5bf137b2c394245905db7e47069754105410b2ad456378d0332a3d6ca9a88b5d237e9447b2eef4ebcbc046e310922d5e6cba198c97c4ef9b1260dce7b7c0da1ec818a662b701990ad3a8354945d780a8987c56ee9a03b65547330d62baffe28417ae5e47621311d8101cc9629a3eb7e23ece21e6427c4200fafd12a32aaee13cd1281ad0bd53e076f3c4c29387633840edb1c2e966dfdf2075f066626767ac9e50c32befbdbaf96b8e6c4cf1daeb1a9d482797905cc996474fef5843200647be3dc5f79635eb3cb964784f8e7b4d22b50fb57c1b957f5987f075f8c8be5141db27ad4703c9179caffd9c437474e7c6b8983ba7852db7911eef9892a50e338c467956afe0c31b92e4587d5208358f3cf4ea6e83e1cc85332afe7a657322646847a556050ab1f6b797ef0725396ae2d35bb297a18fd43660d1527112178db6fa984b61f511f8b3c02a1049633b3d57e4335f414d47b484680cdede91572b68d3eb457efc184b296b5c03c8851665f4ad7c8d5544887e51c1b4bf985686359e364d8768a09c0164d8d83120ab61476073200dd7df42cd0a542b4f213733ddab810cd1fd6a7f4133b780c244b8f4731fea75f576f6a09f823eabefc46bde3a5897f934eee73b8de43c7cec430998a2f273ec7142169d87455118b39a386a592dcf0967f33cbc5660cb57e72a98c7b0d9655ea1a36e643945b02840152c48a48521b2ba668a56179f6a15a2dce862cf0360e18c7f2d35d3cf1091285b98f3024bc828d2df0b2ce9a1e5e3a1b4007b4ae2492b0b590bde5a5e9eb3c5b9801e94d9de9bc938fba26bb7d2e0b1dce523378f8b3c81aa8cbf6b83c6000c2fad506158a5b96cea9cbf97efe9d844c2d3fcae1b28577c99ae61ebe28172dcc9383e445dc82159dcb719a2e7fbcd89a52fe18730524468489720a9e07c4ed11c6f9462467b14eaaef39d5dcfa6a035e24099e699ca02e6a58c9a6a3be8d833925a580a2c5f0e5cee5430a15b4582248426dc4e3ca9656b7760797c35500382906ff5ad33222821b80dfcdbead9fe3ea2194ca8de23c442aae60fb3764e7a2d62fb3a4e439a820db6847de42c9194c78eb8e7c6bda77002fa886eb882bdafbc231caefb83c88613c89092c34967d8227cfc211f0c67498c243ebd2fd1ff700bcbb1ec92fb078b47eb0e259b7cf4be9061892918030d4096874db8362fdc971a6c793a10e7d4b9b0e23c40faa67caf26cefbce975b0cd5f99fcfabe4714160002a20afed0299995fc4bf8e841ad9f5c2d547d056b48d31d24439b15808fda32dd120204f8f1d030dbf2be393a77d3200b6dc7a13f17e02e6848aaf85aaf2160e07f1ad7fe5daeee537811d68767175acaf020659015c7573b9bc3da33e2e40f62fa9b116aa724363c51d8b00a06caaa9220434bc8de50dcbbdb837c4d61e8e3f3661b9d579c68a2407c3f2fa37e9d7cb39d9d273ea32a08a0a366204d4b81fe6860414589d82b891dd880bc55270307a43c2159f8f5e0e8eacd9613eb5e5ba30979dccb50f920f597ca447579abe92068276bd1805aa68688c1de5de92ed276332de9fcc6c3aff772d76795783b1c1807ee4917ec878d538845a791fa5455651db5a6ebdedc9edbd791979495da31195cf4a38f2e9a76f9a519db0a2ecee201c5bce6945bc2219e3ae2f10fcb4e831ed4d7edfce178827f29dcd66d97c4264343b88e306e283e99fd83a57e55a10fb5873274ed411d63dac222e941bee165127e855362c0e5b0ed129f807ca62052d8dfec0c9963aaee46793e43603dab151d157ca1cf075b24370e6a9ed881070b6cd2651aea99133533bf2af9e4625f475c4679db1e8146b3c44e0fdde8977bfee8a27c2669e73db92adfc3c408ec749e89ea9562d89c0757fd65165023b552088c8d471307968c7920bb961332b97569f93358aac96b5faa8ec376b4638d236e3f37d8fecac6bd9430e8b48bce2c3f3c9799ca1a4c7cb24ef0c366d426454197133835879d4325dcd88bd2bf10fc3c8ff8fb11503c97452c3a1e107549122e2c128e6755893ce432efe3328121033a48490ec923bacb10d821be5bffb96098ca6fff455af0f91149f73df6aae3ea26e0d895b538db68fd2da4f0fa69e3ee1152d5f7a1cf5fd85d720002b471c321237dd0d84e776c2c06fb3d8a01d1b314a2da01b2b166470a04ae31c708f82e254350b3b4f0580e8ebf53de24ed1c0e86940bd18a1bf1287ef4dc848f2f45a216e191cb2cae5709511fcbd41a4b0494c5cfa616376c3d263ba3a673d62f6ca514a65cb5d5a6b8299d51d4ec05fd01c0af8bb0b36be8d10b7c6e3687c44fe419ee700f76e936959fa0111170ae3fc1e0e71df5e9aa442e47b41ba14d9a52728417635e092125fa173e882fba4678bcd9963461cad66d388d00ecc63368d411a2d4a89a4248b1e23977e59c4edea0e39278f9bde248b391d2aedee733639a29009f9d93676639a1e5abcc84579e66091d339199c60d1b2905a18f762f7891b0f71abc18247b2ca3edd68305d864915d6db44eeb6391b52dd82b1778693f7809d9a956e67f4c05dd51b38d228122f2c987bd7d46d434d40ade80bfa873e0eb1b8ed857fae17a491ff84e4c903e80ff656c73394c2ab7bafbc525beee4f7b22fdb94c56e1f216e2f9f147f2aa1a00bd6972e36a15840c5afb05ed5f5cd4140f880535a49b22a4d5876c2d8ed38d545a0451595fbbfec88300abeb3b4ce3f943102ca77968c4bfe5ae2644ca3d8c059791d43ab332c661d65b6baa18c5d025b2f4174897de98aac5dfead618439ece3c2477e13b61b9301bf9346628f75074c18af2ae6af2679da4c0d74f4175c669992133ee6a7ec2747bb898539c2f0baabe728d954012111db6b8e55811ed735154e343eddeb9eee059a423255450079dd9ac9a6ca50d011b94d8053efe1eb7414723e2a58128444ad8dfd9dfe5e09814897e9e9ee32239fce4ea61dad2500ca1546354aef5e78f567ab84b857785a56648b30e6477d14e12e9a3e44b8240f48ff8ea2b120dff7d4c1d2090f5d0e4d311d098cda14fe594d60e79426886a8cd6f1629b5b3f930f3214143ab4435ebdcbd1b8800c8bbc68dfd23191267d27b2bf5448896cf59f1f335845517b97dc7e1277c933dca612d0b4dffabe553bd6ee7dbf0f2a32c281e013d1423280f8d209a5afe740e1180e2d2224b84b6f620d1374896da2d25ee580f56fd050dc5910643eff4e89064a210056a3bfb5e634c40c9f7e5fbe49fe61624c13619f20148873a1f5645cb569aad1756f5cf9c314dd13a0098bc3cba74e4fde0d51a6bae6d7323fadb11d2f461a646e38c67f6768e47fc1934c995481be4b9213037d1479baaf7f46b4eccabfed5bb0139353ec4b13c3812e9a579956b32f62d16bcfa5c470e4b07f6c44f3c9e93e7b7c8985df076b73aeebb4d75bbcbf6a0a50533158bb255317d9457071b3c97e0b7ead867d7c335dc54352ef77538ba840679b01bfe59e7f2b30102ed3fcda0a2aeda0ac5143a93c831299cce877b4dc94a8fec557e5e75d2d2bab379cab4db3a47afc39f7ce04d935aab35674b697a8fd262c390bc3dde4451f4963391c0bfeb1bb7c5f334e66dce1d527e36a1ab889cd82baa5569c8c0ac64d21544dcc96863bd5bd2e290696574e7a8a639859aac34f83dba2e784562ae86857ef22193671c2cad22f0fe9da5c7ea45fa5b2bc00440424ad5e586b6c7438048b44ad9c56abee457536b2b55f60c16dcd8ee7899fee65f3dae4c608df8d53fe9d1dff1f6ed20e588bebb1677be5036e925bcc998f7a993c99cca3598d1383fc92660cee1a112a5420cef07f28d19e1ad3d9d35431227ca6af948915a11e81916b268a5e3035ebdedd95f63b16e104d764ada5aa5dddf2aedca5e88874f8df6e85da9224852ae3ea1bb3a3b9892bdaa5a0453daf6788864cfa785f40639d11068d7fc65d8fefb52d4a826a588537bebfcfe6ce9bf3322f85440f3d3558266926f2e6c9f0a7ccf46c5a67d5d380ad1201fcc6e75906f8639501897998cce69d2bc4f2c9b475a6d7651a3ec0efbf2647d436f535a6917b2b7f4992199a0e898b85f997fac0412e1e69640dea4cb3adacbac1c472735cd961cdd326e6431ba5e1b6563775bf4100a326ee75375764708f11fd2ece1ca8840b621775fabd948c1384c93e22ae28468a76dd9c97509d3ddaeb667e81b4d84c909bba46e0e1e2bbaafb90985e762f9dac9b6ce98604a1a82893bc84d03f9a34b6853c95434de7007b7248e40985273ca31a5862b7fb5b36f670fdf3698f945faa6595143f38c0c26c68453a26ce64ffbd2ff83b56d905cba7ce4677e772f9d0517c3f97d539229fd2e9eefe6f84eb2e898e5ef32c62a69fe46a9b92a161611d3088faf0704a8fd0e1bbb86b6d11440573931631ad81e9aab02fc0696db2925af61a3cf862a6b001e731d8852da5b4068ed31f1eff001e4061b8de41411866422c9b44f812cda14b5f2324d9c61efb405e44c88acee79450dfa57ab9de1241ebd5e5b112fb3e65cdcd12b2d1fb3787c79cb9538d776be51c094cc21299001c048e7257dc69dffdd44f3fc68f54f7dfcd569e813527736258e2692db1fa0c6d4c3bbbf7eef1383ba6278097325f22dfbbc94c90ec7581fb14314f4820ed81b80d713777b6ea771091928752db896695d77f8439b94ffab04c0118313a26b4c8e80b797debd6a7e6a3dfcdf61a6bfad0a033c6176346c8c2cf7f025f22ac81f1a222cc4e78d9ab25d1c221c46872a250b95b849d8243e2fe20fe667c7781a4776cd54d0c82413c11b72093c74ab6e00378fcd79f9f0b6dd8365c1aa9035515f234f286fff75ae7207cf653bbe3f3215a83c2a2c502662c4d1c5d5bba2f4dde3eb1afc8e743861d66af6b98600eb483fd3904d3e53fc717d9d3370a30dad0c831c25905830a9400280d908dc5d6ddde59582b4f7a0a816edd9444cbd97d7a20cb9260c1eb29f91634f027212a85f0242eab3ac470aaf905a36a25010daac6541545c838ce36fa4ceaa4ad5a2f58937e86e347b0aed688d40cea316acc4c6220a900cbad383a5af1dde6c700cc208b3e7a44ed494af974c10241802305835a2564781b060f3f3556f41daa2ca8f43a66dd35c9a4a5e03c6d3707d3f83f3b7af9e5eb9b2215fb3a4b65352fa47df641c4bb9fe96a59430f6e528c6b26babd18214c07282af9ab9e51ad064f82d08d8e7dd73044cd4d21feccd0d6c0909f42c19f483db1aa8abf59d0f8cd6391a157b87b424e50f8a18a9311b2455c6d0b3b7d8243d504a5d926652f11b416cc2329223eb4abf525af0310c2650eb9a64748ad192a7e75fb1e573ed7efe2fe41c4c4e55dbdce2ed261e7dfe1440ace0c697ffd43928ee8af66d78ee9385a41170be7ce0968f6bf172ccc8412fdbadf5da5e659229c64883f75e6f6006b472f7111e56d1842190079a90354bd4d68c3d1bc0b86f952ab308c12bff6a3d45b136a1758d75968c9c1751f817dd6366ecfb0affc9585e4b830fb082de20eacac21bcba98e7889ba4319639e81ed39b6c7d0a5b14f709e7b1e844cfd9d902d53f5efe0bd4ba2967726de63c4a5e538e434c3e70245d5a131f589a679ed97f1a4c61498ba43af56e94d13df73329bfa7361ba1c5dcde568d50f62cd9b068a2bd45697a93cf397c70df3e50e1f4c917a33f44e2e15958b591be64f25ed800883d794ae7aa3a24cd2291fa87a5b7589c7a44251cc4f28e74e0b5ede4c4e95de18e5098074714e473290667fd07c9887a7337371cc2fe45a8bf724e5953cfd4d8a243659ba785fc5c657c431c62d45bb29f66fd5ce1786e62cd920a496171140ea761c2d363ec654eefd9398e655fc5d10e1731573c9cba9e6df2c3fc0c701edf997c6f01bd29ec6436ade6a48908fb70de14aeee3fc580af194eee22615a0481e8de4b900f64c90c7291c343b8fefaf86d613c23c1f27a8df8ce674a52dd854df85f910ada9690d960b8a8b9ff932a03951cba4ab9d8540e7075955c0344e93cbc792c4c5fb311c51b02cb02d8e4636ce07b36564c40fa096ff71fd560ce9b0b317abc23f249650e164ec14043e165ea209cfe0dbd0be64eeb24e96f1d7f9c398a003d1856a37dfbad2684cbd3f5b7fc1192a794196c9cbc3960a5851ae2d286c12b2aa63a93c7d70ca7d02c75ace5cae1b0f25d8db998a48d51afd21751d764278f1927fd284f7c6526bf5c6bd4259c2bf73d448e3925f947a0164d4beb81ef7c785c467a46adb918334d374c24dfe379e6020cc4c3a215d0f559091c418e618b4932c978ca7d2f7c4cd93bb956ae4e56b7b60531a5ab88f7c9ea7f8154a2f30bdd10f20ccc064b5b705011588c319c0b85b6fd6d745cb0150fe7e950a45f3286bc5a72377963513b2fcc4b76826bc3dbc9dc6bee1a335bd6fe8b473fb200fdde3c6964a561d7b33f5cf6ddd6f4a8d96691d57cb9e2f4449519fe041c0949863e85bd5f959c22460854abfad5778778c8aef0d121432e9e35acb6bcd501780014c051a8f9247b9d43eaba26dd1fd7ae116d4f064246ab3b35f81044d4bb31680caa345c6427b51fcf5a07159f60f5445ab104ca36ae166577743ecd2ccc52be178ad559e44590a48e4eaad9801ad501dd882a78ef773a1f3e82d87067126345b787cd959516ba35c0fb209b1ae1cdda941e86ff0c6243e5963158954cbc40e1091904bdb02b90877f695eabc1b347fca88fb9e3a7c07aae765f6be78fcca25ee50e0dcebf0b00da5011fc44e6314c323f0963d2b87d62e98329627406d639a0d142c11e5e5b552f3ca115d7bfbf3a9a3d1ffee576f0e9f847345503350ee0b88e7c49f11a86677c811e983a24b5dfd14344b851809c801e6d532b7497292b43fb0f3815788c7f334ec9a03776e4f8875c50dee9235490e0cf4585b5c4f3de151a0779247b3ac932b362a393600225f7fd055e998a7bc2fa5706ae95d35bed0a80c61fc6bfdfa91df34dab1340e8619533a5fa14f823a544a12d58939f8f1615c02ac71d87917bebbb8b68d54de5036774c0368adbb0965f0e86ac44f47353e1b5aaf9673d6ef5c267909ef2ee453ddb8f1964d0e778d8baf171916cb3143a8a6a2e03cff67f2be39e929421e1b728a80cb4160e7dc9651c63bdfcefaea2dc6d7c5e69abc7d01eb9926922162c58519feedbe5e8543412880ed3f8b15233fbb2383461e4bcda22b90d793987be0ad6a616482c5260273c43817c8d7ed1a20a8b7dcdf64916e175a8851acdc92fc623135cd4962a783aea8bb9598e7b62198305eedc4da3ea3b3fa509d482abc7551dc9fb99f1ff228a6902a0b70be3493c1aa19d12dfb310cecfb3eed86b3a92cd85f801f1a2ef5b6ec03334bb1db2901d0b5c9e2a767545f1ea8b9d2fb3554d263fd8d80b48aff97ac30ce7eb28289216973225362ccc2ad543ebbc5e8ddcd7198560e5a619a3a6d12dfaaf05ff6b8424bd34c9c846d9e70b50abd609a000deac2e3974b47f068f0650dff0535527d11ea08b83b23cd8dc3abae0cdfcd47b0049e5e7147ef700a350d89ffdd9fbc38454b652c59c34da0fd87bd08d3a0cdfb4c14230dffe9f03b97bb99a11bf532656374791300ce62a169c3b51d5fa570a8310dbf7b21f5c639261604d8cd897a5b5f482927d04db18a6b5f1a3b63e57d642038e6dae6bf6c78a89a3c04f1337d99eb4a96f0b5ca331dca61cbe452ba893b3e20d6ef1844f4c9487d7d3c9a40c8b91b91d437e86a3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
