<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8c10013b6b0a3f19b50cd70dec184e6f0d3a7707ee49bd7ac7c77ec33ccb1cc7caa8b9d0e11eb2eeb3e8982ebc1ebe36ea8a52973326789aa5767dbf14632dd059326b3eca66bc0086458710ad27e81a8963baf65a0ccdbcf08f32be41f871944308df6c9322c4d31622ccfa00200ef56390f19959f2bd7d918a017d557765504e0d637ecd76a686e31bea7ce4a8a65442d9742c2bbe0903458552ba1c69389e6aeb6a31bb668b461e77910a38e3f6208e0363655eada9b67b70e32aaf9abe0b2b78407b0d09efa7987028b41d9949bc4374197ccc9056434c5385263123225b4d8d25af9515003d11eec496ade7d90fd208ad8ad638f244e886a4c877225a7becafbd93f6da420c832f7202947f7bffcea4163eae4f73c1c5d30694de0902c15fab32795a8d3dfe599e449d484383d9245852963385d70eef5a0e946e0b0e2c23838356c83f4b1465c9f0210f2d390ec25c30c921a83b927c9f75bb71359502d81666b456ff16afdebad90077853b07db34263771e34e973d2043cff3befcd47e649568551b218909fc2f9403c730dad196c84ff01a53407654a204342accb6aa3ff19f8964476d1f7af803808fcb116a0fa0f38ada4b5fa4acd7a8f527bdbf5e326347b2085b50715e2a55ad93a1cc9e217f01561272d34bdc87b9bf666c6f061647a7cb3dfc1b6cb0f966083340bfe44e5a83dc5160b04f13ac2b590d7a0b4f634f6e42e8d8af67222e3a5514281bad2447551429c07d3c4a42e8f515047aa90d34ca2ebb43e04463e97ace8b3189533d98039ea2c83b703a37079d81ac09607036c3e644da157ed8bb4348baebfb683e00462f85ff066f846fe29020e0471b6339582c64abf8f2458d80d61372ef5e9a17d9210ccd7f54060cfbcb3fe4539faf3b18ab1418e2f1d0427eba37bec0fe875eb22f1187ee723a28aaaf04eee21c805e16fd31939fb30dc5670331fe47fef7d3e2de60e2c83c8627c3c55ec300f387fc4c7dea7e064839c2a5e000da8973cf6c0f7e1740a69009e37aeb1f602bbd277d61355d2bc2db71638fd7040d9facdaa78396f17c8a3ab354e68c2e21be5b06bde83c8934390dfb9403f89dc4d482454303f48b382a1d2776584bf54ea8e210528bba4356efcbc83141f7d890f46f7ba721c02541e827da54cfdc44cce46ab6446f41bf40606f9bbdd1520c09664c1dd41cbf37558e3d92640bf9db1a5ca7925c02f3d63877be6c9f39ea17b3d9a74459a49439656c5d4d92b9082039913955760d6c20ba17a3b2fc7b600e933be3fe5e004688ebc0cbc810e75a84831100371068ad673099330ad17c948d0beb0fbca492c9df5ff0f308d2f4d44232c40e3ff99014cac7f31c833a23fd96702e5c3bc699918a17420dfc08c4f8540ebc7557b9d1d87dc3b3217297e42038db6d668d1b0d49da9574795d9bf1e2f90b02cb25ad6dab3c95e667622bddc8bea1c7395e650facb2d615b75f661eb38e8e2bb8ff8dd9299d4b5d31edff6dd7a1854352c0312fe3426c729336c03081b7b16cdfaadd206ba9640c91b408e62418ab9dc2a83794c3529940e7a981b26067fd0e1e4f91db0244e98d4293aec80615a6a52ebb7ba9475f3c7310eb87a16bfedc9b2380101b6b90892909ea6e0303005cdb2d3e65421f91912694d856932766ac59ad71f41d1f4dafe0d660bd888ad539a43bfffc50e2a0d4395c1cae46207b0896c6c0c47d79e8a15cdaddf18db8f105e73fe4c661032db50cf1df4142ad01b1e82bbd23b4d4d3bbf0ff6698c7f5146795de1a54528217cd8e9c45933101059597883bc2e630695341d48a4bdc106e5736990a977ed38d64f125176ec7813d98d8445cecbaa04f189dfa39722ecf43eb65f44efd3ca55dec11b03a37f5a6a1728e9479cc3d647195fde90c77ab827d78682bf00d489f50c58788feec7e83a56a04c218ad4fd085c16427c8b81d80a7928676eb9ca8cd55f554bdd8406a575fa6d8edb6e9ea6ef0dfae6524214d6b4780768ebbe9bd1d302edbfb23492f0e1115eb70c4b06de0bd74abf338c8059dbffc971889defaf575b7bafb87db56bfde84b20716013f6aaf599481c884042b8d1547d3468fea7483a475006e96b8127052119f2f3e3f124e59fdcc12d171b42ae9a6f0814131f95a9bf43e55c6e73ec31eeacb3000eb22c3499b3d8171e7a19cffdad34295c768098978d3a10057b30027923612a669b9a6fd86d5484afbe707af06a5a26b44d3cc839410b0eb35c914a77f6d993dcf117a12f25022576def60922b51ba49f1ead756be621fa455725b030c3701bbe8e36ea62a382bd1d4e1894c058604e19421604e90d9395b673d954e344b74e161a87ae7132b2ce5d113a6edf30e864995a2a16c1b3eae10e00780c33c3d436af3dfbb162a36fe1fb865b38a8f9e901e7f4d7ad5b43a9d9e90e19f86a95595143aa678bda8bbca5a058091d4f3f6ef3aa0cee14ce8361c623b2dc6913cbda8b8f034f70561544e5cafad2aeddba8c1d7a9a3d09cee8ef278497193e9526a1bb8593d7f092d5affa803cbc188a673aff68d278e46dcd509f06e7c475a8a28bacbdfe5d907fa32075bed7a0079ec9ba54dc77fde2e97968c44b380e0486935e77e19d82ecb2a1ba657a55f4e40662e9b43790e0c4639efb5c899fc349513b2f024384420aa30f028e4b21880f328e9307f56c49ad3cc81bfee2676e5af0c2753758918287aacf1acb7a37c8dc5ebb95a70a8611bbeca3a805a4008651fa68a5d03b822d927aab6d860eead35aabc272b3a02be610aee38e8cec33485ec2519b2040644e16d61cfcedffadf5f9c60915276a6dbe99ec5a28ea539b4f373fef08337b1c3d80fa9f95be96c5b5fc52fa266f02814ba28f5c53908361dc77a741bdae24422e10952bb52003b969bd2f9e8e30c138217366fce2747de4e3f06f2531be4aa8052208960a31f2b49ed704eda209f91691ff5bf7c673086e6108877a163525eeb498b506de91c60936f7c2ef66a8a32b8278c9e4fdb1c99e001011cb11050267f81b170119a0b19fc8189ed68a1953e800f10028a6dfebeb56ed8d9bcf975ac344de5147ba6ef852b3ed83ce0f507db9d0e092b2ef1546218c564be836eae35203a6d361b1552a43d02edff0a1bd4501076b9a71acf31a94b6623ca86bfa8f33192d75a23a2d08c17527cfbee05f0ca195cbde951c82a280eb011e379194ab6ed5b7fb8daf7a95ed50b38610dfa817c2d55347145d3d37579d43581cb07bfdc7815b616ee328686eb0d6cdcbc02e9f24d6acc415e8420acd45646823cec197f51ef6ded1a2fa38551ceb3f6ae6f9c0bf4a17ae6b485a40b810360f65d2ec97070367fb6af1c17b2e03dbc7708de2dabb539acff4f412c5dac2030922b822f5ac4b251481e021d47aab690a0cee72f0cd56b893d02957ae3e1b6ce6e99110c4ffe7a781b14802a34c19aa88785cc0df179c94b091f9af59938ab29b570264be9f08b2e0e017b9d08d481f0a3c2b26290d0a9d9996a162024498bcf3a1651a9efe1b9d92fd34fa2e00e55fff0c17a0d7cbc1993365c20d3a45f5034b80710ccb33e3ac5ff7e361cf5c12a7cfb4d108ce05243a3090845cc10c84abba352665f3adf413b2d16856c23153e5e970236a5d8841aaf7418f77004a44cff44b5a9b925ae904f1f93b939fc038f07e9c31c644d965e3d949312f38ec8d12605a7a8ff80b5de0c154d3a70d8cb27275abfe026b59605b2eb44f46d7fd6aa8148f230e0b842c49d19c636db7bbd4bcc2831fec2727d3bd7940a36b1a14040ce2bc10e42d0529b7b58f310b4818ce9ab51e7143ea25980bbc126011f51169bda1cba1a7e7bfb776b55b48f759798409e2c106132ac39152d4172927d6c2e36f88146c45d26596640e38c116f45e9755e3ca1d2887ac4e24cb84aab0eaa35f62d7d45a066dc1e5e548bd20ff6aedade82f07829481a50d1d0357e466542215af77b14598fc68c28162b26091e0a1db5f96710138ada10f0c56faee1faeb9b909bf0458a15c61424d9805b04a284b26e1a53c865cc770056c7d76432c0ad31c02a290fcf0751f80128c8b5bb1b1f450b01324bae59c6762a4c0f7771697531d328dc196c45a999c764bff9c1ba8a3febac1df1110af787c44eaf9c580ae1a07b403d164bd94f2f68bdb33ef978b7defcbe3a1397dd77403dd84eb4eec4740358f543bc84605980405d15970fa1a05741d61348e5eabb7cd296d0e5e6ef0b12ee7b38dcc51def7f8e03b3c5769bd5bc6772b5689a4dedb9cbb4607e0c17080a19f6e85e30acbe49cb3f73b2180a69a456cb8c2820cf3905a508107467756216e3ff49a7cdec1d183afb2e0bf0c190f1f0c5643910ba2ef960aa239fec372d6f2e600f0d8834144103d784adb779d441719143b6119a9418c6a99458a42222e97c7770b2484d9bb816a463940c65d0c2239b0a70c27aabdac2e1a9c7def1c27561be01696f45726dcca4108daf72c023151b306101a5e7f8c56e42d4b26ccd14261dbe012bd054f14999236b1a28c7fc6558732decc7c2905540a4afc5b6192f159e8b470be1320f7d0623b2af6d356d3a0f2128c0d1ccddf18d48771d20a304a8b59cabebe6f1ba846b54b48a5c1326a0110ab61c89f7879078ae0b64ecd2fda0bf40a0971abd4502af9427b00ba17dffd946905f8b56bc01853e41b8847fdda36d2b09e50e32bfb9e87fecb37d446f30658a5374a3c411e9e372bbbf12db0877a789138b9fa62624a544fa4c0cca8748d8cc4201361a2ad33acb896963b03d914b8ef59b5f3e9fb19f4a1a61ce938fdb0a0810aad51df7682b9174a1cd7a3f98a0dcf9423993f2f2dc00ec39e888d867597d028d55a64c981537efca7b370450b2054d25ab6548cdd9e46aacec82f7919865ba1c248003d077bd7c7bee69f45cdfdbc97bb11a21dc44beefee50eb841cd1d43a332cd21b97beecf3c44e56c1f84d014404d5286e6a60a606a58e59c2c0985a25ce158f53ef5c9c0e474a26bcd85465ce17a2e5d8e1338074d7ff2ef361b3a9f5a5562d5c0935ee20b7faf05a47ec06a6bce50688a7b1a48494c9575ec64d86e9104c672e11555cac018ed0ad6cd37b891fc3f75bee3187c8e6f36dc9922b7f4eba7fa2ad466423033724fc8e6f454da9397f14d64b6e852da89a08e1c6034b363618145d26e3bd8b746681fd78dfb3edfd80c33ab65c42aba7165f9a4e2ebe2b98f717ef435de968ed68d3ed0e9253d037e3b1ab60071606c7e98cee6c3bc909a5bd0b81dc6217abd1d468f1a104429fc5a65e0d0332a2be0ed92333dd9b28f3d0a34008dded4aa8db0acb963356aa7c5dc141556d6a00707bfd9da3f4b1597db89d2653c62c6b179def389fa50b78db33ba9e5b607f07bc2cf5431f655bf53499b9684e47bf6b1f4b25405c53a79010a4797cb443235947811a2858374ab76c15b485322e2e2c3d06e420e12601983b8091aae26914e1832be33c16d1c00699bf37ba9250f74fb5504a53352468f0031052a6f4c256842e00846f9768f6efcab2b01dcb0906cf0796ba2f922499b9af490f8309a5b48453776f981fd1ae1976c8e37349e36c2bc34d47c5c962f29a982e9c860c713795048672db7eac8757ac2998c1dd4fa7563d7061faf80540cfc90a44544ab82f8da988ece79a00c6e2b552bbbed6ba8cff95c03f997631424fb9f1dcf50c35a89c19f2b4d66bf5373900d7ed6eea7cb34071eed0b83a087de3b31c42907e91e42bb82304e346332e314128995189d0ecbd4d6181e17e02eba1663676092b20aa4743eec1e286fa2ec836706357e9b24fb306aaf4ee9f26d43c2ffb19976a04a2794897e3f5b2e3d9dd668af46bc37e0578e86b92d77c0fa153a4d28ed93ba9c53a8aee633f00abacc0f888b92aa1910c17d44f1d3c23a4534fce097fb65e4ea709f732b67a899107fbb4e5a3b6ff650cbcfab3839b56389757119c121a9091370db16687c1f3e3f96f1712ec8fff68b28701eaff88dbc10d41ae3d509b016026b8e6363f7f52f1814fe0f5b97cf5307451fc2dd681a123c06fb756231cce0f89af561cebbe3a4a174695ce6570643c60e95da491021419c5da1930fcba2fe1b84e76c6fee2b79b5d52128f3c495dadac5351a6464f8054fab88b188cc1472996395de87b8ea064c071ec4946bd2d85568fd08fb092a3e6c890d23019653acfe026c3365b8ecf60704b8767f2deb620b76789f111f45eb38696a8c8e6436ee0541ef9f1072b0ebe0aac91e768e62ad4f082285e721fa8182e46a67a123a18fb71be6a8b03ab1486386d2ef0ca3e3949eb9ac34a27d50102c7324eb9596a232c732eb8423bc236b351e8e6e6dd3029edb718719fda69d5219168ea060c8059184ab06639b8eda72a3867eaba6bc9445158a971492aacc2c722de17da28113af321f9669a8ddf3ba8c92e158f1585602eae6785b47d1defa37052bd5adf978f730c9e97fa5669f34afd5f5f36b236df13a640064230bd3fbbd45ebdba303697828c6e53088c8c3c427778b3cd403d1d4b98ee7f41172992c8772cd98e0e530b0b2d25faef0e79225a43c60ef3af11afea2f666486a30e093fe60e47bef91a7a932922f85e49751f6d07adc47058fd239b5b73b0f203c195b23e7b4cbfc247515d6be3d3e14ad8965b69818a27395149ab866bea566791cd6ba325a077ef6791b844b853e9f1a49a1fccd998de9ed4223b866b725e5844b49b02d02e45c0ecc5bf01c130f5d465c5255ad8334e8a3b1326809b4b99d1aae30c5372ad1fa08667fab04350306ad1b81bd4bddba1cc936a25bd1839c245c13fc3c42cb6a590b3fd89e373f0b69ef86742b47cfed369de7a5c2d7c1dfcff892d0a2d8f0460545b17af7aa360401b675cef8b0df8a97fbf3e510666f92816ed51602eed773072b78b28d273c762ad360084cd5a0c688c9e2e4e07535f9e45007abba9400c88c69feebe1acf707ca30da21bd5ab936ececf3bb8f826288fd1373c816489f7847e758cb39f1199fd6fd1eee5a560956802af33e7ade3248ae1cce83a5c3df08d18cc9804d6b3cce5a97d63b37f94bb0f8c991af9ec02e1271e9afde886fc7a2c232486ddd773f29898ac2bc06f8fa0defa1c0b65dbcd4dbbace90a37805673c72a365093bcad2edfae2dd2dc00b2e930e603b7aeaf73bc0cd0ae9ecebb9267991392dc8a87bfaa32a760a01422cbff827a772f78713d5e06503207ca87aa5fec536acb124aee7959d11831c3cdf095b3675d72dbc5e3ddbf2f1a727621c3617c99b60f3dfadd319a49f2f5590f6e2e9c75e1a6fe56ce3858dc6af136fc5145d8bfeb09bfaa579bbccf55713d7ca606b8a09fd970b6ee4f84a10c71cbc7f3d29b9dc3e2fe28f3c85a6fb25cc8fef126f67e8ac222631579e3b0b48e1632ece9dc136956bc4e1cab32ef768e44765ba1866e7b6cb6a930da20edf44859b32d4da7ae95c43c62703480a88f98a4d5f5cfd44c4ab6152c038b3bc426b23629eeea2c4ac3dbcab96fb7b37b8e6132bfdb1b41345a8c5c72bff4bef32c787514160ef56919bf2993d535b0a847857c7c57427248d85d1c7e0fbe914cbb28116d2835beb6fe646feaaa3bfe117772b0a9150d64b107b6b7dd03315044a851835530a0b310d4235f6eeff9e13cd2629ac50f07ab0d024a7700cc268e22c9fcd0b335de0bdbaf11eebad68a075c1d390a35fdb39c22e2e378c1cd11778e92d2acd917e151c0d652a0ec83c647a69038a23b40d3a9759bc05d562c797ec078b4f5e822303dcdcce78c7b8b2c9107057d3bf4b6431de45fd67c55f730d8748c0f01959f46554a0f167a3996b18436b48ef1db150a0bbf4d56669bd9f9dc6ec9b8049eb2962c064c6395b933372a65fc9b101d023cf96cead71f0c70e3c6b7adde99e77edab60fe58fc56bb4f0c645fd36e8304b167037f0e52c103e94b3e82b559333f1508fcee2aa1c33b625ea7a8f45d8d0c17bf93b5e1a60c314638b8672531d006aed7d5232f8ff7c67dfaa0d1f104d1d6eb248e2e3d7e12f83b7af766cefe9f2f6a40ff383bcb8c079d222f5cc3c127d8bae7dfde24d3045e7ad7a52cab81743d98f39724d16d553d006e9193f6d569a70fec86db177af7d9a8824714efaaa70e9326198f4e21c436087be1be63098499f95ff8b12dcb21d553ef59dc2d992caa8d0f66b084cae37fc687218770d40eda1b8ced8ade62e94b13f9e2e676795c0d0d486e54025008376a7ac133c3de76f01ac391b1a59d122ed930f81804f07786735ad3e21b04aa2fededad69b4ca5907198bbebb5dcdb05f61f82c28d1e4ba68489143fd0fea5f0fb79eb72caf31274500128c0bbc5bb1d8de355484e1796249a6be8a6121e39d6e7de837fbf44b5d8b2f8e45f269801a3bf73e2b6950c232b951234521a70f81f8d31e88326b364508dfd1f41cc0d15b6cc10901a8c23625ba64a6880b5a2644f9bfe1e5e6020bc2620ae6ecbfb8d86a32a8f742febba5663f7bc4d6c477139ed5c401924022242c7e80c0e2c392b1b825368e7034e25c783dd58ee29680c0d80be7895a50ee113b4ade5c5b60bce7c1c4a597acbbe731a13161bfb7a988b1ff01555f42cec009bf9a5dbd595bdf1ab1995b644fea14d044990d97b39f77ff761cab5742d36e2b4a70ca918c383bacd8afec8abfb29dd74c2e53febeac8c7378362d00c326dc4a17f4eb9308617bc312f0f407144d52421b2612ebb3b2a04f9ef0232b206bc30f4867fa7ee26cb4e5700818a0ac5ead82300713744845d8243ae0e4e99f82a3a2738cb379e8aff2c5f446693d269cc981d2bf179cfa54a53ecdc1e1b1fda6ec2be64dc3e963555fa3f63e8697f1d48d19ec169f6f71bf5d1e9437281ef6fe2d076cd23fb8a9121b98fcc736c9f72601ceb090312b1047083754226c7c36ee31923ce0e912cc62b7057ccbd067ce8e9b8e437b92d263ac122c9fadac80f83a0ffbce3be09cf630afb3981d4d8bc2315a6c5214623f14184ddb2b4215671c6fc4f8977c0457c14449968a679fb0878e275312fd633d02e93cc85e3f06ef2eb814073cc314a14b2a4215f0076178024b13e4c1cd9da455c4c4b8134b64b77f1633d71d36c5b96d564fb2bd8504261feefedbc3c4998014c52196a11103c6e299fa429438a083ec77ec7b227538638b308d3c2c39018a71121c12b7300a232a1367d74f40a820473477d5d41c1b48c889d8a559e9b5571a206d5d918fd41a91a013426bf2e389a783a3f73173bc2d85c4daa3de6c4df0efdda917833edda5563a96b878006cb900a3000613449a58cefea777561b432e2c85b7129030344a40ff97c2015059b2b50e4ac36c2773610bc367727e46d5e54ea0abfbe60288dd08ba5b7cd9f63358dd3fdea20da24d5e3f40bf52b6fc066145036aa59e5a6d16fbaa54a8d4eb529102416d106872d0b4cd2d286fb1d1fe297d31c1501c24cefc190e528a68dab29f70971eaf661eb51ff351b03804b31b41292a129e9e5f0fc345bb3e2508e5ad2012aff4c8577ddf2f1ce8e48d6688b0f465d1b65e2bf280c47576b14cdae139f5c4d7d01f09a6f3b3798e0844b828c18a1bdf69e3dc5521ca8427a4c176df6c1a400198387ac1c83ec37ad4ae99768b43575068878718458a9cc931802acef5ebe3bf78fb7ba4a2bd84fd3d9712b5ed1b9e5246918f6f8696106cb9cfa29935ca201f9ce25066515c46d383595b493217586cbdf3d86144d8834514fa65e8eea5ccc55633e5cebbf598a2e9ccf2c51a4da164095846dd07c3608c21c4975a869826f838a87188b23dbdb3ca6a732fc672aa9decf8c0d0c8521bb0685abe6a97bb71fde72f4f1273d32ff21fe6a56868ebf7d4a1b6b687ca7ad7335321762c5bb3d1b5dc52dea8bcfa6dd29dd6eb384d294e9279088aea1cc019dab725a2c481991a41c71b5adffa8432e21ef7d0eb2b2f67d84125e591ba70ad0012209affe65f3c7bb2c8e534ce43e4ec33df2b14290bfcef7fde78d17e64b445ad5ba1acd3c6443c7fc2d7196602b1b8b7b997c82d1ad40bf038d0d2d3a9c5655d05613408a4dea315f09a9eee3134adb9d2312b6e20f7fb7440de83ad94928485adef47ecf5fd3eb75b755b1259eb0519424416d8f480156082eded783741aee12bdbe5786d24f9485e48517ff2a06ae4c1ac230ee5725007aa1e8ce87aa88917b5cae1db9b47b1de281a25609b30c36a682f786b43480715b892ac132bdf5388cd0fb93f9c7dfe526bf8a9dcbcf89ba3d80c81c71915d7b8d9db53d30a5314b83526b1a6b5a97a76f9f730a4f656447337148ef39d665aab1d5fe1eb382022d8f59abc7c8695183ed62cf6e6b403f147cb913d3439225e025cf6421a10c0252c94f76ea49c588828efe309e4bfb913da4d19742d29cd15f7412105a667c6d544b8c776fbdba4572d02eb7f067bb65f1be1c2e636aa4450829e7be51a7755a597989e27cdd505f6fadb368d89c98fa75675bc6798a49dc331d0e9a9a663ebe552376a9cd8276a6d7e302de1691e5bbecf56afb56dc2185a2da1ecbf6a39845eed18a7aa3c9d25afe7e1903756c122049276dc1b19441a1e6f17b839aca3783f58cc07633dbf8bdd6596fad935bf192e93c96c5ce918d121667d755b36de667768a6cb418f5a6dfad6226c91f7a34ad35ec3883b6786322a34a252fea4dd12efaffd2f0d29dc05be8fbea44bf5d511c1f3b9107c4c4a17a4f5a9d0fab57f3f53ed4aca8b94b962b557a58e8aa2ebe03c170109f66bd7caacca76dc14e163cba1bd13232d8b13e5b9b392e053da214435e458e4405fdf6775b3bee5bfc2a542d4cc652d020c3019103a751d3eacb1a97ad07add3b1e00ca157f972180fa384448617e88b2366b673f43ce675230a559b657e9f32031b993a63d0233da53d052a12a30c103d92da27a9e15cc353a01694194d5faaf1be61d4e05856a78fa687a291d74fb84d0061a2dadc7a7faed6990692674aa0c7991afa33ad00a457737de408c6240554a920b31321f4fedf47695cf348677fdd26cc5ebb4207ceedab59c2d4965229d90a369de6747bd5cc82b9ef57f4adb7108ea0d47562556e8c50dd805fc81140f57be9a571e0c6845a0078db4a078ecb9560c6b4ec74ac3142966cc7b3a4c0053c237c3c6722f95ed448ebd1ef6a540c52151cec933835fca1d81f656042b603e70e87fe9351d52eb6e6ed8ce37aa9c8d956eb298c5c1d5353b9ebf97d5348a33f4b81c0f2e9d0b5e2c574c6e4c013dfa01a8cc06699cdb2a8f67807798161ca60360cc682e33a6b8a4dd6e58a1a681cc30721c62063ada7333fde19ab989d54cdf8d33c59a35e60d9c628805b30150a8b0b56d37a455f248910a899cfc3f72acb6dee4e9a0e5cff139042bf1d10447e8bc5942ba0b8180da4f5dc1ba2360f5e93ebdf513ecb94c9744aa726acda70228ab749430a1523ea1862ae024829be8850400facc4205f467283e55f3d7e4803ff389246a63ae544e0ccc626f9834e151330d034fda973c36492878af14562ea24af9db16bfc0206b585f6ae2a093f1de4aed76b9645c9ac102d1253f95db00717c68436d8728a33c625e31828fdb38d1515ed3bcc6c0dad593025b68f00a242f48cd363c513bedfea37dd109b34fb55b654a39900c058fed69e9c44e6e336872355df955c4cd2b2f068bdd751186082974788ec8503af01022b61935902408971821e566ff66fd5b979b9997af98fcd39f38e836b60c5ea9a45473a5740fcfc37462e17bb5d6cc94d90cdcd98a21b9f84d5140d5a184eedc3b1aa31ff973beffafe38fd71277f33ab627d7c88ad1380a0ab0ab765bb54b113ba584dfcbc0db6226186e3b35878524243930cb50f9f2f33598732ff1935bd1ba721e1204952d4decf167ceeae03c76fa2d04c5a388b77bbe80df16dad277bca31fb43ed7c185d3b10a735f4de4d10e4c956cf5af666fdee637ee1e50b3af7cc78652613838a29193857c19407069c22e1ea74977651e913eb110c8d3ea572a1ab492ecdddb775d5ad92ba6754efc54aa26f9167b0319cf611415cda50ef7914a2dffa2521986a9b0045ed45983120692dcca33d493f6018d59b37a365a577ecb7f78279cfe0f583e3dfba6359abac1e3e81c7c7cad5ae9479e645ad1f5af0258d18d2ee835661a4061d5a2741fda617f3c1881bee1ce0c2d6c01ca5d9143eb2a36ca70717eff7fcfbd0ff2aafb821c83c716c471c22cd5279e7fc751acdb062a52da17ea6687a9581c384fb57b54262b2d4f32720f4e5982c58507e5844e66fc0cae15247c1f4756f99981ee0bc6222e1271cf23aa9b8caedc27cd31cf3675c90fb55c685b7ee426f647cbf9a67cb8ef19d3e65f54e6664a2091fe7b9216cbc0471ba116da4beea1af1cbbb0b873b19585b171abe621c66b74d04cc597716e63a2a25be9f1011cb24fa66936a13471d538fb038a72c0eda5db63e3aea857adec8394c3fde55dd0e1c353b7a6b094436c668f2cce19ee13187659de4802344a40232f85632da3d822ab816d8bb30b49f5ac22c1d2dcb99802e950cd83311c9e4d14669641be42a6433d722d4c2134d21a2f3bd9c8c6dc05f97e9e8c37dd2aa4c73eabd62f3f639f28f5ef997f7e2cad858c07a889716205a2d3c65b73097d158688fbab000f8461d71c3e4523a242501eace0cb2b6c8a85d5d30c3176549655d1506434ffc49ee5fa9e66fd70431affa5ee9911d128b665d6dc4738c73a014c612d30d0dfed9758366871d22e4475a180aa46efe3d92163aa07dbf265197eb2d0dbb718b8ccde94a03d53f4841d2d1e27956cfd7664a678a1362045a819d8b5758565328244e5e67ea7a8e56d99021ef90d1cfa29cf9b278ca404af8f74483c9e0e1451718472d946a3e869c96ce423a0867d831522c94fe24569583a82a47fe8fe50fe98a970bf9ff486a23d6a7326da2e3068ce1fd3d0f73c0f0f63eb90c782fe42da48af45f6e8e8582f3517f1cbc886438e022f05f3c833c6675ed5480d0cdd4d9496392ca1fa28359ae720f0afd6fa81be656d8f5100370d9ba1afd709bae9efa30b2a20308e6f7ddb6e32daafbc2e969be583d889a92faf3a0c850df872c0ec79c7f63cf374cb24e54665f7f641950bbd9385b5a6ccf14755ee08f240994fca30d8372e713e290a7d5fcd9205df46cae0a151791e5d84c5037393335f553e8562dd04bbaea19efdbd2fca75652f7f7b1fd5ec2c0aca89c143eb95176465f410fb3d1a26df673524e0ed8abc34f235a56eb1d62865c138db5bdd5865bec8a6ca1bf3a63523a4278847c5c907c2d0c25e46bf949ebb6c405f9de5337950267fa67d2f30b1b41be3a71783c8f0f0246052dfa5bfd143482bb990cbc98dca1e051f8f1672c433f844ea19a16c7e6fc25f42f2789cd4f6a40b8cc52ebfbfab69690b7e2169efd45b003f15dc426d217bd9008c8d54cc43483e8c68d81d58c94899d081d27bb7c21a3caf81cb0e0e3989cea801f20d50c7e515cdca5c3f748aa3fefdfa142add627ff0e61efdb6d7a278d4f3652592b9fb69f439aeb3ed610fb7483a29d9a1ba20721bf096c8e84832e54ceba8d56e12c1ea63e5073ea174759a4064c10ac71b2189f68bac65ec2f58a72713301996f9c1706432db77d5f7e488274e7a8411566b06b9d9b2f14df5216a9b1329759e42dd58b85a97e6458a33356af93ce11c9ff60481d175cb883a1fb5af38c09ebbfa30f6c50af5eb8c8c59ecded87d30dc878228232670fd1c6554f2d358db7ccde300beb862a1a98fd2fea364e6d570d4176951822c26ca1c64e855720c0d096a15e0c28d6035f622adcf6dbb56843abf5406ea325c74bbe048d35530f74fe5a20cfe4148216f2873aa18c0b70329f0f901f2cedbf9cff60575c37d37f12a8450c841ba9f9590d4a95abc4402c13f2a3637aa070274ff47740ff2a6bdd931fd1dfe63806b96de47664ad1bef26116866a04159f31ad095b4786e56093833ebe1d2977ddfae4a4668bf505e0715f088a578e3573724dfb37f989c179a55e0fbb1df4f9c86d26b07413d98f6eacd23e24f8bb920e322ddc24e67c262c1feaad78258a3da79a4bfcc0b8f332cfe245cf56b021ebabfa4b50f0dd33d95fe0ee0d4d63f1674977a85142a6fee804f8e54009075716077d1650839fe9d02fd662cf9ddfa46b7ac00ee93510034f23d5368a98060dc4eb19f79ea418f2c2becf86d75ba74e3360566bc1b65a77303e35db8ab59930582c305293a04923424549f60e561e5904e128d1cbf33806dc6293c9a4c198047b77493607ed5780fdeec901f90754479adea4ba7669ee62e8252c0c3df74375a15be5e57234dc2d9af1da97b09967cef4d6644fbdc8929b1b1ff669580fd5e87fa9aac7faea5365ec205e05b2e118b7e4fbb873afb46872fe253dbec5ef1e3fb7447f6ef13693cac619e1b9e5830ed7a9be7ec58944137691b7c3bafe78182e70e86a824ec7bc5ad2bc7f8da7256ff702debe54fe2507b8766ff1e13062690044a853e618f64a8798e2a0b80240ab08e486869391cbc234d9bad72250d1ab3d4733190fff707306c8a2ae6974e3228a0661402f1e4bb37e3460cc348a4c61464f40dc33a3847be16ad43e969f1bab8321d4c8dafeab334c015c98ed020a7f35ff099564cb43e748b3ddf989122d5e543007a9232a5b734b91e932613936defb0a5e58f5aa909a8a8fd28361e0fc50d5b259fbcfd66e28606e4f38560cf461a408483ca5ce4153216c8a04832b863cbaea2cb70a79d6f0faa38d43c5ae46733098b27e36d4c12ccfeb27472ea41fbabdec6b9bf24aecd7ac96e3653b8402ce7feac9a7a8a293fb04246bc7025993c858d08422e43d52ad93cc5da581a4b6b69a378dd3b98eee5ec2af6573be96638515aa392f298c155fc1127dca5d28ca016d034b51813cdb1838f83c10b4db09a8d1e8077a5a35cd0d62ba82cfc3889d16d7c7c02f2baa7df31f46f41d3cd5fcebdd8a3eabbe8e39b292b24cbd2eedb2e9845580abf4a5ec42b67e00f6b886829984c0a92e27031170680a1461b2107bfbceaec61d174a0f9a516f280865e7837fb726a373d18989f6ab22a7647ce0870fb4e135ff22a410fb3a8bf71e60e1e4571f68b97f5970317868730715e5ab2d54dee0e88d7c9ec2dec2bbcd6c409a769b6386258e9d01ad0ca0b8c9d59840bafe6c66731bcdd8671c0dccb33aeeca1c8631292411ad0e3fdefed1a7908e6e7d741e7a6e9138c57b25343ac8da2f0ada5d9339819a69d24560e35bfbf3384bdb2cd53661a6e10f32325e8a9ae809cbfb1fd1c6d79c0d94106b2499f002562dbea63c291ce0add29ebfea20d3d87c5c7b73ae1df7b719abf299f1a5d4ade67684b36f9bd3a9e4742b2531903e132f09c08baaa569fe986b9d516f37b7cbd7de9bdd62a3f9dcf353820bcf34d63dac78ca95fa05ed88042148cf748fb18d61234f843b58af6699d462595139fb275e0b0f9345444ef4dd77733c31cb35323654b7694f52d66999fa7070bf6bb8320aae3c430790824ac1fdb7b165500430ec3c0b057633bc016265b475cd849adc93b34014e814908a9856524922bfcb98d61aaa03f07dbaac87b82b4b96f2319ad7b341bdd980b5208666062b4fccdd323a77fce134f015cb0c65c6389dca846800ef79e10250e87ec7a506ba5f706e4ee86cc67b127ab7cd3431e4c634e67ef785539ad9579f1ca475a242e5eac1c161a70095432bbefa2d6820677f0748c7c64726e503cc4bb426028e83d7ae38f93e453a771b2697cef66003dcc53fb8475a41be953905246f410d975feb25061c2f72b53c20dd3ddf5670641c5ab17fbf1dd9ce7a262d4dfa4d885ecb272129c3c6d54e6adcce7e1b01bf82f5e0b1243e00aade1136e2964585dfa9f2b8168c94fee612616e60821094c79e86e153800ea2798711e03ecfc1b15038b713588a18c6f1431aacd572b6b695953881b6eda7a37c5ee0029e87804e36614db1beab4a720cb7bdbd3531cd4b84099f1ae0db6ef131dea28ca4d6d626331ceeb3301e3b53c965b13809a2f3bc56f41d9899d7d5b2dbf413636d62d202a0eaf7c4bcea878ef1324e5181f52a991edeb710485b5af1c5197ad517c1afb2ed6020ae2e7453bcce3590761a15bdb83ec3babef59990b3bd08ae22cd147cb794878e1c1f62b63aab2979ff1b48651421d2532fc3a93515ce83b1c54a10510f407d0bd9d223861bfe6d7db24ced6166294060127d733c423daa3b9489c32cec558228feb990b20e76be2da611bd04c0552f3cb3252774aef120c4d6a03edd5f4a9048e437fb79cb8cb02c214e84e68c09b6f210fefe9b2ed4706d0e4ebd8b33c44047008d195e615d3b20276b63dfe55356141ebb3641b42e9f0af9550c027d920602adebbbe508718b0819715c39e608fc4039bcdb461dea339763fefcb0f0e01a2246ecb6d1fd8e804b1bfd417cf9fd7ee3361669d76c3fb328e41a0b72887376da5705400925881e5e2ebe7697e9874766bc75fa59afa98fc1db7d47628a984fe04c70bc2557ef123ba34e2bc12ec2f271e7ca2ec9d16317f4ec3b565499db55e05b2722625c47d27667a72973fd0d40d486497ce30b839d45d5f2f45aa7e61b9a8804962a8ca2c04d9e7d953ad715ac5fe3e99dc63066d91419619b161e96f68118bc9a4d178f9986b8925dd395d67ee3745721ac5245a730555e5d41a42694863d98d544a1953bce658f342727f59096204b33de1fc4683e81337f4d047b6ca177f5d365b360fba37616b3c57649ac64c2ce77f0a18186bd3ddd62443ea6d97a1a88d4def32206d6b8c8b2799bc336e771ffafbf796646ab17f33aa7d45c0f6fd953898d52d1c314415fa564af237b1d78e6c3d5334096fd6eaee51c44011f6ddf2888f4ec457c4bbe174b84a749689afde53f5dbbf2074dbabdd31fde397061fc01c507bcf71ca4a0effc72129469f66e00101406b1091a32473b7d42692bf34aadde570a10624687e61756a48f0f064ffbdcd13b361ea1337493353e301dedf13efea8f2fd28c298534c7ad8d63135040dd17d42cfe5716497d6eaba1a376c94c0bafae5788027ab87acd62f055b122c763f511ad89d67de995bbf7ddaa615dd9394773b289502e478673727c838be15793ef33b0ab28db087362236bea0922a8762629856cb0c04da247845fb8c49a31a389fe0b11eb85934746bec3640160b2c16a822a8ad9c6bb54c858c3290579a89813a3ade61577c195d3c6bd0132610f745829fd69cca5195f7dd774a4dfd5b2b690a0820a13d26de2d65dd7d21f4322e49beac19d9bcedc3c93d29b4a9539e20204c7aaac6e61e82df92437e964de1896d023cff45546cb97ceb82f0004f276047be94931e87a6baa26808eb0256bae9918bd78a114601babc83bd4e6d660a4e5e3113a50dbc79df8e613fadb886e5a527a26f99391061cc9e90a932602782e7de1a002f90e754d1a143306ed03e8abc0fafe9c35ddd629c7942807995bd37eae3813e7300e14f1e477257f982a945f25ca66a2db4796c615fac7f931efeb1a1975c2b8fe8f9c3199710e93ea0c384d1a8bbd9ca1302db2a2093801f9b8bee5bf05492c0d5ea798efd52b7fcadb969dc5cd0176acc0d5b84f6c49adfc7789257980d5f4b142a84c240dbd13811dcab9070fdfbf449cd03f8aebbf70c43e856690cc2d6b33abad9f862d87a29dd79570cc0a174f191f2ff010c97e0ebffa7bf246aa8e2202ae289c9f30bedb1bd70733d0ff8a9d45ef3ebc1e96a0f2ae4596a305b044e7c337d439f2e25a7a047dee4efdeaa2cf4e2f05faa5cb5a7eb5592ebc2c03aabbfd73221b2c36a89c68d66353a8cfbff313024365a09455cd134b72547281001b4f406eb3c5011e470d9ff20795a752dc2c9ab6b6be6bf21825c731619c15b5d3eaf11f1457694eb3a8ce1ee61b5f65469558aac23fd6dce6ae7fe519f21fe4d257fc52d137b0dfb1643ed082e69997c290432f84165dee1d4c6d1e8f393c27247a2930be550a7a94c3a73da78b18ae24907b70ab4127a13b083cd75960cdfe94cd707243a90d3e2b56c224cc98129530c501cdac375933c54bcb0b9250f7ddef2804adca95b8b0235d95698a1115bb6fb95e4afde8d4abf3562e0b20f7d378fff1122625db956fa22ca0968fcede0f6ffb186cee54b474455bf244997bfaf8c69ca5d2d818148308be0cb13185ad77a293bd0f313b0d6629ec7cd4a8fceeed7d4c1b5cda4eb70aec060b7181da5c14c6f80e61c8b4edd7629d2a1fbc6c9ce1f0fc54d2fb8909c8a9323900e2dabbdbb1394e378095d52b7ba7be293ce91351835bcab9b9a4ce438d2810eda2e5276de28c37117eb2c6404f8db42d6c27c7e5fe4d36568a5c5947d8dad9236ba0430ca6b908f1e8dcbea55dad60db75bded3c9be836c9ac8b256baf3107bd96926c08705396f1fb77847c81689165318ffdb981be7fa06d80a248c9b5114bc0441554db48412ea028cde8e2cd551400001c7842fcafda5f544adf4d42202ec687265657878a73412b75374df4ce57d2948abdf94c2dacdcda924e2e7fe700bcb4b6ff1c37bad4cb9081b78074604c26357ea925ccbf474adbd1d79e7d1c1607d836dad19e9a78a52fa9c307582e1e97edabc3408bd755fd16eaea2ed13b384bcf08435b65ac10a0055b48e285075d94ebdd761d6c1950c91c9ef80d36dc4a86fde929e1bc72b0b002010d3854a96237fec4bb5205eb85258431c59f456ea70f19af896403358bd852f66d058011dc2b5a43f6cac202ac22675d11aea9c86e7b37ae485983f22303758ae9240ba5b5e6543b50da783c0e690dfe7db4d0e479b66f499af5b0bdda2cdde1dd3406b08a2d51e34acc9adcdcc36e889f82d1b06175bbf4a3d16be2fcbd3d31aee1642310418a5816363640887bd68766a332a962c028a3022a2183ce8b7f972ea8250289ddc5a0449a6545270d1b8aadfd65d0447b9aa5e96c6d6317215a4ba4eb285ebc67ee0c7550a4d505f204c19c1c308f2217f7d7571f28acbc18bf522b4989745265d2f9ebe9cc7ac4ef7fc3f0825787b78896ef190a18cef0cbd5dacd2db4ac24c12150e24366c8e2d16cb3459b26780ab51e6009fa90ec5e7ccc97dd00b9e9775e14ac1fc7c20af287d1da25c83a66a0a8b36b78fa9dcd4196c3d5dac98affd29cc3c107c7684be964a9f7c5469e2944886b4bc94d275e822fc662d0ba91523112b1c059607b1a27b350b8df1aa42b1fa621bc96bbbde8cbbc60f792cbbb927e5d69c6ba4f20f859dd5710b1b947cd4acba069d08ab246415c9653f89c743a0563703cec65286c4664c88f02475dcd2146718f1e36c345d9e947fc834ddd984beea436a7baebd0f23e0c5be014e008dc735bc0d89adec10cfb6b983aee7c5f2941782102794d5149daf904dd6f9680662821d0e4b8505bcb5046a06c5694f7ae8593a8a72ea02737e1e58597db1fd245b6176ea03324125122d845f967810accb57f79fc4ac20c88e50fbf80186b7fbfb4d8bd09ab3d44e37461041c4e763d9e22d9511bf9b9da97665efe8f446d755e7344699553a93ee59bb79cb87cee4d18b615e71b63c74002be4bb4c4899a5e1bdd9a42236691d87be691ae8d152372c2581bea6cdd6cf4b3bc978d70a5f57a188ffb28b203e6c9a595d23c83cfb18360309acb479a1b28bde270dc370144cf644de95ec2849525b1d3d3ac23c71a782ddb5dd033a3072f75bbb29b77860c2b3b96a6eb38167cc9431f4a6135dcf96608053c62a5a45fac43090ae25688e082f1401fa3e7e9edbe1b18f38806b3e9feecb481215a933e1cc4717d7fa5eb669ca9045dfab5b6c2658740d8f73628489125a2e11accfa411768fa3895b48c77a0f2da01157d54040182e40ba8173c49b459a8a892f45667991c868f16a448dd1cd8b54266758e7bf9cd96d845a9cfa0317c788f2d99914bd35dcc6076fcbedfbd167d7258b077cdcfec3de373d28ff524c3c963974ebd011e91ffd3fba5de51186dc24c690e8e09d034a48534b788d8b63057636dfa255e71da710fb6e50ad312292502e9b68580bf800005f115250f4080c83ae3620c6214f787f180705b585bc866991be0eab3087f42ddce8c62478fd111f95c14103f7bf65c40d012ef37b464099941554ef2030bcf8dfdce03a950a44bdb70bd3557c1851f3edd18f0fc4a9f385b12e8d3cca9af7d282835a5a5fae678fdc048ad53a7ee93f96b700f04d05e090984014e2af824537eb0b2330a0944d39837d93c38939110d1e6a622a471a932d78a00cacb75109c6c8f3b7ede3a88a76a1097e7341f063f454fa38139eaba4f0482778804fa5b30fdda01e284ead38ee7359c3e9f6b224871efe9deed466a1138e6406a83730cf7a16928333a8f0a70d7bbcf31b5d4bb488d413ec5c21e8f5150c4534dc6872105fe4c683599101e5ecca21b59e80c34cf0b8a8de793fe87ea43b5dd32343d2c0a3b5c2485ed86d50a8491e69d19223a8851b2fcc9513af2a9a5532c88d34fcac12e56d8522247681a37decfdd7442cbe3129013686ea13c6be77494bbda8e4b0eb67b4d76b5d4f832f6b00ee11273807b560d6a5c4c52bc9043f612f2fe6b1301c90169b336b66bf27a4315a2761077279dc171725a4620ac106632a9c306f56326616323e832b54629d56600dc97885a9b2185c7fbb16771afb237c9951ed2ea9e1e1b7b60869aa26d59f6312d06723df06edae8d4d0c774aa03384819ca4c695cb96d322aa9b208a002302740831ac05d7f0e113b3dadb761f075c46c11e2c4530e92b2d9e445563855727ac9330b0be062d2272236caf83f80839660eb0ccd6cd73993c01a4099091dbbc8e955f51b5e535e1357c9298e19d67535cbf789b31e8384c7324a8abf1c1c3df549174b3e6286646c6a1de0d2d7dbb59d543708450c30535bd157e96a4cbaf48297d8d992307041a40fcd6cf1d79ce41676f2ea949f951c7d0509a8ab100473a9a5af60955564b6d4b38b8e691671bb1ba814580cf0949b6b2cbb507d8f232d8bcebedf51c85ed91202f817de5a7027d34539d74d2c7e355b7b43686e4437ee4d35cb45cc9eaa7c676a3977f81eebf28f72c926fb348e7b6e5b9cabd62041fd4e2500321877b7baa8a1adfb09c6f877418bef214c1445798a0e1867d6cabd950f06666b1dee38f2ee62807e7cf65a4d39ef9a5c7ea9e7d28c141eee8487e016830598cbcc7c9e46a73afd8161e90aef4fa1fdbb8c831b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
