<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8b1b0a79f69093227e04edfc300db5c6d4434bb0f2fa9c60acb8159aaf8c8ffccc707c70a4131c096e018d7772c394c5a2d77fb8282fb8d07c00abab73bf8282dad00191e5b93f3cf5560bac120aed19274fdf0f784340aac8de2eaf69cda11bb29d0480a50afc7fb9c722b674cb2717644df7c5d60b8b3adc018a633d4bb47bbd6d756d4fa44fcbf5937c5122e5c52d97f1e144224b71b20df764fea0ab158db2f48d3ff10f0f52b3b25706805755bbbe4940a61f2b869f5531910c9f2d5ee701783f5309b6c5b36c64c43506445a14d8c61be57f39e9637dba18d037e81e1951d0526dc63751a72d672a5772aef6b4988a01d06e967c5704c11a4610910a0622a663e13938314c74d08619916acf27b4af206575e13fd84408e0681c58a5dd2ca9d25e0c2a6638c8b1ba128e677748490bbd51bff4368e7211ab83facfaa92deefe1a024cc9fbf15b354866d21463b47e720cf3d5ac437b96f8d3c45ea22ec38e9bb6d82a5f5417e22112d26c345e86404c16e8ef3a3730bac5c6cc88782ef7543ac14528bd8481b0d9adfa859a69d311422f8c5d90bc1ea0c7a3a424bec80ecfc9261d10b3dccc65e32fdd35ad20916ce3ccfb5c331e3ba6d88e157e3aec1d866cb8f299417a618767db2b2632e012f0f8aa72fcda459c146060305cc789a249e8c6d244954293fb84b90d68b5a7c62738ba444d0c25a9f45a30b58e0eb3a894421d9e42cc7a67429414349463bc68abd6b3fcfdaa0c30250824338c051350dca4bc42e4117c22406a43caf93d77c73549537d55cf968f64f9c91119f39e5830ae3d8d2c59a20276961a5c63e6d2a903535bcbc376b64fc35fcf2e14e042bce58ba46c8c65939239721d026fb4e46800424b5cf0af6f2796e27e49492deacfb69f9b5a3e9091579c6f4068c49cf32980f3792959e50bbeace3ac0cb82dd1f7d05a5edda86c152cc9d0f0af469caa0176cfca2338351f817d2b729d90d338cc522f2bb3429f3e6dd27b37d46fdf9c4b487d131673f93777e2f547b21868f0231203cd2530de0db8aa0ad62343c85f8695db5a8d20466387d5e90518bbba717d6232cfc4ffc3384a0a4306314c48ea6fbe680de41486e841e0b26643123d78789a195b07c16b59e9f21b9af93ff930a8e81eaaf4eb20dbfd78b76fd453ad53ae3d190a4c9db9838151677a7c6398f3121ae23bfd1f790497ba2fcf2b7423e4e8388d3905198ffbd340bba4312794a658b715d42ae9fd96a31a31b1536058afa5554a2be4bec9904f6d0b311538527dfe2a50f6e831bc3211d46829c7e3e8cdf46f1b90f1cead7c8e631ace21630654ff683c6498e7430709cfdf9c8e4b4bdcbec3055408a336f290d1f4e5dd516c696c4eea67badc1c0075c25d30ddce65c17e11b3d1273bbb2c58faede6142d85cd6702bbad01508ad433348e9c1f11745e30adf7885f98364a98915788ef597df066b6e607f89e224017bbf73e2296cb7f152459d33ac097f0c9fb2a7da340a641659bf002af6d00fe6092ea23cb625723f1b361944c4beafeba171e3a37803a48da76dddd988b7edd7b16b1638fd6f03a614bc04986a32674dd0448e794dc41d05125490664db602cf0d23e8cf130abf047910320aa9d07b3e39757ee80031a22555a6423a40ca2a4c77ffd06ef8681398b71e10139698c907e630e4995b9b3770da92a3e5966d963968198792791330ac277d03014d0664a0d413d1c1767dd09203906d4b17c2b16be23b73ac66a64bcc20958410435054a7ab6b45240a3c2021e335e0fe19d5b93255a8a1d62cd15340960f87872d9a1972ef478d3cca528eeac4ca8d511171763786ee6f7863b70d98b6ad48543af0c26e18b2bf74a4f603f3bd919899b6a145dc8d55156f7fba801fb689c9f7fc896fbccb471788bb29afd3984e60144db3db988e76d5aa2748d211dd24c0bd5855a35df5e54236944d8fc91693d535ed4e5f6a912eb73b925e62ef1395b0d04b67296224e0e97f4ba95c82d98836af503245b396ddbaa03382f2ed9205e4925972377ebb999a30d3058a06d1b730641175a17eaf53ebe58068b6d234993c7f05ffdd376cd39e850da79fb106f29530fbf28cf47eba7b181b262a89b4b983e86345561e933db54f83b71b60c6a20aefd059cee951b8acf7273e2c8b8e139de7ac6ec23dfab290366887fcac2f13e6367d274b5b9c74025629d68bd5b6db47100d49d9c909d27c4c01716f2298182d092665270df3608315ee0481988d32955ec677dccf2b019ac78b5499cb9b91af02f31b62e27705079b3f888fa5db0e5acd86f11fc52606c3e633085a811bb8115509fe98d53d4ad111db855dae3109d6933d45611419a4d2751d4e04e084c120ae7f5af1e54a60908645d007b10b67bfbe3a21e2f18fd9bb8251f65c8a15ed616bc150d1461dcaacee486d220ba8c77cee3a793c04d7ac2ef1787cb0ca0c21d11b1fb5b97538f134d59a1230b63a98c9f1966ec46c0e76029267139eec26ff99a3ecde5664777216f4221961d0250606d59c02035c6d234435622910364568d16d4e9273e1ea90e7f452ad6f94eb20fff59a338b557805c400341dd02e9c628205b3ec61122bacbaf14ab44bbc4cb41aa8e3876f1fccee4c0425db442302f664473c60c4a1defc22817d3acda5616a5199746f35b347d85cccf6b1f4ec35b388d612425d9a41233e47d143f55025e136f8ec588f3c4b1d7c4d99da1d665df8c4752354d604565e07a875ad7bf9df79e638f355d880a870d466e9cca103b0774b50243e5fe3181a928e8e25c87746ab05b9eae0586bd65a37dec7b5f31b42e9808b644171f8f4b32b89c5bafcb9d1d9ad1e1b895bf940989500d4e3949256af2ebb4d7c26d2c9c9674f4233679a05e13d0daeb2729352dbc9505cff491186babc028545438cfd5a72cd5e5b861f1f5a5cbc6bd4d817b007797a554393146d3cf62c91e1461ed8743b9eaeb8c996a9d5385812ba591e25ae49a185d74eb5ddbf2bff020ee9d23bcd5dbfca8d3d29df208d3bffaef6e8cc42e66f418aac294d18501b034373b7e27f9ed0dfd4eae9e16e8844e56487e511f11e4e288fc5e0bcc3d8b568a62954c3a5b35aed7eb77b0335feb7fb6608ed430add60cfe6edb182d14929f0b0a2b208561d19bb3a429110e0ab9a9b5ce2a48effbdb244bea8759e581a079c5153849b49f7884d7de285202cf7c79aa40f182279a118e5e7a3704cb647a906b293a1def7de3c693ee5ffd067b533023b54fefe2add728c734dda295eac60de5fcf2b6561d4b467637fb8be137eb508d23f400a1afe3abc0b48260aea7bf52157c3b600551b7072465befa72df5945c590c920122f12672b64ca4ed881762d846a6eca7a3839441dc7ee487e3a6c22dbc34a31cb951b53689f2c35faed03d3eecb5a9a045e19c783a496a84707dbede1ceb9a29b68ddbb3cbc47c6bdeb7abee709505b7c26f70e70f681ead75c04dd7de839ffcfb111be4cc04fd8b8e0729c3eec6252e68b194a6206d89ca897b9ef313bb156c155aa2f8238cd1442e490104cf2290bebcc1e1da3468f7efb9781fab7d17cb35ff8590ac407993ff6b5638468811494d04aa5689476345db646773652079fdd02cab95fde96b82d3aa75159c48520f9fd145d1edea8089abf3edc9a8c6c6a4e566d485dcacc7b8b7a1cb4500f924f978a8f094cf2c3166eb1c3e9a52fd3b02ab4d76996b0cd5070441f362ade9d27747050bcbd0d750bcb2422a6f7689844f3c9dc02e04b8342196db0dfe001e8fc291e44f30b00af31fc237ed5b8c8e2d3cfc75bb6259f6e7faa8d331912e75c899c0751bf3051b20fe0d0f550bebc53a88e708cacd5079fbe5e5e89245284cbaede6401e7cc22285cecfb4f48374d1667f46e320dbad5bab7b85adbf8f11084f43bb879ed15a3c5a0310f0dd1f9d6b0a37c39dd9a840758874017f06136408fe78d0713027831a2660eff3ce3d7b45bfd21c0eef1f8c181804bb6dbbff701844b5fd25bc645d61989f67ff8d57f2681ebf98546075b01f7dc2f0c23a0d4ca8ae0cac006ae92597889de5f01605e4a6851eaaa5c3918bc6169d4b057507dfdb353f69a9d3cc66e3aa656fa52e25795c256fc5484025935ab6d6cae29120c0281371d2c8e5e482152373f81b16910849615bea69336e433afba000def1ae489de2fec4d1f2b5be3d2a04f78d89c987c31b93d33ac24bfe0537a2c36c2a124cd0dc6490d1d802c1de332897437107b4c06c0f68de833b55e0f68f55e3217ff5aca2aa177313e645b2aa91fc55e052ab123ac5dd6ef6c34c8946317792e576ec3162dacb16c3f6b414e6f4932ce9967aa3358033870ad6540d2d68da2d4f3a7346e908041cca929cfa9eb297b2760674406c7c847c4f503341aa9492de287dfc9a10939782526d717c82c7bcb13d3657598f489789442f64012f8c124b7fa6b2858b0bb50720e7c54b19fc368d09398db5d23980939fe00c0be53ecc2440c744b1d943cd88541540e965471d265db9c408ea1673af4bef060c9bab1f40e2d8e1e2d28dfa91c7da0c83a35efde251f7ca7bd1ebf08aab43d80eda2009b281feb495ee138c0ec85b4a74b96393688aed5f83627425007bc0dc7209f876a376b80135a289d5057b61cb2233641c9c3fa8e71babda0075951a40d41b1ac29ab8371fcc0a4a3e783bbf0fd7ffcb6369e094c63b0e1e4563409096d7d54544b5fdf0f3ea4027792992fbf65803bc38170e0f9648c544b3a21da0025e17046a264e9402c0cc2925f57178f125bc55a4accfbf5b5c6be34c4ab72e24e7e30447ab55f2b58c209e017898e882f964f7fe12986d32124ede144dd71e32401020b30fb047031eb7d72c739c7a39e4e9e2645191ab8cf7cf42cfd400b4583abbadd82e53a61baa256d2b35d639546de0717d46b9fca0ddc9bd9b0b1412117271f398b0795a120e17b1232ef39be4ff9c127c6631b52891a58e77dc113ede0d936e3f082fcbaddf86250b6e6dd4b032342b6afd71dfc66fb36b18041b79ec95e0afe8e62a59b5814d96baeac25200f46622d6a84229f144f44bf1ea7b87a9ee957e0524ef3f873d307afef815fb2f6fc811bf5f4bbe7de5d9916bc26776eb4d75956af3f6e02207fd097dc904abfe0f50dd3cf50a97dd2aec1c5ae440f9ebaae44f618240ffab42ea6e03a3dfa86b5bc00632e79750f9088b1282d95e72e0ff8631f12dde6bceb5c7e68e7583ee1859ddbca5d182c6f4c65860dbf32037e92a960bf1a382bd4374d4819d4db671634fdfedf054d6f6fe5a5362ab338c625d53c4c2774b6ec6ae16ec9eb1f3e556fd13041b5b3bc70bb849cf43e59f771e7ab58d34772c3c7a39ef7fb59a73bd73b772b4aafd3973112caef009b301d310b97428d67fdfed222212cbc4985a7f142468dab91aee691726c4433c1b9edd1718eca71ce5091477f96c50b170d8ee13346021b2c02d28ee491b7f77ec57e143721a1cf790d8dc2ab0b66928228d2c79cf8777103822e2aa15c6988f46b742c623ad83e56f7af7c83b056efeb9f9e763f0bba67390489cba118d380378de3eccc14364ce8f1f23ef34009698d23c516aca509ad6dd580cbb5c10e4d6ba0a2e6941035f3132204bd73358745517f4e3e607cb1dd576bbd3f93ba5cc720ddba847626371ffbdf49ecec2026d510f369f81349d32218e8cbb2230aa332d791ba787987852f67fd027f3cb3074776c7ac72e852900b5861d618e469af994d58bdbbdfc9fc98f45df2ef3749a17457df1d40e97537b2b56b9aafe648bef1d325e4e1ed581faef0c2dc2c55d8ce6ea71bef160c22aaa23d3a1a2bb5b6c6e8d4dd9c054f2dd9502b9b445a91f0f1e1a2aef89a9a2786b51fa51b41dfe292832b7a26a0c042c58c95667852a874028329a5fa5ceb5b70de24be699b06751b22ece9c3d2fc9d708573ed880dd973998b40e8f7242232ff121705039838eba15174a081f5cf7313b61aa83e97770e8d2bbb75e9fc6caf6b635ee4557a6b411eb2df115584eb6450a88526fa0f96c39a085e28b5fc835e709c293bf0aea72e6614afce0111a314e755eaf231662d189058a369fe040b5aac0493c5d45f91a9d7cb58427cf12a0c8094bca37248593eac162c94ca1eeab20ff86a1136daac9d328afd0ec77d4502eec217b2d44c28dfb0c1713540af2bd9e74f7240a0a79114ce98f18337edcead450789a1e6140b591dad5468564cf22bddb20e2d184d6692aa330127dcdd8b2d1ca0c2b219a54d7554f7ab14c388d45067c550fb0ecd7761369b9b6a63c9e2902798f8f1273e266514a63189f562f773a1f5effd9594ebe35cc6d710c34478ccc5cc28bfadd9ac3864ee04447e02a181d8a903e507aadb310afe00125c2b9c6bc891956919d82b9bd1ff5ebf9ce9cd63637625e3d2051a9c627fcb4d9037b8de7af368fc71f5068919a968fe45dab210fdc94b9b69d06105b86387de71c3b1e9d45c211df4ab8977a9902954c0de482928b2ca8be208bd9cdff2a5d7fd3e0fa70949c025e96217288c6c0a0257712b86cc03148f3ef7d3b4e619bda60473f46b61796bfd9587e192dcc6f40306fe0edabd793076afccde504c869009d8c8759545035da33794a1fcf6961ffc7585215bf888f7994f54bcd7fc514cd46774882b50fcebce8601f5999074a98206b916d2d3c63273dcd4a1de5ddc1adb4ec2d1c67694c86de3be934ad31fe7e1f1ce586af182a4caf0583a2667809fc71d78324c77651d5986a8ba58b1e06ad0e8b5d7771f59234a71b0c7bb0777385a8d37dd638ec4e61713043fb5c5ef413a68ec69ce5ed95bb21f9033480e469f8ae5ddd0d56438327ed45f876fccf98d8b85c06089338d31b0975baf476ce67b2df7069db2c185bd423a0926234c8ed411d86d1c9efe5ccc9e92208bf338936c324d369c23c46bbd40bbb174eae1d65d0eb90c716c93b7f713f8019ff8743d6f6b9a851139b62f05f8c9953eb977b98843d49f3e88ffb1d7f3efcf0e9fc73bea1c9787d095b774f27cde9950ae4d599d6d868a13a0842df8450dcfda02e9b2e50e5cad256af3e8b71aae83a4e3126fcc30e9753a8988deb44319761ab7921c731cc07a671a27bc13ef708889031df183df6f690b9f65c8d69cbfd7fb1e06105674df80f4c5afbc4ca88d8984029aa5c9364838c0bc040eb1f675ec2f208fa07bd80be1a56c5618da76c19bd2a80aba8c4f6865a4a1c109ad5a7a324e8a5746b548ec88065acb1c64e699e43da940f666c129cd3e2414a17a0ff3af774f63dee7d967f5a40a50b0317cb11432400792964b2e3bf9e51092b743e21744c3d7c5e409db59c4ce73925597aa29527789854c69a94bf17e14b3471648b70e8ba6629c4f9e186b33734b4e7b1c460319f4cfbbcfc4e48a96150c514db6a1db175996a48025e336d5dc6905b22e9208ffa5dcb0e6865dd1b4dc347419b58079609137a8816cdb27193f367efa6841cdf0d17af4f6df2b028652f4838765fe98f5e2b95fc75f2a41597390953db2a7aaa21ea000969811f82f65cc15a6db74a4870723f12d96e1f2f5c4d99a02e516ef7d85844338f13f76cc2e4f3c82f4fbdd79cf6e3340f91b0f16870817f881d4e07604a4bd1e8470da5fc60de3787c1dd983640f511a2b72c8521ee44995d300c0b75ae3dbd4c72eb9b5ee09e567ced1c09d34e6cdfbf3ad0270ef638a0b17389338ea628e2864eeea6cd4784c36c1587b0fa3342396bee5c435729fcc00c7a018718c40bb0ccd938eda4c0027c6001a6570d5d59e7ab24a96f4ed1141ebf87f55a77e5f280fbf3fc062e42fe80b91c1990363f8d2721c678be6e8d90dfce9ef96f24a13d3d6c18e7c1f8c5a175651c02e92919ba116ff8bdfaa842797882ecee009e553c0f5187afe5b57a85e7ee3d8d3c99632a90c7c8f28a4ab23bfb733a7e7681295c55cc4d06c33e894437cb9fe195312d04bd58d740c7865637397f6dc9981493361542e9d5ac5c69729aaea3ef32a933c11ec7d55e5567c198f84fa0ed880605164289e5b65ef9007bd675f1d6002056e82832ad0f09a743d83759ae155c47aed690ef67309aa0cd4943a973efcc00438fdbddf8cea2fe9c69d7c4a66c2c8dd2de7c49047930d48ce124975e40a7e0ca817e8e2c6073f0f920ff3df88a279b0fed279af2d61b399702d28f874d2cc6dd39971a9961ebd44c1ac86bb37e49517b881344cab8c0493d89715db7921852fe360ffedb7a78e779e44578b99f4c29f0a1c23c769a6b399870e13108e677f856bddc3399bb0b838d63c22b9f05476bda01464c279d67d7c094d82da3dc0955a7fa65482d29c06cac881906e78bd0b732cf9bb86892310271aebb51cbd4ac5d5c888dfb163c023d750b7f7553164fe14afc5e8f63762523d3ae118c1cfcca992f95b7bbcc73ccdaf64dd336faebb61ea4f3c9076353632d176b057aa91c61ad1496a36fca072ce3719cef522aef3a605c5610a025a220dce5e373e46e806680376eae3c7bf7cf004aef61254a9e494fd913677cd24ed893ccd3328a0a444b75504c35c3353523f23ca0da732b1411f44768f7d73f1bc85b19ebfe95189f3e48bb08c150d599d74d0c895d0dfb25deea3fd7ba6eeaff068e5c41fc5baab2cfdb89a18868f5c23d540a3204d20c45367314e4f650b5e562500387b7da03b1b5024741fda860717676971cd9cb77c711f91e9974d7f4ce77746fd754ed7d77d878a655f1b65b6161ed42e8a812aa1f218a8cd417043f5722bee3c684640fcf39d63297b350fd0e2ef650423a3279f99384a9c06157a199919bf4ecd8bd97aafdd81ed707c4d6b16b3f00fba4684847cad1287c376917cd1558953e506fe3e5742b4331a1a378fbe96e9ce12e89c88e66786af2b95d26fd50c456bf36d450178bf54a3dc2173c06ee81c57e6fb33fd5e7efe8f89fdc3ec7d724f4f03f3f180fb5507ef4ca584912867a2fc712a6a32001ef59c661d3832f6e8192ac80f3b61d1a20727ee2a3696c4f734019d2f1ea2622c3c450d58c4e708a2b61c559d6166ba8ba7843c2d3011969a59f9caead53e107ef3fe2a51720c9ed457e4d0e045c15b0c3838d6a2a4f2054cecb8300bee5433b64a49ad3e8033edbbe5f91a2a7f8bde1b9c95048a9791dd7db16792123fc8803e95df820dff3998499339fed240deb107aa3c75c67538accd45d74497278916c3f2e4933e0bee2a5b5299a04e61ca403789b6ff86f7f2cd936ec9276e29414e5c8fafbfb26f1602007165ec55f4b7445b5476e9b7a6557f1ba08489d06fd80bdaa075c83be81c77f512bbcab070cab73cd6357aa95ae41175117cfa547d7f429a0cb90c643abf0e83a59db1dd55e3d3b4364a063994a53b71433884f2454ab0deba9be946782100f4ef997c5c2640b09fd65f4cc94dcc6ae6f4bf30cd096f8a2f80a048b169d61191a40c93d110df664b261eaa20be551e9c7be0a06b30f83f4fb043f25a802758d2fade189a0f813cfa1887ec5b0d5b39b5b201e47bd22210cf6fbc221c1f0a0b907555f9b208a91d31ae87fd82e4f440996a02c4be2a63d83c32629503f70916fed574d526fcaf56add50213b7bfbaa22a78c93f11a7e3c6e10b1b51bba9f5e92a1b2c27ac3e37cfc025ccd0a847716014aa40ad77606620ad1623b1816c665a5895b5f59d686bdd1c0bb675de807d849bd18258fccf476a089d11a075921030d53e08e2eb09cb2cadf8307b7c0632ee647cb50088312e6e62d674b694da7ca93494d7e5b834146737a0cf020bd3a45db9f94b8f817384170ed084d8e0937ca69999d261266b261bf090f5515dfc0720450c4abf5d56dd27102a4f81d0b6d5e1235a3cddd8205a931fd5e94c933970c8cd3f3bce1e73a37f532dc993c0f6003696599d2597b168d7e2f9048a49ae48a3c044a035ab9c0c6dc817b5aad0113b3d92d03176be7917a2169eab836cb64982531fef43da9c93e58b5e1b0bdc88c858851f208d1aef0dffcf9d164c8c5854082da9bef2a02e801f3f587abf5fadceb945f82eddd34b8a9c6d8e5be09824ec7b420d914a138d5eba7beb29231f503fa555c67a7dc7e3e064cefddeec38d188d7e967c33b1eb1615b97f6c72459f30b9f73e2fd2fbb5354caa38b1bb26cdd80c34b586c9a1acae4b4fc28fe3980655ec8b8897deace64cfc890fac2cf86687b39b44808c513c845c3bd7a488850ac4ea0e24b1e67a8c14a20ed4a992017bc040037faa2adfe3c4557a40fdd10f0566e67162bcac67de372657fb88b83ffcc5b40d658a7990354feace77966ae62ac929dbca6e88f75279640897803e3d9e77e2e574f54bddd4192ffa83d2ae5d2e73a38a0011a6c1fd16034b02bfa2f3d15ecdfffaa1f5a9405154853a3de4e97ab1f8b2192fe755c6946c46853fdf46dd72d8839541b99c5f2fb508b2f8a98083e8b68c3edab3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
