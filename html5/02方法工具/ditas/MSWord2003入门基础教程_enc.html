<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7cd3f2187fcb62d224dacc4ace1bebbfc0470cf35efe7b7206bc4a7a17e7d70c731b1136da3ce1438a7544aede214c1152d211b41a48346930f668d1394eea692216166b52f22fb06892d05fa91b89985560791a30d4d947999e12a16557ddca79203f767cf6c4086a786ba89e47c57a8828ef3e8747377539a8f4c9e891ec5203a94c25e429aee9a18891b5d317212f319c7be72424582b1d2e7aea43fd02d25beacbcf6d611f48e33fa243309f5fc8c29d7abd066dfac7f842557b508973c0db33b94bfdce7335d804559811dbc652efe67440dc60c6f2cbdafeafa456cb9c19bf9b4a5aaa2ec7bfb50383a9589b19ad1e7cbd7477d45d07df25a6ce116a0b29b401d6ba22ce1282c77b802688b101a05e6b06c0a0250a20190a0ae711a65fb05d03c55ac9e7d5e0f1e2224048a6c901185555f979043635b0e21befe659b62bc35a8efee12fa6af5d47feb5b839af85a1a95bd21fbcf07f15c56a5affa1a5c30e2b705527eb4ed4f855ff835362777d47f5a3c30494dfbd0fd0779234e6b144eab0a4c46368ca3eb9005bb482da94dfe466c7873b39a37b4500aacc8260f8fba2481af410fd067248d0c26eeb1201126a5c9921773548878474a07f76699e85f582f29dfd151df1d5b0e95a324c9729295b51d77ea771f593d9299115c3ab24d9ceaf0e3421c90007d0f92119c9df8e0b61d4ac7018fbb7267ba45cda99225f968760d05df55fdbf7f8a7d7184c529f3fcd8e2f47d68e645af3dbfac2c69dc39a47cc3b9a9eb18da5a8d26740c683e63b2538d38a15f6904f14e5cdf23a5fba53a38c6704f0852950f81ec5832f60519609dcddfb7e58d5265608a79db48f863b2301c65badc83836ae21f9b23e1ac7f0321bf3a8e6fa8ffebabd0c3c90f0322966d847826b5b832137f545e53df87e0c2f5d4ba3ca0ae6d604cdd59682dfae92d9a4e033a6a9c02890dc7ca011c561935ac81b7dc18cb6dd822f4baf81a1a963bc82fb0aa0d981eb4eeb74dde9ee66e730db4c02f0cfd6ace1367817d594f9ef64a99a9dfb77d2c37d4b103f21c7987df4b77645be562255a8441e76a1a4e8fd22108a05602bfbf1d6ab6066b2314fdf399bbd976031fd338896984d2ce2d33d6b60b5b3ca5376cb777a11a97c64853a0ffcb65c03112fb7336516078d70c856c0fb4c20be49b0936b7301d0039268b04400fffbe2849ba46129a0dc46cc5baa6e9b6cab374296047dccc05755299de94148c1b570dfc3fd76e97164babdc4e835fded99da36dc724f060ab9a798892d01a0e91d369fb1fd6991839257478bcc1ff5ef5f4d715e6169a38ebd0182d33892aad7b401ea9da647adccfe7ac51fcf835daa7154a64cd4a07aa95966299ffe3d2b2c5db7ad4627c569c0b9dd553706527e0b599934d807a09c6b1a4cc510c2b83507089dbe4724da215a04024fb7ff8d30f64b89e30e5fc0afc8256b2e3ac69e6421593cc3e3babb05063d3baef762a09581dda30d105b39e36ab3aae8a0d4dfff7b2614a8c3b84a3ffbba683f42e10d77705e899074e1cf589c2cd1514300feac7f0431ac5835c4fb570ab8eca36f43348a944992e592fa32fb6ccb2324d011259d89bb512ea187db10d2c33cfd4651941bfdce57e913b0840d6e5312cb23393b8fa57a9eb93b3d80720c46aaecf63c368e64faa4d6034153e0a34ec4608bf68171e9f2f124158773220e7295245c0d9799dffebe8e44e85ec6029a6abd3a59d7ff4cf28c500b8c85cb10c22257b84449ad9ecdb3ba67157f2b534ca3e99b8414558155007d34c788e4ed0c11c32730367473c69f5a57eb2c48f1aa5cb3ea7cf11b17c59e42dc12fdca52ca619a935c0006d43a7401c74ac70511849599693e5cbc67b55827f618173f004fbdbbfd7ec3181a71eceb3ca8022c229c86346b6ef73e68d71a829b0c3a3b8cce2ebf2fe54163868a12b6edc64cc0cfd99eb041e432e538a44c450bd601becd90eeb914c292e543a1121f6aee6d12d5cff79b26d42e67d67fda3a8e0d764c6bb5c23f1c62743e06ba594b4ad6b0c2f2f12bdd75ebb68fb141117f65ff771d859260ef054c8c4c9f61d1ab46129eca61ec1a57e03cfc8046ac8dcc187c6a6fc17b50c75cf9445902285c3785525ed6b77810890e287d0e6facedf5b01dc9ecff52788d5c8ffe35ebd830ea8234a673c4d6b4c200c1c978deb894769d85bfab0dd7d3fb99ec14526201d22e2210bd323f05896454bce3f666bb245cac2ab4d78a96f83a8059c40d4635d4987a31e545e0535dcb3172b14472c980b71b0efe9b102ce480df43be400c93d3245833e8431f04ec28af1f475a86bfcecad75dbd742496bac47c906cc6ab3897793286d5ca02ac85b940135b1f9fffcf54d31fb401d729b4810fd994fffe357072ddc47238d92117e348366548653726b1a0f956cf96b6d8b30505991a7eabab4caab503f5568db48f7fc9dc7fb48f2e065d217c8d06fed3f224adc9189bd263ef36b67f3b94bea9ced7adc9cd001f0ad118660226a4debc7e9cf353039b616922d75c556a7d5eb04a4f9ca9f8cd05b800c41478ceab94b72b92f31619aaa15ae460bf2ade76ccbcd4b664edcb9beae01cebb9eab3d15798121f2eaf9ffc709dd61569daac5f22a1d2606e8ea637a687ddcb36fdd36ef3301f31207f1d764f28ec19626a7e8757ebdff69a7388da7c1940b5520b319f8be717f46e71e2a78302922cde649993fa3699b98f70915c89f3a50583b6ca754dfb3877d718580995edca938b4acbda25f3534d92ae1b3b86dbe5885376b559cf6b31374feebab93c55267c2d760bafa49c8af63466096d472ad56bc3b6f6957e9a33c2e839541cc39b25c981bee5aa382d5f12786e6e218b92aba84fb682f8a9e136e6a24cbcaefff17af506efd0b540198bf6ad2b991924bb135bddcd226f503d4b4b10a846afeefcb4cace4cc715ca978924473e47c9f67a56c20cb2ef3ee73476f95d8ba741596ca0d33e51d4165bddba928ed95f5c1f3d13b63a7b2b9e6be487fdb5826bf1d5702d3033dd59704d5723ed090326ab7812969e0ac46c6e0f8476703fb165370996bd0d822f593eeff155e16d2c6af63cb01d9d44f30f011d69398c2204794c73b92c3a79556b6efa1bb7e0bce2fc5b278020ab14fc6ea6a878f41bb670ad61777bf17ef0982dde5919ea8d13c1c46fad9696efe8e9b9ca254977f2ba762748a2b3201f1e3eef4e41838071d6fef00c9f7ac5d1edbb77be204d9d8bf95d0f479fa7a1998258a41850d8290445a808c6a734aefe65b0c08821728428b14f95afeb5eec08b1c478c113be2b9ed5103dbbd5693bd51a73dca303ca36ce5f1509c70a02c835f6d3cd03b209b5129e968f080d771c95bc6a6e5e96a2abe39ff82edf157ac1ad3e9e3e49cfde585621182205f13d234be31a4a41683ad268a719efae6273214b392a2a07e757ad4eeca18b25be3956fe0de2e61f1c596744f5e55fa836666499381b674f7694d7be68a9341ae21c32b66298bcd09c9f125dfbfe3f552a7e1d9b050d7269cdaa95f63748329d57a9123a4d4f227162303cb2078d2337d4b71a16b397834817aa6d6c74cf92281365422dd3b5da0a4feba08582e590203243cd8f9ad5733f5e29a200df2e86ab76c09d7c218904c6c13ae81d3efc4d5ec43957bcd8e74c48368269ba3e3ee24fdfad9958ae73adaa2388c4e0af531d133e0e47eec56b4ceccc5942c1a2bd51ffef9f18a741ae3528cf17d7050396a1c8daf307c5cb431404e36edef7647db499e164b5a17d8b0e40155dd2721f2d4c0e964ccdb63d4ee0304c6a561085717b449042da623fbd51e33cba3c856ee4ae3a96610dc990dbc84adba3e462dfb59d5fb8e0490dccbd0d8b7e6940609b1a547df0f6d36d161f3713238b8a55b9ba63925a3b1af5afeea6a175ebf13d1eff776030d767b0f1cea5ec716d3801cc824995ba35cc52d46d5e826a8dcf7ad5df7ede380c742fb8cca94c97773f9e9c7941d5f49e3bb3ef742c610f5968e4cc84d9118216bae5560afc901ce1872410e9666452e7cf90452c83d26e14aec10f8668b5ccc3499b195a14c66f7cb41e81f3e8f2a7b2891a58f6616eb0725b0ed14b6c1886221e9aa3dedfa4e77da3aac714aeb0a360bf6090346f83ce571801baca4203c913521571e570bd3f5312db7873378a4e1f3d3ff82f14e63366816c8adcabdfb2dd3b818b13085b7ea9ba3a7d3f3ee6e281d0fb852c4bc02cdec08f3f5faf33af78331b4786fcaf8c3a30f97725e581239268b8440b5750504bbffe22caccd3e43caa512ad9c3bb737e34a02c55aad46ad93dd1f4668f7056c3f5548052ce11a9855e3b5a4582b9b97ba302dc1ca23568d8ecfe1ca55f4c4cc305f42d8121e50039f3522d58e0e5cd53e823162403d256e3ce4e24a6c36370c50120991d0b9b39054eb216a0973b09258ae07455573c05dc6bc6e0f03c8900693f174c0dbadcf4a3f958e6c9db0fc0eff11ecc2ece93e2acd0164fa423b76a834b5c1c8d9678091c761ddc272935091e9f5b35bfc23142e5e4ce5da980250833637f04b24b2b4baa5cd24d97459d8d88e34a6496dd5f824a976f7e8f07fcda781c9aa623f9554f306404e7a0c3306df9d0552f7f37133d4d50fdca738e451834c5f877f6817df6d3b47812aac8c22b4b75c99d83e9b3f0d90001bdb260ccc1cbfad599a6b955e3b30a05004a562549db98e2008090a4ade9122a01998c3c8dc1d10a43c527bfdfda39ea3ce6060ae1fc3edf13ec3e9a7b2846f1026bc73789a8f24f55d73bdd50303991a19578debc7765c3b435e6d882625d544056e6a7204ebf60a196683f2c6a64524befbb1453297b9902cb5a65435f5a6bdc07e633e8f7ac0f38e91eb78bfc39b5efa346658e4093c7a1c96044bbf8d95375b87e7c7322a5202dc864686b8af1606794fc26421565a0dbef018df844fc7a68952cccd292a90ce0d9a102df991eb8815765b1621fdb9549e653d97932b37f3f862ce0de52f7da13b044ba19c85b17770be6d52573b9e91f0b71ac4518924e418e18f0f5feddeb9003899fae714e004d996616043633c8159a6dacc76eede26a9c977b108360379adf5b662cc7ea132b727d1003b993439fa5d74573353d6744b01a7dc29014963ddaecb3a798afc00adc4945497705b0fa961dc12d91eb7fd27f18f9d16db5d5c2d9429116cebd15378bc31afc0c5e201adbb7e507dc72473f87de9982dc57629b883db96c6795c78d5d438d3776d5581b6b6b493b9551553bd2a898d1661d2ea4cd3c3926a3c11756808294e0626fb1904a0005def2dfc5f077e6102de4edb95711ffb241ad50837be30aa600d7f9433445ed20890ade2b56413a8adfa0d59cef30fd15954bb3d1c8a27234b7fe1d7a53d5b34c2bc3d971cfe3cf880be7ac47d36f67f03e8ee761e25a3a66ed2dcc10f480bd48b8721011c08cfca49f2d41605add2d44f7f33a865d3e20af2f7c1551f976c9ab37595419ee9a503b36a5f20812bc69a42e56ae38b772eba03246c231f1b5bd0349f361eccb4bf0731d80ec992f20052f06ca538c2e4522a9febaac6736355730928f2ce7b3fb4425938c3aac4528b0dd99ce71aa405894b2b0f400f0843a35c8b5361af93a8ac6bd544b07a184bb1f9bb7ec0660ec398f231f7a7bc03a023eddb39d9636e89a71b6a388da19843b41ed796163e6e6c70c9ead4b0a294642aeb9e53c11dbaff9c9df893a2ded3ad43d2e4c125510f170da732c8b465117e8878fc6dcd8efeb31cbad8a4d58c696fe7723d4384b58b65d2e756a6e1192343aa958866e59fb3545342aa3e634eb1d4d26387f1ce64e2ca83e763fe0beb9b8afee103add82cd58442b794c05fed9d119c4ac9a48f5b4990ac659914ad05e22d0ce4418dd53ec3324e0832d5b4c0e41c11d74634dcf9446eeb3a303316d86f12b7a7993937c3dbf95e66f5183aeccc77ced5623db8dffae8ff7715c52f47fd6604c507e8a7b087cb957bcb1ff0312d51ae2c78e90ada9fa58c1dc62c059f0f51ca8b6b065dcc720fddacf174e8caf91abb3d664b8555e11b3129edaf812c8db68d962ec2a01949cb07285bff525f2dace1eeef3bb9a4c4c2450e42928e4d70ae7ac5a63e3bfb3f0a4e818535dbddcf3c67be01a9d1bba795b965ae1adf98321c96bf6bba4b1da1ce426fabf2040370a20cf4818483c43ed2fd019ac1d5cc0321d88930086dcf1f9401da35e522433378a27462164e610c774c9958bc57c951bc94bc9983899227956a519e09c60696aefa1f69070733d9ed87af5b43c9f50439ad1a2775c388992e3206df7c13f872c69074e57d23daeee2024c130958a22b32b4f1975a903b814491c93ae495b3da6d227937fda0e827f72c4749353774dd033307d22f1d1d0f4a51506d2e07fee2be05df4c968742d8d5771184b4df52e0005eb326abb65ea75ebecface8366209ee58bc67719a60de5a3f1295dd800997304d70ac24d506fe654b014ddce1b6a0265e34935884c940574b16660eebb00d538cddeaf100ff7fb4335d3d32529638e7a38fd7584ed622d878a98de94b6939006786603b9cb031911f96457ffaa6e37dd8f398c520b5d985d5e07d326c6fed0d0d40c21d0aef50c27ec83a008daa88a7daffd76a8436f7c4a024a8992aeeddc98554a22e9a621c31ee344d74ddd40324c7ebc06ec1f4923118766c660df4539b2d034f33aff2eb80ca113da7b80486c8ba86d43b3a15c1d313bd33fdeef27178511d4f2b02d46dbfb73b8addb8a7384f660721dcf152a73407289c73480eea9bc8f56b24939a71f2e6247dc1b5a55c6c9a79f84833fd6d96c2c41969e66f35ca42b1120497008bd78479d2be878aa7555f8dbdc342d13b0f1806b0865c466780809fc982852c7413c35a5b04be9673bb4a118bcec224a2d2becdf831d4864c2bfb8e61c057df6370a9d28fb6075bc2fa23a6516d36807aba1020297fa1d0ea055749e363cbf1fe02292384911315ef5e43160a6021a37efc32dc9b69d94a3910c2a0171d63e0dd65fb4d4ab560dd93154beed4ed0d22cfcc70139d557a18cd223f138f32a4c131bc44308f73a09d862aba65fe9432c77329d71770b0d0ff201cae83bf9cadc0787bc0af44e2300011b1df52afeeff48906c7c778ce72f5b537f88f1f96944d609ac10a5bdcf93e6aed1d98c70f41c4a53985af305b8a24488f4154b5cd8593d2410982107b6f7453eb94985dc8c7513a72efd21c337bd820e8cd791f82ba5da79b450a40837cb204944ce96e09c08a5e8c9b7e2cc60cde4b74dc76f5e5937a0ea7c3a9cb6a8a49a3a72df973c8443c7cdf18eb654604cb4e3b57df84bfe437b78ed3c04ce5092435c7575bf7f0c50517cfa47402061a1c86d0ad391fcbedfcc880fad66a81b59c5964bf818ad9d79a70b69ff75c13829ea26a827db257623e0871416f2e3a3f940cae9040c3e4a05b33e9ba9c1f12317c527202c08450015049f45e1232666ad671009b3c99752bd8f7e1ec26a402fd65c3083a24ebe49833527af060b1ee54629dd3a6710d447e4b51be93a296ac4384ff9b318ef013230e0292c02163aeecc4970ac73458a34fa66059eca44db23d7c4fd1e1d01c7a5f66d801778362884358e1115627deb851562d68d45da9794669114fe4225cab896d20e6e5806c8e0468501bffbe103f8ebccb1f97e644fbb05e04faf980cee82971ebe91292b6ec700c2ed497cd79422d1a62ece902bc7f77e761d053362ed3d50737fb389c207789cfa47b866d7da24440b9aff06e8624647014b9522f0160546396cb170b6903be1e4a5954cd3328d52a9bce93d9903062c3ff692455be812e5c3ef68c15d287ea3fc26eb24facf8ee3a573a0af39a3819a582db3b0ec2d62dccb939e2a42880808615c73588c165a1adaa1c1f599cbea86d2be24e5ecb70ad9eb8f472aeaf29a2d18f20316d057a20e4e644d0e4feb92ff1e47a50c52a9d702b4e5b917c297bf66b9751d94d323a4ff603b3ea123a1ea0eb142c00cea92e0bafa393991b2373db7fce46110f4b8dcd1c95fdd393c5cfc9b77346692572e3f9d81d35ec7bb136d582c89031accf362f3e1ffaf4dab3a22386312e477a48f2ddb5956272751fa90c34beee0b386701c6ec1d2640022fe349a317c2b49313a98f87d1a15dc2fdab4bc08e8a94377529a9b6e902bd686fb574f613b5a71160265981ad2a0638f43b630019572e63692ac421829f2acb9b273b44a5029d2bc7d91fa05ce2797372fa504698bc72d064f49eee8df35f1dffd5761c12d708ee879ec813d793de36dddf567506739a06c97d7f484452dfe959cf09d5a8143838359d4d460f5c7020e5877f491d6b0d709021db79eefe0de80a371214ad505c53e1d6bf28c4e9b7b63cd9540aa64d70e20cbaf606d0fcd81a9350345f7910a761c91d257922a289f8e34e92cf10e9da3cd09159fdb5e4a3c8d125f5ac82aa5941fba5de5fbc051e442a033397bb774891aaf7bfcae64c11c3460420f055d4eec87705b966d48c244b3901191b4a9c7fd08d1c8a0044fe1408debc35634c4ff425a003747e0e51670c11694fb0bdea99cdf77e559b4ec941c3cf123dd2e6448f76fb17e71314c35b76cc76dc16f82c05049826b73244fa0b0bf6c1d591f87e54987f1d27de2ef33b9d8ba88c929ed1f7ea6d34d791733391883c5fec8ff3aef3aaf825ee17e2c25f7c478c5d80ff84976b6e912bbcda5f4ea24e7a28fc54c2ff3582d385d0df0af7d8ed0f39fce00ab34de2277de7d791161775c885866a1673e89c920fe2f9ac47a8842a4d4c9f50f4fbe5f74eed83de6e0641f1927be16050ebbf6bc7e1d4639d89da6b2583189dc88264f751c77f362c38abc1b61e19effebef753004d2b74824d4af267a220f23c13915d52819a6ec3878563bbb15c2699a9370d9823bf1d41e31f603a9c1735ff3fe9c7435cf4aac64f1ef4d99ae74efafca25d6a3f83f7b29a70ded858c1e987b20d4e01d355f290c214896fd38e1a5bcc9e52a9b7c872826196ac223193d8afa37f8a8f85e6a6f33ca59ac54bdcae6b7409e3190a8b425f6f5b4a07dd9c78a5f98bf4780cbec1dbbde21fbedd084f0d824bc6a217692301b69129fce9c70110dc7047fc005256900c0cca537ac9dbe2e1edee9f0e969be54d5eaf43f21465e2c9a1c6ac350d4678d0017c3f3b3f74408f7afe0a64f64a0485c73cde9262562f7bd243c7a6991f90f564acef8e7a198bbf8b74d9a8788e711cdf278706cf338ea2f33f5af6df3c5f59e194c959d06f20aa9bb39991fead0c2cbca275c5bad6c355d49f6345862f7beb368bb8d19ac81a066c0340f8244d9a3e1a2eab5e245149342c4e92dd7638413f635ff4e0f8c7b8045080dd8c6bb683163aa1b527c98e0388a5ff6817307858015c0819617c59fdc3be363eea3f9f2e7e4627045e33a153f8978edb4e0af6e1c85eeee460ebcc9312a0d6c2e5cdadb5e1d61e87c72e8fca80c970a65e69ed06be662c047dd016b03bf623696192abed428c0f39bd40a7e20c9dbddf1731db6c8a97b0440b1ea8941a69f079ad6b6c0beeb7ce2be318a16d5aaad11e7883cec660fadab003a2d3dda4fc44e410db76e631b6ada6bf05037ad921dc4b36248a4b7897e6d099b9e53f881d2fe577de4e720b0c046edd03e4643332a209e3cb098b9681a5799e40345842889de6d80ca2ca7a5dbaa27b99be21f7d2866e61d2960745159d659b306cfa954932d0769481bfaa687bb84c23a63ebe8ec98f00cceffa048a61cedf28cb7bb4a034687e381b7296773fa21751aa31d46a2d60dd2cb29561cf9c0116ffab79ee97514bfd1c35bad1a49ab16561f5eed004a8ce96114657d7fb431f03cbe42f2e6588d3b213c1bfb937deffd33888adc3de81d54e7912aef15654c936d5ca3d6f41c0a740bea5b2aa2ada5bdfa40869155cda6489870d7ff53f72f8676526b998128f582b497f6a8830f28933635a5696880feb55f21b3b883f8ab0a0d398b92afdfd175fdc4f3162518e319e71a2f5f2bca58ca8d7c4369d9d169db72e4db96ede1efa53bb5a0e554090b0589c9820261addc199f9450e2f3d63189e17e2d2def191fcea29a3ccd29bab42b210e003395f5a864511e8bfed365ba61d4b01c9322ca2ce913db02df8f369af0fe69cbb08062d41f48e484367901e60238eccd9a09b8d19ac54d79804ae99c13fef9f1f8990bacbb5d0c48673be1cdb092523c75da2ede4ed8be0caccded53830ba94747278abe8a17ce99bc579a122544e5127b8fde0a4740eb21fdbabd9dd365594c3da5813129ce8d36bc1c15edb98debc8a8612bf1adcd3a4c997d323721d6ca6763079506e3111dece1fd420fd2d24e2e7d30a70e192fc287df6392fa7547bd552ebb0d9ba0bb3d21c80d4e12d34ce96f902f8684ecfc8e05b0724cbd3b64b8b356313a24d0bee523d4a62ff8067a75a4496f1c369ab85917255b1d3c88bc310aeb5412fba840076c109883cb9fee06cd8406f772122bb357c145556654a34b0df07231cd77e732a3e5bdb3537cd4dfee72e6d1a047c584dfe83544d2d1221749aceebd3cb8dc3fab19a3a22404b2fbca337473e08d6cdfba0b5417ba3e184467d7f4b67b859bc77fd21d4ca3c148da755294622388e160e69a30788992f2ab1e68814fddabcbf600ec5e7e5b78212ebab8f1e8b144bc23e38e357d2b92bc9037faf220775aa86023ca9d57f1a9b6541c2f81577fb153a73247d2aa20ac62e604bd014b7b520ddba60e905b510caf92eca29cc86a600968e40ec8c2edcb7cb1c1c6dfbbca8f6e78edf764678568abcc53f9a56709dee20d989e601a960b66ce38934bd664a25746eb72cb37ddbb9054d385e4fd9dc480cd954116d0620c1747efdeec426c3e61dc69f6c8e21a7568875bff1216150028443e72059df3043c7d9e2739d693480aae1c1c5526298f8fc83468bd7ecdae408524efe4207886ba7697b60f2ba82679df3209263e2e7893992875bb6f13be3a3982958485d6f2275b3f4323960ef31256c7e29b298c7319d88a025b2b080621484aa74d61cfaed29e70988317b07c7e293d436c50e329425e30f15be1af036ea06873c2125661a2c5a060816daae1d767444d7bb5c2c254f8dcde00f8c5e937714d2990f5de923fc80ed7a296ad027be586cbec79a9b9c12767abb86ad04865a6ba08387b7a72b887517f34cc1bec1061d400a2799f346934510be99881b178eeab7d467d14371c517ef08f2c5f8b025faa266a332d0f524b1dc1516e8e96bd727050952b4260aeb5e16b9bdf750b042ef815cbb423329c8660e3647983ab8ed14ae947830ffe11a5ea04c22bca3907a8a8e1d23f4779730573d8721b1456ea83bee42c17807b5bb3d199f1e49530875888f3471ab38cb2d0b37f7107cf14dac644b9b1522c673a8cf6c54efc3293b90d31405e1abe48f4b08d786b83c292a456ea6f290a4742b37d48106dcc54938df10516a6ad6dafd6ef77f0350e8583988f7e2ec6d9a112069afb4273a053196c7822e19928c9b574ee736b2cf9d3c15424c7f16266ffc4088270936baba2d7f82a82e4184cc802b901e845604e2a8e02ea01c345954ffcb317e24978a3ff1fe55cd6b830a964d5527ba8be06dba68576d4fcaf5d3d34435b90b79242020ff46981871e90db3a734414d62cd5b9c7ac97c29e363c3bbbc106d8fd4ef1f849a56577c89a11183f2b45547c01dd78480fe0d1e5633004e4faef398db54d3780de1a98a992a2d0fefce3d99444119c85e654851095931df7afbf81d6e9d229026ed623fc97631e35151c3544597e6ac985bca3c0109e77f3cb12ba9281e25fef056c79f6bf86e7fefd34af395418cee71cf4979fe9f8ca418cd0263149e2543184b1e199dea4fdbce496cb36b297762bf87e25f30f9be84ab129dd1691b0514c4465ab8233397f6e12afa0a323a9620862e3cba88b5b712f179778f880a4332f475ac7644ae993c0da45f36f6a98e5736106230523c4e4d36c101b54a72bed5c89687dcedd9d57773a5e237ba4d21b3f9fecab6bd1abfb841e3eb30ae86a5f322b56c67a326e82515a3933ea9f29dbde8736285e3d353bba8d57ee710de32a73af46331c25662659f894c71e444f2546e9c256ccf551be50d7c604ab6a2e31976fa2ddd7b7e1bd4740dfcd707934e53a7363e7c73df33891e0ed2cfeeb38442200aed5d3b62537c18ab270ebc767016ee88fced335ea7130eef5afe29b28c4771965a6351bfff63a3b996d374bdc692b0cc9d6c607d3e6ab82537f52f330240cf6074935315abcb357482473ecdc4b8308cd706efcd91970b49729eecb6638b8d9b2fb3cc78f3b8e01d547e99849dd21c06f3494721207ad3e8c208000d894578bd3db62808ef3b434df6c6b635e8a43e64841e3d29d6b58fc91cc31903011b5a7885270fe0727dae4f80863fed6baa21a7fc2e9b3903af3b8d8f7e12567dcf6bd1dbba6d6e173bb51323fe2c8b199c4e1478e15d5e2b5be456e82ce4a99a4148939f586406b2aeb6b338efc83d7a345feb54f166914354e35ec7371e311bb1087914cdf2af0308dedfa94b2a61f3c81f8d08ef72ea9ee186b7bacbf5ced616f45bdce3594b3a6daa8edbc8b819c87e42cdb3e87f123c49be44345028d8fb1193e1e9176d1101a6018b40f22876b1031f29048feab898a3e154e4b4eff0e239f0bb5153f962e8ae90ae9a175f658890b6e9f27220d40eb08e3b1b97fa5b395b554a7c343e0b98969f889c60ce20dd69dae43c30b55ebcf4d532d26144300623fcddf6b60797dab70eb6972bb30e75e75e07af7fd27773083e6b071c03d2b532c7ae40ea6382b5a0492b7babc4a7110285b285ab0a433c050e5dc13003c740850ff31161d57536135b4faab7a4606c224d29dce9200dfd482e00c9eb0b25c5d2717f436db01ef421776e1b16529fee36006bbabc67327b7f0993f1ded0e1800f96bc4e4fb5524dcbcf8992f83bd460031fb8bfc9960f7c8817955f4e83091b85175a2b4635524637affc322b7d38ca52949e6b0096a00c5db35acd5cdcc11b2a87dd19edb300989469bd4e78270e1f52a66a300645ba142f4089f868554159e8d38323c0cd627c6ee6abf6eafef0c021d979c143054a081a038aba09d1bdf3d62865be7c9b2330b9cbc83a71ae394826417674889a8b581c4ec87301fe9ab90c8fcbdd6aae806866c8ee6849609994ef9d4e0b11535a9ee6709d8aa3a63103386b95e4bd5899a3e424a04a2779a83c723490712c39449ed30757d3c1f556e62ae2c0b4c7932b138902b6e5f95c1cd2ad41e072dc56789acdfc9114d70976a0ff053b0ac640edb8b1dd093e246a6bd2514c19130228c896255c65b6dc610d1db2632133389fd5c75d488cf1713e02484e17b05363158786dd7bc56452e35fce19e891eaac4dfe47fe59fb3d512ea99ab9b1b62f63590a782c159da26f40fb195fffd6d9918635d6af5448271d3bcf1b96cfb789b21e9b6ff7a085a4d79c97bd28f8d36d11b3ba1e8549b76fb6b90f613dcadc228b0169fd7b8c313f9dc6d9822d5cb8bfb8be09a9f3474878b58ac6b1290770349ff79931ee4f7122dbb092d66f1fc9df8d1b8ba15d42efba738a07b64d6b881f2c5969d9a9eb4b79eb333ba147a23788f5cc13accee7fd958105c27e8116780f98ca35bb7411204ca970b96939669ff5e960712cee8d2c59ca55788c15a62d12257468bf8339ca5c1a709a1ffe095ed37ce0ad43fbf22e8b6c2a9b6f07fec85326b98820857bdfec2e62a9a139588c49c90ada58b44a7749aa57a2212b75bf0fde3c45b4314256ed223520557e180c900c67d43e226de5fe68a083bd7b03b5252761004cf0bd1e8e8202d5f5a83a16ea7301389d92f5b875edd9c0d2cc3ec27cd477383a507d275fe77740762a83df427d200e7ea258fd931c6e944840f1d2dd7fff52a80961db466fe95bafcb74b90f8cf32adf40ac59a801f1dece443f37dffd5021960e8ef4227ed3d7d748f442ea984d0b8d6dd13739512d56aef05bb8a01224e09c9d7a6034147300ec0db947fbfa649f24fd5cebba9e3be21fb9f2265446a51ed9325cf3b71e045e40698c3547aba47581bdbebdd0edb5079ad2ad595b610000442e1f0074698aeaf39fb28d7824c2cdf96773c72b016b935895d9fd1aa7e0bd59c0442b073ae0edc87551d581b3688943e24ff7a1ba9b2752819867338d2178e9345d5e20910b6fc5a71aba52f4067c9adb64086ea411bda6f5c63b9a56b2b84c25676c975312b76f23babf08fd2396344ce93545cb6cbe98663e8a8385def4ebb9567381cf440ba546a19540d366cfde1aae3643f7d21813782eb5e762023054f68106cf864cb8ca6e59b22852f8a859e4005c489e13aa7ab52013f5bc94b24638df5cd3dbe1b974ec68a1558f45e483e790dfbace0fd7eb3ffc1ef2f10f622e97b42c30a41b69c0ef14b7dcca79a2f1b8603d0823de672d8c38bb61eaad491755b50ffb820b01c6b6a66f2d6b5f6375c5b740b0bc56ba2856ad1a9dd2daa45f2ac05a457b52cca57b0431cdf5500dcd01b0fb8708f32d4a488652fa990254c2c72709d1ae8491985ce8e560893afff415b55a95e09454e5b1ead5e70e1595ae1f4246f9cd1dadd7f04616331b017db8180bfacc595d714eef2f105cb71e701a7b8c1278d4ccacd1d70bdf3fc70faa612675a9e48dc08f93821f36106fd6177a3eabb349ba783c69ca305c56bdd9c4c1c9eb26bcc0ba7b80b1ba203964a8243720dd4a94a028e384551c04922ef363669b558daf662f4eeaf6083af0efc1f6b49a878a6c21bcdf16fe9c05e87ba5af53834261f58ed8b12f7b748ecfc2cf18cb0351c842a1b30e93f2ab40db0f1374166d66c422070f872b1dee0ccde0a5f1c459ae45ad7bc5b2b85fb231d38266fc67b308f6f7b9ded8c02700754278ff30bd66f6b6ed098840fa0da570e217ad00174c71278957d5600609312a97fd6f948902edc5219a8a570a8f89ae8ef155d6a7b99fb1323c00004df08e6df92ada3abda017c3b1ecbcc0ee15e67a308c79c499bfc89107aea92a1b2107479e0bdeeb58f7e042dc053884bd28f4ce22a9e4f462cd4e18ad5d9b05a336208501e9ce378981b6a19f96b5975f4d16a63cdb4d7287161cd9cf5c62f1bd3cd6c4fb268231967c186f7ba290a21a1501203e11e572c02c2f762a847f74998e7939662d144b9d6ac656ab378e41dfac9c66643e2c95de1e0fd40d8ccd7a20487179c0b6a3170b42a5c8f72ce88545255c74a99c038dbaff35b4b779fc6ec965036f86863f5d0059c3376204e564605c2b9cacd696ca11e4f68c591261cc83e767e3df3bfd4613c9386f1244623ea64baffe5e2d210b17b2debae7568c77b69b4a5dd72068a0053230f0b54ae04f70de4c99825f1d8ce0b03b5d46a9204cb46d176ef36cf3eea6110d7e5e6c4003b532c5963a04a76ebbc0b3dff3e436fdcaa037bb13e6b8d84fc03f77cbfd36a64d20727c0886b8265df683b8797671b3bd74df3ca62bdf21cf3b127ec60b76c6ba2bdb811ad1291e0d7074343665f38dda400a4aaf7a275f149ff4b72b9976809bcd963af2e7972de0c690d0818880196a67e41f87cd17d116c6216cdec2bed09384b483e1681f6ecc01847176abdd893edbf93f265f047d629945d770638473befea3152af83a41da0c3b14d118ffd93160c62f49d9f04781b08cef2d4cd4acd0e4297d8856405c74588b4e46593edd1d60676434d661ba7d20f7de453d1cc791d330683d3a6ee2906d1195e248464fbaba9b310158b1de107e2cc22cd77aad71b558617a5315c29982a1d2ceea64e3a1820ab39383e5e13331f92b4fea09882187a623b7ed765b54a4c63fd52ca09dbb6c29068eff0d76554eb301f3cd963918fcd9b86eeef067ba1e7e47c9a2dfded668c0d5fb684a69574308e5e2268b282ca3fccaf5d8807adf2cd13a7671057b360d4afb88125383dc3936d5718f1ff025c8f59db1bd3efbdb8e6f1324b787c53bfd161970572742fbbe10df2e200ecb81db84ef135006ccf4e9dbcc2d62d97b217b7505a6e8c89f3a66484605664412f3af82a5685ce4cd76b59b2fd25fc0f4915ad96f26a8c33a8a3d6a6e78116b017e69a26237192b88cb156bca20ce6158ae1630da17b705725503aeef1d027aa66a884274a02e58feab3699a5e168a8e2ae49ddad0636a442beb9704683710f8b69d98a3a2d3966241088d074564fff430f10286f279dfb0dcdf23b2f0d1e37beb8e4f1f19a482d58db32734e9f96119629c78798d8f8c33c2bda72a96a5af63b48deaf704b69464d1868aa5ad8808d8ec73a140c1949d6f0d1af6c1f7a46e91cc2a49d9d0dd51a73512389b3024883b71411ce7139e64cf638aa92799af05d52375ff349f5b6f746b0d821b99ca6e14082fc50b58c4525562e2aa13877db602cbe5ff82a8abff520b77171a0c282ca7b4a20844e91c4750278159c0246409f66b38f77349a305e76a32de7b86cd8ec258820db459a8030d906dd0a8f0719b71ab34a7d5d56deb6f2c9e3e166946c6fbbe1fe9803ced3e4ae55abec0128604b5485ab0e67dd95c2e11d5f495928c2fe32ec48d5d13852ee70d4d5cb266b833e6b7c444a741812ff4cc608833c957251669e3ddf34ad916a612e46f6a35cec038293dbeab4d533cf2bffc0048f2c017d99b52a82eb83f2df174f30824a1d387b9fb85561a676cd8b16038b64384ebeb51bffa2643fffe42fd93d839351b02c0dbb239760c95d1e18a237991788e0f293546f627b0dcefbfb183f266940761f3e6855b78f047a94908db50e00ad5b65e5934b94126c5d907ef1a0bea5605f2bbb790d2dff39f7e62366bfee6f15f95a7ab04f41fe46446ab8c35c12d3a76df84d12014afc2039634260b012b6829582e84a49a7c6ac672f831e29ebc4893cec403143f97bc2c77499f32ed2d8426a3257650bd4104e03b61667875f839d5c3eb08edcc834466876f5e00da2218b044441873b074bdbd3ce2273290aa353100a5aceafad0b608aab3ffdfae00452ea2f804426d2a33f0598e856e332f2f494f8905230f55db7e3ebc38dd199779903f9c3d5dda1bfbd620b8e7c84ebd8121ee1f520eb3f4f4dce2893376a758bdeb8132f5012cfd7210acc237bed3ee1e29b93fce11d090a8272620d2a8118e14ba71f55ee5f2bf1638b823b28f82c8fcee620d00de82c7f40801cc1eac2bd9f9ee22099aa0e6bc6233d495bbd5cdbe6af400a64a2832fce9faaef14fa02c4994ecf2d501917cd011776a4d29428e65b8f62280a740900eeb5ee7bb94824b88bc712384468b0ba7e65943b74afd1fd3c1199101c1eeb49c5511d312356f2dc0695330722829eb9ac38fbd596aa622daa11c6d4468c073ebaafd771f3bb4f0ab3949b62e744ef24dbe3731475dcdaf89f2d76cda310ca20c320e51b5d11e63abb9c2906290ea19ceb3d7a28872ba0710925334fb86145f97d5d29172e1aa992cf8ed1d3e7da27a92f615488a1875fd1ec15795837e240bbe312a0b12a39357e157c55237e19e002bcb43424350c89b38b713e804089746dc726bfd43f3eaf1f4efec157756743ee19d25b86c0dbdeaeb4083c54c4ad20491a8ca22ae4fe0f0c9adf220fb1c18f1b4c22ea0cf1844e04c587fcda827ad296a9666b2bb5716fe73b154dc2beda6763ef16ffda2f61afca2cb43716feb1af11f066c537c659d7c5e517a9605f0efb0effd524adcffb9eb5c095c29adbb98a0d9089d9092668e9b1a46363fd3da552197a1155f0c14ba0d2c8328d508ad04f6190a0f86dce93629beb666720f7cc14c213ce37b4238e07d42467562757e01d5ec20f017e67e93038af8a8d75256293aac37caf8e1849b456bfeec93a31d3e5315f4efa5e3129b09982e2ec49aa87da8b1d18dc3fc3805b99c7de8823f916aba2a9085233b13aae3e19e3fe5e832929a14bf0bcf8bbdca234219499c21b1c08ca90070acdd7d873bc03fca3f6e95290dcf469568f03b452482b8eb790ac3cf83ab989c5e1bf81f4d14ae38e1ffb9d34b655a543592affd27b2587dd09bb800a919d1a5f099bc33a4420c9936233590f75588d62fb6bb2fdce95fead732f738eac2044289945ae301968e71c21c6472036a557014b7b591c43bd6ee7b6ec699ed26e01fd396dadb8ff2bc3c39e11b88d751279e8373efbe05bc243d6d5689829a710de6d3b688c108992b342717763cd5593b24226584fc8f502","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
