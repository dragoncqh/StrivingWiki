<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b54833e6ec66ba01d1e37266fe7a1c423e5704e9e7e41f111cec2cb618e7639ec537d13bcca97d62042562d0a4418008f4a2268d6c2ca74eb6df762f607aa03d1f7e0c6a38043cf033a303b1c0042767701094e4c928094f0249e40439cc5a82a285aabab6764ca390460c634965c6468a993acfa0d409ca9f96d823ed43dff2d5ab7eb47156abfa5c0047d2d085dae175dc9e96fde4d2f8a52e4ed6b9125db0d401232f56f5fa4007b83d0e2d571ef1ed3f1042a27a8166fad4c4dff07c039f216ecc7c33a33cf2e41e7d5f3d85f4aefcbc21b0446cd9b9f1b641bb218a5d932ae828e1ebc119b08a6be9ff15b880011851a1271ef1a4e679bd7173bc6f7df227059177705ab19606a53d222db8fa45518dea669eb43b263d24f969366804abfadfc9d830bf747f938baf5f784769895b62e4cdce7c33644710362f4c89947b6cdf105b80479bf650017edb89de43a9e10c35c4a0ccddcb6cc61180f4297102d6ccf2a25bbdd1cdbdf29366e5363993d7ae464663e9668d01a654c8d4f5ab0822db3224018d66f02d390ce42b2c5f079cd00d07bae19a6ce4292c69408a066d6a8a060aa9198bb67fbfe3cc1f532221bebe88d25deb1b8af2de8d0907c1c229e59d4ab737af7dec0dad519db1375d485bca6e689dcc217c51bd53ee928c9c51a2a6e14d7e55cd8f2d9347bf6c4c7396aee534e937d0402458a12d3d67424957b4354754b99b21474e50325b4f3312f089384a1a74a8c49ab0f294c0e9c7d4ac5cc7b2b670cee888baca4efccbeb34bbccfb76f3a7667951e96325ba20a741d471cfe570714f46eb1e397231dd14e74af0ce3bd75bcc2ce6bfae0e9ac2cc30e06954e2dfe45ef9ded8f2970fa20ba2f9797406361b197255873322edd02a5e223ca2e469441ef7f1aa72a1bf9ccf8b3359530d4f1bb768f88be5d07d967a822dc0c83af4d0b0ed22402cfffe01c3e10fc136f7aa4d15b3409cbaa33300be2558b731e1a975d147b5ad87edd36745f5a0fb02cd51227cadb9c5780cc40ab5aa472ace235bb0afa7221c0cf4ee7ca2addeb061b72837245b020d6b71c1156be1821d31508af04572410a9c435aaf1fdc3c919aacc97bd138ab180f952ee96426427dface0993d70f0c119de335e8bb7647e2e30f38888fcde9bdf0920118a476649134606d5eeb1c9c5fcf610a86f2b0a8e8c133b84e0bdc1f5ac20ec2ae1238678eef967dd66afbf7315fd026b03baffc273e5c06775d96e4a16e3fa1d1abe74345a98eab0e10049762fe5981fbc6b93d47ae55b461b640290ed194621105c2ab8003a50c7b9cb0b2b2ebc79fc8e17fd8ac444fac14dd0fa0df94873f241c54dfc37937ed079ff527b9741c9806869f667469508fcf68c827acbd6ba1e42e2f2346a832db59ae6d499037e6b3880ee6efc029ed1944c490bddd115f21b6d4295bd7899bf2a3620f207d552176f48e1386dfb488c345edb18c22bbe92e54bf76bed19ce6f3ff868655b13b1dedac7c1a6779ea6b049d5fa37a131417454621115b3faad84da30ec796430381e1b1ff5754bda73991cd265c963b57039d99534d7a4c8369a81b82e773afe2e5329db205a7a68aad5d84c529ffa325af80d6a74e5104aa191c2a62f06ac3c23205dd4916e6be04ce8fb7e968c8d1635a40ef04ac2cb8d6bc4c773c667f4c901a985fd32f83ca8e190193e1dcee86c524907f0c3ddf57be7b0dd7f3ab22c750b05241296a64770f5e5364cbd5bb96c23febf727766c5d44ba53de5b003ef141514268df59f8e0c6c5091a3dfb12fcc2c5c2c860e6424578305230209386add9b11955543c9fbf76214aac98674da79bfa73c7f830826cf2f05322ad5441864a7cf9639794c17d6696fe280edd655c25c7d92627c9797d5aa597574abe9954589cddbc11b0b4cef7bb926586c480ad480dcb11644ba8de74b7b290701ff3e86c696e7c786c812f5029e31006023f6a37cc9d92ce76783470211209cbab10319ab0d12560cf8912cd718b092dbd38f3e9c7f2090563ea2c83c90dcd68ab0df424a9c8eaa653eb7075f7f42b598e2655a1a87f61f935dffcdb69b7da61febd48bba1c8414cbf38c5a99404f618540c0545d0d215cd67f058356666fc4ff8d318bd4e0430d5508f4c0c7964cd13938385d4221d42d1ac494719c38c47cf014e8a20d34372d129e9b82de2923b3ca0716338408538a027cd61e6b1165b7ebffa9fd14ecc3b72ba2a505b9e965906f0f31dd72e79762af5b45076461c1308117aeef242cb36d9ebf71dbf2d816cb801397b0bc67ebf4deb4a794b4ee0dd08e3da5b5913c8c67f5a8f371361b2fdea0225ffc5fe3c3e954fcd7db03d9e63a4d79d25d2d337d552dc78200c353cb7eefbdcc2612c5e22a12cceda61c118fd2528b43819247cf99253110a709ec6108b625e9d52f6374be7c1a40b5e8790e35b2ffd432056d7f7708f6b3cfbfce625f80d908fb30b7676bb23b9590b2035e5a83cd56a4522ff18fecc433c4be628d7f52c6ec5e5cdb50d5b35edf16c39fcdb588f350bd0a1e86ae3a7a3deaba82bff3f9094ec6ccdc7ee85303c0a846ed0b7bdc4ec78398b01a7bf7efc08ee5ffea97f97a6642fce2f0dec3633e3cf86eaa069dadbec73de129cf3b6c2c470af54fb0542d02daa6480235ef9298ce01d335774716b5a0f9b93f3d210ac8cb0898c92bebd04020f0b0078c425245fd55c09c75c04169658592d405070de2d5d00cb701ee535716f2bdfaa3533d7f17584b8c7560274f6f8e5a4c6fde3edd8bccb7621dd6050320e16ef32427955e4d0c1a5ead3b8e2c78ebe7533789a3744caa1ddef12f8f0fb2ccafebf0e2769c7bcc7e9f4f48f162441b6d03108ebde9ecca83221339cc67f680cbc13ca59071e1a9147708b1bdaa043a8daa9ba1902dc451ba86041db3de5dc4f0630c22b76fcffbd16a37083f862e48f98cfa9d23aa3a8536f3f896bd04208ec60daba596cfc100b4c9b83729e17f1141242d47425fb85134e3efddcb9b9d5a6634e64c3462107b35e8f1aae9d47672c54773ed940e26054cef90fffce8c3eed015076ade14095ed86dd29abfed59ae0ffb04eb19eedc8ea08e043ff242c11fed9a7e411d7c2705ee1e2fa51ee01d87cdfe2dece4a9fb985ae2f8c41355f0e10fee0b89913194e3ee18b1703275bd8cda60c15b574f3b4aaabeda12844f5bef17b96ae9ccb03f358d3f04c4b4b5d70d0c3465622e0dcaa00ae9766a6cb702d8386d96543c622d87f835d3b46ad2bc79b8ad2598c86abec81c6377eb27910077142c99df9602e3cafafb55a0e15cec0f0bdc0f1602ad33b2b57d81a7c4720100a451a6d0834331d48c882e0e3b9a6744eb3cc4bc941eea11f1704ff29c69397b971ebd6d7b14383b3def179723346c895f4dc29918541295a23c5e060e1f59cabf8a384221713ad621731277fe21132c49593a4b9dba91c1f1260be5a845c029dd49b0bd2c5007a0b1cf86be0a025442860fb3062aa5270ccb28a99dd39aaec406aa539f3501a9bbe18d54fe89aa02c229b94e8a90f420e3140c77d3ee61f02517201dcb5f038e11d2271a95f30d04877788a69c21ef6f432e5c38c6fb3bf22bf0b1f6b2000ec3f74028c14200ce057aa62ae4b853eda8e09ee6b1797609b9a7208c68a0128b30778cb359e59448fcfa98032b15c76794abef5d59b4070593ad1c010f5042839566d931c6eccdbcec96ddbd57cb133432ef167e8144b12f9eaf26df52e842be5b6e06473f2402da92610c1cb5d8f278bcb624fce34b29b0734e177504d45d6a464cff30efbe8031356fc3d1195f30f19e816d1577ea96c3575c40f787d2d25bca230b0936ea5f32cfef01f63cb0f2809afb296ae06db2ff80c272120e5630a21038ac808e63a0eb7f172c39674b17da1e4daa28dad9f178cdc9247bd8b0c086d8dc87475d4bedf52f510f45353aef1323cb02609d331b662937bc54d6ceeb691c43237c9bbf5df8f8bb20104b4226408cd1261da2dd02dd93197d5f1dfae0482fbf3beaf3f98c765b5e659741eab487d3f4b2733cbb31b98ce9b35e9fe4f2056a10a2c58f31ae567c7bb198f3ce6377cc43016cd6c960184d63bea1bdb002dc533b5f229a522221f09fab94d0e1be63902576841e904bbc1e915af32de58264752c15cab3d8621e6ab74dbc6c72a3d02de635cf213131790a7003048789b66f99c618a35158ece1e21129b4e5ad0f5f6d5ce5b145be64c2101de3ebdee0a66ebd263b5a13a865839011f62c0a222979b6087e73e9e8cae6048e88d87f095959643f74a44072bdae0e2c2654c604a30006b866a4a80e35ba75bf30c02402831f9cd75545757508719594ab93f9588c15782927439835fd8b56af2ad5a480ccba8d50926a52ae3c3f32fea63017994a0b2b8b6cb6501cbcd17b7790ef4fc3538c180ee3020b85c0ca5c33d20746f95ccd7bd917e5893da38b59e63773a95ff54001c5424bf3dae4ab2c2c8a4ade0ab5da9034d4d547b5ff2b6bc6e83d71cc6b48a9ee8dc2d569d829646c0ec8fc77bd33a7326623d57d3500610bbadd867919c4882e033b6fb49e2be17e0d1207f6a02a1d52383fb0c166dfdb56f936fe7bdbdc70182b11cf5abcc9d8e7c798261ad4dfee51e96308cc24f30829f59c9c5ff1e09ff234bee9cf48e7aed28ed652d85d068998dde36adac7402eb02a173f443be781aabb26cdddb593d3e137e864babc868516e7150771c19268cde0113d8a6e66d53ad755a8b989652dc846fc36718d12f1c7ad74e21839b76d63b5a420a2af59a00fb15c60ee8effa0da77d6cbed53041cfbc552d249bb6d6b745b87e81c8d99190240f168bfb1d384e20d963d849edfd3495c7ca1529477597dc615fdb2b8ad261174f8c6d8d2b803aed6b099a31b4783b01c780a7094cca31a62e1cf894b54e3aca1b8eae63cb89e7f3af409f16aa27ce5fb41f3572deb65d1656dc798737b5575e25716eb022cba02e64e8a7fe34873330c4505e5a6dffee98d55f519d22f3b919a5ce2f6861f666b1ed7dd557b190d083395fa8b8d80bd54ede27ee23490c678266529f75fd2e938cc064d93fc9a4488a0175a319f83f3792390bed7b6317f295b07b0efeb30f4318f5e61225489d7e861855bc0d592fa41dd09981ebf57d57308a4569f2f6b5d264250d45e01820934dd0b78b0975785ec74f8ba4145c198eb0645c54561e71b9b7eec402d7844ef6bcdab495ff030bb2bce20ce462fd934e66247f7cd8fafd69fa8abd239c34a187f41d2b98caaaeb32860f0edbfa5b2711ecc1ce59eef5024c32fd451e13e70282757d8263fe45bd73997d268209d48888b0b8475ef5a3c8c4e230a26151baf37469ba72e86549a969ca268c1c865566f089ef848c4f156f82ce3d09fa4bb0fa6858a95a396fc3262b2a73397edf0f8a9075b0c6a1238dcbe1b9bc6f94bff41d4511cf94476b1281f5fd704713f6e03a26fb33c5ccfd605fcf7004a66154e72bfe39af530df74f6dc0f85866d1a6a5659b9761fc909f6adbd40ed7692e6bff4fc96086f8d9fe790290ec5993e5a2ff34dc0edba2967ac467b952efadb5f071dfe327cf859cd5e0a3bf94785f5f4b960f94db185a22ff28a3000ee319f6f2fcbc837ddb09b6fab5b2120df09b5e44ca21c201bf9cc82d5522fb62daaf6a21cb630cf5c5654338783ceef139b48d7ed53ffc288c893fb2cb5bf9b5121366bf31715ae8174cb0cd782c2ff850bf3ced49574ec6825066fb8112e4b7e6732d768bea644282184aa1f15c9cc160026f0ac43a0167cac7e9313e7b6554db3f5807d55cd53a74c6841334089ed42b423475e91c15339347649105fa5c949f73e0bc144a2da3c72ae4807cdaf97d03fc3b36862befd06eeb4770cad75eb30172a9b1539c1ec8caee7a10bff377778085ef763be49d759d0779023324663fe86d2b5615f9fa0d3163f8cabfd8070ab4e19e2dd00c72fad7008b42952507901edb04483a5c9ff944ab4e1da2aaaf50132a059512159c3d09c26a83163f8379de47f5b633b29043b8cdd3b4512ac395450efbdb7b61adbe7c97fd274b4f01ae576750460525bed62ceb586b725de434cf15b63e1a8e104e7d906c0af90ec9aeab97ad4ee39ef8364c6f272b881c67e9c205c02d811d1e491451409a91e85ad7affa5b6f406af0b291db5653f7abf9c090e63135075f46dda4544d05faf1651fcd1c0857fc71d9964c717e9a43860e1478e65d47dbda634e16996893ab99f540d7ef08e29f7b9a2734396df260bdd65f313e9f745ba9a2b4fd2a44b8f94d2916c59aa546eca22b2e49f5c97566cbacf28a252cca2a09c507f0a0641a596d1742fc24bd04a6ed53bbf9f2b686898028bd867cfa950590975d9e5dc833a2aaa827f8f06f2e2ee2ba8ac8101e2d99c262467c7b3c7fe2a77d8a63e939cbed86f07474bfe99fa39962218d4cc6921fdb787e9fe70c07abf4e93d1f3d6107794f674af44cc0d153c4eb44e2d1685df176d4d7744e040910397bb4c34c9e15e7cadb6b681b87371bde4b10005b4381f45581f3b8a32428e8aa761674fd078a67a9a64b49befb528913c134dc9647a4b7413c4a3542053e42705372936e90a535f6970b65b9041bbde4c3504a50d3750df1e5dfc1d5d2a90f298ade53ea7fa65a559a499b8216bcdf100443c3e5aee54a0f73a1c418b45fdd1b66c929aacb3b7bfad3611b08e1fa1b5b99d82f73ccdeec1bd5ac7519cb9102c51cc4bb7a3aafaa48b1cfac75795b026b932a369663d456d5eff146b597c3025ef2af101016e71695924ad55ca8d409d2c9d025cd9df29bc4005aaca31740bdeade403d7fe2de448feeec3ab87393ff3ef33e3250362f4b267fd0799f5a1dd57048ae8df215fde1126272e9c1ea2fb37b4b7c3e2b0d887838409dc800805c36d37bddb183d290b9b4055e7243b5cd409c0b632d81a4e6c892f24f0b13f5b19d3c71341c5af35701d1c8215bb070c4763d5f1043502f82c6962ab924db946ec2246b0122067a8e648327aa6bf16d28b9198eb287c7e8a8bd7ec1406a52071d7b83f1f9777bc8147a2c31acefcf949789d84f61ed5288cf9226fcc9c43a4f18791d8c28990cef24f90299ee5b9efc48055eff5c3cf04a2846bb698b8cad3519d95a3b6a5c6f4d24685ac86c8c37697ccfa8e742592a740bbffca7386e1eccb70bad0dda5a433b58a5a6adc69754aac9b96805f86be6da7604ae8653eddc5df97708964b5c86f04e43b4860d93199a647435d40ca1130e91881db1f620625784725eb51e4cf487f23a289759557ea343ef7b6037f2413e44aad31c07f7783d4153f5120a3704e7ea335bec868c90f2a8aebbec779951969961bf2fcb59f9c30e504b1300b752a286249b77b3863135e00122137667b36ba51cb1817ff61234cf52a62e12adc2155d5cf1e076331927cae183c8cdb0139dc0e39502f230a1a469c1b720a751431237818375c16c3d4c0bbbe7b664267bcb753c195419629fbc65f6f947dea3b84c0665e914a1b3871fea6a59f93934c8ee3b3ac99f69c1965ae6f07ebc8ce0469a50cecf1d4887e2230f3569d0fb813a9e12d2365851659a01b4b2a4df7d170924ed9af6b5a33f62181e24df3d153fe721516d26f4930bc7a631bb664c3d8b30389a214e1549462caa9d7e22e71a2fc135b62655431643f7c375a27ccd992d6b6d08c5919fda0eb79cc66fd0e3c31ff219ba7ccd039a65be1edf5e55ac26720d7aac7cefd3369df2a39fb87ebbd2dfe47d6ff028ff95f88b4ceda43a111ab52aa646bddb19ac10a6587017a857f8e9e94ac2a41f2cb833577d976daba3f40190ee2a04bc575384b463b064ffb11c70774ddbd89f2418ead4fecdd2c48938f797042b0ef07743c63957d7fd143a1d9edf2cd230fe24fd4653d2298e5cb8341696d38ff0011fa4e44cc92fc9a41cb4543bd4f6991389d93d09c03fdd30fee5d903cc546b07d0a098f82f79f3a229a3fe386afc0b7d7b5684323a399801d6f846f333e1a110b4bc740727a9d333c27348c3edb089d422f7b10352df6f0aa74c56a5bd1651f05e8f0f644cb5476d9486d77929500fef9d5a7bf1ca8c8a900f8608fb41381b495f0e70092c61e6f040ff1134843c18d6dbfd0fdf968d78c226ed97f424825e6188a55d93183ccc2587ab3565edf6d7a4cb0e2e2dad91f7aa9a0331da4c4f2758e3ddab58c0fb8375753a62c9bd3f3723dab47b9e487f5f857d97d0d4a0a923c7b438edbbd11bda53236ab79f41ab2f958affab49ea41f92a7941f38bcf61c97e7a624005e64a8c18084ddbedca6b654c018c31f7b326a8041729b08567e5d857bc9b373cf501f355a38978d93ad72cd305bb6c7f08d1f1a873386bb9cac3e0216099d103a83e8589691ab436646ac23203cc3196cb4ad38528c3f31e42f0c5fed1b05975abe67bdff36fd78e66474408b483714c7019070d29aad070b5ce604a18b223fde42ebbd10bf25780adb15f79193171a43f28c26e334be55da2a85edd1cbf750f2308bee3f54f63959707c89210f011b440601126615f2d00e14d9af9fb2da2b0933687600650cc10b878208afc02f29b4626bf88d08efac4caa6617bbdbf0a4d85f04439577bb4d0c76d6b4b13963cc264fafbaf6172327f61d18f8890e602bb102ff7b132e2290c960d0b8340a86de6e71d934965a84ce8698a3a22dd8f7700df5c1561cbde562387df3794bc57a1c6cd4ade24abc5a3d9b398c77394e5ae73551d049fac61da23f67c733c6778c93b1029c9e0f61a785a0cbef9b9c39a492bf4e007972d7f75ec632ecc33b5d9cf2ecdcf591d215d9f24da07cf2abc5432186d87ce1bbf5c539ce0b2f6637c8ea9cedcfb13ced2ca45c33916db89b3df0815a3c017af2485e01ee13d39b18a8df08fd620807a07de6100baa93acdb7d4a85482570cf084c4b44aaaaf761e99a082f2dc1a39bc2132e38bc03e3cfde5bf8f7e482d152347bb5f8384797a50c01726dec3b9a08472fff33ab23fd081bae01c7982c235551545fe66a3df98c60dbda9ed2707dc86ef81218ecc4f12e40716f780918e949a1bb42b7f44df96e4697ec003fce57ca91a406fb526c7add43b4c9e0dfe13f261598b098fd7cfd12ba9daf080ecbff0dcdcb53f06b8f4ade774f47a45c2d87cf31d851f0ec7fef5e5903140831c7b9b2ce77d94d2b38aa6e0b751b72a1043edefd172363abdb2ad30f6de0d359fd603aa7dba3d2c2949abc975b9c9b1affe97454f53fd3d0d1f42a7e5e93cbea9e5dcecf94ba1d31dd13e49c8c486166dc98831eff40c8c564b2dec66c134664543b582d169bea24a9bc38352a78278a4446f6dbb36b69e0a59a2062556fc1535714aee81c890437c557b513a3f5de667cedd2b87cd6ecd66240a79134f2e6568d0b388b22742f297f4e8b570abd98fa6689fff63d5b3316599b48a788f581beaa0704eee8466f942d5c3edf5f95524f5bb319387aa900cd9c50844caf38f8654cafd6fefcdd635ed87c05f88d04190259d7c82c77b179cd82baed6d81d8bfbbc05f5918aa9be4af60cbda7d7182e4f2b46ac1d8d86dde2d87fd97843518926b02241daa51a163162c7a50720cf6cba66044373435554b6f4f874edfe59b2cf5e642d1017138b82b7f08d76d324fc6543c0e59cfbc71bcecc173ddd4aadfae9163ba1e309c72ba42e775fbe57c061be1136316746fb5c4687f598d38f3ca398239f27d8993505db8233be99b0378ec2f91e9a63e8222d6c82e4cccbe31529efe6ef43e2f0638650f2e490997cf6d507a1630667309610384dbf431489a6ba974604291f4cd13dcf3a0d3affbd6deb2a5ce1380d28e628c0b88807cbfa42f0c9e40fb1ffee20e72fffad33c9f2b43d3af2dc2e42a2e11443557cacdc5b4b9ffecfe8633b9ccd8f36dd08b897108901b59e21f4bbf8e581ed1084e98ca68ab9d3aa69b9d567bd9efc0bf7ad795ec4830014ccfc58c3951be6ebc85cfcc0a9570b6bb8d50a7c30c116bcdf23900a9c164b9cf4e0621c9b109cf10915853bd7b9346f1793bb35756c2139a4fa54ab22d72063a704fbf5f9c2ec297b232b3d6017e882b59a4d560a2bff6196b7cac445af73be0f7cb1f6613675f2fdc87a08e28b8991b08c9bd185772feb556d33cf30d07c1c601c39f89ee250183eaf255e70cc1e8523f9d5ff502f511d52cad361bf087132801df22186d3e1dd7d09c2628d164e426149494cfdc200c6c7f823ffc0880b8ea9ae6a12389729b48a440ffbe1828337fd3827e9bd1abdbbe9acdb6d6430d991805a36c6fa8a86c622bf9c91f1d8aaf1bcd0e79586e2ecef51f57960be48fee42438c02ac08128a0adffba3d6b2165f9476160a3baa17e77c195dbf8c9138b0f7a8b5e0c05a3d339dc6173f1d0a2fd4657f6aab23ca58ffe9c458b7766c2ff09e5de5c536f21c526f390b60a4c2813b18e6e9a8e6d516b9ad90b27681344b7c1e8259b8da749eb1a9b53df3d71d8fb6f386630a8e48df16a9db6e4b3b027537938fca8aaa6eb6cdc9defd5ab190cc80d1a3e85271d66fa46373d3a4af2b41731b53e3c07ace8a18e32d89e32e4e755cc75532aee50cf635081d000a5a66ca5997e139bc679ad4b78cfdd1150b179f1c2721c52a2105d7f5c4273f403449319ded690c67a4b154c489a90e7145116904521be83953eca42f2c8d2e1ba323070f1e91c4b7c8ca43099cde301714d4342f569895bff754b3c5c1399147d18a70b6d91689df15e52ecff1adf6c45f6fb31a59315c26bb9ecd435e0ab5c86559a8ddda29863c45e294fd8e356e1d1fab1ea52dfe0d8f5758f595f3b8f9f68d36b821d7de6cd9bb30d1ca3e83bb33a81afbe23cbfaba159b2f9ff5b7dd6441bd6b252eb12f8584afb4d0053b4172d663646a13c6033d8ddbf7bc321e12e420f3d9611a0e44caacfe7fd0f2339d7c23d3ce4749c5a799c2ec5273025669dafaf0dba611b861aded6141d3e66374757a809b5273c99f49c26dbb694cfaf107c1c70f1fddf3735fe2a25db7baed4834a41955237276697d0124a01c1f85a47fd58e39223b77bec9e6dabff8dd35085fcc3139c9645ae0c6e6536b3a194780a2c78ebd02e434327fa02ac69740c05795c071afa5de4809ebf52d30e44421b10b845c26afdf346dc848d12daaeb83fc2738582d12ad90508c3ffc824d7ef349a959e45ca3a3ffecd6720e6743699785d5dcab3ec98a1d83fec399ada5dbc9dcaa87a093e54e8fa60212baf28e7b9478bc028be9af88fa0bd3a837524365e3a32615317481d02681107bdc38ba8ac71fa28c0876ca2b171d2a28fd38f6ef733998350da4d7a4e52703eeafebd792d8ef96cef1112cf8345732960b2a9f0f91f0141a983e7e61c1ac9923fb4a3033d6d6438e255f651f4cd13e1119524e474913a24beb56e9b6da6069cefaf978c13fe4300efd706762f1c74d0fbfaf0ccfb9108a320354a7c29ff2eafad04e66f7ed3f17f33b77c3548ecfd2dff00a8760f9d5dad7812f6847bfceaa55dcaafaaf1ea5190be13c1f4ddd59e8326fde1bccb631523caed8ded25044310efa8122865901038d1c07cdd9be5b9cc7e191f06cb8bae2a32b53cfd602d464c5190098112d0305ceee9cb7ba0686d72eea7b295edef33cf78944d16b8559d5dd03a0684801e8f9a15eef3e0fcc56c46c820a0e4405f3ce99bce02d6dbd84ae42d5ebe163f4dc539d4c8cfff2b9b1c727ae8b682916153002d3d77d931e766c9c9211a76fa9600419b69e67c9263ea7f256af53493bedd0254ba8b777d5b579a6e417b098deaec5622c687ad7771f8fbee8301d72f051728c128a79c595160e8929bc0a6132c5c258032c5343ac9710ccf31dcfa39cc209125ff315b7916d3ed0134008ce5c2b2418f3f673df987b1e0e3961c99c2755cbc1d7672d0a72971e4510ccd9fef9e396fdd9153ff269bdd2d3f2de739ea5f72f8096e7011f38f6bcbab3641933f0cb0ef4319ae3b8e1eab2553f47fb305ee83ce4db6141463e5e5ede86e6d5a634a75855108068713d0cbe354420cc9c3f803ac050b756442950e1af7b9bbb435e788b4bf28e8f748941b5b7bd24f78bc4514178d755cc32a845d224aeb541c0997bf22701f6d71dd75041db66cd3ea4781706ec4dcc4994ce0752e557a7b3dca11fe2dbbe8f7753cc3806d3ac8ee4faed0c70f95354392d3363aaafb300f740f909b81c1af1df19fe0d0cc2bbb911d9f82a4b580bc4dad46d14c650f97fe13db8a5cc59999f38ef12175e0fd20da398c0d476c52ed2c6fb03c2ac8cb9ea3e046a70d3adabbb900b6b924db413c722d34414fc5d18c5ea19dd29d0f61e275d3991daf736ed0900b49ce3c81c30f15f7e15618e2c725504efef0670e373f2bd13fc829fa3ad19d196877254dcfd9392497aae253bc6a727cc3e81c3b47d746d0c9e9e0e8f73432f88d94d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
