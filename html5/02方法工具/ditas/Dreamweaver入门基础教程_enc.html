<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"138fcd1df7fef7fc1252aceb22bcb2a36abda76c57787d15e1c48ec71049ed70ee0475a2c3a30120fb37e1a37da25a09856e8cc0772344f00a4baf9d1d0e7d906524e6025f297dff361bd534de8c78a11f0d788848dedf0901522aaf9b57ca530cdcd01caaf4044498b84793c943f25f3c74554909c9537f38112419812d78eb4027d51000f541a6563accb93c72f70a29dcc180ae3f71e0cc0d6024f077b28ab67ac78c19a989c64271426caaec3dda9fee9a935f29db679d82bf71fa96f32e7de40fa76200a0a722640ba06515f40509894bd47984d737ae791505f97aa74085639607583fa18c71570cb477210ffdb26df9cc6076e2c22f818072e64c0be433c324e7d40f10c5d53ba10e4ba5e31d40d3e10e3477b743a1ce214ddaa5dd5a696453921184b9639faff1a3d0599f9f3f2f878ea97ea99100ed1b3628c539271f2d5f2f700a9dcf1cf4992d3749dde5f481cbee890c67aff50f8b4023ab506b7d29e02749234fb65d2ce1983753836c858d3a4a0a697470fc7a52f01008739d99649f7f8a993517a1314cc459c1600535ff6e30779b1fdd9ee3f65e67f9827e6be21e8d2dfee21ccaf1ee81abaac860598050a587f67d09e4ae50284ca1174db162fc2a6225565758113087d736ace0029d4defdd63b592b88455df662dad8ad573fd685ecf0da558c8215a755136e289b0d29ebdb38be38f3bbd15d909d60e0dbe864e6854783ded29fc941493944d75021593089b387c6c3521727a0276a96baa6b10b4443d8c6d1a46191014d8b441084efe171ad281c7ff1ea6141e5733e36238572907c7631cd561e238cd2df54971e239421284c64fa83fd77a377c28a31c5a2d535e5d7341d9161b51996499738cff5a8f82ddc878722c7e9f84e8cb04b91b1c82c89d9d5d25f816629b505503e40622285d0e73eee4685da97eb3f0b78ca9ca9a3e950a376164af2848a7f8c6d524a041180975c992089946898cd822cb5d0d3fabceb33b123b284470f266bbbb8bb7b7eb157fa3666ad68686249f1054aa2431404c1938f764066e090970e13d867f98f44c51a2b951a114295e780becb066c4faa0a5bc22eb37c99f1393ebbcd3e07eb2d953b04a3dc4de04913ff38f25e98d976daeb5613a30d438c41329c55b29e22aff5212dad29908e9c2c0589432408d540b61557cf533fe2eae87355ac20ff016ef265f62c63047f09c12514c63c26d413e5831b4aa8eb667c1bbe17b1f8bd10e907422dd3be711783582b376df1ed127fb616561a2873c49e516c573462d6dcf7f3eb91aefb599008ab20977ec8b3011c4ff5426d71a79e57a682a8e4679dc36a974aee4adec0385260c3914b2b15d48737c6a2b348e9acdf09dd7d6386dc38ca8f642235956f8ab077d0468df5790b3b8caaaefa06b7c8297ec218780cc0ddc86ff65bb5288d99dd69fb102fc07418afad8ea30321aa6dea6739765520e2d751cfe14c65989286632b3ee8b5759e0ea706fd601efd1586e5b592a52f218be240369642bd6740aaf275b52f918a9ad29ab0ca75610535e3b401343733bd99af1fec073e7c76b0421a10164f17c2a6eebdc822793754cdf57b9c8876854fc2f1302614d68354f033502d73b2db2d2b42aa02cea2af8a1a199ea5143dbd13d0d71db5539b902e0887d81295a8a17793b8b7bff01e26599a099a0a19c970e53d40a70119541fcc3a533c47e811ff8cef9410fa324065e54fe099bb2518bca921128922160edceb2e474d30c3fce4b5a3cbb91b2d964b27436ea7011b4bb25a9c69bcda2478d59c3cf112206d2cf50c4cb675ddee458a7738de507f2713ff52d8b9dfa4a9c4ca808721612de45def4b970e43dd30181da3689a25f54cf0be96825681bd49e223201cce4cd2ff132123a24a24ab3cab4c53d58ccb51ef4da2ec8481ec257b1a26ffe553b3ce3704ea514e20379204ac5471743a590a894b16387ef0fdc1ebf7d197b8ba0f06410098bdebef1b141e23910638b0ec59ff0e1dca32c78c89007585a7195edd41313f767f74d2270cd04306a64511d50a0b8ff7d7ae1890246cfac55a73ea2e0003930a3cedb04ab7dd5fc291c7a8ed67ae1bcc454e24b8ccf9179de9ed425b191653b98127265b68993f9a2bad692cc74c2ad3d590e80187f26b5069a758e4b600e7ead44aa85937b6de12e8140f372124b2407778d4fd5924cb7a2a1858bfffec4c2dafb267579e5272486e7036775b6b530d541e9e1bbf63607c021aa3fede3fae02cdd192550ebcd437e4fc74a8f2284c55be72e78114213439d491690ff9e46b9e0b7caef3ce1064b37f936ee1a7f3b35427c9f44f6d38afd93c8b30612c836fa4804cf24bf3d8be637c874d733766ab84dec8ffcdc8561ba52f7fa8e49496e180560514aa04db18dc49a1e06a52cf6dc305c0b98040145c0fbe854fd08e8b52727d5e01ee34e82a7f304b5b8efc3b7b25d333739e12cca2d68560ccbd04b7457624bf086d325b72d60046937ae33774b851a481bc04e220daa055319bab9d6bf8623da65a6224a16f9da4594af226c028843679af4851542a524e9439917bd7acc9bb231f92aabca47cc03c7489e66ff58b3d22247ebd9db951a287ef1754e1d81148f25baa6b2c9f361e2b8198c883ff5f15ce51e92db85e93b14d9f14e48db5bafcb12b2e55f9026762a66e2924d6b7c9e38fa2b2a422bbde318ddc7e51f853de9f75914a7b4d2dede365a3e623a9e83e5ffbeacb01c169430077993440ab4b9857fe9135f616d8f5b537f9ab0036973a69fdac6854ca12751557b0956887a08f1bc5b9221aaa4dcf6bf30120d4dad17ecaea32f81c3e227812d00c3d3b04a64a0ca7cffbcc2989469ce6e15b7e114368f8715bfe5b555f4f7b79c6a84bdad567cfac0dd8cd1351c8e9bf321a2cc44212bb1b88fcc15f87c12e313c43294b252894e7805d53b434d90bb288d2cb97d0a434a2da974bac9f9839fee7a4582c3b14bf7d5e158f3e9e61805fd2bc303767c3d697d727a9698dfa7280d6fbb43f217d0711c364f3eca9ecda0fc74d6d1b76a50a35260bfec7c9b8a2d844bde3d853d0f37a410973aae07a837cc9b247018ff8d8617457331d9bfe9572f18be0e2bcd53a1d881b2c9c8e686adb103766e09ffde2303cde0379e4a0d3d6c9e8e568a837bded44ffc5ac373fca55a812271d6657c3baf7bb576b8f98a7d0f1b9d820ef43aa35c028741cf7ab5f36ef5e4ca143a80638df0c2f56a497541cbf2ec0e3274edd33d5f4859a25e30b96d4f22fb1a26917895935b3ceef3fedfb7b8159cd6917c237972a5e24852c3af872ae2ca2451f377c9563e3373b28af6b5627e2156378ca1567d8745712b2c160e1af2b343556a30ea28b23e40e079ec7992c355a7be77945c4f9434a871da7e548ac09fd7b4c9d656fcca74d9aa0a8fd286447e44566bb45a32d77697075765eaa6cc1ccc0348e55e34b8b07c3ebde58a074f1d21ace52e2d0ec8e7349c5651a302d1d073befb3b9c4ab093be6d6145878215228a102ccaec8e4d2a9224902f320f17d10df7873124ef71e14ff954c26d5bbb74aee579383cb831a1284fbcf8393e3d0997fd1814d51857e767f967271880e5d22ec191057d9f194c52094cff662f05c7c61547b417a88b740df6f576ab9ae2c8da792b8f34f0fe9be237fc3f280f330c822445c2a5828d2cbf3256893f6a7a7dddd4bac8d2e798ab090d322604eca3d453e27b37ec00dc7b06169383ad910e3ec2557e60e2b730f44f028b7c2dcbcfbe820d1d155819b849a56aa8427c365c9703529609fa8b78bff9b194f6fb490a3185a7952a045bb1548d163686e2121d48b204343a588e20e43ac99892207fbe43113e5382720162e4db77730c4a5693e74e8b4708bdf383192a1ed683e2200566887b1f47a4498bda55bc8247c67d577feec27922e0e8e44cd2ec4faa37f4b08ed0a447361a2229b062eb6f9d3c9bbfc8eff8e16e80966f64afead82c7373c0581eaeef749186fd743c55dcb8c16291c325ad0bbf509c5fec5633b0e1d7b96a449ab6bb579364ff004542b0be0de16310141274f1754e6a665c8a2fbe0184be5a16ce1517a6371ee316a3d448bf765a9f3b894373330a4f0508661b8209575e24f72dfca5476e21940d2388d5cae28236e03e057cfd36e05198985dec9d6af6204fd2ce69994556d7e7203fc5c0d11f4ddbc6a532b4c06f15ab6cc98ea2ad341c35b7b979ebc5425f4ee3b8bcb00b725a8123117d68bea17231299db705cd8da7d171b8036ef4f6f9d04e660e9bb7c4f514914371931b33ddc865a6f5e0faeda956ea420a7babcb96d5338c29bb6f0aa965f94584d1e97bd213661e2c33570ea6a63ac53ffeac9ae41436dbd70e0cc2cfcd30d666c28090fb82f8fd1c7e1c50230f1f1cea9e4cf81019152c266273ba858315ebfc8f63bb5a0018e468224e5e94e40f4973fd75d024ef5de9825818d309da6b495809aad48f1ad694d489dc2ad78e314f13de415d63e09fd6fdcdc49ca7beb54b74e949c8122e3232b4ec8dffdca8f7679cdb132c61170d4c3e44eb541dadf403cab780895bc5f7637cb1f7daf6257aaad320511c345541a0749001f448285f1d42f0fff0c907943034a5eed59b9b98ff0b3907998e0c60a5ceabeca46965ef7d40f0448a516be69f9b42664545fb5ea009bcbf59f4474bdbb31c47a1a841bb15f824e69988a3f38c568d4b1101c3c0e35eee844644a080ab173c24f8db6fda809181c9fc8dc10974e2f95c84ef942578f692c1720034387e620d422a22d6e4c7a1e76cf11ad6b516d43e0630ff283487226b96c5aacacfb045694a4dd6985afe63ccdceecba5d935b257370a9eaabc90fe80c144095373e11930d9e0187cb60ea559f824680148780655d037329cc1ca8eff28858abc7991e7afbad72e414190c45d9d3b7fa3e82b2f5ddb35c8ac67779b0883d8412536a331e6d0acefc19f33394404fdc3ca74b4c8267a3f0cd40e3730b3e75bda04731836f94d794ff01458785b70e9e99d3eb4200ca06cc4cfbf6536e2b9e9e75c5547a94516d66f6e2196c624cd7c3c7e5ce26af3093127aec787daf5e64dc90ef7130c9481d71ca5ec146106023ee215896985cb3969f1c13613d1c20e938334018c0c4ad68fc942f9d965b00aefe2ad8f0796268aa4db15cde050957d96befa6b7b4f84576e3b1ca8c5fef67b9eec0e777c3ee4f5b402604eca3169bd1daccc5207b4962100037393a5c5d78ad94c22a50d7ad78fe5dc870885e957f8a76bd9591595364f55a43c53b7ff58d256565db3327140ab5690a4ca9e8d87dcc75c4ca0f4afcef321315987ab6f52282bf792d8b6c6ebc34c8eb27e472ac2ee15617a10a05288d3afb60030cf25f8269ef44effba297512430c9770c6eec372c79c700fcafa515e37044c79d6bd78a9fb26848318750eaa28d9a2b4884cdcece92e3ad13d0512e2c3ced29a7c11fa37a6ad2cdec98e8e070c35664d3b47b0a8b19199617ae2720a4e28f5231b10e2287f056f1d041717832fb2c0d6bbde442e69a9f318f065e43f7018d246dbf2425d869d994bfb8b0e9fb605d4224b9a6d3e5edee973dadefb4b975735d623563bd46188b8655d646b0af4d6963babb000936e087469893109d9d9ffabaa7421b04a117ef9094b6a4927664ae653ce2aae46d812a84682faf1da69bdf7dcaee6a6cf165488d96f662c28eb29d4ed652895dd1fb0af0c795cfd375ccc70beb3658acb06dae5f68f39a4bcafb7e756cc8217ceb2631de8f885d7aa1b647f28bfb5cea853926eb17852089b95ecd874896217aa1563d87bc2a393885526e9240a61bcd1236357cb74f5b09efa25a62737a55af39d99fba9bc4cb1097bc66b218e05eb83cb7f437d52bea0a595d2f6776cd47cd5ab20ad35dc30e2fc53b662c27315d10e5198dcf0275a6a71f6f08c20ddbb1cfb626de9e6b619e65333d4a62d7760356bcdce82526b42380ef2a87d1f3bd13747513ae965ba1d9412d18b705ab06c45708cbdd2cc4ae48d3f1b33fa5461fc4f7a205741ed5fa3eb9fdd58a4e26c341b6d080d35acfb98a9f19ae4af5a9cf0d4497e5ff9906199732dc5d60de43aa06bc6e1d59860ccbc5c97ffed7ffb9817c3dd431f8d65e334c341d32c1246c43d9770806c24e512d3bf3850e45ea949d69eabfbeb66c54d84083c9a1187ea7d22b48506c9e641d38fe201307a9b10b270112b5d79ff500a6941578c4c9edafeaced54cf6c8d4f569194fc35445446424f6d9c4274c71ec25e1fa80a9b9fa029b43a9569d8da16373303a4733c6fd356e5c5e6f9ac2a2dfa1e1d1792d13ff8d6bbc6ea7061f545df31651090aeff7b81cc792c34a3e446d764bf3db697138356a2cd0b4208386dd90de9017d5f53efb13d875f81b32074b6d3abc67ef43627de5367eb97f0a42c4053787f2634a23df93cd031a44f9bd504403291302b8b33f587f2cfe926ec00de259051e0d20e9a17f333c588462808ec6df122e6a91739f2da02bf3972c0915a6e9d2aed3a97d73bb683b24e209f9ff21e871df93ba0d39f255522db649d58d15cffc6cf8a62af352c2748f94d3c4e9eeeb6ea5f7c77eecab5173421869acf6e9e2c467a6b90a6de9b5d0032c538b6dc0ca22045da56e42d90ab08031268429cb29067e1ad22c2dac6b10e9671eb71ef64cc60da7db1dc4c38bd40fe52bb21340a6a524c287bfa90dc623890b180a75744fa7e9328fcb254655100a5bddb0e010cb4a6881435522e3df03c537e37ba41fd57add83a23b27b34c9b0c49739ffbd720cfeacf44b98092fdd37ab99e4d69445b0539b08cc084ab82d0f85b517d28ae6431a06ea88d5215cf5142320f87168b7401bc6a54be2fef628219f5c01f3964db63f9a769aadc29e9f2bdc0aaa2b0c398ca552d8313f4b2fab0f450a3486f52964a0bd41be5d128303bf0479703f1f0a9563a263b813ee79c7ab115391e2c2afe6ab6905822c4d8d9c387a1aeac7bc529e3172ee785921dc1054c657d8377ae7ff3beba0c19d624aa0cd747d0820fc18de13b94eabbaa028ad9a02315c51d1103ad79b567a60fae41348635a224efcdc681cac206474451d9757af664d32e23bbab3dc4c3417614b9f385b3e754d8211d7372e8763779283f1a50ff6ed17f6b3b6c788423391c8f5962073247a1d3c7376eada49c3babec2613ed47f22941a47723b4053d85fc74178f48f64e20d115a0209c8906ec5c8bd48d2ad3ffa7ec223af365cc8ebb794df2dc8b029d711e4d21716eaba76f4143049241f592089d315b1de0f0e619a90c56533991eeb61701bc271f308892cd738a345b7816d21eb39eb19c4e32e13e224088b34753775328590f55ca0502cb4ead59c098134a4ce9ee3359cc4bff756e055fde62f95668b6d683a6a558aab2c7760bf3daedc24b312b009b3d450a111a267cad6298b33d2249eff01cbf613e058c18a63946f8bbbe7f3452a7cc6c7f8da3a221ab201dc4292aeb56160ff2d05bc09926703bb741f50d6915afb1056e59f69af5867a746aa9f49dfa6d4a832cbae0ca35de934ac6095166f10313186b3c4cf11c366df019017533e77f74d0b5276d051f624e9db7be9696b19f4c254d698824d43c582e1debd515f6ca00dbb62b688bdb8370f6cad17a6c02a37107c14ecbd6a7fbc0d36a2d2ada978221123487ef3eb79c7843dee8fed971e278b74a5e939278e85b2aca30408665d543980ff2d4180e4c04dfe8b3219697d55284a651ce3e61a5c0a2b77381dc4167e5e5e67eb72d9b79dc93b98997e81f2e6f5e858a79e92faea51465b95b06599822bd6165e16c65d177c33059c06a7d325a46169117d434e1caafed6d91c3ce22a1bf314d6803e1fb2f20c48262cacb7597a27dfc082371f31e5ad43dc07659430cbeea1715cf3597c72f0c70dcaa0e3a6d2c8aa82c0cdb5cb94835732a1aad1826590db2591ce5a1fa3dd8883bb9ebacc2b2d460e8668b008c9a854256c316b60b6b06bc4b269d02f194684eef6cb84385771c8cd0c9207d87ea8f63f532c82957737f777f7aee7a84b3f9b0a9e5a53c0ffe816e9d650a6254be1b1de23f1eca2fc7e3962d0f44fc9a511dd38170ec85d3e482bff486f3dae4f0e234d842b5c235d97bdecf7127bf2eb45c8be8d4585a99ff0f971fe1b9071d48e169f013e7b7b3b6e20df6cb12f913a3ee67bf378ca69b504154dabebeade0f727f85334955aa73ee46de8180322a1340ddeab137ff9aaf9dccb3e1c2119c718bfedd31afe95aa8219dd5ba31e2a6495e518a4684dc58ff975117c3ca3918615cd349225117f139e53f321b5f29128b8dde6d4d2d2be98c7a6b9bc6b20ab0b555ffb706649ba49cba6c5bb141e46a7bdbc2ac1761607ce0318a49b91a42e354a37b5a4b97d96cf19df541af5bac542ea4a31072142f6c71d2848874eb213a48f5b66fa98c8e96bf3e2097f83d309dc7141dc91b091af83a4e36400cb7480be4faa0b0c3dd4fd602348f5ae3cfd109fd00142e6707ac3efc9c936f6dd075d9dd65f631a8f5e3550a09fc4bf144e1b49eb3d9bbd7d82367edbbc3f798a189c6dee7b34ac500a3be99eb4b96bab238f386b94bc88fbc32f9c4b6314036050b981aaec5927a0696460cd310cf3c1a616094f6869dec9d5583e098ac791b541b1b2735c6fd947cb4d221500bed9c98fcb11ea4ca2679df518835b404a272bf0bbee3b92583b26040b4d70cee38c6fdaf4b26f1a286080baabbaa5d5b5d9594dea3c4946859dd61b32b3f5013012762eb9e56d2dbad0b7914b4c999eee746d537c2445e876488310d2f541048fafc01432a5e15c3748e725c0783285f92dccc7d12225428488d79577017099a447f4a499edf0a02196110e7e285336195ed733b868acaa32a8762bf917c42f3391a2a9a6498a6556f74dd4728d60ac760e063d38af60186f126e47e9ac0ac2d41764a7e8eda4725ae6acf8d76f525cbf5b83bc3d66387961ae6a3eff321c37f94b73bb65fcc6af1d87194bb4f4cbaf0a5dcf80644abed67e7ce72d0762ad3dcdbffba7e4739b64495b1645da913c0a44c41c07acac05fdb174f6b085496d78fea7f0d176f672eaef3781a163c6073d1d01ce7add6c8f152308fbc0b333cc0776b9112fd1feef32113e385f072a5ab5739284fe5b50d6213b13727e4578c4044b708e36ed30302af4b3ee087bd4430c32526c2b75f2e7567e3dc4343be3d5735e77ebeb6579a7905534e5a0185b8c7d36d9549eec8bd2fc0677ae39f08bb18831377a816d507a97bdd553e700090b88d13c474703916eedfd0304e3a188612b86fcfc8746a27aa22331f2aa3615b0bd4448ae70e0e9bc2c274ab75f508ff94510113ef6214660dfe7801fcb4eba76a4e4a022f88ebc289ce2b4453806f5c07de6d402d16e17fa4d268568c5a5a86b8eb95c9d6e2780da88b9d2ad9cc342a51778d3be7122d68f6d45a69951cc7e6dc0e58a1880a8482a48e6b41de9f93bee2b9b14bef58d940a330b86b5e0c7cd57a8b753a1e48528d8a9cdeeed07fcb1cd983744fda83d2f8168dc96bc0340d4f96ade2acea8cadc3f6ad4314684b8fa113e8eb18726815837b5687e510f7c47febfcb5156bbe5eff43039268e9b02d721db90941189595f4618ae63d3a8b0c7c95cea9a233513e1e263a1d29361499202e6bd25227a830088fe480cadfb03ea1ff13b57325cd82dd82f494cc6ff87ca773b00b6eb3c4af273f938f68bc96c5d7930ea3122d0cfbf7a046e3cac269aef3bc73d50f6e212060593b987259f264fe355c3bfab1218af0af3777cd8a3a8a132f03ba8e395722f6e8d66fc70ca2e10581916216b67eae7f506c7415d7a271706fb9d0103275d0d6d8acf2e347359f3753dd6057311eed29f6b2466277224ef583b75b5db175c75f2e0cdd75479aa8af01370d38b56c1b3be911c38cc61eb5599dd19c7ffe72f50d4c2ebbe9ba6483ea66fc458a76affecfdacfae6f293a78729ad2209e99f6aa607265a2e4ab44875463120d38da6a5fa87d153494a331ecb0d5c51f232e0de061adcdc0d92208d724a90fa288808c88a8b2c1e50568365fb836bac171a3d76fa621e56b106de75e2f73292d098033e3808fe446127af9611a22eeebc69a77265dc0ee0f5b51c4d8a4d0cad4be415c1f8d96a21c32477c7d18429f4a744065cf2c4658cad37608c236d4eb415877e619174d81e21089dc3b2382e324f158093b40f28910b3a2b506d4f457d9c9589ad53bee3f2bb53c86bfbb051b81e7cabb0bdd30cb7a47ce12d5043f50ac8145b60d9dfb1284600f785a8aee8b011ca21bed6684c0ac8f7dc5f81bfe5df4033a46f1fa93e1e1c140782b24f7d6440ae0cca38eacec15d3f503e66572fe535c85ed2242c5e5f78cec9f6665a094f849e58c309d4f489cde78cafb1903167039e53a8c1b1509fb4a02234b36aa9a10cb9bc185ba6a6a3d8cb4acdd4faf050a0dbc66fc1961247558f3efcea9eea0d12eb03f7b94232397e30eaa74b9c5b31ad5ed4caffca3a726330a028ea2ab6be38dd7c1ff1ac34e5f8da929bbb7ef83a850086ce8cc878bee869ea277bd081ff4c5eb81730c927a9748ae9fb8f0662138007b5763206d93902f4849b15c16341f785510ffe45675b8e99db3789f4b38c93360872d3ee1e92e8eacf0144dd09dce148629654f785c20eb970de43b3222d269f7a713e253d36191feae5b1f9f308505bfb012a14e086dcf30f415df477d00dd23c5ef25c8d7962e6f404d651bc9cf2229e5fca66d2a00e4bf8c8bdd5fef31d327e826d3c123b420750f6b956f302f84091ecd3ebff8de8e9c4396b9ca069894662ed54d9cb500deef37da54d647098bde4694f0996838d21ef5ce822a623b22bc3c47f6ad2ac81de05a1f432437af1e5729485d2ef93cd9d3f737628b7bbcdf49488ad01531912c2c4f4b0c359d615515024f8922b63bd6ef84f2051ea880d4202f7d55b0e6a07d69ebe072b63bafcf435243d196352711a162f98210f5bf57ca6fd2e9144fb821772b9a4333c2deee1647bc1232c0e49cbed772ee27d8bb7872a115724ce760e5c3dc553b8d34be1040ab4464a3043a410573f5ca361cd160a12d09a06fbf16173207f4d12770d79c0e59e7ef16124c1e40ca40588e9a8a7bc1e598b1ed4ed3b0c56eb2f51a6bebd5ee60c2dbd5330bc80089c879cc6a083190444b84192f2631601c511d64ad4e7ce4d7f096d34f90ee8d8bbb0725927290e3fcd18d6274b95c43344c0c6873b60c6535021da8042b992e21ab7b02b7ba78bca91a0588e4bc06f061cf7df73f7b3cf5114af736e62323c40bda4107b032927b242e8c339c313b64c68ddcef9186c8aee6319a069896a613c0705b0ef5f836c48775acd365eec92e54f26dc1f6392f91f3b25ecf821e5c813b65115cfb736a10480d9cd6d5c7ade3bfb92f0f17e3f312c48f2a97aca1becaaa6f226c71812cf32c237c2521eeea0d6b0752522d86c58cae78caf66d7baa3a26ef870ba611a38230c0bdd0cf799265aace4c80225bb449b36a5f0e22f7ec1638cb26307968dc528a34171f2a9639ed9d02a3f3b2ce5e4c828b2ffe7f4f36a4d031abaa083bf91a4579f95d01cb8e082affa17e3b3e16029feac5dbeef6fb06e87831d25926279494ed759ad9970ccf3510f0c92586a616539c46dbf69e46f7a4173faf220dec2ce456a1aed7d9535bf7549ecfad8776808fe4e8d3327a3ce54e8333475f73eba50026ffface43c1966d460e2c71ce4ef9218863dbdc87faa91b64c660df147f844f539846a41ef6f6ddac9fbbf0e948020e408df461465d8e80a5426000131c9e818bf4ee0b550762cb956eb4bb0b7a08d3795216f9ea17a0dc03921971f2fda7bbda795e23906cf0d1b41f9435e16155fa06494ef1b0b381b3280be1b8147837454c9f0f2146e7c16a8fa96f66d437b1e920dd60ad4f7e7186fdf3df93bf0d432535ced5af9f4ea2a1d8a2f91aacc33e42bc8334bdfb177a27f73193e85c8399a2e7aec1046b0a19908a1b3d1e4e886c78ebe3351405cb78b4e9642564bab04bc5c556956259e26c7627cee67e936bfad4f41bf46c92d0477b84f152ac093d1bc4d1289d47207644f383c336ccc1931c443988d6cddca01b2779505d53f6924869186cdce111efcdc82798bda5df0a3528a323434b93b50ae817cde6caa4c3e4c06ba24da421df24bfdacd3bd319291bcd441d338caddc4d047abb6084a3f544e82b786e50b6e5581e12dd878f0d2e55a6f887eb54df55c2be6780901576291b29c50c592723a40159ff32596c193a4140f8536dfbdfa0ed3992ab94ddb1172512476eb9fc8ecc2944b5e0152703503b6c6847e587a2ef582c107703d9781a3ac1a99f7a7d03b6e5311f54b08578a71387cc1f82ec7fe996f985f1f76362f9f39adf6c0a53cb3261bf4cd43766557c72805d899d18692e9785c2bc3576a7af184c6984b8382069a90b28d4ca7e4477f773a942ffac540353f811a1a901ad0d14b7eb339c51c78c12613da1749748ba6b4159599967de560500afa7fe41d96c3a5239fd5585c494c998a9d8318ff344b36a54ef60d85b0d9bdc11351d4155081fc70648a9a47fa3a243c20178b356aa7d87c1ad37c9e8dc1a86b2558b96c33bf1347428f5b246b0a17dcda6cb2275dd106566f17292ca9f90b6477ebb212504791446819c239984562a1819821ded0ddae30d0a97747c755eae72a2c01b8abffa8d71525ea8ddc00656755f5d82e4de5ce59939e37f7e7c88f7049649030ba9ecac287a48dbe62872313447eb7be2b58b392b1e82d58ae8635018d5cfb4401a021c5b4cc34c84114268443c583a4ae8bd8c2e8ce3f837f2548aa57345fb12db05f30f62231d778b028e8edf9d5c339bb36647e915dca21d7ac1c2a8e4392cc4dcb1390b701521103f265310d4d1a918b6906574f67a0946df57d15731d16a0826dbe65a6d9060573d5900cc7ba7b93876e4aac8a9c06cec4a138a3722b0d3dc0ba9d5b920a4671d59b874c42671e9e194d1d3351da413d10183d3888b792bff278c2fede316df0d09759752db2e2ae10acdb83001385bc3dadcb7e57ecb2656211eecbebea7dc5d028265c759bf4f6bab32ea357faa0b644bb447931e3b5356937954cde6eb5c19ca3e0bfcbc31380495f799f127ee3082dec1433ab49d06eb4c57df5f08b4007398b6d610a04d70dd8f9745c34bbeb86d5250cc148ff8211cc202a9e479fdcfb312d708d1db7ff0f231a5dcbf2a4a34dbdf364cf426d32621434809509bea7c7d79bdb6b8c5eb69afa4d234f1ec4a37c415e386c5e63dd1a492404190f40c603e11316f982e02433f26c3c76571d88b6d2bdbfd91003da6655fb888ae6039a2652dc5802a037efd02a934b0e8ad2948a97aa3af7f6db4f2f848e0a80af88503f57a2c5066b6ac26adae0e811286f5499a7ef5119471391a1ca044c388e82fc8f6a40ae6ce9b1b03bdccefd453fe47a0cab4f42e6e1d38d068079e550da04d0e3728fe06cfb01571dcd776de4f82335af6eb49488f382f0b6b6a0a7ff8976132320aa1e56a29fd9f6e4b18e681ff6fd5b7ef08344a8f590e53a8519aa40aaf47cd2e311a4ea359fba96b32c3fd943bbdd52970","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
