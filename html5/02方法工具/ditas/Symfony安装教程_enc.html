<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"07ec196a81b1b88f2b533e4e1ff7c6938c7e3677d5024ff9f5396570db27c7ad4588fd89db4727b7edabc6ca5b8039048e7f7dca865596ae9a6e01368643bf5fe89518a8139009d3c0925a400b2db7761a1b7901856febc1d08d84fee9138aac67b6030fb09fb949f1d6a9a6c148201152f93816f661fb55fecc804a244e96d67ca48da5d229046e63a0dfa17efde3b1c68e56c1d3522248cf972c2277c4683f18134c5486b78026d69cd77bce5b63f585067809a669562e5ffad79cde956fc98ceabe4038ba212f8629438630d0ed5b1eb8bf1fcd658061370f08d29d5f06c61b45571cd90fc71516b57ec0d67dec489f189ea10c9d4a5e978954ec33bd9a4cbf7bdc74639c9f92ad4c2cc020cdbf11abcf476adb15e864711f131846dee5e527dc67891d159614dba6357e733fea324aa7fbea0cbea731929706e4134cd7c53e2217a5ddc28c872f88e0b633abf20a3a51697c27fc1b93acd0827fd2694533bf883dcf51578fadb881a6f4956b303ec735f7baee8b3d9aac3cf19685c6b6de14a922e899ed913e9040ea82f582c066786179055366dcc4fd3bc8525821d6a4432f26a97512627162b80f9276510f9ec808cbfde582e79db5dcd7b5df6e16710eda1ef6f67293832187bdf42a98df82f4129ef217fb6d813cc2e3ab958791a35e24835e42f3b321e7771373433ed5d6c7a829cfdf5cae9e0849ec5b167000247475baf800f34e701b6dc7948aea5649ec9e540221d63b3be15ddb9aa792851a8a5679e0769dea83b5c9cc18383353ad53fbf3d3935cb22d48fb8b865fdfdcdb20bc66246f7dcbda040fd08a1ee25b7fc185fb01de4f5829aa323f4b5e3bd37acfa832ae7ca894a947b4e3acd46e5023efbf8a1d95fda20b194c964b0eee3aebf386cb2c144f825c435906a58d53902909649bf31193eb238f35c995c8e91750f3666abc4d4d59306eac9aa8db3af0ec659ff3b809e4f8d18d6150ef62936b7ab34a9b349438b5b41160647842977f6f2e22a45293b6c68675bf2ef08a00463315470bba9561dffcd496ae8fe1e1aca789e6bbc38418941c425858282f3eb66148ffdc784eedacb486d86dc41065e1bbdc2904792c6c4c77fee4aca5a1e1b6f3bad22289417fe928b6481868cb377c2862a9f89a5c869669c2d0b698e8f021cb9e68ddad4c8f1be9cb0b8a45dc00614ad1da5406a47d73ba40b2463df736a5d3e48d2bd61a2a13543c87a867adb2c6f88d29f0dcb1be4086b0994e4706599f62e9be0d4446b7acf334288a908f9fca365ee76d7a3013eb0543c00ba6cd4ddd39a2a634edb19620a71839771bd71ca7028a10e41742da94eb6e969dde763578b0dee92b527ad89c55309f001ab7cefc26a1a7b6b2f8f336d5bd79fabb3df509e6495705d1d7d3a8cd17569be1a414f733cd5e25dfed66b5ec9eb4e66f606bbea187489eb3e7131feda2756254e740cda5cb25800830c92db1d1bdbb2221185a59e4fd9f9e852ef018c1e5b7c355a7710fdd6fab254ce3eb2f087db52a985979bfb7592c072321c22fd710596031acc59ff78197a2c65c500ed039efb29ca2fda77f52c1e7b413023d122c027cad2e1ffc7a0f3d1be110f030313f7ed84e758c3633ba0e08275b0902216a325f6d70b6221bca5d5c4146a8c125ed852e08c3e939a728e469717f806f08dd7d3585f89df939a857a3336b9c17ad8ec7d833415c9b03be4f5f5e8507f3356669a2a4cb8d356f15c541be1c13d49e6e4f322533660d25c11ffbec7e18dcce62db21cf110607035dead47f790b7c81c159d2d08b95c1d9aaa6974e762aef1fd0308423f7412acdcdf3aa7e695a027e4002f0e73c99c935b1f9b3f636f0adfc98e3c0a8c89a7b95405b4bcca4fe36024376a660779701034685252937252b6925938205c42b4aed29b8621558e1056b3dc6e93f47049f7dad2903080d644a2d6aafa35c9b1b078aabebba6fa2bf546eb268a34bca6d400b35346da955672ca0feab075bdf898e9188f1671d646778af7eb895db57b6686e1493cf36bb5c1ea99abd2c4d247110cd6e9bd11605fc8bf260e5f522e05a9623274996ed993d19c117ca091fab86fade8801963c74e4d26692787f15db72216cc74bd2f0b6bc7631eedf9610674716738d8a7fb4d29d94bcf803a5b82a0ea08c5c1a18b429a7c836658ec871d80d3192d6a5c24c62863a2fd65fba74c838431cf36f77a9da91e7f531f30a1787b81cf518d6a5ddff5e12a60f61af2a79c9c2137e587ade30c8de87a42a30e86b8f8e66e2811ef94dffd2d4c4757bdfe3dba5a68f32fa864816d9e807d244525264e66d86288c949099e47813a05cbb087ac39a3be3d0c1485301abe8eeaa3df0373ebbed0c54a074b19071dd3c588301abaceee7576d11f0ff965a53dba26c8d18c462764c01c40d05cb97eb45f60a507e9160fc752cbd5ecce1470c73deb7813e6b787c3cbe513aba3fda41ec0070454c3d0fd545e841aaf388ba1fb9c898bd3866821d4b70dfea7c64c20be150e226a24fccb9a8adafb0ec1c6ee0c9b6f978630ebf7907d22aa5782963d71e7e0b154f7099ef539786c63764fb984964571b36f1a0207dec813de1fc493994de5fc0b5da2727a358f933d018289ea5d27ffcca8d290d02ce35d4c411df6644e3a353d2b1fbb3d5946b3e53b5ec59b74e0ac4bbfd181637d50b94ef61a3038f86afec1d347ec844e3119c87734879b3e5420232557bd413dcb2445cc991ebc69559e36c7786f4e2d8da1e5f55516b3edebebc457d4f1071e31ca8a7ab929148653b5f5013e46e131fe89c66f1744c2c26eb5033e88784c59e257d6ed3d9ef31ec02c1ed0406906553d187b7b7435f5b607296b11593022f76db412920e6753d8418af3ee2330d26260bf56bc9032e575e4a95b84f9c96b4c5a3ede3eaf1263453d68a53e6fb5d3fe0afd3a1e6f9de0d0aafc62c47c4c713d0f4104630cee8bc455c7295b083a818965108e2a4ea4717e99e6c9a378bd6b3b257ebaacf1e4d63eb926d3d0b34b7cbae0a3e64559c599d2e6cd17405c851d1d1d344778a74378782f99ef2cd9315acbd65b3b64ec229f3aa3cb26d8a295a2353603e49e5614cfcb8dc73ee69ddbdda49542d3ee46de46994b80c8bf45f69eb3e8f04d42d265a48c2fc0d4bd08f9149acf1ebbd57160c2a4671331f5024d89d4346ed82814c4f28af1d3b6f894aea2d1e1a49f0b0a0160794f55a7b128a866083563ec7cdac3e2a81159d36ed24faad81b81eb169ad31c75e3050ae0b4725c58711ac5c02e7419e32701357b2763a1bc622c8568cabbab73b2310bdabab75667c327afe6b9652146cc45cef9472a2e8fabd1223ceebd8637558de435a51dd1bb73c4f157e36fed8de5c995a0f956402df528899546cc76d6f8652b3aaad204eb27c8523b363a1eb72269bb851e514bfa4ca6bb6d64d00438635c0d5dd89bd2f9ed9599c205009c78ce8c3c8fbe60cc0e5c38642c1a26ea4515a712024efa0151558620945c54db8f4564edee68a6cbd9f0321544f9178693e5c558656e3c074066cb641875278945ca4966189981f4b97385c84c4f1bfec512ffb0e936f9d9ea5e990ec1f5b662006fe1de834c0f3972d741a9cafc79c5e9799ad9cfb1224dae6ce5e9962b6c12c8a9382c0239a5191c0d04f48024a0beb01d78950ca6cca3a5b0886999729f5e1b2562c57685b4a28438ebe5795cbd3e26bef7ef481ddddf3b61b9f3fedd94dda32489fc532f562dbd1dbe2d99ed0cf2e2875ad57a0b3adbaf0e3711c7c009853b3ece5fbc3f0277a52ffeb3c02ef37e54b96c960e134208c32e9e43f7953604bbf51322dfd6063be6514d8f67d9bd02bad183cfeb7efcc13b8155bfb3dab965c59ee4f839a007bd351b83dc07600f7d0e98f00dfde452eed1f70ef99b1eff3441d9c6000d24d62e3caa12b2028fac3550c85ab82ff95f71615b7eb76b262b4f6e66e3336a51481c55de5ad0306d6fc02b5ddaaae9b1343ed6b4c115cbdae3499056f1e3e4c84764d35bdf711d5f990be134457a16af9d50e386bef48161f95ddf8f7686e7a5c7072681ae46fd83f87ef8e37205d8f59ac9cdee3437052cf494141a38826e9d85902b546be0c16fd1657d35b1ea906a2fb02d7cbf90a38d15d5fe0b0a77c8c63084e0e145b63e5173ed28daf317492f55043753dd35eebe670ee4626796510b3aea6063217413917db3255f3fc8e0640456dd5506aae586a6e470e9c3c64da293308815501536494ffe24abc59ed76d3a657e9df91589f8094138d577e70592dfdd8d9e0e420bec746940b5b0d05d84f3289099f9d7302f7ebf745c06e0634c34b0db1e3f529793e04de46ee06ec97054e504fcbbb42a406dfc71654e1cd6b2e0214301f765153374aee0347ccbae8138bd119c8df1717c16bc4d253a44e3a3da734de6aeed2ff16232f4f0ad21822566a2d186cc85147dd2b7f0fcc7cd527714a5f12face82e1328619339c7e04f23568205757afba70071329ee62002f43a20a1c151913a1584289a55f2eb8636bc2cbf11189961eb1580132a2c5bb21abe4d2a6305c72f7b329ebd2c366098d1db58cadcf975116ada5e975f120ab41db50bc996fa58c40691a01b653b6dc0f36d938ca5df7ae35a11543285fba8033c64d7012c0840b3e38f00c805782c3f6f38fafe7f3afd40dbe0f0f1ae25157b94b97c4430f0c77b358f9b7a02879f267ee6e13780909024d8e8425cdde56cf0e8d61e9be0d61d0c074633af8aef7a6eeb4e7d2980be3a7e7f966a70fa68b28ac05978e35dcfd5c20b7de311a2d188a883df40887a3af25d94c9d64e3a31e3eb152e21cd86fbe1c0c592df7b65f91cbd7cab18fd8d03be89582a8b7a8417b3a92986eb4f234dc31b93c83fb5393ff8dadaae11afa3d0c1990b3fb18892efff21178c4f82cba6dd8bfcb86aa1325e1efb369ec2c5789e2af8c83dcab6b9a64fe64e3bb06440b7a092b90143befbab488a27a1725acbe680588aba367b7ac0c85c6aa7de2ed7c1c6fbf9e1d70e6bd9e4f7417f6f929d318ac9c97b1740317f9a46fd61cf6e7729d842260b1fbb969c5aa5d50c1887bff07b0da7f521820ddcd3c403779bbf88c62b50bf66d10f78d6655a93ba01f1b81eff4721345b454c5f62debbb44aa709c3eb2e9ee5ce3d9c8582bf31bfb23924a4f6b0ac6a3b49f4c7a4b34008d8d40ce926689b102f905c98b9bf33859c1d569ae57ebd2b828dd85a5dbe4bbf5d024d84f2f879db42c594b52355f3201c4e4d46105700b505170221425e60c5ad360a2685642bbcdbf3fd423ac72a6ea1c956bdc4b4985ec22910d7dd4dd49b7a450caa8a81fd6b7fe23eb61edcfe3128743a4bab1387da38dd904748ac34649fb70bedf3139e861fc0c949e9c986c46dd90afe1c218a3c6ab69489f4bfe9d8fac29cdb1a7fa2e11ae0e466a4e8e575d2522bc1584c5ce62238029e1b40f4101fd7227f14eb4f562a122c7cbc5f94cbca0271597c9f00afafc9c95c5cede788d1663e78dbdeb059cd27352e244deb35efa9a4e25548f2eef3ee7de37e6eaa2c0222f0d043252de9adc716325cffc5840fc8e6668471d63e14d6b51b7278bac9b341ab2b42452ac85e4254a0ab33a61854b5bd2fefdee02830e2c23594031d34dc6b6a965f9cc312f760015554d83050363767d84480ccc07a4da1de13f9c2276d95a06e961b6259ca4c658308a9d3578ee43b41fce79410184872bc9d0446e80490444a0f7e02008388c685b52d345bd4b46b0f293f84796114be550b8f6a161a053c0811334c76e6e5113e41e85d97ee6e0ec23faef7ef47a10e10aa729cef77613fb2a0f9f63eb3231d17d7ecf3a2fcf315474fcdff29248e9e990807909f6ed7a2e5d5d330317a7fdf8428ebe07bbe952dff6744198c0e5f67a57ed5d4e4be3e9167210a2ffbd394addf103cffd2f4fa2c4d0428f599732c44f27bc8678ae0be49e42f0f7e3702b53a1554b0154cc9efa80a13d337558a17d3699b58bd0cd5a376a5ee8de4d25f5f2094e12728239c9453a84c93bb9477d5da5f1b40fd17a1885e5468ad54093a8e34b5cf6b01be94a9dbfb23a44e10284f6b979b94ed1f86368985a02de993a3c575e42756238ca1efbe3aecbb55faf6235bf73c4a23967d129221c9270cb592bcaa08b3954580a1c66c7736266da8bd5a68dae4d9dec344b24cf9384d0d8a662aad2848260ca652d429cfebb6cce192629d2bf4eab72fbc8c03d9d2a031c2db3a172cfab477997179dff7a15def40b15a915f4240d8dde39f84732341cbba80c2caf603df9d27cd59344714f064d44580de7df18149ab19be54da97c35b332f2af6ac8d43389104463c945a022347db768fac2f39b155982973782dd8eb651bccda215c23c2b5d796075829a3bc81e5ae8300b6336a7caa6a4176fc2338710a6d936d36ba918c1d746ffb7eafd2d69870fd6676d9ac9b8c380cac8d62ef543f095f8bdcf3d9f3ab4d3d950f03b4aa9874a1777b425d8bf68bc4dee8fceb519f05e38ab44eaefed89fa7e1fd40f2908bc8a40913baaaa76357a004c4a4e2df63c5bcedb272c235d94a93f2749de894d4353f9bc07f71d94bc30edbb04cb3ed5e6e70b4758aa000f6d5e695f653c925f1e274f9e8f9baf0e559b7a858b4d0b51041ab40956d53118dd07e4bcde4f210f9e00626356c135f25f9b6a86f9a85f9119d8abcf75b3d4db0121b7fa1cae74e51d65e0fb5bce2bf510747172a46d9e9cbd0534035fa6c945124c8d38d90fa3cfe0aa0145017e3649686cd8b8a42807223cf8392ecc3aa5a64e62c3330c97cacafcdc371f37c2b89341efdf02a4537af9a3b47a37211ba660397be7f5a64f6955645c549967f32191152ecb34a7483d6c383d75738fe641c339617cff0b3abc0395aedf3b7545e23d01941ae04365b665e8f1882238b9c23fa7f7358d5e848affd8aeed69bb76eb93e2c8aef4195df2857e089c49454dd31bcdd37a5fa784198875de903770c33117030d4c46748ca898ab6a91dad13230a0578e31e270a32e90ba8ba062f0a02315bbeeb3919c87ce72e608f408d727ace15a245e73ed777569e394105a3358d466edfc4a5b6ccf6fc27928d324d82ae3de7e4fb886c81125b2f575511671983387a7e15c3d320d8e83937358182f73dca0f6e3711c610a902ba248cac217569e8cc33b40de88f214c821d32957df5921b2d67dbac1dedff6eb8ae0cb9fd2396fe0801cc78fec6fe8ff7a82501a2e0731eefb1684bc3f1b1a3fc047731dbf8a21a7807dcade0974803f2737c6cb8e52049edcad58f6fa89a61130e72cfc06b022c0f0049894c34696d599df24d9761ee815ac283d2cdd3f218a4a47d3b43e43e629d85d6f8628abfbf2757082c5d10214c9f51fdaf93cf8f85b1c42ac189d5330a44752ae508d10f67f66296abb92a95b69ddf6c0f8d8755277c4def911da833005b16d04dee77dbc45b0c2e64077736b33178bfe0c3d1ca70e31124be2a125b1309717125c30194d215738d7a71dc73fffda108fec9e47ff7f02ac7c3889cee9ba0d91e0f5e2c04c8e1608a2094e9f65b785d057661366f217422a605915b2f610a67455de86545c20162a2d80f59f3f3e8adc162f9519b11dbc8128404213504dfb5daa9ad132818d5aea13250aba420c6b7fb02a39812253b822eceaf57aaa435d9234f768b944a206b2cfbf66ad215eee49504fee8ddaeaea548efcb42215c2901ca2824bf32bfbe4cda32c78666b8634247bb3e196db4f4e8f0ce18f02b2c19c8fe2ca2a9983c8cf31b4119584a8ba3701ea274b6f15e9c97871399e386b0a03b975e4f8b455450d76205d0801fff3abb67c9206d1c13ed0421c29c54d95be05c9c06f6eefc6b5c6cc4a8c4ed597c0af763b21a34ebcb3ab6b953a9b422e5794ab56c49a36417710624e1e45cf769605b2ddc1c59fedca0fce22c7a6e5c0fde969f834dbcd5ce7cb9d11618b09112879b5327e013f98b033d3a60418a0f2a9737999db9a4613c8ae74901c601098c00ef14c1cf9d35deed988e024f7a8baa00628d2bc7aaff642060e4b706ccf451acb8459cfed47e02be5dfda0ec56a755125a12cac9bab07e0bb30c1833534d7861c342278b98707084a5e910dc99cc94909807641c369500e4d18bf539b6ab5eecf7962a2914d7ed3b7d154cbc73a8cb870cc33cf7551cc828dfa121818dafa4bb985870a14102928e6504a80bb1326a79791e889494d4c1fcc733e34ac49de66a4e284ba69ee3f7e2052420effe9ff4799d655397630b3dc0a46e456a11c25d7a04ebba8bb89ccb45d5296a185a0b620270740a53afb1d08df1ad4460b8cd23e578b737a05f7d1848960e23a9a8a24395c419a0b549677fc658ca6c4f6aab2d35ffc6baa83c8750b9f9a863e91fa4c5df8182e18fa9ec4ce813d167c64d9083629586e239e4e10caf418507b4aa0f7c24b31a2abcb1537f14cace3a948b25b0a8a268c3b496ba65b15d9b16dc64714b0a8c7bbbf9db1ff7e06a64ae323ae15f1efb3c34bffb27a89d40d4d84fca383ff651ef850f92d5066cb03ed733ab9b227d3cff68f8d8649c8f5c59dfe0a3b238d7a7131071c79ae7be20044ed217f2f4df620244b0e4818d7daf20b78f8405a19858058e954071a1f9669b67c199c639cbb9ecf16005dee5a45182a211685da0c3c0922625399b48dfd6da62ea170d6b82124a6e2f4683bde38063a03bb29044576d4fd5d4c2cfc54be40a6b249e46e5df0d275156497a73ac57f98a7eb8009a0d3f7ceab2eaa5224141780c84823ce8279dce528b3dd2bd59306f5fa4368ff23fca22a94c7c8b42089659ee9be095e2b927da52a62d706fbcfa923b4cb2689e31c08f54d538221a60b637997a213d501b569eef29260965ac9bda2fee6655e4c75f0af6daae2836253fa8429915d741a53bc49698abb04f37af465b0cb6702a9c91cc356c7b432e1ebf1cc7b74952bf3a52ace1d45261ba2709bea45976e32e93df159fed384e4033c3076b25350fb356835cb3de88845a714a5212b77f3056c85fc0247ff1543339d84f85112da5f4980acb0b4b794a8ad8a559159e3d97e3ec1d398817c999321ba2e7b53533b3fcb8c0cb6667d16cae755ede0d6c2af1c9dc32e8bfcc63a44b4c0ca126ac12b4b6c7c98db626a247f9990865876290b7b68b0a02662059f6a381cafe5bdc2b7bf95ab212e1f5ff5235e77097bbf41e242d78bc78de9657c29aa0ef704b24d6f332211ce10b6f2df03dac898e86e8dfdb06d2e3e41510355fa716119d0af5fea929ca0bf75f9b7a08001a009e9bbedd87e3605c4b30d4d85f315ab24131937bab4a38c707e408f2bd2be1b9b43a53d0fd91ed75c66d2416e00767d3040eddf26af503265d6f15325aa49defccdaa336a6c50e576ffafd884b4729e349b4e9acec382fee4894f480f34aa91fd90c50d0e04e629e16c6d6b5d0aa90809033cde1f6039732998c3e8cb43d68b2941119a7f6a5ff03ac28b504fde48b9a76b08715ac12160144a6e7c1aa5be2b6f0c7a3ba8d74e0bfc95fe7d1e9ec1d46c46d40dbc3a6ec33a69917d3ddb4b08b966e893238c023b64c6e3751c993944696107740269ee9d97eb8acbe02faf0eb5dc362e6c6e46ff9c7317646ca651a1bdd7b2ba806bf9bd26a9685bda1a90f6d01c565c0c3baa8dcf24450ce1194e4f6cd82e0d40680b651b863bb4f83e96824879af06d94c3ffdb76c84f22b53ea6b0a4ba16982adf62669178aa7172ce26e3d0592a4660f8b4d646bc2115570e55b30b2fc7acf1e765f24168567c8977cf9bb3e30172478c86969643d7350d63a646d4a0608ed77ee7b00c10a2d4401dd50bfd373afe2dc5dc53ce6ce1e1688fdcbc0175f15dd6bb34e8a9fb0f615de96dd2f475009cb7e6666fe84315bf159f5dd7f9b62be1932840e2057aa47281bcb03e66498d0347979a44cea26f221706bb9f26ee67983a607b4f2f4bdc78cd11673ed5c47a56b2ae89fb76a4f4f202ffb1217993188ba753f39a244fe9d8d52b603a9e55acdf89a2f97055ebdc609bba4ad585aab3139a711361eac2e602e9048261c615e8927fcb3abf4e0bff51767fb69008624199a1b662f934f4caeee17827f2497c52a411d4111284c485e0707b9fd086c5c0a1875daeba97510eea2fccd054c41b72ecc19d68700f026b9d72a4424970882c16fcea7e962a1a55f243d464ba6212f57c83c7bca69ad514a78860e604db8fd4d268d04fbef0c5a91f25fc474a2970232fd1281ef0767d984a2c2b8951c6b7ecf35fa1f771224388746042aca7f958d77c227a9983500e00c702ff0a8344ba4a1b0607586e08a11d82a23f0f72b4c7999ecd7f8d68d44393ad497b8dc698e8ec8fd2207caa2ae5c93b92d5bc27700a4b73807a0b7a5a350a1bc5243f704d4da5065c38b8b4a5819a3ee72248d76ab575dec21ad0e52994e71f76d17591b6cbc27d29f147b284e54e88cf7cc28136e93727bbbb0bd042a65248bc43ec775329b34520d28971bda3f67168c926365b0c32d7debe33d7ed86507844e74453253e3acec782674bd67760b91ced1c49ff7663573577d3bc63c25892bfc6e699218ae247667f35f14f61b60c5744f8f46da9a425dabc4d5091c6a27a9f3b5e6fe7fbcd33a34c79f29e5ecd3e78b70621beb3377730c59676d3c4e43e91a308f4c49b2131338bb8a4be5c1935770eaffb7468b852183007e8f17c24ce3ccc3dc986f7ed3d31b490335faec102fb174b2a229e144e1be8396f55543b764d441f06e3f1718c7e46bf11ea10b996891fdbe4ebb35fc32ca72472a5e327e124a0ad56916810fdf81f3f93aeed38d032a0afb5e902e1403f3dc529aee2d58df3c3e441c5b89e239e0ab14b0a9aa49d8b0d38f68d580f8cf4ce6dceb73fe24ba0ce762ea830b8785735c59fcf17e7d665807bb9f61199e21a805b5b8aa39e22caed9d9d94edaf4128bce4d28491226675f2039f74437f28e12b57aa2b574c61cfa2eee462ec9fa9deed37082576d4e9a32271dfaabf1f047305edff503104f519b22e7830868bb908f5b3f69f34e01b9cd8f4dd369b538980216afd60a9a25342ef8a7b984fc3659e666a55eda20b2c175fbb5f0a1f72350e169fc9392bbecb218617d0186954d353d6e8fc3f42d6c7273c23bc2db481b7bc793a54d01d2516820948d85186faab8a5c91abb70890c2b017cfe454adafc905d1e574bb41ef02aab8853ece9fb5fad58fd63e540c3dcb423acd618f1421b902717ec37591b702d22b2d98aae503e93e67c3fcc7236ef5e92ae5db413c3878d41f76422f8bcd3fc839964950d50fd9e10a38e977594eab2858c159a155b2b3f95df1f831d5d78f5983f3f751973541290f4a5fb2e0b629bf0d4aa5b18d0e0dd0432cbdc634ff2b18baae5187d761ce1652da9f477eb2fc981e2b4be4213799d1ba48f0c4ecbc27dd19f75a1357b1053c7fc4784e4c0241b2e90f481ee7dfd8e6948962e475f7a3cbb9fc71bd612768860b47f11d580a40a16468bd0293e9809a18f04a848462f6850710b3680a1ebb673b64893ce7fcb3f3e7333e821566f7fb1ed093b79f8787adec131b6aad6cb65ae9c641b48bf8d5958b18e7ca4bf66ddac1004abcd07ddea0f6352adb94ebdc026b036d4b659652fc6f882d697fc2f17aa3cc169c757da26530092003f6ab7988964e6d54e34e8af49685e232f525dce764b406722ddb0c66e48d7eae3ad98e5f071fe1a9f8d0ad67ee4e4985ab53ff4bcf51e9971182c8ed4d10266db905091314741b9863da6d095bfc2657e0b05fcd3a7c5a414501d6539e37ce4521b677029b4529fac2576c0001db7a6a1a7b94bdefd3a77b4e5474a1ecb23e91d04a1f2ada2d007cad063340a6114eec7cf6f749b4d76fa9a0687f8b6a1f4508161a80ff0887bdd71fdd23921bc212341339281db915de7ab0f2d5125b54d440a72c64e44b318395572d3e6cacab6ce3afed28e9b34f51cd17498ef40bbf07f4088322531aae0ea2d01c0bb87e331d6d9706b79aadfa56384afd42eec3aa4320a2c84471f4119d5fe6d6ab694aade924995196d7e5f137109981a35c92c2a21cb9263988718b54cbb1f1ba158a213cbbe427d6dc223dad58da482a24eda9f08a908a36b872659a33b23c397fe3b1f377448577d0c9af3f2bf8b62fea7afae935e2490dbd14a64f7ebbc6fc6e808ada8d5203563e8020ec81ec2f71d71f24fbd13c1a77c76cae44060e71f5783ed50e97e1b878f79db62daa16753fef1253c968dadf81cd4f2998685626a98a6bfcb62a943cfbb8bacc39425d6b7f36dfdfea5fd7abcf14bbb536be28581bab0b9656ee7f65202f40bc36aeb946a0a2fcf79e784fcc9e203dda6f8839c9557cc014b291a28d1388de0af49680082ef8476128f04c28b668f36fcbf9a2eb5561bfdf3a031879baa743dec96b78534af223f3446ac89873ce0d2ab2176a64d035f8fd90e35e106d8c2e2ccef5a1fd4f92c0b16d023eaebfbb902835ae868e88a4fff2fae7b121a40eca813719624f039d00cd126555fd53e87b0fac98b23ebb501b91056350fd9131257987e8e4e11d542d8e247fa72d2501eb7ab61207d238f618da1776cdc022a4ad980bef2749ce9e3c716e6f775fa041983fb7a34ff196e45e26b06b60f89b8a35b0c8847e6d1068eaad634d979a72873e16208253585499accc3df090176c55a1156493ae15f808f2f926af34522a1ab2cb79915c16e2aa70194ae56e8fd0acf5781e3c8d4be8309e8577d9a965d6882b0817451aaa507eb7605f42bdad0bbf53cafea78a11edd2fcdbb3de0746cde1d40f43240d1eda733d51635ccec609d6540b07c8af6e4e15c2647db958d7b76e2f6fb7f8a23b01bdaa03fa646a82e71ed85ca0ab3a828250b498f73e0c2ab5cd5115a0572c59a05ce50c0b13a67f4940ab7eef66114ec0df3ae852c84d121a753aadc60aabb7914816e2dcd6e87643c42cdd581b0a7ffb1044045f2b6404a5ed571c295adc7a03295d1b323e0ba6d591291fa2b41a0c30da2b399a907fce1d93585335919c14411002c7a492826398bab7aef644d95cae3289024ce6530740fb558e4c103d189d6c676466724b72e66654ce60c701cfada667b00e273427422221409349e67d8d96027cc2df595fefe684360d17584bf8893ea8dc71b898b16a50cdcb59415bf54e85efce3d5fba4051a109da33d89364d98b1871a5a29f5e6fd5e3c98ee9c01ebf6d2baf4a435c9063e3768b6d7705f5e9dbbf58ad9ee36e30a89a8112ac53cd469bca12029614ced861e78274b256ffc7e0234bf98e4c556c800dbf641ec1bce5aa30288fdbdc6b448db279fb78384be4c3c3a0501c57b6afb8c4a8aa3bb2b9550e6d7540c1aa81b6850a444d6a33c1b4b99764e18ae981453038a7345f7e6c90f0839d125cb50ee4a4a803ab77a96c23852329a51cc39fd0e8d095929850cb7709c980d7b12d07865dfa740c986c5e648d7e45ebe27353b0a769fc68c6d2c1419a42c107fe2220c57896314e170b5c16a7118019456928da9bc7d11954cbc6159cc6ccb46f6d70374237313b5752dc071350fb5b458e7083fe35425d3eef6350bce2ac4e1d418f6162445410d7e6752810d4c9d6fbe06484a5b8a56209816681d888950326941826c50f52ef900cca5ef5e52fff8e806327433daeee6401d33abdf12f6fadbc054ace034b93b06630cd7e49854073a5b57544b3fa9b9833030edc586ab8bc6dee569992080a60e2fde85019d178bdb53ebee5a813b037d86e5aeee266835d1baae5ec5e44bc6826e818687ca14d418ef263581b49c2360baa168e234dbf12ab8cc3dc1d755dd11672ed28495324fc411a8c23829d24899a3dc1d1479752de993935e20bc1870f1fa361ee6b7f2f9ec892de37e0454e25eb3153420403bfb887727afed4318db4e13f128c26afbe11c1e966e7e6803635cbb2a7782d344f3222036bc2f9669a148b278debe225cce2a58955cdb099b9db1c796687656000948477de6693d8522a4891bc46f17a4dfc9fe36b514bf6f37bcaaeaea05dfb82227898e89ab769f8d959c82782c560e1c5b43f500c449cc51e9cfaf8c527ee740154b01bec55c99e60ac3f88e3efc4485de5047849dafe9adabb978ba7d04e48b99ea7488a195878aa49ef8dac83609c5a03c6596adb5f6f84888b652bc23b3e63cc741c32a36a502a1df01f80f7175bdadc9015c4e6455dd46643f598889042c511ee713175f449a486dabd96de7d93d4a7dcffb8fb792f55a8b66d0e75f3ab256653f94fc534d6ba451eefa100ffcd161f62b19fcd7ec7cfe8b57ce1378c0f9c91377f03029b28b07de6cc7fd0effe2ac48ad92616d085a25430f9a01a184ad7a4f98ab27fa06f5f724310e37f53e448ebc8e7bb1a6d5292aaa41da4aaca1b798302eb1decb8201733da1e69b298e6083c382bbd0df633fdbc2643e6249db72183659f040dfa5cca3dc264b8d4fd6b9f0e09c879fd719180448849bae897d2587d2b36b7792ed01e4024227d4e107eb3ed02b1ccb08422d42de9588432e7ccfb2f9c3f70c1321705b7ffe471f6c81982c9ba0900ae9309072d367a0620bb08f839db401bda864497bea8906184b14fb20a5337b3ae07ea44c31c8f2290a5ff2e04a89cc2c54ff9ed54d51ffad926fa9cca6d097a0f938fc6dfd328d9b2a4ae873c2e7327c76a4c15ef4563681cba8993230c38a5c0ec970df7487d84b0fe720755486ce76ddfa6d3ee5df5d7d8ae9c2a232f6062b19661b25341b2341df9460a9b19549579dd932322546a2a2aa3cc01ba19ea458ad4d00ec5dbc52a4c26f3a395ea8d12427aaf118d69341735355da6e7e644bb4bdf346674820ceb7a9d67dbb1904707e732dd1ab1685523f79cfe8c0f91e5efd421fd6f7e0d9ba8aa61813bbc22ba1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
