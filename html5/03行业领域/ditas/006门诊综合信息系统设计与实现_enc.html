<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0bf7a71d753a2d4b255be137b56409ed7708b9a1ad69acab8dcd859821e0d102fcd18d03f800428a96782e804a29f446ebfa6c0304fa6df8c8eedafc0e72bc390808ae87708c75ea3753cd13bb8b6562c9a988928d6cfae699e67ecf52aecd078d3531dae17ada135be4f65f7fdb591dcea23937030fb1f7d88b4011b09fb187c47ec33b657a6c0fee5e91b1fe61ed56f3a25d3d89df85f720cfc2c6c5de9a18f0245d7d9a0b09570ed20b59da5fa935791e45ceb49499a990f7200a046de7609f3cb487ff4f1636626b91e3c693dd1912850397295808e263a2d99bb2ab184a9efad0c00d33e11088d63d454daa2095d8dc11ef09d3d9735449f544e704855df775ffd2dd0909e8df71c62544016b5f03b598a39ae03e437cc97012b5e609e78147e305c1fb245948b926244fdf3d433d2f5e70b4eab58925c85ec56804ac50cf4f44491db8884228f74363b44080ed122ae7f1ec892a09f3f7b1eb674989d988920aeefb295295ef6e58c55cd8f1ef1d9f59ac02f79915a60b3a6ea1f663e0588e8cfedabfb7670bb44f6688b0db4a75a57a69b8f75a20b63c0ace6de4b0bcde3ad9a60c58df9334991eb3eb11d436e67567d79024c8dcb798a7e46826d81e8b209d8b757058aa9d440bca47ec1e21edd5f133f5e6b45fc900d9b00b4abaa30536a42ff0286ee5bf34ea2216013fbb258559af15548102d29bfad868103e5f9d7ca8d4612b42fadc8f471375597d5721216bebe69b2aff989e3c716443e8f3f590e600c58d7ef3be6b0f9a2fbd3e9f3f003e591fdf1d5bd9670c378ecb06ed42bfe9691ab632049e21281d32eefddc482d71ab106b680e3e0bddcebbf54ff447e602aa9b24bc164b14327adc6a2aefe9376a9c0494f154307018950feaad5f9fd52a22a3577aa39781632fe14e3162812357f6631f3bbee319ae966693c2efa849d1c3b663e23559b01030662d6411207c92387a16ce4974d1387679665a20809e3a6e3d93d56ad0540da059d96a48226d354f120c7be744934277c3e61530b8ca96e9f752c39917dd20ae3db2e5c63f7539e19e556bd2a30e94acb94fdd92c1708068443b491b2ea684e9ec5b3c0de0479e9b4dfc4a666b49270619cc17b5a16141665a12f6b259b45e467195e64dfd13572b71934d9f4f183e4b50625d5a25e9dfec27565afc842bbabbb81aa490f7b09bc5efb4037dfdac97b1ed72c26ec00897d67739593e49b9d175a498bc7463eac1b7b36a4a6e77330198e5d060488441f2c3e77938e91b780ee03bd673d05283bfad75270c83417485e174d45f3042e6543f8f9c2e806eb08ee2630024f36b2198b3516fd0cad678564933c3c6785073e39ab5f9329faff23f16a2453be1e7c97240d9bbdcd1fbc69e95e637a50ec133e8fedab2995d474bf31e41546bd5ffe7517c098967aa01758bbe98b9ae8b841350b4b5254324a0cc7f5c79f25665a69b788e0e5392c0b60a49a01c35a6104296ef049490eb724679a696a0025c911882967e4e780f901347d59d11e01862b13e28d136cd0f6e0bb00d1c1bf1f8a5a93394ec514e6ae14845de9d51f1a046f888bb8b612800b9d113542db696ead37e45491837fd46044bf2363fba0ff7f81ac6dbaf19bc072675877aac6beea6ebdb15f394afd202fc7b9435c3968ba7f317f84b77b7e1d95609ff5a53897ca16c39e1eb5dcd3461f25f856b592a0fabeb43219ec329b9e7c15efaef07d0592ecded188e4602bb181fe2761f516a713295db5c6d2e7d191b0ca800ab3126d1c37d15980bb53695ea99d54b1015db52dbd940bb9f105f721025e78043322baa28d51038a8afd5c2ca52e18d08cbe75d45e7263de13fd9bf27e640f574421cf9fbba8ec8bba9731616e5e89a4c8df909686d4c329dd60e2699aa8d5b5d3f5922623580d868096ab40878488f8ad1243f7b854cf66df7b22328b598073a1133a97b6cc9b72c3dedc1ede6e4e886cbddd1df0ce100a8908b2c253e13baf3d8ef14ad30962ac7af6a016c9eff72ba753c1a8792060a95cfa11d1710f4fee0391aff31c16c39be033a90f6fc48da086721a76ec82b6809549279326a50636a171442c6dea46a6bf2c13feafc0c77d6f945f06771ff1e22665f18b6f1996f1335d283b1ca350b1c3a1997198f85a2c955e964920a9bec152e08cf6df4128a3d4c667e697d7071bf3eb23eb1c071882220f8e10f0fec4dd0ef4170bf28af9a25a3335cd799b94f3c8fd1d60264795c3097ac068071c415a353a46358610b09831c69af8f52a550d08a6e6fbbeed336c6ca0f27d0bb934018bc202eb47e882a8a25a05fa9f2cdf7c77b55a676b608da4f7390ecb5c7ae8616fd9d0305e91e2be36aaebe4ed58682d9c3c95858c820108d290aaa090b0cf88b8b176dac1f7475f6c16d546c58ea47c7ffab21467d469ea4f92e38dae2626360dd3abfa70f0313d96cc298c6478e4ee77acf22e70544065e01f41890e4531110c49a53e8f2f226ad5cb1d28282cd99f6df80c694529a9a6c4714502c8a74f5ee763747df3afdf3806d74614c003943d931af9a679aad9b02056184540441d57f3eb66a68fe3ba27ef6d0e8601e027448f38103cc9fb4e0ddc9270f41f80fd4e9ca947ca8e394d6ea87bb12db11660072b3cbececb67609afabe8b19823ef6ea3ab4dc04b561f4abe8224db933128366141d465ea23a6c84925a63261c3dd56de28999e8e8c74a3e62f886c0f608ac4ec2b7334fc3a327e3edd30b311b5bf8099e4ac3b3fd75f822888358f8fe74e2b82fff8007d26d2db84d5dac206de33fa0122b75e3069d9268c46f808bee5d673eda19f15ec92b722a29a0f8733902f0895d77cafb6be1b60a1c78105932e374351237a0a4feb39a0c57f84d08fefac7347b2f190cda7a8d3efa3678b5122e3655e648bdadcf0a4738bb6deddc2724e838ecea5ba232746f718b04ce6adc1547db037786ae56ab76673653c135f330fc09ecb5d4464811c539457c1b3b2c9dc8d2d989675287f5849d767df84da48c949c27c83686eee58be4dd6b62afb4eb2af1a341ddcc0348e71773aec980445900325544c52be688e473ef2a540e86454036d9f759c5bbf90432cb3e95da18dec25519d455bf93a21671f320f4ada3f34d2aa5b496170cb0fa225cf465a58383ecf6cc458add35e1b8057afdbd659d5ab9a4190142c30db2b294cb136be9f545020511b163016090c9336972cbe5ad55a2c661f5b0c5227c4cc7a9969902b004b6cffa3f4e51e74105775102a3f4874d4e2dee5f4eacbfd232a65215b1a8dbbc9d278fd60c0af424ab476e5440013248e2c5521de611764e2de059449fedfb06f67dbfb2cf74aa2e9fb24d96c9475ab498bf430b129c7a348d41ae6d983173a405ecb0b08ef5b0eb80b8b6185ef91a1ccf45461be7e7bb8046d159fbabc20ee77469bba1e2438922ad2f75d1aa313cfa92f02847dbad997934a8f719e4963ffb5e25def49003b1bf8234c249ed24c204912d4072d25d45d586e3d22832f44897c0c8d6522a4de923129729d34f2033355232571db61d2152dad56abad2675c5d23cc721f7d135842da7d09b6a0dfc18561d17667d53ae02a628f58b1c48b250219ab78fd32cddab35ee2933f7c21d5d52927db5b2e4530b5e1ba0f2710d541cd07d0198b2ac204ca0246a875b7de96e8b2569913d263353692a313a0b158e2989e5af91ddf1950c3c81207ee6e8af343f79a4b20606ba5c9d71ccff36f7b9ab39d069a9873459aee810c5f530f2ea277c300b527db57e19cfd231696ccbe4c1854bac33c0ab95e96808a74f02547c66527bf1b85b03ef3af44268ceec6bb75bcf2e7cafbef239214b0ab8e08321479cd88e246d106032b021818977e358f82734233204a96e7e5b3c79372769b7152eb8e1ccef57c66fedc5e0f5c88c10494c865b95c682c5810b0eb42c3f3a935313572689b947673f9e2f26b9a4d20389855b8d107acbef98c276041c73f30e06f32f604ba4f4039b4256d0c9d5c85235df6506e40dc528690b31a7e59c04c9cb380bfe1e29843fbd957c30342ea1d9371e6dd598db1c5a67f371320a6b8534d459f5444073367160237b5da6f2717b466129d75548deb01ac63af22ca94c216aec4f1eff25733b04f3259599195b5ea001fdb93d6fc46a3e2d9c906dfe37a60b3dd89e2489e6cf51e642d9b183a8626c907357602715176d29453c4ace54c432c5727b1796628deef90a0a1bb52e7c6d3a5ade5757c8316b83303656afc29d8dff1233b7e40ed168307bfecf41ca6781bf23b6fcd9c94234a63e86c5007ef4f0b52aef20e5ecc71b73250afca4381de1b23976f6723fcab1aa0ce5964e824c5c578ea78460efbfae0205581fe595a4c5622699bc28483d5823984db82139601bfba0b8b8bc66cfd2e07d20a7e62838b90a8612fdee6bf68e34fd03247ef9ec685ad4b85bdcc7cc74b352eff3e0dabb4c5cc92a1866117fdc68a2bdbf0309285b7b65700548be7e9c9cb11c21db6d5f295cd7190e9efa37a9e7cce67fc68ddff6bc3e24652e45d6839e85b4f6c0b10254c8c5b92f70128581ce660a67141cb2ef0503d7ebf70ebf09258a8fff80308034d7859bf72dce4dd9b434ad5fd45b204864800266f8513560d7b5e2f4b62512fe8e0227385062cbce7a8242431d39513b300a08ef6549d479e555c7ccb47b5cfa743b3ef91e65cb369550dfbf6d920c668aa147abbd506d8278eb629eba0566da63863489ce298e13f7879f12580ba963a92a47191bda26107a388ee368428b7776c0827cae5120142ae0d3e21741d88041fd45305723e8d851f5da54b12944a38d1d644159cfaab1269d54469c59e048dd1c8ca7c290ecb342ca09aae8d89d018a12367cb906f5086f0dfba38a081f5919ca9b9a31e343d17fce41af6dbd3a9cd3c93d27d410c2b2c8f1d6b3037b3d3b0bdd5cbd245579abe6c80c14a25b80b628305c043b0568fed2c508895143169fb73dc2449b1858d84d6166aa3eff41fff30e8dee5733601d9f30973c362ba8951d4cc7ed5b2b620d2a8f31893a7ae13f1159e19649f375e6f99d0bbbf3f1ea83080b10c21f0ccc7091ff9f1e53ecf0cc75dbc5b2b82bd7819bc6ce21b3f203215c45f7a5139e696984ce0e387f50a7dd9a3f00c2449648b56f2e46210a19e8ef2baaf220db063d0dca58b2dcb1b54555cac1e22c13adccb2dd4f02b763ad641ca604c5695da292aa7a81ebf8890d0bcc78d2efe59d475e1af2351c474d4ef190089e73a29e260fd46c0b517c3c91103b47a0ef84e85e532c0725f77cb83388d5979245e278138e2f23c56116d559683d4fd8940c919b2b6e978be847ada2cee0ab900503439d10281d92ec200eaa2fd7a90b82d62125b413eeda15e67a21e9ae41d21daf45b91cb268296f836c4f192b22de4b901d066339f4a670087581c35d754d3862fe084252a9146d803c5b132a968442f1801cdc486c127b1a5dd283c52a4b41a5e0507b0b056e6f9ba2e7db41d46dffa720137c96b205d32cf6d7cf702fa7c1842220faffe98331f218a9d97b94491487cd22a1c8660787a8e5a6948458fffe143b54c560328b7b62d22ec267ffe32529c74039982d9c0e6a195b85b0fa85def123eaf8dcfee4e7707e520d464a840034a2585ce7179b58ef58e5cf3dd3a92277fc216610d4f15ab041e542ad139a15ba66461bd8b0eb720dec0424bd52858aef90c2ff4d54f51acb6ed1028b0a46298cd735319341f2f170db3b72f8f811cce10034f0db1cd3466e9a87f6e9a15d5f109996a2e6050e1b4020aeb686810a6a008e4653d964e137d1c251ef40d6a461350c7abc584bc81f6f839d218a1b514e2c05816e55c3f7bb9a3cbda5c99da2b490fb9ffcc8892b025b51606d7225c6631eae4329bfd18ade1d6123d065a47f98ddf2f09dc9393faf7ce5fc840e69a3183724b0afe5684e641abd51f806547c71f28d338ecced7ae355a24ae6a00d2a20c3c71adbb71950b0dbc74a95326dd740a0443083c2310e8ef48aee8faa0cf733134f5a6ed5c2e779bfffdbd0e8996d52a8a56fd984c3e8ae470532e5d9b5b88f30c9977af92c5bdd370e3c4c4792e95d5617e13a5fadacee5b504b7a964d329c54cf5735e3473e1976729aa09eb3c1a960444cca56d2c570cc08a1faf1036279496b66590f1156ea053e90fc81464f737a8039795a5b6d83257235986c37604ee150f2613fde2304255a828f5f1453cf3e3e5d46d620f64ec5b6b93128b0c616b32ad950bcbe600252babd2da518d975d6957e0c97ae6b815fe47075643e111d93cc1455b1e6d0ba50a5b11430be215a88a0d27e1b5c20537a36468fd26160f49af0210863a52eefe05eb2e4af9ccfdd61b32fc6957047c5c3348f8dfa721cabee21c95b2526f03142df379698d89f972dbf74d46062255477fb7294c5a4236c45272b619b80ea584144ac324bd553036110f580df741ab9a4e627b83d85790f318af733fd2559d520dc33a92d7a531e4a332fa375785aee3ebcca8886c01255d4c379b9e590acb6afb4fdbaf377ec08d0805660ceb9905984ea9902baf949810e0870caefbc11c3465de303460e7d9fd5ffe146ada6fae37853939eae4af2ef2f471955abaea03b752326a1542d8f0b9c95e79feb893de4a739e76737268bded044a420f9ff892036f7942f41dc17105dd1bcd58a51eebbcf90621d31fe7cc542db666d8eba085b24306d80e600ee6ff5ae22fcd72a2be4fa95073520eaf9e5842c20c2d12bfa42d2a230ae41180a0fa358f429030ab39a19b936ed8641f398248279f1274d03ee9c987c84cf15dc99f0a06ef865aa53b71f576a9f9e8901380ed76b1110471509c95b2dd068d444317fa1acf65214fd6d741d608394adfc9223dda558bcac5ec28a29ad953df5cfb8456d33a80bf2572b9c1330a861138ba9ef38d7328c15104b47a424a5a0ce3f90cfe472f7b00eca0f9e80a210e7515597f4cbd1da4c6349b4e5de43aa305308e261bc1e4efb30d34524d2a221f0e219cc1bab4fc366c20a1d784967a0b52634363e867a39484e7007e658bb4de0a5b1e7c93b7f13f7678a6a1233470eb5acd958cf999201d3b7c3457780ad468443988d18d1c175519db8df17605c7b8ab1c91750271fdeef3fe591313231bb00703cf4cd87f130ea0ee5f0e787bdc268871d96a6eeaa379c611045e11642c21bf1cfbfb386ef1e9eff8cbb719f9557265e4e1185211d8102f387818443a4748a4d4425430f8893a96db786c58ae8215db09ae823015c6842611e1c4026fe7d3e1511b996364715963267455da1a93d3c8d858b947b0332ad66d11d73f696cfa2418796b660b34760164308780bfff181dd6a3724a8205ff6c8d630fce47625c6026fe45f0339d0b7d91ac5caaf6b27e215af40702b81ac7625606624498a358866067102908b0773d4de4d1ee9087b890bb910b5f772b493324b2640094126cad52758eb866488ea5608448c877d3ae4386448aedf6064a6996eef431dc0f828318b78076aeba1184a4f6ec2518e96a2f1e498c13f921415cd58ef7b3a8f85122790f1fe7140927337a3c12088cadc60ac8c8c470f8e5b972551abcd671fa35e45673f27b74055fbc86d93e0ab49afa73462a180845158d7c168878dd2afab0274ef65c6f32c3853d715593e37d1dec1a01077b3449c3e2299664c4d68e2d7afb357da3db99c7941d2779fa16aadbf7c4814090aa431af17b6d2e7a4bb700082c67cb0ba6fd558e8c3b7b0ed9a499611f776d0809e8f2b56a173b66ecb436ee5c384c50e02f196c9b838d84c3fad404aa316dbe810005fa6fb48d5148da7bc6f9b2174b7f223865d0dc21f068f4d5f43999a0cbfb3ebd39d97c676f48cd8580ffd6189d1950c10092dc3af5e3849b5c2392601edb737d0d72e7c0b6310e6eac2591743f438a233781e32271839d184f5e1373a2c17677aec5ae9ea68f133891c62c1b9fac5bbc07296404c3a211ae62ee42e5f873251c391096edbf4949420d6a9e3af2b231a69303c12ed4279f6457526d1e7592acb560b9738859356c2fa46f5662aa613a127c2937e8b8fea46630ae2d868536ba88ae6c2e5acd19662b3c0cbff77dd90f4f32660da6e9f081752822b7cddf0ba662f6a4109cbd15928e364d71de61ecedc3a6ce6bfcff7e91b6abf07c70c888e19fdb3b654cc408e37477c8994c95606bc46ea32850791977861fd32ed76c9d0ee02c81d0353691b2811ecc663bd698a5dbe331bd96530679b814d71e51678fccfd764fa26269c1690425381d0fa2ea7ac2dafb3fe5d236247e0cd5f262b469884a51271ff16aa59e8191f5b6fe9f254d05033b2c2fd946fb17809e69e99371cf5b4292a15d5e4b82662ceee7eafe56bebefab40256bad3cc8018c4a294c4311dafa93adbdea40bc1475b3d617b07f426e34d78ffae63a409a5cfbd3ada3e56ea7c466a41951244b5e79b1bd9e824009e006f51776284648b474b5a269f572dd587aee2a5e845b2c4e2820564b99813d605ce8fc2de9a789c6cb29d5606c90e9ec7ee093a1e3b7adfe81bb7de019bebba4291bef75e9578c6a23b31e5d19b1e73b46d12d803c1e111d9e0691685a7254d5f57ae874bc9e0d33f90a24","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
