<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8b1dfcb87e46fcf29c7603a79cb92a12d7c91142bfab2dc86d48f73a68628b97a56ea6e77a511fa6be4b369b25588f30e0380cb7c1d5a2cc495e557afa35cfeb5cc938f78cec78d5af744fb80fe0b6e46fe860dc22535c849947e99adf9b76a8fd75b37d13b5f1fbb70cecba8c63c5e582660861cfd4b52caeb93c98500ac07ebe329270e59ba10273052972ba757b8a01f3cc18ce16165ab3428151b1fc5570b42b5c43e7259dcf95bfda1860ad456d5c1743f1755b3ff75a25b64204af6f97269348f279958a2343adce98a12fc9c1063589280667bc06f6f416a8412bf9cd4d0da9fcb8bcc6018ab28984020e91767be3a00ef94c528a70b455ba0176fcc89a26e4b10bc7d3d2ada1a2ee828dba6a65fe01143090c6c119c162534c60cbee696c5d35eb58a101d8ec2ead30ecd409217ffae032a0cec51e3d1a9206c829f774b27f2be6fc4ef67764e0b400aac9eb464c833562c82331769553b2cdd936783cf5ea27837fd9ae1f8e1a3229c55f21a5c256b662fd5bf193c5f89c76fbf10ec8a5cc76529858dae4b2a77a86e16c92a52f96e1bb081a3b2b8970fa5c84478b5baafe025255a8adfb9f75f5e852fcc7cf49fe0ba724264bb7111611058b3575753d582dc486bd769a4271271c954b0966da3b1cabdf4f680b9efc7aba5b50ba952dc7e4b4cecc4b8075fb9d245b3e6003b1892f78db0cd3b6297df3b075ee58c0186a396af58854fadaef6cc464d9b86a99647c3dccf1ed829f526336d45f3f85b21316d36135431d3c9a02252b62a7acf95db0f8bd8d3ff5d58c15eb12a8c2eebd8b66aafc9149b68ea5aa363941797b0d4934911163e54efb3abb504f30c5a963e1c7f8c5e82e6904647d913ec1a38f136d186d7fdaf5661c09a2f3223ba92073c43be6c0759c55186265028e12b4d6ea660b3931c0a0937aac44042e72c0c76650fdc5e54ca1192ea9bc954c90a2c95e15f743c5671b828ccfdaaf7ddc09aad777dce6aff4e06f7d6969cae1e767dea64693dd33ccc69fd766a751b4a8346450ab5cfd4accf8e44b0b5b2806552dff67964a23f1fed7d065701ec9f1a572b12677fa320dd327bfd25ee1b492416b451811f03b7e7044a5be01eb3fc349db217998a8b3ef0c8c3272cd6c5abf89491f2c87f9b2f17d56dac0098bbf6bbd2903b651a6de374d29d0556e5cc8c5a633350567df301b1cf564ce79174bcf2382a6b35b0bf76b22b37c680374b99f17838081a1f4d0f396e1e294f85e197b09218e470ed6fbff8a7fc0648e025e1484330328ddb8e918da97506abbbf3cc5d3fcf21cb319409b8a318ce356265cc775b1ef14f0b494ee0f33ff88b9a887bc83f1722f3fa9cc22e95064159120e09faab64ac0daff1b04b8f902f6b670413d50a82eaff133304059eba062eb3c12df026a089ea626285c46da8b12f047c21d876424fa6e378034935fcd7a2abc389ccd57e8425e2785832521b58db56833e01f6b75fa4a963083cd48c4ebfcedb55593c9c0d28719c250bfcd3084661422b26c08c40d4bd5e3f3d5c3d96f5608bc471f9d40f6076663339d4f550013f95810b95dfb7e4d5a08108029f7ad93ed461d2a455c2cea42fb406bd45bd479549745bdb06baebe43435fd0a061978c450e1849578e3c7f4aeec8e8a445a25f116d8cc99d01a8f6fb92e1b8744aedd2c81e496a2082aeeedb43bf28cb88affde2ea765e8e23be18113e8de1d095aab427620481e71a58b269235d1702726595332192863b119d0723820cc8eaaca8b0bfec3185bf83d00b218849d1920c401225ace937147e665b0be5d4be9d76970948336a123ead4cbaf69589efb503e1c72cea568da0c8991d50e868d84a206d4a9337787f1ed6038e66bacb9f180a1836dd3524b18f90d8783ca2fdf976de4ab90c346567a19f3ec72392ba5ff8e9a85431e8a537738f76a83d0897fea15584a0cf1c8c3527a70d6c3f720574ddd80896e3694daf1045a82c6465c4271205da539cdbc1a7fe5de83a24327acac9ce1973378da8a2066a40008db9ab2bf7b434b2f428956b8fbefa11f1775dd2dc7f4fb4c0f86bc9fc4197c19b5143299aaca950f61ae1cf4838fe148144005bfb35d5b1708c63052c2472cbe142f6900cadc13ea0cc4b123cfeaee50016c6810e79c9cfe48ff8dd1ac0e9ad593d8922675c468b928c2ca1c1da44ac1845a27d0c1bd58cf67c408fded4c759a264d25eced8f74b47e1eabc4649d3735942c20f316bc07400256a142fc42f203c64952ce9b128ba9c46ec7089831d2e8f88b23561db4876cb4dd501eab797aacab0a3607b31a0fa34401b287c2e3f2cba11dd56e8899dd783c1b46e29087b39e0c7db61c2abb5dc2da1f000cc9188b905127f079347d871dcc147853e6e1a2f43b90de9acbeedeae64d0a0d7562110a782b26f07075f68b196aa7079021e0d18e52f616690bec678e515f014b50603df7885f785f3e0607e88e198727a3312a2553d75552d1551593c17eadf64647624e9eec30afa925aeee2aee01d7680eeb259e9b7f7b2c2dd82348a6b9fc66f1ebb142fcc5f9ff2332350da305ce8924dc95a8a56a123b4e53ac3ee49b2ffdc065d2962c3ec2d5589803eff21c45535287e8fb347799bb92549280e6d14500a35e7b2f0ee630c5e68f8ede3da30b22cfd07c53920163a8697c96f258f03c661135ff9462cb08145f0ad6fc21efaf7d6ae21814e67decd901b8f0161117fdb6acedf3d5ae2314196aeb30ac8a009a056617fe0d3706c6a2b69a97e3bfced81817a55c4be3708c10a85d2fa50bd01c9f3d3192d43eec5c0ddf69ddf893f51dc478dc894daf8fc8cdeb9d8ccb8d865d13145ca95075b445fe413be3f6354c0a69fdf43bfffc8feca247a99bf892c58e4ca49efaa908b48a5e51ebf1ab9b1f00b315f48132b47aaa3c21cc11962d587c82598dc70d94668748d4f8b1d79572550570c1cb26bf6f2acdba2cf6b6fc3c4dc011e11ad56c4c9c3677b012e0b8a26724822fe1e61bb8affc5265b3cc510b3e2e270351f5420212a3fa75d9e74ed254286e8513b5e81308ee0a8752689a5f3e622992aab9f364133b6f5c7be5ba7c1b51606727a3b2c93472a65e4b14f947785bbcef7a245a6b05cc0c2064a8c80e83cb1db71d4fceafe3fcd94c41c04d0b33c56b34f90a57e63115d80d853a1341a6d06dd4ce6ed7f14ea5fa6f7ae78b42847da2431ec82cf7ffe2a96a36282c91fe88bf2ad2ed624448aad752ae005e78736b043fc746e7c3a8e82555b0c7d8f084493456910094105f8a095e17396c0a4090b6e1ffc234618a4ffd603cbc0fdf5b25df7284b51e59cc377cc3d3f9e5a70d6a6511ace3bbc6fb5f900bd29c729274da217fa57290615ba37b13612a06aef6e9d35ffc6ac855e8168b245df683f952115b765c0e138902d949d9452831305dfea0d7b2c10982e8deae4cf2eae96ad6d4af51c6f0258ebfd07e49aa7926611455dc8e6c9d0d5e4989d48da6058d1aa4994483e2e5284b51cbb351cdff86447e4bbf6e29304d8ce1bee7537f1da268c105098fc739dc0df42ca3d2fd7c5c077e3fe555fab6e05460721279a1d5606cddf2bf0b67d16fed83599cd8cf2f10b915ca5de2a26fcdbd9da031a7490b125f6e5e034b917213706df06045277303e827502f49d19cd49403935a49050318099be9c0da6bbb7f4d468b158c43739a1cb40feeb6feb28666f4c186700ae767181155c30b3eccc46165a854879671041c5bfa88f5da0f57712855e146a48fc90941b5a6d7168a4a4700df81d7fa740bbecc0646cde2a945d790920fe7137bdf46412799efcaf7b09d31280e7550580f48745245d62b0835c7b7910540b69e4c33aa22162980058700af55c328e0d4a124e01af462dbfba2acc3ed4b720ee099acc8b3f9ec77dd6ab78689b3840dd2061786da8554be82338156b84b53fe1964b70d2636753a3af64916adcfa5aaf6a427a383abf8c337f454a00ba15bac4f86c622afa6a1ac111163d19923511e5d1e2a95ce7aca9ecaaa16d1f5428fafce4e2ddca34720d3abfd7ce80a6990846ad2c3b56a3194bc04a02ef102ceefe78c54d677609e34de30a5dcd68ba326ba1215c43a0a6dba511249908b51202c66eaaf322dcb4730c2b0a9d8bb07a0504833eff3c5815c9ff154a5e45abfb26c465eea05bd3e4d65fa20ee8ff285b2281e19cabd9b91844f7cf6ef4af15ee2a9ba21c8690bad97f923464b90619118e1873a5870dcfd6f887f40cd8dd50043119d9221ceb8d381971535fdc419ed7b8ba8e3ee9a8c6b0f16272ea53c2f4c6f985799686bc9e57f3cf6c3684eaa0a389b9081bc01662860cff17100b6a2911326de8afdec200b4d01dae552348d9f85205381d07bc79d9f7b73de7d2e21a65e749abf7c6cc18414b8409d6f249ac9e5f267be933f3caddfbed2f15978fe529e401c960efb32e079ee01cd8f09cd14392993ce726815ffb7e2d3c8e4d52e70820d8df096bd6866c335a2dcbcda1d8e3848ff54ccf45db06e9d67fe54c7a9690b239827bd7ef324fc75f607fae5b1a01e9b568d55c6b58507e6e6364eee7180c1120906e30dde3fc4c76aa477984b2a690bcc954224c06d1215d39b41d30452934b732bbe10d420e4a3d07b0ccf1bd19e394cb0375e9631afc30309ef9bb03e16b1e6db57efe4c8edf74b40baa8147cfd0e6939b6b9572ee6175c67dac08e0212fc51f680320caf6b753f1e18bdcfb1579cdb0c1ec1e0240f4022637f5102f274b6547eb301086c8000262f7f0480643556d33bff0319eaf2ec20ca9aea7a66e37a102bb28b25a0a781484fa1e7aa246ca33f58c2ab7df4d46d6168b941fd704da49a312b6aac7ab137928e71d519adc678df42516a809e83b2a3e95a66bd64e585dd2cc99f8fe0409d86d9b3833e486a52a5f3e44c07f0350c1250ef9eea869d2d2a8e67fde30ab6590519002fa6626992232a838aba78c654d92a1efa3b42ebdd1ef15bd0d33cf927171b399672ee8207787c4d97fc49d4dbe62e80b23095cfc39dda09f3bce918e1a81428aae28027f56d6a7e57c90bcec6eeacb26ac0397e3e1ca8fde54229a9b427f3378ba1948327f5d4df02465310d96b58c674792493599960c787069495a107b39973b03d7bc80a69a3e198ed75a1289ac1503de35eeeb6f070db3cce180f90e682a6adc83f0a8074f8cbc102746d3171262af49e71974118a610a937c66df5ef2a312bf199f9454f6323c9cb4b8bc7c1495e62d02280e1bc366c01e8b52f22331944a874f5f27e7d05fbd475213389914ade80f781d17f0e8f403f698616ec4699d8f998adb8f6987da4af7e2d1501a6efe20e89247ee8b215d6ef2b3a6de442d37dc52b9612da25c0acd5e588b37088f816ef018382ecf267ebc1a910c5029ebca9228407894e54f4a3d21aa1761b04458b23464e6612e21888a6dcad1ded2072764ac0a6299760f5f7c9682b03202f30a8d4d204cfedd2b767aa05278325824feb26f15df43e05c48a50680660d81570dae8265e770a4fc32085d64a58cf60473e10c0c129012e976dd6df8d878b7c793460594b9a13c6226f02c0f95c4b0802b7b39718869a5267bf5d81b082569b5ab3fa71b861c349ed169e8e8cd45fbd6c87096859171aeb5f149b66de8e7380b6fb4cda7681c572fbe4eaa07ac00d0da54755c0c86163b7911bc4ae0e5cbca65167ec57941435940d526eb30c8682922ad91833cac954f95c2c72664118085d26d213ae34ca27475dcadad455aa16330e85dad468968f34b801f5c0e89884831016ec38e190f2eb118bcf3ab4e5d0f9ae9989c3b58974d157b29597088590259dfa694597485f32622ed28d4f1fad7b5b0979bbb4dfdd380babcab9552b3bb64382a19f2d0fc5276fb7f48041459c9cf95571ef764f8f3eafa90d1a286558f1856a326f18b035730394c35f5ca081df27b66d3975f7e40aed556d147d45e61c14dbbe1b6b39f98cf2a53304c1f28165889fe07fb6bcae93f6e31e68f7acf8773b4f87622d71a5c31fb136ce381b6b0979355ac65d775b7e4d4d198fdd52628f721ee744022470739508aee450b13a9603866d9387c1a1929ceb7e47fa28cb41c8dd43b500cea439eb3e61e61277564c675219a3fff9052e01fcf5a9d381db23adeeec32420e195a0911690a0cc53953290ef7ac6c0d24817f147c982b518e36667b760f1d5efdced3eb211050ecbeaac1ad1bd8daa79f016efebb54a48a3fe3fa8bd9ec47f03705db21f81acd8eb0a5e6aa06af16956164bfc6072a18c197fa36dac3da085d3cf4b4b626b06da1d0cfed497a3f30bd305e7ca1fd95709ee330dc11fce4b18d775237094119eb9721889f69b61d2e98625f0c7ba6d5acaa0f4109adec5644e44b96346f012b0833772e8788bcbc5230f0daba75209f55417aea366cc01f3c4488297d7d283fb03917f3fdf4b98fd927284d00c04a74424c062c0383eadf4c8d03fc4c9e9e40e34f5361ecaa2886f5b6563d334df494ee54624e84ad052940920ae987b11854e0f67f08bd86f6d64bdf600f4049454fe7f833e6fe92623e788f84e4956f7e355da2bd4d5007934d0d49433c895bced4909402ab9770df1e1a6607c2d49c3f119e65dfe8f20184730961da5b45506ab340b62c350fd8edd57761ff5634537aa3941388a3b04cad0f833a68d52b6af5b3af564b489b154debd88f1bd6cc8518a877f3b34976ec1ae4d9a5d840e2c6d6e2e7dd0ac280e7ddbaa86b6ea8c43f96d41514cd203ba3327869ad00576e406bda377e4c1be80b91e17318fbe2516e7d6e87e78bcc80264bb06885e2b074ca36df49eec38f4128e1ba0ef86dd2c4374296a14344e6d106b0b08b93e09db6aed0a20841e7dad7197e378ce6cddc99646e3ae9e11e2d11597d7af80854f3357ff3dfc9b27249304dc4a31f7e814c5d583c01e38dfa726731dbdcc147f7c223fb3595140f80ef8d9d4b31e7930bf7df98bddc6c8a0fadd5818efc89506c20a01f162ae9f62c2286301909857eaed9060922807631da458eb969c33e33e5e6ad07de9525627afe387e506945697ce6eb476a03d2b3c30e2e4ccf763a7c682ffc5a5c0ecc67e1315ba0d526fd53cf75fa0bcf5e14405604e76a615f77d5ca100422cba774db32e1290fa5e124b8cbd8c0694ddd80579e4b719a5135555dc552db919cc5386d1d9fe59357d493db8b05c0d5e9f552766c87502545287585e9745044ff0ca4773bc4f0d37e41e38952938817f953fdc27fbde0ec805711585ef95dd3af841320ec8c86e9582b7bbccb7dc53bdf7beb1099f1fbbc3026ed01c306e0d7c7ef6804b4bbe0147592db13b1cb199dec1f3852743b37b6b7c57198d943f69bf05d3f7b8f1ff79268ceffa6e989829740222ba4caceb8db258e153a2d143b6a52014174dae079d8f7c9208b7c1826ac7f3c12967a51ca26488052454f5c6071c8ce2d05ef2f9b60da9fd6db3f1c59f45f1e1a1fbc5d67f8fb0c7512cfac37db7b7713eece0789fd854270960a46968f0940dcf184751a46e81b771ee29eacbc4ae7d1d6334b6c71e48637e963f430e524602691618b6f535d8e491bec068af8b0fbae4363e494a314393b7e3d93132cba24ff96521e48ec426d17a0b06943cd8f337bd841674eddd7f846adeeef76a0caaa9ead7b94694b5f7c68b388861bb482a4da5a3cc035a304e2a1ca5e5a4c6101c01883aa21aa38e6cb3a1716692e8837e41eb74b95aac26cc54c0b2537435e9bd666aa90347bf6265e4927c078df33b6fe1166c85e0ec1e97b490ae98fc8def31e8d270edc9484b82a8b2d791e0db3009916e3f777a5dc25cfb5e0a8fb17da8b77de3773eef96afa341ba6e7b47eb04773c39e892d2c1c4270c5f734ba262fd69ea939abc791b1b6380db674eb5e57229b19bcbcdb5b3a4da3c07b21cecc176f1bbb5d95bea248fb7adaa24c60ccc467a035fdd1259f447701ac6ff0c53aaee0a38cdaf2b43814bd2e599ca58ee66326ef1c9770a939c4e58c8543f71a44a5fd927cec2c09f4c7747644f05b7a3897fac21ea45367e50821f6106e345958362f5917580dbfaba6f6d4e585fc7e7e725657ad90de4bea0812abbb4c311410d6073aa9cf20b171253113af707fbbedf6ffe65c9d58aaee63d3a6b1976166f78edd6ac1bc83055c10c2fd331b17884e0f3c4d4288aac9a6d61125fed354f1a0cd68ec688d891a66fdfafc90c8ab2b24e8187f39784d0c4574d599f13c53c03d73a6bccda06cf41d5e3e2895169b11fd508083d24ae6bb1334dddd7dabe4670d687312cce8ebed7277b269da28503777a5579967a7cbf04fed458fe76ec62be0435112161be6e29c69acbc0ed62536a6588593c0f01a97021027b18565c7dd9f4346198318f6b80ba30f31d1ab4bf8a661fa65822a9807343b73a0dadbe7d826d71675d5584eb287ef37a76fde97b87e3d3067499ec22268273a6d104bdc187db5aeb6a3f14a8803c3830ca6235d76e169b9eed5641c0b10cefe47eb1aa08d68bfeb2582dc3506bdf3aa45da6ec2e9e6ccceb0b31a41a096f840a4fc1338215963b09bdd84095c62eecf496cfefd057fac61cec7ec484fca5f6bb069f3fed585838921c74f681da717d98048ee43ef11a0fb","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
