<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9863a4713de9a9750e5048a42cd6aabb0754e7d5ebe31fa20f4a0785b6f83a4b249e07858013b3cc839a9ac49fdb22e68103a61cf3d24e6693ef106543cd70785988604c67b942b8230309ffdc89c5c828908c2ebfae29356fdc856c31b5602b7a9d836346f45376afc8c45d19570d75cc26cf87d8398ea3b626df712523e1d4415519685256379abbc5fa1810ade8e74e0494f5b5d0d93caa497300545621c108c26faf65f037ed8c2b8508496afc836f60efa347bb9a277ed1b3bedf495981fb250484723bc9ee7c617437029c42bee3aa7ddf6d03e18f033daa77a645546af35a6edb35eaea66de3aaf37cd0fdfbf70fa1cac599f60c4da374a03f9d5e8b0fa0bb86a40385bf4631c284577899aa154fbc75367fc2bb9a5164d945b68cb92e8459fc3a3461bafac07cce91b58c9c38af166c0c67601d2fcf142ca479129aaa511f69e2b5281b73b093f1a570a51a682994bcce677d9fd5ac07ad9ea42f71674d21ba066372e87ebfea316c6f76231dd891707e389f76a99f44d22c6f9adfd46124e148dbe58117e67172c483cf9c8c8ed856b7f4303b02d5ec5b81bfb38939b33ebc00210ee376351ec424ec98dfe4381a3ee688fd8a506b43101c75087b65c89f04d09c322932280df916a6ff16a55a35cf2eaef0b52f4227817eb5c17bd1a0671f67dad2edb0f12f652b5e991f66d607e4e2e5420befd781a8fe9d0e195064068456f8609f43243ccf1cd6c1743f9a80a2c5f1739532d0fd70a6e807416484bc7efca3ea3c1d750aa6fb1cb44b5afdc73dca6f22c03a7b245c05e9b8745429733600e95054bd4634cabbaf83e3bf1a267c99d110d6933e46c71a3d2dce358308c05e2518517cd05b5266c9a48b0516fd5ba3f4e69d8ac3baa41fdcc9dfd64fc75c865b36ac29ca8653195a18a974182e226d40a57c4436ab014fa92114cb0fd16b4fd93b414610f2888d9d154995d92358882c121c9b3a98c260cc32c96261a8244ce97f36a3151597d9f3291c74297393d402c575c234a5cb25fe17dbe823c186c85f512cf7e195b1c640514495e2bbc720777b68fec8f4c59dca5330fbfbf4828c40f6aa69da1b818efa8cccf42d3a51fc5a93678e01398dbeb8d9c0ab4ed1cf1d2c4487239a74ca85ca63822e037f1bde8f11f79df6ca86b1825ceb00763af23e295db709699ed92e65bcbdee19d113196e69558314afe7f2892868e7d8a41a372674eaef4389547823e6b8d6c46d333a32f9e12acd02513a21d3aaca293f510cd34d333f14ae52c6cb083375be54fd2bdfac3de9cc927071502381aaf33a054342c1c84689cd4bd162cc62d8a6a3c85f05a34997b1711df542b970f359e1dd3a98cd19dca423eb05aee515ba3d497bf3fbae94b560e829a60b5515745976409ebe8f69fc587a21c0ba3c834eda496510728ebb5af7f2f49875c2807f17405bf3f92e66134908f748df498ae675df340c21c0ed0404bcb412a42230599b18f31ff7aee18b8d1f2e3f9dece12f3c28015df3bf6193f9525813996001159583a899e463ce25c52cffe8bfaff65b2e923b1b4c0c06f7724592beadbaf3886dea7daf17ab79b8ace847c2db43a47215813c85a943d8cc9d32d58b5e150ce5965c4aed6a9c5d3b40b4a5992ad4a193a52c2ab683e67f32e4b4659402d77b6681f2cd2e27868d8b76212bdd8a46ce5412d9b8475e70fb757bd5454bc8171afeaa4f546b724eda8141e2fe113c7569b726e86626a2a1cff346c8a1598e5414128195c350b0822d8841b903ac7b66967e9c65aa99d77e220da14c07ccd7f7eda7550831baaf48e6450901de69fe369c295ef547ce6cb1fdbbed4c987cb115ad061637d64232b7e35955c47dee86fd21f960caf48f1b37c13b2763947ae5cce61aa84b9864ad1720d6e4006edf94cb09b31cbbad92e73521dd44f4c77d8336f12fd806bad7c37c187db3772056e0f0a4758f5cab92d055a8c69ec1ca69c84e8c090eca6162ffb41d4655604ab9e20050f0b728c5af9a790c98e8656098409dc0ab733e8db5c1a981509e96e77dea492548df606c0ef56a98fd8e5c855beb301f5b35adbc1246e65720d2b5afc0fd0311897eb29dc0357e32f8144a5c1d65c57e9abbcd3825bd1e68c9734a3d64cc89918c15ae5a1e6aa3f21597f419e822a5ae57d49a58263d9fb4c3dc285138ab3b03eddd471f77022d8ec30755f1311631714de86d0b0182e6f474e8912bb277650a9c7c22730d9ad26ce8ac5e29c0bd43c5b376d75f316c0b6881270ea220b5acbbac2d7bff1f532ece35d1b33fa335b0d4335242bd78b0b39bc5a0f03e7af03ffc6c3f32b02fd456593172435514d26ea6abc0c8692eb546e41ffa9cd943177e10b691eeb17e5ce3f9e926b3edb815bb65b3dbdb2fe354c2cb1c2d5634ee007ede1f0e8e5a6aa1cdb0b1c7f772a0cb3a1e6e6e3f3e4978fcaf677652bd615d6de7935f0d5326fa2c8f623182c50231e2d9bff7b53959bf12bf017a724cf6c2a03da05e0f84c8f8f3df1cc1ac3fc292460a80cd37a0ab4fe3d213e9bbadd9f839879a4b20d1927309176247914cbb5f03657d9d289f8c9f7e7d3d7dad5fc79d3896dddde83f9c3678f521f204045a4c79c62db0000d2599e4a0e7f32ccb567fd6cbe0a701eb1dc0d71aa4769bcb1a134a35032c884429a1493c940ee52e0461e707c600e7a504b0fb04f0cf4995e36c9c9df7be406fde23c023fe702b2c3ba98962d0fdb2f86794b2af378ea0e29028339fa25b15d3a25d1cdd5eed77b3fa8de60c2b9869c1bc579c71c202e0de1fd3e678a76054828c4b450a3490ad14723fed884c5708da35c7c5f0ef334087994acd9429897c9038a2c917fe59afcd9a791b9a17f4c910a5cc1fe7ae95ddd2b20496798995ffce4468886da5a40fd102578c92380bc4377e53d6c58b7c7069ccd13d0932edd8b4861edb9d3fa535cfa11209cbc2923a5e0e07244be8f2c8b22482d9539f8b0f9dfc181d0fc5971deeee65f187bfc16578fa2480864eafaea2472606de00e1c78ac27a34f60a45eb417824b4a8f4c486a57904ffe235029bb9e3d2ef3ab77af10fc6740d848f12fb4f82fe56a9be6a756c3cfb124ad1cba6c5cbe470e4434f136ef8b995f8d0abc12837db9f5568fbaa1d1577c2f19e2a02713aa7bf38e8806dbbf6885eba435d1bef080081371ff7dc661e32d53fcd8e3ffa6bb02f4e26424e523fbde90e95f19003142b26908572d4a506b25749e1767d321469ccca413314bfa3d8dba7d9d35d328f6b80a9ed064ba2c327d062f6fe2beed2195131531aa9c177c8e4407b0b684794b564e256542e273b45496a081ad2a47e375efe4b1dee195736c6988e15c2365d70172d82fe9b0efc986dde0013c351c97c186124d6592729b8127ae21cfda2a23fd9a6057fb44d73abce5352638e2dc30556599871a45866e9ff6dc9bfe41de3cad0ff689ff86c08afbd78949b4ef1cba648c42ea52c4fced86b8e4ba44409e673d88251d05ccdb2e42b623fd15c776701bddce5a591e4b5b767499f5d6115d6652ae41f8269fc9fdc25ef98a3e835ce165e208b11eb7ebade7327f1f0d3221497f508a19572e60c287dbd83adae7b4082bc41ee98c67bd38185fe4dce8bb6c9c59e5c697d8a6e48812fe58c7dc773c78e2cd3035ae39b1e9fb9262ab602a8b94777a952106c6fab233022344a0e2770c6a44ea63e3c6e4f3ec822a93d14e249425850de4c2ab593604daeefd8de4ac7e04310d31a418d4989b37d80945d2d14135e4286b12c53d6d22a57321de1593778184963ecc19ae4eae8781efb4fde84569d6af6ceb758c546fad8a85e8b65820c5bf657f673606ebb11262ffcbc2f1c4de452d9ac97622ddf783e2763eda8a825b60e107452ab70aa5a803c5abf645fef25730000635b05d5eac61869d4f290c9086667c2900b611d6454cfc5b5d1dc1077ca9b4f77ba544ef8399979e126d58e93275cede9e981f7c7f30706d45471b2b769db1f58f86e0994592df621efb7aa4e38d8d924572187e569cff320ceb3b361858b3f0059080da5a847fad2b329a7ef0436cb7f21d53a23c54db883488905fc9db6828c7692c0d8c4c6fb0d110bfc328ff151965e8341669622c94740845b7c8745b6258ef11a0401ee0d3860958dfd65b2e8acbbe98504ebcd06f712fb0f458854250cab59f9c0952bd76002d31ab59c21f3847bac6c81bae5bf89af9cf88625dff0aed64c27e010501f31827d40f151ae4afd23665d41a9f4a88cdcf38b5a9f14959e5bdb699df29cb3554b7f95bdeb581f86cf6f063e2a4416baa1316af7e8f271e26ed35a6b22bd71f9475414593ae7ee06c8de6842e399ad5727b7353ba4d097d05f156b72ae59e0f1f805b54559fc791941c77a1c340583a684a34bdc24f7376cabf3d36e46b4564f6c7e0d63bc095cfcb998a2d30c82cfa690c318b8500ae8e0b1910da392f23d913d0c15ad80821a2e736d9620d0dd92a3f915d45fe8cac97dac27469283a9d7231f0a5fbc5d86d713fc5400ea20e4da77d245c268f08ba2e3103aa8001bf137bae5a834be05b88fa777e03b39d3540ac13d6bb5ad0532ea04f690e3b5ea8f4e7e0b4575ff6cad566c3a32a208f458d64813e8a5a33da99b975179247ae786b3aea1f9da5008b776d115bc105e63c62509692e8d71a4b9e774ed7518e53de1d7d54f7fdce2d4e69f9c7c93387d3ff23c95e1806a3ddc39a5685df3ed1db817ba5f18a5535de5a520984a015dc6a0f44baf72b1a81d38b594b11704881fdca96f10143fa9761d2cd111592d5ffb6d2376a80a1f8d7ca34f7ec803a4bc6dbaa97f37b65f53788a8c4a543ce6de52a78dffcd4abe241f39197d735986365a3e412a02b79288a0162c8a6238ad7dbe581ab9bc65ea82f7039c46231a074cfe93740efca2c7e51026b05f061e22af4813382306a5715f41c44cb2e2a81a82e7a1ff94d61433920d6c435b47269d3deca167f1f0a9ec694e0f85955f1f3469f8f783dbc596eade0d0d187622a42586fbebe9542a0ad9a81b09ab663969b7aa6ea4e80b66a519ae4483b0f880bbd235c9d56dbd71b6b10b20288ef6e75fe12b19e3b5ee11086471893669dfe4bf9756668ff5bd2d66e2cc4bf523b019ed108555e5f911c126e286676657049ac3f381451ba18c61e66b89c973c56ae3f1bd9004ee798b32b78636fe20d61ce4476874b24351f94f0a9e44f8a4f59904a603e6c0c20415c9939f520e6d3cb06ed00287c3570c712687067b95d6892480558c2ae51ad76c86b416b119bef1d634770edeaaf73e735ff28c9e68dbe161fa6665b6e4f824d6de8ce1befcf26d61998596bcb77252a8217a2182e04dddbce52d0b905a2bdc20fcb1ba4adf055a19c027bd16cff18d83bc0502b58630d5194650af090347a332725de6058842167e6f6ae4f02b03f41159ee198a37ce98b78d01827de87ee52bff60c40289fbc59d7a69617c27bdeb9e9414357e4bc515473a513f851457aff73c35517c3b36f55271ff359753d345ee311fc2574891f1fb038334b64d21f4d6714a98bac7bb95e9ab5e7d5003a14a960e47b3971c495c6f1528e31b14071f7489af582e45ae337ccfab58f99fe61656e7e5cc7fdc63284eef72ac0965ef458f85719e93fd223d27f73b74838561be0256730ebbd507f8188eade222df21cb4098b9871b9b474af412a6c6628aeb806fa7758efc93e5fa9d54cd964fb53f18768e4adcac5345db8fd01940e5b6a1db71ce0bf35c536fef146dba44b45df5c320aa7298da4212927fe20d84c660f6f31488e2e939ebb5ab2262d0ce94b592a313f92256888eee24a81e5d88572ca917ddbb1ee059a4dca9d6455302d499f8fe645df3fe96020c22cf43b37da27f31712204a30bbfecf5d6aa1fa6c3ea5b95f43452492e2ca576bc17d828b18faab4f2d98f5635d08fadeb4fe9fefff2f9b28ccbde3680cb10cda1323a291411f51b4f94b8cfd73ed55f0400002ea936e69ee6d24bce06ddd421c9c1af809dbb99226318d9ae931224dc3ece7dc692d5e46b42ad53a3df4e3d2e8e68683c95d4195a62f90b8518e8d228273fbc8d9be8b32a29eb0d37f104b9bfd4ad069184f865ff5660be37059c56ddcab82d5a3f9f9d9705a148bdf4d5044efce7477b65f51e2a487c7ffc3709c96d152ddb28dbbf1b928f5948ccc0591895cc26617ca3599a33a19698daffec924db4c9dc0f10327c7bd657f7c71f47453c3039431109a8d4651fa208fa99c4471080b3ba9784304096f4aa146f70673a006daa77e1da864a0da596ff20b0fa4bc538349a949db8a79f586f68843ae868b0e57b89efcde65b6b25c630ddb29f1cbc3a80cb80eb2955ca036c33e2db28d2d3d39d0880c7d7c956a67669315789e5932e2f10d892f90e3c7dab8071a873e01328f53dc1a2af06a840d11d51b9a244c6b7866f8b6ee1bdb9bd96fa0c00a809c016e1dac016e0fe8bc3fd33f9c75f23070a20d622332ac2614407367f858032ae93f7ca5da74c6991bda00e18e24913eb40b9a624fedf6a3ac34041802aee8bbfe3d4bb0811e2aa4125cf7f7181feaad0e4fa35ee6ce21a95ef4d958cf32e1a8594872b36b189735bf4e906aeaf25cebd27c52426ce68c2e64dbd5de0cbf0b1c0507c8ec11c4c0892e2b4ded92c3be5eb2246532b3d014ebf12f25a7c873e4362c22048cfbb3334348cb5dcd35d92aa2ee30d990d1daf9d20e97acc6584714149f71e892196616f7dc45bfb3092a285df36f88eb730648805329967704198c69a06cc027ca11f3576302b1bc7c9cdaa237f247d112ba2241755282ad46321adb38d14f1f929593f806bded17527e851478e9bce1389e7bf84ce248adb8e8db49447a1c19a36e822dd999b1ea67c116b1a2601c6323407c549ee937f031202d6002bd012e64fde29ac3d2428961fdcac21bc2af24bede9f9dcdc3bc1c069d646eb759ff49977dda4c412b52cbe2441f6ceeef30772b6e06e8e117df81a5790e64242dea526f96b38dd8e88662ee092076f731e6cc8961557fa56e3828fef4c03596bea46e0538d26ffb6828b5274e36eb3fd3e47d1df0716100799a1f9c4d65cd98930e198a438b6d8066568c8fc572fc72a64138a93084afc927bda6668fad2cbb1e733e252d493d624fd3a39f0941c614c57be066d54e8d5d13b91dcc0130d19522f339b59e8578a3f7db33e73dd7ae2335810ba4ef80dc01b79e35897c01df7a5a755c581666fb203e859d341073993bb6de7a9a5b5ab4aca9bf81fa1f6fca767d311a1997f6a23d74b1220d9834e2802f5dcbc28658e1fd9324d52a9221a17b978589a9780ae5a9eaf10bb91b727403a59c9ae38e6e6c41471ca5418bff8488aefd89c71a0ba3e49eec1728cff51aa094125597698332355690c1e5fc58ae59dc6918dc2756193099629a1c0e9a10561916bd2d8d37baf28e67975bec9b1d6f04995a367b618d65f8b34b754720dc20fbc98b61746e22a7ac9b872155d79395e4cc42d80523546932409696f30bf57422ff39376e1315445655c4d435bbf5dbbfe644624871512a26e658cecbb1b2a8f7f739209289f45020a841d334226546b53d9dd282dcc570189fafe7876cb69d222dc067b6b0d79a84117e8392a8cb7edeab85290220de65dfbb3e336ccba6e3fc7455dd45b4069dc335cf94fcdb0c20b6705dda24d3859d1ebed427ea82aee10dabec1b11ac2d4b2794689e58328843d7a735eaea17348250c9ff0d753c8226f9ec67437efdbb873be13cc37cb4cf752f626cc3d077485110bd935b82a3ecd0bfea7b6a09255c628799334293efa3e9048d600d4ba405a64e3f430bf23d8268d6fe16371fa5630341a55d98de5339f237e206a010a0066370be9dbcd707871b86d97adeed31d7c0c2823517273d5b773bc92ae83b77b655663ce2f27b96e066816c0777ac07f8539adc40b3444ebb1e4ff6c954279e333ab33e3db51a0581160122f6fe378379489abf8ff0e78859141b30d6743bfe2ab0a9c2769bed5b5a459e6d13364214f1024f498673b6b449940e7ac1f6d76c55d2d3dd31077be9c3615ca89b86f67b4a8b0add35aeddb2fff13e4f65f4d67ca7cf997e782e30c31f7a7418dd460259b62254082339b90d1a02d9fad2946b3a1c0bca14077f7cff2221466aa886635e0d408dfdd98d2cfc0a31d7466b59ff29825cb702d8e5689ad0c95a80bb0f4c27930b38533c0801319c78e1c5bf1ad2a1e5bc0192c80c13790d3ad899743b241366376bef0ea4815f3e209f9daa1f763a82260d1d029d26b186c92031c61589d9d72fc79ef22284f3596026194ea68145e0d64c9a7d9a0c6396a360e5a66c1bebbb0eaf222caf86d4493ead634954cb4fc013f23c76f0d8e806edba4c09cc758eccf7d8b1d36cf966217e9f887d1fa6ad40e3029f987d23175a12f4d2bea61edde3c29fcd485c71f56d54fe7f5ce6283a4bfbfbb4a1fc892da1e1a32d0bdd42f7fb91214b4bda26472610e73af46188b00a5cb8045c724ebeab29269a4bd4bc1c608d13cbe5803eb26babdae1c25cfeda4c748f4ac1a82bc42e4b8cc37819e55af114696b34a043d3a55c46282c51e01609f7444c27c1a83723c2774725b37fe0bc9f85413ae0b9523b6c5ccef97d567d0e29b627ce4324558c44bc93d8c2ff6dcbefce29cc42aff3ce73d9abd3b0b0b4fe19142c5300b2ff0bd5a552b2f44eba78799cdee2c7a626eddc091000d6d5011cb2eadbc7d6883447cf35c55f24d632d3235d8e5561cb7a5bd5dbdf4b3cc8961779271182ae4fa04f39927880128aa870cdb7f6f5c3b34fd30300b700275757a51d948d99cbefbc45dbe8058538c0e9bf906b4b2465c6d49c8193830278c15fc949d419f1f554e8d64355f52e641b1cba45e09c306fcfdd0c3c6f6d879c2f6d663d754c3639e5a1ab1a17982f5d2c480eded6c755ae929ab1af6b66cd1c87bc26dba9041bfab7d849ab7fe7dfa18d528f9753108687a2bf3572803b2ab2e1ef950b2bbf7494c43eb775f4f07966cb08a8d6a080b46cd2363e06d01cb107fd1be8108d709b244b0c98941f9ceed81902bd7e6698224b9b1c616349d5f09e2ac1a2cae963baa1b87a679c0c198ae703dde5098c34c829d6ff891f96e2e1f21c61cf7996d4d638bcd58d61e264c5be7d7476d9837f11f794351586e6fc44ea00677a576ad439b0ecb711c0efa2ad0ad76d5449348202547223b8c7948f3f2fa2eb60b42b3e7504d1b5bfbff5bb1f95ea850ed494be47a1ff597136e25cc1e1e6edf566a9344c35f3893192d06870f5572d91cdb867ecd0f4250418cbddbf5fdc579fa313de920930607c652b8dd312c4bf698ce700df6e525b47e110e5ebc532ba079195a410c3efa084d187705b5e635ebda2636e3cb78efcc2215d7296637a61ae434ebef93506952974881da9333ea0de6f34b2e1822a18d206842ba6da3864023ae150d4a59ce2140ebd0a2d8cbf562ac8c035444bce314008ca1190c5d1d1e5a7ed5c48ab680f1b89defacf6c8947f75c9e56bdef533b6c7c8cc5a907c8d8b695907abe21e0a07e351988ead0ada5469a9d7c2471f4daf37f9d8408f8eba34f9729697bfa7e38c2c77315f03c21ad79fe6c33708066dfe45dfc8fd12cd92c2fb3d8bd985dfc6ab0e0b9b77e4c1bf93fce6bcb6e45b64199f36ef4f936454e210b6de64a8189a0168f17ee8209e933e3932fe500ee4aaff706ce3d15f42e3d458d6b5e0cca09ea4d714d500ca3f949b195ebdfd12e7627037f92b01d0beb105f4e968de166a1222e81640446936a36bc3c53c35818d3ece2f1cb08ded5c752fd0d8a178fb351f694f96c31a52edb3b2369703ce0b6683245a6181322f4a7db0ed005c5218c99011e6f8d089c9a60161035b6c935e23fa75ba181fb1826948338dffb44503247148c1ae358cbc3bf792f6de1057982715e091d76f16e6d3e7d35a40894e45bdf165b7852b543bf1e4024377398945c3419b106dd2a65b62dc59edeb63c02ebf89c8a6addc0ff30deaec69bc2e18bd0cee4e6fb6464b1f94ab429a18f28608c5a09b783a57e4c8b983e635962dc4cb53eedf8b103d061777a5b4495b08c50fa53d6ee319d4d63b8ac11d0ba1f290755ad5e50fea971cf8a16b605bec1595bc4a693d905497d17ac2bbc2eef51e97dbb0f31c8a98253db6e28ebbdc89782ee45172913088d7d7a509698d9fbea8c71744043b62eef600af9da09c1518abff11e77735bec84c52de12cdf5c6e760ab71e0f32500ce1afdb589e87b7c18d5cbab9856506793a287ab10ca4185b5a8d7edf5e29ed8bf216dc5fbbcb364f8e7daba2bba650e2e69c4ff7bc9a2fb1a3e77e2f7194e8470c9d140344ec0cd7b71882d83940226dbac48048395d26d806cb44b60aa2077ab87a15c6de0cda525157001efa53a8f4ac0596b8b666c9b74781327c4c89b78adb9df24f4e333b33ca4cf0bca74af4445615bd40c49569aed59973ef671876ab624d7779729a691c8f5eb2984f1e00f14a48902788317565dae8ed7a8dbad21c29bef76110781b24ccbac4f4ba8423d13e7f826a0d8eeed4f7ad03969cbf535c2529311118312381aa6c2130cd3243b8deff05be119707d46011fbb0d2de10377166873ab979f21aff117c7403564290c90675a5e970cb75ebb9a06f7fbcbe37c8b04409bbefbef9505aafc54dcd7910110056435913091242d9a2aab08e7a7b4d9a15154e4ec751e701fe8d1e333d92839ac0406496466ffe68cd6c6bbebcdd800dbfb48dfc127894365c17fc7fffe9170fed5c68c0e169c70d106bf5e44a210f412b9b5376adb2a9204eac227df186fd93eba6b949af911076f58959fecdc16b9307090aecde7d65fa4fbb7c27484bd5b989e7cb805002d7194e3df45356d90a6c302a572fa9b0308c023437ef583d9aabb738ae6b1f235c867cab5539c8a16bd2c51b9083fb932648d78d7eca781b6626a6648fa8fd1f1b5bdb0c5e8b257b63bdd85009fdfe02b67203ebedce9a219e75fd372820155fb9d11ab4754ce2d6e440fdd4043991518b717ee172439f43e27b70c8d5f53d1c7917350f0c690f2dcb4558de140ba7200ecfd2b9eaac4271762d69f439f312843772a2b5cbec831eabdd1c2e7ed95c6a7f0d7adfa21d6978fd5917ebc7ab051ce3f1c46592cda489c41e1f79201e30434d997918669a9118749a8d87c0bf0e49d26b58926b55d3f7ffc7dd2e2c9f58e760cbdaa0164bc68d57225d2f5e55bff73201335cb99ea5972f5508292220fb2c7ab0d64b2887fb6d7cff21c9cc756c5db69efddd8c0fbba7056c90b4ecc92cad6ac7c658d8d3988c7b8c17f7de9d63236efc2713e54610538d80d0d47e8511322caaa0ba3947b598e5e611e5c283de83874d3eeace431fcc0459fca61323dc565e9196789a28cd535f6513041d9d87daf2cc5c5e90e155a4e5cd39219ad3d83af55d194d8b5d1f1cc629f8fdbcd44aa31440b2f94e2dec1eec1ddbc22de5267d4f76ab3b4ade8db241ca2184a351e89b50a83afa55ff3f4961fa62296f673af135271f024d2c58b43171f1b9d2efed8a788394c139c6b35fb8500c5527b1d0d9709f9120dc136710d478c027af188a8579259a54fed814350972216039486a5f1712657805ed083529093fd3b100cf4ed7e320fae2e804c563f336b45ff483b9d9d86f357a35da9e8b8b030fd300330c879d072381b8612248ceb800d88645b2547b8ea4c0496db0d778b9c9c394cf32b36c25c3b5a1ab51afb3fd8d4652c668565ed5510e047b11b5775e1408d7c1d5ad693f2fff21dc754686a7d543b9dc9a5015b9fddb62e15d7465e85d5399b1453d70632b4cd2932a70a6527cda96049a96a07636a71d47652b8714b7b600af8dddbcb4972eaeb7c2d6fed7bf8299356811673ca47d707ea13f4d98e9ef7c72bb594b7a0aa172d837792f50d04a973138604edc75b42b5b5f6c645c117adc4c2cd500ad7e1185b923fc1fa8d6d12aab87b89c9d032be46c043fc8c4dffbed6ae2c0474bf5e5030fa2802a6873ac1494e21d001c540ad7c5ace787160e0e77a5b3879e291ce93aece27e96320d50fd42e5da5e8f0b66c4c13b2f41b88dc23ce37b13705ff25ed9089f6caaaf5ecd973043537b541c7f8fbb5fa139a46ecb60b73d53b99f23496f4217eb4ef007344cb7a418268e0907e3612f230549d7ff55e8183f4cfee4efa6bdc38778097cf269cf17e6c76f603e55d66c427dd65eb4a4681640dd7866c30dd7ccedef15808f8514add625254d11171587bc51990ea597de0624d697462335646b89d3def8885ca7f9aaf5fe4d3f586f8432602a64c632a919c44047f28e6234b7738e9f57743844129b0fdf2c43b3737f4f59822b915a42528dca922f26343ed0a4d1c391529a80cb22139f73d2b6b93992f21e145ba535938e0e758409ace100ad0ad54bbbdf0e26d36aa6036c6c5a20fbc176c074f7792d1754633ba9ad8feaf8c481245237b0359c5261553db66d9b77b23b78d28e8a5113a13e49c105c551a13775d491900011f4cb534cb0ade3878cfea2b865d7da84d0a2627a8da7a65f5d489a89b017ee10e5b6bcbc350b2adff7c5567708b973dfa7d40f8affc7aa77223736ee203e14dfab46631deb4f3202d2d33b191203eede8f0a41ea6358db29b0aba77774f7ca71ec143b7053b64fcd6becf36f6740034eb4d92c79c16cf20d9e2bd6d7b3fa349d33bedcf92669f81363244823082dc7862d5ed6b6671ec568a031db674e113c3cc4b987b84967b97306fa4c914fc74b611fb79b6ac72f4afa155624aefe0e9836fbd7323191c605116b1469b1c84efeedf25e6b786938130cc451c5e3b8a19e71b0158633f0734f16766526c42a61ed8ba6af3b6fd53c561ed8b627196cef16e6e6adff44c18eca3e6ca05dbd98203d245754428918ac092ad3712d44c1bebe511249b2b54016604551f627e94f8505e135b5c360db9055de8a529a15a6f76fa954b7a7ecba75dcf4e4902fb66bc726911279936fbca815d7c1ea4534f4557a10aeb6f8acef7d8463d0c23b7251149b230fd3d7e223b398507c0f6c8603ce98391670f7490c684cff0369c5fb6df41f3df57d5c0fe4e805bedfdf88d4c2ac2c1098e33a6138346aafc13f4d8f74729bfedb1881d91ab010bd2c80cc7142bd4b9c13138ee3b5d98c3949d9054637dd824b50a7acdbbf65b010617d8549adde4e7dab5db77a948bf76600c45a305c31982d1116582e41f9009cec41a48b73bf33ae911c08caaf7d1b75ca947072a8120176cf23226440de4a90aab94099f16579400b949d9b780386d9b1b56295add7adcf377d98ac5dc05048e9bc422e95526e609d7fb1343e3c8b917e3b295e8e062176876652014c9bd88774132c3fa779226f395434374d67769f8bb387e2f289a70b7d41cba41f06bce2d20d8c4abb7f730620938dbe27235b624e2f17fc2693e9f8bb9f1b43e8d57709a7379c036e4de80e6cb5dd4e519cbfeda947fc867b5b0db80a13ed6bec8e11905108bfd6c01775767743fbc61984ea397f772b2d448a742df1ddebd55a30f8cd4381b8d6e801b85aaf85bdc72ab13c630c2a07e0b86850763f59eb4150f2fb3caf2a55d4182525836d5f7cfb11e65b3339520304d39afd2d7624d87e3fcec3af906aba65220988c5922aa0a8f8858a89e40f830b0dff6a930fb5f9ac54138706a7a94046c0d0a81ee9675551f3f0bf0f1a21de60ec713b91803616f65651fe9477c3e50875632e9b5a5a7da92069698080d8c8f89d3e03333af03fea546bc99776bfb42b7a4056093bbbac53518d83d7531c852b4338a961626d4c3be9cfa880edf6c1b38098f07c2ce4c253099c42e517b7aa4436c2ece5d0a4ea98ff50b8a6219e33d8b8892901aa9f29cd8f6b5ec690807a734bb7b5c0124ccd49ea7a7841948cde05bf06a8c0a4f5d8e6be26e3aca4cd0b94d95f481f160f97aa71ab4e12ef0d7eaa89207c99a735c483f59fe754df2e8345ce25622cccc7543131eae147224a9fa30d487fcab711a4772904c8599809e09dfafe1e45e2c0700cc5603c16ffb8ec29d5255bcd990540c8812632aa0293a3fd2c785349ec4fb95f876207fd4842150c58f07e9c18a99c0c259adae18c2d6cc6af5224c687b6f6f2ea8aeb2798b9ac0422a199094762fd62eaf642b4f06711ee248b92eb393890441cdcec6db5d2c6c526440e977a25438cb35b049c173cf2ce2f6430303f6a2a0fbb855b726d8c88e5fecb0b95ce366e78e0599a6de9b010b3c88adadf0bd3bf295099af79cfc6a2745c2c6b528cbb7e2234ad27aa4ae2a6fe5eeed141183bd035a42db529a17459c7bc16552dc1ffeb72ada16eed39b18bb9a49411cd564160ab555b50cdbbb71bd23cfe037756d62888558c5342cf0e7ae6ce7ca03dbc908202d307dfe4bd1a5111e23093af426b1aa9449051de083a00acbf8e6acd124221bfc21419342a1788c326f2a03708a7ec236825de8326cdb2c1b482eed6d383d84dfa954ca0823b1338a8e796929f8b048ad84a792af58132a1f9b903d332bb6623a348958bc9dcfc23e15740b50c98a49d8f6ca1d75a7328d6118885609a45b12ba0b6fe8d84173c2aed441a17a59a7eee837786cd9e62062c11f36088d040952df7cc3603146d3032926c05765225a0979828ad086131bf01e14ae3480605802483460a0c22b8088b964aaeb67c81e952a5a2f1494e4166e9e40b8cd6a716b2793c9d98581e8cccd864c6e4f246bbb836b94a4284a9213549029a5d131408670694fbe90a9af4cab3c91c43bee2c08487fb456ca86a4fb79615c736d2d0ccbe30104aadec4e275376152f719ab9510f2378596afe06c6879e0763c038a091db212de12cd1566bcada050d45889b1e0cb02b862b661058f7f663c27a1c6c6854676c2c85a660d197bae00491743b1c833d62f143872ec68c4a513a9e31b710b0789a3a5222b49380518bf85deee094d47402bdeb4bdcfc5ba84f9b25a635107373d95abe8bf510226424f23c9711c1fb872abbe94d75dc67d4b0c5c4063d7e4db9e63e0ce1aa514b30ca941b2afa8860333b03667f175f80d22914e7597077fe9640cf87d3ad06f5d5970f01b9982c4ad467e90a50760561b872fb36655ee411fcf0a7089c5a7521c5c7b765549ead986fb1d9fe043bb658190d31c804fb650c7cbd570f462bd0607b95bc2693f90121bbe46cfdd48b271794d7cfce268cf4799ab38cc6da7aa142fddc6ddd2a1e6b715b8e437673a8934983c14ee3d53443b67e10af08820213cb09eecaf00606e3a0d3c5fde5e7c3a9929292b6f279ffcb0b7a1f151eaab0b9cfa6410179b223e3084e988d0383c8070b82935be07414a2714eae071e8cd7f4ba2ed348ea6c98af86ea1c6b803614bb964b1f90ca90630d75ff73026c662517e35c119ea7a3f26c7a1884eb360b194a8fbd9210330150385beb6d7fc069a0a7309385f36767afe04ea151c3f4e0f971879b2ca10f006b77ab091c98a7c1bf18c3454acb6353465d781d210a87a15fbeb236520faf40558e3f3ec5352b0283523702dce3232a2642c1f9947e8888a0ec39217cd3f3b8a6b5d5bb5b840bd5b1a4a0c053fd56f6954668710947d59522da81170da2cb46bb9aca204205cc31c450e6f3f6ba4bc37963a2de7cdab6840651c9d3dd56744b8589e463df7f27bed1e16a09e9291c9cb5a6e44a260a09ffa394b976112647ab6f401db64b89aa8bc4d86fc06a01c6a4219c988494891a4541ec494e65a2137a20ae9ba07a657d80392a959cb9782bbd22fc574848660386c4f452083d1475749e40bf7fe18831a0c60681aab983a1e8dffdb8ab3ea742829d875f3849d68c42dc652eea5a23c3a66b840649cbe9f54724df2c0cb96800139f0784acca353d8d5e362ff86580c37535463ca784924946b7a52198f041b4a9571985fb4c5b205de61a6be3996ee4c655059cc9987ddc9127f412a7e801b508394301f23c41d24de6cdf25b556145791b52e95f497c4b64968769eec6ff7a88d5bcc56861e527e9bb4d7358147aaf7125adad3c4620dd1d04b37e8390fa302f3b067468e03ab26f55ced1444c9431587d4345927a78c7fdc23340601e635746652a9a084bcc9c648ab021fa379a6de263a348c093269aa0a95461967a0124a2f13b95926a01fdaf5cc5bbfe1effd4c9cea258d8a1f14653c4737fb8e57b79c037a0b1dc45a13695afbfc204b588a8b9827226b7e9cdd186e1f29d35c70395edfa85df4c7ff41f03a955e8d0e22012d82d9db688905232e8fad3b99c8505f3d4a5da370cbd36be37ae1a4aa7dc8c5e5a2c4a15f7c0c67c8f46bf1d58549625da89dc6f66d64d277bd101bde2047fe80dbd94667c47951fa09272462f68d224d6b53891e24f3fba1c252ffd4403e7b2bbaef87d6bd0b58497b2f7d1422f483767a8f5abd4319c369d9fe74c6480db6ddaea25e6f950ac96ede13f7272477915c066c4c19b1bac688b001ecb866209f5802573382d86e0d6a9ac8e9b98ef5a9b8d058a24f9e9fc5ecac0e1c015596780564dc57e5663ad5abc1a951c821be6a0aa511241046ac0fa8c3b09597118592521c8f517edcf2a15c93c841a680eed71ab5fa583535278dff4e6054d42b5d3af0c1a4c40730b88e43a23480eb4daf58050259afef2b30503cc2ed2a8b733d5b9fbb0a6963833234661556075d8d11855f4cb10b24cafa248359d5a2d5e4c478b054c0118823d1bb6cc16fa7052eb19a7a2c7ec9ae9c05e82dce9bb8ee2fbf66fc701928fdaebbfdbf42b80d1aa2ec553ee8a922477e6e6af7c772ef46e0abd7d6e9dc860e640aaf9b7e6cde80a8cdb7738efd6c283883076b950b9416261de80269f3684e94f40a13156a8135c13e6ed6940d6d49aaa568a6b178ab24ea114deb376dae8b7991324fe35e72f2d408c6e39dadd5e1d145469ca7d52b5a20fba87bee87b538292961cfaff0e3fe796ff31c15aef3e6bc610f6c306004fbd91305977d236264a86e952b0bd88ae87c5bbd8066bb74d73b5d7b2549ac76a54a514de6d6ac9ef5a632942e248a3533aab1ecb482b3a0c4abcbb147e577cb7783ba71043394b498fb563c4a7a115e9ce61f4187c31e993a5c0ebb03f10b0f8ddacb47a205ce694adcb6d13d1f9d741017bc7e68543fe4fdaebada283638948a54c34a809c6e4f1af344008c0c47548b27d56ac08c56eabe38ddf00b15f1c237ce10d47422d20dd92e378e8c3b91ed4b56ea3b55d4ce60e91e1aadf3112fb34dbfea297050737e705ce6e5e018ebd43410c7f5c5f7882f5d8a1a7a2caf3b29d60e0215589b818635dbd8557980905ad38a2af1bc4414f571326791cb514be37db03a746169597a3b6a7c1c666fae7e39c6cfd98e0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
