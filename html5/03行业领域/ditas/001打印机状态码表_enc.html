<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"29ecf7f126643786ddf5dd4ac285d25b2285da8faba2fbf30281b306489e7164d873efe99334319a121cf24682d8714abd6e416bfd1c5396792bbf8a4d1a30f9a493a0832e430bdbdc70697c13875ca24010c199cdfce0d223e876b92de3f316de803f9a4973b00ceecac8bf7e4b6ad9b0914189a357a7724f6af67bd971be7233e2de6ab3152da99b0f8c0168aee50420e6c4f2d6ef3bcc76e9234b383efdffaa1765ce0fc611d6bb6504cd57039314bb79d3ea2db6ed57865e6eb9abc0669c930d3de3cd1789609a64d012f93004cf4c3110847806865fff1fb700877cf7e637f38cc44485fd7127fc5399efd19cf826b1174fd89e5f6a6358bd3f23cac648019a8bdface5824597a14434870e89150140c8f0a55f11d77da1c9554051c7047971e361fc169aa912a0e8e6bea8df3a91383c90faaf3319923c5f4a36d8162e696c686fdb6da4d185a6e92eb6167b2de8c121a7e6fea092d6dc6984ea302f816edfd6293ecb74a265fdfcbcfedec8b097291beeade2aaa6769c121ea3fc5260dd833d1b2f823fa0557568f8a70ad8f335a1106b021188491cad77f930279c01f3baecdb865223e85eb5934caafecaf56cfdd25716ccab3045759fe1b3326561f8a4f026babc9bba6c063fd684251a8ddf611e2fedd58809bfb87baddb11ca822a4da089d68fb964cf2f263c186f2df35067b417e67906e3daafd9c4c69b59f39ecaca5c6d05a0cc282e0e1d6e8d30349feb4307b0de8eb0d64035809ee8654e88b1cdc55b4494fe3dfa675479b866e26c44c260d4ce94bf09125fd3273918951c536695d20edb5da53047c0c0c5b269da97df9d066314194e5a0065c55e00dc4078a00eeb9be643f60d9b6ab63098275fbcde6a336559bf0a15ca3de075da460c56ca34d19ea000e9ae7cf773da5359818d0c4189a3fa69d274068ebea51069d433cd0134aaf6d82318fbf81a332600209e4699097e86d38f4f75b4c58c47d4cc0b2ac72e247e1769349619773f504fad2532c339a667ab41364cad927e5103f8e3a3c41b670600825de1440574a08ef9d5d90f2a2dd9cfb0ea9e731607ef17692b5ae6089818b6a77cfc17d7da275994ca86248c554fa9a3207f27f356e8e48c6c1b8db955573ca685b66bae61ed5ea4e82994ffd4c30205ba3029fa843882b60fe4e180645841f8b02088332700a321eb6cde430ef576230d4738153e2943e98029563567727b536ef24fa8eef00cc473279c64a60955c9a4710cf2f9236065c98444576ab0d8b5227afbbac78e72fc95dae3aaabcce54a29e0cf543a6d62e7aa701b5739e33e42e46025d1e005c48bf653041005f85b8797397d81061e7a93062e105d8695d0de4853d71f6fe8f6b4b1037699478e17847255b2eaab26bdb0f2d52e34b94c3b80c5209d0e6a2b855e411890e0c264856d16aa70bb93c5d5abe65479d461c8a21e1a39c40d634260f58b20f467f03aae4117a75d63280920aefa16b073c8861ac11fa6414268918a3002c5a58cb4ef4ad39f565c85995a26d64302850b3b4eebfab53519d2109d60a5aab080e48b753c56ae6f7305dea64bc815bb9dc881baec34adf720aaaf92edbdfa5143dc42a3dbf826ca02b9d467bef0b3793e70d1e6fe8171f560edae6a59be897a5f0429854524b40d46b7f5aaa0eb47c71b3d6696aafda15e5e2aac80592c82a3206dd2880249f4dfd98d5a4abbcd0ea3a6661da95c79c746e53e2fb5b69ebbab41c9d5385a7dfaf1a65909ab25340278ea29a72d204f61a69b859084cd42aea0bd96087ec435c1a270539f89eca35ed100ce789b8fb85588fddbff49d7d0ab8c91cf9f66e7eebd3f3f52a350c598290147bceda0b5377eceddf10bf8e83f7e973ea30d1bb0e44e6f17b7bbee509c9b6e148433e0cee26816578d992cdabe2d3cc6a79ce368dfd5a58e937e453fd4dc0a46a4ec27cfb674b2b7489afc1e80ca65b112a90218fb9c211cf068991f74abb59f4610f324d6933da069a6df15e2a01b05c8da38801f016ddf079e37efbb0ba8626063e9829628f6e12e1f11500e88b8677d87bf75767e78fd687886e6c92b5b360fee6b8745f495b7d2b6b3728f8e0f534582a2d21e3d8bd3f3c97aa277400cc0fce800a7e935d6fdba697a0d481c8dbf2c9dc311de93145700203de60ff26b1dc2de8e3124822919094dc755a76937a28843bd93eb5f644248cc5275b4e891db7e5bb1e6604fd059a557c2ec38fe53a82aff2c87b9e7c6d59af2875f929019be0dbb2d8a1782161d4cd05b0e0811cc5f66d2e81f90eea2514ca8fca6af8884c589be735bf02bb36286578fc42ac5af95ba854dcc1b5f9ec71434014552c9b681c68fcdbc190af635348fcf3eacfc6f63bafa7c78f2bce2161e9a483a7aa873721466a5118e3560abd2b1182b44678e2892c062520ef2eeee2169a19e0fdfe8b17b4b5798509a2c9553f1e86b0b02d205b4d30fdab92f21d0fe85a0f6d31fb3fb7a544b99d9eb309d8a73d6b97d62bd3f6b130ab6f7c76e300274ab1b50ab8e44d26a0218fe8c0d991dea82278bec4fd1deef8f5053d0f41f57d3bf16290481971c343081f4f6e9ea9626d66e2df4ebdd3e05211252ca33f05f975220f149f9ba68f0b18d1cba032d131dd32cf0ed32224c4dc5d9f8dbad74efd59b527d7f31bca6edd8f92f02f5e6d44279b76d3b35af97984156425c5fe2fd0f9f760edd1d5898ec51b47f61628f6b3d830b2809e69a7a10bc9ea26146d73c36ccb5c3ba5071681d4c8fb80dd5fabf1584c200cb6b7db6358a9f671ccc075ce94077b4952979eba571807fe1e2193c0393ef770fc74c1fd89ac03d92626f0a6e35eabd65b70c9ffbbb088d2780242f230f1a35648c3158719c54f0aed1479016809549c379238638dcb4a2d677b48a0a016d674b9a34a0ce2f4b30932df5dde9fc02b72e138990d3ec02f70706c90778c0be426b88352e2719f3f3361d475d119050dbcac86c5c78c68150a07b066420fa47354c915dfe1b7009c6f6569dd8498e76f46f3e6e62a4ceb8b1e7d81bb169d39fe0bf1be482825df7f78178cf532cb1adb91eefa1e7333ccb72d517f488a48763a4b570e3b5ac3d1d9c81ec138f029ce88ee7729de3760082edcb36754824fadc5f820e26b3383044b0c49d5e5b88c8d2a865121ee03a4ecfc2f4e56953ee03714f7ddf86507b3d56935c45bc778bc7fc8e230dbee46a3540ad7ba7e26726b30e1131cf505d33b9d9a2fb4de29a43e1dbed989f92e358d9f792a96a40b99222df19a2831d40ac074a4f2b1b2752cd8c489fa98a91e91df7459fa9fad76ccd86b2531b8a71b6a7a8473a9c451c9085d2df2742b4381dcf6d0db5e608019c2a73c6359ca51f788b6f618482c20d142cf617fa684898e47e59f316cebbbe1da238065c502a1596b4cdaf8b968666c597c15e1b1cd119062949e8a04419eb729fe04132025f205311bef1223fed6901cdaa2ae1a6e80566dc735ef93f643f3a88243d9b938b16d001e788d317122d3249dfb70055fd7edccada42eb3e51679494f4bf75d70da32f6ff20cb97585b08df642a176a86d618043eee8e732d90a5fd6872b4c33e1bff4963e5709768969c7f7febd9b8552df99f0ed47ca3fe0f8f1415a1f33bd493dfbcf923c0d831197343e784cdc2411daecd6435ed7bb33e0a42cb99574825d49054c948390f4abadfae26e2fd3ea2b26aae184f66a4e200845968df6b271e58a63cb89e4af50e628d9fc83acc1153df1608fb498310359e64d2a7a159756b1a3045a1356600cff776dd3d0f7a712884f0bc3275b7728971e7420257b742d8e405beffa3109ea48479c8f3a962e036897c370ef0953f721dd7956b0cc15bcb3f78238598d2b562e0f92c59d84db35e5cec65d0792ff1f04f3269ec25b0c2000d8e8c739847743bca99c87d61f9e5e803f5ed6ed39edcac8e63dd2e1150640f318b1f574ef02b6bfb287433135fa3eabbc3219cf4557cdd3cad0bccf0fe4fb37ef2d09361bc8f7ad6bcad18ca459196cf6270cd0b95e09e7a290ec20e29bcb2d7f65d0a22a42526db4a732d18340ca8c2cc54831852b050bb8cf7f456a9bf22d97e72fe0ca4a2da9d4ea88b48a8a240b4e22d9d4c785cf30d064cae57de660e7455f459c807fd927292c5d3be4ed670743eb4817b8046bde23f2605269c82dbf1df198a7efcc51c6703b98686ce7964dc3d5999a62a5f0f1242455e58b1013111c355989b11d7bc42c1f81c3b4d293c1eb97dd9df552086421bc2c568da8e27fd8dd7a813b3bb6d55da015aac2b1ef1336c37d83e0c9332dba178859da0b7fe24a3dd087383b9f77a865ad0b716a5be4dff4c29b4fba202722df71ce6ce6465b61dd11481e8caab71e4e447343172e5f1673cbfefc8937f051ab38f6b038a61ecffa39e1013f3e922639321e750b483d27d9b80f86dceb9ed65b4510027ea43f4b2bfc680a2421123c1b03d7c44749b53a3ad65153ae12da78cf734bc00e105e3ee6374a60536710105c8ca39c66c4f1af339c1e04b8654e1ea09b85179493c970699be101b59e903d20ccd5fe2f79640d858157d29ef2334d300db106cc03183a3e2aea4ffa5c618ce46f13ca21263d3a777c869792efcb44353bb22d18098d3784627c889befcb487d9e3979bd8c7098c9f7277adcffb97140ad23ec6920bdb655ee379d6cde77d7925cefa981f20a9ae0e94e078a6cda8fd50adb03a8ea1db238e8f9bd74d7de3e9f6d717a1e3e9a5bf31acc24128ed747578e6bb1f034030686dfafb1f4782ef4c4685f2177a1e32a258eabf113dfbf01af9e6552c1f8b7942e37cd260eab1c4c528550ab9f29dec5d48c26e21df27e93bc9b8809e82a5a4af5b1f18d6436db6ddd96e2f5dfb612e465729fa63f9adc84b79b11d7bfc8a1d5a80a2461138795e45c4e66972b9f19601e0da12f4fca2e683ee52db9c71561fcbc636fe9793a7362ba04eafab9e58b6167b7ddc8cee62db6cf727d66fa2ca1afaed7e667dae87b691a7d21b6f1b3d173b8cccba0669c71483292a45d25046b081e95b13889303ae1a1f9bc73faacd7c96c2d52e65a0511e06b45d7b50d44d0c1987bef1e012348f1a114643f16bc076aac8ec9e1becf778bd9f1657fc8eb3ca904859f12d35923267a612ec734ba90d3b52719a730b65ba77aaab308bfa57af72eab62fb5530c08316cb0b12f0304799d9f9547e85f11ca8938489b8c8b000066f8c0ee16e3550d131300878d9c72a842623a9d0e295b8b28e50ae95cd1d155f1f3fd5825279e0f1842bfc4dcb3576d8df6d86e717982c79b15b793699c509d342cd84229dcffd93a77cc30a01a6902c6d4509be62b240bc98aadedbba0d5a55d32350c8a810b9ed0b5402a1a421e0099dfc1936624432604c26eed5c5e317bc6174799b73084977852aa4c048a1ac5b6289236258688403f83e49836097be9c366098f872c3086cb6c34d456efa7cf4f79e663aebdacd65603e136f49ffabd8e238d4d9647b35d7a87162a0deb3ab6a2d9ace869f5f2116bdd755a8438e4fdecf869feb75e6cef3f9ef4f8554b5b0b1cfcbf805295eb34d85eaa06b97adc95d1d0020f6587d6d550bdf3aff1f558c4a027e3f837e6ac3ade4d0368bde65442c0543022d95b2bcc5c36b87438a2259bd388ebb3a47f6d17a43d2d5c2990726207a2cca76cac5040c1cc6cbdd6d4065f7944b1108820cb8e57bd2a8cbe7486e8efe2e54fa903b186ff8932902c2e84b7509ccb4301e647a16cff9be52d259818a0bac87cbf5b87833800055f2697c4000074d5b9f88662ea141d84946d28be0624f411ff3f4d8361d7763c0e1568fe824a4c4901478c759449f84daa00eade617836454dd3b59b02d78d0366f52af96fe071edbf803289918c5808495eec58a2027180f6aaede74089a41af1f3709e051c31bb5f6a6af0260bc7f100d255613c9a65a16eb946c6d535df470210a4057726f6dcfeb8fb8033fb829ba2206f933815da54c51202476630f6c8985e4e32a45f15590f0e9ac4c7b713cfc9c4b6afdb3d3ee0ab814fb476e555f7280520542bf859946d9175f0f9825aef2b84b8d3a4667a7544e6fd6bf663dd177210affbb01a8ee22bc1f579e27eed4f0ab5e15a5dcb882719ca7cddb1a2372baa5264054c291bdc5731c1cc355b1187a2c1fb5bd37a1f03c64c431e819b7494be143794619a5cb4ea8e6c0eff1cee78b54416771dc17307ca219a2d8e4cb9ba29dceac69f8d404301623c81dc3db235707bac9c2319e73a01f86a0ce6be36a522a9332e1bb8dc873ff6f696a8a76a52636021862f5468527ec1a172215c7b915d9174edc294d15b8ff03699b6a3a8a112bb59b931cd02e26f023fb3b350b8b2e6a1db3f84d86b03fc7f414ac31a6c9aaceb702270ac420763396f780cd6ae35e6021f1eb219b2bf3fe5b9caf09b626f42875b0f311473c97b254e1f9622eed986b4f24d6047398c7f7dd10b207da1ca42ea9bfd051a523ee4c96a13b9f03316f3efcd6f7b555a7fd85b85057b0ac224e1881f0bccc000541379435f083aed8666b6763b66f18dcf7dc81597eb61d07458e5541f506ed41f2889559582e58a2193714c12762b0af69ebef4780dfbf5ab314bcd56653cf6658d16fbce983f9bfc6da909bdb0159960a6a5babe27e1e0094079509da42fb0946f21fbd11450b1b3905523e631105e6231960d6bb6b6f719f730af452b31402465fa8934f81524574b438f0b30e41d4b3a13e6a5f8463008eb9df494714407d8d4d93462c2c93fce7978e3e5427464784a28368a7b67302da831e24b4406ae5f342465b215daaea5e6c8dfd829550c4074a0ec08896835f8b59dd3694f1912c977ac992f9b75289a9daf6f935b0f2b17d5c33675393bee209e18d3be1d9e9f07670d91e4fd10f14ae923541efca3f18aa0b1a9fb22820c30314aea5c9c166a067637239c167abb46be8e485e46078db888b390629b73be3e9d13a1144cc7da6a015b0f424bd9418cae43b2a95f38762a860907743b73a0a48b2f3648863481f2d4bc94be7ea2b5e0238d4024f08e29ab2160fe6a35601044fe7ac2ce8bef715fb3373416f812a8ad01c666e9ad16512a05853c0f2dc28dd41217a7599c3401b1347127db636309ef01605f0e612b59b60fc30c22d26f0b3309624ca150406c6a7287d4d5918ef76c8b878149f51c34b6ea1b4a624aeaac811fc0c7b2ec6a76a138f9440f8d80483e5c7cac745a72d27727ec0722093c758cc197c8aa55ce28762366f2fb540cab364ad2b39a5012778aca079cf35823ea089c50e59f76ab72b247492d29cc60f786b3162fac7eae5fd3b7aa3e2f5c7b15775d4e4561cca3a887e61bb623d71ec46f8972939b4eaff58855a4310ae702a6fc62c777170596ecc6e3291960527a2fdb457be21762a108db373b517a5a8c680f69111f73865ad4b05d8ee46c87bcd62be43274a9148ff8dcdf23bbce8977913bdbadf962e4570df881c58f4985828b8a72f954ea2781c0ebd33ddb497852e2298df33ac6b11ed055848fada52e825f9b7184db293972dffada8f89262e948d104209662110ade1ac36009b0944c6483b1db1fb38114b12302de4ab633124265bb6d074c7df0d698c5c5d034475173e024ce8494650d460491ea629dadcd85762ef0771e2ef2840517a61415937ca5b0ff5ff76e682fdd53d85be55ca4e06167d8d7174d14b63bd7a4fb411ea0fbd75d6c40a2739b0c25bc9f300de5f62788a0bf2cabf25204cb9d7800e94a82c0e9891e24a0733855151e55906f182c6cc630980e03d46386f4a6d8051f252602ad87de162b04400aee12b9a7a4c9c25734a404669e30a0fd3dee5fa29e96b9d109c7eca2b477f14d5ba590bdad1fd276e3a58782c5c9545ab77d544f0b5d70fce5cfa72169a658e864efe5e2a419e68a18cbc092e6bb9c9e798bfac5d7561c35882713b0a31f21ee1b0dcf9a717d181c8b55e8376ce1f9887bce9b6ab6fce9b5880ec2838fef4c72d8992487a2667c65d6b35ea2cd6b98470843ea3bac242be851d6e689b5ff7b77796f019abb36174dfa191d26026aa0ce9b56967cb1d8599851abfb219de1375dabf1911604d11be9b8f89028b2374804b4f7adbe79739f9183cc0aee991ab1a20717da84000ecda0037f1e960e95d30d6e828781d34cff0968888c8d1a6cdbfb9020cf7fa48fc02adb33be773cc8805579a1bcb372df1d132df95f535e40f78cb55deaf922be7cd8eb9c7417a5cc08c49f35a972b17aedf64d1f6c356ff98e5418b82962ad39136c606dd2187ba8a72d62c1df78642643e3c597c37744c8cef66c296177e29460839ec2a1bf8e0374b2f4a5f5f8098160a6379f038366368e5db4600d12a1723c782ec799d0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
