<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"91a47b9d3ae1fc682fbd9cd8591a09ce58e8147f08ca655b1bb70c2152c970ae0e4042f05bf4561dfe7a714e4562b722064057d9d8bd340cf774ef7843fd9a5d18121391ce3a3e586b20d4a0135d872934cd1a5fc896ae824a12b1ce9304153ce0ed0fb03d13d12331ef00d19f7a5265326401be131799277377da4c534de15adb1e7019460eec706a65c06ffe4e635434a53a22e2989355c1d5dd4b6bc16a13486b88e2f8bbfdcd399a1ec9545e93bf8ebf098effbcb096030fde20c8cd6540c0cdf5b99a2b6e7e6b183c29cd95b0ba4e56ddf362c0e50f97ef43fa964f8eefff5e1dc1363ad77c5ac1102f4843bf458be22139983aa9aa4c609fc11b6105a6e1371c3cbb4eb3eab737a79c8b0cef726e0fea8a8d458d4fe99fcbe0cb467bd99a03890d903e2e2c523fb65c77ddc4787c445c6c241880a6fcfab4d9fbdebfefb5f20145fa3dbff05ee7a0595319a94a46d94ec0265c041e3e85fabf6e799a02279673e849c4de46c3f3eb61c9a3e2c9323785931d57cf9601192e20f3a5a8bcc795940700c43e372d644c093004d3298a00b0a3f8f708f0e8f59e53f898200a0dc9ebe56eb15beaa367fb3c4444b95183c9fba7152eab992a258d6fe1059ea35abe3887ec1b8e29193eefef2f984e2b0a7a96d3858c3ed47a288e0614fce3cbaebc68ff9b95c1c7521e15624c2e1b30e48ca2b93c72600e795889b19155cc2a384044bc63ee47273e136d551199ff8fcdd0be7c1a596e0bd0ca09668a33ede502430423fddb3a5d67bf342229d25f71842381a898bbdd4f350d606af2f6701ea1dcef2c438a75bfcbf38d992921bbc8d5bddbc4854a5e361a3ef4dd5c341c4d4f39660c1028cfa30cb56b28c1da9b23205da1c84bb66e37f053d3e19136ce11d4fdff4eac6194fee91362512cb081b312dad7164c99dbfa61ae892ef4b491e4b0cfecb7565aaaf2eefa704b1cc3a154ae139f8f05d4fd16719a41b3d02f7d8435ac819fd2ac422bae9f3b643bf9221d8ff50a1ab2a8818e4660a1572f65a3b69de1557ed7c9cfe3de6f9e4d462131756184353b2b106760f4bb5064c1d094424878bda83594a175e98c9cd35d59d13ab27f725c15cd624957d2e62614638544b511760679a7432ade93c918dc7f2d8974f5da4c13636d973dd069318df2d6cc2b5750e85d6ddf988437c33c115d3bda13014388bbdd3e536fdd4d102a82bc3b9c0b0dd09907b23a2037ae600b7a31aa3f9abab77d34f6175e002b7f258cc86cbe3901fc4f5bf15646da699a8ef5d21d3509b46114235a6512e38aead315985298f6419e2a299cbf2340bd6224d4700e85ed6363878203b928e5f8b1c5319624915ce4093f4e811be9d96613fb11fdac9f5ce0aef22ca4cac53073e4a929c25f328aca8d00cd815d3b7f7662c355e0b1988d5b6039eba91474ce6a778c53d84dce44b191059fbe9199eab093a1a363604ae26dfb5a68fd636460bf346843e25ce56ab861fe779534bae0030cfc175987b9e7f4860b9741a6c5da6616c0d673f0425fbf67252964cd296b0f10b5ecf7050f631d6cd08bc04650d8500fa4ac4f39121e59caa241820053e53b59460eb9b4bd768ce9e31a8c3b16cdee7e4315db7d57eab787fba50e7d6ef66664b5c64bfa95e4a53be6237dcee4bd0b76f4ae1a9868b497f5d5eb9d5cc3b2bb0c40e2b44dfe0ed5c536e30151e5a2806c72394a86c60c8a9f6ecfffd7ce1adfc5534fd95ac86ee0063b2257dd3fa53a2cbbee9c4c4690e6f49c9561091bf929506e6d9bffef62a2eb3a7e2438812d2f7bec70cee50712cc615ce3bc7e55e8ae5476aa2fbf82a1d2a55d3c4f006a9bf77c039773b0b493fa3f8ec7358042ec2e9c1349620e103b0658227040ba19b8755b2c3a8bbe21cf8d9ab426cf3143b672f0ed76221f57a971596848fae2db184bec35644d819d0aa8106fd64d031a66de145e75ab5124bbbb64276d030c8106981327e52b33cc949eead59fcf0f1b7e1be90098edfa44fc5102223ba5da1674bcf1bd45c06ea84b1f968a92f267d397ca9700d772c99c603c5550e83abb758657ca56c1beb1f4bfe72928a54d25e13d272c909675596df0d4cfe97acbf083fdf51066ccdd8c57cca23b8703e2dbf61332e2d418eb7511a22c3ad8d1ed4b9758e03c467edd333b46be55fac49791588afd906f964a4c6f7479f1a47994454297b3bd4feed6757436a190897eda71460eed35c7bdb1c1a98ecf1afa16c302bdc01cbcfa3add2caed9926a8864ba71255925e71b85a276c6726a0575d88d076534cf3dba7c0256ceb1898923a41a911fe1287f28c8465f8fd23fc4f2ea2aaa61f46c47e50161df9060c2f5cba0e71198e8e9b3de8bfdcd49792fc6fd78cb122b2450ede96361c5a52a73d1bf43161605fc2447fefdc98aa30523515502c88cc321c9b22c7bad78b233096d9051c53c0a446376bac241a3b7cf93e9078566b65773aac31e6064d8daf04a3b08ee8d48c2bbf0216a28e22fb9eec99781f057ec76c0ae87ec862ae5c20b0958a03d1f29f1c0ef880cdb50d95243371f3e6cf317072caa9194bff617c761d19e50310f63d440bf5f8cfdd3a037b3482efe15f46f452248441eab64ff2182dcad33b8ce0be62c625a4989f94445724305161b7018c80f82493781203f4e1a4f3a4939f8ce123bfdd73110a921474d100264eea0c9bd21764418ea64b8277ddc3b3a9b7072f74ec13ec73eb2a491a1c33b10e7e8af3e6a0c10d74e5431d36f282e2eaa54def9b3a661ffede1cf26852442f10be8c8b76b2367cf7467b875c06893c6631e958849e6d7e45926853affcc9ce85fcf05e03c3ccefe41f0b46365580ea873297cfe07e97099bef7ed7cbe792f449da551f924fd04ed16c73f527e7d806aadafa2ca1ec6c091a23a80744d713c50de11abc0521766d6d1de8cf4ad34c56203a0db75fc955d23ea1031f9be937fb49338fffc9691198466b68932afeaf5f0b10962634206910cb7c4a1596247224025828b21fc37fcad1449d33117e0bedb86f4485a4a6f65410c5ba1cd6562a68602244955df01e9ba74ffc309e9cd95afdb86d62c0b86f989f7ec3d608b34cef7f894d60eba40dcdeb70467c8458a0468d8f48bf8bfdf755ec7062181f2bb758284a38b3029c24eb8185257f395caddbb9c844795706fc6020b00f74a0672434ec5741c764b5558fc1340c4e78b926c97b986bd4d95489049cacec7b5983d957826da68f1e1a74bb168e997998adf41b02843365fbcef75efc2c78087931a1245d0b911278cddc5f2af1492359e408f2e0d4b574a17617831be9a84101d7797d9415b985646c1073b9e66f9bc580258d68a14b405d84d0f327197bd94dd47d6a39572288db8f214500fb814be56581cda13d6ce2088943a52caa9fb50453a41dae0b39aa2c0d6fa965af6faeca55289995a8e5cb370c55a2a490b4d0d2e6b4d0476730d8b641305f31ecdc9938c4527fedf9784471996ba25d72d5a71e2c70e0cddb480333582502369c10ce251a3b4983e030b88de6527eb7ac64d54267c269cc7066a9ad21dadfba52ff4a92b56c56401c8c46bcbb82229bb0e29781a3e8040bb098cb2a03554e325496ce8e945899cf5fe9ac318a21403ad5455c3d78527b6443f013c1b68cc7a39f2720b35ea0210edf17f0d952e523b76896ab06008da85c28adf8e2fe1d102385115659a6fa7ee45cf901967538063491c48311f4638e95b613084e554173c209903be4cd51652de1b1ed052de1df5e878ea370f7ff829bda553d95b23f3a3c7b6aec530e1279a7ea560ba5c2172df5781c17f597614ea76bd5298f6d2d0f3d39e961635e2907255d3fca0ad08f8e75674bae2e7bc1c003ebed160de7776e8d2840af477337558cefd3cf6c80ce8f01cd18010b4b94bdfe2865c2421df7d36bfcf84561338b4e4e2d946a192ceb035c1498ff85424f81394a336ff73f7fa5bd3c7d94f5bc73fecd2bdaa61d0047719808922b1d2da9c63fcca8c5da026fa8fa367b69a46e1b7135736e75be90efcacb58e5854a9adf3176af1457fbd11ddd603e435964c06421a162007464880e4b41f4a6b66d85c4fd732d389404dd50146062331a2b1ef1f82564a7eb5041fd23b2dfe1d420aabd2c2bdbd5699db496902b81fba7cb52fe29b4a7472339cfb5bf8a027f23b1027f02a16e7d3381f72b896226568addfc34fbecad11fd7b13d5da89079272d684ee411862fc057695cc63a7a2cdb4f07202f138a5ca11d9d320e53c07f1c1a5eb82daeae9e8c83446b02fdf6caa0eaa15932e13793c305a607f12c81e16fbdca20cbcc1ebece51a5d68060c24e041b59ade360c620b27b489cfbbcc3a6348a034c1c3b740c2bafdd52a13742971f33791db49c52d1d5348450f5bfcdf31cac60cd197ecae589d5c767ca56ebc8ed6573cb41d0fb8a657534edb4e7427dc5e425f421f1077841f0e019be8e7bcfdd16e0ffa127fec2d2e23735210b00d8545fc9570aa0fdab4a00fbc48e2954d1e19d87dfc741b852479b7a6954de5910c71ca4aa1a53e58abd1725e503f89392a0a69c5903303b08f7e7e3556ce7f6851443554f47a526a1737e1ed113f71974521a05a29779b33fa767847df9b995f48466ffa4c6910d1e516520316dba9e175e7a363d2aa1e77f7800361919af418ebce407a32cfd1331f5c37fd5f06a79e513244ad6badf323df09435c0be971325a8fd329de6c0b701fc497eeb382f30bc8db9e608d86d153f96ef31b8979e88aa32275150ce65b1bab9f7ccee0b8a86c9e03f947a804186600990c7eb2ec6051d274fca6b2f83a75618986472eb5772d4f875a4f4adbad5f3ebb4c63389b752e45819498d793aa5d5773aaf30f81577eb8595e751998c010aebd06e1cd632b740995ea21276ce9100a941bc943feb00faec74fedac38f011ac54910815ec5d4978dbb566a183c450d30c211763aa9a2fc9e465b0d8722ffb8a9dff9effe9b77e7955d79258b04de19a4efba36051bd98a5e2b390f43e4bd8b566b20c858c26919a260f217f2cb85631c8994c8d3ec07c5f0c29b01a67cc1638b2fb30072d411acde3ace58d339df9028d8b36666c311d36d32d385d2b9aee70412805605efe61ab822b31b95eeab7c50f905e0b8bd633d3109588fe0d885cd4dc0536a39c2191f2244fc0c66cbd054be6e40382d9ba701138eebd0810ffd4653832234e061b8e88650163e87de4c96e97bb2b430b7087a6b9cd1316617db1010bd605bdca0fea7c5d2c7e602956bc5c179ad0694fc78772543dc33df82db1c25da17d93741cb63e00f3104fc99b9f35fb78f2dfa7d37667fe7984cb1c3dfe767ef82441a97cbaeb54269840c03f75335dfe5d33f19d0faf6cc9dcf2fede4dc83f3fe2981453679c6dabf0b61dd284e9c73f5db8d001d2fb33872cc32b744f6dd5b274472f6c1af3e73a90ad1e760fe2b4180340fe441ceda3862d17902cf455c87ab323b2621b18012de8b156cccdae11d399f296ce6bab587e03f8e1fafc605aae2c916f235df3ef26985fbf3f47829fd8a6816a0226ac5f319edf86fff4681bcb777909708882cb676dc995f1591bcb7739e55c21e5c0f3609b99acd9ecdc4976802081d5aac5555f5f449d5d5f68c214210eb06f1b0d4c5d9eca6860ea66caedfad995e1b5dba7a9d1192578787123557c7ff2d705e24dea87242557aec5ee0caa0f26fc6edd6ca17cede12698f4e54374fecf7a5c3f1bc5cdcdbc235ba0534db7470ce4f059180c8c972fb2a709a06f40738e72fd950f688e02151db7bf5e9caa38b24c8967d4ebe97050e47ffea7448a10947b5998ddada2b7a5d5a55c86fe9a6f91c96e7b3f722fb5eedd2fca12984a4851b5a04c214485bc6b396117345dff90fd155ec16e6d6052b79613942c0ddfd09ca036a39777684e824d657f5cdfc84af30dcca8ecfcc06c282a9b3ccc52fc89078b744f0fc0ec29ef2159c1bcf77ddb9648777bd422a1ae67bc01255036adebf78d599cee35600859db261c16b8f324533ef459b5288e11d74dc483f2dcb4e46d04ff44167e20adfbffc5654d50f8ae498d46282ed3a623ff0ea238fa34fc867a451d620580ca28c0d40ff960e1b20369f9a25634912ab016d27fb6791e95bb3524919cb6dd75c3047b752484863b178e99050f1193e9bdf90f86fe8145b89fc771ccf27ba422c1391461e3bd5a95ad1f5b8564e3ea4c23153dcc0cb58892cbc976d173d50067e6e8d6b0aaff695b6df770f6a6038eba66e28decd8d33be06e3101b68f0bd18c06d428c949c19c072917e48f71fb9be95c94b1d932a3ed66f5db0519793132686d51b08a6126fdded281a11df661e8d0f957117b3beed993fd3d2e0f10919348e15c9b6512aa046cad6cc7ebdb27e466d44fface7a726b1262fb502acdd516c79762006ba4242763a71f0c3b299104f71a3ebe8c422192ad20fc847ca1089b908eaa710eda2b850b9d6e88e929f305f79218d76eda2f1e253543d7e5d8fb0f0edf26a4caa59787a5e9cdf3718f568d8bc203756a17c20a41bc339fff10fa80c5af3d21115ff47ea6961735e4c89112a2b7c4ce87fc8e8c874574ce2cf356df51385ed3171dbb5902ffe2ccb2b6ae86454e156dcb94672cd80b06c86ce2862114c0ec955c7399fc9a70ec8d12771ffe15370063ee16616d8e22a955b4d7cd46fc6b29e8b1a12da3fcc4fb245ea1966373fb3ce2a181d6bb2d4721cd44c4d4b00971ee04de019360b1b0555970cbf942f77476783d89cd32d75000b90e20fff45b128da127791660caf63fb656d5e35539573a7086776ea39d781c171aff20f61278501d2387cf7c248699d5251ceb4f58b6af6229dc017535f93b8e1ea9b27cbd069f25a4be2ee1009cbbff1538228e86e66cb772f71bfd000871593f7a9618f0e0aa223564ffbf28943ca204110f11dcf5d3feb863e1cc5bb2516eb1d4c3ae3ed51af88ee03c0c4a010ba2348d9ba0e9e55c15b7e450648ecd7cd69d5a689f661f07f35ec0d8db5e0e90b2da43dde3326e73692643a63939ecce9bf4b77dc6e8810176dfda1ea99fc23a96193a74758dbe0215c6bb16f654e7fd0618120a82817a6fcb86009354693ea85c7a305c0f44dfdbefa9753851c4b7aa927ae84ed772892c206d96ce2d301d1b5b058360d22e2737fed3bffeb1221829a0c5da4e9df9063c87b5cf50654f713052b42e097cbca80f031d34838d030cae8705013628bc8c41fb9a45c3c730a755ad0f4b6e76da98ae83a5320e7c2259ede0d498cf3e02954e6c10c4be231edd878677dbc95d2b1f738fd66cd92bcd31ed62fa2c36beddb277276f3b18db361e3c9ef6639bb55b523892521e91c65280481c1047848d991b709cb7fdece270a5db9084e7c1676fca2055b83495cd6ac9420fd85337167875a40fef53ea3faab226f3f9f4a21170bb6cea461d296d385020f2f7c56e6de226cfe45d3c1e231b162752b950cc634fcef6f0c32a0491a215b5dee3a2384f804ca242142f6784c843da42746ce4b52833d77312697224277ffde2f5da88bfd24fe58ed5b719c77b2b3e29a079b0efdf2ec50f1e897a83e41a2f045303a62a1b047cf0e9bab87f9623819c83e521736bc0ffd9d9c248de93cb08fb482785106312118da3580b08fa953ec72c9fb83551ddfa4ace762fe18c8cce709b0d1a5033ce67396b2097ad5281f72220b4ea42a201306e14fb4cef78ada4ac94db3ea93947af1dc8f0676009f7c2192671ca891c16808d1e723e68e1689607bd5f73daac0f9927f2c4174690e0487e1c327ca1e155920c76ace7677cc5c6d80fd1b53843683708e2e0ec0ef1db0eca67e71de860c8d99436698249d9c79368c24cce2b550bfc30f8c9e1b73dea7daec833f4f6f2ddcadbbd79962a75fc9960e02c79f4c4fa5023345828b7b41cf83f3646bfa56a2cd3ca63b8e8140cea6007421bcc24701e6e6d98f8f3f31eebefd8505da9b8f2980cabd29ef7c88edb9ded4994cc4cd5dc2b2f80afa3b2156adb31caf27fe1ffddfb4bd378172fe5c786a38a45ca5583c492fbdb40f95ed802b65b64a96f5c3028295faa53c3cccc36411e074c3672dd5c5a416d7600e4aa57c280ccd53c3b767e28652ba291ba0b0fb894f011da5d0f6c1612d93dfc755ffd3bbad4df1c36c3115abd6b9be995db2ac6181b44423dd7eef1d728293ec4248fcb315b364c44e7a70a5ca89e1652cf5c8711c0c785b86be49623e97476fbf50771f8b90e6ca30079851bb04d3516d3b056cf79d063b3477a63489449846f27717efa307e20f5c2ce3ff1a8b7b8e960658ce0e4af968ea3a508e98137ed95b088b6b00573d4e190e2f0a665100f0bb809ff73692e237dd4dc66e2aa38729865b13f76144514f6cf99a31624c8d240a7bf0ac1efb03e934b84ed6926b18544c708aff1800ea5d9d7a060b6b6a804f3d5c3136b4084212ef4f6fed7dd79b62593b3b43917d48c0befebf52b6194220e96830ce20fc9191d516ead6892548fe28d4ffd22f86ae11f22a8d0903e0dbe7409d12c5ee62c573481208e6f5dff33227acaab38d03b66362ecfdd0783e4a9c0047bcd0fabe99eb7166e984e8c721a55262e22d863ce216554fa395a3ddc46c6350549dea90b71b6994624e43a6119a32d28dc96e0b5673189dc27af646e98b01a067b3092205748c2edd60dd75a8a968e81b7c57daca13b7225f13edfb8e5ebd2650d3b061b68a46cfbd118db6796d9e34e1c40f134a6dfce0a29c47b37c1cf23fcbc699cbaeeee221f2796e04ac54532527fcbef6228b4ade74b73d2df7900b6c2147207cc4870db260619ac8d922256e1e9399dc90f8a0603f021aa6deb7e639359add8d04cec2510ebd2ca70908e3c3cc49edece62cea6dd696fee40e2f7617b19432afdc7d506ffca1d49d1d63a8d300e2879945725c154c05d0d627abc55eb13cf268e4cdcc1bb9fac4ba62b6ca263f32e2930f1916f04949e45b8275fedb21157976dc9101e6be0e188e9a575d6a69c6a5041f847649d0922e697b6e83a66b3aba4f9686a32cf7f8d51c1918f036170b1f4a9d3b90d73c137d30e9486752cb6a9114ebd3973829dbb2921a959eae374ebe7da4ecbf6cbbc1a4e63784db1ed9127877d80e5d028ecfa48928f09d5bcfc99c94a62792402ea925db730d77b340e1ec654e3aab2490399b0c6eb6e46373a9764ddbd8ecf9cc0edcc7ad1cffefec73a2e7ffcfc8cc4ea457075632cc4f84067403085a8b0c871e5200af32f2fa0eedd525361104c5f23cfe1521e6d7893f0808a9e02abad34b4cff8c90f9cb9bf46f14639686b368d759d9b1f890eae4af1787ad43a1aa8dbab445029b7f14dcebbc86ba86ee14dede2def1bd00ff206366d378d8f79656e0e71ff8e291d6d9867e8d8351806cdff240a31916412c12ccbaa6cd982be986d3d2628bd6443273e2f6dd4dcfb0a7531d605d6c126402edc56877607d7b333aea90b8be9938370aa5d5f878d00b9965784cf25330cc4554fdb72b52d7de4b297f7fa20d3fe18ba81f8164156f36b5a371a052bef26e8b6312501aea0fb13093529f3720680936cb4de0d1d1c3da695d4ba718c20d035190909e2afdc35b4e1a8dce6464e121598967649426fe6e7609bcc6b037c64612e07458fae9583ce426c2b9483747a539f7dbe8b800886f7e4909f101c3b68dc8ccd353481703fc6e3859c91ade25d0ed3901620538a6d8991439495823606c33438f10a2a70bb2316de29e59aed99ba5b75bad93793cd22a6b4a9ecc303acdd1ed31b25bab300a7242efade16adaf894ba831dc559101f0e21d26e9f565546cfda23c8086288c661670d3653599d7701e29751ed8a2ffbf80b725ab5f635e7ca72825585eae1fa22a28234eb884bcfdd4c3173971a23381acfbb4d6cbabe2dcc23c2d420b595c5b435a7560a2c0fb21e35711c0777ee94d933eb3e5acc21838a696bb71002f59c7f6d348780a720b63e0d66a61c3d89f4e5df901e9db9f5cd083cff1927dbf8567f00292cdeefc4d9c76cb0d6c20d8499353ff7a86ba4300b72bdfa37d71847fc7dbf8cbb2ffd433b70ff8db735508d59fbef12b4e9813102c1174bca251830e85c682692aeef03d37d6d4445fc35f02faff2d147b61740ae86beae2d46166407f95db3f419c5c44713e9f8d3cdd0d97e5d590b275630986e7f515d23df8f56885fe391010594becd8b639b0eaeef77df5519db261ee310cfb826a40c00fd25554d448a8214d7c03a1a4763e1c60746e006a68511513ece9f02d7e030baf7d61eb2cf635f2a9bfe199067f4892e033e4a2e6c8281eca60d18bd44bf694a1f81606268178fda41e560e539c573ebe25d0405cc301be1684bbdf10fa40ed6a131fa733350228339bcfe325c53eef16cba635979a05d6424eafc5d5269ae77e1d8434f85ea596500b6e9ad918888fe8ee26fe6774ca07affc76915d759debfce739d9e4c8ca742c0e19d40678f84075d96baf5c6db92629bf212f7503044ee11daee7783e1f9ce8a58bc0c5cca0d6b7b38c8ee9a0eada0e3c94dd6bcda3dd53bba4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
