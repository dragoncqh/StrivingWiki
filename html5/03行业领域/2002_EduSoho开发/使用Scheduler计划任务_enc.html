<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ecf6fb430d6b6e9d6cf23fbe937d72ba9f35d5c15369e98676250989b788807e6d2784ee6782ea22b161594b4b648ed39028c6e68abaf0b8e607b49a86712a20cc4b9d1ce09e14402d9f16bd01b1e3b95b441c459c5bf7d4804b1350524cbb7880a92493e619c8de2bab8eecdfed69bf6375c5af6fd55a3702e953ada0c91c1eb1eab080b27e918e64b65e055c5d054329d415123ac7ead4d87b751009299f61a092d661fe3569b921398e1a612fd7039af82c6bf72a440543a2d31c76260acde81eaf7d8ad423d8a29ac3db58e87b498cc5672cf9ebed1bf624355621466113484e7bae602da739b6278c45eac397f112e291a5179b0e0c7705a6cba9f0ae36f5b4ed2aa56f53e8c05df2d2925cd48919d612695ce04fa748b09f48a7a1aa8e06bee7f2c088ecbbec0abff6f4509aa704aa90f8e3b359310b8116cb0a6214c7873837ec10f9ae02b4f4d2469c85b97c856a100dabd2ff3b0290266b989830a009dfa4161c3346c414a74dc195c8cdf14ab3331e6b7657b5f571998fa15c2cf44bc1fa85a6e3d204600e82f66d1d7af2a00d9eaa3fe60a1ff5c2f58b9e6d48283541155690bdd5d6bb2481cc16e9f52a8be8a7d904535cb196ff62660f8dcfc23021ad7987120f147473adc92de4094e60114308dceeafc72f9193982b1060d8f358b98cab9f2148b26640555fc23e15bbe725226ed9dac85c7bd7076c0cd216d5492c4468e90212d72f043378c331f00ac59dbcee012fe6bfaaeb114844c909ed9749610e45e23ef9323588f63022456290131899bedd311c16893955f59dd8dad33e8633030c712178c011c6cff0e40386ab11068f3bad7affbd0a187c8876d55b08a22e82157c3c8b7c0e248900d29a832a52080f1750a4d2ad865120018de6ed8a2fde5eca21d27f0db26462edbd0a94a6d4875b4fd479ffaa151c5cdbc727409f85b2739132e5e9945356adf64e9e532fcf376329c1da0c6bdcfbac556467691219271c0592e29f69059a4030fe0dc063454849a2cb5fc0ea98aff4a2e8ccbae651d8472e50c72cb455c8a5dcc1f3115c645b006300e22e4a6303ec45ae6123fc455763b698735827f62dec0f183ef55122a5b19945e6305c12eba3ae01ffdb5e993a2b313992c21465fd92606131365f50c45ca39f5dd8cb9f37f7120eb55fe8c66ab115b315ad2645448764ad784c6e7a8988072303dbcc74558e6443ca95c35fa2b50356e2d6ca0dba36447cdb396a45e927e7fa6df545f289b692ed8f670d8807ec6e87cf4950af6ac9ecb0f2c68fa17f31720657869fa9b337b6eaa9c24e94d94207c0eb63329bc4fe7f15a5f4bd1131485bda7f3c72f03c4797388482203dac259abcc950a877c170f179f01565225c972ba620463415d2f021733eb70083d32a467eadd31af9aea0ba3d6a075ccc50079a1ac7b14abe4aada1ab6c4d2c35619baedf16c4fdb06323147ea98b28edd736e9ff9d487c2a851167c2c7c69a8ca657d96085a0ad2658c09dcf47f326a169f57403509c7ba6147a3b8cac93f1dc2a7ec42d65aa5051e29991bb4c0304c23ec853011ce8190abd7942e7e3045f802121c0ebee02553e670caa4881c208e94fa819935a258cc720c1ea8db5e7727b621245a7c7dc796e65723acfe973f18e8fce2f03739a4dcd9d5cbb0a1c96a646cdc4f1534867b87df7520aa2fd74262868d9c4d06e16dc4192366babf1da7d18518069ab8bea240024ee2fdad085efecc7635de3d89308350f025ca75b23c5cf71a25735f4abf202dba63460a6eb0707ff5582bd49c2ae50baec3780179a8d19c9c6e5eca1cfdf742bbcecc4f595cadad59a1d43edfe947cf9b0b434aa4ba729515f861e0a2f8155c724ff99273664320c3a98da8b8fe0fc200f7e3ca8851cab817320785d4dbaf1b25607a01c10aed7c2006082eba6f1f4ffab8a4edeeffec2d170eb50ecac9b5a867ad4ce1965382dc2fa7f5eb0f2758590493e4f04b68dbb9c400c66f31dd87a343e54eee0f5225ec89265f59b3ed91dcbf38e7d7c72eefe72d0a6de152c19623ed965c6569bcf1b3c8e2a04c3586cb806fe4e4adb07463594f8a1838c0759acd0dd050cf069bd85650568b86b141a424a2658b8caf7f9f77b77de545b4722205a230b0ee27f1020481d69eded106a50a017873eba493103e90abf540b0dd9c5c268e93820b76379f5b3799d32cd68f062ace4eb20f9837a40b06e947cd3d897431fd805c1c6f9439adb87891e53b9c51f76a0b97a2bbe43e0372373ba50cf231cfaea62f085d0c62b41c20458bbbbbe8f3d4cd953fff31ead0ef8be9886893b3dffcb8815f315357719ef33e1572245c80401500b5f8be9afeb7b236c5b0f81caf74a79c4ada3924ec6884a6b758a11ef61cb3cd212115e4a360a8713955a51b9af655a03b1623de4539f97f41e638a4e1d11f52b21e082fb1fc9553eaed86108dd44ddb913b4950f6c6f436073ed493707ab7ae4ad8f540aa830e317b15b8b1732eb7a2bf090ed862f67dcfeba9c52d61be63ea6fb656319295f2c79db4d3cf3c0aadea6da89376d6805038ed9754c9a82b006cbc9ebe9e5628127d6401ee9c4b694e7ad4a123978f4fc2df5fcc72eae8e8b6b4d677e50261e15ef6d15f1ad7e583832df69493562e41b79cb9513701accf4b07daa29b9b9be6d2ccc1a67a90e9f8ae0b6de84851ba78eba57726d561da42d79015dd57c3dcc3ec4cb6ac20b3de86fd37dd6c98ae9912591399afd180d4f21251b4e58362c5249f234a3cf946a035ad0d0c28182a74f6b8ba39fb0f5d5232ced92b5984bdfbbb9bb5bc5c557aacd539d1a97d26e6a317e39beefeaec7ec0cf10f0e8657c92d87a43adebbbcc67d1e3cb8a54c08ccd1fa99e266ecfa9400284f161926dc6ba183676b528027d423b0ca37c757b3b4f6ced0659232af567f7196c817d8e55d2d3ab24a6694311465c2e1c8ded2140a6c8488c73a12bcae4d662a4fb0c3fccb35e8089a4aaf1e818431c86d8246c636b1d073c4f91ee34e61ee34d86267283334c53df498f44909c15eff3262c137aff774730ae6a9b1324303365136d91404d7c9068d2937de16fb9ebf111acfd1fd5a7397fc7f624383b7ed03a6f5b8a0fdf0501de9412e348069cd414548600d083c75a23ee3ac3e61669183199eb9e0ae0097730288e162b53bf3392caeabfab991e6f38f8ada1738b16fc12a91b8b91dea1a6111c5eef10d077924068ece62a9cc97414e1cc920f2309390fe87177c69ac10f881af458e1eaf87560d7bc7b1361694530101056c34141493e148d5beaa67004864a6daa3543249b60ca15967252b9ac2d1debc12baf57b5218ca41b1145f23bce18745c94a44a99fa2a15db82f05701b3f4a307e9ed286bb2d7927e22e780cd2e6ecb7ad6c3a4b53c82e176dd989e93bac5040f1d14ce73e373fe14266d99433c35552f010d407d95fca8d865c3e63d7950585e25d5e03f0d401d9385be6452722689d33e1010aa02ac8e0581a55e750afcd1a44558f9b0a1043bc4ccf6f488af58617e0f4dbf35c60d35cda6d230ad9749a39472a1ba69d184a4ffc47c1d5c62af7c8a77657376977eafc3b88c1f0a868d35755e96ae18c007c6473875cdedf273e9b67d46f35f5d87c9c237abed9f97942bf502bd807294e19e56bf9a58d60fd884465037a6994689fb62efd8b007d64b7948179bebc470d4254de01ad0f122d4e6e8ecb3dbe860a502327668e1dc8d7659164b6d9cba0b36387bd587d5a02a1b473e650551819baeaddb7fea5477ef3ed95a63c5455596beccf82b1d5897e6bf1843830500d562f704c0d7e5c51f000e10037d08b6961e1b6c53448a704cf98692d7b1c8b80dbdc2ebc4fdfb98a60a4fed3dac92bdd171203084bf7939c8fe6e2dabae7c21150fe970bcee63144d2c554de4fc9d1aef1034cd9a82637a2e85f3c57bbd1e31be37e096940aa1399162d3e3c2fc7daabb433b053fffe7c486cb499cb92d85487e77be00ce0d59aca2b2f0f10ffdc5bc10a7a41d3669031657b5cd16340919a055ecbbdf93c130373f2d60408fd1a96ea9f4d36dfe05956896e4d43646eb8c1427008a875450f71e94b0a9617cd9c0bee25471c13bc8bd757259e27c6e8cfabcb866c3c2464addd32b100f03680c06d416c38704d564e8201b8d6b287f028e54bc86ee38c481d2669bb37276f38daebfb751d3713470671c568646df25f345c8a7ff04eef0403d5001c53d3e201d43f1548ff8bcd28c6615c24b692d2e6a29182cd0ac052e4b0faf6a63037edbfbf0184a5be4bc53db54f9ae86278c064e98b625a62fd6d4de0bb44855a947a0ea3b588492442f8f8d19b8138cf25defe492a77ec8d835a437255d0ff5e7aa1a44f453984ed9db8d7e6f637609b6e13215f0c300f527b6117606151d50111a589eaab485f0b22dd675debe6c21a2b063031a20f17a2aed092dde35c21e562e45360eff8f0c2cc93cea76ffd46681d32187e38011695f0342fcdc18ed83dce1fae52a1d4330a1f16e81d53a3dc0ef2183bcddbd27916ac67328d9c6e9739d1453a864fc5b623148472d062d150cfd11a2e05c92978ffcde861fd842006099af1e3c8e1826842f32d0dacae16a27381321d391b19f73a60b5222538add5c180d71442a8c331936cae9a1b6b047523ed1fdf8bf5e1fc04c1e9155fc76d5a558a7b8fe89492759090dd3a3972f01ecb2cd4c550b09926805435a19e5749b3ca85b9c2603b95e5efe182baf44c3c9cd54ba8944ee83e6092c14cf23da1e8cc6a35f8a3dc3c2a310ce947b5a33cb070c02261bf4e5ff93049d2c58794a4f2bc157daa10152bb7e172b61bc7ada5b7290b72486b65ecda71fe8122704e0ce5e60079dddec33e45af67d8614bf410daacbbaa6e913b645849142054a1c945b42dfec36bd08854df7b08dbc29bcce1ac05a6d809b6d8865869f798a4db53c7a8e0a4775fcd81ff10cc85f1e652c2e9913f560967af798863b640166618fc5c4ef2fd28db6e854f006b205445143152456c1e668f0b5e1e5aba6fffdd36ee0801682dad7f9677161a58cfe76e198b6edc048bc62583fbeb5aac8146e8288baa8f278a7919b1f3a0af9d67597a82b62e8109314eb4c581de4664ab43069f433016cf9244952efc415dc4cdfc3e3db5254479e820783f5da33348ae452ebbb111e4b77532532d5e588e7af66a2b84f2bc4d7ea357604df3d087d7f8e13732554e34c965dd02f15a9a35d60c60db885d2f1fef94a09c333a331a657c093a0498e5954695edb93b69282d6f23f1c577235b09b90ecd26fa5835c9c17eb22ab823bf6a2023d7ece5faa88b53a7cad214fc150d856f217155db7a722ef78afb51cc15d1ce9f90f752c52403c34cbf98d08bef2090d7f3fed7e615934433a43ffc4d8073a512573253f7ed703a02f505e5b60171f2d457e27f65aa22d4368c7e64c2068b8ac35ed8ed9b79db7253fc4132193c4c2631451e66bf087ade445e27f296b9fe1b942dc43f655c94c1044f870f64ead4decf9f70a01c068896460a7f261adad7444cdb02a1988dda8f42edab1e307b03b8a7e5fd6e5f7af5396df8cf497e50da8c9ae095a386b32edb38867e22b414df5666c2c3096d4b76c6c05039eb3933fce46ea3f4af19ab2ba1551133ef84e2aff63e45ad078ff75c52e5d4f026da172c9ba24a6bffb9e95d313d5bcebca6ae205ec11af99df060ece1f7804c126bcdf3849e2cbe96d6346c4e8fcea8c906cc11b23e8858822ae195397908f20c053cde2d74677718e8a047094ee38840b4b25d59515f2fdd9dbd1c8e10dfb62492f75ea6c04523f35db6e897cf38522011bd1324f62609d39fa69e5877b86bb2a9da52628e8ff34cc1761f5dc9dc3445ce669cb2b991fe249efbb8b99e5185fefa948693289ec775f663a0ab4274e1247937cf39a7ac5ebb02e7073560df8440220ae7120ab918352f66fa2b87db7768ed60964fabe3eb133a545753db52be78c05e9390506b2607d1df38fdb6705713218aa5225d9d0270db1e853884e7632fea456fb5483ddcef7061dd06d095cc9fb528531dcc80161f03c0f52956039e40961131e13e7f51fb7d4798b53aafc7ddcc7e4c0e5934fdeb70024f952892474dd963691d39b9fb8d5bf9626cb147b6a28f2038ab0b47d6f20ca966e4451b26344393e328d657b890476ae8d2cd077c26a6f45af0bfa818542d2069dfcdbd11737c234567c5b91bb6fb6371f6ac41185339b7552290c99113dcab8acfad0abdef51fc8a9bb631da1d9d3e64b525df942541e863efca052d3b513ac1c3f9a5533123a691a10370aebe3926af5f6607df0e693b1f59089d586ed42168990cd326136d926d0a021f1d47d6df1baf66dfa820e6da46a91ee19bf6ef0fadce0b441162ac53cd43b6c08be1f70397ddc9b502a28951100d6c008244d1a55bcbce3e55d1ecb848d25b9714b6daec11def2269b102dff55c626c2ad2c9596bdd08a91074df6d30fc92c341d9af7e426ad5f4d41e9f61bba304629337105b566a488078343091b1852326238da4f3660e23391a369610cb106eb6a396bb3a7927bd44f175571c2fb5468767f393061458dd4039ba26046ea1c8ad627c03cdac7a3971afec7b00151347208a2f171b672449d662d841036caf00ea0f1a6b07f8d84f4b12c4c83902e4124613fd71a7772e0197297205d41f8e259d6c565bd46f0a61c204cec6702ff020ff86bf261b7ecc6b07753389df9ad958247b147b7e3374f06456a531853e7bb6f81b14fe5fe218cece67c9b5e12d84f3bd040d4a73a2653b3963373e879f36f2e60665bb7e5a4ed01b49a4b4ef6dc7a2e0d1800f86434764ebe4d703b45686de1aa0d49dfb7c415a197a9c266a0e2304927d6d5b8c4046fc35a3020c3952df5d8b3ad5a1f69be8521aac802efa59b20cc5768ece19b45c6b663b505084cd6d0a4d4a0a99f1749c3f92b5f05bce08bba95de4ee3b955443e042feaeed350491166125e40ce6301854b7032076104ea5bb485c86d12c76e052ee84409260ff2da09262f91cd6815d68edb7fc59cb610e1e64eb4fa810126cb0029fa6497459b032cf7c9393d553d0d61c75e26645c5be45fd9656a72c751fb21b41198c6480767f59b9139194257cbeb4fe4b36caa0b3a17063166c225ad4c5eb35308b1b2cbc071c9b190d0bd7acb269e1c5a9326f7119845f4bdb86265e07d96a3558686d998d9a3b66ea342237ac1721d2f60eae415997cb0152793a66aaeb82fd15a4c7219ddf4b5f28c2e595897d839318616e9f211dc245c5b2b305249b95e0eb970ef439c3e66dd905009b550c07bab8947b60f63e5e060fde6afba9523fcd25209bcc10d9dde41f2daf9d9c434c502f78a5e1ebad69cee714dff0afd497a77a90f15809e1d70eee800b2bbeaef1a03e2426095f84f7464c893ee6c37e316c09ed482f00819c04a1a4db30b7eff36bd98fdf789f229181f7dcc9d4fdaaec793c4d36f3b254446505a79a6fcf407a30cf3e0df32a427c7bcf354ed33e2927a2d918b814e21ffcbc5c8417ce117f01660bd9f82fd1434cab20fcfd4230546fc93c061b4ae4989042150429518bfe27525422ba0273293bf08be66db577f64ca1e4084f8bce5a58489773df2dd9b313ecda78dcb7079c9491f2e431b06ee7007977b7b5e53fb639535439934a87190d60f6718fd89ab1bae289ec3c95a011d0e3a02af2c4d3c55e29683ebf48d294ff363a7b2aa87217b46368f582b6ba0c207716c7e4a054213d21c2bc1ca2bf4ee81b718682a5ab936a4440032f89cd97a06003f1c242d77814693b316ad0965765c0bfb251504b708bd6bc5d68aca56df0be354a1b0c93a2f279718dbe76c64695b06bf57f8d9802e4baca747302b913089b702040df992a1a2444e97286a5d229a5828551916aeecc63a35307cf48884f501572269fdd6ca9badb2af9db2811e82e3f74e33bb84382847042ba75dd0b20f24ebd33c6ff01520f5b96a02125b5db02b5368889acd79e5b3b5b3b5b4b9a6c67626c6971258fe36e820d73eb26fd5477ef6f8e1dd25f4f55bd6c9969108b8db982855b71f0e618ebbe1697e5d8fc47c3766a3395778a5d5e39bd33611dd39a908b495712188d7e66abc32fef9c00700c8ab29640b2a0a844550fa1b7fc53fa787207eeaef01627e5730310d0f9f7c6c2d8090d6a2d1418a69a49d388bda67037ab613a1b34b57cd6d1489c078a32cc574250cd3eb42fb7e6d6f76ca667f025e4b25c5ba4ce11ee5f279e6f77c1150e47ccb74335ccbf7496e3ac9ac448ca8a8ab98d73abb6d0dae3fa7c4a2f0e15e04b6eec4d6b2a28febf8dd058717c96208288446743fec5af80637f14890745cdf4a28ebbdac3d92b0209fee1d7f071dc58e486f95663dd70d507c351bc05906263cb277af2a1d367d3b2db86c6843d789ea0124ed47bccbcbf8eecd5d55a537b33b0ac95bcbe91e03d6c9dee8c347e6192a4a0158f7f8f7da0116796b9b473543b0845ae1e494e8fac1d1559a569a34f7060305b983b1b859948808b3a6ed8cd7ae2876f8148f34312d424a35bf0acb5928e2b4c92370837bca9d928ecbdcf63923a5d20063b981f042dcedf6ea5e5479801f38f5834e1a96075c5d22aec8bd0077d722e7c993f956c2e4cb6376918690f71454912d396db59d900d813df5475fea0807496fe06398e1a25b6a09dc9a2725ce8f17e15f59df977ab64198b7d6961135adb4583f40ba942197cbb13982fb68196d19701381f1141ecbd3822bdcbf0c19c39b78b18ee505847c4ae8e4e8a9c93251ed8bee3aa6679dd597fc96e2ca440a1920ac5bb233d5c5af14c9b16a0235c68b5c175e403abcfd50126f471a1e22a07a92da779968e9eb615952ebdb95437e3973e51fa3fa080e9de308bec9311f93008144fdab6c8a6dcd93670958d3dc20fff83c11871dd9e566ef84556f0f19c422f551207c6831bca1b3db8bad6dd9c1c93d2f9f97427fcd7b447eb6d6c96cc47571f707defb2cc28279178f224883e3273f03dec82bc001190656268fe6d56ca1dc7b82c1b9588607083acfb6016a79e80522e5167ad0d5fd119818c2dd43281656a6a6294bdc5c1715642573fe2a8d9635d492aa9f373ce14225c69711533d2562df690b0049c094cbf30de158a172583b6e59f5842c38ab866a8f4ad1f1ed00bc052ad9e95b40f1429f5b41801c5b83b0e1cc846c2188bea268d185a35ef7a415c5dea160496d53eba35b450c6bd4ed7f711c5400c15f43196d48cdc395dedb415add97592f53ef1d8e093e1404552613e9fb82a1f5486cba296ec06a4d59b054013fb8b386d8ad7555a90065cb5862dcc38bd79926d4fcb6e041b0bf79801bcb88cdc2f17f900b818c534562814005a5be89287270714b466e0cf76c2012f25e62347425c3ba9913ab454b0f00eca72e89ecf8e2afaa42a989cb6fed82a59c4bb3bacc015f9154a3b5f27873ea1b9d1ab02af002fb0f25e426a8aafddd12a57386c3fabcfc2b99f7fcfefe2386b56b3b5eb6ea3d791b9a465757672c3bfbba36b8c0e70124e316ab65f0757292170568b42f43a4e621a465921fa9824b71b1954d62a69b58bcc7e952eb39f66ba4faa1d61d6bddb1d3a137d3dac63b905635ec7303f7fd2395ad2f3ade127905a630782c720b12c05f840186fa93018ba8038bf945df10a01e5036dce137096e26fab03a40379fbe9b84faec33a7a1d55d0326047d91530ef4d42eaaf621b21d9c598c51277889cc48b7f1fc46e1c55536e82c3057c10d1bc84b558dac2db6c346c1c11d6a9c875f15a539c177e25da793d5345b6ca78e1383fbc67e1173e15da91a14274a3b917bdbefda747ae5a8a0cb7d49b1eacbbf77f971f8ee4aefc696a9cd5b61e4049cf6f6c68fd7f23b770670affb993f98a610c15dd4465cab8a3939a05b098ca40769767d7d09e22564e84606cdd6a1841656039478410b5d5519a5c499377115effe77ad0b349714534453707e53df51018d26a28bc62f4631bdbdd835cf5a6d535e0e8967dc8f104a4671b452283e7585bc2ce8e50cc82e584ccc31a44d0ec1a9efc097bc67fa7cb9942581e66db1483afdd0faae736cc1cbe8e1ec6cb45a408d97ebb0991f720b639d29eff4dc25c7731fb0ad5f10e235ea0362cba42a177677d4e4de742edfa216486f223928038b7345a21d325dd6bfbcc7e706d4e184d8b901f6c2b5194b37255648dabdd2c7f1b9cc8d594e7a1ae9b1faaa93cafea43c5efd219bc9d758193bef76b6af386f5c8c444c0b68bc1a876d3678c2f4d1523e8689ec4800b47b30c5b8a717d1941b756562657d0af274294d354bd9290be10542118e406678a2ad7b6a05f010230198ef578d373c85c59e7007a8dcefcd35f96e93b6c7cc0b5fc414e5ece151c2041b6ef8377b9d2a87948beb1e981dce8ebbb2b1fbb7aa3d33b00027c7ce3e91e912f8b01e7e36d6b163d733dfd59adc4723cb3c064e18937e617c44eb34814e86ec5200934a93acea20fae1573cee2b6af31e567c7e27f614f6b8ae0ea3ab984ee1217c26f68b70aeb1b8c7b5d813a76b6721c90468a07bd853fba2a613d6d640baa034503f53705f81717daaa3470ab74632285197c183442b438b5e6b01db94f92e6d59630dc2a5c2a60bde523296b7af7f51cc6116cc5320f1555092dd4df3e1c093ada0d412842621da7559996ad7a8f664ada147f766ca6a81bb67b1685cb134ca8c9590aa4cb7f9431b78ac81ff4997eed97f7c2a30270ec07503fca6b5cc13376e023d48fe58c8df448bf0128f726d43a7c5f4647c33387998adbf3c677a68ab11fefab31d69864c99a1e63bab6173f7fee1696e73a060865e7c27ef7f1b5a9be7db96551930b2b1153352590d8034108ec3eb12198b3807a3a328f6dfe2e20b5ca8f4c45c3e2f0a6586f320cfee0a355b38bcc375519d32d36e3f72a58c2473c989f8d1289802f400096af6f15b23db767e02a18000649e654143138b22f0056f34938489847729e3a34d59b89d8aed603a91b295e2e622c1ef34fa513eacb74730f2a23aceaa1b3d85d993542b52ddd439fb760a35ce89071b909f059a43f977135d8e986bdf74f5b4ec734440463f66a986c8d2cedf1f8ac4ee7c86b3de86923e52a3521e8f6cd2f3e1584750098b05fa65dbf2973f4aaad77a22a4a10e59c24f9ebd4c1d4106df121bf67f1380779f2a04b7a25a966834db5eb74b1a7e584647293f2a2fe0c5e9442baac6bc00fbf315fb20df168bdbc13cab84d55ea2b048e41a3d6a3708828979d291424483bed142f719fbf28db724b484df808952cef9d54666ff98a4c1099413980a59da7603f813e878d138440ab3448fa5a30d83ffd9b9d5c57c19ab11441ab4d99036bc8c0f833c705224decf2556034a264f36bf7fb8cb071fcbebe1279b0b7958e085778b6e6de7aea4d6b9bfdf44d41c06f9b1d24527f6a468be2ac764e147f8b8321c8cc348158e6f3af3dfc8b54a6dc700d88041a34d9a862395e68fa24fb7e528d27f160cd99f5668b1a9bc6b9118907bd6b689041d096e51fb07f2e843627c0130382ce5dfdcbfc3652aa6e8f684b2cd333ab5d515759900f9c6f773746f633eb8f772376836808159d8140490a2abbf92038f313f37c693e67d87087d44815226be9c9c497272357e0aa0cb92123396eace452e936eef759e5762698aa2d9c655a3f5d0899a142056cf6bb3bbf236bc240cd3541228a299ac8104a54b67b01b3a66341d06bb2828ce9047ab044341c29a99a89c1082b06a7837b660923c20724f12f1720cd61a25a9791b0138c0163600414d5fa8fcbc9288401d35db8ea62c5eec606a077144b117a1d263f7040f0605daff031484bdec350c0f9a0a55dc616a9c17e15e3cdc1f9d2ed4e9faff77e522d10ec8c10bb17e33fd69b714f7b24be6adf94f7067457cb969859cd00c824d1b702f9f67c1142a421b000e1c6e826c76947492a98fae114adc269324c7f2cee59a440e634fe7b1cd8d9f716b3f86bbbb183b42c2e398fa9c4f64ae6b4583fab6f9b176df9d2696f4150480cf8f17e50c432ee4f098e8acaff0c0a586e1ee305950d2eebb07b8af907163b01868bce466e6bae8f395bcf76f88ce2830a1806825d517334ec46218c5d5ebeaee3cf5684166e003fe48e053e3791f1ce7d684fd303d1a1d4eb4c73461914e8d0017be6ca8d65a6b99d0500181615d07d0bef8af48953d4ddeda343619ac36dd1a98cdf9026a3b1633d731d1257d0e686ecca5f775fbdf96c0a5daae708ed415261248887a49daef61703e02ea51788410700b1cbd01b5da6a5e369bad2ed4298ac64cc12b554fbb00d3f01121d809e3e83e88843effde5212d789eaf63e6191da37187befada2ba4f26f1516239d2af347658d73da2b696655c6d6e8c58fe07efed4d28049278cacaf4713096351afd15a13f30a880b1504e8907a7d31098dc8bb2241f8a9a06a1a4faed42eaaabcfcffcee6818413c62f19fb326c0a6a60aaf84f0e1111ebfb87bfd61207a0d6ff4eaa1963e92a5f425a3c79e945389898a97fc8c07c92e481155a18ab3695c8dce4c4125fdc3831c6bad473bcc788bf067803cef5b3282e5a8e6f8d88a3b4d7a915b9fa6f40bff588b403aa917a02a36c9b2540d8b4c15ab6a64c23279a1734d137978aaf351ef76e92009bcc5395e041e00f31debe539343ed2fd99a5199761e3fc38a241322a76a0aa82f3e26ff715e72fe1c06458eadce924100051593562ba01e96bfb82a7e05ba6a18218bc9e424f84355d89d26590e32ae58f21784140cf96fd913a81fa1ca860c8119dd4e18aabacf6c34ad6bcb9c89c93a38481d0ae765a01252ccb9acd6432a530209b21a2f77098f26f862e9fb43c57ed3e9365eb66595275a4945bb6413e321a3398f360fb2f04fa92ce851d1f59cc55bece368f5984b029335303b154da59f12032d6c976dc4aaaca3fcd52a28d4d10fe494cfe084c9a0cd52a1ed1d6e3c32c0c25a63a35d13a59043be137b243cbf9d6e57ea07533bb8ebe6f1b62ab91697c2a38756d66ca2a408ba9481f848e83d76d50799d8746e633e173d6de21b427375d373fdbf61289c7b9881ff7a15c8069140f8cbacfdfa060071d9e8f00b769622c9a4ca71baf0bc08201ffa6469f0a0a4ed025bc20bb92cc93e63e14ad886a38e2c8ee3e4602b3fbfb9bdd7b105422f42c2c8952658c25d1e4ebff7e3ba14bc9c5a1c6ca28e5741e82e5b60bec9056b718151116df85a63a4ed2853b1a199fb271aa9d84ffacf3eb7783a281920e938f6e61c61857842cf7f1eb1040fd4fe834e69548ff4051cf7be408959f710af53a62fc1fd71ea66c436bca5b8bcc351e5aae9d7b4a503b4f2cb0966f02823c35b9705502337ba8d3d898b20591b646c38a1f028eeadb4625f74aac249895f6ee3be712649b3fd35a1c7a15590d84368e211facffb4eba703f7f07492707f3600f899e0adb5a97455b0e1bbb1293915b298f7a84742441936269135fb111542bc17f808f8188f13fc033d7f25e5575095ffdb0bea3bdd37e64fa4e0ce61eab6f151692a0a69768be8e5f5b569fa8b5bfe9a6d910eb13b6adabe5f56f5aaeccef3be396c3b4cd4814cd587d8efaf1ee6a881c32f70f8f03b3e994f0e2336f4955df2ed3cb52be8f52bbeec5df3bcdc27315907919d0deb9f8558372d0c93698eaa39dc2befa3f51b60d0dff8ccf72d6877f43522c9a57f014e72c6b5dab0d41dce6b212bda1cd31e426ce18919fd62f8429a3d81c530c074c2d73426dd6f7a4335d8ff38a0da515580cea8a6ca1887160cf8f2a46cc62435136c4e4c4a259b9baa57c4a6a4dc328e8ac4a5bc92db602319ff0778fcfaba81e1bcec238661b528f190966e1dfb84d23dbee92fdbee0bdeceabf23f8b5bae2127946547c4a9328a5c8803c6f92de77d5c0eb1e0bd645a8f6a627ba75128f8f6bce48ebd04e852a633236e6ecd4da64eb4bf721bf558a8d96560c736aaa05a4d7c2603158d5cc1b80e2b783fbc3fb1b7b042a5d984c458b204e467cba380f6b500d04f9b362e0d456162f6c84184ccd328ca37e35473203b0e054f4dcc0c4b5408d8e56771ac67538dc080e770b02e76d62441c6606477a2879eaa0f730de3728bda049a0614a11e78a19b1dab12382cf4eb10f51388268e7832a8246be6bd98c96e7d86a1b72cffb7c171f4d725d35853baea458162cea2f020b8de0a63a142cd333916d53a51dee554ad2fa0afdff316ae7bd737358a7246290ce4e6dabd7b56720a187a638acb3d5b9f8dc1bbef047f9bf4136d4ae43d9479817b350e654f594a3d4b31be98dc99f8d4ff717c68fccee0a4b8313bd1deb55c91c1139408fb46a938cc1645a2a12a3229f278e7c1c8b603ecc3b1f7324c21e2205a626f4e39a6e2e744139120f07102b5e0c5f4641a54ea8cff9e1e694d2ccd74b702160b212903d344e3df3e42df0e96550f147dc81eb69a38a2dc08267d460b8e59866b652ad5a30e014d1c50aa3c65464b8bf227b3d96567307e74169135e7a2e58a78c8895121761065af1ee67e60abc3a44a37cb58ed417aad23eb6c31a6f9aa6c87d635ab892726887c2296e9f98365da270ab97cc7602cb0a77a3eaccf295e400f98f364b809efe1fcfe679b0624ae1267a5e222a6995afa38ac515a8b7a07373c53c248ca69c5a79907eab83a9dc6141359bb7328e3d6a840aa7416fd3a315d67fda1858bf6648d2ccea6d6f674bb2c4ba78bfbe5724be78fa794c9ecb2963fcc29a8753f39aa84863d06f0ac4d7819b01a37ce5386e25bbf57d19e2a710783eea483f5eadbf4492185b40a95a6da49d5dd1d814db606aa1ea197e3b78721ff0f26283b22d95817924d1919892839a5b6b591b8cb00137c32d355fe315e1971569ca9a190ff84ef329b1a0047f5a43de5416b90e531cfe1e7e5cb302786e3c1e734319f2b232fa096acdf9b985fa5a54626be83b18fa33d8d8036dbc03a2bd96b2b8be9574a8ea32a54372ba24d62522a6988a1516c06428d2b8e0afa196cc7f53428a36e3dab991031f58a7eb22ffa248734c1930d767e85a30708409acaedd1b4cac71b253909e222b59f4d110901ca8ce234791a47bebe82e46cef9fa840fb698d698b3998e79de2f649b69b343fd5de2380f33f2ea56c376056953bf65c4d64de0ccde20df9024e1ac1ed80bfab919a155836eda6452d470aff7afd1923e20c18d18c133bb243b87b4a516c3e898af0d53236e5064fb86bcd8342655b3a3d832f7312c23104bde0253f0ae641154a7b0802470cf4ba3e988f64a68f1a9b421444186ca61a7e0243c69983f18fb247629caf0b5d108bbf5e0b7848bf5e3e36199a13a5c8b36e7c83b5b0786c470524c95ee3851c333185c401c7cb20f4854d89c03f2d4c5aadc06922a328dab04a8cdd33b0b1d28455b5f28337bac63851adacf623ee17c2a95b2b88bdff87615754f818a009b482efaef11b14f25cf0322b5485d6fe8fc2f0457b3513b6a336b5637a117fb12211494bb033d46c410a6d1f8dd9c52038de9a4995293f48d1e73daa1a653793bbe38f427ccc5071fe250ea80e94498494beaa33e5d52c5c368639e4214db48572239480f83f935de2b601b87a81e84b39b413d2dad2b4d725e719ad3ea2dc91912032a67ab27c056bf7062061e14acf71c4836b08cc21c100659d6b6d3fc404d62bd6582f01742a2aea2915505a2dcb2aed707593ac1cf3a4767250833df93b70d5e656c70b8b9ff150cb10e5164e638c7f1b8740a54be1590282b0bfdfe2bdc2c19ff83b31f0f15c6429ed90f0d3cafad3cd5742a6556e3c48a0f77e061b154c596a84cc9d1be49292f7d4ad6c578c48134fb8487eefccdbb4837b624732b3b2f05e3532db9211667658bfd4bb77072b59f2dfec94a44848d8f9a79f5896f7c2fb7b98a3fb23ededc863a32c3e4801689e335dacea0769013687a0f78954761f58f294fa90def3ab94910df72a2bbe8515b8610eeac8180fe1fa620a6c9d356fd7a4d786fea9f15b3a87abbba42439d9bd57bb0459de504a38215c99fb96b8b4981903f0c3a180f0989e722b1b394e7aebe83938f5582a038ff530518a7174847c21b00fd52eafd8f0091c4487afc290cc3fff0d2a1d1e5dc77ae1a30891fef9dbc4b555f913361681f2071f1d8c91f014938770d6fe129ad4fd9d4490cbfc1ed13ccd5715d16fef36e054f615f5adefd5bf0f1a693439ca399cd9bdc0edad3a953d8acaf07b3baaa968f2281b2ada824022b793a8c307a5f5143cfef3a65750d52db18b9eaf858864978dcc6da6bf994868cc31a60e0959fcebee0150a8939dff0bd59ae16240056330645e07b5cc3d6de47170f718c7b75395d250f956b62efbe16568","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
