<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2eb586d3c4a54afd05d3e688cd6dc479631d30f5a15fe5765ad61a771cc173f5795c18b112a741f286490d6cd178fc8a51a7d400614de6b8bf588c79ea02a3bbca879c9e2d25221ca3c061d013f5d62bd35c0ecd94866146c8231e4078a6e3646ee4acff0824b0b120f6a05d255fdaa8abc524637fc6edac4f42066c060b8c1e59ea0f3e592238395c9165dc208bbf2b38036e8ecda7ce64fafe56abf7074c874464dbcf1e4cfc2c01fd1bc4240b454cf153c5e16943506b2cdb42f18c84abef853c048c9fdc19dcac46a4f23e7c28799230ac47b84194213487e5cde6591e47f04cc70100057a70901406553a1e9d55c9852980191474c39829f598463bbd7d9fd9861e1635c97a80d172b4802c269dabe3355451618ea842c1d8257912ed57f4bebcc6d8966a4cc0d1272d7368ea5574ca1991fea2399b6538e1d36256007096d0b130608deabb5d84941e31d66e2fc535e16a0981ec7e4746a855f71339a95f2ca70cb3196e7d50de21a7b5c0b8f31d3fe1b6084e42b846dbddea4d94a615cf8fff701d326f9e63c5555f0984a1acecbc9fe605cc4704a2b0e794465021ee056898e53e41a87f4156d7fc31b13db29dd5a441cc963c3fd1320c3ac067fa4279401ccddec3039c3077230641b3bad710455ace791d6d2d66822ed3a457ac23c5024553c297925cd61ae40b0026e4968fca822a20c582038a685db8f54dc346cb4fc3be4f5f42d4600b93aca7033a6abd75c1eb61ccb185e4933cca6661e1c34727caca2eb74d8a699789529703c1ad318b6c92d138ad5db8f1ef16e78428c1ea34c5eb6c86eb3f6b4800b47d89c6a4817372ca3e4b1cd83d3033c56da352091a08fb4883288cde1d312aa93b8255acfba152ffbece45ce70a41bf54a1e44c8f99e65e2295a944e6c6e6761b69a362f7da75d51c639616c75eb362ad9d6b15b7a779bfd8bfe49c1fb3856cfd175936202f04347a61068b86a5d1025259e0d63c212a7c705c08df0874390979d258470fbb7fe33c21f83e3d38935ea58744d61422c91f19816ed177792a6d1fbadf21936ec8528a2ef3fcf8918a2edc1787fa69edb6b19ce2297cd5a5eaab6d33c3198855b24bfba9c1cd77e4e44c80e136cdd184caf123da040c27fedc2258214e4e9b7f8ee1a402e18181d1a101a00d54f6c2c3072bf14c14c8696f5415e0189a6728dfd7325dbd8171d5a395b8217802562ddacddbb0af33040644a8077384304d32cceec74ab01ef654a94c22435c13e66a855a1a182cf903fb75dcc322ce551635d5168d570527f14aa854d5d5473bd5a40703f026d99b01be7e2005a92f5d80cf484a1c1988738737960f3369e5ffb1869e923bb5e94c1debcbc34f2e62cd172b771003c25ee37807d0a80cb114445983e8c112bc0baf3a84c46f23d7f5dab40ea3463092d8add9d0e63d5e943f89dbfbbcae5769a85c24eedd2e244e5ba431e357fb541b7289a9ea40891ea0ad9e471e2c5c71f0a254a2d2c62b8fbde66e670b305e2588193a7604600ce3736e420384ad5082d3b3b65b597ff9e7ae7b5c4a8911d8bfefcd9d33c85b03132dd57ab8ddd272180b0f6c6cb9455a2297ab0816e86e2053da0216a96b529d2ba23817e530fcc306bdf0a747d94d917a54f801ac2bbb2d26ec5fceecf719fb0c105d819925c9c0ea3fc48e65a1b96d2242466078defa943b6f706586b5dd356c9867879bc2373e75fce2711519f535299a613bb96c0299f6003792c8cdc7d29ce4483f606c5afbf0efc0a71f90d63af273519dec971803ebf39122310a18ae153397f780fbfbaae87bbf90d593ee29b5fc00e65ca7b25cae640df9d0bc0ec29f517f89a226c84c1fb99fabf6caf4f03cd178d1b695ad2643af5f9af616903d709e356334ef249150b600f911b1c16271b34e17d01f4c465dd17998a24c46659ecdf6c27c3641696e88cc0c978f3ee9fd1827e2f7970e2f5a61e6d1b2cb2b758289a12d4ada96820179c8db02e43db6d904ab913a3a25bff25b8a0beab8c885117c94266a223ac3e2cc62e65778c13c1f2684014feff64049570e5ca26125edb4edd3e9b38cbf7616dde0c06e4e3cc99f74a8575e289362eae659563c3e0ceb50d03dd64210d386c3209a59ddc4784ae61035a497d707dbc4b847b6bcb58d18b481350452b02a545c5c705301847d0082f40441153620ffaf88fce67f514771be73b07b8fe4a498dd20c8ae7bc3ec8338817105921e33ea5cc9d3a228a409463a73a8910284e035b02b3dcee0855e18abcbec80e77d087d8360c9c0cb4275a262555b4dffb5c0cd689a344eef24eaeb3d829804202846bd4fe000afcfe40a2c0bf8088fa860a6a47df711ec9bc53ad43817237c486d5a8103da440795be9591ea5882f7f4d59dc978a45b283e7728e6f3ec562378408b657b45f578c575bdb32a1554921a8c2cc88963e5fee4771b6c2ad0c516e9f145c302f15bb666ab9517e605c464d88bf9998f297beb010bfd6b4f8204fea7d1ddd3d3ed285a8ba710a1f29099b6f95fb6f1d048006450ad19d692aa94d2d8a82b9a2df32a79cf8f6fa005acbc0f6d0a93e36fa4cf8e250cb89f2fbd76402431ac567700f184f8b8282cbbf560d9d8142eaaa4bbdbffbf7bccb8fe3a645f4f829eeaf1803952314f064ec306882a9aa5a032cbb9ff467791b44086178cb657396a03afb155ded0457cea60df2235e324b2329246fc04af01413651c14f5717c93b05585d171a7cd7c244dcb4bafa0d2e9cb01d8f13fd436c194841a50cfe5b32849c1f17d2f9e362ed0eb191b76a12d6ec9a21cdc17dccf00bca88be663825c9d49cae4064ef337a503df951c2af380e008eefb1604ba8b3d7755d42af2c753bd0e9b916af3f40db5d3c4b77541f16b69b6c34b0bd48e01edf6342cab38099c53403b5da07df9d10263d5d818dd85de70b4913de660e2fa20f8bcf82134e7353bce09671f3a1c70399309c4c925fdcbadfdc8d959137a84610b0cb984dde7d87164a938af97a893d7f5c2767efb9ebdcfba7c77b64e2d0bb14f59d9c1f7400b292099234852f7032a0f682d6a2f1981e9676fd4f43d891e39469d6756864e081b76378a0c6423801d2658a8e9f3f76d6dd28ee18f98e2e43e6770a9a55700812f49527e9d60dfd871c125a760b26985f6682fbfc7ab20f7cbbc48379cca42152344b66cd0d3e6be4a7f6668c13889888148cf365fbc750fc3101dff967e95ea48763131b29d23f0bfd8056e3081067bf5693b02faf7b0fc8cd8cf185ab8b6d607b7f09609894adb5b0c60ad7fe0d9ca3868b7eb94405723a996e9eeb783b482889442a75430bc1b772fe320c55e51df60c4efd7f4459ca2af9d92f7cfb823cd590c4b9298b5177becc8dfc9961071b229e3287249137ae5f70ee9cf3f9362eaefe41423148b74f068e004643388f20a799b9e1de2057296a9022f821651e44892255d4c5b1393ca1ca7951a603ae8e705c6ac0d1777ed6f5033b509dc5d0de14f93800fbafeff2e16a47af63f4b1ab8820dd3f6b9f1340c9ed1c3f5c9e622b7b341b6f5690d9bf83b953f82bcd8e3d7f26f320f64b0f997b6f8c6b30135bea08f048ca5b50b5a4592afc9ee139a6a0e010f1cc61b8ea0159ace55e893adf2db7141904b1402dda49784369bd40cb30907a1478415d20087e2b72d18819a17ab6181d5fdb40b188a350eae9ab1852ef88048f5e44eb4400da981b853a31e983f4b879a7aee0262c1cabeefb9a0bae34bf056ab65f87f658f8272362fbb97166707267c7c0a613310ea931fc8f48693dd42f68b62cf9a7ca55cc1010c0e4bb26d50e1996a33dc38bd77653e90789194a7d0f51ac0bfd374b143239bc2bbfe8e08e3e7ec107159fde6c4eb6ded5aa1b515d617ec576da46587871ebeb2dc171744b00ae51ef7cc894ba60d338bcadae44c8bbb56b225ec452548565fc800d6afefc265f9c93d9585546f315f22db0a6328297853883ee26f2d39bdb43281c7f1ed2efe0f975ccefbb6a0faa672ba273857eb2dd5c48860163908379ac054b8206a44c627a9a76220c14a8be0419c1f38f8146031123bcaf04332fa137eb7fafec59f1a1b7b0c2e243cfb229f4438f84595ac1686974d329eef5959d8be65aa95485e078c9bfcc56c86e63a82c74e2a2b921c95d047d4f7417a2241476fadd1af958a879bfa32fe05759cfb8c33f88df64472f99335dd0f8d607bd5b8e3d355cf5c8a1247f7d4d057e095d55f04c7876b0e0173a91dd758962fd646ce7bcb05e67205dc6342474a6298c0543d09c6f3b1ceb00345ea5c8684b0dde8749dd704cb79d2afdf5b310c538d743babe77d99a18d62cd34086f64084ab7d9862e0149525913ff6356f2d4929ae50c12bd62eee53b26ec41e1b244d7e85863d438411eaded46ba1f8afb914934a35dbead032557b4e708627786c091a9bb7c2e0e18e4dc6b77f30d0a5d61a1ebcc2aa0c22ee596613ba42125b5b9b07e157acc615e7d1f2ba8a852337db726a34c04e4981f893d5e5a2bb35bd45217b2f70332482733e6803531f8a7f6713cb645c1cb2646b1dea4f471d3157ac1da1c2ec8cccf82770d492ce78323f59136a34659ccd1462c834e2ddef4945f4808b59d53cbcb2e0408b1f2b1b8a6ddf44e1322e3ac343993323cc2a438b1cf94ff200629f3af1bd76cf1fac03b9f91cd89aed4d67d89fdee854ddc66136cb216d422a5626fca1bc4aea668ba3e67f00620e36160248456f91eef5482804fe6dfe81003b645475ce09d64104ea411aa9c600fd71cc5845c95ed6ac5bb6a17ec39793ff06b5b7bb22f3e75fb2150913fa181db6b27e3f96367a697f29d58abea42add9384c9fdb1cbf5c2ad2926847a6092e97cb67331714b84f05c66ae73d268d45a7309ecf05175770f2e394196dc203525559502e055f09081290da360a74af4fcc5dfc8f42518e02711f565d6923f4e52e135c644dde101428e354c8965e3531a1e161d36a1ee32057cb00dc8976c0a306424abae5157b37f13b97ea6c14a7b1f28f72c2636d619836abc8a763a658b37c19979811609510ae807adf3951a95363bd18d87438b1cfce5d90ce8c776c76d5a29699f61423eaa25a2e70e6ab8dfa0ec257a67b4f850c861e57efce5b3015dcbe5d9ba935ecf5fa938b261f1137d40a2837666983660e80dacf0016054b6a3173870f9f303e974d4a33223d48fbd77ccc110845e1d207bea3842c894b13a878537a452774325959d2f44961cac2f2fe415ae99822960452ee562e965ec3be18828d2c91679e8a9aa10821f27f08dfecf5efc78ba99382b000090d85dfcc427ba3144697d17c9df80133072a0112d26cd5bfc7b5a1333db6029104c4e96acc86903ea471ad2e3bbb4ce81509eb067b2ac7665c48aec94c6f1eaf322948346e07a6b7c71d9d752860a619156d5fc3ec2f58203d4fd3f715281300c683b7a8a0eb2960addc3a36bd2a29db2eac8af336f571ede517fe91c209856200ed648a200ee2701b4c593c690238b75f40b99845a14782fe51a552059b2e706a8ba40ae7769a3cf7ed2eb565dc2947c2f0f2479132aca630713f2a38102ebf1dc3478a4a6912d2a141595800821ae700cb0e007ba2db74a2c0e8eb4f4ca1391b27037c50365a82fd17119faaaef42633d9db24c88d3c79fb7f243c3f4fce8e040d6ca8cfff3e1fd6314e16e8b54e6ed3af48533c9d17523c51248a40d76298a73b25eb8a9e53550c0fa53a8bce86618041e776d5159999943f69136e4a8b7d85f98cc7b96188e5d56bea041c0bbcff79bd4ec39d7859713e965a1c5310c43103aaeb494ef21f344348e642ef37bab09ecbcd156c5315718ce7eabdd20c8cb5ba8dcb6f44c4a23905fc0520b3ad0d67174b7468f5701497c9c3bccc800e0ee05cf258dc6612426e4a451acfa619722bbeab7ad6d8477de9a1a1d5b8d7993e1db7cbe9faf8d7db74bd711e06fc8f2adc70eb464f84e7484bffefce920c8e5ff2a800a7de7b7a9efb07fa0be0192554fa483d7d1f0b11cf24a1e01d087972ac9a4fe8c96d073c4a25f911680f1ba4defa367417c372a7c1e3f1fda5c6cffe1f4ecb7e3672eacee3aa7cc3821081d6105ecab23d480e9ebd8ded82419b35120364164c9a4de41145f1ed3dc4a4fa3e5ec345985ee4fbf7febed9557aa9f64a97da600ffbd8eeae3f28e442e6fc246a9560e0e1aa86e7879c4241a75746e1b79fa856b2174bfe09769c1964e427becd736dd9110f0bf6cfaecd14f11720bfc0775f642947dd99a31d7b0bcbf88808098deb195536cb3c86bba1b06e0787fe8727b32357b045d0336fc4aa11c973ad72d98e19bb8973fa865145eea08dfc46593c329b170789ccc901d110c132fad1dfc22ad1baa51e36ef65892900cf62e0e1228fce3fee895a1103d58378aedd6eac86334f27c87c56412d103ff9542ee841b62a47bbc1cb9cf79941dc663846a599ca5f96eb22753201caba598f8fd2f169f16c8cf5abfaf4e2d7ff088896d0b2675625be3d3dd08fafbd99f2716f9e4bba93781e0fc55d7982defabfd6554ca560b72591f7c4da3a0c9506a203a7e47385abe3dd9a68831814f513160b5c4892057d0a1d99a096fcbdb85782fa6abe72897465acbff25c5aebf8fcc00faa60a3b21214704a006b48874c80cf11502874f32bd6628afaa2208ea532b781f79699e83a808fe3751a5e74bc32344129054d0684b7cd6f4aec1dfeb76bb077c42ea3d72bd8c9775a473ab274fa94f435785c1fd79079db4b8bfff37da954de1f8a06e0436539f3975e9bc1bbdd767277d7517c5c71b77ec3c0e9b5f81402fab7ace310c69e006cbf0ad4cf09cd7f5769b7eebba0cc49889fe83f52f7cdf1fa59e96bc75e045d7f62d5f3e6e728751c115212c6e42dcb6ad5be7f5f5293be2d7ee09eae8781035186bc29423e9db458a2c583d8a771899ede98d65c76deef026dd8e504081636e010b6dd1c4089f730a9334d2bdc6f184927ae26c6374ee494d4fe8bf22cd31276d67d9a46722b82f359e662be074805e38e1ea4039645311871359e929ba6a7a42a988efd1743191a6fccb7ff47eac385188e4233d16fb8f9f73b620e3fb25978d94aa5a9656ab391921bb7b37267decabfe8cf1c5f17cfa0cd20e9ce298e2ebc58322135888419f2c18ce4282d801679369c5a35d7bc791e11db820d086898abb2335f7beeac6f5fc4e458c4562c75543604824dff572b2352b731784a496b6c06e6f85cbfa179a3752bc89b3250993b9b7973c9688cf60813a0015b93afe4a4b78c8edb07ff40bb46266b37493890a75694c22289356839a91d9d3c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
