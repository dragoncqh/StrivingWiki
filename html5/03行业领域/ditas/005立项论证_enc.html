<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8e83b1018d09474a46a4a00f085125b78b92a4b6a66d33b19936d7921c7f4b4872debff2229cd5ab110753a4ce5ce91ff65536c5156e80f069c4c73a1e0b6fb26b3a61512e7ff4d484b1ba8ed49b9e4f02ef5848be5af2e76a0fce59e1ae08c435a112316261bbdff582fc6c35d3a8c20dfaeb5ee1f872e2c8bbf7b8764b7c62257c75e8e3c8dfebfcbb4fe0727e0e99260b8252b429b8bfaba566f612b624fcafba5d8d7de7c4119eab8c2aed3fa4827aa474e4ad22c706bdbe92dc93491ca1f2d7be7d77479e8568019008f4a1ccf379f8be21e96a66e2cd441d337a46df47f42d536f5f0dc3f99d34ea892771ec84fa5c50fa502d057075ad0cb869a37446418920753d58fa4ccf2549f37b515d0ad07529a25807214d054e810391837d67953f134a8bf583c494b4239069a5684536196a26a240951ab6e2e5f00a482b47927d2e9390b81eef1eab1e5cd824af69bf548b218aa559ec1f640ea353226ef3fbec336a5ca058008764f682f6801c1d420d946d947698bfbb437d946f8bff416a0815b31473f267da2d514224bcf604664bc4696a2dd5009e9164af0e9281ccbd2342877c45f42bb57f9232e6fbced56744ede9afecc6bdc9cb90a70cc96d0b5158519a38b7244d08a5ae3b7cbfc00aca745eb8d55c37a873967848f85e400c421ac5eb94a577e6526684ee5c0c83cbf8e44908367aa3413e371ceb505d6e63711bd16715712882ccde25db50641eb44e791db1e76da3f12bb1e649ae6603f23d4701cd1192bbf544d25560e0cf731d24c5ff5380c0a8292b28c6766dcb45833089d88d5476672031efb470717372f7946a58bd9ba4c5e1f05266b2abf4d5767e37ab32d450a86da7066e8e1c03a7dbdbbe104094909f6ce4cc06141379d9d0a1de17549cf31a2fe3be3f7f30c0712242ca2eea8748826a239887812d92245c7728809bdf585dbd2f7780553604e29caf18753027558e4ace4103932324d3759b53238a315d8e37c63597fc7ddf3c1034cabc563215e6da7d861b0e89850d537392a9a54ea2eeaca145387a45a9a0ea04bed90cf91438a5e68be5506c1ab44ea5e5b057a831c87d74c927ac5167cab33347b524cff50b6ddac620c57c7f029daab2f1cc0d54b002be2e4f93a47bf78bd9bf5975aaf6e169fae888d77215e0f56e723936286f971507d49d0fac50df70590d0842fef781976f839df1c223162c431761a48e84f1405309658eb91907d8d6e0b796db7b1fa1caa892b6b3acbdc9f740b22ce6023bc199d18180b4003a99e1ff414463292e304c405d9bb98fc61cbbae4b7c88fdd64c1609a2b8cfe50eeebc61b9b2a094e43d96dc3d8e8a452637d95206bc30730699f01f16c1809fce8bf1fd6f8a3803a822db05554621a715b3dc58aff20350cf7e9d2d928014193e8614772b050c37ec932e3688963be4a39a682be2e091a93b5d3d6ea25b0560f4f8f4b4402204911d0e086054bf29db01bb3445f61d70a8f9308def34258df14790426a4d4ec2f8ef7ab410354af7da88815699534dca03e3137d1af93e7f3d8b8a7b68ddd7aab252aa117d25ba49dc4599b0e099951e3288ac4fc1b2fbd13691cc65648e9aa6b8c14fd49b16e3816f6e16a18723ab387483269f2684f6b54077c13e74c8713fc049659e76f09e03da3f0ddcaf8af2ce5cd48e33be9004a1cafbf133a92d2a54c0a1ef2a0b7c63916ce516039e4e2d23ea33b81bda0ed801b674015e9e8d1c5174a4a87c83dfd14f0bd504eaebba06ef594e8f0cffce55a51c89f46abf9ccbeb78f3d56ab6776f907c9e677cd25eee0b60dd846d10fdbf0f9c9daf69103e70bc37167083d98df09c7d9eb62104b39d221a12275e30370294854fb414282e0a49b0907076f25c8399d0ffec37a9f808f16657b6b4dfed14f1251753d88689d3973589abf928f0228fa86c741736ea390fe898da80d7a2633786cdb75ac8f36689578f767197d8910b21cabffe4b8711d21cc4452de932ec39cec2ff886d07b8754c78394f18c505a1c513968033d41bbfcf34aeb20603e355807e566ccb558b6ff500fcfa04d00c57a9509cd6eb09a870c1498860d747eb8a3ed13eae2327527736a4743d873c50c6ac9be762be4c43931acaaa581bf501b6988a2b88da470d638c039f1f6f1c8819e251a5e91a26aecef92ae4a3296c98e2aa2f67674089109a9632d1cacbd19e0dfb30be1cea9a63c397c7879176d6432909d167d124bfd4ba43236c3c517ae5fe4b7bbfe084a0310b96e250fab446c72fb22b2912edc4629fd3af1dd97cf4e5d8abe2ff4056102940961b2a44e9fcee9181433198393e18d481323a3c2506138d27cc83bbfc681d0623ebd797457ec7b53c4333f90f33037cfdd4f4b131e705f1795545ca3f4c70e0a48e94a5835e442578b3d50415093ba16e0e23d550ec60b6ec6ede81657133389f1de02e074bc2cd745314cec5b65b58f105900412b2a01fe93804dfe847fff1547b05b616468b36bd99fcd341813771c2a4e858e29e301338ca7e5f75b7a5529e429b0ae477f0547a5560075d6cc3b3c9e876436af891380858e2da0b0677cd1079049a6984c033d6ec9e29dedb1235eb26af0a7ae1c09765cd75ac329642fb7b78da3f896d21e67adf6b8b0bf23e3e6038566d0554295d756f94ec75c6037ab5befc681228951ac0161a16546ab7a79256e8557ebe9c87342a475dcd069b311b8686b995aac2405790799de3917b6292ce731400bf7b9e051e991cb9723a335c28b9e9c54ba32d84e42310de9752dca7231348b019c8b79214fc0653383f0634d8f0d123745ac4959658f724133698427e33af64d37a3208f809422d9cb17de0ba1fc11428bafc37d981cef2b52d3bab9bbd5ff66a5c927b3405812f9bec9b8a10362fcf7f64c2da471ccf3b5d5ac666c9de31f65468f1bfc96cdbeb259308a85e3d05ceb7a7b8c89d6139412940f5a91d4de838ddc25b259d7205db8780f5c9c1d7fa5a2c7e9a4154385c0e57d2ee38d85e939a3a1c99d6492f083b07ad8700ad36817e26ddf107994a017b42f5ced97d56644c3cc8f969e76dc652386bc5f5824cfcd074ea902e130c2a34c1d7a8b7700e264129448905031c2fb1cfe5b3893541d2a21156707dd31dccbab482132c385fcb2c4fa82bb291612c42fc97deb1cd71ea17f5afbef52b676ce37267398fad5026f89104e5a605a0564a829b96847cb2c3efde46d991cdcbff79555ac7e661b54f662e86e090a9fa08b4a29179ff54396615c057ea0dbcef7e10e8f3d2966c72a86c76f3846324ae8a6d1818a2578ec3ba0f4ed49cb5289d298f088a72effc82c56405efdc4d346b1d705668f3d93ebffbeb06c862d571989960aec9145c3c6b46c4c9a7ac56ff86c85754ae4554fa13e4ef48c6b49b8b5c403c145fbcdaad73c435eb02ce54f4d013cac05a7a5a27587123273d37aeeaca713894cc3a3fbaaba706e23d1a57292a3e5a84574910eef99b183bd4e7d2b34dc33d5379c8d26cedc78003de237e7b047d495dea17c8e921f6c457d1ad57896014694edfb1c95e36152e1572de58259d3c514f50028389646689edf8682b529bd8778f3c6e45648ae141f55322bb4e876ea7c2774da4402bfec9345a5fab2e11a28a463a07408b55309a6f0a85a44d34b9226907d527b6f1f93cd4d27dfad8fab13e6c356adb695e58f0ea0ba63aeac4446b4f054095ff6e5ecaab71c404130feb9067d9f52122205876b25b37cb4f2841427d4a0059f303068e1af4602d3a3f5f5df8be805e981be4231eab4d1d8ec59284aeb876e87b95dfaacff496a2501cd13a8c84df01a542ae3b709fec98a6225a6bfb46badbf98475ae8579ee9a124466e54d85a9e9e71575f2423bdac22c983877fc15937b78fc119a4bf9374a9814e4630e6d4a10870abbabe427396290b3ed3f2bb691c90cef869081e14a8d72c210e5bd2d831dd70fcea7147f633ee4cc27ade97f47e36468eef9e39a6aeebd222f64acab23b86f0cd0ae38e06b756c30766e2b78d35d5335a3bfe8769154e4d078dcc800f497d43ba1b92b15dfa057a87dd712993a6812e76db19150ef1d8fb4c76321e1839b0a2a3c395159ef3d0711a5b96cb8e90046224a96062de3908c26aafd27983920cf387192fb583256a05f519ebd90bbf3cc8cc6a858c6b238d5c9f5ee7ec403437dacb0b2f14f5486a72a4ac9f2a0dcd6c19f001e5301af208a0e1aa8f14b40c840aa8c0eeb01e7ae8322b25b3b0c08838b716dec024bc4ef16e658f36567569f0b569dce8a043b5f6ec8ab933673aa0813fa57b376b5819438d2b3bedf6f1aa3e4801a15b1bbd8e0d1bb67de579dd679e3417702fa33f5f9345d49e889c40d2fe8cc44aacf4bbcb4420382cd14a1fbb1f8e313f170b6f2a569c81732a3c0d6319d8031417e31076fee88e5c2d39c59aadf62af7a2c4becea5f7c538971b0031219aa29de37a475374d747ea84e734bb8da1bd958ec95322754f36ec0f811bd7ee43c55fe3dac75f056cbaccbe7fe895fa91b49b2397c225ae05128ff85af968f72c2a01d9ec8d502e91de846e8334f703efb8dcdd5ded44e7f40446120d7ba61fe5285cc0f17284a2d81ae72a4dd29974ddf3e36d7bab274cd8fda63cc8358358dfc352510b7668e073d65466e6551b09389bc9ad2fcdeee7efcad44bd18e3e09f965b9095959501aa9f15197c0e00afb5ebb7905e40a67abb7db652377b84177024a20d80b26c9bcc8e0068674289c1698284753bf03b9cca37ff2ad5bce52cf9c9786a6021392132745bd85b092df3d08a7cc0b8f105ed4859ac06bdde9c2728d9ff4b8959e07068dd0a6021769d3f02eea1d523597fa76dd37da6755fe7b681b157073e462e8f698e4592079f7492bab4e1907fcab19b50d7a59bcc3670bac84b5c3e3350e48c37d092e2e7e55550d81bd1c7268d8bf6302444a0daca3f8b0e6e6a3037afb920fa8d418564545cd9163b5d5295391088c32dfdb173a1d9cac4f169acf83466233becbccc7c15cd36833c6d7c6942d11dac6c91b1e46eecf1c3debbb11dad556e6650505d4d0d5dbed99929d65e8595b7a7daa3d51e16e848f1b4320d431338814554fe2906a725f36e25f69e960bcc1218d1b3341ddea096fa9b6ef9b3673cafef196f8bc0578c16f2ad97bd10b7f805bef791fb0b6ce2262feabaa64af1d61319086b30f9aba7d48394d510ebd4008b5fd20959ba88428f6e1db93e80c4fc2a54902b2ca11930ed886f246f29776b0c72c741a8db0f07a7b4cce5f4f2a72b93011970c9a2b67edb525de9ba37968603b1e950c25dd6003f1dee9bcc35d2ce7d8c294c0c23121f19975df5acc65b511bc05afbe5fc1bdf8fb088fc295902ed0493aa1d1f4678606c6c4dda9ca49b7c717a8ca2b699e62562aceed17c80bb775b0cc504cf6ad59bbadb20507ec552e08f79a0484223b7756e6cb109ece9d9cff1285aaf33f9298976b29660becdcbf9e321786e5f0fe057efb1778ed6fbe4e1a1507f37eae641feb642d417646983c7ded27c6036741dbf2254f8ccb3072197c04aacba5ea577b495fc29d6c93a146ed6d9b2a48a7b8c67174982a7054c91feceb9e82f597f810bb88682ef6786649b2f8db649813644d89354c75c59244057eb9582298b0776e71bbe82f88a5eac5d9d2b262813a40e7ef11932b9acf21ab03ec2e9b76d55c4797fc57e770dae6e3f54a199072d642651299ccc094cd5fd41f367e5b00709296401589381b9a2363239d58b838c424ee6bc1e91972b2983e2541916ffc5da1747044b146b5914171b0d0cfc332784df3d94ae39e8583ef0870e61e269ef482950c0d78a8ae858d4420a71dfda1e35fb84ac2662391a467b6281fd37bf6a1abce5cfa7a0b6e35d71c18a2a8086ba719bbf94b29aafad956848f0f6142f6ec2dcb76c93dee51591e564fdb9ba1c796dbfda9632e402e0a2403c0bc24067c07b1506120f3966bb0be93c4b6449ffc4c75271bfd6866f1b7cad27f1b864fe635d35dd4c8920ceaa76e74c6b9f61154acda7b165027dd6feb5d7f3d320adeb87e9ef95a3ee55073ec4d374d59f6b2718e19ca8ddabdbe64a7be5e21032aa843b6786cc47fe72d31e30821ac9596023c3d7d37a161ce127e57493f5a0705e32ae85809a833504a7a50af60d68d3881ee8b1a41f8b2e5365acf625342def4dfd129755f7120ae7485300506520e806f53989ae448746768dd4081396cf4a69a95d30a41ff48dad17e559426b951cebb54e6035157453ea9ec5eff8a5b63456d6d83135fbaed23a4a0336105ccffd5b0c86051b277b4ab1578ea96181aa47a07bfc96852c939b01392bb50d59472c74b8c0d6e0a5f139d7334406f5dc377e0abea9820e99d0a73878312f8e00ae5bb8621772cbb97c16b40efe9a6d6159ed33c50e837dd023b7a237fd314645341c7037cf3b7f4a186cf5ec47bb36c7bf8ae02bbffc1c8d361a2f21c0f74a3150e1838675b2c91c9665cc9c7365ed876ec389cb6026ea479a165bbe62a360b57c550d48ff625be69027e5ed17fac7a1e4356f420f3d84162f3edcb24602b080891628eef260dda9913c25b82641666b210b46241640dc05d7f08b0aef13aad8846ccbac159359cdcadfbeecd87596a09c643afe2acacf84eb49ef2ee08b5d8584e299f9bd9e954d14b14e14823194541af09639bf7e4685682048368d01cdf8111f49cdb23e24a914e97fbcfa0ffc419bcbdf5e28cd99325225cca177009ebffce7eb89c00e3a58fd5ea8ab8dc907bb995932a97be22675872acd193c15220dfb88cabae79073a21b31fd09fe37fe5ba28d7b5a72921a7f84e5e52044f631344c3f65ca0096ba06108a6c7b7f1ab0902dd89fb199e8eacb2a8a2680212a51855c58721a50e0fd7bcc0b98ca72d7ee228ba38adace5ef83342f58a7a7d82e29e066fb3c9dcff28366d7a4fb82da7802275115b4806c2a45e87595efe03188f85945530de1230ef998b27a8ead68da43c5bde5b2d5f85a7c363b16649bf68b07c4ac66a1053cd714061c66f7e0cf9d4a05d710402e154df8863477034af9a25ccf5f5fc40181cba803c643dc8cdfadee3401c556f2e0938b9533bb0d1a435af5fb82794f672ff5ad625180fa9c7ffc7ad9ef50039582ed1eda3a4eddd8b3715e46a39a40f4c0a18f44c6f3000d9a92a629b0f46b4b8e46590e20230f1f43b14f988bd619509dd0115f3212cc52f98155d69c50bd16e60bbc9b7995ce0dd9947afaeb66a6a17560ce1cde4e13dc2f3bd83754085dccb523863fc26fa8f3d6a752115b349346d3b19337096699ea60068133dcdae43b7ec57470afc7a72dbb2d0e53bca427774fa0521323d6ab6d97c6b737c55d3e5ebf39b6e2a84d0fc3180858eccb2656c2800240b2ee472831fad2f022bfefe985721ddc6822d308aa0f371c607db2f735adc491bfa171f871c924d5ed316514a367de4bc898af4ec89c047f966ab4a093115db579045c0168f78702885ba5ade40509c7800841ad149c1668fdbd4f74cf74ed71c5278647ba227106c927f15cf0731619cf12131e7a55ee4bae7a76c4d12a2c23df6bcb06d374769a7f51ce774914a1118c09b1c1d7c4772f8755e11fd819a6b42a0b60c8dd034137d8025540016e4ad6e182a546f5bcd48afa2f9efd0a8029656941bc685ab0c079559dec588d7322c47a208cacb38b920f74566e501bd6dbe47c7472a462d998be84b044d8fff209a45345b446420f30c4996f4396af68d03265d084787644cd82581e3caf73ab3b95e34a06e8f3324d9a3dda652b6809eac53bf0f26d12055bae5b7ea9aefadf5d31a00a5583eb0a9b2137f05b47c9a311e4c3709c794cbaa1995e9951088819dd4bfb31e71837365615d962121886089bd0dcf0e71447c6db1989d9caf5903ead958ac1d2540b4653a9589c5af7ca5de1bb1adafd1971455ac7c22a2a693269ce5fee70c8689e7fb94bc78e3857c7b5df7b9f40dd21ef222c6b2d5104bc9386e56f2e1981e209e22494b3dba5f1de9ac80088ce7d550d592f8c5fe64db16b74c0da4fb6215f74bf37db1d3d47b722b5be1e384c727372fbcc161d67048bace3373c41bd4273e18f6f9642536c3bc5533cb637d5d9cf7ec6cd2dd929669f8b4d44715b24acaaa27e27fc2f2e0f04f77bd23e2c1bc1b44c86254a38c8eeaeebe8d295678cd3a68207ff5f4d297f10b94f8673da67964721d72ead840591ab7d34ad8e08787dcab6105e6e0d6e21e83aa972f0160c1c6f18d100b6c69fec18df279ac0fbbd81278bd053745ac04aa8e6db02eae6d8666460239add41ad840d59f3fd20dd5dc7ded869fdc4e4979e70e05b3f6776e8dcc98e358903ae3f79b0c27f53931028a311454f23f566a99e5c4cfc4c2e3f0827f224542630f9d5bd97cfc4021dca3fb631a7c29dfdaed5417d6677deec9e269bf2e88844e6cb2966f0a39b2533c81b8dea71c5c28309dd7d593f81819cc486521a5af81212f3106ff76545d9d525aaa91c89e9a34f17e12102a3ae2cbdb9548eb6d142bf0c91bbc5f49926c7fe3b7fdfa55d11af269ac5b2ea8dc69be35268f163227c8f1e769832ad76d796ec64e7c83732e2f33aa37a8710f95e94491cb9b0bb75a45e582365d4acc7350d62f0d4d523d979588e7f4e35e8fe4d35b1c9d364638ff88df65a450965bf52e5776d95864c90b0b3677212429e64aaa86a90f01bdeacaf0e1a2923d41ce5ba0ebe37c91a42d27903bb0eee48024f08bdbe277303462976693046b246f4d74e0ca6a55f2203ce3cf4edcbbb9b04bc35ebd9068c286ec6a1042b9ccceca3f42ccec06acc391d9cdb5d6b217d45cd9bd439a84401b481e9707cacb6fd70e3695d16802afcd10fb35b43b8e282c040290927d3589a449eadee9eb54c2a05fbf69fade6acd2e1c70d8685f325f5baa0fb9954695649f2103ce3e44a76ddb13c2e13f8127314d46594cbf4b0282b3c11964f4906331ac9b1edb324f58f833af0a9e0eb7e904a2a0c79dc48bf05837ea0e69e919e208196d7aa78011bbb41a63768e8e82f9611ea714056f66f9b8b94fc69a5d1e2d5684c634b87bb39d560b11115c847d10eb445a524646e42c49b6b429757c9557c628817b8e01aaa42aacca8e1932e69ec68057fe43e36b95fc41b207f05e6d13fde9fd1afdaa6f11ecd12309fd59340cd6bdffa38f2672e8dfbdb925af27dc5fa7fa9bbbaafd771e74a5c4b28dabd4c67e5bed8ff438abdcaf4a82d647f674ab194f5d9333fc6bf72f44867110ecadd38bdde8ea33914e48b6ff2d30b9b92806e186dc72579e2384225704f67078ee8e7e0f9a43d8240fa78ba7d447a5560bfb4ab2f450db2dd5b611713684c3c673a4914182ccd39ad027449124d98d9ce560e80811058587ed2322f766f7245ce1e202283a1ffa16b92b67c1e5d9245ecfa5dedd7d27fb491069ffb334915454b6ed7471f6db3eb8ae9a5065fa123fe3b91f896281db4be96c1cf08e38707bdc0d3fbd0e53369b1bd11cdaa6ff36620539342f1bee3d6a6e33589ca93205cf09f757bab983f9bb2aada7d3b91e8f8c6d9e28fd743a1d6b25f5dee028117e68fa6d6350285aacb0d5ccc051ddd3b7a0c60828c32020b62bb4f586fa8b13b18e911ebba19cb10bc92ab1ed17b8f29561b79309eb2f5ac56ac8ae60224bf24e883b7c85f8d6ec14b1a87e2673c8d6bc8ccd52f37cb587dc8db811210ccfef7b787ddf7988561196f38f48584487e6805ad1c61a83b84e60d4aad985b0c60b52b4727263adde1c30430c9f7f8b90910c5150f4620ce17bb95b4252c1c557119a0e1ebf303ff963b2e8e837551af81f90710375efdce7c7722b5def770e4be330ddd67b1a50b858d95b776b9d2a971c1c2bd795624d2742b308e4774a66d85291be612e8638ce1147e355fa6c0041f74ac8b7d159bbca72b28db12b5f1f4a3dfe15fa0783c7c6bbf680c1fa52a4eca0182609d8fc2917d15b7c2fed57c97a36fb9e87667ea84e8390181c58170c7b604bcf20a5db9722f5707ff37123038cd02470e744e342599f616faff93d89692f156a7019f6bfc60d4796858a49f00d91363a3667530d2723be6cf88484a1c834f6968991cdfe5696055f0d2a2fa3d35409941f148afc261f083c34747521f1ab3c32a680319d6bdfe4c0ec48f33475e858b76a1ce8bda4958a8479bd66241fae6562ae68d9d8de3aa87ee2f36dc709689db79f1b3d3b2355faa0ee5ccd98ee52b98ff66ea19b82b563e8f1dcad43ee187a99735a7a8b4df75dddc79d447703ea5b904deaeb4b345f74281bfa3e9650df50365c59d790febc5c75db38a5e62246fd00a89c7d29121f6b301f24f0e2bb30febcd63441fb8ee9dcd5616f2077a2302f811018d4e91cfd6917fbd58c8e4fb6bd76b643f4270b196475cc22cbca3edd9a87963c40ccd58399988a70922f594353cdbf48a9bee2d80b767eefd8dd9986298ba0667ab13d99347c6eaba4d48ea172a7a9a2ef5cee43aa60de54ed87258520ec15bc8e8b14c2bb31caf7eeb5ec9b5998d3982e2d40a32234dc93fb6620b7aea5cb6eec25e153e836b524c8f996d1af35d720ced2c6f37fcc641fad63bde9b061c328158ac02d17321af4c6f0db9e875a375ef584a00549a972f7913ea0713ec78c1b80e11224614bceb292580f67e067786659ba9e5d23ac73ca82552a06342fe9d03542d6a4fca187c247125ab6ade3029498a9e9031eca397b40260f0fd9a53bae67978331e1683f099271316c0d73c9c14c2b53f82804fc9ccfca461731d2290f65017c12b52cecaea41d539711f7177c96309891cf44bd7204f1f892bff53c2153c05b9afb6b443cab068d34c81c43874e2e3b78f7b394984273be3cb91af5b970936609ad369ba12bd977bcb81dbedf5b6a0f8156604a1489359a85eddd4b673d8f2d3775ec2c0763e7af5d62b2c65c26cf69ace85901e2f53f4cd9c45935accbd145b67de61ae190af4b7b74ceef3d7f6315d2f94b70eda9c71ec684791ababb03faa1b9d83a488667e2b9eed79b10ee9b776f87a3724276c96027292aedd38019747656be3b0c774d01359041c189c09e11faa8c5712368142ef462488ab0be84e2958b543148bea8df1f9cd440a11a7bda8fd684a3108d53a40c60dce53080a8849ea2df7f33accdefb723cd4ce984a039ad9452e97f04823c85e89f76dc59864a58a2619239eb9f6b87c5bfd4fc4dcc44188afedfda30f6e5a3d79c8e4f80b2c406b4f07717367f03a3bc0a417e1aa33f1009b70634d5e49450d4e72c490b562fbdf465e9646efbf009ee04f972ce4ad21d30a77f677ee99c1867fbf81f3cbf712462b2ffd3f156be34d0c269d6de16dfb83c29dcc086c6f52b73713ac98621929ff8d58aee33c976dc34a1854962f9fc769bb38380a2c169749ece658493c49d2a59fa994a5e3500b9609bef7687808bdfe6b6d56c42da33fe698fd57adeec04a18bf6cd8f3b491370b582e6c10fc32782b32a122a1a4ea09bd22555fea490ce4742816608810fc0199dae4c8721cd7e8fe62f41671126ea0571e1c8fe2f0d6705e8bd0adce9eba43dba3ea49a329a4afd178b7ed45e9afe3de33e9258aefc6404f94acb7d606ba508dc0198c6969cca10fc85766f39f1c4eb099beac36946ba638c11acc1d02d43d73f6024ccf416cae9962e9c9537e8e97f6d66d103064b11e17fb08d90a2712f63cfd487989d5d53f8b5f0a75f4a2d2b825ade9537449b8d93468ad2bd611d1b77a387182e6acff4e8e63c663a04cbd9ca022b6124e7496791dd19930e770503f4c026638d24ae88f96b524cf0fe201b2406c57c0e9dd2188ca9f08eff28632df95e40e204dee814ac5470bbcf2e304dac66cac05f76e46f65e341a0af403cff0a9f07ea3665af6fb5b919e5b00d80eef479529199bf8d89ebacb807123b282b05090357787f0ebdc11b1587b5763c72f23ea2446dd5b07cfb01370368bbafb7b6de91b63a3b88bb7e3025aab4770794dc420c71e3d0d99753bd47b75427d700d30e8dbd88aa1c359a087273ade0c7a295735edfa8c1a8fd7ae844addfb74ea4a8aeb4f2e3507e145129df01c4e7501993017f5915cf1107e1ed9ecfd67fa18d0b0bc4585d168feaffee2069483e3676b8eb042152ccd2758e3cb74310de13a8e417840c7bcbfbf489c6d517002b7f2eb4bb981173bca0cede737c7806482b8268a6d591a5873adc1d8720ac260abb45d841d1891b296284602afc1109b25134d748db26f6a283d60499cee53702091663f8bf95f91bbc00b0e7db6280f4c4e926da90c156de2ff03c11c945d7c7ca8bc810d8bcb492d3ce82a3fe1776248a1b5bfd54c780c9d2e040df5c0bbc023558d2fbdd6ae930c71de589393bf7793adacf3c2958486806e95180f82db61cccfb23fc446b288840b86828a9ff8ce41279ab1d58ee1c9f6de606af454e792a5051cda04a00cdb34ee84b9ccf8960b378fafdcb27f695544169487f4aebdfe31d2e3bb8be477adcf14fbdce97635f1744a5383f0836b83d088f9eaf2df446a9d51167dc803852ae381c2637241bd34cc5ab452140812580d187d904000872ee7593571a8d06ab5fb5a3870825d7b6932332b6ab8374f035abb5ab37780455663048eabfa0f8f368624c0c3a531400890aa7e2713337f1e7dcd469d1a2b568bad9a0f52333151390c4e1b9ee43588e3395ebde67f9fa15e8785a56152fa12d0ac1b2c0e12b5f2f09635f888408003fd7eaa45ee3a41a2f6e9096f7f1144b73902c97827912f4980dc833a80c511351fecf4a5990c258d8555748aa14d60ed995f5a67d017dc9bd81666e0127c8e725c64ad4c419eb5a036118cf357f0246d6e4614dbd64d9d60729f30883b442aaf46010a8b69829aa377949695421dea2a15af2279d6807b365ac9407dd8e9165caf8e6eb1c2b0296014738624acbce5c42526ef5e97510c86e92dacbcc2dab99ca798a2985305510f69c4058708f9d4919a95ab767fd3c9299939663b1d587e90460a1c85ca79943e9cf6c4c7fb32bf2c46d3462b56fe2b0059a2a3b78680c0b36aeab24912a857a3a93dd3766ec056231502ecc1ec0a64b2a602aad3494861350d1537a8271208dc37012a6ac22a7e8131cb3adef0b7f7cad50bfebb85e786d496e1d86f132a0e9c07c0efb3103171507d941b5070b718d048fb5a84f5f699343745e5816e2be7b876f538d4ef8581d3b4f7d0b577b4985225c3ea4565f0932cc0dd39e82cc7ed049b829a086543f4b5f7445ff30fedfff8742fe42df09fff385e3a84d0310291172366b6dd057de587346aa43313ec50b7ada841a4963e4275c78507e099c703e44ecca8a5828691276ef18017dd7d0fcab801abb4eb998d5a9b4cdf6846ce80bccd8591397e67d80d87e57453fdc274d4ae2478db63c243adab3c8f57ea05f3cfe2585f0f15d03ecb3e1d92bfa4ab693b5782903f85ee0076169e7775ffb639b45b3da89b39bf5f820bcccd849e5d518cfba3915229d0c7ea0028145c11d96b3fe726ae8a13d2c8377ef2435617d36e7fb6b7dce58df6816067001e82ac288128cc59df7629792a05aeff521e5caaa31b8d1a90246942850aa507d318332e50dcad503123c5fa432793569014831fce17c7be5398cd062692d9c4c91051d319571b0d1d9fe0620225be5ffcf5aaced475789fa6a24c69d8b360970e13107f7ca2c1bccef298ba87fb6d48b57138632430c16429884aa08a4e54a6d2285edcf5b3bf20a5cadd862b26adbed1130f631391f46f534d4b5b9a7b32569916dbddafe6f940a8c9485f6ef9ec1275504a5a488c72d329cb814e17fd92c4a4ead9a7653c04bb905947e14176811ac9b233502fc69e4754589e41814dc9b4fba4e97319c170d339adeb227efe1aa95bf114bba11a8fb09ce5a2b80e687e04e5d2c3cbd39290a28b97b0ddd7b0cf580bafd1f51ca9f7e2dacac3c2b8172af6e85333b58cd35892d46375ce1c31cc1bf98848e4c2c237fe0833fe1812bcd6bc5cea6f05d1571b6f81a916bedeb957819abe042ff9b591ff9e12b5218b13b59873e57861b5405712a89a16888ff8e202fb513feda880e327ccfc6735b650472ea2e1a0711498f2c8995aed4a25ad79ec567be3c85457fbb8d668d22810f7ea66de9c637d87225867ef97a6cfc8050988283c4a839358c55f97931ea04f70a9d5346ba74b2629efd7d72f91451a1c242ba9864197c2bd1aa37af4cd6ef18c839747cf1dac01c60e34e987b12facb45731d1bdebd1fe48f606c451a9c10ee478dc3bb166f201b361743cb80589f099e82e5d024137ac440cd5456f422a123962b620021248df28cd2f03b2ae5443c662d426669cd3de91bc3a92df8c1f224f82743747287053bb53113d13d14f986d56d8b85f57a47c2cb5db5a242b88d69bfb98978ec27f20bf90535ecc8a583a51aa4be37440a4627931af5346eb2996f69179742ad6831558390c531621514d5179befed1a7f680514ea46f076c5ea58b20a004a17b9ed97ac87b42e42bd618bf2d4478e54458a2bc83dddc322b4cc968d82028fde8f14c089d64d1dc9d90b744efb6fa983ab7434ff0f08a1d4d436f3bc7ddc366f0007edc0ea72d321e6844f4c26ceb51feb6e0ef6c6437d3e6626e85d75f7df2eca0ae4d91867214bd59708259a94350981b07dc148a807b3b4b23359ff733b5c8caf4391267a52a60ee14d716ee6da0951914a0203e887f920053efd7698e0927883f7383a46c9c1b31fb6ef52c12e873920c7460adda1e906e45533a0c7d495f63c67525de00c4797e296a4622169fa7174e4a21d4b61c2d363ff6aa51671302747ec22ca0bfe2f05d9398adf71dd03e29415d1bc6ba9b1d42c2f6a4849c0b2bd8f3fd31fcc5b76255b330d8ffcca007becc5a63f27ca78a61e00a7a3563e4ff66f07a2a55c8e609163d1b2dff5547c3ee0dded8ef71291642d6c9cf56c1c43f45cb5e4f821be9b477747b33897f3dbb7b11f52f62b603d23900215bb9f9139c08122d469fc38d770ca5ead44b638ae85e854a23a4bd9f2b71651b4999959dbf3ea8237667e184ca4cecfad1bd44cf654680457ace7c2b069084a54b57b76c5ef4707ca94bbe56fa29caea333b90142567866e1b5efceb2ee91ea86ded633c0c672da0bb486a837a9df8f5d659b2ed9045461c2f098b696ce28898cc268ac649b5c9708bb1e73eea63e4a26734b00091057944a415baaf6d4acbb1ded12633ade158d70cb2f5f55526e4702ae8a469a72bf775b67322e9bff703880eb7ee70a6f1fba953d46182924d71501f5fa7b454497dbe698092bf7c946e2385b3c9199d056e8aaff8a905d08fda07c2bdc8f4161975a3123811db9498f157074a6350a238d36fe5cf5acec4831202292d3f986ea3144fa936104d8a7611e424a962103d96021b0ccb74f46b0e86c38e6459a1cdb80256e9965d8e56b23cba7d44ced458e62aa0cfd0613032359c6eac37e4607b0e00fa9b9e014d85aa77aaf45f9ba0b048416d7893f75bc771fff3eecf514ed1ba2c9305df0a242e408c2f465d4e66a6b9a0c373a70ebce31a84222252472a207ef1e1c97ed5d3232dffbbd6544a8b4923d56785b005e8ee21ab1fb5491a0df628d8276e9ab55ac54a4162afeb72fa50635eb11c105dd6e1c921096248cb09340b1358e8360acf6c009fccd4cee3eaab2906ad25bf70750fcfc87fc4a62181404843ebd514dcb00260dc613148fdb3cc91bfd4b78c59514c5aef84d458736ee820ed64fb69202ead24391a52505fae28145c151471df02896389bdafb148040f1c251d7fd4de6d86378c4463d58f7412fa203fb628a63da992a5e9b510712d444b501c7430072fa9c6fe42deb642dd154498b64c21f61e899c2b12331b36225d850ca8f21e7f0a3bed0ee3c517cc802c43f873311bad52859ad519576628f07037ad1bfd37963fc685585d0e3a57f6410b9e7882434362bc07f525f233ab7e004a42d92e2f354f759d0f96a1c784726330a0272548de50ba667909b4b95eb3749a9ec87c51c6b4dad0cc4950ca6f67efa4c9ff878b3e6cf4d8f578aec6abe6eb474c4246c91ff1764eedd7d919eb033e75cf8cfc9240312a92d80f88303a5de01ad80e57c3df8556518850c9179b519abb192a1f5249944260f5a861bb6ed2be1c99af4ca3d3b124b385d8fa95feffd5309333ddff2665e541df2947ce59cd0254fb0125bc95f563886ce66c5e08bf9e376e163e03c21368df97ddea1cfb17c61f05dbb9e45415d949d18364f133e3338269384b1889b9983dd08c2b1661432fd178f59d2f9b61e2aea397f544837d75177684c9093ffbcdf8d5dc4196b5a4a50bd38cfe029dac410b4c20a29eebc76d1fea40050e4012171c6ef08e67c733a6aee0d3b8324e4bf95a494d19c4eb3b257943edf755d1cabfc0f320c46b7f76da692db0214b6d8f4ace03fbb579702833656baa2a1e731b0c4157f82f9d35868ce8d26dc5d76e38b95dc5b37362115767267eaa7736c0a90e0b7b9309188b5ba49064dbec66a4fe7b6fadfa4808c7df90590c8de996ad6bed70457c92eff294eb527a195714b600a8851ac4e5ba87897a227119bf382d73760545242ae4c128897eba7f59806d899a2d72b81dc041183e85c036fa8012b11229fe68af0fedcb76ab2f3227dd289e8904bb2f69cb4c913e0c14171a815ff88337ebad425f754b030193fc17265d2bfaddce608f00210720b444fd709ed9cb4c55068b665f12dd085f6599ba82a24b1b7c923631f70fb9264fd3e6ea8d6c3cb0950fefec196aa171308c8b5caa265a7f46e1de93123de348be389cc869d59e86c7bb8ae836989ad7731a687b58a3f0bf992f149c334e7183c43e2b7eb27340ebc066479e2c956e1e03622e175a8b32e21aa04e2ee79a06e03ec6b42ebaef404e3dbe14b23e33dd8b23be5a8e5c0cc8a433612cd966ae5b5703d211c761560bc792f39b8f6376ab458738a495fbae0ebddee58d31bdbe86b4071bb9f482cd43eedaeaef619b053e760c740e47772220956e1fbbb5cada524f9fae98e2ce76e0c5ef796c3de7bed76743f78b5951decfb4a97bd3c37f11bc70fbc2475e398703624162933b5ebd490dd12d91bddcb903a14a4fbf3882552118b81f934d74a41496347ddd92f2acd048b7c3975e66cf15e08cbf834dcf31cfb2988f952e217fdacc0bd6163229db222d604512078798aefb916475b2e3163cb1bad3f78742b0851cf32f72ab341bffe64a00086966a8c68de45e8540db0072b9910ce7bbe02e7bb1eac755584ddbc17a852331a4d5ec534f98e6b2bb1bc48129bc814010ce944224091714525b7f5d449a70eac5be729c778bb973282bf0c18cffb9447d1126cbc2ba2f5c4814510e41ae6e7dffbbbe5e35e153e0614c67a1aba8196f1fe5fdd938e4082e1f786e9448571ed4ca551d1c01ac75fa3a545aa5c335440404ee40bfb9a8b8444a92a1a57ee8eadcec6f45a3b8a28dd6487e36c7df6800a6f6e983c4572ff35c78fb4bcfad0c5e0c361cd71e5ab8299a261f41c3bbc577f55d0a566f25e0c3ecec298ce2cbc08cc87c49b112c5d2ae0480f4a02598cb27b3f4d315324745130b42b7fd5f6bc2f7dce6089c2d567531144c14ed03c4eec9f2928dbdf95bfe48a9e5a2945f91ddc953db65b4b45010742496c8e82142e85a7590099cea1fe280bdb1667247c22fb6748117725e48433e152264491a0a0ce95b20c09583721652d4e845b1d52363df9933cac73375718661a1af4e6ab651c0ab3a597ff6b5cbd4c8c1d7ecc0f42b1245db8311b0cb7958de6532e7dc109305b3cbe577999d2bda02e90bc79da39db40eac335a0381ccc0e873a8f997b1d464b053655cf5335217a7e68673a48e034b7666bd202c9a9c8ec79420e0b030e10b01a79b380be0e8947573b31d6fc4f8967143e936aca35f1e8b5a7c87759142ef4855f4d9c3733e00c301cedee92dd77074614d41c8220dd5135223d12fefda694b51b69ce849fb009b2d3ab67d7c96a996f775de03a79c75d495f2012fa0f5acc374d845b810589b5115ced56e03459f70e7d34281fea1919aaa48760c0358f516e5153648ec531a9501da69ee5c8d3673aad6e00c5ee1bc77a7c987333ff4f3ed74b0138a62d8d7610b25f2c20bba3dfc66dc6749b90d6f0c5f2fff127bd039254de68216b89481758fa4fabd0dfdbbe3265c8e750b3146d1ae79b888875b1d495e15d9bd603789aad9862efa7f15e35ca191abcc65c46347a887085179dec1261336054198d8f0eb8f2804df64d3ed3251532c89c9e193c03d514ff917e9820ed3cb4c922822b6a6a5e0c6512538e92fff8e1fa46fede56c90645b588428a524c313ede714f72a0b079e1c1c243b4d8b0dfe1fc1eaf61ff9d68e1090f6dd1a66fb0ef3e46b28314a333f44b8b55ea6a9283338c9d128f3fd722ef8450455c6536ca968895443a668f23437d64fcc3835beb3c136b40a8f07521ba0c498c714b974788c2cfcc6e7781f742cbc94d6aaa08c0cd07a773ce398f21790c6f236b1d05463ba8edeb02760f78556b5fd5314f1d47200bd82a850090c37f0a9e52484ec2e0d6c8748578a81565981098e0708e85f2978124873d49c3669e04381afcaaec07dbc616c76eba166feec851b075a2f0cd68b60fb9766eb3579d140ce31c0f9bb38fcb0402bafc0cd80b51c4260f4a8f6e5df2eb8dab3f2e2d46e9b5020a87109d3cee43e4e4f6768453971fd21996a252156af9f0b078c334168cf1a5c85ee48b35cf465fe3b820a04d0cb3f6df13930fc4868cdc880db1752d34999c32d697684bdf675f5230ff15cfc9032b79e2aba1ae57467045e98b88f82231f70058e3afa4e8591cda2beac0b24ca51a85e5599bda31ee1ba9a1baaa765dc6a8637c0534029711d5e2495a2473af86f3141a460f64aa21e645d6b7f84564b2efe0a8f75d8ec904e586cda398ba11dbbc7f2eeccd4176a96d43ad1c9fa8bae43145dacad475124cb5683f1e503c5b4729bfbcc4d757c0723dd6d9b801e71be48a012f78470d0e9e86f3b915052d70f729a7baa3f2542d5201ecee1705eed5daebcfec7d231dbfcb193e8c0b7cefb6e5c2b661b6c23c12663fa79fe6f9eeccdeedea1a42bffac59837d3f53cf005ac7061f19a7d2712048839e1229a4dd4bb5d0b455bbd374100b076d60b28823248b5b73283e5537cf935e3a4551aa30b6c0f7ade2f56583fffdde9ba87f1bed64d9c2ada674cc8d28cf7b0da089f363d845c0534cf2898e405db8372da737be282cb386b1313cc6d48636a3e24ba8f639aec9914f47540beb5a656cb0f9d22cc16670457eab15c491eee43484f9cd3a8ad78b86ac72462717567efea92d205a98db3b6cffb92c9b3c786b8dd9473dd3f808e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
