<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1c88b12551a59930ab32b4fd712128778ae2294675c8b0c89a43e8828a36989a905778304ac0daa5213c4cb88eb9d8de6102416cd011a544403475fc0c90c4161a6c209c70a969be0ba2322ed737fe879bd3b4d09b6acdc713236005eb5aaea310ba19e2cf9f3c3d9515ee47dbc4aca7cda06231e7c55ce532dc94d3f1286f766f4f734d1cdbf99fdb34de59275a8f7555bd6a5aaed2bc7d55c4202374fcfce3064edeff4ac7b1b6a75c9800db506ae7ddacb30040c416c5314fa65365e39b52b077d843fe705570e2a71c6b9e6fb7277fd7cc338dc891dfc70333f349d9628e7757d3f7c4ce7f209dc2e0e1752d47ac1a1f9cf4877f3e9fa2828fd2fd6498c87af9afd190dfe89ca5a7da3c2457a3a3662a94c835060de512deb6d54f6256e84a8ddc988bbb2589a8df4b36aa41f392128a7e9108a6fd0c5b900f08efb64a9a59aa3000f906a1e114da3ffbcea0c57ea623013a81192fd8bc24a75eec941df504c06f902332c7d6f903042f85d19764ad3cc920c0e17588ca789c54bd0377d469e09c2f7b6605b6deff5465a85b191d252da6ec57e26a7b28461b282ecb8fb8f4ce054871b5d0ba59248b53b149101d492031f2c3c6c32a5e394b3f5619bd06a411164f2ac29da02df9a80c7872de0968441b60efd168b809528486a754bfc6278c7958fbef556183d624c447d4655d2e852ba6c975c52e848557ecd13fb8ee41e10ba6e2bb5dba61150db70de7265b8d3980a116992bca5f279e7c49d614ca7eb71e49b56927e6dc201e2a77955953e3f43ffd866dcbec3d0af84058cb2107330a70acdc1678c66d665b17b7b708c5f49576e0b21c3226841d6e2407f2254b2ce41f25e4970e2d2e7763cd198d82c0f7bb3e2564d3e53d99e2c2caa33e42dc96dfb7d8383efc83b3cfe559d64fddd300691b83f32da16d9369ecece4d2d6bcbd736f254d818f4fa9568839f61230d39156e215152c1fdb5a9539466645bbeb2f47479eb2630c8941d4d126c7025cd8cca140e3e9e26ae620b037d2cabad7bcd68d0b2bbce4c23caf27c333b8fec4e83ca2521d4ee521cba71ae06cadf1d2a14e735ac54c6668715d1719f5cb67276ada0154345c9fd00882e57c7eb3e04fb5684dd7234fe17a249abaf2d265889e25eb643984bbc4deb7ce6297ac12f537c854290814baca03e736169956fbe36bedad80453e54e92be06db092fb72761985043ceffe6bb2ddb1bae0ce29897e8f90920ea3a404a4f4874802b5baac90b09570f6b73b0c06757d7c705036d240f85a75419321d2343efaa6c344d4588d1b1da8ea9276f0f98ab594e15d327d3873ad88c63c119a7f115aebb5a62ad4748fb67d77c19477629ab3cea4cb98d5a657bfc0384920d88b878fcc9d6590dee7f11efc8aee1bd24d3b9813d4f701c295f7c31e54179aee1f315bce9766bc8b1351f4957d3ebfd5b6e8d36e1993232e1678a776124f9ee1590c8c29e3a7e050cac4313a66c3ad9e9fdcd7b8a147c0191f6be55b6ed7a28ef343a69f78c127b8bbd120be46b2f35ebc0c4883c49cf622538fffbb645f0f07771fef4f828e1bca58d6dcb40d65b7c465f9ae9d6761593844154fdde24f1b1791dc39fb9ea00a4864d7601b749a9587a0363c39674e52818b8d3722fa83397d5f21c0bc0cdff6f4256da84b523b20e0bb3d42baf73f919504729623ebc0dc41ed7c733838328a271d0aeb62e766b8f9265dc8d828c1206c7f632312d943cec6156921848b2b21074fa46ff41948e8138fc93ce05f2271e70ae0a6162049e7b765d534b772b8fed0f27f07cf598ac0ff01dcb77b5a839205b5d9edffdc5922ced8aa8f4c3a6cfa6ace3da331cc6c1aab23d602f329dd149a68fa0acb2c6987c181b466a4e992e1c0c03472350f73e4bae390b37fe1169b57f35cec059cafbc2f6dc23ce889c3a01e9855934b9e386635f1e9cc0a721d56c89328e6804818ee11e481451922fa77bacc486de08a1945e8b5ccabda3b0be9fb43df2e6ef2526aba0fe2ca040f92d02bb0a3cd9937b2386aa7e72894a886b790b46e8655d1bd6b0e00a5bbad9705bedd345db2d85283c9a7f28e074e62a5907a51f052b33f21946b70354eab8529fef26ffee1b4f068edd3498be05b48628cc977fccd2e18c447fc89b24808bc9b33351065e85d31896a3e103105ef45fd2dfe75db0a1423f617e82334c3a29f77d25c42fefc98743d74e1ec0c720d1749b0bb09a49cad33c2cf8a6771b57e6746d227e10533a191e02dc1e1e4aa5bb25af7cdbc3e4961bab1d51df2883e8f33f44e69fdaa06a5ab4824068255e821fe8a6faee2aa6a785c03fb9bd8c945cac2bf04265a92f933bd7ff98c9b699d7502aa59300bb67d0b15b079fdf3651fb5240540747e0368ee424e2286be1b413bac606260970a689487330507c9f9131b9a97a1b813c45ef9cfe07dc0b471c4cf7e97996df654662d58ac192e307a403d3d2f2dd5e244604ae83646c0b350a83bb83d7a4300c5e6b9ed7aae199a0162dbb4da570e8bf38ba77987f5516c8767dc698558f34115a4138a014032135a0d0b2b5d366e9109ac36c8c2485296a7d3cf6f9a6693d2136b4bd95c04a70a592c48b13744611485792f24f1abe3394f865e0150e0c6d43611f2349e453a954bdc537abd9add278f0b213cb6fa2845810e4d4582e470596e06c631c7baf3663d2f50b3d769564985de870491d10407ac156945cbe1ee7a97ef80c95fdbf627d411fe1a8483c693cf1b1f48d3b91462f9495295e2a82c8e48af86c13accb33cded8d3c08ea73b3ba8711d58825317855dd2beba9914084654392541211fc76542914d70a6321f6bc3cf4d9ecc85f5c4523d42ba621a3ac972958ad32ba79d07d0760e99da15db82ca4762b04ebc503a92b1b61e888ef2edf8070479c723cf89e4b7ea6be3596a8b602729b0171b4df6e5c7ac439af2a0110be8a510c15fcc36c8fa21ef4d87d62c56a5517adfe065f480c2779de0f611ee56f1db8311e4504acacb6729079a1086abcda0789a2dce20347881c82cd07a2de3c6e4ecab586350f85bd31f51dedfe56851ed19ee802871210ebc460b86c1670b831508f2827df1e27f2b65f6540bb719f43adc506828c587dff4c716f7eba63870cf9bd3812a9c3e747016618121791afa247c8262e4f3220575fa2e8c72b49d9e703ab54b8dae8d70ea804a65201640954d91d068b9bf69c4cb67f646f303c3b721590f86bf7ab0c19fc734b195cfe308324f186021305922608201a1a96e5c5b9632b184e9dd50e4a2c8146d201168dbfc41f7cbdbf7b6324f75abe715c5426ce1140b3a08124eb865149b7fdb3f559f7b2fea1566a974d06d547207808fb618ce9eb3c2dc5e46978ac99922e94f7a894082218a6a75621366a2990c1370b58730372ec6d71c50d6e655e6ae5909fa8528c6a3a2e8a4dcb2b3e296a3289e0066f0d50f8edf18857583213e0942a8f518a5e0b9d2d4541578d004667c0dbfb69ce15d9a35745b94aabb660d707a5fcbd1c23beb439a5a6eb6c11a0d16e06e4f1a146b43c1d2449e163e53dfc5ad948647ac6b847a3174cff8482fbb47b2f18bf2ceb1bbe4ee499f8f52f584b8fa49553b6cf6c852c08bf66ad5db8c2098f73e7effd0935a039f7c679b9c4d31463254a57c92e4d35ce55090cb0b6e2dece30e066d450cfeae3f6b5d787aaffcab04eaebd62358bfc4d91664030eeb2cd097daaa623c9403af90626c13605811654357e6c21aeed0627c1a74759c7be9097b72bcd96a845dda0585978d58f3452846650062d32707f75b05ebece9b418251bb30238954230a29cbb798fd67cc1da02c981241323521dffb7c95588622b4cb83bc58aa7b1f229ddab12d1ffac13326221065016dbd9615dfe0447fe3192ec3d1a27217a9c5e72db0886c230f903b03bb94d1908bc83b4e3706e8ddf4faa87626a9d79d2f5c5aa98fa40299cd4f515f5cca89cdbf1e639b8a15f205ab9da2d3a435583c937854d34522e8bffab6e61f7322c0c3a959f74a74b17bcac708bee684783ea42547a6b9fedca598508685811bcf3a89464d6514af5aae121fe584e7934e8e4bf2d4f77ba8ca7486233759408cbe3de326542572debb548b2578be9e9908842dbef18b01af966f1a826ebebf13a0b0c8b46acf5bca5ee00dcbd54bae506e420e5c9f82fedd494ff917b4794165ce7e6794e40fea59fc5f32d1a23d9a6088516016a07bb1baa446bd638b3c28f268c432e025010bc68c6401fbd379b2d38b77169253565127edf2a0f0b65ecba3bca524954cfd7536d0490316a956e56306c34e93e09fad66130e0745593198e8d68bfb329f0a138a07df6e7b26d6329cee29a0270e2211fe5b72640ef6e2dd63eed6ebe44bacbc3dfc017f8448d1a96fb95f54610ce5f9492652ae2e321d4ff03f518c33d772a89bbb8c563e19223520da1acafc9cd81d75f9cd1bc4260cd23d5e9cda20398e9599eccfa1f6051ad1ce9402a8a42952835f3ba0409850b57fa6a9396c19b4fd145f22d7cde2f9cc5e6e92a34bee4436561f3cc6b37fc28890cba9d1e0044be2f21b7b2cf5ac84ca9f48b9754df3c3c4956c6ced3cdc8c226caa75e15fd91f413b8396d3a0cca2b58ebc2152e5bd1b37d83f6fb7a53fcf1bfe9eae14b8afaf716671d539e5f443e97e886c27ba2408caf9fe66535599f79de206f37857b47e4fc879be4e31d518f61c3a1faf116c881ef7c0fddd30b6702dd95f480434360de93066fe79cf6e6d1f10bcf43854795bc7c236240630b43f296d42b674b57e6bbed3dae9664b3fe5be1617595f65094f85f4e612a8566c7d5da4e7175438c72bd91d062edc61c2c606a73849ee2e5597b2871207551458904ab9dbf7700a7cc73c4bfe851ffc3d545e6e37d561f98f17de829adf1f9ff93a9bef318dda1d0fb0075ee74edc4b38b2eca14b61fd82b98d24c1bf247ae1412ff458ca8710d776edb04bf9c6cad96165ec309963a5e5b9e34f0a59167157e68fec0d86cb8cb8d01575aaad5e00cef6e57e9cac12c12e54a44dda6758f0a484df42390ff3d073319b564eb6228e3c3180f32b3595cf7b203f1f7b2e3f68c4a757052973cce2e680caae2e9a8bc249d51966fd912ab467c19a3f219d55725927c0a95f30c18b6da2b77672b240e148a372c7f1edbec08dd8f6785fa6dc3b4b85022c53c4872037d49d565243901566fc1713411f4fd462c54e25b853de23e5eca3b1616be8a515ab5d60337d55894fb22a25126e98f118fba875dee8728a1b11c22c6bc6ccf34f819bc6b4c3b649f3da6f614d14e07c9a2486ece03babdabc8ef5c73d3e4d59a0d4fe5f709042e5a21700c790ad6cc891d77ba28b7e2ec14dc5acde254ea6f807fb03739a875e2cfbe0b47a35ef4ca9cf1abb65c62ee8660d6ea337ef7b49cdedea19336394a6cb3d5b81acb8002d066e7e875d2d0b5aa5309782023a5b21877c1241425a3413523633af27daf4400e7c0fe82d2c7585853b9753440ff8f281bb3e608dd209ade8dba27a54e8b0786119860e06e3d71c05168e4948b0f40a922602d704cc4f1b88e6a8cdcd93762cb9fb88aedfb2e8621fa4d89e1c4833cc415ba0e0240adc6fecf3b1cfde34b07ef9a4c8d01ff31025a5c82eeba2b0eccb572d74177a71ea65f3c3e3126d8a3f6b8829465176c2aa682e6c2ea2a2f1dc0f8926486c2d3611366b1c0b8ad05c8c97bf35d324fe19c4a2b4e99c5547cc0a0970002fec8210f513b50c85c0f18d2145408021fad994aed95125971131703ddcfdc701b2fca6f110dfe7f0fb678aeb78944f39bf416827254d45012062d41f8645c9d783141fee1ec9e4dde635021c46a21dfab10a31c9446b2fb9375b18031031e9d5e1d554cfbd73c2cf552e95680645d12c44d9af965be0be9525fafe7a89f4a18e4952676aca9964c26700dd67a6fe641a8b68111d726d6ae2a55b2b9cf92eaed0d61b95a2053dc95d84f520a79293b3b2e97eda7ffef635d106ca21befc80258cc019e0c506653a6926253864af632db8b4827c0cd23bdf19d597e03a12f61e4759e64bf9258877353e7de7b60dcfcdcb2975330e429eea784699ed5483420508fad70efdabf7306596f87940829e14314727370e118896b5ae57f20de0ab83ed8c81118321626ea866d0093c990173b3c6322dcc95a679b50c1dd2937ec369a3de15eefe6c125f1ec6e6f8cfffbab8f86449e894cf94d9b43aee17558faa34378f0bd575a62b28a792519742e95a0415ce26b5f497041c5f99c4676ce3f12dfade33c1e374436b0800d9d53b916c96ca7cd44c6adbdb90b4903f7fd696b0319a86407432414bbafcca7fd5ae34442b23b3c2e2bc1a84569d98a3bfe3544c8b516e72d97de52ec5af3603ed16fb0362da31819f1ddda1bfe2021f85e926c6e3f51366e59472509134507565d89354e19d19bbb7bf49b6d6fd62f9eb045870d97674ecafedf3afbfd92042237af0d50912baa879e3714ff6cae22aa276b77f85cb193b783b7cd51faa4b433cfd795fc35275bcac32c3fa638b6a286c6246a3ec116935f5aa7879c571f00b45ee735d9c7d67f7a7ebd9835eb7124ceb9eb7fb0e30b4f10c05432650c2e2f60d0f7d6ec0d9636c0ae4e4cfcd145aad26a6a77bd39bf90ad5cf4b26324f5426c5d15719ca6c11d1f3726ee466ee4ebc6aa8aa8c644320ee9eb0d648673af6bd18ad5710dbd56ca9f080f31dfcc3b9d0133223e37f7453c297e40117d4e77b1f7fccf10321c4305efd8c2bfb5991483da6a48b2df5d1fae8311f206d952955c5b3379e8966eae1c5ff2e923b209e0d0f2dbdcf79772eb16194922015d1b32115eb72310d295038f6bb9cfc12de3fd6128ac6b1d5663caf4e8c2f29f11e9df3966b55e555db875ccafa0cce55fec678c422cdac7132348ed4b574c0d0eb46a40db0d84c6712bc308156654e6a16b0acdc21800a122be851b6099a51add2b048f0a64bcdaa10d3bea7ca193f7205129ce51618d41d80face9abdb77b9048031eb0d45b1e115b1b2fcb90285f7d262421cd421723ab781f81eba7bc94836a12860d37b93e773c5f0fe5262eff5283f6128656ef82217f12493c83b3ee7600ce26e86ba49337b69312460320fee73b92c4b0e3ce820bf77fdf4dca4dfb03ce7f8e77a507b7ed0a65ee54b51e5e20e5e526202349badb60106d5bc9e9e949d4b523320192e8742d2b1020c9f8e20294e4c498442bd2a08eee9415ca560514a9d9979539b872b1df2f070b1d79698b69f108dfca60b658f3cec13458d2ab66bdd22bfa71d6e8370ad65988fadd50aad60d6ace1a827c50bae8f92f184300e30d337864749a69481d07dfd964f70b3c61365cd339f696df7f8c6740a069c2493881af27ec9557569cfa061bd64e10cd26bb02cde22638750a2fb2f0234e5089452ca68bfb6a0beb4b74156633a4c13cfdac6cb0f8f0b9c79e002d9090f2c0ca2ba206807dd9eff359d0c46353688fdbd344b117f9d0d9594a1311a8a2cd7f104fd1676ab229c94dbbcc716b1a7d8f25864ac60353640d6449cff5c7b01ba4b93e1ca4628bb094c28236a23670315e3910c25a2d81c7c224f9ef6956c34d044ab6de279c6123070115e1c311cee827dfbdade9aa2101332582a781bf172e4b632690e7ae586e7dd73507486037a73017eac5d1ba7bea357d8fcb22ef618a338d482cd0810cfc00f18d1071ee4da489195d7e5344db97dd2ab6571498aa2137b607a3e139ef3b15c5d02e4ab78d3eee07d2910a9539c5ebb549cad25f173e00036739bb5c73b8624ff7875e3e955e131e870cb9c076755d8dda512519ab5498dfaa3bd9f2a85adf36bee985ccfc7d9e4c9fa5fbf7a328236705a1bb51190ac72939ece19c1c2178597718ebd2843a7449dd3f9723ea3e7546ef5291081be2d62ec18896337e2a31191efe4926b125fef7476a4149cbb3a181d61a3834c99d84a88261bd6a9808851338538d76af71cbfe24dfcfe84bf6966c8e16a82883d8a99b3241170b21565ee0df635075d1a0e371bb4e3ae38205f86c7c088b7ae9b37c0a62190faf5a30c99d49c09bad5304dc461b62c0e0217553a8cff135d255a84e5d91c70c4b2812094bdd94831318146c6b8150e63990418190bbd090806e6af40b841db6646b7e97cc5fbc28af6804d605ed49e58330a3a72588f9757d99f1a8f73b4428de9b55132dbdc3210c8c65afa3eec0709acda34e5ee9bc9584209d10ecae53db29d50bda50f95bd014bd531749a069ad7244f25c76f002f0c45118f27e90e9ab96af5c83199783f903463941c5f9057e2c7305b3e5cdcd0043084f894678eb8ced3553d92f93957cdfd473925b304847c7a18c7f4246f6796dc4a3ec469438ef35da8db9113c9e0333a14ff181e3a67bafa10294ecd3d43ad070bad141a40818596012c4eaad15c37242b456d41d36c5fb09c68ded2829b646ba18734a574375c0dcddd7eefeb332355037c5296c7221ada937ec2f1deeb878c4f885d5e92c0bc86534f1e07f6b75aa2497cd410ffdc2995ea2575828ac7c0c9b045165893d12f1f0316cab1a198c2b29152d32ef0d34159001d01637fa6d0275cd12e93c85f756096be917a1a37c03552be608ba1f97758f58c13cb1de13dc8011a5baded073d79a0265253b4fda3442c05be5a816fcd82a2163c3b5347c31395317241c3a060e73359e2af6df314a633a172d6c7cf7097d7de01f512ebe7a7ab0983f455ed281aca2bd2a7eb0f950fac8d6cf76757503f8966dc0126e3906e8684f198aa8256b65bd0fe80f6a18a522b742c12abd16d4707f8fc429d60247cfa2090f3fbe9b2a9edac40b511edcf4fe04fa1b178b9ddef4ac0abfa87a393b42d500323200ed1f451d3d7cebca71561584729203879eaca85f190cf04020d42853ef635c17abd043646fd743f96fa8a9db59a7ccfea28f33a08c5a4bcbc402070b345e95f578568f377be82a604054ee11232aa3ace1d9585586f4e039f49f17f939e83b8207cc79af448eb4bbff9c042448746c15e4afe2d282ae71b1e005c16028d1ba5d35ac45cd48ec9ea7b8cb3de85666b627623fea0216d97232602c51819051311f8c6034a17be34d918a833ef0a4c9e9e960963eb8ebeb41cca4e3a668f0a3fb7af5d9f0167d6b292881804b8043d41c712eb3749b8368900121844068efcb7652c1eb868ca0df57845f6d168fd39c442fbd1b993b6cdcde158fbf237af6f0ef1ef7699fd55727d8c26b5efb1ad4c7204d09abfb3354e5c96f0db2ef0c94b749455d2c8bccf640cd4254edae80f92ca951bc06a41c5cf11d66ef93554165d497dd5cf4bc2b0d73600c4c313f86fbe3d6945977289b0ef62756bf3d5bc8435e174a32a94312fe6b1327f5550398d00b9478339d26555259b61258ce08f058b0d6e658f9b3f0ce94675db4eda8b76669332b312380c3406ac6e0228aec3907ee314259123373cadc2e0218a9743cfc0862c540fe05ba2fb106e877b1f6b9d341a24402833bc5f0173d1e16cbbfc3e5b6addb5d6d396502dc595225fd71852559ceed689feb928329e3fb1711b9fa22dc4e98624f0e6f78018db0f4088fbd5822ef29a00a25f9cfa58aba93b7a65e6139e3a2e6bca3df027f3f018ec7379d484bc88c2e07f418ff9b4ae7731ed544feebff4fe2498e0af8d18caf6ab5348099850df6436b2ea9e7287ef115cd2108596d85aed7ea1bd39da18ce003f156c4a36f0c031ff418d16a115bbe1efce74bd07a29969d840ba394f1c8acd46e6cc520e20fefe13c05940dfd3eeed6831090ce239b4e8a91898be53d2af4118bdbbc7569aec9eed8f2a41f91feee5a8200e3b4f5b0261c0e9e0f3d2088e31b6ba16807c0d4a4eb470d4ad9ecfd8f83e331fa12ac4d2177c00595089f35ca988a6ae63fb142f1bb784fc33f8f1d636bb19eda545cba491525e659c1fe5fcc8d299089b7c55ee88fbc474d879ed0c1c8d2c950bef80024c753f94edf8b8b0e9518bad8b1646ef914e876fb57cdbc6d6c8b6c32b12ad02805e9c75e385e344ccec31d6ed04d0e47fc04b780d418dd4ad869a9080ef3bcb2327bd979f125e46acc317ab6a2ce57a95299c7871b10d00669a22b25a90133a72f300b9acfc91e24d3a2e08da42189effb1d8f9786ba9cafde6c1bbbb92a86443a5e2bd1f6bb5df10a771019ef89209444e62706d00734018ea21ffb84f6f8021efcfd61a848c47a5e7e38609b55228fc6e7d837969e7dc1c3e75d20a2a2fc0e4c0598d77b1228a88a996b45d42708bd83e12ff6afed74db73f45abc6f35c20e697f9c5905c660f8fa85dfefd98ad71fa1b38c5459b5d35f07a9c160216d41a7ff04a19073530eb844603df13aa0fe5bac2be0ef7ed22fdb3bfb3d82574f11b5c68ee6f35e714bfa14e1dc34209f5ccfa1fb92db07928f1b75b52ed88ee9b385a686c891c8f28c7d0bcaf5d890dd6e3f5eafc3a827471939f9f08dc963945f79dcf993e7c4cef928d004b088abf4d71f2df8bfc5a456043126ac41bbc0c92bd50103bbf227e70e2f570acd220671f83ca94eb5b8d1c0233ffc87152b9fb9c5c6c948e9635909d5df9b912bf6a0444d9e543afdde497e180614e6843d64641bb8b57926d03c10ff17038e261caf1e50f07199ab393cce55f284f858b5066c908ff9ad699174a46368a09576d2aaaae226f8bd026f76de99247e97d13737ffd965ab9abfa3464cdd26bcaa0ef5598252d318ca8b70d51cbd91bfdc414056d3b19fda50c96de8c46ca1bb84644dd44475fe5a22176c8d5068c51b2187b67d00869e2b087e18ce4354050a6f86dae97664037877a5ccaf2e1b777d88eac4fac1401c3ac3d07b34cdddfa9a05272b243f7437643b902a67ee36629dd0c199e9246926c47ada850c7ecedf3c846836077643184868c8a41faf3a220b685e68e6456df0aa9750a2177aca64c5790997b17c1ee0a8a5938b86f17997b30a2a1c57e4f3304ba5a2661252554366288c868f08be9adba48ed969fdffa1f03b23701190ce8f9fa3f9185138f504a15ecc7dfd590bd495864afe7fe29732e07ba5f3bfbf0bf07ee4bae01819336fd9095f2c8ff7e6119a70e5870033a346b323d48dbbb7edc9f15c7fc4aec45f2fec358c36faa6e87213d425efc43285691ee1e3b6f89600d82410631162113439ab2b67a2fba80300545d9882b665ae9595a01e6f8414cba3c13273de6106f5e2c0520eea545f12d29e66103bfa644ad80c1e93097852a549db014bf55808519a91aa120d666beabdd1ff8b25da90e6d11112be612c2f7d1a8f8e4fe2f753f76deeca2f4180ac899512648e8d415833932a949606c47b3bec3eb8cb044249b90287ffc2a4913d43fa026937c176bfcce2129144e5b9926043cc604dffe758092e71aab3a1e409196910af67b79d68210239e64b82810373be563a105f500ea196c232a51c335c5339e371a6fd6fc9430c0fc7124c7dce10696cf9630478046436d5ae54a4ff05bf1912ad1fcd0a2c0248ff9beb2efa484e5ab9486611751074ff585b8b89ab9e052594b9234a0e5626da7439792ade71306a7d077aa97db05a6c6520b9c090ce1e9d484c90ffc4c5f14173fabadf0c905ec154df9c215321605ffb5081f9eb53ca5f2f67b46f03f7bc60b682216f90655bfed015d01f79c33af2298216fea3d3d309371a1b018e52436e12647e02b5f86e9015a2abe8a0cfb77ba65d5462f320abc209717a1a1af5f18aa0335ae99ab70b5f6616877851580e047658e3619899458fb061ab65e8d5eaee4b2c81c002526381e9ca0869ef146000ca16cbac8283fdc909fedb4d1197e0d8b46eb084e812c98294948bc3a9a520f02580145ef2423f6ef77e5557c3bf046f530daaddf903f46ddb20909059a34bffa2196572f156b3bcba52413e7d0c8c3525c0dc55fe388a9f25cbec73584f9cfd567cd923403294e602881ac930a75b229d63cd9cd216889728527ffa1abb2d860a8a9b3e5f71271bb7903405dc245bea6dcc12006088e3fb81bc2d55a220f33b90e6912003a9baa08faa8d6bc55f250dd3bffb3185899c3ae6e51cccbcf0419bd82138032805fd49771ce76e02f811d2f63465db3ae72532cc871bc19a1011113398250b93fe51c813241b028a378fb7a7e112c20afebcb39783543aca1b5c25fe000795c98928ccc8f45bb716b15a1f6807d9a60828b60017163692c3cd9562e3cec9743c65101f3b826172a7b6d02384b782f0c6d6ea07b5ef60f5f7aaaa1aeaac5f71f1e19e10f0f178b650fd43601d0927d4021e08eae0186297477a38f341d93d1bc70024082a0cb2c2ee16e23bf2704180247b324410d5595ae8f4f1c075e535f8a9cc5cf4dfe1f2aed8f28ad02f931767dfb49c89082b6189de432b1fe1e814d4d69cc889887c4aa27027e6dfb5bc7139ead8a349cbba984c13076fa6e070cb174975d701c01bac9ae6660221a3fd45ab79ed4017aeec4c1f6faa29007c69f08a3c510987523258010e7c2447d178f5c3fa1ab2fa2d21dcf9fd1443e787eb1b836e1f531840558fcf617802a90c8e3292bf10dae8060c7b5397364c55ef00b8da5f4ddc11485f81e5071e8590e4b2f5ebc66eba382d65e16be5a2bf797b22d3661bedcf6a90aa0427260704b941ee2409b9eb72a9e87459254965bdcb3fd0df8da870baca63325a70ff48e869b228f5fb7fc01911f9171dbd3c48fe323b3807f06bd47052da206c1fe35ac5b56480cc8d6152d55bf241ea2115d4f5eb6d3aed4b30c82ed6dc18a3f3f9ca19778809dcc178f21473dfb659fc7697ab1f4d483d287ab4b2dff608696ce3341a1f648d47c62e4752b6fb06325b05293fb4fb90cbd60b6f07b72174b0e20b7287267ffd746bc277fc8c39bd5b476e05b584d9878b5cb1a278ad779a32f174d8fda05e201649c95792f59579b60d4c08a51f8db8703a1b534610eaf7c30a480d37d0bdfd609c9f8c22da300cbbb0e5ef31395d3e8af52ac6668e6fa67fb2712a4a6b52ef0be7f86554e32588a4bfd402bd584bc76b7fd37cf488d94635df7d96ebf77c4e48707b7b01674da3ba1d5981c949f534a1478d46bcd8c8bb41b98015a42b2ea6b8887aca411e05289731fc0c18eb4cf5afbad812f656f7d14095e4846c4099f88fefbd2d02eb7f7ed7005d5f0cd0b75e216176365260614d79de7cda93c1496a0812f29dbc1e80bc2f2dcf10cb7795563504cea7b70ddd12ea01689c15143d674e410af94f3cb09230574174d45b56e78adfb031602c96ee9d073ef6276e56f6ee63f727d5ce815f5c63a7ba88eaaf565bbd1ef1c9223d42515943e71ecfb6042b880dbc4e0ccc589eca4b762ffafb0fec37a626ffb0056561e84a0f04b7ca3e5856fd017fa33d70bb4fed8e63a7b4c4cc3289f3311ad5e707f6bf6ca1f00f48b66699e3705dfac6ddda709d037987c33e76124c06ec0c9becf08f1c7db5cd54265f3ee0b13e550786af06a52ca38bb481f95419e2b5e159318c3567b7350ba5dbbb60f099635cf576e7ba6d8823d60616d831be68528c9835e8f1442a9e9c65732304a704cfe2df0e3847244690c8c854045bbf7a07900bb1bd12c958adedf7e96dd297ba0e41564cbe174ff28232cd2abe3e343de890937ef35799448d0455fd8afa589242a41d05de96265d1823a8f5c719c9102fa9140a5f0d33cbef9b00edc133d4c824f7df40edd58f93ad04ced14a6df4381e60f7017259bbfd71688be01cba429b3c32a56ee130ea296c028639ec4a41c3458c771c141d6da5d9cb61f89dce45d44777db8fe00c664cf3ab8d73bd45ee619c9da80de0023ee1e2687643deb1a98f72d09b3d7f7f3f4b7e78e9e8874ec98614eaad445bb95b2be42eaac12b61c49701562966b67edf758c4c7fbbcc7fd6df603a9f0d134279dfb7181bce9abf477b27fd2d1e08db30de51f953dcc67c11f48c6d1431eaa9f53858ef3a281c803502df771b158aea717545adc4e2850a9a2a61abf168aab9c0ce84197344433b7cd451919e7550f967559446b90deb5ebbbe9a636aa67ed014cb3071c2225cf50d1c881be57de68bd85ba508957e0f0acc1d0b8cbebdd913308fb6731aa4fb57def3b182c29e62dc2ab05e9c01e1747b7dde52e16fd9b99d493ba8be10abe23f8e8fa6c520e0b132d5ff60a81ef166e3946c0824b37050b5e073d2546ed22b2764df95d18252d17e48a0b9996d4d272dfde4f2211f1da5baeb85a238b6e7f2efb17e85f60cb3f2164ad0820b154ab9f561cd593d0609aa0cb878089a4b10c9535d2f5e2e74ac6b65e4a143ce5080ae0916ed864a77bc118b34b02db87ca4b900a5ca9fb9b6b242134ae5012edb86e4be6ea31aed620a19efd2c6fa472e0448fd50eedc21f2a5f76b6afbb74e4d59488fd83bb8453d5d032c49d759df1b1b2fd155b924e675e39291bc0eee3428a9c60a49d55955b5e48b28c091e0623f2b4ed47c6d1cb2dd8f09b1b5b1788708bf4195e58270f2b096b5885d06597dab4e107e494b4f68216d31ef5f9225f7c167e8aa93af06034e56bf34bfbaf9e09285923483cbd3c96797e7a40fe094bd54a71b3b006ff2d31e72d067f61f66a6713ba451773a076790bb125f89b1dc913543e1b271155d846984848d4da1d2fb3a2d00e1dd847ced1e6834215a1910c4ea8b08c9c0ef1bb54fe88122c3d536c50b3af4a6891aa0448ef9e94a060bb1588d1a0f19a01ffa8a2b41c5fe63f034d84529ea0d3063f6cef2659ad0a205d199cfe95036920907edc75a6ad33f07fd381378fc54d2702260d71ed33971c45eb18912b00c799369ea35eaf080d952921e9ed4d0baea8122ae49acd26173a7a13e30817db6beead1ba88ec57566552b7709cedd25c227377791c3d8758cf44174823c77ec554566151eee1ec1e9b6e0526ab9225365b77b715ab6a5ef70f4969e74e2e0bcaee69350a5cf2ff82efa6e2f8d6d882956dcf7bfda586a91ff6fa8387e0a8543b8dc236c7c98c69afaa3d679e5b6853c86e67b283cbda90923b73f01cd6ab30df25aa9ec07a0d3623884ded983f2e16ea081aefde167e822d8d1f8c1aa9f9cb24278c71b202f0387c25d8b47b1b353215567c0eec9ea270c5b4977454840b1c9d5cc9b555f4ac17da273ccb0c9461153081faab0361a9bf4ccbb41f8f0fa68b7e81392ccfde61c586c2ef2eb339c588a961d63519668a9b54b09d2efa32cb521271680bcc975ddf261b57d49c9841b1f1983567569b4df0fabdbc2e3bdbfc0032db01bb4d565764b7388d952832136728f19fd929432e531897a3ad725f5ec4669d852d2287296fc7d6597d3b5f3c2538902b6e5f46caa048c64d54cc016f4c4a6f68e905a3f60402e7f850f3d7109f9add69be1919a2887e24533aa50458767bdce050e3e971f2b099e9b64a0b763f5e3e1c19cf37ef6cc580449abefb86b9c0a73db467b336467eadc4c02e133271c22805af9d1b8553da9ad8bb707ec46bf3886fcca944c0bbcb2366638f214995a3b5f4a871869e1f8f3fcd53a3c6e2eee462e115696c3a07445a088a7b56864563c06bc12a20e573ccdbea0fcc50666fdfb2381fe55183d9dc96a386853356f7ee4c9e1fb313bedab2ee9898e805185bc39f82a31f9b028e458ffac37efa572fe9887530b90a5163b3327e7b8204f1c944e53a687d5b0b51bcc2a756e4c721207d58d6342f3b46e9532d9119e7f7b00344cdf423c7dd59e9f627ee5c232be03d579d622d9376d1cd679f9faa5cc5f4b53ca968fae5e45bd278028ef704234932e9a25f169ab02e6f515b36093c4e0b95b143d0350f2f6bcdd27a9ac4b55bc55dec11ec8f01415918d0e8efab9dc08522b6df8fe12a993c74af0a1f7f295e3bcd56973a9dfd37ab112b4cee282391210e50606302c018f1431133cabb69994911305bff8761782783fa1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
