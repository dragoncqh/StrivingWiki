<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9dd5dd63ff68f767186c401427444325103c38d9ca2e761f962781d1a41193907d3d5a46a438f7caaa732b49ea9d0f0563ba97f98671ad35a243e6af5b4b4360f4eb27588c4297eb1acf3273d3adf8b0767c0d67814e7b690d6ac960cb0ced491f32c322d7a16050b8290b67bd54d966e46958d962f5952a11a89fccfaaaddd907531af822adbe1d486a97027ad4e3b939606aa37e3b156dc0708f1402f3656a9bc5605acf1646efe6636232a5d3a5e69727c0ace74b9284685bb5432d5db07590dcc3dbcb9fde5fe76aa256d9da9a473fe428b4d6a892b6af7c82445945201d2b477bd3581d4acce04fb3d015517d1c56bec733d77a374d03ad72ffd619511cba0d9b90a4e643a27dc7cdc59facb831c0f6544558ca6c543506743c302bbcf3e34cfa8c40d60eabb870398d7c503dc7c312908ca9ae1f2b2515305ea35129fd5b819bbd702eda267f1f357fb59737ce0918ce3206f02993841fcd045812c44bbc9af01809662491018e89c52457287e53ddaa03f98395592f176b6899724398a250ffa399dbf011cdde539488f2b3b796440b6d36ab814d10bb708bf8dbe2466b41b97543a2ce4560db95523fe6a3d37fb7f24470789817f7eef12bd724cf0d33ccefd5be4b994d544c89ce14d237086de5b39f8f29a2d949147173a22692cf89b6b6eb5aedafdd32fe165ced0967940ab38ccc3624b50977e11f592dbcfe1a378edc644a24d089488ed198a38aebad011c8228f28d358fa067d0bfc66978d9fc18cacba84c6c1a6c8e4e6b75c4ece96fbd8242e172ad0346b9c9072140df1b11194ef9777072233e528025dc117203c846ad25fd3eada0ac2f276a7d57bb02eb1396bfa44b3df06c90259ba391c475289d597bf97b5d077ed3df33d1e2d966a73c6b6e3e27b48c7f60786c9aea35c3856913d6ca9159700bba21c2049172a226f7e3effdd77198625550c57497d955ffb1767c0c1021cd7526ba68b2942c6887186115e13980fc791fbaf873e96c2d891287455e77b9fcf34603477a46bfbd00f4a90824a41707337ef5ae2a8c197c70cb1a5ed157462987887459090d0c1a69cd61a8612c92bdad16f324d579a46e9c72a5f3f5cc22858dab2c9f42e523164e7ed3f44f44d873e64f9fc4d9b9206c88827a13ac0cf14a1bd474ca0daeb328983829ec0632ea58547bc425da5e8d42a994b0c55909e85985675552e756ba34964f845cb438709eecbb763fa11dc5bde139c4931315117022b08d283e1b48511e26917829bea24bf2b89a26d73cdd6035168799ed047f61aec514d35e9a8c7a4d9e18beb453275433d2ae2ba17b64709dfc378341cab6a0d94e02f580b3e4455207748afae7778bfa9046a8ca8e1882acd81b8faac8f1a32443ca4ace09e0c94399509e9f366aca2d71d3d699d7cc73820635316d3e031432f379da21ac10fd9538d2101a069d249c81635c983dab9e96f0bd3d7a06a92da86e5393f1eec9dd7e6ea7029fd01a6f1ca39e90d4bdd9192dfab72f94606800cee16f14d8095ea14b57ad3087e09ebead2ccc7e2a398de3f4de8bc035b9b0d013590016fee20d17aea77e46ae2ce3f8b0d6fabb38e553c8afdcaab23ef4e6b1a05f923b959cd730c7ed7f1a73fcb7dfaaa950e64ac6dae0ee73adc1d704ac874e5b58f81ada24862322f9fa80ca67356985b5fcd8ffc88d46b16313be4dd8945caa7c9da32269463d2d40a0b6a0bed001eb2c16cc631955df321adeafdd22fee9d25139716903b8eb1a79303a8cfc79248425d415dfc57d5ad12b166358cc0f9aa26e5af43213c517ecb857970fd0e32861f88322fca446989bc4c4b360ac203b9b34bef0f027feb83d2c5fb3a9188c520373af36e10bbcf33987d92da24d1b8da01646e7fd2d8c48a8f4a7ab19460f730f1482d7450f2227695871201dfac4cf2e61190b6ffdc6a050ccb46678336838875cef249a52a3ee42980f51cd36c9e078decdddddbce8739aebd6a7968e17d8a384112c8d4aef24ba89ed23cba60cd16f11daf40799bebdc4b75f3aaad5224b658ec341f43d925eb8139f5da2d8791d50c1ffce97a06ff2cc1ef515f7b8c622e37ebaef2dbb366389bf20765bd08df98823c1beea966bfd9d0e4241758316b0ab3587423ae5e371d30029e8c6ef6ee3f08a99927e14d9dade359d6b3d97986c914f8a46ede2aaa5599e4fac5abd5264c4405754f8ba6bde46f709b077f4fb7516d5ed9fa764cb66c49b011554375d95ea3bdbf7ef50a2329800d1e9c46a6247ba9313a54aea02b41c93c7d715069e26b50f67f7230b7b0947b00a420039f2ac58a39a02e7ffb7a0457054e2896b987a30397e4db1899ee68c1e923e257452ca9fc7b575a4cb123cee173b29a0c6d718552682b656ff21ef18ea5cb09a20c7105ddef470fb008b27918d2a499988134d742e3587e5aaf1239ed3683c67b25f9f1954f2e87e49b6f1cf5909cbcf45959e7b65f721eb36ee053839b0cd353d27a3bd93020232af50f4a3a46e9fba2e9e7a1c62c1245be99088e8426a83ecba96790a0f9d7d0a84c22189a84e27c85614e849c0d839e7490ef8e95bc1ab3f5977505c6808228bab4fc7d57d03e9dc22054bd08c319e57ce3ea2e9f200309a8750921dedb22e8c5f92e02484400c19a455727d3c51abd2cfb33ae7065d0478ef82e242e4b78eac8029e143f6954a78494e0f87c9d9844d2fad7e6c10f8dc88048c046717fe2153e35e45adc31b51eacb57682fa2948110fb1acb00782e97b675ead82eb25717f899bc9706cf9245ee51010bc86f204d22e21a72afd0803c6a26eae85b75e1da723f07529b98539c11eba9d4e667cb52314ce036be8ef47d5dd9b22497ce799ee72b6747d1947c815a0cdd00f2ed5b5adc0973f44319cd5827ef9b7a61a5b154e6588100472046607b55b331acb1acb09e856a4f3f689119b5af62e514cffea741810fd5029f5182bf6362c139922a1fb693b8a32825c2c3bd524234c987ad0ef0fb9940bb7f7312a2e852ae4fe7a369aa7de9c5df77da337806bc7c96e78085e456d2a09bfa18c0df27d280f38a5484d24542cc2158a58df0ecea535d6088a6de17e14e63ba65f48ef3789b88923b30490fd04afb9f47291110e785ce25e1e65ae259f2bf566be0ceab191f650588b6d5406bdec32c1423c72dcca4ea90fe169e5fdcfe2f3b44d378b47628a11b963b03bb12256db6f016044edd0775448dd1f29f8fea966a7dd8711466ff3c31f5ec3bf042852d2fc1eecc012f88812ca3f5d463dae3445f1f4f6124890445626fc9b68e5998c3af6a6a4624a17e4a85380f1c041b6ddf0c49668c6f599b63c8d5446bd076916010912f00c6e3ca5b5e853cad068d6f64738054c19dd5e91176b97b9f7bc0023fcd1999fcb8b4668bc52450d93d48a43c385fe366089191ae178a12cfb65b3f082789b24a23300a80633dfd27077ff62514e0de92a20dc3a86184391c14ab39636fd1237729e392e77abe40836433391954eecc24b3113b9410080dce628aa8218f775f468162488054cc9b36d545d5286f94e59f9683559f7636fb8c67a78e9c85ab6f8f04ec254483d0b9ca105053d2f195242b76ee6755228ac4337004a88a1df108dfb372a33d95c9691828e576b447e53cf0cff5fe73739c3d6589d619a9d63d094cb4df63ad9ae14fa2676bfb1a6e0a972286881619489f9ee4a1cfa332374a178bf30e941a82a150f0edcee2c4cc6866da1e5718da79df4e448f6d2d79dfdb9610098881e499ab09d1ffc1b22f72eb91a212cb9b55aebe5860e693989b541e6fe251a8197d57243ed8e58ce74d17ab0f0bcbd52ba79ffbd7de9989b1785ca238180cc928c5dd9d7df73bfaa9d64c3600b2236779d7c9cf2e2efb52f8cd9a2e4f095232dc3e99a4d206d631d951f28da6963e5afaabcd0d8f7327db1a329520845da9192f67a750dfd444d0532200bd93bbce9bd529f3f52a4a199a1741a58f5789d28c6917bebc0ebea2a8f28c6ef5c953e79836b3d0c639ec5e8e636ae0e5bd416a65ac100e6dc42579d47828aaaed686764d1f7b8e8ae00f495237542c65f475fae0f678365269b6437bcecc853739145fbce2eb75bfacac91d93089c7ffe26f54945bd92d63560073c4017960805c6eb4cd72c59092592b6058a87fc2f616a0f5a218c938c0811b02155e01a0cd45aac48db6bed4655147f6dd3338724e606fc5ea1ab0f6b221b9050035753751b2be5eebcb9d0a28f7b30ecb61b274b30c4f3e5c165b22de80ce05bd9fa44ddd18d8b088df79b88b3ce14c570ba4b6bf328d0ce97379f8b863198c4b561c13b258c37de45a5fba3bf11dfdab6eee56bfe68ddc1925bde4cd0fee04984bfb5cd3b339545fe1dd42f63c4f41e65c9c6b54535be6a7f723b1dd7e70de78e483ad0c85950c74f5de8541b7341404d8ab43aa6ba4935ccdd21481297de57e4b3190d018fd6e350e85e573ff033c89f4d6d66dc2d225d1d059eaa9643407a4dec807d2f80952ef40f6b57e59eeaf597cfb86a4a9e07293d33006c65e76b8564c313488edd1a0e5d87f22857e696db4ce3243a22221933c4a562859a5fe711080577588b7afeeaab57f9ec10b491916d64400dc83d725c36bc9df4e043139c9eb9e406c76b2cf0d005fb6d9fe837e18eeb1ac4838ca30edd2ccd5c1c027a7ca7630ba45d9bf888adb059fc7f41c5745f33821031e6d4751e15a418837344bcd903545a4368c0f3ed109371aeda595a7d7dacccbb578bb74843f3c50f10b956a330948824e1ded86931b8f3a85f22652142b5c13c9ecdc8e770d09ffa145ecfecc307562bffe944f1574e14d73c07d94f54f23598e5e92bfa2a00960e9c7425e4f460517571388aa08aa5c8af3f99474e74d4f8ee1569134647b2481010509961533e045e8f85326dce82b8ab1f79795ffee5ea425017d1dccfa842566e018929aa33d73d80950fd0bc589933df2c49facb3453b961271b6184ed94a61dc7ff0efe2fc9393f0c7fd59bd9a3739b2f3d5888241654a5ad63468dc8ca6de78b4b873fc50c89ca0acf9d4e1dccfd3c47058e27db9deea5e888c6d6a96e51474d26b66afe97ed6cd0b194a64969cab8faa93a50e53ffbbacd6407f450ed07c18c974973e81d823402303a5b0464e2cf51782a2d7c55de16cab1ad8387912e5049e1abe9330b56b473c722722d9c20938b904ea16652e11d2d9c1988eb07c5dc5d04eafaccf34c5dd1eee3b2c88e7ab3a98ab48a2f4d18c5abe63e5b0d6b729a86de3919de2ec36c09de691b4e661193ee7c0ad36b17c73a502af3feb3e05162373fe582744e552d531813726ba7273ff0629b83daca297b4e34646807f8d47df6cc4838b242ad3ac25c4d2d5e3111a244bd2579c4deb9f147821f5f82651e7ee605498117e999c98f8de1432217a953366dd6a2710cb1e348a674891300c7607fed9fe0cb5fcea6be0cf49dc7bbd52bfaa6547dfa4861bf551eb70ce4e010a21b015a035af0b94be4cde7dd036e8db6f9dab46a6dae8d816ca3573e1fafe433215a460791c4399ac54601c669667b27746f3cc4719a202f812d8315e8f62d37798b24556750f878b6257eef21b08a2c5749d1c57c5e2ceada3feed269dc9535899d1713ccec9cfc6f0a2cb431f97298f38fc14b55d64d87e31c937c3ef56307c2799dc5e5abd96f40ee69c9c3bb266dc100ec95526968c98da0f20313e2f68f41a3291ab4a5af3709c8dbcf4baa1ecae6fd255507b6b76422ebd54ffe83a945f89a602717f32b1d6fb1c9f26ffde32da7a6e925f7d57c5c461a9d055173c147d7a0c03bce97ac16673b11e4492822c0ad2b53ff0f3d25cbf96b8e679db25a9befbb88531a170fd939fc4e0ad837831b20f71433e398bbb896ef5408cbdfe245fcf106cb1d55610f5b878a993c937756ffaa5f9eb5a11b3bc717efacf053823236ad14b6d4e9bc07fb21150d178edc3b7e78d3ced1194b8bb6105a264a34e26932700fd2555deb8cb090ffb4762989e4f3065a24092b117aef3868abec55895e7d9e236cd93c331898bcd1a71c6b33de5207aee1b4a022f3574cfe1db155c5af7cb08d73d14ec337c8ff0e3c8c9d535613d2c590b666bc35ecc5e9a69a89e1dcd287393cbdc1772aee8f6c4fa103d320b253b8655e1524903e066dcb6beb1aaf776218037b932abdf260ee7eed9e4eb48c18a1f020fc28c6751ce16bf4c4588be60a69a9a87a9de530cbfccddff996cf568eee832ae8549e2fa485d884f402ea74746a6b4f47ef849ca92941018c02a5dd5b3efd81c1418881ed70b194bb48565a8ca2ecf5c7cd58ea4c72dd58b0f12c063c0306d3427c8a4bc738c58c85f37ba726b7a39c81d4375046b7dd2f30cd979bbf2a2abd793792469e114a75dc3ae04b5e3eb8b343df27512228260bebacfd8a40f586577c0d51fa72649cc368fc780817dc294242855b48cbec2adaa230f7fd04d308ba872749d77189a747ab09a41d60c7b252fa729f42912948412026b6b3da566fcf0d5f078f11e42502d6adbf631a0e0f80bed4989938d9d77f01e4fd08d41d6c47c1aa62773a53d6673597ef859bd1d64a3f8653510d3a8732c3bd2f528d5688ec1783c6c0205f3aa4c400e7ac3287031c802563c23ba8f0367a7875a09f90f79e76cb180929b27035f13ccf0144a6ba879096dd9f46e25cce8cbff93f27a3fb316b4ba4d785c5dca5a8be2c3fda51106e52ff8c6c014b05b8ef8194b4dfa1e465f9d0d8a409efc55665e71e36de6c69a143e8397b14d6b530c3b0f4c1663a0dd3cb948ae6a184029beb364cde510e54f2e5ac2fde71430c68a2b16de3bb3939018f7b5e24420ae7a78a85ea801968b04acd663e9dc8d097cdf2acdff1e47120a00e1f878744d5c57388a7f1f2f5a0fd4f04cd2ffef1e337bad8d5f04ce81c97ebb5f23235ac511b326bc20835f7a9de73b475af52c791bd287c72e312e47a4ee5d9dcb610440f70f1cbd2e60f670a5be65a6136cf81db76df270e24a09b9b74e37ebdf79aa6ff9e469baecf189a4d8982443674d2f7ef18ab78514f495f2978c2168864d8fb559c2cc9912f7fb1b69d0a3d4c879ad218b0406760fc0e4d6ca3f5f5295d052da70c56b547878501c820d83734e25f03d77d88b1588f09571851ab525db3db4985df5ea01fc85eac6af1ae1b59291289e434cefb1f13d82261f24918fd4f96eeeebc1957b8fdd3de8054d4dad03a78e74648ce69005d75e388f53954308637135bf0cd9fd8735228701c5deaab3bccea68b2a20a8bab12bfe9bfe64b6ae364da9491eca6fe6d22eb62c71a4042613a0d2b173b54ef1026640f96f9ba69e43d2d24148d13db0f370c2751dd09d4a51865533604db7b17117392e054e0704910b9b316de3a71848b80a6f63cca19d7de4a689891f2c85757d3c2c6818aa974f87dc3ec91aeb32f25766","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
