<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3b69de032da026d4f6987779d179c1344a7dd4c78812f2efbfa284efb2b16428446da8ab34a65b07f250ce98509f77da38ef02c99173c1cf6f87bb9302ae6b57f6db4a2e469fb8b4642dee0680de24aa8c5825b41143c0f569d8e55d781b30e3503d4f3780080ee82c9774938a3107931c54a5f5ef4d77210f4f51f7737efa0b6955c85889cd92d8d315ee6efeb5f2916e92a7998ca8f0c05f622eed9c6ba56fd0e42e647aa1cd5fc1848392d45ce2ab82e8d79240ff8f4970593bdb129d393222db5c62c40265688bcd8fa9364386815d0fc88ca0c36af7972c09391210b4afadac0d9febdc384bc21813b15c0a4cc686a9cacc9a97b598e95c46676ff0326d14c4edb7fa68e00108c7a52a070a44a6e78a8c1eb5b48f4e546a58fdf7c31ec43bc72216e0580f4d5a499de28bf8fcc8aa86be5df58662f6da3d5349879b8caa86b8cd6ec3dc9aa76f6cf232080d242e1694dd2058a7b044c6adb5223e9b44d878686e27d0eaf5fe289a8a980267e5986bc41d427e31da2360f21676a7ba73279bd7e9bca95a1cd5a1f6e7a8bf48b9da679071435b5230c0700585d993651e3b9cf62cd3e2a38811546294edac62e62a6b2ce47cddf85b09c74c42f7547c842a823277f494a642544ab43f611ca779771575c51b1ef6f405031a508b846c6b798310980eb84cd7a52ab4d5f32a2b83a9b95435f6a808eaa5d49e292949b8c200605ddc2e9762eb304d8d4f78adce9faa9f47d90062046c1e3ce9035bd23cf37e995053fde0bfe0d169222faeb9fc7c558d97ca4ea76ffe334dee245f113dccd05e71792d58098e729522d8300994bf4f3d12195ec01c8f62b2e5d9650c0d73efa69d68c32031aa4f87dd973ce59e2a8ea2e2381a16921a23da6f1d8c96baf052fa3e9f6338d21effd804d89c14a7fe5e658545cccbd0a265c2e03ea5dfc5d8af9466b308dc1db5c09f603aa8931eb799f62bf4901c2965109e8ed5d28058596a061f775c36c3277fabcdffbba1fc93bc2560d538113cf552211a1562ff74cd421b6e9bab9271ebab72fdeda749254a02dc64000a23b502cbd85be9fc93718e6ea846fc60856bb153fda860d0edcbf14e10e195c0377fb3f194b604b0bc20db613826a7304d789bfc16a3a94d8918abcc773be21eb7c66960544563037fb3c2b86634c3ebd6da10a9776246415d1950ba0431fe2e6a0ee898d222b03f8bbea3bc2d46dd546f19137caf8192b01d6b5645342408b74f4e3583f8247c360d61303ab0b5714717936fcf95460ffb39c6e45d9a700f10ce6a078eb658a1060a7778a186a02bd76625590d27639c7ba949c34525ef7964c65854f64a5c2ba8fd7dd66baefa9b2a11fbf16e50700158218fec9cb138c35c36ae601f27ce07141764a1fe8b1e0950f13ef8a4d06b4496bd4b91b895693d19a5a3750840e9697bb8ed66f92920e1b9570dd2f3eaa8202c6c56af9c0f27467a91b8d0fbeffc729fbda23e693c78564bc14bd73666c2904ae881c6bb15b2d1184d04914802806d853191d157625821e45052f286b3b8f7b8a2e04d82b3572db143b88bca1f45bffead555ff8f344bb91da3e5dc772aecc242c81fcaaf1295822a5a42dfe3d70ef26b285d22584d4fc5698db8f1ddeabb4ac02657120c03bc2d19eeb1ba150579489564302c73ebc63aa755feba583b5f4e0313c3a349ea6b1621cbc99284cb51ae4ef6471c4b188c78cf22600896bfbf5705d9c8786a72aae1553c6f5bc822681cd9721dc319df03545de0f61dc9ea9e66a913ef73964fbe93296354bcc82320a67b3114347acfb4ac75ef9baaf38a4a04266a29655c3eb6b8f80598ab9e8dadad1f4f54b8200e73bb7452b4fa6d52f9b8962dcd464bfcde1aa11cd8ffeebfff834b164c65ee8738db274e0ec179ecd6a5a4d7ef306f54eaa006ba2c50e7c6421920be3730188843f8f56309ff1cb246ba84b9ac2130d42a9c55601b7debf36137ad683fc2407e55f544bcd9a5cdf8152d57cac59bbd0e599881d901e3532427870fa19a5146dd2bb9a9f4551a310ee4ec016c1721a6b178076813bcf45a8fa3cad146340a95ea81550b9b360a7930afaa2b9538bfa787abf9155fb5271e26a3813eabc3771e7ed41270396626eb775654710fc758d44d8800a16d1904a45fe7e42800f61530001f783faa84d80249a71ff2d4b7b1c417305416257c373e314f9a1d3f88588a529ce4d334b5dbc6ad42579fc1d82ccf8cb5cc4e1876db7133edeb72b53ac62b6459c7caa60ea209960581bbc15016d7edb49b7e686e77ca05a204d8088d9e1751dc22d828e356042a8025f0b454e75fcf14c185cc00f2eca6439f78de8b5f45b2ee6ac763ac4e0c34e8b191279e025848382141bf2179b4d4784b89db0194022b2a5ac311148aca1d1a7bb2604ca90c31af44ca00378ef52d9fbd0646ccbfd3957e904564f01c7f320c83c5036b931b15d3e3a07445c0572b96b9efa32b7fa3e7c9e261f1469b6f942e08ec56e18c3d07ac90f3745e5125503a86ec97f97f3db0f74ad8f5278b6daf5c1cb9c553c051650d5a97bfece10d2c8bbd8e852b429447ae6ad8c308e84037b185a297915e9e04c836a85b7f2a0b2bf481c37f7954320ccd28096bb218a6caf5adffcefa00b5a5ceacd90793b581638859ef3abe2c15bc270592d324d2a5634d84e392c7e63154491a49352c8ef503fe24ef17299648505129fa8882b3702ef7b0daef160489c5f88677358215c64a3fdb4388877d319af82ba67dcd713ad849efa0b1f78131fd4c9a1aab905f0ff2b46ae9f6f2d2b3ec467cee992bc2dfaa5c616f9a87ae4ddd0afd7458c282982cbadcfbe0cd1c1db478085e2af8f84879fe805977ea0cbe8883dcc3d21cddcb00aa0128562690388afbbe4aef5f683ac622d61e7bc594305300cf78046d5a17d3a94a8ee17d315915b6585db4c37d8a6f94ff15240166ff87b5677d4a57caa3ddbfb426656f8d274918ae715046e46c65369b38e7ae1f7306ddfe148b6bf973a171e022b80f7279e76dbca74c4938107908119061b6a204755088ee4769713b50e9eea98b6500e1eeb47d0aee3c613cacabc4f42fbc026a0a03bd4265b8f70f66a25e49b5aae2ac168437c9967c2c0af47dced5103b132b8158d821470a25829442ead28491274a4d4fc9301b8569a004eed8248be6a09d533318cd3d8d9516d7d3d9ec6f528f4b4f13d3b6617c67da595c36fe8199a2ce051365c9c33289843f77ecb7488b157a2cc844989741612a360aca261f46db174618912ea313e4269655a1b574dc844bc1f23e5d2f6bc87492c6cf23d921f618df34c89f726786c027c198b8c69b23463aa31b01231f7fe070e6802ee7cbc0e8291265dfe819d18782a445f76bfd3a71ba7fef9cdd1dddd4732eb5196608636c5d86bad9dc5bcac0efb6068da2616deb1566cac72141cc879a192780ec76fa47e263dba562382db0a356505cf946371e1a2ef3050676e6c72ddcda4b13ab444d7c058e54fa00b5d00f7821aad933c7ccece10ddcd89c95451835d116a88703859e717b3db3c3b505f46fb348a9715a02075962cba9fb3d7296925d9524f08e0b1d5ac891ca1a4dd5dcb32beac90922bdb7504a1480d8840877b360b6dafd84581349a5869e9c10e863cc7abd6c1a724eb221154cdbaa89a43f83bd85748ac7b3a3fe36246ccc36c6d97e9c6f1db1008776e59ccbfb7292371fe0ca01bb050d5f7583b9d2a3e3e8db94bf9164dd91a1c4dec8f1dc42a600cdaa4dd149985f0b7033e2043f3b4a398d9c6396d346b2016f45d3798bf06f7cf10327f5bbf87757e16dbf4effb7f3e39f3b8449acb02590d71524150281a05ae3e6413aa99dee047076affc23248dbe82359b232e83dbc5b634165cfa3cec0f50e2d85d153c93fdb81afa41dfe3228de72e79b1d5cd7f41396e4df32e03f160f248c898af6f61e99ddf706b5d166215920ce5f8bea365f7ded9e2cef47513c87a68174785d77c236b3cd6a357480385c5ae863167e43f235703b6ac9bfb706dc9c7b48437a13923eb958bfe6602b4ae716b3efb5c707a82a4e3f0804430978342001a760da39f29a37365524e3b2e17dde3cb524d45e85ee0a0002efb584a4a28967ba407a3ca12aabb97cfc4c729aba0544296d828a31c59735d67285c34d9df55c121006cdc20b0e9d1fdc7f1b09598b41798ca33392b13f7f8ad7658fa119bc43df3ac208af34eeb698bfd03f51830f7346731fe60f36013432870d494dd7c716a82c18ad47c2cffcccdf8217f02eaf79fc93223aad807c652bf2664c0a191b5980257eb63decf70fd8605901507da47e15058b1831a307751349e37380a2c6d4f4a81ec82574296b75a7ea518463683f719c4a8af1811ecb9d7dd206ba17c713018c2bd3c6abdc74b61a7c8f526149eceb083140df989800a09f3dd6715d7a1af039a8734752f45a65a2e61eb048a9b87227bfdee4324ca028ad6e1244452fd0938ac1aa244c6e9292b6aef906d6d3396d2276d3b4aa143a756e31a66cb70605a83ff7184913a56f84da1b3e5aaac620c0bbebe0cb15b363b2bed3e8667a2e231dfbb6d0527db631ff8959974cdd6ed3cfe716a55b005c71aac2762215a99f9238dc22e8e8d4197ddedd83fdc594b357c7f207266b94ef8b934a7986c9eabb092ac29540f8da619b27da0f1a57c2614a71e377b47da5b1add8700fd574f3390d42591b6422c05b074c425b52a2164b96df0f8a1130d2df29ee716d76f313e162ecac8aa5c571e8a39e67d15bf08e4d04dca955565b0f630eea4b54004cce121fd418cf965f6525b12b5126f9335229675c5ce64fd9766254f38a403f7f0d4686bc09226d75cb45a94855b018b20fc2170dde0930a09e4bf1a19af384becc4140c8aa4779cf9ae1bfa376a1a36bc5d9da33b45bc8ea22892491d03a9194a8386011114c821c361cee268c76e591e01ecbe4177578dd61acdb4ee31cb3d93aace78b8a4cd6613d49b29157e4a32403036780dc51097cc6ce37ddab9ddbbeeccd2734c8b4bce678447c75077d71804476a7fd9dacc4dc3b2f1ece3387bee8af50ca10d17f3b595ce1beb5166320ab59d8fac06cdc7e6d4c01499332666a01889bd4d4857e2d1ff5e8dac89e6821da0563ef41ed92b788de568bff0d1b2f3f68731f134aab781e7e7d68a08722887c133aab150778b62af883d5d41788bc7d110c1129ddc821456bb47228307ff7331d7865752f3a039b80e6995142eafdf22ae3df3326afdbb2f53aaec1b79c649e4b16a778c8c4a3eae87a10c3903b2a839cefdce39c30fff35de2347a3c8eb5f752ff73fef3f8d8e34fa0d90f87d8ed2bdd44ebb07d384094750a7401ce38dede52103824d8331ec8d813220c57a0d0e00c6f8a4ead918f9082832e6f0e35bb6ec2097ae652be295e85737c9ef911e43616d9e739820127f534e3325184dc7e9f2e174f3a792e22b6cd13de3b19e46081069f0b0db50e4f1cc2345c6d70103bdb4fa58e77b435bdef0a27061cffc7dfa694093541de217872a1438bcbeb8983b6cef24f6f6739c0d0d97538251d020eaae4272a5807ea079e9b2d4b70d1afac98482f4bd3c47811794a410fb20d59f6d301e1e754fd1e2ef281d3c93d3d6d9afe41b1d0bb85d4d47fa0d27166be18e31d165da4893f1425b2107835dd0396c9ae57858beca7e7282ba900b92cc487ba5c996e8e49d3d5723f5afccdef94d7c517ca27973eb96cc8be1004355894683a4601f50146f7be180dafb47926e478dc8d61e9b501d6f29db9584ebb665d0658f9dfcea93a1a6e190eb69192e89aceb27822a6c25ac0a2c9fe6e88ea349197d7fffd2e4cc16b7318f10bbcedf887f04d5fe138428a4b16e1aebecb6c8ea1844f9176663da6ddbc4b5af5bc7b93da5232138bcea7e64cb84be5e380749e5a005135831fcda393cb9465b63999b163dd58867557e76e4e8d90b6719727e8ddb98589d4d1aaa757d4034f2cbd371857a8a7955d9d5ebfd4c0997a992e3cea025e5ad1f14bc2aee67109b0c2de0ed0b7fad4bb78f584b9be8575f9942a7e7df9e978df0c5cbebcb9d02cb4dd76996a12946714adc114d211e8d1c8092cc244d64b61e10a9e13fc1b35455741548f6fee3ced1a1f96c73a8c9d0cd05e777527039ff62016d5c4bac8e02babcb872b42a814034ba93c58efc744545cf59b249147f039b5877e509f0bdaeb352de25bc53adaf2832d792f4fa12bca5f69603d59dc48ca4adc66c7fab5e1e51fc4af7422b2355d0cf12873b07aa73fe8130e9f0d976d07cb25f1dfb0ecd0d2c54625a264afc73bbad134ffe6408676ebbb8e8aabab1542c37642c650b4dc424705e0ae2765ba4e8836e200ecd5567a8dbce10be7097a97fb038c0bce6f94dcefbb38f8fbdb07a12bda120eb24d46ad78aca660efd9b7033228a0a8f93fb365a9375e4603deb83dd8e397536de23f26f822e2210bfbbf7b9ac81bb4414d451f4638327f9e74b71843dac562a97ee792112bf1be1ad1b02819252b13db35e3991db09b03bce124f9c9f9ce1604e8e3abd50dd25a4a2c1882aa5d6236ac6fac7ccf207203e9880f571a2beecb5caf71f9f113be14a50976a1a946e60ab49562be812c3161ba82b2d19477bcfa7be293c15f2550d50a072e42afa05e9ae191b1144a6becaed894950dcc4e17d4db5f2045ae130ac11584557745ad82b38130833ad941f4715187e795701733efddd583bed354aa95d32db4c07d9881c366e7d41103bd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
