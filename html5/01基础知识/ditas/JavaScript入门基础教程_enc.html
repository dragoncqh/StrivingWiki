<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"37efda695c741b25ca95edd568253261216a96dd07ac9d9434340b32a19367bb281ffe44e8c916b66c22dd4713f7727b75dd623151ed80948cd24c87bcdc8a26c3af7cc44d73d525f0ab9e375269ca18c64ee03df3359fb01c8abcd3ab47e6ed483d0d76ced8b637852e648742aa9b0767e4929667d843eaab028a397ec0f8c73f22cb8501618ff292a1abc23c00266abb0d9f9c52b39b228c315973baf25f4d3fa65d45b157ed7e0a3f53af9a5d436f8e4f873692df29c50f6546e17166945a53b370dc29c2e625d4baab60b0b4b58dd2cfccbbab3756f38be2d50e15674ab0d02758e64903c974de750bc8253e06cb1a227192749ba229e2eb817e21e89a2ccf6a16699653eeff2549ee293720ca834dbae41068a4bdf55c1d5bf71b2baca0230e8b5897167bbb6b8e82c8256814f830d54462a98da69f6af2cdfba6f90c1e72dc39fc1ddd46a0195bf10da8c77c5d4205366b42e931f787979a5d5af0a9b674f96cead24d801546134b3c99760d8a7377ddc59332ab9786a1194f09e74c08fee41b85ecb84ebf68b2469d636a302ecb456a925f976cfec7c93bc5b01852b522c87ab82d121927fe7f1ffd89dc2a4a6e2d78a48bf29a1b1f48fda72c41200751507f7bee61c77fd8455cb5239c845d0477575d7009c117a0c75a5aacdb71b09cc326edb1d36286fbc102a8d6bb3856836e1538c3340679affc7ade37511be9ce4c5be6e6d1ea88a0a5a63431257b9c6e9d1013abb1b848e4e0b453609f41a6c398ea5423e9f467aa3ce57929117579d2050bcba8c47f3062075ddd670639d80533dbc4386f388059fe1fe382cd5f1f55394497b05d7cec3fcc8a48a3c8f7faf9397ab6e6b019b990e23cb3ca9b95baa5c26b8981dfe3cd13c8db0e90fd1630be73599a6cb7f1ecb666179a6c04b9158d804a0140e86ecfc824c8be4d79023293cac500849f86694a10fdb07fcaae1b5386a8fb22f150fa525ed8b028421b8110e3b879d996cdf68ac44e35d58b0ffcdbdb55ac30fc7e0878326a0484365497b5d16d9c5a7f4182684e7e87f65cefd4fae0d933c9e51b7b4a1e54669d2db5f6b99398ee073c75a6b52a827c7386492bf6ddae5f449fb1a73556804c4226d64760cf5f41ae16e1ee1897905dc8e3759cf86c4441e6e5beae113bcb18a5cb494bcb9b5adfbf8a0bb60c201002b8a91957a4068d8e9f2fd69ec9ea3796ea3192e934615dbcddf2d0af1426ab9d925912d2b6a02aea5d9ed6103d8c1e7e16bab6416aa76094001b3e71d22e40ba551cbaa15c5bf7a8a7f826dbc525c451291845ecd2a461e85101fb2dad04a7428b1805eb73da88794ae25b07892e2ed380b2916ed2a4c70fbd93a4421b582598a0ab72508a8a2f4f9539c32ef2e4100fe5a9d088fc3bbdd4a913eeb9ec98948546fc7d23b1ec081446b7c3200e62b63b8946429b211d65bfef9ca3ead6f2d2a787b4db66929d579b8399c8c024e4eaae0a41f3c03c8b9ccbf030126f1efacb0fe922970fdb90e8d7d370abfe42305f7d10a462748de6ed0dab5c6e000cfec656cbc61ce1f040ed2222ce0deca0846fc1985131b4bb1d5dd58c711bcb3d00b491a57adc9e59cdc3b15bad9c1d1c733c3e094715c3f4c7c1553f863458a84d8a0e0ba8def9fb5517a78f02850924c0d231a190958db37d7a28c377794939dd5d7374b73d0f31c255a702c64c82dd9de22b9037dbdd19ca0610daadb337d6f21437854a3238c189463663e2a1a747e93ec431834251a3a9ad13d2724599fa29744e486efad4de892e3198433f5ceb6acdff379316d9db7b802ae4206d5484b693ba75303d54c1ced101d89d02e09c757e09a4173ce80dc18dabce0f9fb444914b4de9733af76d46697dab52154f7bcd4fbbe7627b98d8baa02c87aab68bb269673eef89403721d8c24840ac1ffb5be4123cb336aab93e625bda86fb000ae82c6797ca63f7293006aab3a9bd543e0c7f8079e2b40b0e737af9a7afa105d58fb8e8ef1f17e2b4d2d8323aaf00944b0c3fed4d753cfcea5f07fb72b81a7c851b2abd99aa28a6fb7d8ccf8d10377f63862f48d0fe614966ee5ad8f02a516ba4cfb6f90de24a06d884cf105807103185939d3cce307236dd1d375c65af0f0e40bfcb9a0d4dcf20db3944c55e398b7b7b347ee033530a20ea5f4c44609259080c3ad419a98a831aea5bf774c5c88b03bc8dc3f1ddbc2d7b31703abcc67587af28f1d61e2798d07815a384a66d6d2e441328dd49406fc38b1d2e2b05664a2828ced4251706537ce4675636196c01d034192115c12a604d11400602a58db707ea806bea587d8aab03140e42c5ab2675743c71aa8b6503f766917ae4c29d83f0520a3eaf0da7f1b11aeb94d6ee65b250e93b7deeda24eef1ca2ebe418d573a1bbbeffa157f225aa01ffd5be0ee29f1e588e1cb149439f0d42c17a2f4dc6ed9b7aa0be81b110c5231e5eb41c25e83986658e164e36973ac5616b3728ab41cdfc892a67bd40a286876523c313f7a9d0d9456463b8104f708e543b353f082515d88889f6bf98aec1affe238e4b5e6d29ec554f25aba942fe9fab7f1d65479ec3abd89212fad5892bfbd955eaf0f1ed60ee5decb061104875b5553fb4679e8d244d6da2a68166eabdb89592e70a3565245233f767b531db69769294e7bef3d1504e399ac50dcedd2b9020b555ff4270ee6fa87ae164fc5f57585648b5a3a61e554e60dcc95a6516d25748e53281b82b9a4693540c31912a1b8f1140e83bbbf319826373acf94034d434db341abc4e9aa81bd784b2dd927161bb92a5fba92fbb7a3f84cc331ddea14fb3a260cbe857d41314e64ab506e9818b3ffe09e63d92a809650790e31a1737e2d764a994a57a69ef8e0b1ff743cfc606ae6deab8780e1f862184d64608e7fb43f856078b8c8fca07a2c074c9ef28948aabd3406b6e1e04e5fa4d6c223c8cf12b3a5ec08626d05ccd57ebfff7475911ace8631d25bc9f481fcc64fe0eb8247484d713bd1d0d032736440b9ca1e94013ea7207ad95ed54a8c724a05ad3a50e6eab624f115f219cdd92393d816c5ea0fdf6756910af1d55e8ebb546c4640b9534056d1e088ab86eabbe08b520db3fbe624b848e719406c9cbba7b319421d58868a6bc15a9da98fa4ac365766992ff981e7e14a9a38d461281164110b0cd5dbb70d2254d896ea951fd6ef009ba61b47af6c2b991ca6166a3baff6634984319f0a12e4ccf5d53da11fdaec14be7e5989e430b67188a90eb555366dab609673ea304f57f9bba617cf5c4f7bb5b93e92b08a3d7a9b2d2dc0017e59a3c879532b45ab779bd0ab2f8f26184b013505f4cf8d453adced03ac1968212bce0c87399f433310cfa7daf570a185ff1ab8df375ef446fa77d4d6ef3a2013f2bf6eb740a50c86cc82351ac445d37d9404112cb4798c66a7ea19e14fb79113dbbdc78c0a6ead4736ba0e6c5d6073b3f3933c857d9ec949e288c832051ec5c8744041dead2a5c9d79a193305588aa31486b1796cafc9fd03c7ab59d10883d48d134f2ae9aad33d9ce88c458f7c5b954118a41bdeef7b8f2595e165426977c903c94d138b82c8ded0d9a5fe0150241f71eea4d97b087affba6e306262d153d6fb2a10629921969e9826bef5812f6008cf8e8f9a8950fe2d9d06cd5cb347155cf033abb8d760f86adda01f6a335af8155752068c1308c7b5469bc880295cb225e7de587dcafde45511261dbf2382040da75f3a4621486d03291083d2700ccbb6550c49461b5fb48beb05dd735f26dbe6e673139f2c094abdd9854b05c4c678ca74ed2e136965d5db51a336f6dd26c52dad1bcbd9cf4a3b93c922e2f19ec5a5872359b0e88d0ee4fa2c53f829a8c301eb703ccf2dd2888e124b1f06b36ca2a1063806f0e1f71205d92d28c6414da8081056ee65fbcd7d3e4929412554d058dd783e5a0d064381bb0deb8b62994b29e11633178d8feb80cf2b217f7da1efb3308fb9c5ffb3d688ee7a3497dfb1f0e3095d2e1da3c558762958d0276694a4ab30fe0729464fd2981a6ae31399944439375b14fc350c903e75f3ae756cb8ce984522242c46417456c885dd5c17430450608805c26276ef47bdda0bd36e53dc67ca6375359019a7d06bca41f047f6e6d5d4544f877260ad588d5fec5f323e3e8d539fc3225791dd849e533084cc8b1136f3dbbbc2abe40b0b6defc88cf6992c1e2e5d5842a1e381c7a051e18023ee14eb08cecdb54f4f9cbf01d386e0b3185ce54d44aff5c1a253d6aa55b03886cce1f95d4304e2093afd239e54b1b4b466eb51bf2a4970400cca8789b8716a381be5994b795ee3970b2dab5d82f17916b175fc31ced119b2ca623b2d031e10aae8cb809abdb0b64deb3114b67a20c16dfbbafaa9dcb13c0d6300ab30e71a4d8f6648f55bffe70e6e7a538186285cd22ae59f30256755c585ccaae2d31e3f01d1b871a60d45358878798ef3e6bff27b649f585248a00ae71d4a41146bf6a55e2c687077c9d28b960ce6d9b7b1e23dad35ad5d80a9ba28e1f2fa6a183708ca25a9b93ad02349b0a9e223abf3064b479572c6d8ca0d478c1234a320a0af987a3a47a609f92fa913e760c795bfe07ebe2457c1de44196d7d6fe01caa7ba402e025997072bced2f7e3593c30bb062bfdcebe91d1e312fba2561c7373258a5ce5e892d8817b19b8548fd2f7c9e86a5fb962ae8be304cc98ed327889e4e535fa6e96319617a5b91e15ec5313ec288e0582cc2c0da9b4e9ffdcf022b4ff9ffb7a4fdf5efa22e524615a1dd44b0ef3f5e7285f592ea0d8c005439747c05ae7675906601f7384a59612c5e0d9ad923fc2e7de2a223de1db9e665ef18bb76df9c214c1e578a91b497e59d74277808328690c0f82d78fcb708d7253fbba851fbb518ebf61fa944a0f5ad887045c378e4da50ba97df961dc665828c68098bf4580ec4a1764efb2258e811df70755132a858af34d8e8ed85455c05467838ca18891760610ef96dca6f4d3feb8c8bc51ffd67170c19633c28a94c3bba24399415aba568204b0531a67905a6d7b1d8fb2967ee02b4bcafc213f8a73d8553e5e7a6be3987375577ed8dc7f569330dea72eec61ceafbcbf06a675fe15a10da31ceaa7aa3cc687a852dbeda52e59a73d3879c40a749fb0ff2c17771578dc41396f3fa77b175ab874b4bcaec8866262f7ca0f7fd0cd1c8332a67c24dfb7113ab7f442500ac636c7cd0253b683e58359c62f1e35761fd96ce9d845141c211e8e28c0e401a7d59fefa0540c83a496aaae7386284d07214ce5d4700817aba84849826ef0a316582e19cb4545b29a05cf3dd902a6c2827031ef1dd3266865f6792a1c20f59b77bcb2f692d99f84c2d511878bcfb8c1bab8d1e988d1d7f0b91b2dc7db23740177d06b5e9158486eeb76bb955ddc98fb06b1adc93ef244b7f904c6fdc6ef5561b519aad3daf2866238435fa3803975dc9f796f4fdae8585828e065f3def7b4ffcf0591520393c9946af08a07aad319450874b819b9aa9d20612d937d233e56c6f159b0b0c6c3ff8d113ae8eecebd667d714bb7364a46733c35486a5e878b1daed5681289f343aa3b15ee23fa65ee7f7e59eb533f282793dbe6a22dca02a40ecf11dfa4ffb633c067a6eb2dfd6d6e97b432fe2b084e00da52ff792e74240490e52117c3eb1ff3a659be67cb420cd55ecdbc32cd480fb90f3a8bb6635cda867c6766f7294b7c11294c9156a4c27caf5e1811e8c7324bad8132466400d337551aa140e74ecac03affbb3c4b8da708038b63c18a12a62823ced7b4dfd10c5c8150990fb4b6d6286a8c2921be85b00c7beb7da3883ea3c0bc462ea466caca8eb57a242a88eb794eabf2676615fc978dec13f1570718cbcc13df2eed93a9b5ea72521d9283236b8acfd5b7f098bdf96382e45921b9d9ae081bd4e8c24c17a77bc58aacd653b8442f4f66d2632c5bdbf8dbcf0015be1451bf8f749d7aac79db3bef65df82deb282c3385f92e1fb567dfeab0ebdcda521ed65858d6da212a414493ea49237d16c8231f9f095ba8a903145a8df9115a554b0185e5e54edd649e23f941128328d25f8d87d7ec42791189312394d01aaa63b4422eec7ac22997f2fd74323f9a39046b8d3691357c70779531f4328ca4575f1576181dd7dc1c7c6d889aa4d42f1f3daa9878fbe8bee633c2c37125ce33939bc8cd4ec404338df227155f3e63ce9bf7bca4beca979d4ac6b36dd00cc969df5537269a0dc3471c7c7c638520562e5626d32f739078782831fe970ddc2f9020a57b35cd1d7d4560ac366f7db847d1727f951f92612c0ee9d256a25691bc8de63fe4db865acacdca831d92a2b2f947fdfb02d60abd2918e03828724c310968c9c698e44234f02956c2e1eaa374cf8bd3a2e6869df5f4161e1b92e805d51070e19e908b272ee071f62760a202bc4410cffcdaf198949a9d88ab8f50f250f1fcb705ca67404c5db35f2497d1a24c7687f6d97ba31a3f82949543900c01f3abec202f928874763cd9b1d82bf51a4480d594dc4c279f4ac67bb0b856481e35856027e6e605cdf92c91ed2b6c181a6726dfaa83a4770495e9898c16725c56767ed7bbb5ff493ef2c8edb49defe8fc45851ebada2410bd84bd8dcc0410e491b59a84281bd35633c891fca1c255614da1bfc86ed18d1dc58454cd7c4fc88c54c76a3f3801c85d512a73b96775ad6f4367ef1ef341dee970be6e3b1c1e2dcd663510b2b5abe7e847b3e174850d13bb85763d3a191e6458197bc9ff14483a19b098c811f92a47124b5fd6e04423647a7c740b17a57af3cc6712238143250696dc6a03c14a9a8495761fa59845b86f0c65973e4ec97daf083a86206ce377555a22cb2b7caa63e53c1fe34ae596841e97d304a9534f24215e827f2e794a03959943ffa6da53f5cc6e4d5acd73f23d13f9af045e4fdfb215483c8b62bc26e985de2cac4695f3fd97d9221695eea9b405ef94aff7e6b67be1cae5743374d7b9b29ac5e0d8b22db36372e05fa53e0e035e1fce50ac779c1c5fe11f5f197b26df081fbdc5692e46585bfe7b1be0e82b4032157b798061197fb65f7286130741f5d5335cc994a57a52839bb997b4f41f38d6e218ff5c3a3c7365c99a3bef454e4fd67cfc3b8e41faa91cf36272a91555cde204b4d53a0c09b64446a06f2bf8a40c967d0cc6cca31113c96a168acb37094a8537825bc01ea188ff31b70e49224226514ca1d5bc224d7ac615248e6bb0187b274c82af36b09ae2592e83de4ffaa2229ba40621f7e8b4d0d56b566447d96d0de3fbce4584249196c0ca7e25f1f5ad7a0c116787311e5aed631ad5fbc24c69e07652e671d383c8b96fe1b103248e6351aec78d741854a05fc972152a840daafa08b73bb61050b3403312da13837bdcdbb2f15f994ee57562d540cf4bdd9ab8532384f0ca876185682c6fbf1db48de84ddb1ce0d196a58952d1b073636c0a13e14e0b49da03b86e15db9f756a29292dfc6a3b3fa3bf5e1f40d591d17f4c0be7f26d4a0e31d4fecd550d29a1f2cab9460eaeccda9ab84afe24a62228cc5a64827f528f0be9395214dc9a2b16150550ceeb8255ff6d4b627c3207ceed39d05594ed551ba32f2f1c2b6821770d305c94623322df5ccadf7eba718aa24837b1b780fc5314d061f246932608c8e35c384f279cd4a3ad084a16c700678484689bc790d29f7b2da9ab422a202dd1fbfaa71817c3037102d44007e70262756d1ec3139fb424d3c744de7a7f005dcd654fe017618ace43ab24fffc2819a334a01d99b8669f548bc15a35d2732f9251700b05d97ef311414434bd34f2214e418b98b50b2d666580f3fc2fbc7d6583967e2e40768c3e9c448a233bce0d90a7063578e0f147c29e64896f6e4b57d8c92d3717fcca81234b75dc1586c9627c331fcd49de8eeb9ccedc639cb0dd82e957f04c4cd51f4aaac84b6aa596bd66027efff6777acf2c6f763eeb2edc8ef3d60a17a7bd597741e40f69c68e7136724e0bd975f99b161707f0768f03383ec963cf5f93866d16757668d0f2c415de75a7ddca937882d4fa2a7359646a47e26a750aa8440f8af8c8008927babc7c3f4a824e572b9c0cf45eaaded372247cb80fd1e6301087cc4e76fffff83cd4c5857a32547253139bf686efa753d84f7ff93719aa75f3c6fb596d334659a43fbb5f46922db6b6dc8917c512dc5e6a6e25d89692375916747d5a69a1e157919c42f9284ec277b076e23e0a1d83e84274c810a674e7344b192a7e9dc2f5daaaa2e3ad85eade3ac1395344dad7b284037cae91145800daa6f8a4a664f0dac6748b3df04faa57dc742b2aba4678373f122b07ffbc9111885dbed3c8c45e53e0b7ebd6c75aebb8b180c55974a92f45fdc0c273fc51bfcd7ae9401240f94b4e2356a437ccdb228cfb79fbd308c5897ddde8548118d1d0cafa67a721a3bae831270b63cb7669c45b19859eebaed03d09ec1d14b828c7bd416f65a8beeaaba1069bf41e4abcf5baefcafbccd760b7272b2d45ef9784f4971fd67c168f37a980f9a74db8713e8dd026782c65f171f3203ca3474c29f3ff16138b40c4875228a957bc90c3f9330bd6defbde47d92fc725a00572c4a835b695f604b47e98694386a1d4b86fab52e15b0182cee0a8dbd7fd7cb7d8dd26e07368fceae81bab29a0721beaa8eba00a3373c0101e5d42db194cfee1285f8467cce7a804008dbde6355f85169798d18ba57a6ccbae863290d9c99b45ab5832cfd5fdad68a916403461befd049e2f6fb91f4a327ba58fd73dc47cc487e21d5cdd817eed081d4ab5c4b1158b501bfc982578eb44d4c67c5e8fe980f5e108649b75c8aec1bc482dfd78eb617b156c553d95987c3e76980ff41adcde300072cdbbd1b35cb45015777f28d523ec38ef9ab6b21c95ec113599bf7b69046d0cfee10a5bb76af18be3ad02f79a242fcf5ba314ce9ee0234aedb3c406526ef8c8748978f9c0d7de173f571be4ed46b6a08d75c4fea773636726a2a3a657510cd5a8523b06c0e4abe8e27c5eed3666e2799df182a80843ec0116cf7825ee88a610be17ed4ed00ef743185cfdbc60801dd264f0793505fc36d95bfc1a41b53c88616db6ae36a26d9e717070a41988c00a6e77627cb6383aba01ef449dbc0b19c394c8186a38b64ae504fb1515cdd904a00d546df6e2dfc1fd108a2505a261abe73a41e905e38485c73c5200e8f5764eea4446b2bee94504ca4081254152f779bfdaa28efa6da71d983ec0d4e02fe0b65b33f1f833190b869be33ed673bad730527f91e88052e41bedfc6ef0da3ddb2db742202c54b2c3abb2f0ce5a01213d623fab6746628e7d3ee2da50ea64fe5d9713ffe51ca16db3b292bda2ad97898cbbc86f9fb91828bd63d354764cbc8400461b241c12cb16c4bb07eb99ef9695d9c7806d83faea9ad53b8a3f36b32b8622c93121f855d726f00a6a65855a0f771091be32189f71241bce17ef901726678dc1dba6c731ac29c712738878b88bffd03c9bce1bf7d32375db397ddf9adf7715df306a8a414caa8ea792290f01b96f43a2198318050e86aed0ab144be898fa2b771e9b81f9dfaad21e1c628ad90d27e28d4e35f02aff555e98ff071ec7366f3e08f83eb3e27453b3ec1da5720551aab231be058b3ba118025252ee0604d99f7f35cad3d2179405361dc73cdde8b49e86d3c0d18ff510320ef6a87162212cae194100a6c32ea9d62206af80129be78dcd37efa86fa94c25278cbfb0aa10789ff1b6993a9c22b11700c863b2e3a611a40fb93f734f2bb8c7c68a2f900946f64c94d2c382c60755a95849cdb10f5652c153d186e8e522064075fc8fdf38c9dd25ab00a26a7f624214e0ca8da6ba103fc9f525c680a9b5ffe96ad3c1d1d6f2467a2599034246d56a43b7f71ce5c6d58dc75b0ac743027cb7a3cdb28f71e418839b81fe2c7dc121de9c2f678581aa368035f08484e7dbed9adeb403aec6fad6318106e679876ef96bc143cec4b24db3389e27e012b316e669ab8c9ab5d16ee0ef736dee669b92cd9f14041985e1d0108755a0f6081860b17511e3934b077555be67cf62e62e72e8b5eb800770fe57b714a134681b8d7e79b29756c002ac316a0a5e5953a714aebf257cd91ecae72d810f28c660913d7dee12980a999c95832f757124d84c33b275950c3a9012c07175e8537bca3a2a0f4595ca4c005189fb56cc0688ac857ca6d2a407e41e5e1401b4d15083f2b1ba5177a8dccd4539fb4d2a0742ea9d35bbb99f693eab74f2d1b461f6b16ae175100207345f9947fb051e851e50b28712d05262d4ce3f3ac22428bae0261019539e5faa46c1d04eec7bb3f110d66dd42b48fdafaf4fd6d3b7605e02fbec105c4eda7ecf290fbec909aa4d61b2d71510576cf56fcaca07ff452c574c1f456dd7a7a502236dc43558f6e03842846385f86eb8921b0dde5767f4111a9f3c07fc182c1a5083f99cc2b687b762392327da08e27a478d672ed82d8cff728e5722cc7b3a5e617e2685749ff443a17d92f7f3bb3f8794d914875bc9fc43468d6036e811c93c13dbf93f9f02c843221d1602ab9953aebba2f27947d400bb4b7d72d965b91afbc336dc611991eb342327a6ed1bee703e1fc7119bc242f7eea29d8ba68dcea795864aa5e0b9b9d2debd72cdd3822c2d3abecad934444d596094cf436720c82c0cf9adace88a5334584e632b095ca6633b56be3af5ee46202eea6f75e51ef2410425c55aa11af8579c0341bc314b7b71a1fae0f45fb08478a8c6929bcd62e3e77f14e1abf1c3afcd26861a8d14d0ab2363742c608e78ebd6df21cfe62d50a09ccd532578cc8e236d3e86b2f4e779c39b73a78e47798d2b5f4ddd754d37fc85b88548abe403ad1c839d09391ca6bb0f3d8e123fe22cc1e568b1d1be30bf1f33fced899243d5d6129e333a7fc6950a066a7028c63f3cc4198bb20d93a1c54111e433cb238c5626645f7f61ea91be862fb66ec769cd2b655b45a0b36e4022b6f8af9a6c7d774b2e8fc18fc0623402440188a33cccdbf71defe309e8de2861ff4efc8490c9dcd9aa4eda5d7bad21d461f56a4a31b5b518226b722ac7805ef5cae1d7984c93bb6139e0d5e8c071604ef0dd475da65690a8b97b64193fd9bfec9857d182490a8a48c844d6aa22fc78620910ac2e0357d55dabf1670ea5060f4241819f069cede763f5deeecbe6d73c21a2939b394b3b85433629cb2928a5b805640b167f7010643e20d598d0e6309b262b2586b7cce609722fd956528bc6d0d1652b0e8a1deed4ccc72f517e2ab5049328fd79fa06531918bebc0ae3b08b38479d807e2a90aba5b2a603626e1dd09fd10388fd76cd17739227fda2c2ec8e461634250f9a210bc89a12634c06c7a258f4ae4225db902b92e222c7bc2729ef074332c6281f9d29372bfc95513ca1da6303da306bdf1556253915cd8e29251a8013cbf4a73f8402802a8aec316fdc32d41efa27f47c660e26367f0f6a06bb1bd95f7d0e402877591e4e64caf254a23389fba89a6051604699f5ab1ee28ab7bae190eeb6d4a15e991f04d4a93eb4d83170b204fe643aed6c8432ef59daab523510168a1be55fd6c7bcc155f4100e89bbf91f36ddc955efaad9b669cd2c278564f5ffd11ae93f74394012482dd745c5ea6c7162de7498956a1f6c3f307fa0a6d4c2667639b9b5c5cb79cbf448af58cce9e2588baf8684acbe2769821053a6cd72485d13ab17718e9c7bbbe52763ba3a9d28de25b9a7aafe8a626ca92a211a39323cf3566b55e17af2f99a8f3a12383e6c869a8c489d99831d7810bb5376ccae0f7bd8420bc0c97cf2afa18e84c11f22574d5600e57b8860c36b1725d4f250494cdb6fd17c73425f06f70d6138391ec7493f6010bdde649dbbe54a1bd3e532e5e2bd49dbb4adb3063f6705330893a7a4e26ab0b9161374fad4d28b72b7ca8305da58a61fabe2184022c7b884ab98a7b57686ea46bd627d5c9976ce417c2f4021838e262372930f6cb21d8b10c6c6c15988a94f573fac4cd545910a537d0d3e5838df457bec733406b05701f928324871849177eefe215cfc2101eeb1c2a231b05ce1314b27e2fbf35eaa1d2e330925ba356bd610a51e7519e75f1658a53a678342065640854b35fb254aa49cf6ac045c937383f8975ddadaf01c3349cb24b331b554e438a86c6ff6c3eddaed0cb022ade58bdb30df574c7c96873d7af4d4e4d24175a7dcc41be01f0fee1096f90a2dd9a05a3c7d78b1875b38c135a1370e056cee0f1e5234022c74c718c896812ba4566f2c1250cfd950b69dc4a42cec6c4a9c5d94e8c87f079f16db59f9d456958d31e0bf2d4733eca4c6c0223435cd4f2baf9537e6e38b0878b8c5b7941637dc0dbeae5c54ada4c9d123c7c789197bdc214b5b6190e9e86f20713abd7b5a56ccb7a470c7a1b738b684c7747dbf49fd5f1587bc3f2438241442730716cb9bbd12182c3df1392ad78f36a055f4708087d31647424d09f614647a8c8b0bc33b5f14e856bf2a6b2336229c26e3535cf5e2bf2c8cdfbd0314259dc1e94063973e499d02ab0f36de69718517e668c23027e9d8dd27a2393132c65017d8b9da35b0120397ca4087a65cdb9c388d3f4a239387107f8eddd778cab4fd126592fc1c1cd856e385dcc7cf8c8d6f5fdc7cc810fbc11bee4ec644d0a38291ebe819b516fd519bee98116acd1994b80f592f59067bb148386eb03bfc5d8e6b0b65b6382296197507c6f74fc98b8630d47eb8d11c0dd54f09f120b420cf4b40889efb5ffe634293df3f1515205a09b825ac547c5369a426e60f7936e5714bb47655539ea38e80bc820454a3b228e926586931a4de92d625af8762cb143510e2cdbe7012646420671baafc17fa4df3234ee98dda3cb4fff7f18a7104ff83c1fafc531b76a44e3ad2fabe315cf07dd2685b06fbba24850c8e6b97ea68a2578abde9b8612c3f01ea88f8f82c7a80534a6f1028e8a5ca5112d3da1e97af90fe44f306c317b99dc84d566870d75be2800526989c665369c388c9aabdd63471fc92ca364344d93fe5cf1b32ba1dd8314f9875cecc173c9052b4b0780d638923619c68b512170518ed56e9afa63ea0ab8397d45260c01d4e0c04d1e49efdf8ccaecd18fdf578ad645a0774d4e7a0a6861df1842bd1f7b074e67c2dd925215bc963b775fb9648d5d31f2a632c690495b3fe08cf82526ca8ffc93b081373a431861bac75188477d29a2a12ff638db97b5f3e2d295b0073d0c34221ed0435cdda183c9a126657a575db5ef928565abbbaf035e52ac32110870cf553fba9b76e9bed124a666d9ece84fa472aeca9489ebf7aef055f86e33f1f2e2f827696718285831358f4d7e8b5f7115ad1f4ec56c353a144c043b7838e74c6221a1486d724c3d87968c806587344a10f1d038ed1539b3cadd89005dd293cb5a764e235eff2ac30149809b479ec2a39084e2baaa0b329a2df6b61d66af73887d3d7840a218317de46bd7d2f1c3967e252cfa132dc956885e47584ccb92b8df91970728913bd6b95a282c1f140d23e60380e236d33d2aeca43c2fc7d9f0919d203ec12f87adf7f5c6abef44c088565689684441a768a53b77c433fba5235f818d1da47c02bf1e4e3f23266a03a92c0cbdeadae5c2aef90e6301dff03fb79b85c44cdc3546ecc5d64fff5d5845dc44307593e42cf6e5abf29a82aa47b58bcf085e1dc752d86d91abdbfa76661c0f735aded2a529210cfb8c33cbcceb5337c31c22eb9636ae97ddb15e140bfa2ee67adf36f0481eaa08d954a69d3df56719a12db8e0ee7b882d2181fd2532032a64b87dba383164ea52e45368453a509c8dc4860795a261deff34803413d5604f3a28e4a93816f88445b4c28275532410b0b1f6e030fd84f3071ae45980376821840106ae7d0531743cb24a7eb2885960f816f735efb1145ee9c123f19ddd5eba025a76a1cb84056a113aedef8a9e84be69b64fa2927c9b2612f796cabc690c3325ea29d64e2e334c678f7a4425dc7a3a902e56ef97e9c8f0ff65b7901aeb838fc7b706298641e97e4f3f41c0b9235bdddabee3824f67edd5242223d942f81b8175bc705a4e13013066847ca913246f06a80900d92fba8e3af9df47ff875266c4b17f89aa3216a651d926bc6c48fee7d7c70c930448085b40681cbfd2cea1ebefc44072f3d4a959746b2822657dc3f8aade4a5cdcc3a364402f3a7bcafd23ecd9056118d51fe42abaa75b73673ca3323c95337351a1aecb95c920c22f855c44c568012111dc1ba3140145ad15b66870106b7d59e6145b164b416df150700bb934227cb8b07bebb10f0b1ecc5e552ba232aacd1b2eccd99b27f1e38e87801bf95f85c0528e21e7bb580af0a2904d206582684b4875809a5b05fa6166ac1ce6e83b79829ade01ca9c7530c8cbb02e0796f11ed01d50d4a7a573b67fe9b2792eb691a8082bee7333cd21326df415db3240a00767067aea6d4caee17e2c498c3e07655526a6055ab9cf7386c4fe685fb7e329842fe4aaf05375f11c8069b94aef0002a1afb75785f746adc5f9de10e9dc28914e635cd63189902aa3d5a1bbff05a8c95d23047d00287f9986b691503261e7aac030b1d1f1e4d530c1fdb1a299c00909d9385885cf3b557780a5c00ff3eeffe16d8f775c1bebe1a2cc22aa8b656b9b045d760ee567d339212568ff5ce799ab5f9545ef9f4dd7e5be4a1744e13896231fb47bdbff50432dddb95c0e6074afc6f21b6022bb0cc92d62c778bdf626493c7d04a6c051a7793b0a4765d60e2aea96c8d42b251831f84b98c71b5f7a2bc52443324ed0e3d9015131043d3c59a2111f7f4ac49de85d25ec526d96a4c812565ac599a0560e29c56fe7938ea4bbe4192789b4bad6570e0d69d176b53260faea6e5dd5a2dd44f5087102d4c262a3a58621ef6b25c0b388d14aaa7d8022dad4fd88db260d8504c8423c745f882db835a33f642a1261d5ae667f7e8b29781a6d8fb5574a789234d900704c060d837bc6b43a3e897cb2fe2e105dce06559fbe437b08b4d8bd999343f8cd4204b2da93bde90382c24e993e06367b4d4293764c05bcacb62d4ce0d6b29ed0f233e12ed66b61fb345f136791404be325cc4f85cf708c181b284b8525da68110157849802bd958b448442337c9790196f1b52ebec5361588ca3e800a0eb5d24cbb570fddf9c4e003fd9c2870e49515e12dae76eeff6d1d7a41d5390512e3c424fc20ae27299ba77ee73b8185a4439abf0e01ca37143c9dc151dbac37cfe2326541d10547da4683397fabd2bae29351d3b4254811d766552d541d1200280cf645770e04a77faf936f4d188dbc9bec4c58f7751cfc8e7b839e05ddd9ba647abbc1102b0a249cb4c5d8def922ce6f3678f2bcc0ea21342ae72c6b079bef3a245fbd83392d299666c085e6b640e1894b2bf0198873a387b669f4b926afa092e0a5547e3dde70142305ec933af24bd5c67aecbfb73967c9592538c8e6f1444e1471ef0201f2cdf058341ee8140c409442e06a5c747f69dede7e65d4c6df11a2f05e8fb85be74c771debe5bef0c3717e10f589e5182547fb27e1d4c4fdb7d5defe7a6abcba8d908ae3a927ecb597beee18fe58adea587f149faec6945301f91464f1632474c08a9dd8439481f6bb956762b90c6e3bd92ac453d4ff69949713140e334bb11abecf0fd0a060ff8a9a87d96b10f534c2b864a2f592a6b0722b1b56c6f3b4289491ebfd23b3e2faa653a431b434370b72988a2864712a6c38fb3115095ad5cd744d2818924859231f96ad9a653831c5104ce239893f7808466b1022a2878a1db780de2eec152b9e9649fc18282bb1c0af98763ee873c7dbf213e1d4cf4951af087e9fbbb3f91f6e6cfbadbd5ac90873a2999dd5e32f7d6e288d8aff6e4d439dbe94330df4c8261d568210c7d8af3157a8c064298a5cfde6ecbd3c676e382a42bb357bf7a185b00614207c0306bf8373c5ef620f20a7cd88596ed04505237ca821a8d857b77e889e813608c61b9f48d59d47afd2eb15ca28b87b7d477554db1ed39f0b412f431fac6db50d488e18de41c348427234867d07d5242f7f8feb715508f7f83b4451e04bba1297903da936bb3872be5cd662cc01d69159fffe490ff7bdaeb062c373d2a1739692f00fdf6e0a53567dd457e3c0b906ba3d267866fed5bd0c9c587a426d17937c68dca7f6bdf07d320207b8dc34ff024ea17a86ca6a35ff6f0a4c423a22a8ba90a2172d81e1f419778f6ecce7e20fc5dd5e02a24fdf4e19a78410054e48eb4368072e8eb6797f1653184e8d957bb62a9e218f97bfe250a03e25b7b4eecda4da9e0d3a61bb8d26bb21bbca0cc073bd5d2337c988e15e23134909f4c1a5035a6ad0e77445d8571b6335da3e97e3c5e9a0061762444881766344ccb2b4a7a293e749a70418b9a6b411d28f7dcf7b3ae7457a2ff3fa020d8ca0e7f8583e963638e408842f4a3408a975bf2d29f0358d15fb0dcaa8cdeff77b1ad9abe042856ef16253bd083c91bf9194896375f46dfa865d36a98698b10a03b783ffbc731604ac42c0929a936c929994394e36f9ea0fd80a3e13fda532695436fe9c15b117722e44a6c1abb174a1392f3c356fd782e94ba0f241ec645219dbb47fae43af13a824331ba89f8ec418455bf5bc328808607b56537298383ece81d2dcee5a627554bf27bc55e08f58ff6dcda3ce910ab47ec914836e96587b04482ab1b4cdbc671ec2ddc4c52f74c52c688a522da00505f0ab04fed52e7ff71b5cca82aac2d465ecb6fd7aba16735b67780a8e89a1ddcd5c0f0cbd2bf13f6ae83f4cca1eba47a83bc3cf91d227b90781a703980c68e58d1f12a44e105d348cd6fceb98b2b3376199e5c7ae7a210413d572dbdd5d35d5bcf023d54df4a9f1b00537740e318c46905d87085764489a0bfd1ccb3abe1af02d28dcaecf2f2918c528f14a8d7186dc7d7feb90dbd83ba1a86cf84e1650cec62e54ab3f85e569350473f3c600713fb4ca2d4a3172f6a84925b1fcce65a9c0ea91d378a7802b4479992414b2ed57a3f7cbf9d9f0e232272ab7579b8481e9f073079a13e9a7e719fb3c71fe4d78dd4a56b6ce2dc1380ba51e91a6efeeb4a3930701dd8707f66d7e7df8f16df3eecd89e2f04a95336e0338a63659b0f778ca500f573360fdd5a1e62ccb7bdfed2720c38d9bca0b51e178b5e416b5b0c5495a170f0451fb8bf31fb8d6a7c0d1673704df41072264389cc02fd9b4f094f9331d3eaa65f66be14b6cd66ec51ba0f081e4a1b445fa5f53c6ba0942f108d553a7b97ca96fbc504c55f5c782ce29007c269d2d5417c7807694a533c26d38f0484709ff578198977a28ac8e8240237a211cba977d0f7d8730f5f36cd2813b951b4e112828c8b76f473723796f208b7238cdf6530734ef90bf1580e5bc423de59374465b2764a8fee0f6ac1e250b57f74d8ddf7796e0acb682cfce268d050d358627f0d06ce9b3acfdc074a05430a7d24d00db7b3fc153f46d6605c9e3cb4a5c8bb396e764ea9a347a40c9989102716286b2d04cf14a941a2eb8d59bbae988ccc05655f422686ceee922e0f53d7b1ed749d2e6bbfee377244cef4545a2bb605049e3b63d58807ed87e3e1e526b1dd5133efdb2016245bb25c3fa796add84739ea07699174f6e8bb5f626a798dbd8d8b316d8cce81b9bf96cca689e58a93695070f78faba28ecba0afe0813052002236a788edd676b3fc363d3805bf8b8c08fb914a12c8543bcdf698f3117d041a15a232db7d236c8a7167875a49e4e74112dcc9ca7692","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
