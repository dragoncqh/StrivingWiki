<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3206549c14d894dff59f58260e15dcc88f05ba9a65afc8c9594b4a5912eecdc88343b2992dabdb3ad59744935191a2d20e614ea98131cb6420c913bb0daec57ef75c6fbc5e9e0189241c89486974f354fc3ff3a8e49f48b728ab21c8028565431ea7a89ad75961acd435d2bb40b0d2c2c6175ed77a525c20bd42f65ee0a6ea66afe4ac9aff3ec4646e256e6689f0cb466aa02761af55b294ef8959ab6688a00e0fc0467f20e07f0659e6208bf26ec66fbad33ac7bd0ea8d23805eabe583c022b201baa6089585addceb2f44ebb32ca7f3f27b81679acbc547db76afacd9c4acb5834e3dad99f31d18989dcde751f409242d8f6bcce3a8db56bf089cd4221d1227d014fcd36c0af8cdf6696424aa07db265cdb211bbf97af7483196701a2d017630c6b51aa28699ccb0278aa39b731c1654330bb5c155195fe4fecf94bfa18370e164f9a644e22a20ab1fc0304af1a289c18b0c2e130354d45e3abc41b4df7ad714927ddd57e8d5bddbe948658b1f000e6193b498f88c952de2a836b9344803caf907d4647f0912552031b127cd307e8d13f0f39c8f57ff8ecf5253096e3b7582356d10fa8c5fc36eaaa5c3fe9172ade354e7403e8e0bc2e3e9f4d3ecf37df798602af5a4f634acc8446066ab8a4ee7a297c0c705bb930c30b7ab328f272cfa1c5f3167851a3feb932de8c2ed3d41ad067d205fc4dfb338c4e2265c91447d1f90d7717277d03bf5c463234b1365c369d91851430e2f75e8af0920b8dff10d19267ace76ebbd8eef2dfd0273d753c98de2163b79ddf9fbb35d421c5d984eabb91d2e2b014d0368d07f8da9a3fe336ce6e04d53d904edcfb472754d52e6f4c9a36d0edd3c7d104a2fb8b18a2f2597ce8376f559e52f9641a8bf01d6693040e434a8f0c9fcf13324c65bcf44dc7d7d7889912676ef6b532c8fc459b5133fb250ea18e34510c77e4eb4a890d8666080e92848bb2bb3ec23ee5809c039f279c73d6e49d237e213b5b10579605cedd1acf6d7dfc2c77690a69b9190540f242e3d136be2db5e01e1fe73df1852b90b095b4f01f3934d3c7d17773333a0a0f5712b2895340c7e5cfa775e0db938be85af748ea1af2cfcb3e655e8b31687d64e1356b2f9bcd7ac15442ecde1401e31a6c41afde4a5376201134bb99236593a0c55cbde9252d28bea163196c75de1f7dded72e5ba4454a6a3914aaf4e7763dc3ec4333e21858419e156587f0c4aaa009bd9f2c91625bd80f059f7d9460bf5ae3b667dff7c30a8d20583213bcbddb2f27eab274569ca84290c2aa4bd63e011df1fd7bf67fad68ba9245f862225b58985a10027315100473c35c56081279d6606853658cd9453a2263485389c4df3db2c064f8633cec28a55e5d51ea9b54713f28713f791510eb726189751b9bd96b0b7652641310325519864a0899c6383e378f014ec8ce7e3d88d322850477fab25ad3238e4191b0296f815c748575ef5435d5228ecf8a856b785a2b5398fa61643b470f7c6353e4781c2283250a0d45463c942f74636a54d0e46b8b4f32e576a03bdf4c5ade4608bcc3e740137365951a669bad83ad46adbbb0c915f52d7b3e8bd5e8bb472fda658bb20332feb975e0dba263a9f2bcc06b8d0a13adeb205a0ba2f4951ab2d0c98031769dd9db3f9bdfe98bb46711dec5ce899d3dc2879b9c9fbc6e73fe8d62e4413c02970683589bdba3f59e78db2732d16b520da2ce86ad2e4c87fd31b75bbb2184d934083d4823bc3e9812353c6199f6fe1cb156e853eb59d23d8f8351e7265d8035c57da7a7dc7d87e4ace1a00bade20f7eafc5fe94a9df95478d80c4f2a3e52886fb39fa782c790ad3324b9db5d67260d97d5cb2c1f5bd161bf4287c8d64c1f1951ba2fc89ca36b9fafc9bf8cf24bff6b3e54423f84ff032bb2becd9d3a7e8fce9f8872e9dc752f9a14be905055781fbad8b19b6d3c78b6fe75ae4a680d5f12c57d905158dd893070295cdc2aa68e603dac2154d2afa03c281f8956aa09d07d77e530b669309ae10d228633956f6cf096cc0d67056047e294a6dad5e96eb56d1f7935ab1ccf18e1f04908bd74108601c249d0749c17022ca6de209171388a8d4c0d345e682b77af07c288ce25faf7479edf9738c3252dd006887c77227b9ff39336c5dfd017c228ac1addde25080b724c60c4ddab87c1a10b04253a121705af76b17980c4288fd6fca0bba0bd2e140431932f5d1ed4559817517abc849f07fa39f2d9fe9ba3ecf90697c3d34e154a1cd1a2ec274df4fe4814f27f477bd02ea4339345f9dcb6e12dfa70db68532d7d8523788ef6bc00d8d152f62b07523542d8d389b99240f69e70c693cf8b3f5ab4cc432a8c320495224c0bbe8891d4dd60d31aebe2f0567a5d98f786cc64ebd0ab994899c23deb7ab9485b86b1907612990284c092d2ea1b6df105627092608623a7509a826f11dd16982eff595235cc0567085869479dd5faae186de7c785086b4f5cbc2ca6b0fc6a45d62639ecc97d90d4e020495dfa118713dd22f573f2f031e512836c21ab2bef9b1b89834ec0a2d5723528f7e943f8c6568922915739ae293630b1b12c6be0470671261b398ae5e58ba2fee7c8c7247685344124d9aa4d59aa5c4e2c51b52d34c5859455496583817fe3f1f693952b20d6391e55d0b960947434f400f709a43394d9545dd1c0ff1d4e21a97844e1a7a533612d9078ca746cc3b613c6ad762e64bc200e698542f3866e5bf1901afe5bc6206afb265d4f9780db130e8cc49509969dd71b01aa7bf77f85d3217273bd89ad84c374ffb87e2ac1336e3aea24d381d2975f5857516b66c2680d6fd4502930c61676a5e41f7871ae9a7ee53b270f24e372694abdfbc5b2ab2aa81cef3e093e16f4b15f33eee0ecb6d44fb921a977fc80d9da664b851b7ab5b4a6ff44ed6a76fde8b486476e7a089fced4893911483b183f8c5e0a5a3a9ab9cb6adabeb37477e58eadd1bb252e8f7e9e51255d712f727161f8be6da2de1f18a1cb279de22bd28a5533b9eda3936ad02e21b54b6c202e6e9acdde997a5475a762ec8a86c266e5d9dc5ed26f56ddbc5d9bb78d99f53830b420617990369f801fa6dac91f2c1a9f79d393d3c1b557470e33f5bde17cbd0ecb13b8f22a1c56478eecb2e8f103777928de99590e6e6fc09f61d15b0efa5934da83c6628e307a1996e04c538dce3a0af5e2d6cfb4df957ac1aac334c373c6773517cef377843d55177ff50b6833511c9e5e7f5caf9bcb88fb07662c415962c0c3e9fd38337f5c81648b6ffe617d4de558ecc68a73f0a8ca6b115415b288baee84c8bd4e6f9d6dc13b7644e50a868d6b89672a177aec34299ea941649b29f6b5249d19dea1682e80021828c8b3df7184fae8452fc0258a0063f322f5af67fa237fb71204288c55d9a9fbbae1f242684b7ba9c6796cf3bec0a7c94b20e4af29a4f504f3b08aefb08a5dc4801dce30e320028722f7509f2737673ae54111b30353c3bc25ee34c708cef873874cd07ce523e305a1af458f3de4531d8f44b5ffef49e6a5e101a0183d2e5b14388048f90c1ab2aaf37e783227dde5fb3907552840cefac149d4aa712b16a5f5a7d27eca220283926f24d1c61fd805d2ab01eb2ad4b49a1631c1ed59a9199c49c8aa803ad57c96cf8de73d256f8b5ba0313aac131a94048e469bfb5d64ae6199801d2d203b4b2e13d821f31d5dc214b3d02f15b035977acc770249ef559d207add87d8758311644df0b05d9becb011f0e385ae7ecf82c2e463fc676aab4ef925bdb128a8c70dbd1c4f963894284d5262c31c5a61bbf3cc0fe0ec2ebdb9c030f040501716c490f8fa8efc86acaf475030f87bb7fa2e0a239c493e6a4e0177d1e2e027382bd922254d7ed58a5f6f234758f3d5bd15c4a7b78bf4f0b41c5dafeee53983f6cd8de6b39cb1b0d5c68626893ec86753094cab3e51e6ad71ae3670b26a32fab8c3d0863f40370329aabec5f067f85333cfba7ec82f6f1f3ed6df26e4aa7ae742b14cf4c891ee6617bf9811efda0a7ab8cef4949d8d04da1fb5223f60dca67e773d1ddeef47e17a73ef469c5653d68d473e082cb54e011c7b248b2687f5abf1dfac12f4185bd0f73ddf7f8e43633e9581a91882bf5b2e7afaf83b748d14e7c3272c1b09c594bca67f262bb660e7591ec1315849eddb9fe3396774f4a15fe64c6ccb0a68facb0395f73cdc9ef87374a432a252b4b56546f92888669d08281011a8193de6d34d0a86d55866d26ad32f2744894becd157ef092df2e43c64a18a0aa9295c8814e5a4a346ff3609b1510e377462262b01f474c111c4c5f51659c56475d6d2fe82e648a1258f39bca18998785a803a49a55dfd1ab19a2bcb958f69124007ac80ca6565d0ec61c0baa3074cc1a1741728daa4bed4b92aabe864794715ccf6a30a9bf600b3e238cd1c9386fb7c34615e4bcb25f0e151cc06a496b7071ac62151243a55256b8519dc35f3c4f3c451556bf3b23d8d36c9dbca654ab6d14843cd7b967bb5bb64ad092b05d93db21523e3f4a24f0bc91bec71553ba39cf1401078e721372c67edbd9eed5897aaacb8cc7fc8ce9b45353787289bd5190191add1e6470aa3c6323339b61826f426f174ff052696d06143942e2958ca13f9220c9b8a0b4b4f740f024ff783ba29d9eae72165b11eef236841f2ada7e4cf8eacb93891eea3fbdd2ac3ce6468d4ce5c8a79f06e26a3b77c8fc2d5a29667625015e831d1abc8af90403175751d3603e640921c47087f65dfc870bd11841d42a6aecbfd10e40a81ddca00c14eddadaac8ed7c1e8d8934c83373b55247e336979925807f2426be6769098f7b3cd84fbd60dcdc3b57347c68b57b8f8b14a8d3db79799cd990c2be7ffd00f9b69191d1164521bcba679ac5f0e95ed38dbc8e8e338ed1a107b231a3186eb13878afaf2ed801f4e5695499cf5e53baa693e4cbc4a75bc28751e4be71de98f45a294638889f9f413367bfc86f84ab3b0cae63770219248b2a95b0949c9269dc37cd1b632961d7f366032610f74fbca496652adca792c0227e4bd678dbfe9580de8eda0bdbfec8beccd6c527206dded37501be77caa46c434ef1ba1e7fa04a19895dedaaebac092e5a4c47313d439ecd96d9a85d386704203146690e386f29afe230ee4ac1276db11802ad607d8f09934ee61d38635ab44fee96d7835ce24f6ded6762b83e9cccb5e2a3fe4fd970327fd3c95cdf4d3dbadbf21850341880460f3e7e9dcdbb963359e36222b17303c689a908c405d54385f72be36801413749972be8a23895796cda459caa70ce87bbd1854bf9a460782d2a924606738172442f462fa57e871319822057d77cd97355de2b3cafc796ef1acdfe4192583d2c4703998da051ea439a27b792b8627d1ea115082d52533fd33b7ac90005f11ade7276beb0ec45586c6a34e2a02934a3349fd52920f17399a9c360957ded99eefdb174a15b7fb55bd0369a1f61dd6262524474d84c527ba2ad3dddfdf26b4fd7a0c4e1596a98cf73e32de18ecc2c0748a8b7d5ded5555d76181ba27803170b8081b95755fcf364e022b1fa3ea7905f4d57c24ffe3816cb811368bc6ca630cbd37695712bd16352508aad584997c60d5afcae51c32233cf424cfd3129ceab2485ef7d47bd31fd374955850d4991f249b9adef388f8a1b92d62899b509889db4ba3665709d8c931c3a9fb108d05c3666347ac1439244fcad6351795cdc0d16b5cbd96e5449e1d862f5bcdbd942ad5b0288608dbc8e0792925e1102f93a1afd98e468f02c0c18ccc0e42d5ab97eb324c3e2de9bfa394424361373992dc9885c7d2f574d3b7ed29a32d04fdb9d33c20bfaaab91ee99360c5de3faded71631994637eb072344527c134736a9e793fb36286b32299e837532aeb0857f389cab8d0d777f0590e167a42a0025f8f6ca18ffafb1e60bef6cc36756857f1fd6442d0b743ebf453e057f4fbf95e16b6393b98d9b2d3c11d5159bdc14f1f288980088f47f5fcb535398a0916a515cf870e7fb97aacbe5761ea42ea47e94e3edac41a4c731a7cb40c74a8514edbe034beff27dd3b8777fe0ccf6a11489b4c722ed71ee53b6ce9f4beca790c01bfe6b2f58b2d89cf088e9af52d5b9ec22f3b227a6fce5728d0c5a1cbd1324e88d615acc8442292951d2de119e4d82cb456cfb1dc8d657d8292c0941970b76b8bf48ff29a3d6f7db0a2f5f678d146a06e14339debfd21853dd67b4ada260148757157b241f04d0ec6ff7f17dc76a85c3d6f319a0c76cfd26af665dbbc2866ad4327102e1a7d6ed6c9959f587ca1855e280306da4c66c9f0f7df59e9e12945a3cb30302a4827de675d8a37a58c10ed07f208d667de22df58028ce4d6dd89c10a9cac89d957919d53526443095a9ca28613234ee417ab262b67dbc1f7122bb5843da3d38fc64ba5fd1dc947328f98931d05207c17b557e11776df20700a7be217856ee90d0b9ea0218664adcd2622173682116328d811606bd580a86d2e0804b7b29972b12d408bd05894b3abc491eb3e7d4ff6852a1ada5a62bb922ef4f4cdef3bc3f16df19f4d44a50c4465d06500c338dfe6cb9161dc60aecbff5f52a7e26de013296a6a99cc4a3ce6abcfa5fcb0b8fde72769fdd9c4377fbce9041912eef0c3bf13bf1994a21d4c057828448fe01e387c6f5c53377e3621fbd31695fa4fc4683f216acdd8fb2fa53b23aae9ac1444e343788a86695bb326abec351628bbb2b8f3b15ab5189618a15a38574ea403300d149f2f1ac2843a5f15c87ab3c47228f680472cd47d85206f34043b6af08311363cf2f383e22890924c0c2aa8c3af1d2cc333b9b9f42ddc6cd25cc243e2d9950ffc5be0f153c8ec9ee81403f95dc56a6306410c51013daa21dfe794bec00a0e3df71915c27dd71528ad804fa81c777752149f56b3df25c27f7672fed6c31f59ffad656a9e9a988d87d1fbdf65c9202257c52d222a0259e84c76a5d52033c77e79c42fa61c411bb128d40f92511d17a4dbff92567b7875be7bd32bcd2d217afa880afbbd36579e349708ac6afe3b06e0dc523f83538fb84bed1381bf2cf1c0892dc1c921c9cc91bb81a910bc0f456d0abc4fe712e787c2555df53e315126f692d5e22cbe3b98c2314bdc6f5f4561df6b0b3a7155099aeae579a34a61fa75a83fd2560c38fa59869c9c413d3a5851546b1450549421b778494fa827a919a0b0fb694ca8c39e83fa05658562e5c1ae06a5b1f70ceb798067d6a89f7970555c72dad70a472c355fe62c49d23d7fee53e1b26d6386d6b65d22d514de7f9bfa502ab3bb2cdea85918ebe1df4054ec716ce2d552832f37208d87cd04999a065fccca94039de0f7ddac75efe2a91d9a42a6efea8a0e250798d92c117cb1cac0cb86f84b9abebaeb9d1724fbf15d48fd999551c50f81426f509f5ef82eab95ddf9a121ba411d9ae761d6eb0a67e1a92bca783ba2f087565e76554c5c1c6ff0f1b65b765e6895b9b43f22d61b36a5260715f552976f4ae2d640a380ce4154d7e58ce01be2ee9eaaa99ebae49a3c2a92c803e0fae510733ef262636de46fcab4e8f3fa4c58316cdeb660ecdc9daf6b1b69262bcdfc2955aeb7768c4b2217422f7ec933b62b06d53f43b54d8f33559b61cedaa867a7a095359b2dd23fd35e800a84e650b41234c2ba6728a1897869ebca14d5e5afc2714b2e20c55e903be076f7fd94fa3c1753b2d8d538780747b2505184b2eff31458740dedf9a7f587b9634e0bf3e3a0b74ea94a2f65a1b194647daa3d1d0a8945e5eb430d5e3c9f153ade8a4c850dd933236cb96404d8b6a62e091a536adde998d58aee3ad9badc3f87a6edaac4d204edc4db73847e2f7e1234841be80d77d8964ea0c04eebc35749c2fb20bc01a0e10e93eaa6a404939d80229c2baead2dfd7b61c11e6e7adcebc239b123b8091b417c70938a7b0dc35a7bc31ca66e7f73dfa4748ff62cd471e99c821995c8aaf7eea6f97cbc27fa8228d0a67189ebe8c134e4d39973bcdddbb29b7c1f70b611db649cca5567609482d53d2a9622e3be72dc9d65354c09b44054c089b23b54cb3d25bc5427c3e51016c5ae1a2fa948fbd30bed5eabf65bef3db29aa9bbfa4e19ede1cc95ebce80b427af49801b159b512c732c4b6b5380cffe28e0e11854ecac6a10cb7655c5083995889d393d4be82ba97ea6008193d8da78207c4e10b54739a34105fe0138b1d1d87a7dab4bb95d55ba5eb99a962839f95dabd3bf23feb71d6912796fb53e150a689a72b15907bb8a717aacc111e9f15766c9ac317c0479356c35b43ecb3a1358224263a7061daf0b3a4512f149dbbaeb209fdcf193fc30aa9ab630034c5f363398bea23736b7ad64581b33b3f240883235183b93ba6024f67d9e0709c7c4bd3827d2771cb5a5e175484cf7b309f741ed44dfdcee1159aa3d575a1c27a1b42732ef489c406e89b10afbac098b2c955d1c34232bb862dfbac4986021a65f7265bb648365af19090364ac64c8e6c620653547494a924244bcc6e5415247cc68a3872705b259cab679f84da46b513c1667c0b3306df2394fa9a4b7456be518fa0bc71a5b016fed73181d7cfc6230ead2ce0c8879389ddb881cf889db35493f1e2101720896e7be09e98f8f6fa64f7256774ceed507e52f2c5e1b218d7f81e87f7c9affc0c1c21ded6175013fb812f8f4b8802880a188441d525e34202a08e30c89e71ba012f8be252d42a9880e1abb37f9eb804244fe18ae552eb0328cabcd9779a0fd9e74004a8049652a2c8ee1eca99bdacedf67d950481b0300f4b461cb569f1e2ab3bd76137ce4c3ccd3598e35fe9264064bbc983c21bb40c4be4a414f07f064536fe0a4753dfb602ccf83544246c4605e1d0954ee1853747dd1fd1417aad5e0ccfbb1d5e6b5b7643fac748deade2867f3ec2efd35a7f3f0a0feb2679d3a9cf264fa1d4308b89bdfcd979e7f4d7807a89ecec907bb78d479095a2f7db6f79fda0bda2174f71cb8e86e2db56cb894c0eba332eda2ab13385c79985d1f1119e6694e45094cbde7cc898df39a13fb21ed1799ee2d5dbbada9351785c0d11d3698208fd43f506ea8a4f0f5d0644afab2a61e81fe9678527821905c41c4dfb5821c8e970dd12fa45d03b95dcf22cd976f4d8df08a23644a2a8d3368860e30dbad8c812da09e52429016c34ec3df72e99139d29672d47abc44fc9db495db004e912e405708b94b00bbdb4c1311ca035232dc5b4b9562efda6bc2cdb95a9902e389cd3d5fc225fc3dafa25f09c93199fe9ed7e1b7e7ef9291369ac849296f58f43c799e0b18b8fde0e8b7e4c833223d1dd3d0bb75bb607ff5b506c818ed156dba8af65973d357a6633388f87d1e7125c87511088fad9af326e6c4ac806e2e1fb7dfd258e57bc2d5bca11d850963462e84587f8ba0200840aac4393bf86fe8c4792ed00e0ff2958bbb942a7b3f92a9223e3322342b4cd320701d3381b61079dc7372aca0bbd0c4521b8f66219b24d116579d7cbb3dcc7f677ad3db1da4e74816fe3e0b78a3d83ac6780a8f8acfdc9eea4e8ec3de570a1be16a6360e7b2c9fba9c41a41653c4df071333fd1d3871ec02c435898ff3855a0291a86ccbde164fbc8003461823be5349fb60121a72063121a4c426e53e2c12165d1e28a56221b78ce335773cb8e1230cda0cc0a8af57b3f286bf2ade68fcbc7e880c1cc7d8416f50db051d8cfb5d4c7b2106d32fb7f0b063aaa3971d03f490d26d53327a0db92f94358a46ab230062f2619058663f08c2f58182ecd9d414bbd899e5946b3da2365e752dcdb62b4812d1e032a33975683df159368817b5d880018b607c92e8ac82726547c67b50b6c75c3ccd2da9d1bd1fdbc960404fdbd16284c213b2fbc1245fd6c66f75809d24b35bd6df30920ae274a269af8d04c9e978925c375d0bfc8d9c0dd8661168e3e9f6e830f7489638e1433229e022a2073cd79d6756fb56fc945173a1140e373c9e04ba24e48b8a1eebe598b16d695f86bcd7e0898b3ae727c1f8e4fa3378779eb356b700cbc1c0842df5b9ea5086f5931192030fa7d04f07ee50938f3e3b937095e0f211dff9b9d529ed55726dbac96f07dc0ec52c9bd7a808bbd7e240444e2063ae49ece8003ffe35dace31ae5e810bfc3f06cf38f12cae64738043d1c6d80f3273cc4fdc677769a0c310d54e57d4968cc0259bad59fb6dfee9c636951963d8b563cec0e0f2afe4d7f8acbd4ed7ff7a228a7616198608fa1ec010eae76716bc03896a5f8ebe55be1a8c892e637fd1517df619c95ea9c7fbe6cf4ecd1c80ea2c0e537eeb921837ed69e00704507e4f4f2c5b043b030e0c60f187bb4b7c08ad8d198afa345d92892878b221016e5cebb69c49d7db60b37eb05c2330fb4dbdfa83eb7ee7dd4246fa8a74b85f0fedc9238c26316305bbc02bc8c5a89da0e5bce424c43857f74daa4ad0112efc66f7776605abb3e6005ac4acdd239027eb060a3acf01c92a6f836894c8dda882164446eb7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
