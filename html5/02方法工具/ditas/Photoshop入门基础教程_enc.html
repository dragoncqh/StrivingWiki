<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"896b42c45dfb58db861e973a8725d0df7972d5f8b8b7954a64636cf58026538203148b05a8a69ac09c35b2762a3d58fc9c30bd1a02275f5ef859854df36e1ec6eb76acb1c11815a5ae9020dff8cf430b62b0293af3c9793bf0bf286041ea12f11e392c4fb1e4d78c06ecded94b2f6030ea92d615def1d2fc84728d690ebb80f77b2945cb3ee9e4c1d785d2fc0244a77c5c1345e3790ff27be4f14cf26ad7601190713afea6a23fe943abe22e716728044bce921cf15281836bc9594ddd673b62048c014f04099a5d22409d48228f23957e0ba2af6f5f592657f49ea174be7e2f59bc49bfc01128736b4b9bf38524847c032d25e3a8886376caa65fd2a2ad2e8290d216737a7b2797e0c76aae6ea34d2f6c5248cef597bb2556a5c5486110aa0b2a9592447fba5454ae68ad27e7f3e73dd18eb1bfcdde9c3722363bef46db18524b830c4b818ce94c1af82f7fc611b91f088a28fa19e40a4a516fed73f55b673881a531b75b711659ad0020d72a33c55ac5885062ca005d6c1e17e3e068d6557bf6e0fa3a1d0fd71f4334f1abd760ee06457025ee3791261a7ee9a5fb9a833a5e99493a5298bb5840b7b49ef855dc69ff5e1b55dc0b92c256869ccd953c86d13096e915d43fba6fdb33a39912f7cb05614cc2e71982e613a1fad0816f1b8b91d6d4f24720eee53057a42bf00d26707c74d0235f8d3b1d9b1a14f1f1bec8c1703cdf12dd2f8cf4008b2397328131c436ea702c288a709df12fd2093c9f27a9e1c841af217237a77dd905e683af335152f8b800f3a45a888a06433b49c949894c785931831a16128aa0a7dbd8f4c50718339e1d8bc50a46bc9f1efd33bb21fbf25e97c9fe7cbc3c2c52d54b92753de755d8a86a6230846971d264c4f284058fc9a0854a3cfda87ef60bf7786d84fbbc1d6d81a8f87558c82cd70bbeb1e64bd6f7e3c065c61aee4ad84f261578415cf61077a44e568f0ce698887de0006270aa345e4f72c31eb9f15137e7c6d5ec7b3f4cdad99a956d3a4660dac3e315759242af74a129ab48961fed0f31b74b8817071c308e912e9b2d2dbedf9f22f13138dd84cb32a4d66b6f835bb621c77b45f8bc9e485a028d81f61337747641f70521e987a471f22572665f70d249254eefccdc0975ccb33337028aafeb5cc58e6fff2eb7147b794f20d4fe55ec0edb9a89b149d8bd65d1bac002b46d12ed5012c10dfe017bc9931dc4c808a8e1e676a6983fa6c80e12b791ae4ca29c2b0aa345933f2c5bef01e4c30d950bb00cf1b98d77e34d38f959347ab560147929e513e80b0cec842a9ea5c43a336d9632396cffcb5296d5e07ba0638ebc2217d144c472c4d18fe617570f86007044fadb2720f8c59e3dcaec544b9d8058abc772d5409e8953eeec2b90be973ff1b41b003bb6b6e772e2b5ae0f947f91995fde20bee741832b99237de64772ff38ecaab65279fea9230aeba0bc26bc1ca07ffebed42c0ff4c49f4abc1ebbe631c6d83eb9b4272b477b32a3353322e3a6e52f0acbf26b23354eb383dcea0046c9d343df1748f26e5396e6eed8b4ef546691b804401971bffed532f0f9581b69fa9f7419688390e4039f945e4f90af632d76560a0c78dee69d4ff244e29def8940b676026230a9a608c5cd3b2bf99784b6659243a33392f0105e82271ce588f955aad4e664bc018a9db583490c58365611a26534c0581d2b880d030662406778b2f983d61df633721ddf54927e98c23b31fdffe25fca2fadb2050bd486c3235a53772ba6b9cd1d94ef13638e1f940c88c3f7bc72319e470c3ab1abede6e0ea55468a7697d40fa93d64a38537e8e67e1f742c45751b6875dc84649482436678714beb183059fee5bf562478b0ea8428f591bafb076a5bbf90506c12e10df5282f7476ad0743b73b1c33ea201afa8faadf60b8780e384ed7901fc9fdd50e686dacf252cfb2c91f1505d5cbf9cc05461ec036115afd7900b75d75afd6a1a0dc4aafce5e0de47e092ce4617b98ff03fc731f77c0560b5b0ccf7caae08197f82aaafd52615afe7eb33cc931ea996463eaa6ad4119b0f2fe7fd6ca50484396806e8a6e12f7d48cd2362ce214b5f389117c937f05016b1f4743ca30637a9ad46162150e192efd207a6a797ab39236ab19379e818b9f174dc507dcb0dc50b21ee68f3480b5ba69e9fff7ddf86edd832f89fe07d9c3d6a199d5e210c0232b84b872a9ef40b0f0c202ca2ecd74fc96a0d66efc57d29e7516fbe36c4e4c83171451d97a79ed09dd87d72704eeb0f46b7574cdc7fa70622a22f8bbd46383938924c2efeb18a4747bd6b945a3fad667ff4cc03f22e77dc7fb4a6fb1b443fee56f66a62c7cd001d01517fed5b506b7dd057c05b92de72a62bb6a48bbb84029d52e9d4ca03f05355d3afe4d99e8dce160cf278f32904f8ea31ed055933ccf37d4870f9f798a20ebff799f62c025c794dc76b1dfdc595be12d8e188827e48254a7c9d02d977607196917ed34086b7eea332a5040dc52131884ade56e2f981d5f168258d2cf4165feaf60726bd1a51b10626d682812a29d04bdfeda575e98cb3e0e73c7c45a00f72edaa91492e4a84bde2a7941289bc8751ea5f2b15b5bd0f6d7a3ee73ea77523e71160575ab54bc8b3768a74e9b67da39958efa9315ff23dfd71e937edaf1dd69708c2fc5f741e38c9bdb4b0e0f396b0a0b3f9b7fa6b0ecb7676b99440974542d1d38ba49e67264a24d3905f133fb241227c3d14a7731e828b929101bf3db44936d388f4583fd085836c456bc0a2293e29aa8e39febbd05449a397bb9c0b0f8fe1a0e8103a4e40fd72f79ab044b5ebc671268ceb3f8dce8809e4636dfc959dddf2e98dcb9ccadf0a2fe9dbe0aacaf1fa91d1adbd1c27c74181e1946b19b1dcf1a4cf65c6cde00c8675e511c56bef81eb85c5a5eadc5c1da17379b1e04f29fbbd6e180d08ced04c82bb61737d495ec91cc624bd5fb13a4cd742f3ffb25af465aa45c3d85c97ea5b5c9c2de03b62986d8ec43bd626006c8ae44673f6dee2dd6ab0ed7e9dc14e343fe2bc5b2d27d7f7b5470401a11ab222bf9c1fbf921b3f104a4a034c3b294f7a6755e0fbd553db278d64a460194a3b1c01f4473be2b4d5002a043fe826550f466247b4c954b8806962e21e394a6405600b8f42484cbf9648228a3ac01c5e863ac4076fc4f0d054e2625f30a0cbf2fff8319e76d0f91b720ceb8a415554ca8760779be6fd94f12a8e94dfdcca8ab9a0a6c4377b1a2c2d3ff888c1b657b942ea1a3e8c14003373aba334fd99fa47de9ba9ddaff2ef4e4945cf38f0da0709392c3860281861c4d53211e8c75b0b931a14633200ba34682d5d900569a1e00f3a0f13d0a66a425969f6dca09887957091fd941ddd9ff310436e66a4f258baa8298728c6e22299ff72bd9fd314b45089c8116dd212f1aff9ad1ad253f66d5566d26258c6e115e2a61ba644142e61fdd549c983fe15b66c7c8874f74d6d20387c6a3fa4f75612b17c07c183f010ca1884c775a36a62bbe589da98b112637a1e1564af963a2ae1555d8eeb88ea75669d0875eb4c4cf4941f46f9adcdcf087e5172b1b9a5b89495b7fc01508a54f1ea5371ab7b879185b7e4e444688719863ff7f3f3e7a7e93cfdb42805e26d41ca90270dcd1f007a773ebbec0d0e6d73106f2f5f4d71e5b03b266fc510a28e73542d4774799e787a7a27d88aef3c2db903dde1304cf473a8067b97e71e546ef587c438a251737a152789128dc1037f2463b14c5c8d1651ec6cd2a09807632d71476b0daebbcbd4b85ef3f71cf1f912501c00cdb9c39221b0ade86b61b1e1559370e199e53a93d27766791a9834e76b1640de9520fc214dabf32fd2d4f49dff48b973caf342ec72d871c105bf4e7758f450d111498a437be3d4b187c8d71006587edebf39cde0b60a05b80cad44c94e346a7c1c0da1ad290b0f0be6f20aa33e12983b2161692c5d866ff3c6d83df18e0fd27705df135d76c8abaed12a9e6156e222f2dc1774260ee0a538d39a29a7174ecfee8ccf53c9a84ffb2dc412c0338598da3133fff628033f03f38e2c834efa5dbf3c4e015ee7f5bfeee8d49887215b68db9199cdad875b25e23e8a6b38ddb122e0b376c76fad89c5274fae3f0c2ad0e6df0a22df3185ae76f513db0894ffe424dafe5220b9d7b64b9751b31e8475025a8a2395e798a3cb083eb426dfa9c132eb1b168d094a3c542f5199acf9dc7547a3d803a5fb8eee3f5af17fb1da69d446cc889ac859bd0478499b76ac29ccc38b4cc69029762c5e8034c07f1e82e1913d59044cedae468c5118fbe0a51ec020017441c638549d27b1ea20d04a2a31610085a2c16d1f3456b0a21e37d5dd637a6c429499cef1a07873f177d3304dafc11e8e509cc473e6d18e8392e7fd0d67fd39bacd6c68e427f1682e53b91f90fe33e38f19581002b02b2d18fb5e8e8dc3c1152840ef2c54e4af79c04938a911fc93c337ba7347f2c991789717f34ed6ad81bb443ed85a9555e567eb36b9025758932858c8c3641e133c4bcfe3b39f051226fcc8dd3897318d6b1550c6ef77e3fbb9405607e3b813642702f1d1e39266c77d97aee2ba1f6a9b80597ab954105171dc2d5ded4b072844e8ebed59494cee545442506fc126d843dc3e14a5fc53c00ce68a8009a5570c284ce50e89382c425693cc1124fe25a1d7371eb5aa9737e265a352066dbaf60fc52891c99efb7a80cd22b043f1982e39c739fe71645caacb8987a3d1d8700a415ee2f5ca70a4a8dd0cf0191da2985c9ca16c183c21b22ea77952f9cb0739f26e84cfcc8d5a80dd8c11c24a043f8bb33e33787c6d82f679f3815c5b4ee24129b7825631b1114052e7a26b63c08bcebcd2687ef03a0d6c4dfc25e6e5d28f7f4865a472b099747531603d662bbe8ba35138a4661a430be94aa9050725bce6ab2672a54f9a37710aca34a8879d8f660f140bed15249eb03919e30b6a0ea5a8240e84fc4dbac0d32031f29348cc18849d49ec5ce93c2854c35c2fd50c2ead212ebf6bd6828955bd20a1fa16f7dd1ab8647b66f9e788187cb198096fc59615dd85262a55a1861a1b304a2888caffd5d7da5fc29fa09cd4238803b0b890546b0452318484a3f2dcb0450680ee68153aa581a9e3a845541456923411f7b475408ad20afcef65260970c0159b3ac3c534054591798387c3577cc1bdb2cec9b47c43d0643978e0137eb82ec921698f4eff841a11cbb2b012f94c627eb80d9ac619bb2fa2fb72ea2ab2e37d8c971a46dd0f87404ce0306338b8a82e9024764b282b39ffa8ec00dad885c0814792c0cc36be05ce1079543ae4bd1f8758ac10f9249d2093382b03ce427fac0c4d3abdc3a8272480021013c4525f06ae1762c35cb26989de9cf4663cbb36959047ac1cecf5fdafa58d8fa2225cc52b6ac27a635839cabf2e943bd87f24eca5fc267b0a14a343f2d19c5014852a288e7f3e278670bfff22280e88f8a906ea283069cc0f4964d5e55b8d35eee5817e4afac92d46c58ce0e35a4a1a7704c1f7e42cda208b8f5ad5dd0cec70c58349e95431c21af1f0034529dde8553c43e851237bc158e20d45e226207a7edeade8f1545f5f6455bfc3cccd57ea85b05189e02069732077c763f065b13ce1e4b913c4516e2a552a3c6089d17766cf8afbad446b12fc529fa5327db4e45b1845facb9a856a90140703d5cbb6505b75044e788382568b7d0793463fc76b60baf5d2f3538447c04a467f8c58088ff25ec0500baa15b213d15e1841b9ac6917ac8356c20c508cc2b7624908fe04cda4b2d514b9c969d1e87338b73ae4e9b422dcbd0a0aa4a403b6c794e42a6fb7549d116bc004e0ab85852c363ac9c391b41b7a4848b6c26ce60a4583e43f720c705f197be2dc88fb2f2c84dda1fd72aa7a42486176f362d7ba255a6da46d057cf3c8d53369e5c008f5ab0ffdfa4cdd68b0fb8e1d9379f4e9e16e87f01b9f61802c1aec17f6380daabf9d1d27c163793214e0727e465628d3e1c2b29158a19ae960c9dd5316248a62007f35621cda4321fc78d7f25a7701ccf5c5415e0632de88eae843f55354b13cb216da8d588b8687fbca36dbaf164c8947e338677616753a4066df5ed4be903336d2b8c945e58d40e5210e0ff7dbbd03baf0875c559fcad766343da330e289ecb887163fb870ec10412f535849cd7ee482b20d3587480b0074a53dc2479b187269e273748493336c04382ff14c15ab45376a4ec618072ee628d495373ee2968145811d614d29dd66d196ddc07528cf25b5a4fd972b9af9454fb5fffdae392cb9fbeebe77e83baaa0be492f4ab410df645fc441aa6315ed9e8b1412cdf8f3f8cc48c6bfe736db9437b2830351f0b949ea81ff6c51de8830e90e8df76a48af9e18c518e3af9a3bec35ea40df895d67baf79faf24eb96baa8b30f00dfcccf5465f9ccca4930e64c427442789d3033a90f6b52c12601e2fa1b6e342237c50fd755009bfcb4735e75f899d28545610422c006f0109806ed447699509cb628288b0ed6d412ee3a4a2df5a3893c8e07f539dabeda1619993aace51d4b60efb4e34e22c9e04fa81fb3b31f5aa11599f86803ccc98100d834973953e475b0c0b0f0acd23c24a8d09175b18f791ba560250249f6c1ac0dad36b6d57eff2577b77d58f6f7c460abeed74d4400aef0095d454130bd62f9fe45a7eb4909c3dfc76c2d39ee08b322ff5e123e310376588a004e33b3f4dcf8be728bb9108e072e0d3f9629170a91da74ff4a9841fb419c7219475c48c459355bf22749f60972072fd40570ec80581e0de551a476f631428c3b2cf667259632c049468561298e8cd6950369b9be2f11169c3c361579ed79422cd84048dbd430db88a1021f18de38fd463604cc734f72520bb13c89dd265da9609d049fe999b1ba29285b24af058fd6d1e0bf90e50d7b6a5ec1d9e42633b28a67d09ebbcbdf8791d5347516b8c45f2c4077add029e6ba96c77b7bbb836150adb1d94cc9261098c070acacab418a25721602b3ec940190d8c65974a1728095a2abda91d2155d93790fbacb14f41757d3848fb429f9760363378ab513a3bc44785d06369a64307b846c5f4fea72d0745fcc18617e0867c2658e51591a6f1c16f8f959afe38e6d2bcf761aa1787eca59a40bf682d56108896cef5d58cc494476021c6df9ba3f21afacd49493e4e087f8accb8bfd4171d808dfb6553660257b3e179e9b22898aba7fd1ad0593eb4eff28c09c02a43fa9208651ee3ea57b11ee0831ff71731076fd80c409ab89d1e2534fa4018b96f90ac25eeee23e641320748cd8d431885149a94f751d4c52de0e79b3174d0a65053a90e42297ab29cadf152c7f029eecc0791d891a165e6c43ea33e5c9e1a8ef8dccc043eb2078dda7b6bba49120375b83cbb8323caa51763e7bb93d18f7b243393716dc5496288e515d639936bfc4e5e9268930962eea03a07b439dbfe9f3411d4bd9fe13ee31bb955ec13fc3ca0e3c07642b3d17646b2d54cf7b7a8a70d76b89531f80f29ffc913e7c941c05e7b0614b5a761f1d845630c932a595aa08bcf62ccc292660b7b034fb56b98e8d41a593032ba8b710f257ef466ab8f1fb0fb1a4fc665c298b2116ad7ab7d293f6fd0c5166b1c355e6ca3f72857d9d5515718254e675ef5e6f80704eee47eac58e4053a6ff5fdb057085b4e8eaa565fc683137a5666e75f477ee017587b11daa5acd7d0062456ae43220891f47726131222ba54d8bdcbf15a2effe5b33d996d7c45c8e81743cc4f469c00085a241cfed056b9b3185430c671a40e574d9d23ce5e65a79296cf9bd46f548df86c8eaa67d77b0123e937f72dc3d4e8ccdf71d91159f834d832d41ab2505860907d28f6d4947ebab2451434612118034945bb3afe328d177bd224131d378455f5c9c2d05defd5a65efc9a859966b9f3e6a6c701176558c9585b8545f5b9a45e195b3c253aeab8bb0b98046300ee2b69fd0b6fa241bb2b46bfaceccbb47ff86527ef2a1db3cc12cfefbfb1717980f3b4acd36f36759077a5456fea97c61be588ea8e887ca3eab0035fb0f715199fe9a5c9deb39ec213d857c3b2ed8da1f737948f0034bf2092f5c70b574d3eccd5a651a98adb33346a63f6aff79315bc5c043321efc6f7c266b1e89747cc20ab33dec47b09a870ff27894688214680ebfdc7e20283dc3511b4b3da1c4c8a44ba6faa6359c2566848d1b716e46faffb551a277027b1eb365cf0a1bb875b396a88358df9e6cc1908e0cf311ac1f986cf3e95abe197be8d86285a59d867155d70adb64860ce90c865025d825adc4ef448e2fb4bc1ff9bbe00a34e3449795362fd5d4ece33444f7ec0789fd0a205193a7487f1e6cbee36ab95f77090c420c3f3cbfa7f75135af796495fc46d3b1350ef1580025ffffbf2cb10af4590f3330ef0815e0dcd108bb08cf574d62fbd689eb8e7278fceff585de63852e5257c2a08ced5e0df61248db66070b48ebe9b01e98e11d1f4e08b0cdfc2eff266ae543df184a6531c199c2dcb5ff4a910ef4b5379502ee0d76e1a120a65b57e02864ffae1b919b5193df19f14354129aca0189012831ec6792c9b23d44b5750f4f3dc93271db7b835983b651319e2b07ac42874178a8d17ac43d5f3db20c20979b35a1b303036416ead2ddc87d856df537f4f0af274cf1326f40f2da5b7a3cbe645388871148a2cfd80944c3de1a852e38dcd394509e395e210bdaccca9512456f43f8680d230aa296d65fe19d74d9192f5dfbe4168d10794d1cdaf4ab9df24c075c632a9211919d7827901ae494fa08c30f4488903210ef90517b4fa26efebd8bf455453389f8ed04d869eb27df5dac88c060ed5e6b789b9cabe0600c85418ba70925283a8c7894aa816f2f23f062cc2ad6230ddad2483e2a4452ad98b8c85e71fa1d2467af649f841a5da5aabaee2748a20ab2c43ebb5964de58f3f1af5f1871d633ce89f08c2bb97b719c92d671e095f2c8cc3e2b17eff2827118274338d18decbdf13d7e417931c3906597df101a8acc2c7a2033aa3ae51f200d784b31dc9c5aff99d367e01839ad2ee9523cc7978c8a091db928f3b243cc3eae6a030f6e204518c564fd5610d0a1c8cbae4afcdbcb61a9d8c3c5bb2d4429ba275a30e7b5357a3c0bb5a5047f0f25faf686506e445a55957d76b319c487ef5385e46ec833f77633e00037c92607d7853d2714c09352efdf98c37e97c9a7dd10a90c51432bce4b3eb2c8f5b0d074984da1136050327747bc30759d67d63ecebd8b9556b80ffbb027796a24e4d15a01f01bdcdaf069e1b2f6620d64ad2197eea433d8598642e348aa4255c0992e8f3df4ccd873e8e0b788b3e25d0f4f685f9f9c667cca29e88b063074a923c608f89e18432afd4ff22d85ed938a4a3805d6f9c0c3ed0ae465d38031deb5ff246e9fbe5cd9b7899365061d906c912f89dbd0d354ef52b220b67dfeaecc0dbcdbbd9912e7b5880c26d67b25488dc28a052f0490da741f15039886990e43a5ed9dcb146938a7edadc57a8bec8f6d79e24d81c9bb1de5c080107c092f9b4ae56083a855e8ed5d8af310f64e6bee33911522dac98d9b935a458b0c89b4402fb7a63fa14deda9243b200f460faffed2478b5ca6f846132483d4d055894e5e96c03fc30cd723c5c53dd12c7818e629aad7451975d5536ffca604a438afc7c1aadc06644e71f7a898aee553f3abca237d74cd4801e6a9f7529ca279e76bbf0d8e76c55d04c699045e4015f433e1993c987bee843932fdb48c56bfa74023eb0446397a677c02904caad1e2449afcc0bee13a5e350c803590222af76797fe581c747823333ae66424f36a6f62b32c38f0906af90693d0c0cbf4b55e12c844a043c8635b1a77c25869e2acf2961b214a627f8d1e63fd37b1944421e3f095c7be96090bd84fe86a765bd24d11968da943fbcc90f1a1ad92b9d362d53bbdfed4b6444f0b2ed21c269e0e32850e088e0dc400d853e55e9232da2a700d8dadf53831a21002081539568200124db074060c28c5feb606c737e9ef3bcda3e88af6ad3398cde385c5b914209513d2cab2a5e5a22c903fd448dc1bf173614042e60c89c093636e614f977e1aa0535a4bdd329f7ba2c4b40d10f8aae85ce8479a90810d1837e442817d1a2315521d5529ee623fe4bda7d0ce681d19861c0cb7fd1298c59281bf2af592599723f1c1a430317724e717f3986e88526a8f9ec6d8117aaa5412358ec823ca2ce1bc43fabd5f940c9cb68c77e959ae2ac8a0913f706117bafa987dd56e7df2387244686059f5819f217ca37c5c8a05938317272c64dd6284ebf741072dd9b005ed584e5b59cd75cba3586d9327ae937296acc8bd8725d3f23b3ef1e5288ab6d406bd6fa75f80158de92ff4c50da9f2e982c8a8db98daa1f39d47738457959e01a574fd7bd4a76f79febbc84f745fd392f486b6be7937845588f7a018b4b48b15936e14fbce95d20370dbd50cc71c7321d6e731db17b4848c204851e0b64fe65aa49b313e4bc8defd9b917680f47a9097d148935c58cd68ca0ae79c6fda3aa24e9cd1537865c196931b1bb1bedf8ad0bd3725b9e742f91024cdabc6423c671e5830424b6092f8841ab1e35c2fc4bec6a190b3c247b05683204cdb6bdd15bb24075a4d516b68b2622da5a5e60eacee167f827d04975423752a844c7995748c6e7f0839274958ecf63d5095efa6e64469c591ee9bc85ee5e5348c19197d218f9550e902da0c57ca97ec53eb54a8df42d36d60bea5151af7cc5b4c06a3bf2ee844f0b8821e8031ce1980741fbe81ca680081eb051616e06e543c1d7672cf0a3d767c487c383bb1a6c210b195a74b6c43b962c09812c195075ec198a9adec713232e3eef5c4bcfe8d8483748a455b984850b090f8c595ac38f7d31710d7fbf200669bfb30082546645c401abdba5731369f788729cb2d478336b0b78d67f7d081682f285afd7a4a45b3eb923904f7dea5caa11664d46d76bb4d5b188d79eded8c8b697598508c73ceb5d6fe7292e339954add516fac41cd7307a2bec2404b02501a710145fef496a73ba4d385244d56c026d7db4170ccdcc65c1921616607229ed3db1a707759f47df78866d306e53c52cd4902b76d0df530b76b88c4154285d187561874ebb1153bf44e3cdc89a0321c5571e1dd37f526b4afff17129c51030c2343d994eda818ef6daec8746844838ed729afb7a3ae80e62d1dadd838027053a84b978e6157425dea3858d187c0f32b3bc6e7aef26753a3bebf7004def8146744c4e3403cb46b990ebd6966af7a49d3d4ee53cb893f68b3199df66b11c6429e588687f6305aa4cae41344ee6d41c9e791505a5061ae5f27a25b1ce4a91c99901ea6b140e0af1b7f243ec851bf53b744b6ea515b9f0ed0eeaa37dfe22fc93584cbda464ce8c277bd3ce374dd54af4d5da8859ea1062dcfdeb758ce5a9ef20531b9305cf8d4eb1cdade4fe3634efd4054750235b2ffbdb1e9e66529e283c05b8ac7cd86bcb2a1104b10642f0204771672726996cda80f142a29dddf4c49578d99e199696c895dc5535ba51f0c51f1cd7620ae7292d9725d2d5b8e41c03db78eeec3fb79586cb5ce7ff9dd5a93a4917ae01b62e6bbf9e8493bdb25823415f42cafc381f1345b67be521c8b0f8108904fb5587e7d78a5b666a71c8b97386eb218f6029dc468cad22ae9fd13badd2a43ec0cc1c226948312e4af7f47c145f33253e0987be7603cabefc4722925fe53c4e7ca263e7277f887159699180e56716a1dfd555d856824ba1765629c4140063ac76ec05489b56bfa4db19c51800ac2b042e9e9ce42802c9ec5fe89717a310c20ad6b6d236a9c640f2269e94a977b693640860aad5148e81eb6b81de5a7199dc3b63d6bbfb26ad95a0610229a34c01297d8c9072038f2846e35456d3615d8050bb89e0e3d51f7119c655f20bc192ca5c8c8f389d844c277e8797570e5f6f1681218133e90a469305550dc124eb4811d2190b72d1741c6c1d2a86d1d992692f9bdbf8435750317e173797d6aa49cb46b67ad279f7f42c5a2cc17ed33147d4da1ec2bae596c61202cdec75f1089eb8798daece3c32f7326e048e4add66a015315c05b2af34b3798f6d13645f5a9b29384bf44050b3ce55ca36a0db7997c5d364944c30206c04b34f12470375b26b67fe181f6c7a459bd57bd6a5dafbb19341ff10e2ca2472f2314b5688abdbe49316fc622725ac0fde63530cf3ad227912d20f4e704fc6217cb5748565750cbab35debb89ffb3208b332828beff3ae81652d943d2fa710953f9bd1c0301ff6ff2dc394f57bc6a86bc4b207feaca8d193efeadf92c350d36cf109f032dd7473647dc3cfe2432d6fde822a1d17f6edb63049bd45944ec6952be1be9e1edcaef1a4f58cbddb9f6790b31f73ad0d6bda0a4f1bcb0a5ef3f2c11b2ec5a178cfbd6fdca1d23069db58bccabaf3799423d75a1b3665762beb7c9757de8cf1ed5245bfd498a21229d8358092f8b1cbed71683952eb0170321ca72b273e59975f45880c27d0d5329449a25109fb5b926d3c43b766ed0685c84b49a684facdc5d92249582e849ae504affc2681dc8e98261c289822c4fcc63f762b4611e567240fb9208125a73fa364d83ebb87c0f2f8ec6de94048ca4a516a42022e0bc72b548a9372591a421d0799ba6acc475f95ca6100bf5484e2d4662980c82993e87be320f388fd741612efae0c38ce6ae08a269628b4f988943da6bb4b9305a3453f40d213fe6aa27ced639502c77d81bfcaecaccb8793a697288199774d7a5c464c1740de6d5db2bc8a1e09c74fed8d4137bef255377723dcbce24e1cce5236edac91fd621842ce5dcd8aeec96c4e64fc04e004640126c9125644aef4656ad4929aa45e4d6b8f5880cce7f813957f7b95e35c6cd94ae6962b88cafc70bab0d57f4f8a5648ba3f3eece7c2476e15d842c93ce14a6ee1434aa65bdcb02cbda22ea62581e899a918021481066f37ae9cd362c66d12bf3a1eed0d468e4bcacc3fac0280337b75e23e4cd62166462be840762296301ebb94b50dfd8d1b79e5f081706fbebe2b473e0c25d5741587a9eb2f7c0340c30a8d50bb59e8233ff6cb0ab481cb45710987ef62c9450b93b17ce2cc3db3e8cfaee8f24cfe1d8141a8a05dd6771ae1a4315610d4aa80af21bd4655eaf4e1dfeb9370e9838129ccb3e5b405fb7f78af261db0a85442903a3a19f23d7a69101ff58a886563eca85d9bf7e5e2f139177e315a1ab455755c5ebbc7dd9bfc1e312fe21d74527c7365fb650eb94ae2bcc96322abe9b64a72902c2f65f8f0bd99304e43d707ad78681e40767f54adc888f83476d0f4ca07dd249dfa2b56a2198fa1ab159a6238e5e7a625b46b397eb62ca8e07f4dce7a637dd142d7853cd72e20897f9856241f4e567fedc15f47975e41b474e4378c76de292c031d53c28bf7ebbfdf5ba4f7c7c0f594023af55ed7edcf8710f7116070624bdca102496e8e2ac7a1d0c693e95f801346724da131b7b08af241c2efad58e56a3a3519514bb556717324857675967e21a9e105d9a3b27a9e16fd9fd85f3d3212dd730547a9a5d87abb6a51d3343a9ca6630e89a06acfc5df59286e72515aa25d45807daa7c032dcfe9b05a6a0201e5f8b383c9898e5c21b1961048087a587323c8e8a54ea69f25a42e83cdbe9007286c354c7be529bfe232b7e0c406cf5e0864ab10af03065fce8906a130c05030487c098a477ef7a2ae7932a6d60da16e9ca7d148eea024dff20a333b5906afdde3eb7dafd61d6c023780f7b354eb9ce0f94c98325fdc8f60c5029f2ae629f9acfcff3ddc61725c1e5a5d0f223a621c140686502639445d655f22c4322eedf595741c06771738fba15585dfee8f36dda9cd0b39a73c640de044d8228e684903ed1dc919302091005322579a145870dbd01135cc0bb3b9eb2093719855137c6118d77f4d03c2b3ce1763bd7ee231869d839431a3eee4d28dee6d8baefbe19d4a2c4133da700d81f1f6c12f7a2238291535a7df727a85fe711c448941c54eb7ddde2399a49009a0dafd5885e0fbbd1809add2006457ab0da0a5fffd7939d6f66cf43f1898465dacd57f7b3ef6db2e4d71c06e4fcea0d09a981ec406db0162b0a8effea8b4296e0a92c7d95a31f7383943d6779cd04cfca973871795ee5cc6bb92fb3469f0d28e4798ac006afcff232b93949871a40529d8f5cf29ca3e1fcaf4ae985e75b9920ba8bb2a4b627e3f04c5f316d629bb51d955760dc2b5124af2af22fbe1257c8b5fa9d0edc2681528719b20f97e837b0ac745853f8e116da3f9c0caa40516392f54deaa0324523d71dd875934b311310c8a9948193ae0ea19b6c0700cdcdc1343713e61c1c0d6f817735e863f0e1c7e3bddd70c4c8d56d89981c32955b54d22088026b83e3e16e7b4993112c2492d1e37cb70d2e2f718e90964cbcaa82c563cda09044f330fb7a2fb9adb588ed8ef2f7b8a076940e6ddcd4c4fad6297f201d0e8079421822dfdaef627e0f7d4c8dcd78f61b0cf41f05ba0e586e59ee049f29ae5b1bb5dd10b4a404644118b6ea075b0444859c6016b9bf5cc0a046ad48eb6a98b2dfef504dbe31dc3d2cc5a22ab20b659e541f9d498d59d94cf66219b8c79d5b2e36c6b6cafd79ad6283fdd10d0c9399f8adfd529f921c5f802dc78c23ddb0d0a4923110df705149ec39e948ccef2242388e5f7378e499c7d027f6c6ec1b010bb7cc742f0a9b2b35f7dd223c30dbbc65acd5c6ea0cb22029c8e46328d59c04663b48c94ed1d22053aca74837c70665cafb692ca18b8a1fe0e2876bcb8d055bba699552f6abb9929af4cb564fe34b4c5eec35ad9549a31e4447c069f0a61d25b24a67f8decb7e7770f503eb2d4fa8bbfbd2c7cc0cfe31c2c1deba39e38c3fad311bc5212e6e4e78c3b3c0ff07f97d0cc43eb26da1e4343d91a58633f39ea0d74ede97a8f35df58cf31ec7dfb3a3161d4f15434fecd5c49ca13cf6cadb70f9e96bb341919065fe04d8169eb10b19196deb9075d71d5ba0d1cd2b20238d9ef65b7089501e415e82a6bb554a00df610d188a12b8df121eed2969c60e66afeee73d48687d0f05b34865110ca89cab35694990efb6e138fe37eaaa01c2a0fa01992b34e4dde135bfcbdc31964af51c7dcca067270f8746a2e787a6c9ec0f620bbae254bc14c7b6376c13d5bcd7d8e0d4453382301e01a930f34bdaea2a25059a5c26aab10c57eebc76889b919d7d8f19a328c7ed6150cad2ae9e77b174cf3eaa0776b1d644454ffbc6ab93d9fa0bb8d0cec9e3f175abbcf5e8bd58b1d87fa348e5c500fca56286cbdae2d9401c787428a26abe0307e37e8a4fd78a967cb69a3148a54f9dc44fd9b711802422b128126acebdbdd949039594b3fe0e61e743683abc562b2f1449bfeea8d5bad577b7d97c4cce344bae44f48b3b09f72e3f36d0f3925f189be5c14df648296123019304d96ae4591c04ac3c1ed0a803bc9b7889ea52d2bc6a1cb7a29a71b9199cf3fd819a11b82108eec7ec9cd404502c410b7cc0e35a8fad4059564d4d4a67f872c62bdfaa0316800e51bd351d60a55d68636e6c19e974c570fb2594c34ec870e11fcdcdafac964976df4ee4684ed0c9727961edbda18f624e08dc524e648e3c8da4d873ff97e21ea8326701a6a6bdf889b386b2796c07b6f7f32225529fb177a913d9ef130997146805704b609631a4c42cca5060d78dee0d5baa4c4c4c5862ceec8c7f3f29c84a473247f0ec6a5f39008c4192727e2fe3e8fc9f6a388df64b7f67a0dfe567f7143acd4f12166155fb2374f6b3c22fd89631977e7e2d7a99299a5f0261928cedb4323b38794fd7e09f51a5fd83778f726774a184c3c6dfc92b47fdc7deffc8ed1fcbcc1d1f88b7761e5a1954eefcc27bc3b91e03528475e858419b0e22f65b5897fb2166d007987a09958eeb9e4efcd4dcdfe55a2b6173254834754af0ac1037967da62d5674b351e6faa4c89fbe1305da044f3cbe11317443ad3a651c9f54b2b336c008dbc3e0c7a1b88def3eb80b64fa8dec78c3125ed43b04221d41b69e20679a3d1d3ad446a0f30044e1eff047bff3fd53ddd515ee324bab62f6137e4fe3109c13ce0a2e897b122ba89a277460b99db101fb842278218d5b389040533bba96043267b90697eb98b9b39f45e90a1952da673a046d1941c5e62908d7202aff1e76c24c165887eda4c0a05142b9f40b84d19eca93b2d58974d72722a4d0fdfdc84af0a3d3a14d4bda83a62c03fe46c9f85a120ef9dbe7573df5c4618502f9ee3dbed5e1f7d505c779090037c0abce18633b0ee603815144cb6919b77af3158c0c885dd5e2c090033ef3f7a9834819fa3f34e34e2a4779190ec92a9f3294e34b558a810c2b56b3b862cee95dede906c14b555fd2dfa11f0fa064cd195ca256da2562acacad4b3283a030fdaf8b8f5bfe36f8a889048c0ba7323440faa606040521da787c363f2cfceacb18bdbcf668a225c1b77d56d6cbcc43ef875426dd0a734afe2be77c0c7a6e099ee08e8eb783b409c70ea7bd8270b803cf401d6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
