<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"52e1ddfd0b4507fda5ed2982d3a89834d391067375202e5e1839e4ee238c4322e0a076da51a3da8a7319a1a040d53600fbe4491350c30fa11ccbbd59482ce936a2856ca28f6d6797aba3d29f961f8c00954e50098d0100c3d34e253322f716d317c2bf14f09ca1611c9bb5b22e8e858c7c61a2bf2508a9003d5f027e8beac1e4c7c1030e755306235914802b6f7f01b0772f45a2920f9b71e6796b9d10c8dd05a6b8a204a4831777900695dcd493c9fedc3fadb43ad7edac4ad6365767b5ea5963070abfedf4b53f2cf56855a431368c383f57bbfe36fe56cfe385415bef265be41b661ff1181391167e608fe5e3aa98f10d6de88c4b3d558c36262218cb4f421666be542a9fdd85f7c351d076c0d7bff07edfff7da28c2c6d12c415b49200773f2c1aec11c08bbd268152a421c8f1adf0180d35e9f40affdf870a275d1a8872e82b9257390bb1167c8565cf43dd4aa64592f729f114f35b458c1c18621d00d83c1a0e41aeb3115641cb803a04e0b9037e41a7ccb81b8b91ced80034dccd9697619e840dc38dab8e5e7ec0731248ae57d9eb03bc6ca2b2319954cc6b8c497afe5dfd375d48a45188fb2c157aa9df3704695c6cb836600c3d67a4b974fa03e262231cb2cf8f0b77772c99a2edaad5abd4e5413d410b9981af276f25f98dbaf3712bcc25bb9ce3b30c5db8864e16ae8b0d32f69cbe4b2b703ec507b5e8482daf7028a39e4961aeeac8d11f546d56327a6350261287093e8f015c92fcb4c6fbbec82593cf3bfb6c3832b4f0ab43817ff12272b53d4728d55ffbd0d29a8395fc8453d95a639e5f07fad4e11eb5cbb3f33b5b16cbb78311ed83785d25af339877b291802b5ad37836a8f1c50daf9c5c5e619fc6f3e8edda546826f10e58b7f25f628ead9c1d07f958fef305f9a789a57f3f37ce8a4c048c708d3c899f69d59c185c51ac9b0028a72aa6204266791456abe8d26f793ef04771c365d2d8e554f0b56e2dccb01741dee2d5e7322c83effb4074eba86709152dc4d044f9b18d4d2236fe7ed51809c685ab92f57fa3bc69265c79fbfbc328485aa571f2dc5aaa4b4302889400264bde05353930ccfd367cb4e31d209204f9d7e3b68c8fd52b4d82e790f03f4627440b3650622fb3720c20d44c53652d42d27299d3cbe93e2e1aaff9932e6e874634128c457430babe7edb4f38047f95365cc14795e5b329c036884992c40816c4ad7de6cd7c8699257d06b34134f08881946f10ff13b387a7aaf1a91f2c3ddc1ff11bc074d078eef3020664a8029ab994e413a2e16c52483f3f70f4f0ab17a8d50b989188768c1dc5b78a017041084d8afdacf0896d87a0e92360b533912c4da7d2702783a1e0a8fe8e837c4fc25a547a29214efc49297b73cfd62a3bd2d4374710c3675978aa4d5e62ff3ef9a3c0b08f9e4fcfcd72af67c016667f2637bb025e585351afba0830dea418368f2004733c49d162a39caeee5309abe06935308fc8ec77e20ee52e93982fca3fe4b909a2155261ba0640461d707aa3c36ecb6c158f91ab9c5a227d1a2f26bc21d6133b2a85c06c3299a8322040743fb2c062d19e754242b3c41db1c4f7bba79213e5e7c328782c5eb42fa8fba5ccd49aa8acdd43545dfd20f05bec29bbe497a3ae08529e64f496e18a3d1e239ab1d269beb8269d1f58d8a91659b423cc30b1d0d425a9ca7fd5ff72fa4948047a0a8f8170543a59f5fe1127fb3a4595061d8ed0a3261a0a1c86c9659a161db5a94f9ed8df70e88ad2c7d2eed6fa2bfb543999233175a8fe1380debace4e3eef5090d96713beb618a5a794488ef1848dd4e9037c995f43b7946c84e6690bb6ff9ef0e52578c86e4d8d5ede0118e3e3dc78b9cb3d09264a81595b797b614b1b4600fdafbc463521799cc71ec3452a38ca18525f27bb802d100dccb953c6d6ed365ec12060484cfb9c249919f71f230ce65b88ca0e96884bca0beff8ff8a5961386052995f0d151bf1ed2e44616a0f8af933ccee50d22bb21e875b78ae6cd23f4e46863ac2e9cc98757cb8b09ff4a419e84948e51c96be87e409445218bd693748010ab9d32f272c83175b3aa0d273dd3cfd99fbb8687dc40f2982ea242e2ad82e9cb51a42e8c2509f4189ea8db429ff6fa2400892e4f4b7f9a3fadf217c0bc0e924ea728553f45519f13df54bb49649db3448c0c2464a6f28b32ec42c9f646b56365812113795ccd54a940911b7cc20d3bf48d049ee3b4de75174220b6b86eb85cceb4d92874841377514a068c37f015fa179a04598bf3337dbafa36555905892f6d97e858b3a0627b4331561edb963ec64228cb547363a353833183ad56fd4a20e843b0a23d86009ad3f5a749c7926cfd7a66672e67f239664b06277acde00dc5ae7fafaf1357af236ca75a34a6ecb6ba72d2c4a37329417745455ecb1665be1737bbc8a24a175a2bdb3ee82e389feee4baabd0b940cd09bb90247792c256dadedc08fdc02838d725c0abd9e425d73113f13f6a6d3bbf73dc777d7cdbc49ec4f60b38de7d575aad0a68f6416bff445ac536e5ab938626b0283f2aca05d7ac5a4a6b18912b96ce7e7cbb69296d9309699d0d91fae465e2b3430473ca2df31466026d1e5469cfeaf8e426cacb316c768d1a5afabe7795be04d1228828e18a8decf3344bf28be58a2cc87e9da72b82cb823585d54c637ee0d6f3ea643a912afa3f4a3f742eeb508d135360b4fd0c1479c80fb51d536fbfd300383b68263cfb7a84fb400ae5af49ef0bce8180512f4c477e7a5ea869e13aa50fca67e082dda6bfaa20df4b6b3f4bbdeb11ca6d5d9bc3b174fc0422b5baaedbdb5a67c85b9761fff1020523dfb16aa86ccd0d231ab366dbd46268dfd0a6ebc510c124c54adbc7caed9c5e0e295f05f5242395172c3cd2b51a3d3db9bdc791c57d08bcf55dc2155088b89fff460864b620d9e15944db23639803134c92b2624038382c1ad7096b219475134569d61960fa1d0fe1f439f7e1faa7441c6a2870976d0907937970b088693db347cfe6584fb072b8d26af8fc151a3e05edb16b642316794a9a2230cec10be5c3ab44898f9c63efcb0a09f9c0260e1ddbddab11c51d45f8844d5a27a3b9d86e2790ebc71c3dcfa683d46578443a4e440caf365de2bf6f629d06ed7b5bce6a8dd636e3c5cec037f864a81b166b16ff37d6c9810d76cd1fb23014b2870aa99ab40547f4f70d89fb96d5441289f57fbf4aae9830290d7b2edbeeddbd1017a4744c979377cc3f49a36130b709e905fe402a25e5af8375a1aacdda6f8ca94bace54c03dc442eece178531d4470cd595107dbea2752068b78cceafcd13fade654b2f8908bbc89319cc72e93f5e113dbf70bcd57e7097fc2f3cba534f3b286d1461d2ffb6493a1d1e2a81a0ae2c2130132189499e5375afe693f04595873b1dce29ee5f7693a507e880e561ae7a06feca6585561f0a99d19b95265771ccb665b88e6c0f89770c5d57208749afc707b54206ea5c4f0502722ca218067d6b794b5b2bcc756b97fce5573f7afe533580ab2649f3bcb85f0d528d5120f0eb6b1a688c0a9aa8831f32eb6663ecd1963643a2e85802a4deeb2408249f6a385cf13e541a5fd4180a74cd7cb18069f6a3c5564f280de31760f5646a413cb7461aa981d23188bd836e29f10ce506bb00d1bde2c14f1a771e7d3627596a96ca05b5131071407ec073a63526c80211ed3c1259a076fe334208e28dc364df4703d0bb24bb5b8acf3471e412b5fb314b73fd0303a5be2f1cb090745d2e11bfea0dcf946e1c3c77af04c5e3c022c71894bac500d7fd032a988ebac80039bb6218b97f71cca5eaeb21dc3a95e794430687af192b91833533a4ad1fec14c62dd5d82b1e6d7863ad9ecb7b10628e77552b2cbaae30aee5d87e931700ee635ea528594b41c8a94b82158ba801e1c2cb79326776a4a8b7aa05fe5167b681e5027fdecb2059f56a42c5aaafae52d267bcc36b68126a85d16780a897bffa473525a80606bdc9083d148046bd802d2c799d88943af41e3ad8e21d3fba9a8c040e3715a8ffbf86a5336fe721578954ea26c5141b1f9cd3b7f95669a740d3b6dc946c86be3b891c2ffc323d2eea72bdc97d1778db297478daa896b364b00c8b2338eb082b71a10b558d81babd807e238e1c97d11dae724de9731762c8ad1501e57e32cd15f4f194eb92efa971cb50fd5af4236b480b6a8679cda4a19eaf933d4db2476814d3877d03b3b932effab13c5a915d9fe8ac6395bdd8b2f7cb9c28eb3c7b82ae33e0272635da3e9cce0bf31dc30cdebc37bb921cd30075d05f5b4a999fec9d9098156ca6d785f9e5fe3a506efea07dfec8dc09e4eb4efe4a12775dc5237b1ec6fb2ed66e1108e89ad7518b917e45815a7065753bf5a0d73e1d4bbf1b4e7ca39829cd5f3b71f3245723874bdda7b8c8aea621c3b67c0871eebccc14969e5ff30e5d671e91719a82d974bc071f607c2fb5542c9d613445933543776244ae17e6009b2413acb6116097b57ad04b343771f3e8162c23cb5a9cdf4d6f9edb8990030a4d4bf530b992f561b1623de055da468d616597a91abc1356bc5411acd1c4e4aabfebb85f7c1c54600a33ff8d3f4ceef49316d746769b874307de41f8c42e8f1ec2f1dd08df4a090de8a4485f5396f4d242175d714aacbf889408f0813169931179fe8da88806c43d4e8b3b5f14d5fc606570e1b07f2901ce57f49f357f85f0abaf20788a5c6988a7fda1279bc81a2bbcb1ee1b8e961f46712c9ee2a6a3631a305a9919a847de5a0d4ae5f330a5256e58f7a86c20a6b419d39c40f5a65d3f27acb22527ddc8f46315d0a2ac6737b4523cc5e779aa6188a90f6e6eea7eb48a75c7a033b81a0176af16005d148591cb9553c7e3ea5a8961b20bfe59b46832ef66dd0410dc2355b245395dd33e6aa388b5ca74c7bbf7dbdd33a551064d4c4c3e58ad2117a3d4b86370cc667e189eb19acf2c3191b467749a4befa0fb610188922800e6a2c25cc332078406949069d55fbe4a4809cc7937aac1012cdd36b02187bd02ae773f064e965b6c1e3a99092a049e8c4d081274ce31fff8e23a8ffb64bb445c3a1a7d9a524e425223b11144053c96c62560de8cc9102c4b99928adfe54dcbf6ae9900b998079a42f22559f9e16a3b53b76abcb2e5689d15d3f3ad6574d9fad92c910f2a2e3f8f7287602a8f81dcac27da39e12c8f82d323105e8c288c609bf2e70df6103952440be5afbc9b4fc707d3d8376215c50da3f3e1d667c602ec6cbf1ea9135154c85da40007b55d618f9d3083d8048db3d244677b4bc39a24586af1d54546d2933759044a77c3f3a35b79848ce0fdb2e533bd3fe43528bb476494bdaed6b44c8c35e3b7d0ab1f936e734c4bf2e05b8b2f4308de06c52241f9b1b1c9e200ae236c00b1301186b486232b96b8d15c365c3c09392b05b1268b2b8d017c7f5bc22f20462a9647d7ad45cd27932a6d988d592fa246060976548ae3fe28f6866cb206500e4eba18b63b07a32a5e33d0ab2c4173e14686e825638558bf3fd6533c6e9f152ce6bee9e8859d4d65802ebb61226babb6cf0473501798cff74c2bff857178c18494b14b323ef79faddb206b02c4de812e9255e4472e5ed2df77bcf90390d753de48752b53474959edf3effbcc9c5f7eefa2753bb594789598f68cadd63d825d9798e654345cbdfb5f03feaeb8a47524116df995738c07759c1f54e8f5eaf9016b45545bf5b5ee9c224eb2079b86f5749e869359d479e886ca60f63cdb643cc384b6c0794b8a4d8cbab046f701e9b081a9a078538ad2fc6e2b763b3c8dedcad8bee6c61b9130b31c4ef577f0c42fe2daa69c8ef14ab6252f619400a150d91786fdd84fc731d23112811749bc1efd2ca7e2b3f2075c2eca13123860b20fe5f6bd1f9dd4e14d5be368808179bef7ac22325a8798d9e2bce8662018463a7b2314b47524fa9ea109c8790234e7819c74ed9008c9e06394d83fad456df668b5b1a4cca532c61d5ee7f20ac725ee55f224e3ca090304b545fc7c8b42fe8044b22f44e3ced87aac0fd001633402e15b42e86b1a5dd7103038bebe8c15937ca2d41baefd43086f209c19d24cd0f3c0967b686cedca35123a49b37ad3976b45d86823730030ee5189f8531027bdc2849be102048e92f3d589542ae075bf3278e03469b0c5d1c7ddfc3d7ea29e7c3a420f60885aed49c5e957a849aefbff5a114c1f033f59d88c620edb51bf7fca649a04f682ac63afe8d17260939991a7ef1fb6bd8cc5135201ef622059a183217a908fa2f8558b2ea1f4b8c76573b7dc637c0a1a3ffbdbe515bf19afb99afa92915f4926f7061dd037527562d27ea4e3dc5990f599490c3b7a290af6a90ac85840e18febaf6a2e9bc34784d9e6ffa217e860f20d1b7e82927e5c10ad940a4dad31792cf00db58a39627e275160ef033872d40e3b52237fbc844ae537584f1a6f2de543fef279561085d2528be8f30fb5c49d72d0481cf03a8d1d207e1082a7fbf1ca102ce56a5fa735298742e1cd24fa610bbe73b2ffb94410467ec1e175f9e2c0501ec17b414dd9be76048dffd96c18882d186075de893826a746cfc2a3afe86b0ab4852e221648b57e378bcca6ad76591033918abf813dc00e977684d397018701639567c246a8c213c1d6960f30924cc28a1445eb8b197bc2ea1ab5525fb546507dd1fe65827f8476a1639fc5f6e08a83be58865e117522ce52e36f800140d4736e7bcb2d4c5a22a2803e0ef73773c0f536c395f97cda639469dd4d962b4957370287e6eb4d50b350f93a44e26ed81c30c58517b9fb3d72d89436aef9f17dd971de59830b9e49d6f763375a5830fc04f0e3070a0919016fc7b08f4677794757578b5e06615ea4da27f1b0e2e12572feca5e17efd2654c16d50dc30c9f9403d7139d90740bb99d4d4f997662d310e711c0478ed9578dcbc91892f451d090582ca9f87f2e0daba166ad2b9f3c0f75ec32e76290fe4940f26a087de0002a57a0290599f70d1fee8f5d979ce82326bdb1b9d6501ecc17b6a0a20c3ba21bb43021392cf983fc702ad7c7964b438277030b74ef0d9079d96c2b12ec10dfe2130521cf75b9221509b30b798bb36afb5e28d0105e2363cdd643acd95cf8119e6ae21733143d99a4e6bb4e8f5c63556e9ca34ef86383510fd430e3cff4ed4bc92e8baac155c3ad31ee454ff1ff205d91624511f98a8417987d6a1040ce1e2234c71bd3a6e858f9c78a91d101e4d115126420f74eabaed79602a9f0593bd25b1d04fc23158e2f192385b3647387ae8bfe2283789cd585a8c64ade3484369c473d4509c3423f2a9df98235eeeca94722c4e88b2c8164243a61a7cbb7800c9b675529989d8c00913ba877474589739af3de594b0e96f6c834197b22acaca522dd883c68ae9ca846add73afa8ed79f3ca6156c3cbf793063cd9533d6d2fd5e3f4a65cd99c7e193d2cfd9e3b541030e536f48dd7650611094ab27bc6438ec7b73f42874a6829d25e5345116be42b837c53f403ba68f93b9bb58cdf7e4c0fee2ccc4e15b36268414db65edcc406272b5c6864219973e20d8bc04e12c67e63926207c9943f3bd2d325297fccab1d34796d22631be7cc768da221d7b4b7fff46835869524e39d71d17aac23c99ff3366268446094fb37139cef7a1dbe31d42e8f2f465a867d829e8b6aad848d4a2ab9916294734ea981715b5525e7a4174e0c7acee7630cb2474bd011235eadb47c3e02e07a24675a9bebde40230221cbd79359ba02f8b04199018c193b4750e18c232362dbb237a690a3bd5aedc8e86c1186fab190e87fb97b5db4d5eba9abeda44a020dece13bbea81dfee963e2504d80497a99a04447f8a1431f5da063d955a95227637770b804ebefe2edb9ba3ae9b5c1057f4097df20c775e73836a74a40117d04991dd4aeea840cde45e6ef7e9ce501e6ae7da720be22297ea4ac94c335d9e5eed7f4e42b0ab009af9293b175a8d8b222609954dc1de81374d8a62deb2c9ed6c6e2b114d79284dcf5f54b746cd55a9b493a08e6343530b6b760e7c68e001c03107c389dd1ce638727c8aacb96fdda6e1557acb6613c4bac47a7f2df2def7a9b968da88c666da01c4f97dbeac132a9c601a6b30d8b9aaf3a2170caace438289c7219665d5b3881f038c67e2e93f72aa35e100ca1ce638490fe7c7dd42850932d8ee6278099a6f8c0696a39b1f1a45017b3ac6c074bd82680fe36260bd57ccf88d2b4c02b66b0d5f4a374b7a97cb51857cf94660256cc4666a9fd1d913c4c1e57702f0248542b53c6c898d77a7b284d35e470df60f7748a5fce8f7385de7bcb65f127703849625c3ab023c0e007fd5d5f969c45bf92da80a083f86954270a3ac0b78dbcd3838b26f0bdaba590eab8737b3006a95f5af81c29b226c3fa992f2b2e587c2b871927474ad5762246909c629edea407480546764ecac7f66799865fe3bee4be99a7e3ab20d876ea19054b94ef4383c390b9073dec9c06813b9eb72d5835ce705a3122478fb6dd8a9fbc8d6b66a74c9f729db936d0641d522933ecd765de5db547aa45dc73bf9d80a40b64dbf56556ca90b9770f736439390340f6733061e3c10e2ac54dd39b1082dda589a8a68245da2091a99389bf9b5a8b015d71e0232294249cd1906b7e1fc5d320895b1414b2bc9ece4614c13407caa62dd36c17543e8d53d3f79a590a2f9710a34353e893e1e39fb87e13ae55dff6cd981d5f40e19cd278b4c499538f7df332f220c069daa969c0edb06bbc874d36f4984a3c676f4bf3cfaf86d7c706128a4455779eda0d645dfb32935355ee269cbb350cd31edc77b32816b99ee4eecddc10c81c2516fbe3637b031ad72bd9fb2528139e5ee34d8e11c0ca4821968821069ba67cf11b283499130fc509715524549da709af94f60084bb772e97a6b62daa9f64509af436a2b6b07c0939ad6597e441c3cc00070a35808883388bfecbc3dbf972bff9252771de2ab10a86d3a8bef6db80dc00d90a3244810326bbc97d3c7040f7f0aa3ddf31dbd9c01d578051f5ea214cbc2b11a576e5730b98c0ea042496e283cc92a77124ffb59cfb93dcb43e076ada6a75bf6d030b971978963f715da296d4734abadd347c880de6170f6b9bf99e430da622255a01df88196f479d4f621c32a4db47167eaab4989f6f9dd540e9e0598ec6ac2f3c729de496f8788a7f97b7b1845cc19886aafaaba8fdd0521a5e9a427bddc371f06211e6a7dc254cb30916691a504073bf7838bbf689c2dddb545de19256111fa68b7bd0ebf22f577b517e6ffd5dae0404294da160ce97d6771d9a52285393bdf36a2e395e29890daebebbc260b325e4cccf6b3408ae7c6e5171825f4862da3555331cc7e44f90a4d0b3358aa0c54780b9fef050a795cc10dc4d8b281c42bcc40c4b65e495a1c86b5417bdf41ed5edb039a7b5ce9a8668d9d65f4295794a4c5da71e3159a87767da61560ee10f4047927f905a4e0a8875bc7b20cfb1c5983b489514ce17bc7fe8d775be712114f15c9077ffb982ac907509b6cb16453d7fcbe018f7c36c32f51afb71c1ce5e7353a973d30ab5136f480c8de94e1d841ae4624850ceb67378a377e6f714fd36e738d8b0eea666e32a93d9c537ab165c11bf68709a4a59b4cd5b208e451147bb0a926a73821885cd20c9161e5c687a6f776736c924cd330f2887937073ff5533832313b3fecd98ace5fdcba9fc9f74c6fe4c286ff7d954153edc317c2ba38ade9b5cca4fb6af098ff4fd25b5271f3b8d8adcaf09d0c0c6692de618d9675e27fdd5f3917f59ab03f2dfaa6daaa990e30a6dbc52ddfb30bfe11768566f4df3c8db5e06e0d197cb2c7df5a80fb41fb592689acf261eaef8e6be30fdc826fd64ff3697cf04a5856c24150e8d67aee095f2da1ea435bf8a20a54c039422303952f81a3cfbf4cff6f04c8b0c059e75dbbe949354fb3b08ccadfaf0bd1b0a7cf31f4fd57295d33b852dc75bba44d8795c943225b2a67f25697b8df96de56cd98445ac4475875adda8131b85b242a316e63f6f24058dc0d323ba5d5e795c46b8edbe2feff27684472540250719482c1e667d155f6994c31bc7b7fa84e883b3abcddcb508070ae0e5167703de2d9d541df718aa49049d7bd3a9f4e7fe5fdfaa456590cbad6608b9e46a2a54cd9c77287da8a5617913ced8fdd7205a2df6d3a0097a98c27aa125a61d8b178c4bec2f0c0e45105571532b7c8a4a3dd79b7d3a84c9d8525e6378e2dafd420ab6c922bd6abc52d9f45baf26d6a307d745e1f1a5f88c4b7df6388a3efebb54761ea1b2fb4b455b8af64279e683304e3cedc0bed5c56cd9a68aeca06fda2360f25831d29cd97a564d18620bbe101847f1ad2c52b762fac0d94fb24ed942bd06e060af9f863ecdad9a9ceeed93ca8486c802cc0d42e65cfd4146853f05284d33df5dd4ff6966ca0d7766f13cf7ba61298281629f48c378eb80844961100dd0acc72aa724edd32001b0dcacb6699fa38bc430e9ef8f5d07fb14e6457ab09f694e034c8c8449ba9f2013a954b5439e5b6c06d1faf4c63cf19e1fe8e77bea83a9316bda622ce3a440c273bb51d3b9efdc599ee8f4bd4b468208545aab0e934dc498c54d16fcc3c2fb7c407863b508a1365257f7a08ea8a9247055a9d8eebca84c5189468236ebb10c98f5c9e1ff2054a449de7bc96bc8c810e7035a5cdedc0041201c713bb30c609d8791b5b2f80e5c7fae5d070b26bc04bccf1d53283cb7ada2eed4a794500cdf797c0ca3055394af026acf905009082b5f8c1e5f830428c353c9e1060a3b6b8bbc474cee9d1d7f3865f2ca21fd6288bd590c5f9eff27501fd68f96f743f09d9b609e5b392a64ce1cab527f81b678fbf095d4e4eb78110444511316243a3f9b0bf71a206baa378d5ae2e80a797e4079a592b8dcd656967e18f74f2c612bfa1c9a8ea8ac81e6bcf57755595c5c04ef387f5187e1feadb58cb6493e92ded27f14b8a12a0f58d2c5f19bae1050b90043a3e15798d1db757d444e9aa3d5f208a673b4947b6770933c8b3a6a64312b6b865f52428f48843adc3a66d1bf47dd192852ebfe84118ee424b04dfc1ddcf4ffb61688fef98880a15f8498886d19f3a0b0e48e8c1a9aa3da89d755af30c7a276ddefc298e76ec8fb45a0d8d3fecccd6a91f3c3a174ccba1f6ec6e9314f4edb7109a787e1aab95ad4c544a454a99005d36079ec0c92a8b4f1bdfdae1a8d6fe6d6373f76e3fc096f7b590f79ff6fa2a6fc15c24cc8678b8b3a0536c18584b1cf9b2d23f2c741df7a0105da51c9a518c3cfb8834d6aa83aae9601e556115648018c9110a9148d5f10e349651f1210d70654c99d37489c9366a142ce3162f9ad376b7068f99ba9f467be7e18d5e75c9ea7313eea997056066d704c97a4e74ded3b65375c844cfdfd82b9a758c460ab203a6cc331f68c7b0ca45b02d7b9087161d3bb310f2c28510a3c22f63446b08249084729d6546ee9a69f9f4d8d64b7a150aa1d39f2a03530ff2a6832e75989381a12a2b6e1a41c718a933b902b989a3b5566361fa17c57a48e1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
