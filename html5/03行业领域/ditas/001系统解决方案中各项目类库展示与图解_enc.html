<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"56c63e64a75667d90b597477e5f5728458ab9dd8e552bc27b20e300ae83aebeb8b5eca3a5b55345334b9ae0673be91a69946d7737d27e0ec8a10b79a9453f40aae2394440a031886dd08973d877b232297e848944ea3d762dae9c2e165207f0aad6dcb0fd5089e38f6234f7005aae216f6badb5578d8a647dfcc4a72591f4750d60a546ca2f656a3948a352d200965de0714f7df282bddd9531cdba47eeaddbc28768ca3b591ca5f2dffd0ddbb2be9890002a2c029758deb95705748cb9f08ff4c3fb3632127f2d98bbbd2d3ea3fea4a81047a6420f1c5149e40c0205d022b1976f39189cc83120f817c1fde396a007c3457498588efc1e2cdc0245aa7ce95ea7aa1b2f88b9575f7128033e3f1cd580255b608a6ce2894ba105dfa6c2bd61cdcbc5f5e98064a465d3a761609b40be9511e9d561b2512ae8ebde736ea5c0d592aebaa7fb8d4ec90dd821fc265ed1cfa87ff7f57b49b1164dde739aa8e6670c6424934a15d8496b15fe88b7c5c6612d1d3a301eacd5b6202ad9f81c609e8db632be8832b22b9ae821ec307bd04855de16b26baf6e42d583d14964baac419a30f4397df8b432217b5185cfb0426a02702758a1012b53569e639db9cfdf12e18d31d9fea93a464f61b0c8ca4c9d3aaa56f31d5e6bb1fa066b442f67c7d5ecbd0df28e96ee5a0610848116753a5bbd90b3b40616ebe1ae898963a7fd0047ecb28837af4ea7a9d264d504d33ea8eadfd0e49f4835998090fdfa17f71bf2e09743233e18bbe10f889bc59a349dec57db5e983cc34f06fffdec06d2cf0777ad88f4e545893077c92370d16c5a69c1a13c30bb25cd90dd4c8576f861facfe2c199e0268ca962f764b3cfb2530156acc5f9356801aa596b380313b47a9d0338d80ddae2ea3d7d6e5fb4e2b003bfc882965c4fb64ac63c809d06c17fb6e2f50a65c8e90c02640dd3b6acdb3d23894c753c55b41d469119ea5d3980245b5fb7b76788ba3b6a16ebf4b17b072dee2311a161931616c3a4a4000e7cb807ad96d7fcb1bd30eeeb98ee9d3e290c0de2727dbdb53d7f863925e2b166fcc01712f143dcffdaa101c864e8d77b876ff3e99c69d837cff93b58505ef79e9945b1b09c9450a5d7a5189531aa6f7f2f2305c4468b654abfca21d9099e35a20b6a088cdf660f36b0864bd07d0683e3f2c07b654c5f42bd6e10cc423352ec212e14dfd95f8c62ad094fab3cdbecb8c3237d33e56e50c3a64a17263893f6869918c959422c390f29e459cdef93d1acc1b48a83b99773712ad7d792103ad2d4f353da6bbd49be63d90be1e190c0696d9dbbe7f6c3562c72782dad109220069cc98dfad60047decd8ead99b3a4ac6898bf902a045fd90b65ae90ac45adb3f7259596a98267fbf07bda69b4ed54fd74687ef480eedc3af27c1001064f0ed0876bb48de56bcfc513f1e303bc32eaf42be084ba17d31d4dedd16371cd465b7cbfab98c02ccee0d6cced5a3bcb86625adccca7bd640cdc219d097707a83c13601948e440be7399015a8232458fafabe274e600695126362fa1128a79ed6cbeb036421d3231fb5a64ca1a6f9ae028d7e03e84015bce7c75d508d5490d59bb59bcf126e0b1028517f4f1dc176133308a86ed032215cba99937d75e78b2fe88124ab8ea94c7eadf24bc2dd43b70d00a6f622032e3ce88cf8b4f0c241d1e81fb4f3c8003870eb736e230d18edf5c11a23146833a4e6aa9ab047d512090d2411736422e29e9436d01b487480bd330b261e6eba1e7a06f95ab92eba99af4f162e6d60dca335669c9a1fbbdef1a2dac0efa85d2ead500a4a3ba93efb548cdf56f040ecb0f267e8ee8f657359d0d13aff1902a641a950edd1b0d0a46ed86b875d800d93a6346126e240880af8958b5885ae8b3194eb792a51d773c96acb7ccdc59f00524b0d03665364942049885b0f02fa2e1f0ed2aba127010566451880d42dac27238ca654dc7fc9d915e167e47300e4ea0de68deafcb416c2f4ea0212c2d84bd876e1cdc9de30890fdb6aacc0ef404ae35db96657d9efdc56cd3720e82fa22b434c10f8445a8d195ecc032ac4d183ae311f7f4e73ca3c91e0e657caa1b54bab0e0bdc705a9daf8157ad8a3e320b5738e0b10b2b2fb35c46b7b05eb5f5e3627320fb07517d412ebd810b0b24aeb9722f74b9c3071c1a17b419bc6737891b58ef9fd15f60aad48c8f61d3cf2b722db1c557b5e4ad788493a0c0e6f36cb1500e18ea13fe9e388c7116d791128b2b584f6609d7b4e351542a06e76f9bba4d1fc5c227e573637af4f3a5056e0f10d2be30f1abebfaf0404f33dce456e0216c7a443f560c04dd949384546f79ac23d9ae26e147d4b88041d33ad4f1087df8111eaf6a5ebb6813e29def380efc85d2f8e5b29162f8214fa4608f18aeb3d167814f34b4ed1a64a20479dbbe5c1bfceb7b211790b010398cfd1fef07dd7b102335a409c11e2b4e49fc3ea17a191b78c1669582e4b97a58195e20d1c854c12ff19004ef19ddd7fb6f39e25274e73902e3423d504b75e7739dfb148a3f6fcf7c5ef00d1f688b0b5048f5e156d2a14983209c77b496b8cb42fcbc786b3f28adc47c4068ab14d23e070128c70ddae1f89060b1c8f965488254767efc59d5e58af68a772a3b30bd35a0bca3f5d919b2e713002541f55ea8bac4264337822f1667de7c3f8f7f9c18f4dc2253c6a3dad2b197e64f3cbb4d4d8d8c3c5b10598ebbcf4b4be88440a5cf0d127eeccf5982e7dcb5be35b0af1beb8bb050fdf09bd7c60b7c4944620a54f88b3e7222b9f026bf5b750a54949d479fdffe4caecdc086948129fd8f426c752f0a65d0d483a3c9a489ef9d418b7d826f6f3a2248b6090c19177449c148651b7cde9cee630bc012d861886cf52358321ef80b7b0a682b0c385f09f8368331b5984f406730a3f64c68085a1f0eb06e56776ed9c5b41c889aff1bed55aabc53397662fdf903c5fdfdc9739c7e02a97f09994f9e86e2eca172df11682f23a5f9320243243aa1e163f71db9992325beee181ffe49273b9a340269a678bb6318259d60370cacebc3f75cd75e8ed88dc4af9d9d05441a017f2d035a36cfbef4f857b2f9d318a292db2847e87ba59dc8768ca15ff709d6c8509f39a5ecf88b7db914fe151c0d3e4976d8548759df0fcb0ab2aab3418883e308e5c054a232775d6f22f6d6016bdb0b01be9c1d827cf2c9bd9f4d24e9cbe90ecb11eac8145c2cc7693755319003746ff924fcb9505b58cfd85985935fbc7a5ef6096f2b6b8038770a5d2a1df5840659d4189c099ddbfb492924751e95c2ffef2ddf48d020ef19881dbfbb3e418112812537619b9b20db67c3f9b4645a536531533d560759fdb14e6719a94b86e2ff7f702f4fd32ddf6dfec7e7a0b8b8f2b050ff5355874ac6ff77a2842e7807023126ccf5c88b2ddd80d421a2158b0821c0b054fe9b48513c3509b4b6e7ad1f214149ec96b90d70b1723ff2cedd4c6c2e48d4a4f61a8543b29e07df656c6139b5dd8992c93eaee0a034397e4115c8081f90e5e5b3d91b6b95576de40cd3e854642a8f823c338276117d844ad9298960f41abb9779515bd5891b45d7f75e0e3abf0a43b8e9e670961e1a11e06fedcd5a91bff839c165bb4ebe790aba4373a03bf11109949071306ad3196d51e5c3a5b8faa4b776ea99bef8761b38ceee2f23291306995baa0782eadb3462f3fd840aac520a242966e8ad7f10ea2d0f603ad3eef2aa1ab6ea13eadaa7c4c99a1526b8c3c19bc7494f85f42d0c2fede60e8fca7ed5413b931314f046480688ab88906ad3bd58479cf64d4b88d96b23fb8084ec977a6d14df9cf6b514468d3f8397ca76a0fa463f4f8fbec2cc2d83b5fe7f9d09599a896d4d2778981f0360a805f5aebc69586cc04518a7d74a741f353a02870ce5d9454427c4c0d3f1549810d820693585c92f2a488d1f14a8737662094c2b228420d642395c353222325fc3d082df5c293168459d8b090b2ac0db5b3c4b46e0be918a45d17cf8d4d01699e4130dd143d03de837a863f964454c9a5e680728e02753b809a2bf4637b63432b5fb3e76aeafb5d06d114115937d60e345231777caaa6b92149e737cdc3235337ddbe09b1a79acf5e21c675632e25fb0bf72f319da7bf47a59d88b309fdb94e77f757407cf06872ff058d092eb736defff7bc2607f852c771a60cd336b01ac8c714ad0a8a34652c5e14a01a13ec3cb576da7f0b0ca9309d33d28d48b1fcb948c19830261734dcda5aa0d3dd87f5b0020939e19bbd226c861bf826024d2b6c86be66f415bd7353931800087515240db26f4b4db1804fd2ca9e6771b0f0d3d2bc5affcef5204bca8abbd3550b6a9cda1b519b73e3df9d32b9fef44e4f1cd73aea04ae2517c53799fa8115d74882635845b3c04a6b83d9f5732fd9a73040401d834132413f4da70f34b1efa21b21c10af7472a92166acb61587ee4272948a8462fd4212672b75c17f56218ab96180286aaa9518a16de2aad331582a4b67d210d5e8e9e0c14915eba381b8b56955ea5e648c449cfba942c74fd1fdefc5b3d62dedd5443110929667abea99b4e249628ce88ed1c1c9714e063943aa0702fe3179e9b617673a40ceaa55cf4466f373543e34482089093cb2ef8559caf6748c2d49a2bf9d53384552cb91cf13f9e61e3fbc299a18fc00a4395d0d8f0364260e971af19cb6ac9bcb0b163e7696eb608b7048ff90bad9c2f337ba9edfbf810521bd553b9857adb151c501369c4fce66aeed70cfb03a67199f46cee7c1856bc7f46b2326cbac84c2a14d5d5d0c2cd45c722c84e1395554573b3ae5d06f54a9060bed7c3bfa628e617df9ae47344ab1972f36e7b7d7605dd40151d1eeb3061af18d225f9e22f25fe61675b574867908f3b3f722e547b96c44e32cd1cb1d83aff134d91bae7c25141c9d9b59c73149d19fbda460011beaedac59010ba829dbc002c2e809cc362437aa17771ee5d07e547125b1d34a68d7bab1d298ebde17efe0aa4fd36b5534d7edbc90471ee49ed6365ce9266fe461e3255abaf426fa06413e7352132c7c8ffb66319f8de2f4f59875fd45c842212dd070c52068fd8e25219dce17a40db30412f6b102c1478e96e7daae5e1fdae40880771db52e5b23495a41b320414005badd34658cfb4abd9a96795bd8d0b6e9cd1c05b6e906bfc754c8abe29e0ce5ce9b7e2a7020d5727bb51c07a5bc92f6d287fb73b6c489f06f95f30d90e9da010ee4ada633e466b5c3032e5da21ff28ae23dff8c10fe2d56e340f43b2be8c86f8bbcd8b05360aec9a622aed2ee313123882ccfc8e80a2363cf6dccd054ee9acb9b451601dcd3daa24433cb486125d3246ad584a2b5f34a1409323ee60d2e6b03f41e5fd15b66526d04b7d77449a34794126fdee7f987853dd76f89b9877fd46c9c5735aa152a617d160a8bc8c554b8a126ea72971771420d914707f9013637d4d74951dcf16b676e5c6aa57a5fd75bc83f43d1af9f2dfd1c3171930b694e3e48db607bed6d8cc0f937aea285557d0928f1101520fde350c6d71954a5d4b753cc4668ec47793f57fa34b438e63716565d5bd8cee05af6464b75e124e31975e32039cf149c4ac69a38414c4efc016b17213ce5fe5c1fdd1183549622c45575387186bf4ee6c242fe3df97c0435bd6eb30c6aee112004e75c8d866368d1c56e88dd532a3f46be8f7b5e3bf093656d71f93d6a63abd392dc926a22f0f02c239f7c10baadf4e4387a792501043caba6100ebdd7970a9c7e71de640d1c6777d7078a553b97241a9247711cf5fe5ae10fb8a62e2eb4cf132f059e9495f016959c54587ddfd06383ac8f4f3987fa8ea39fdd7b1ee465cfc195692cbd914b504da9566050a808954eea219603f1afb2f4a7d861152f39524827bc3f91e2a77f1400e6626ba4abaab6b2ebd0ba278e4dba1e3c5747f99396b254036679a663e13ee1f20c1ad11d9553bfd2b64ba2beb01d2818b2a917f413601969165239457cd0f1fd44e0bb23f7663778981b12ba6fd94d7cc999fcf3ea3d6d0e1626098095d000122a79dc0af4fb42a94981b1ff051f3a63ea9ac24ead4d2c508561571ebd2a86220792178df172f4991b34d03d44e4e62e4dba91ea7fc53c0906877b6cc1fc4732761aeb09ef064bf1461e55bbd38de5eb33f918b36b06de8d89cb4fe44420cedd8e06db3ebfedb1b75f1e94bbe17cb23c68703b57e236bd5b707ef36ea03e8bd973e83cf794136b29604319f65d806f2ce61fe0eb484d11be968d2f2d3b0b67e67ce400e44bc882e6dc3e068f996cf6e02851250e9a71802d1c8a5eabbf0b8c6c6972e8290a4a0324b169e8a32c3e925a9fb09ad1adafa3d3786d77bc9a6dff86ff6fc91ba4299afce89a96bdfba8875e9d12bdc209aa97f2cc4bd0050693912b2aa444889b2bda0f8ddaf78163ab4b03f88e17c9ed317ad5f86c80c1d9c00e25b93be1a008b2240084f376e78e4bf8f4b9a79a064a2c0c1470927603383952c0d0ba34ff60b3fa53c6abdc5cf1c62820ac114f52d5630c1031dfe233ef2ce7aada82979a0c835a478f647fbb14445933e19debada7470989de9a48add8835684fec9e96381fb11e4c3eb3af14c6c8afcdec0103de33e83d12a3a0fe4a8b12b5b9d5fdbd7e5e815f6407af06fea8cbf0af5e1ba714009928431737d8be348d4c0d73e1a273b6a0c506ba56ec47e512b2bcddbd5a5561b0971d8623171280e971ee9843767f661236f24de866f1aa123521cb449fa9c8ef63635822dc63ec5fdc630058d364ca41ea9132cc27aea998140042aa9bc65198d1fd9aa73c9c652b91602760da4a6c910247ac1c0c0884c40834a7941798229ea11112ea03d3fdb0466784de85d937bef9c3c3385fe9e38d8281edf6707e5fe2d6499cd3a6670d7b11671b0fdb057f38cb46ea6ea5daf30d39bce8ba4ca42826d37b9f51f9611fa42a5c1c9496fd0d33f4e912d066b3f7cd740c172c1b3ebeb8085c7ded49813b701b43913d1a420600e371558375d3cdca09262deeb7bcda3cc683075e9b04c148a00e1d288177c3db5307cea3a5d6f501e378d2a659022545932976a9c32dbf31677f5e839db1972b862746312688088634353397410840933e345b4455aaa47d3888103b86a9985f4200a0fead8f34b3ab3fa392f5c6f55de6e845211c0d03ce0ae51fed8bd9a03f592b9e2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
