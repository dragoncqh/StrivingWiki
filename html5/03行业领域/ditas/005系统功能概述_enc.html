<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c82066b640f8d6ea19083210e34d03c5832af9bb981996606a9be0c58c61e26e29386645053e44e5518b601b9b17e952dd29f83bd88340ffe15acdfb9ceb6070186b4f052cc43a53543664848f1d7b5fa3d3f9f8284f63f3f30d57d6837fafe6b70d624d18882a38245863cdc069b385afcaf6ca2b69845176e7164e4f35deeb3f0da95ab704019f6b8c8a3f8acaa68bfdcf4a32f9762ac3aa29303b234f69f56f7ef09736c2b5fd664d673278d677dde66f0bb6933aeb65963b77694074effe9babcfce5ed8c30e117074aea0740d53de8b65f78f5fa213a6867b15b6d899d73f49828990dd32e5c8f2219988053867694537bed5eda553565e821b286f6e258238445d47c2f702b7dca217343be4334be992d0c6f50df791ab54aa53ca8e340c6bb02a2ca8deac19883ab3df43181ea96e6ded44a2fbf1cc746067d4e3052ee127415f8fc6a932715f893778fe823f4b576c20a8a0d2635c7927b5681dc4bf6e57d9d37972eeecc2066475bce8436f829bbfc11eb1549ce34b0d60026733c5cc49f3e34d09f4783cb2fce3d8fa52fb64c5c6dcb8fa9dcf67306f3eb3ed94eb0e109bc18ee37b13aa489ca156060da70b92e6e44df7a3b34ab3acbc475873f9cb17da7c4c53828a47bf1aa1746b3d27434dcc932769a26e0160643eb0fcfa7156a962b3344b6f5fe17ff9823ee7ef77bfbd11d6199b14a9c87b4ea349c2734cb90a3f3a7646c0eab053090dcbce22022dbcf70ea5ece496e416530ab2df285bee4e0c0d7464f846518590cdbbad1438ee62aa94b87eaa0ca7798244e1c81da8ffd1396d1cdce3cc447eb29b2655b7b58c7c7d359e3e4309a7c1af072bf40a91087769f798b96636c2dc0ef3039d40d39536f86b662658f2cae64b193e73276e5bcdc2890d4bc680cdea3d82580a3861a3ee4b10598eda4b061ca796381c544a4a65e7bb5c8765f10e61f0283e1cc3d5d0944c5c84b465596e0bbf051f46e2b1ba836fd1deccbcb24c4e1903f662c2d8bc388fc81c4c37e64c27ff00072250e7bdafee4f9037ad46ddb9af506476a018bcee0f687c89b4f591cfc3bdbe0f8ca32d50b6a15b0e0a5148a86211dc5959db23d470d414dacb2d4845ac11b4e464fddabf81ba2c12dcfd4e8ae1ad95ee10e70cea0772eb9a40a96b9d7a1507075882f9d13aec2cb94c4358cff766c60061705dab5302e2d323492cab1a32abad7ccafaafe323d2a6569d121ff6f86770d9cd8a3061f48f2f7d91bdb7760cd647f9713f8e694715a779125d452d10c0dc7779eb4a5e079e29bee08a90e996204cf92ba163b000dad8204ddc0176a3418de1baf0ded1988ff56ad8faea5a6ec1e3e70cd5996204360f77239072bafe6571e507a9278d2f2da8bcb8afe915ab75438dd3917da1a34a8ffd742ac5e705e15c8429a6c3f35179af70a048eb25e2ad80b0dd80a35dc4b7c6ed0ba66e339f093317544701c0d3b1ea3ee427deab0473c77577dd3a34a897eadbb5dafb416737c10fd633e6d985c231cd93cb115718737768dfb8046a4a7649bf40b4793d09a349d352a06c26e2bdd25ebb12c409968fd51a6f0ab7f3b9bff38976ec573435a4e50caf2b5ec0c8582503e18bbc0ac42064284687f256e4c6e00f50e28b7c964f808d2dcbffb5c50a417a0fa513521cb80af4638b453cea8c7a7941d08d55c5c06adc58b3ad5744d634c04678f985453913ceb3d8e40c5fba3d4ca64dabde3b3c6193a75205261351674a7e8feac24fbf281b0503af6fc4d241980a888ff1ba87782fbbf50d5ff3123998a004b4e0d568363223015bf7a083fadb05375497dd85c7d9f1fa79865a2a12fa89c18794a666beb2dae16d71569e28c1e27456b6a9ef734ac693312c1ec52f575770c493ad86a31a6df06a0b244e7961164329472e8ca3e484c0171dd8c7842f629ec2f2b6f4f975551ea594ce0c4b894d14da836bc44c147942b453749adbd8dc372df8eca0b26451fd6f8d21b3ecfce3b5538476805f5da034972baf463f4b9bb8256379e9a8ccee0d10e0cea2f790cfa0a34062ec120c363843a44cab99448f82f50171fe3627ad8e03cb2cd8f5b72d932639a5cd3a6f10765412bdb5492069e25a0f4209fd9f6bf35e4cafd53450729b2652a8e02c9da2acd330e981f730d9f1b2a98b45298c008c5cc52372c8384e55d0646be578b4f8ea10edc5c278317a304df96f223871c692648e49a4bff40bba2b4fa10df7ff3e87fe4d96a6f3d480229866b42736d52598366e0e18d3fc798205edc81b409b8890389a8ebd42137806b606a65a2e59206a66906385deefb5a2b0cec2676f603b25ba9c429291630f59c6668d109fc5b0625d977357692579e4b27559701c2848f50c73644f498f2cf1fd463b9e11deecb6df20cc04152cf1d21432c4439d465cefab91a173cd258cc9c1ff987f2c161eb6c29d7a1d27017a1067583475ab30067ba95cd1bb6c56506a8bcf859024ca4a4c00498465883a5d4f80235a874ce03be3c8acd7a4228dd2f91dfd92d4c9881628edd06d0237b0eae402d3c6a4e96e25438f10dbae6f84c6f1e2e82d754b5a934e1ec9ba3b8e44d1d4fc51c61485bd05a43f71ca7ee0b907251464e752a9fc86f039cd4cf5e3a8daf07c7c06fbf68c6337cee3f76270a016e220828bad065a84f3b96ca756b89acf7772e451a4912dd568898b9139f01f6bb69488c9e3e15d0b63b8cc52d14599355963a752dfe94e2802fb52c978aa47f368e3ed4d5b50a50b0ca118255d5a451f538ef810108133cb53700de47d9a01e89834e5158ef55af4f2058ece6a875ce61a319aaf13246d1dc20cc1a20eddbd520f5584ba25d9c901d8e4f9ca0a2c82997379ebd6ecf92590b54b48cec04d9cfa7703be133ae7a852eb5c37acf86ab2178a5f36396277f226e47dfd8baa1c7fef80cceb45a017e906a1f9c19b7a9db95281eaa2992e8ffc63a9bae24ea24dd643f2bdbde8d239cea1e0c5e3662a124be61403db1097fb13a4d9809215b76dcdec68f16c97af46c5813397412f25563a3b8d6b93ece53f535f74178445ce66cfeb9d4f17209ef337cc6dde38c86ad17c31802da4775ac69b826e26f66fc7b18f4f7a43151d650125b9d8af9c2e5c41e99db2fcc933363e5d83dfae3459fb20171b4451557f7c34c879b7646eeed59ce289b45e2a65491dc62287ba526f197ff6ba0cc178dace58860f5f6970e2f07b3a730d89997398a391537a1e0076ba0ccce3118e60c9a590327f8f3ae7cbcdaf1309c29d8854701ac6fabe87323d07e126e677a79e61df6019a41a4b930bbc6dc85618d208a9c958ae1006ae089e9b8d24ef37bbc855fecfe5e5ce8b85c2349a257fd4057c9f3cbcbbdb1d568397a8ad0b75bbcf2086ea75429b28b01ea805cfa2cf10c371a7e2530a0f2604143f885954636dd338c0cfb079e3196c64905961a3f0fb3bdfc702be91c665257bb03bc130e0cc7f02add9c382c88fd7695c8d58441aaec6bd55370db6f415a4f66ae89c6c99cb3ce42dfce4ed87a2789c7a5948bf2c44510aff7076d771453d4ef0609b8830aa65821962744638e8b669dd1528d96bd8c7a299b5eddaaf7c798f806cc753d1dd152e46ae247ee00e66e6dc57357c448838ba687e5c865149a1f4f52a65081e289326c6d9e3f0aef0053fa73953db8ae3e8b05b511fe8e0fc32d16930eeda119b22e3cdd5dfd2c14f2a9e5ef1effd8249811655ded99f1d206e8ea877a3c6c7aaa9e611aeff8b3d27545daca6b5f1ac676d5603f05ae143b972e1edd2121e64c8f2f79f1088b83cd16e945fa0ae1bedf6ed0757020a9891af31daee00be77f8574b79ad1446b8a721c4a48851ddfbe51af2c09a69d79d21ccf0bbfe4d1d225e1b814b3798340b6abca1230c473b800e785afbb9e7a4b453b5eceb6d288f9051e10438b1dfdfe610fa998ea213b922659c7d8e4dfad7474527516e8f5ad9c96480ccd1825c357186ef874e50eaa6eee4ae4608922b327d2454d7c994858480557bef71fe6e160c8ffc2f1c4f3a482cd36f34b658e2add8cf1fe26222a7cf0adc0554aa3b0b38711fde1ae1e57c75ba520b666bd60498130d9d8f9d8628b07a4e40f2686c6d43b21dea591241c1e1f00668eb60bb2712293c6a3bdcba78ab3c0a34089bf552b79f15ca1b9ea2ddf5eba04caebebe9c6c68c880bd89446bddb932d7746287e757d551153302a76df9e94371a3aa44237970bd066b91451632622056acec9150dba031b6b591c35751bff109a37889be91ed9eea3c84ccea17a29cda1834fd841fb122f561132a6441b235d86c9bd93b9dccf906f9783d43afe297fb5d848832c5d18b5cdc6860513146797606720e16f555953f0b98c5565a7ae0be5c4c38bf12b7aa5d498af7770b377a57c19ac5e34105cdc0a47bef6aba8e375fedd25c2bf7363b864abeac9ce50093f6543143f5d1318bd81bdfeb21c0715b0fee8db1c2b869523119e812c46521fc1b296db7b8db848830f72925cb21f1e7ff63a7b2eb40c9006b0255b0d75e3655d8aaaafa1f5d5ee196a372316d870419dbab5ed0b9d3a39276668604314e95085eb3b3d0120854745aacadf0b64e7045ad9b415278882a639e5127eeb3e6974c8226be723e2455f26c9fb2058e174a6d4eb21dbb20bc9a6d29a679ae7f01c9caed722d1f68589a05c33e66b2c01ef9d1f926231847f0a6333dbb75de7e033800be5ef3ecb2d16b0565893882ef4492a2d880ef8e6816337a137a7082c9020e583818700a2657b6f7c1c13712bedcff8a1d8fc0c2bb814dbb03159b4ed99ee4c9514e262033ade52c5df53aa17864b494ab39ff38fa4bff51fed3878c08bac82ba0b058fd2922919c7e3980c4b8309181a062f872278861842c4dc24cb013603dd89d71beb132ff26f8a546d017a7c9a0943cfc270176b352386b0713a6bed58ec22dc8be8f383e6532e3b08359ec59ed64871570f622916e97c9c8077f335bb83ff14eb5ec2058a2b6f132bdffea03c7377b5a20d198bb39ec0e56edcfd6ba945e8542d68a2d678d34705ab75f852bbdb0657ad00fb1322298149d707da111e658d717aff034a29f017df7d2243337aa60076e4fd10bc8223d0e32b7aa2d7058e2fd6b0c38071e39f1776e81828d66c84c22f80b1db120756a6aaa73afec61de8e100c1d35c109733bf03f2642ae289de0afd765d9dfa0524f40315c4036a64533c56086408f38ae1c6a9c9371ecb306cd13c90838dcee7cc73c75f8d0f97eb7db1691888a78595cba2ac1fcd484ce3396d3d8348cb659ab57693f13d546d42fb29e9a63e889354b45d96014bf5641476b3156801c157cde4f02c7800df1edfd01dd882a810f9bd83c2e3e3679a5253eb09473eddc91ee3e085c37e97fbf53a0320696927a38f4bdf8245280f9f97aab6d51509014830230a9014ccec4062330fd4b8ff1053d78ea877ddb7cf676dd03b90ebccc49915ff0bef59143ee9dc9022e060e67167d7e5ae4973395c605bd937fcffe4c24b2a3c4f3875d47dfdfb7f7ec02771707ffb4d323549e4a97146cc3da696a6df4e885cb66b7e7ce4457465cf4afec31e8dc64815dae071fb9b9a26ed1cf5bb2afcd0dcc0105e57ddba0a0c53eaab77801413e6f89d2a18075e82460c547f643c1efc4796ee1ade2d17977f2c9bada13242910e974dd5d57a27e28dd452eeddb914619daf5d20e5ba1f57a6c22fabb1acb705dd99e7dbfbe86fe749092f9954ea35c789a0faeaa6b8c144f0daf96b8e38e2c4c5e89927fbf8828754536b08350cb2159165b2ca35822feefb9f16834f9970be6eb67ebd03ff87ea5ed4c8f5e0979443ad13b1d69b11303ccc7d5598d0c390ba22c9fafe8aebb9680e5f0b52d2e18444552a1fe103da533b0c6948d429f9921768ef106a9d782bd09e73e2b8b0ef9a9fe2506fff22faa5ef4eb1726c46ebd3bfb3a4b7391312f31463a1de8534e1a3cc1f6ffef192571fdc1dedf01de4d7a20d76401b9a218ed96f8e0766ab180ec7869d9292212c172917161775daa0617c1a192255c1514ac3395f0ccb2bf8ef9f8fc7306b339058b88d92c4e6ee964fe9e2aff150ceebfaededabcce310a3e9cc2ecd72a7d4a038b989706edc81e157ae5c72cd6a42920575aabe0ef087ebf7b73d5270516f47a4c5f84cdbdaebcac37dce334728ca69744af4e82cfcfa00d9e935eb4f81362335d2de9bb2349f5363fd36ae5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
