<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"336cdfa6923c721a5a1a51ee7bb22e0b68a6c199b0012b59ab5ef0bef70a4a4ce75671a6479d666107d17281652ce7863365651597b078f77ea81b52fe2432be16849d1152735989044009141e93ec271cf705da00d31f08bdae70a9672ee5182257c6c09f1f83efd3ce3b88a686f25acecbc5a698ea9a7aa535fc717cc020a7322847424d83143f59f93548f9f517c01fe91d23b5095a6514b59d91175733975adaf4007f6573d57e6ca7ef30e2b80bf30af221336c20101b4f81da89f619214e34efbffb796bb041135c519b699ce2fdbf484291f5da3965806d3f5ce2813cf7d73d5be34cedddcf95d69e254bc30b73e376c98fd1386db076777fb5664ec0393f2973d3a9227763dcbba730d9781a11a0b47f5db0986de17f7db8f084c91eb88859ccdab8b84490e19034b43e59c92d3d1ab577d70489073c69c584b2a2d4e6577749d94bd62825f3ca6027141b7e60a3247c536250ab559309210ebfdb727486a29ec119c2103274c842fab1029ecf8f3beb3d337b32228ce12f09c61f408c9e37a943431f4de8cc58bba8f5bb348dea4cf48c8c8780ba9dd6d09cb6a44745e13a5dcbaf9eac96e3a3b27533ef28fe6ef9b48e4530d7a32a3983b36577c894f84e430699702f0e43584bcf8556585f45789618ec9b0e10b037f1b686bd530b2ddc4dee957f3fcf03364b4ca900c73b7cddbe41b4070316374f4d0c2a386ee8a35fc4f5d7d34628b7cf82b156fde329433cef84e6942a3eef7ab95e701faf6ed05ef4ea3fc79ac935c924f574b34915ead2ce4c151aa29ee8ff5c1be396dac806adad84dbdea153bc90274543fee2cb2f2ea36768ab6c557f10b4e7edb78307c9004e0aaab4d8c9495acb977273620b4f4c76418a5ed1a2595c8bcbf16d8399c8dafaaefae8ea9d5ef4063cff507b0b0dc3cb484ffe649aeb3336f98b72b3c42564a7416e0dffe91a252672b1d894d15d12efedfed3c4986c2658d1efbf57ca33397dc90d2a4a1ad4b1467a6853467b0d16385d2fb20a7dd4ec312c85d8e2bb904e57b4a2cf9c574904779494d18af60a95b86c966b969a8234800aaffbcc5ede0da4f660f2a7b0718d36007ba012e0545e925b04a24e7b64bc4fbac8e77b918997c4c6e61a262eea770d428b30ee265efa1555bc9290684aee0c221de301c6e07b4c2fe4aa6d4db733099cb997ed732f61c6714be5e85017e611493ccfd185693f1b808d415b397f4e22fca7036c74d52726b670a8a4c5e69f783f1e01638cdcd3022741cae1f82d592bec6056c01d49fa288f819ccf3c0619bf49647dcbdd56cdde8d52a1ef674840b8e86b8ae8fbaf1878b7c724c2e2657f0592558e100175f1d5d7343d7018b5021936af1cb659ecd6d7996c5a86ff3cc5df758e1921247157a19ad450497cc34afd5a51aa51f74725d2c91349f458dd675d9272e8385574fe0733cd28c56a95fafce57b7f7350c867e694e664840ddde56bd7d997346281fc857072e4085ed8c42c93c2a1ffa00f7ecc58609cfe4e643467167f492e96d56977753603d69b49ace97a818ee3e2aa1e9454f698aa3315714bc2fad08876350196eb07a3e44c3039acf6fe58851f8f9b357fb7de71e22887884a54c3c5984f633da4ce5e2f9a8f25d3ba5aa9c597ca29c0a520f2ce54d3e2e9a4df50310b489c34565017afcf33598ccbb7207f75c9b47030073f46d39ce7f0e74295d15c5cd3c2747cb94dfeb393fb39fa7b349bd7649ec986e0d23379895ae43f10f34fc630f67fa6af3aa8c2a9923e17993c919f9587323ba58e16fab7e56f476f9105de2ba8c5cb532e1743b5d2b60fef6eebd870591f944fad4806ec2b8f5e133ddb2233e9b2172266e03c970c2ba9d4bd4fbcc0993e6d4d61e12e32ac4ddf5041678edb5e8d422dbed125a8df364831abfbe9a60a683990c0c94abe355ca44fb13a327e93803be60cbaddd2db173f6659229643ad504fb1edfa97c1a5d3a2cd713d21788053932f4061aa3c59e5e6ae11b04425b22d9bdf10ec93b77687c2a08c7470391e2c797fa08e021bcab0de7d79e08e1d8053bce8cc893611ff83facabe941080e845e269d84ed374ad17168d8369566a2e577e6f5b40f6bce00f81920de554c86af081adbcfd33298307b8c719ab05bcfdbb1b70f993ed70f8c4849c23404b429ac5d65b2ac446c500b3a511a04afa88b77c1e34cded4ea55179578a47e4d14894a4eb0e1f72a8cc52c1cb0d2a360225ad84fb8794debbf8a1edef2a1e67a70f6bfa9b402f42c5ed4cf429845fae49182830bb3972bed6301568072440851a5361ee2b6134be51dc5f934b706b8212a257dbde5db75b4de5f47f61a9cb929dd5a32e6dd26a82bf1d99413f38ce1ca012f2555aa2bba8c025b89f99a337943c2dc1f9946792d9f5587913a1f4fc017b001a89dc7f67e6ea1e538e7f131c3a871f5cce7394c2df3f580ef8f0d6104f2b68283bb5b9dc9e9a7bbcfd8afeeb3eed833dcf34b531fb8c1b5e01f5051c5c60f143f35fb74614cfe6e0f96896cfa5a296bea9fa82c0db2ccb9a89067afba6aa66883c90227993188497fca1ccd642c2b542ea9ebc757c51de94bdad0d31314810f43234ca4038e1bb837744b7e1e0a79224a01cc8044bb0f8345129d5b5cc963703daa36c06fdd13a4198581d2a1f278051f50b66541fff406011764a83ccfd2fd8553b3d0b8d8f28e6759cdfb3bfa4f04abd50dc633e836a6433d877a8f870beca2554e6cc3d6ffea85eedface7f44565145ce3980ae5ad529b53a56d493356be8eaa32eec9e222cc7df24c08992854dde98214a24e6ece7cbf9010867c4d88ca208b742d640347ce56fa028b1f3ca3e88e1f03ea893d0811c0f32ead37d1a77de12bb8a9fae8684215e2b5774f2cf486bb0779fc62d96d5d9fdd5176e9f051a3b7bd072c148293b5ab14b25ed9e5d00377b6b13414e1bfb965633453ff074da6c8400aed72f56daa6ef04877739622b9db0535d681ff8463f87309d2ee606f21213a6091e14c3801043ddd24b5de408f8d808935870bddf1189a6e2e841b127722c1a5840e5f021b47826b2c43a661e06bbe159ac9e681177ca0bb520ebb87645a067403f54e415b0b6729b04fc9bc8895f80cc9c1585943033fd5a951a8817b2412be08264c637b217a1e0de677d329baa9aca5ee58948d4d433daf3dd9f925060c337c9b3c3e9ac2ee87c5c9371cf692f170f5bdadf3f242db16e16c34a5d6ae1ad44eb5d4e180965989101dfc3b9fcd9476b332b8261c3d8b21a7055e348c02ac2804dd57e0f866167d6bf3071616c3e1c36de63307f5f01468d1937b4e0b56d1ad520452bd1c6064abaa63a6561f26dbfa7686ff189eb299dfa19ae90a7b881d3ca1fb52e4fb7238347c1bc1e705143f16db033034130722c18dda5bd492a97d0e9a0e3a3bd764f8d6076563f98329f302a76cfc3f8dd70b3e9630acff596e72eb18c0d98121c51f0b4d93ca5fde2c46675fd71a5fce55e816c9e6b95ff0c4967e8d7766d37c6f965d2895819381cab251594cc13629a46221adedbcb32d0fed65c596f81197e77d8095788fefa6f97a83943f449d6e444602cd8522d1eadf79d330e820cdbf09f8fe9708b51a1b748700d4a5c18b6b6b92834421fbeb8ebdb6698801034ea537ad404110e09e0fa226ea0224b296598ade85cea9734b2e9cd30134452319174867e3f8ca4da83c542fda53fa03644352a149031904f9b604d3cce2c0730bd783ff66efc3aa692e5f01c6e0cc522c7651c5bc97e24a5ebfc3243f80cb577e3b0a16d3be85dc7f3a8c61dc548150df63fd0b3111337759179c34febce3ce90fc9cfbf71360fb576b73c4a964d024ee67274cc2a33446c8fe63efffba97b2200302d570c0d267a3c0d4ebec7095002009e49285d593c2a93e88e62f1aab3855519f1563b82b7c4a72cdd88a1032d8027b97dfecfe3a2ec41493e921a75a3188c5e94792aae96a8b7e7b3a466ee072f6befe762a384e16d49239fcb4bdbceb3e508c3bac5aa7d84e13ca4252c312c1b7da5db31ca899cb7344a99dae8b3fa72677b0061cd0d619cfc1a0086265d82d7ec0ed955af1e41fae771e05fda832d0d93aa88e43e31078f630368ae04fad79f38ba12c7659d8de973f3105744bfaaf1e320028f1532945330b7d586f1102b713355b2a71589feeae904c6ca58e3917c188583f90b1979922d4c2d5f1d69236240057a5569eca1191cce695c6a19c18775c38b5cfa6ae5d2b578b774d24667ea8231396b3f2ec89bf45580ac56cb582dcbaff28e31b2111bcd2c7c8c200df6ab32fbc1f20629d68d0f71066cb0e8aa01db2fe01525075179a3ef62d456365d44fa36e47bc1f9fb3764cc09d8522a7f931048b1f8c6c48d7aa5fa787b92db5e25ee559c1ce53be8e6966854ffbe7e34dde3b514ff1e4948c8f6638ca231e439d87d12dcb2b990bada676b4ee798e47afbb1e2d81e59c958c7b2a2466301a4a33d4014f63633a5563e80ac37dcd1347641f04ab8237600ceb4b364b743f7f822bc17480c01db93e488cf6696ec9346b6d210a02e809e05e91d9bb79073e1f73d05e1f56afb1750e42fe9fa8fb0d59b9ed89cf55a31f118cfa29de5d923797f3ca776f1802d7926288826329906da0861e7bac8f20ba1447af9a4897a97ef204ae617728a1653ee949a4b138c567621ef510802933d323f16f36f40eec70cf505fab95a987504b94a8f5395914a9c0461fbd3c42ed50694dc9b6b370a2b19575d67db425f763edf076b525a7ae83d36688045c750750bf81e3092dc3951c3f645309b584c98b315c54f34f64b13ea9117c3c848c3c179a2dd32b69deb4f741fded5d7be9a7dacc7d5f2fc81aeb91271632c3f2d88068f406fb6fbc1197ed23b6e31ced9787624357b5fa883d604345a4e85a2ccd2ea90c8824aa497411a3aa486471d77a2028cbbf69ce647b3822a74953dfd582b39b6a92414cae56db2059ef035f24d02a2ae26b854247a66d5c7f1d7ab70cb05c24c8575e4c2035fa142c2e2118c707c8ae87dcc335789a90be5cbbac10ced0861920c05f67912348efc010c062ccc75bc87bbd98912ef43828c21aee109f4d52ae410d9d8877db0e56d665d2933db02d67096535fd0fabde355ce36413f7b969199375a10b826ad9810ce68e3892b637592d1d6271b0825e1cc1571f9d68ffc1a83325d276d07dcc6dd46b7f6a079436f4758e75219f5408630dc001daf4981e82ad9af33ab0daeadb81943d3c793056e993f03368bbfbec6a1ffff3b5459207cdb5c44546490a0fb2a3b1f053f249c3f1100a132f7a7e62ae0df86cf9f471b37cb07e2f9eebc96dfd72b882898cbd0bd96eb6068f1c696fc289d62461a157fff1e30dfeeb892b34c2a68ee5b7459d1903fd09ecc8a2aa7e3ec3f73a671ad9112c8605ac6b159c27e7a037b6810a0e53f5bb13c4fd5f146cbb008a42f45970a1eced46730caebf8c94ab42f30487635596e42b0da5414b65690d66326a2fc3ec7d30e456676f4611d32d1e442c9a60c3a2780c3d562dcbaa9a87deec5ca12c5d0ee42f0b7199f0efb26c012e311b93eb6ce9104387a606b687b115cc7d6693aec7c05e6d9d8da4b319f0652cdbfa0337896b8894cace08622a6b9379af055b8ce1ae0873297ece11c29e3d54d7be87c0952318fd7ce865a78b323305f417dbe9d7e2f78ee33ea104576bd77f959ad3da6fff65f57fb06a67854b18649624cf5d4f35dfbddc2f0e53f92a4283b844925f1b7dd4566c78322f98408c30a3b5444f3f1a54bd1e51c192923a27b19729e16fda6c07dffd3f1841ec4cc6caad0de4bcb10d1c4638af7af62c9c449a37059597801cfc3d7a54edc2db15997da406b04ae13579098cf7a27d91949bbab6c8d61942bdc032b1939de433672d8b63bd70bb0a3b0de0ae664190c1c3edfcc9dab09ab7d3dc3247c0e7ecf224e23a6ea8de75695d12abb7e626edf3a61a598547ed2422b283443b6168b044aa59e8b0cc942e87a6c647311511cd4364cb136f36c876cf37900519224a22a3c3b2778bddb5d1464d850d7a93ea0f6e4f454caf624cf9c94cb95775bdf9ea26cf281cdd2d91e4657d6cb7f229d0f9a6eb2e4926533d4f261030b690127c43a76e0422b57467348767a337a73dbd0e4c10f1bc8b19dec754bfbfd8932ce8174537760d543d815bc01ad554fdff2318f7d0efd44c80eca2292af5f7442790e2bfab1dccd59f6d2e8ff7232b18e5ccb9493f49906d4b5169891b7a42058caf3a7fbf8a8af2481cb2b7af94ec213b8f3665f66f38adbb1bc7bc19f9698ab2dda274549eef2888d81e1adbd26f0236deac8a0d2cb9076d2e61a7819434b4927520305c356c03b805a5917b7c2d965ef3b3f93135ce0002aaaaf848980458e9642063c74be53f49f6864f351acc9a9c934555c9d4aa21f4faad9ca2c718d5c7fe19d24bafadbbe6952c505abc1918bbc75fe90591c581e16896c710046db57d218afb6e3e8010391d6873e4272fae06358dd298c935f4814e5906959d1ae93109f5de5040f1a5bd00416d680150f4adb75aaecfc01cb5269c19f192788f23bd79f157310e4ed9b9e7945c57cf9132a268cb465c7599f62bc30997d1ecb691f8f049ac04134c8d6137df124129005e6739c3890b90e93ae8e82d90bdc94241d6ddcd31af93218669fb012754318c47a4e15a1d1af189936536f2f2da208e22fb5c804d435836537200d653af067038bf0e0390db66586257ff3347ee56afd3917ea38a08d2ac54c437e0a8641e2fb414bee9c562debcfd5aefe80ef1bb4aa76e9bdeb2916cafba669dc737ddf7479fd958d3488ffb912e4af811570880de5e055440acbde307c82724d12544d186a312896c7df97981a6813512b759c7ce14bbe930773f2862b3bea1865bcbf6f68bcb97c44fe69bd07b4fc4b3e670c2c97bbedff3d1d67d10f68e9bee27b4597dd55247031f6e33617994e5d0269004c6882aff9411eadb9e311039245e1a7943e5ee67b27b5bbf2ecf8f529d753e39600d314eec311955eaedd8688184a065d5a5646e8a223d1f79e0c193c8142cfb9a7750fef71caebe79d877858cfa3df8005e95272abae5f6e12f6e02c42a971e67976075a8b2c372c5b4b947bcc5b89832740a9660c817dd3e7713b7e791cfcd601eee64dd79a09df9029e2e15d9971ce42d7c3a8971ba810bcabb7fb76ed368d594fcb691c7ceec22a9049d532f34e2086e150487b1a822d46a866abd9cc8fcaf63d71999f790d142836932380a04b2adbd95d6f893be8ba5b906eab27be47a89c5c1ca9c1ac67738400798c90e2eb111484844d394f024a3024026e7865571b7259272cc18ffbabbaaa57d3e2538cb4bb9e1e301a2c5c89c2de00e71731d752e74b3c18b53b6994612c6eb1332fb3ffb03f982362f9a678a146df512b8498c88e6149ac37119090e2065bfbb649c6881d671e6bd51f5726e9729158162ed46443bdb8a6cb53cfcc9aaf3734fd402ea9caefe70974ee4f0ce54c53fdd8cdc164af594f8db512e8f6d20387f4143227e01869ca4f7db6de6e265fab859f995b96eaba273849fe67ed0c85a4deff584bc5b04bdef7316fce4614ca5d7b4b71e48acc0fba18ec0c869196160d9a42001297074727f5c7f10e4487786eee813e00d67217ce793b34f2581663367a613d5f5671066f295315dde94daead1e4753d2560c44fec7d7ee1d66eed35d866d7b235b4f84fae1b8c200ae42dcba661b44125dffa48dfa3a3b236588e66fa3913bd13adc9a6c13ed88c4749d6111aa9bad727505ccbc09b6060fa880f3af2179fe847effde6c93f2354a8799d01383cbf508093c05ab04947227e977539b9a26f328b01459e8d116f9ce13a697e97ec5b1a1d553a86357af21a64ae657072794cd6158576f9292845848e9f56e367534282335b29d9cc595dac8e61fc188929145db9c754ec1fbe7ea7429fab19092915fffb8afeb7997c2d41763c5bb8473896c353608896c93a3a06236703a70a23f798c495310437179544e8163f6021a298ab257edba610429f602eb21c86825330ed6570e78989533f66329e276f73fc3f9e433f600b70a10e27e9cf470502d49827e2e8c0546caad24bb40ff1d980450d05e5b342770799328b4e74627c5707426b39fbb4b2c4e32531bf5e7eb8aa62c9f926581d29c512afad296585d6b1c12b129cde18b771134f4434521eb47fe4e2ee288c402e6105c76705d0267ab1ea83d6bb2c11456e666bdd86f4a0e76ca520bf1a1dfe31aecb7e676396a47c224933fab1694deedf0c2b96ad2612a965cdcc0d63a0a1aad5e022ffd0b7d36284bfa2612729208396e4b0f8ae32bd4d6d5348821e081a0fd799d81de7dae81e6f1834de722e1626269e68cd3e5d2d825a7338d2218729887e2bb96ecd192f8136c6495bea5dba8f52787091678a08d707148e0093c0d57f3c8a439eea92392b38a24481603b4b347f9992255747661388fe162d2ee27d463a986830d9b83fe391457acaf1746dad261048b891f81b9f84ed53d32677347b116a43488cc879d7eac5e503cab7bf37e9ab6260b1cd0b5d6294e412b45c76a2a29aea08bc7ea9e814a1ac3b04c7b9c9d9cdf5a3485d76eba0f7b17536d446893fd831ca9d2681eff442f357e4abe65e0c7e23f95472cea24dea9cb8ca0e5e9c83486e82e77138f8c8a5e9a6f6207b6872d5278b27f4f4e50dff56677c3a2300cc0173805365b8bb150f02d94533677e82e2ad909ff7f6540da0595a88188e657288f7724c4afdb19b0a2921795dd75faa2568b8399d98dd6ffc917ea1f2597b1b1ec1362d1e57b87083e334e6943a20b50098ffd56c210cea84111a37a8b8f7bb191141f5111c1c13e78abd4983fe06e9ea0c9ee97c943e9fa46c82ae1e234d356fe1f79b1f32fe51632b21ebde27d6435946c55294765ebbb902716aabb72192de07a47fed61b388681a6e71e52264817aaba8873360fb70ddb088764a8b0932237fc185b796e81df25c1d43b66369943acccd45573f94388fced08e112b2d8d60d0fbec39c9e3d9fdca8a072562a26502aa1f62415dafca80f6e3613924a4b505e425bce531db5a62d3e3c52c320bde62a6242c8650a441b8da31093c1c617a05f00d2eaad7b3dbcd95b3695b917c327593fb9e0e645fc89b65eb01d8059f8eea35a44cf5d1c7fd939fc5215a29cac2538af1cfe7290061f5372701e72143f2c513a16351f98c6b8542240ae97a99587167599b8f182f6a9a1922571d02a538160194b8531e7d5c5b60818e81905732a66359c8d77baab6bcd6615a5fca01657579cdc2c52942280af99445009b060818890a93d21753ba7bc9c6d75483f44b5bb9918615266998e14219177ba6c68322263eef5dcad729f089236c9b2d0b7922184fcf30eafc4163a3795b3f8975189789ef096a40405120295003a881a16782fe82304bd7fb926cfec1d1da9f29c06973f87fa4fb6b9ab94536393f21ace5fe46ee08b223a9136fe1876aba1d5c2a16ef668ccbd9d396938f1807e9d71ce03fa91602ac9446fe218ad0acc6c73703bead9d8e76c64895a8be9969b4a71a421ce4066b9ac8def92a1efcf9d73c12be0b3a5904a8a886e445f6ec6d54c7e9066708576df9bc5d9cd42b07097dd70163b1d6f7f3ae8728376f7fdc537c124cd5d4cf3829614f9acf9befe6fac43bbd3ada73702bdabade94a70d562aa247913ce504132625b8b752e7a322bda8eeca5e885b5d1551b88358797053e2653ce854ce564939da44a46d87fb6e5c8c32dbcb128f3936a0b142b17df74da8543fd7c2d08c4216eef078ed043b9cc77bbfceab6bb98d5fe500682ef939f99c5087d29599339fc1814db4b99c9b5f9b58a9d6dc0b71f15775c486f3cc3506ee5212f6f1c15b21fa03130a79a66833003af67ea28b10d5ed2ce4a79400409897c9f71ea8fe6c7785f836ec4ccd4062c8d9d51b5d59f34196cea520406350dea01e837fc6344cf11b0c863880ae206ee9f22e2249bf33f9641e7a7c3a851dd1f2150337b3485580825d6d53ef6e0ffa003768ed5d12ced80a0c56a8859f3c24586d368646ca445cf6e5277476e516cae962d2c41947205f29b4dd155d744bcb98d1571a0966ba6327440800ef045a7070ac2ed5c44173bdd239ab8643e676e6859b2112f88dbc1d160b32a4d590d9fe88a5c9e1d8da43d4be763906963ee0fbe8e8398395dc810dbb2a0a1b059177240649123de538e4935917e124fc74c5a3cf3e29ae77fe8780a6a666c720e16e1041cb44fb36e01a3e8ff51f9d31f2d72797f6cee555b2c3bfbd39883f43f3e81fb6694771236ab365f5a9e7955255f0d177ce744874f27e890bdc492d07c3d7aef225928d8e62f6673b3de65946919dd77b85a2508c93a96da7e8cd2c39fd33862b773cca3a794ce869616729274aef2fcf7c9f592be770cd3d208215d96a36c0e3b7d9d760ac132713cc0ec76778408c74f022692b30aede7b4d1976adcd87f76df304d4c75e2048af2000f5133fa1505861ec98c60882da97448fc52842b9249f33046effb62d635715cf79aa339baf2483aea2c6c237f947c6fa53bd4f49b96c6d025504d82c66d51043ad1a1c1363c5e7698e400807ccb92e28d6a75d23a96d0bf9f2cb6533d5ff818f41b1680661ed13c2c2b42b01755f23925d48d22ae887090921a5c8977a5adf81a415e4ef0639da97847cd27e7268d2b8fadc0fe65ed15e954cfc11a342b7a129924c8c6d99c790f4c53f602cb23b7e092f377cecbf454eb911dc766bc85720698e9bc253817da64895a70e8b6c51755638192dce0be97a77b43a0b91d74ad9be7ba0c6e45e1a25fc4c5f4041f72ea8c8ec4454cfa20345d1b5895ab5929223ddd1cd0de7da488265845a839955213e4dd782763cc76e20d920c4ba2860158e3afba4aa57cbd7a974b8eeb3563c0d241c927f2e137733b944c067189bbfbe745ca9e31425bef94c77d13813b23ead6ff35c863af93a359781576e0c74f2997c15d4b8ea1e3ca36babe87e879881ddef3224e5c49d6f3db2f6f00d0806011a19b04bcee456b169358db5d72e611e24b55fec2ad8e594eb0e5c13c85a932dbbb0261b3524c10c551f0b42a645aa81a2bbe3529b74695b8389959ece2f39b167b007c85a2e6b4522d6fe0b5dc871a1ec4e21a32eb962c21791c4dfb3da70b83ef4f7b5ce69924dc332db0cb6cd837b4060634d37aef60923275c0f24e45f16ea048d65ca416ecc64e0ce5ebc627563fb43b2e2d6b43836cb2b176b988ae955ce3af491a2c4c99bce800b9e6a14b7d65ececc60f0bcbb9ce6fc5e592f161e836c3c5d1839300b37435719a8ba05160b2a495658f25b3c8fca8d324b8f73841c1716b01939764d79dfca9c10dcb5ec2899c5836b23ed2bc7fac9d63649e0b47bf9f9af3ca873314fadb935e6291dc6e576036de57dac72329ae5512420d87256e12d29c12f753831b3234523b5e7aee227c8428e15821f7d77909ee683d92edccd8e4a8473c77ea40131096778e455f945f2262b603b090067e507177a04f3153ed7268cfda84a6f197aa1ff4abfc52fadb149757af3ff04c05cb3234ba40211d1792f0b2d25bfebdbe3ae1b6108135865986f6cd0c7fb1049a37c51938eee7780afac1b0f571514ef05f84e9dc144bb5fa482c691273a32c3b34aba50bb1b68d5546f23d2fd28b8642b7fa8ea0f1b85be031f4498c3e9086b43d3c69c7972c765123dfe77f67a1743e5c720fd816dd07ff166bc00e963cd8ab02a56f700108f6271fc21e2d18bddc674c31f2d5660d44180b2ed9db1520cd6866c1dcd38acf8744361538111ce56bf9bcf1b31b18e116ed3b4d853550b90539fb14c3646b123fa1f11f3bcaf8de92a62c493d0f6b6365a06592c5081a096fd1edac8f95293fbe00940111743fd3f0d9ca5c7c48a0c787de4e7d176021ce9ed5a7d608c6ee01dac17723825150f3b6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
