<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c58219a50852f1bf465415fdc305f783fc913f675727d21980d5deac08ae8497bb944cdacf8572d8dd0062da35bf34da25d2ca0d3607b5dde3dc8c6df51590f211000fc01cf0609d008e320c4bf1bd377587c3524ccb87b039cf06aa33e84d6f4d8aa75e9ca89b9ebdb725190d1d01976b3c77c89edde3d2d1047dce3f58ab79f96517ecf674dbcd66e5eb20f43a70c19523a380d9542a0a941b5870a69acd36bbd02a1dcf5080c0c662bb13227d925dc0369918669c84f0214e5dc7ff690f3d7e77ac1f4d45190dbcd6317a1a09232dc1d8938c5750669d1b83ee8d5977937f16abfeaf722b59afcebaf3051c9c3823433205a2b1588816408f04333a0beb45d0dd45bb573a8bd8bc75a89d207292e1729d0c38498499a0f26969fd5f4747d5a0905b70c47452ca2f05ee3e5ee8d858caa5657570ce8e1aed1a7f8e78ab534f376f9339529fb51418ff22547d2404198e6cf71e1c5adf66afef9f5e575029ba636c6e99bc58ca7fdeb0ab845a3af4bc1f27a412bc02eebc30df41d0fbb944076c2f98d8eb0423abc8b0217cbd670041500f4e69945790c35761bf02de227188fb1afcb3eecb8efd3a53143c7f4e504c8958749f5a89663117bbee95f883d48b985da5d9073108d7e91ecf997dfd4c4dff1e72e9160894c8083d75f41d91b9dba563d22965b7faa06313a4c4470143f9bfa11c60ba9a00424cb65e00fd02f271d84a6392418ecf6db9e213725126843e738c33b979d50a8a86598b6fe548b754ee8c00377a51339286c1e2dc90f666a0404c21d4ffe711baf7829760f028a4369965217d840693495587339c0a6af086ecb00736785f508aa2156c28bf4fe61c20af5b387155f0f29b09279d972a6319d51bf00197bfe285691f3baa3f70ad8c6ebefb67e2f7be0bec57173c8437c5baea4c64bcdf923400dbb312fc1b577acc4c7c2627a61b8ffece02b01876842f2d4c3bc133aae6d25b0d797695825228e03485a13b1e9636c86579412e8b47bf0619e1c8cb57da522373f01501187547a4d805a9dae2f7565506cd34c98c1f106fcd38e9b81eee12a633fa8cd9db46e9513ad170fd67b129b248b0bb0a1d003e25a54b76d31bb08c1df5dba7fbef72d188f36091f537465b937f7ae7d335081c5c5c50d2be41e799015b9832322c6e64f16c39db62bc4f7cb377f7b3d8b2678c18ff272aa57306f72d18135a588f53b5d7bb35c73bd6569bc3eb6da1c43577e3d3c259fa794652584304bec1f67c8db74ffb1aeccfa1d7a156741016750e0b7dc7854b39c21c7ccf44bf2765f06a2afcefbdd97df4d092083644ab0026e96b3b57fce89b2eed04c1a391cfa962efe1714e1498e788cd39122cdbbf0a2832937913d4e99cf35cc6baece89d6727a2083362a75bd963116b7a800c65b0276fcdf2e8ae04c55c61407cb4cf82a236ddef2b21f8da1a0ee63b975863145f13e07ecaf0d52430aacfa670fcae6d2f75dcc1a8eee5fefd09f338dde288aa9cb990bbb6b6f7e655a31f95fa2df73db9b534af7acae305da0c01f5a3ce2dff62ff8f23dc5facebab5e9b0d50dd613a336acff5a6c15a4cd88b9dc392a304f2f7b0616e0c57b0887b6a2bf1ae092916bbd6a0b7fc064d238f551ef20268643af487b42e204211cf0b6c6d70bd7c4130391f253220e53aa888ffc31199dd6f07ba9a474d80871500abc993b06cf4793760bda2b8f0848efab873e4ebdd2bea4e4bb2c6c5f02e988d19c5481f0fa9e35ba9013cb43d65cfc8b1c4d4c7b1d60609ee548e4739ba384b398a04fe42110ff9402d8116e06ae178c1b29c19a2934a0bc01d81ae1ab0b2931ec9a614865aa4ed4a74b031d0f4ba8d7e3d4592dd3771118ffc20d124040b91717013ceed3e230c51e9d05f4d90b9e0ed89eab122eb24176daca659e57fd0c59069c41f07e043baa184e2a76336da72278b3165b78d538c53b5c5aab1ab92ef0b1f1b13ca424aee102ebf60c2b8e52167c8f47b166a4b035a5440fed89d278219b5b0078bf5c597cc60b74188427650397783525e0af92d5d59f49fc1b5d718371e1c8399af4c254c71c4a1768a9ef56da0b3f68c47e19f857df92ac9abbe819c08c986e58bd9f5a44ce28111208b83785412ba7c70942ce46668cf26e0f9e623585816528866645a29e35b295d7f900eedf43339760011aacc9a22f38c0e7e4709709e77ddf6c46b709885eeb9b79bb599680f6066d9fc6117550a90be8d9488bae1f9c2358402d2bbfed8a9fbd92deaaf2c2e39b264e5fc8ff0384cf35502d7b7d8f67af556c432c90eb9e94aecf9c7c4c536fd3f5e37b76882197f3d899cf25dbb73891e4e6217630c5bf1015127e328b33630d20c139d2a40ea31a0d8531248ee3d6ace5ea90e861ead4697aeef46e858232deca6b838c8df06ee35da84cacefe85705bf132ca2e0d7c8772200bc63bd4aafa7cc0d84295b9cc517fe368ead97f19f6ebe0b8563cf6d51f82e02b2b744886c882b1c253e2138fbd421a6a61dac0f7cbe99d1e2effa71580b4f87c776cea0f3edeb4e5882c4fbdaa8b67ea0e07960a855ec95b6e7686e3343ccd14bb5dfcfbb2d1aa919e807026ccf8975e75eea5821c3af6c725b56654847d7aea4ad035171d0d11fe365a0b421505248df7310c15d3782936416721863a3fa494c3e81ac2ef123006a9baadcc17495ad3ec76b674b7bdcf3e8bd1af6e0ae9e38d34b70627ddb8870464fdeda2c25655b84d9946d49c58dea1ae7c9255b6a39c5093f9c1a382d770bc89db8f260e67fa44ad2b1e62315864d4cc87cd391bb9a2e90d304390987b74a980fc42ef5b49a0be567f330e84d3d457b8f99d896b2bc1eab7d74c6f6aaa739c6484d31e78bd1af149a4f0ee81c060c344f455c225c46336c0f8489399ff9c3d89369f1b2a8ec05065520198cf24717df497ff2874943cecae64e617fc92f6b3e18f2c5106c2bfd7ef69cc12d8935df2a0818774a35ce189b3d6878e27455350762a4b721efd9add018204f83913220f42f5e038ff49d9e7ad8305c5869f1c6a0ca2001fd325a8654b6ea20538d820c6eb9e26a2bfcd67e9bad54c517fd2a1050bed73bead06dba922440f0ead15f5f6e40befe9ee13383bce84501679573b0cd1b94a440c5203c1404433f96a9ac1804ad390bbe6022a954a5b86dbd78cec7b5983779b6954b718d120af2f1a23036d253e8b27928c71e8aeaeb812726011a6347d51995c6fd0166469c4d0fd4e28ccb15e7023c7f7c18091c24e87a348a0be63b16c418617177618b7064e3badd443bdae6eff4c7641396e322cce6d318ab4a790569de8eefd6c8072f2afbd4d9810c33325ba48cec376376e748f115e97e39d33313659794795bb5cb7a252f78b3a69efadf99e3ad2d7327c1e8ba1cf61482455ea1e78a5b704b59c6787d06f242d6ada4139821c77af2f7c576d184f9a87a24da3642ad64ec52111b2c0f054ab458cb9b5687f223aefd1fc530cf3197520e05f0590205855aa4448c5412e9ed0d7f21d64fd74f7463ef92a2c4a6c9b6cb36240eeebcca957787c1fbea5c61c2d45ec7cd58e1e18c1ae537f5ddd65ca04818090dc391e4c42ed877986150237c83e7e3cdeb19b251f23732bcd55741f844045a30799abb4752c125a09507d67e51aa9b47ed1e2ee7fe1fb26fae9daba0147d5524abde0a01335bdcbc795047801f1a26a0301e9df86974e7dfb537366cc305df3d5b7d1f889cf56a6a1681bb85311b85da00e37454f81193684e20101b5afbc089e6c14dbb2f9ed25b0ec694e17049c83c22bcd6a01472be7594b13933da03302eda946e0eb5a9de0fbfd11816e01b5c1477c7c25bd36e722773af5872d127f8c516a9a58dc3e7670b0507c31b0bb75ea697fe6edbada407e9b0e7dc3848a7981197d34fa7c40fe200804d7ea9b2acbfc27b381e683ddb945d6e4b74878b47418986fd602e2d3e28cba8cfe69ba020bd2a469e95d52438c419b17f9d52b389a720f8e6ca0dcfdb69c63ae7f3313345277a05bc3e64f4a5fbd808c566a2a560b5578155365263e2ebf6c7facce8b9bbbbe5049206b7203ddb5a47bac870ba92cea96c0222859bd738022e85b79d1f268e4b0364ee0e8989dee9eb44eb8c3976b85d68aa3643671ebd1f32cb85779f955c87d33adae6cabac5c02a3f0fd9d8f538117569c3edf0bc0692b50f499f41ca1ed7165d21b32d8e69e12867e8def339f26487dd438131e4c355de8c7ca5daff58cbf7544e493d28e628c3bbd870bf01309ba60c759a0e92c11e1d5cc3ed6a5545efaa9743135a35c6f4ced0247ecf3f66dd2c677ed79a5bedc8d6b7abc6a6e8c074bfea5617d8a8d460ec0e44bedb7a742f1c4a7d1c0b6cb6bcf60c221af33b6d4520e17c86e89f429f804ecbac687e3e3d524fc14bbfe4a8d60e74ea146b987866ef315b640350a8c88f5911e81f83f003a9ec8d51d7e7c0ad159def8b7feb5f7e6e268ef72896006e055a74bcabadd9f62417d164214572a7a49a1ec2f28e83a4ef7fc3a70cad7b62b0eb7ffcd7b1c43f4fbc9c6c4a5d1f6d890835844377cc0547ba90e8245c3ae3545d426f8f9d91a5be2e82d46e201deda2e4171edd08913f6685048907b5dfd160e09837b313563c31d2555be8688e4cf5a8b874899bff0d95f57504082ffadc5f70f8c2abff1ac3061f800e582d5d7e85f778581cb79c693a7d96fe6598300c5c6bbdbf8b5e25c2a28c8836039c248a803b1e7346aab02509710b8872e392aa9bb9b4f9fc421382ed7b92b3721d3da29df0200a5a5bf0d64bf8c17d40d6484f528027823ee43b6119ce91066955df0504c6f82853e0ad35ea25f7b39bf02ff61b98febbe3af7e16c913a949ddcbc92469d9c51b77938b9f30d87cd0ffde90c5a2a675fb18967d73efb5f967370f7a750447fc510423d6c12ce5bc0aa4833bc51b7db9f44960ecb088a5bba1c212406597130502a91150f91930042b53243808705247072c9d467364d3304bd1ae076f36781194eba24ead60869ed2722a8531bac61397be371afd1c9f17e58ee3c69d61c681cda81dda977931b25aa30298d9704daaad7c7172ec9168a52940b889f19f4a8aafd9d06952650993f56b76429ef3232760908724f64cd0bb6913359f78903161c817ee28ed52be16fa5ac1894fd5f9d15cc08bf31ce434b28d1849709e47cf8da002045e881d8a98187662b90f0986b9e254c37743ebb4c11f3b0de92d0f6fee77e2b45cbf9e4e09ee4a5035d11595ef27f2267b8b16cead6a0e999a0ecfe6b41194e7234cb0c6db62ce9e7344f0ec1a3d7c7cfb2e3a75b3700abbd010eb5e112b6d60b64659c4ea4c1f66185b9c3f34178885e18a4115097b632acb27cf07825736ba5296a5be8bd4c88142ab04b6ca10144c43084edefb1e12f6088583537c3920ceff032b1eecc36074c216433e99829d176ec5cc9889a3083cfb8b47eeebe66ccb5ba0b27349f0e00508af381126d5af6ba48aea6510da1e41f899fbb9c9aedf081aebd0aa8f0d0f1845768436632a2964fa12311b1f194adc89a20cb95a2520181bb5db2602cc533a56d00c3d72a5a3ebe11f0d234ed2215ad3bf20225803371aebc79c7d7a74102b7f13b419bd7c65f715f429cf59ca40b978b1ab5072b47eaa967381edd824a3028a4987e98f6148b0f43b216c4d3aea54a8ad4d24a69658dc1d26372f11b758bfc8e1ec3400ed1c2327f6594d2ae48b992df3c0fa08c24300fe3807c48a4d6a1fb968b04bb82a1356aec2bc57ec61cdd89b01a6c8188dbb43dedacc587fc0eb57c3be1573167b96398473815d7174a84bae0c6b0b2ba8ea76db8a56dffa991d75cc217378ed0a57c4d7bca86a7b2891b06cf6b8cbed8e441cc4a07aaed4bb1792d86a8808c160a6b928da89c51973938c6a1a40ff53d9e36d0a6fe959976b8de15d11a54aa7e3d13175f54960857e0ccb07453bbd1413e6d8075c30d513085aaf1302293c32770190c96a29b95ab8d32c5fb92e02b1b17e4935de72ed2f1aacf68aa480751ef656fd184bf5b760ab5e9ee2ac7bef1d7063061388f2a967ae23a41f914a26cee89c01860da53543aa3ec5d64a8f9eb17669d1fae8a8f9b22b70343ce6970fac07bdcb0288444e26a4824ff61bdd63ecd828c3c5d17d25d763f17cf23a314de54c42fd403de3f6fcc51198331586c083370e6222f9ec4d9fc8b877188a39f420555fc95a253e943bd7a7b35fbdeceb154cb4b8a917efc08383fac9da17313f808308767190211bd30345f0fd33d7504834c3c93077025faa163b4085e39927874413763f0b30f47f3892569a0598e844d1c0eaf8578203836b0bd372f50ce71de0410bc8fd397cebcd94b228816c209392be91cb6f7e48fa10d597515c469c64f22efb990a29ddeae4fbd0be60483d2fbab255c3b0af4632ba20eb9b11e9423b15817665c92c729af758bb3286ea2959438ba1f9a22fd77f171fb8ab007226cef7fbbd158e1879eb26e8a046b7c42343f3db212ac39dbd36a273d158a29c707da63c0507e85a2716fa962e2918b13863879cc931b0f6844974fc9385c7568e23ac474cba467f3885e225d160021738efd784c1aa58006788d858782172187b999a0a7659d5cc97d7f351cb262c696c05886ec898a3643df39fa98f1395e866994d7c6bfec7bee89c2908d311324d83f92b8c18d321d021d0949256c4a29fa9cc40017fcf7653b39ca24748b21909a649808a7846323d9a69b34ecc2f9f43d5919c7204e66f7ca839ee13f198b82c2045d75d364bffed54f4439cf0ac40244ca97773759680a6f274b62fb25b976b86dc617d5b1ce1c059662ffbae4a8fb0cda8035a8f2240cead60c0e527c0b956a33e194bc0c428dc8b8897e3151119c5a85c1068c5b383cf389eb8d349469430363c377636cfaab4db9b3bad88803c3227a7c1a4d96dbfbd96abbe3af1cb671ea3ffec073bd066a9bf437a360a446d1e29c544f2d34dec634418b314b6c45088e9dfaeb8dec76cd66505825d95ef44107f1dbe3337b891cdb6fd8ecfe1be6e482c4014d036b14e6a80f882252b0f658b6e955c6572b4f2491bddf7d5e115231b3795fd294574cba37ff18c3443aca7ab00e43b931afa684fd574192658f41bfb4a5861a966640403523e2fa2c71e69ff8a2dac13a7475b030deaa68805ad9bde25d84f7da653d319140f4d2f34f54aa4ddebbb8d9bc11f484c989264fd23ab0cb06dbd766f017a453b7c68f1fe05759c3f2b6b959b3fa8eef1c170ee550a6371c68610b53400bf8a4d05eb5f584ab20094fff7b381de54c8d749a35ed2cca6f710ddda761c3d444e3841f4b5977ba898677a08cc572231c48c13565a0b7197f95c1644142160aff5ca346bacc5992552911c245b0d18a359366c09cb18a1321b4c48c95e40d4c56ef5ea4bb6b7119e76598ce6b12afc4fa175718c2d779f485d868af84294c7c0b6b723290dde7511a4ddcdebac1343785c375727f61a28c01fc97fe02fb30f78fc6512c0ef3c461d6227a6d8b02e91753cb6d788b8f66a831b34a76396627e25ccda8ba21f5fbc495ec950f6ffb0a9fca829ceec3a6dae00a148c98ea36422a0cd73b2d8b0e89efab355e6566c4738491ebfe3917f6ae1240e81c25ef87757e720ea68d3c5d9a65f91b5a557d74350c27e2e51d88aead650beaf60418e265417e22587f9333b85551d96b52a372b91fc2e7e67f84a069072afa596adbffa431bf66d58299a0affcecba85926ea4156b1e1a7dffa3e7b734fa1f45d5098da196aad61b85805b1b1576a2844ad47536c6100c1a0eb56f371910c44b836ca201eb2eda60fedf97354f856cb4c43f221862606fa1ea876e6ae5f14d01a12f9b71c71600167cb0029aac9c16f4715f0ee12c3c916119873ffdc19124d9c643b3a70295d71124f4748dc0c61bac2ef2ca5ff73a4429b2666e22a952febdcccefbd40a4c2b82c84f80d6dbbbd32deedc4186ebd82ea47a581ca96cfe0dc927f6faef63124378c3d9da127e608b533ef8e9ead37ad107caf10a2ea4aa4463a9bcccad423d75552bff6f10d656117f339be5a068e7c23121402f64f6cea64c4ad7da9cb400e0b609d98fb79a1a99f1ef5cafed26f2400af4631a0b84a92d4c961e20a42c4a3b4938892404e97adcacac6c36a77ce16521d092495b0f83278d9edeaa732469366aa0491e3566f3e888b892aeb05ad6130df7b49b346179e7d9932f774ebf7e18013ab844cd54eea86b6130e3e2369a0a9ba285c2f4984378156578673a2d40207fb1fd553d251d4cf2303b0feabc02f68d2cd01551ae64fa07587257a6d975d4627a6f6e99ad05165890c694eee4dc169a0d3b2ddfc7e4f7b52c299226635210c90c5eb858013ffa724978746a1e02745b72eadaf7be70051c46a46637ea82b0293f9e18a3693b101334715da26cf65f9d4ba42bac6fc0eb06361ddcda02e0035c366c908098e6e6a925c69abb9f9cf45102fee1d9644ca5c82b025675df115da9d3261006edf9e233ace6b8e92cbac4e784db230026532a291967a556f780f3f63e8b167d95d22c812456071f907db9d0610e3a575febbc6773d8042858e5f709c14799a31d7dd529b3705707230ed9bb5a8ce97505e05abcd6e3f4f72a1751cec4ecd9fa290059a974cfbbb99ae7d3088f6d0190869a8b97bc914f9bae0d44ad8732118a5418e6a70c5b5297d4e8efb002c0ccd87efc19501665a82f6e29ce99705cabba0067a06cead54b03e1c8a1688f7e40318300e257b454eff87d5c792418e2b75dac51b4eed666df9f206b10ebda728961cb08d92c324eb13710970a4c1e4f0718f39d253301899b7e43720b215df012d37ae32af77f584136af932977d0a1c02afd1bc46987c8f48009adf09706f9eddfbd7f3bf22827a28a6692d563c7459da547bc45319690cf1bbc9d5e845c28196db6365be91bb585ebd6a5fffba1286fc48ba94b820c40fa08641c69db2fb2300a1fdf67467692bde76656da3e8153aa7bbf18bad4e2a60a2b6ba879ac4f78d0835dd2e1abcb0b59108ff506f35e332fd0eae4114c80bf8842df882d3b2a995df2b6de95568883dd9d85a0839bf11133a2323329e6070f28ae09c9ee2677a7a341b8397613adeba623db79568f007358d311be83c6517c64e4a0e18b329f0e29641ceaa4cad1ecf3eab7a096949673530317354cb731dbf4d607a03e39a6931c2cee9c0827ba24b8b59849af2013a5940f3d81ad511172a534589d61dbb5dc95e0b7256a487b3d8aaca7f8860fd2f9de11156ec7622604498e85206b063d663fec1851cf2021cb4660dd68a89b7e4ddf4498e402c34d8fee4190f77924b23432655bef605a2d3da374d9f38288e3d0a8f180eb454a72a24159339a860c282d36cb5bb25cd72f78ff88d2ef97adb321f309a1018136824e20e47747193fa7749018a3a38354028ba5640d4b9e8c1433cc9b968e701a3cc3449be1d6c83ca8254e945c755785ad2396cca73dc23f26c8ed18b476129e1e697030c08e6714bd968e8e2ae4844c2f7d99763c5741bc93271ea02ebe687bba11f1578176b9ae217d8a7a42515b5f4bd5a263d7dec1d5d5a1c328c9a2bd0b35da190849f816d1ed1c7972adc44bf0033353d066465506f08957830f4ddd7ffa3083817facb7b6ed445952565164f42414f522212c5e2e12e5f600b06836244654c3474a042d08f57c2b4515443665537bc9fc2b08826c5e3be9389780cc017e9e2d668650efaa5cd8fb3b33145008cc599a8ca345da30f47773cd75b4f291e4bfab07228a9de5e284b4881b6182eab805655d2372b1d567ea89713d9640f1b8ac5b303dbbf63cae59c2920b93eee2921043662113c32b0645d9425d8ad38ded5db7eee33a229fda4d758a1c6d670e77288a55986c439b62ef04b5ffba651b2d92258ee4ebe488c875fde3ee0b3a8f9ea6283313d16769a0b41cb8e2e2f897e8d2004e84f31d8ea6ff3dd45228a5e19e9eb0fbd29aacf14aa3aa5548d6e0e7006fa7cc9b08a5fbcabc3a5631303b808810cac0b9184ea3c7cbf8a6c1b0c3e03b3afcfadd820a706511dad5f872dd73f3698da8e2479393f3fd9a2f6ccd0d7909412cb6fde1bed5062cf4691d2a7d1665d415f735a146e7c8c5d650ec33d3848c7c2808ab10e174d07c7711110afb670a06dabafc763ee578496247bd995aba114058c37f9f48cc6da559eb28f0df7a1260b29d603b5dc819844c2830f860cc7a5be1f68fcf3369e1a33f7884c297b60c0dcff6872ee8d0f5b7fa06cb026c6d2436d4e4c3637b3c8ca2c3e749d81df5f55bc56be2ca31a954cfa44e6a42169afc7b386713612317035ce11bc3588f2f8112ba9dbe132076798a5f7508377aeeba6949a5a287a3e9bba539ccb02a2e3d162c8058c9c0b8667876599388aa4c8766e7932b2116648f635adf919aba879b1a8d68131a7e2c65d155908e95dc60dfb39e1770d6833d91391a354d803dfb706e6562234cefedd40710f2799e924d68fdba00e76b70328b9ea70ec51ba181beb2f05641e47b5a459725dc4b0bfc8a5712c56e1c5fee8dec46610fbb6a2dbc0dfa38f4788901418d2602abeaa19dade70eaca0eddbd1e0d60068258c4157a13a778d6553d3bdde4722c7a60df1a4fff38b1b516a1b5818ccef2ea45137dae12d7e90374747d7a3d41e8a85d6b62d096c11cb753077932277a0e003d2458a2c33eb5d9f889f2dac26b285fc10b215cfd45005ce30cd4af55926fbdc166d767a7ff6c4544c64761a8d592c41d6dedd55b9fec1a28dbc5249b0a1a4bda2a9aaaec845464a3a9867462414f934444dd9432d55a8c5813af0e9fda4c06dc8c8dd313fe0b74ea7c7c25d165dbd2a6db97876563f04988518e6b6da30b80027b93ece8daf8bc0ee1d64ec8c9d7b1244643fb75dbaa802b0fea3025975974c04a38b149786939ad02819ed22bd29ef9e98d099c9c528a17dc494791662c4913df06646d6aa87b12e02d3bb7a977596b2583544828a474c9f942932082891e2b5dc6ff5a767aef74c718a3ecaca678bd1b8d310453c5ae55ad7b579c3aca1e5f1f7366e98c9fe520c98ca5f26262456a266e6661f713af4b9aeb73e7f4fcd244db54e82e4119e59a36900764cfe179674cf826659a3f216e843e4aaad4f1379962d719fbe196777078f36a26842af5f603899a65220d625e33b5b149318c386c44c2b3d6b65c93be2cb0830d64af1104be8757ae8d29e4d46c2718094757cadcd75793a5daaba5230128f6cfa8542b23660e799b689faa470226fb33ce7e6684560ce280c08788549f591720b40b6667f67a070b94994a1f2720236e402185d48c21856e8092474826a846385db0d5995909dda9d0d4b7a619191bb42db00131fed79924ec55b4a95e99d425c4e5f013e8b7e8577d614f514b14a4c260bbfa95b0a391535d2fb9480dd4269c5fde5f6b66025e9b993b7a52126aad7786552d45e0890489ae4d8ff8257c626d9add663beb7443fc2e41d953e6a11fcb26c8b9e3f5d0e1b837798c4936a11fba3f21ed5fee3054d3cc2af41b35ba72bdd83c240fb16a19be6de9ad057b5a0410d5f5754cd023ea0e017f13a06192a2844e74911efc8bd12e9cd31ac67f9b66cc4d2d06d8b8bb6ce9e285f4bfb6d347d5948409a162f1be2aa003e7017e0b2f89c378d9f3fc43bf533de6ef4b980d6d21018e2b686ce308987ca0c102c65b0340f83510554e29b409ab1e1e181c4cfcca15d8480c6e861dd6ae161f34b51ad523b9ea6628c3fcf535c4c2de0248f984003cd2ef24fe6dd48ac2261aeaa9a9334c5ea7769862e6cee71482a9ce2ab13e28ccc65dc4b41483b64d4ca89bdf3065db023354d9f523a0816090b1e4d881e1838fb8672fd609adb23271c3964165242457bae4361cb6086e5e5a6a7d41fbb2f55a9756069716d380eabe5592882c8f734e257d93acb03140c1cbcc7039f3e74b28a92c7d8add1c790d0969ab66e3231e9b659152c9a8f43e150dc563c0db48bf63ccf62aba3632015e2a513b77fa21bb4b8c11ce2d6453bc653eb0fa675e55b0dbd074c94c2a77f9336c7dce9277aba2c33eccf28e63411f0f5300f776faa550ca7bed0116da01d0c6cd0519059c49c676159e52d6fbcefee14c22c143dceaaedb073eaeec5da8bd18db6073d723c43eb3df1890081d077eccd0a433e44f1ebb07d253e92b50e005a8dc2337c4b11f937297c9d584dc99e47d4803c18baed08e758d33e63569079b1887e7604f5e25931c2fb512f2111a59e7dacaec7083aeeacc719bb54e27433fc93ad230e8224818d1b906c5ba298acce53875cedc132d81cebf20e1ba1bfa6cd253bd44a6ab49c71727c51a59320c23747bffcd2ea007f93737e603cb4e7175cf10fb314607ee61872319142cb486f7f16a227a8901b718e2c3a8ab1f35872076202093c7aa4354e2276896a7ca5ef9819d30935c6f29d733c67388170892975a5bcfe2f488d07b09e717f1f7c39efe42662c073e8b269ccfce6a3e350e7be4e22fa5bbc6e5f8cef6830f814ac0b9ac22f52309565c3c10bf99040efadc7da1b7e911e5471e9edc4fc4dedfc4b1a303e1f2846a5d86f22040f5dde044ecbfa1778d91cc6de2a2ed093af82e5176cd8cc7782ff84080c38dbffc40b1d94772161565bddc7d1d1ce534921b9605af1b7338e247aaf880a31e585f709cc226c5d3cbc97acab08ed7991d2c0d158372e75cac4b44812372878204c825e09ecb5c7f08624fdcbb2c0478d6acc31fab2c0edc18174595c76c22c7f01ba419fc22fc417e9ad676e4d9e3d3bccdc46e881ae6a9accbb03d53898b373814f885f7c0c1800bc0083ff897af5aa6183e9ed7f639f19aa50659cf29eac4c6bda4e45ee04d2011f5f4a428829ef613b22adf35f4152e7cf9da74fb2579c3cdf1300ccc49872b666d8df8b51df6d84e275c3b8ec8577bfbc1c8e9d9dbe1e726792fbe53e8c783374c33660d1c39f0f162bcd106af8e8c7c4a14b9f88ca75cea6244115622505dbceef24d3bed973b6fa20006db6d01ac87e7d0c5617035d6b7e43127af7af4cafcd12ec894f55eba89338bc2106fec7fc0227c281910fb429b051f807341b18439860d6ecdbeeda15689ed0a9d8afc456a7594333894a168b667f298f4487728b8d1ad006992a177d1aeb7c7dd46c4364a98283c602850901643228738ffd9dae0dc56b83d31f602af720eafcd82c7f623e55d4213464cb11e703af87b4105517fc5130a31b9bdb74f0dc91fd4781095e6b4d00ebeb79000385c0bef366b205ae8fbc07c2a5cff7254b59492c2aeae9d1667be672de3ae47e25be6c7e0b71a24f874cdb75a286662f563930c9f54928d056638406a31873c4b0b82ddc8fc1458aefdcbabe3734e744df91c956b7e01912e5fc2724407a740df3fd4011cc357246bd9d609c85094f397a5b453553dfbdad416797445bf0c26a84d0e644b5de8ecf97691eaeaf82ee81af8dc3ff00142d5daadcd94c3345bd9379e3f045225e66add598684adc81db4692","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
