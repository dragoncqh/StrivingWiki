<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"582bd138b376c90bf43188c88db4b8b36ef608ed8d6dfc02cc487c08db32dd9c22122ac52a09df438505873053f048120b342b66073537522be82b525b46fdae7646b6c54ec55d58f81311b78a213dbe5f62695383330ff13022df5b259e830c700187f033637bb75021ebc2fdd2fec0746bf1165fdfd9d5c7b4c02a13c1fb011fb571a939bead6d8185b209f5cc05fd017119541af1ed1458d5f5d8248d0a3c52d175fbc02a90ab2c9c0fe37c889a46dbd6f5c2bc274d5da9e9a3b8c32be4251bef75da6fcb428ef53ed255a04356ce2b386f04d7b3b66fbd0bf4dc7c8cbb8b6c0fce5e270a3914bad6f574741c163ff1b7c1694b6db4787b148a6414b34d09fe6ce4f077f481bc0481cd3dc05fa9472434da05222c9534dab5e070faeee3aa110a2813a97077d3e63c3089d0d0cad5acdef3900b8aad9be55f429c663de792587b003e77d2b3f7af1b968eae39dbdc776de61bc829ae7864632d3eda6828874fbad064fd584d19519974b5697834492fe909054764a5f13c249541162c070bbfeec0499dcac962eede66821da52284d17d4e8ec7be5dcf599c444247a1eb2805b288be22a4bd7319febb30292969f940a93e09a0f4f65b342c7ef44d0fe43085ccc50161556ede6407e44b3bed468e7b12794fd7148ed0be40e0cf47189b791fc8f65c0237b8387049bfa5662bf91dda881b44b2fc5aa637c08523937f42401b700ce2bedcc6678cd82ca034d303e7475f8ee707fd0f86a12492db2e1eb621f8aa8aaab3737e3f68085d9c0a8b3d49a9b48be1a3cd85194c318784b2cfa735b609e4555a33ee42f67062676f5fa3eda37010892ebdb53eeecdf33d15221b158962f4760d9bbf01926f79a9d989af4ec61d055cb128289341610f3e5d7e59ecca52d5bbfa4f665db5e2cca7dbaa65c1d148ec5e6eb972405d4fa42b876ec8a2fc2628cd5c2e435c2c7bd62fe0cb4ec776d253e6e21f2872cd03b04f0ef3de3ae1dc055020fa0a1ba2fb7744e476119f4d0a9a0e3a1d1c7ad84aa0004492deaea6f8e03894c62459a7c435837fd0b85520488672968dee0e9fc9b204f7755547c111fe1b75f173c85b926ed4028be3e0343fd958e6d7f23c03b13edc6e329129940d6778dca377242b5fc8afc212032e519b5c28bcc7b7332acd2654398d4755a326d4c11bca834bd61f3edac0265f4c5a8f0933eab398987d3dbbb5d56af706f31728b6a8ba32808da04f2b1f0927a5cecbf7c3e0e773e30febe8430fcb2dde25cba64d2be89ff14df5a9305d7ce873701dfffa563daa5330622e1b8fe1d3d8a2eb317ad397697d4bea7446dc64629a3e9777f15221db4f60eee09ed3c862654da6410a8c33cbfc27da1ae9b291cdf61e3e16f6062fb462207db36021b8175b605e2a8b1c1573eb52f83324f406387e7105222feb5fb5162acf09d6b0d4a0225ae01f4081152b862d35f4a57e76d0ce255c057bc15783418e36a497fe778ffcfa78f2b7002ee71115840dc255693a1cb2ce83b2ff804986aea1b06b23cbc7ba0020099f3839f58b3ba37e45048180942a93d1e386d441c36a1b5caa71b0f3c1a015ca5cde565f927884b2d1514f419149fd37ea9c11ce78c6f1e043531b0877048bf0eb4e715c45ac5e4db7dcab41e6c1ad426a7127daddc69a3e5b0b1a903b5df74bc88fbd403a35a37ad4fc3c82c0d1787f215964cd2a4324994f6889227e7caeb64a9f04116e40241e00ccba56f1df46ecaea6fdf1dd90222d40aada4d610c0463a7b925a9fa30a37403c8a1c57247ac39dd49a10cfd2104a662a1ffda9f1d136d0213a2c3bb6b63fd907664657ee603d1ba6f3e32a38b8415343724aaa09dc2c5e481a98da1a3fd3d483b67e1acac52b4d7ccfc9f85e40da1ea324ab57f31eb35c0ace7a04864ca83dc9b8c8d8e7fa1ddd91e8724b9a238fcdbd4b42395c8e9a84d2ad1d400fff59f484c1999a0b4f651e98758d82f2a7605d90c3956fefba4737c51d9bd22f10a4be97328c0c7f14bfdd45fa9ac933f91396f48b5514a5487ef4f3784b8cd9e6bc34f6fe9743a125a0863c63862a982cc81391ded86f02036005344495d4f5b51ec6fb7e8e4582e57cb7666aa6d2b5f3a91bf8ecf9ef77dd5e2f9f3de4188370bea061808e198fa2fd6284fde091002c0f2cea1b98fdb9fa1eb991e3b2a485948e60dbcd840416b3763017bb39dec5e9d3dd3af38ab9677aea64bbf18ad7d2d0f1fa25ada15f8f67432d80e2df922810f425d2f6f034c7340efcc07963e17665c500a16f5dc9074b614c3556dfad3d4a60513b78c32f3303812e3e1af7031706a2d0f404acfc6124246415ccf28116025a1703083c52c6f0ae9d50f9ddaf0f17eec3910e76f25a232427b5b2a396f8f36ebc76f47be6140f45a887af57e2d1d11a8e6a1d60a37fdf212f29fcfd1c7bce5ef6d35e1375e0241d52108cb1690a4360404a82aaf7c2e24cc0c46752f1030f92417074a9a94bf01c5fba460f99a431de9b1f09b62c6c24ccf8c3cd25d6ecc7ca4e39662a2e5b92262c354a880db2dad37682ab039f22441e17d2eff11bf4441f9258ad8a38b327474bd6026495fe78d4633f5cffce659d39bf7ccc418a95b72f531010faf102df265464c02350c1e97bcacb6ef33fb6472f0815a182ff3cd599d9b4f391a63bd588f99448913da128a4703939e3ac495da8fbbb2f06a59dc909a8f15f1854b01c89d0db06c1ba9263ba7b2ac19593c4888de42b9d03bc25093377b20a6128aa1f6233fd1dd14b3a3f2b9393ab1958902e5e46b59baf5edcff5bf473cd11c5a2face25c337c58aa0d0cfffd409f6d1d0d10bb38c21e6b3bd063b563c4388a8d0bebafc0ee141761202492342a6df520e2363bf63a518771115623c7473664730e2f46017e8dbe91c9516438ddfb77c971d13c63eee7dcb2c9d8249809a165f0d78f3b345eb35222a969d1fdae17a6ec436c2fc4149c6e29e603b84c05d863dcfe2f5a47f6156e4ea6ff86b465d10f39821f6d96350a837e9f482e5577642ff03724296c6ab6c957de46a2b090b01c8c8990482a790f801c75f79e37ef4bbaa2d923a949d468c7c13cde7036d23c5e2208566d907531eba9a2b7267d7ec59921303db3623d91efcea7bf6cecf9525ebf770d5cea2c573d06c039cdc81b7f1643102cefe5b65f482d231452a148a9dabe715ccdec298ea493d61baff3d85a5af3c04176a63621381c95e35a56f837b7748ac351b23ad4a6c533517498a271a3eea5d4d1e1cadafa0dee51bdf5a271df01b20bff577167815102792bd7514205fcd548cff8face8f4b1852534332ca7db4a0b00af5c442d8e0e032b3f973bcf0d1e1655977efe8530f1ddb0167d4dbb0e4d080b70170d5ff5058cf739e9b808727b4d9514f28325601ce521415acc522e7b579a53483f5bce3e09ce7b2345cc2bd10335499347cc13d5b1555116690a78868056b0e4dde7043f587b71fc6acd04c2c30b41d40b4de27adc1babffcf4b3cf2de069f4c7564e6b58cded1c45462ac233da52574fe0b5da7fd03965149024f99c1f4c6cd3459cee612cf1b11023e2a5caa8b6212ddd5a051c784cd2b50997a6fb61567f413389c4362d7d762bc1aa3bafa8417821d8876cb484e318c4885a76a70510b4752a606e4d40e1c0a4871dcb597a328f66f4ec88cac540bbe46843de074490a56af8a2df32f916658ab53dfc484afd9aba6344c982dc1f3f53de37d1e44426e0a017a46c697be8f3185b1f4709c350cd67f9f4524bcaa1098ddf0df71345de63c736df816162986d0a5b9b06177a0cbdb3c0ba5224ff1a02acbaeea7c38490bcfeddc17879e990b85d72418fccb7933bbba2dddeee2eb76114f205cc8c907387139a72fd31934618f3aa2fa04f6f222422e03d19ef9696d7d7391790cb460ff4f356c1e217a73ebeb8487d9146bb7029029659ba593937f2da17243009b352e92350921df067707aab99295ad38c440e996be1a80123b23e7e95546499cd1f7b2ce1685203c81c3cbaa6cce271f6ebf4bfb0d286909f5444a00e7dda72b9ceea9bd3f3e2e81e9a20c00278a0ac0897e46d2116e2bfe375fb9f8306aa797a336cf48ab63730949fc7b7d74a4bd03afcb39d2afe77d8dc7ae61f9d536bf4a1466d56147574b9199dbc7bf20d44a6b49eaf5a85ab3dbc3022d0e568c72bb14ce03cc6b90c958720b7551d52230611476ac3e154f035d633b6811639fd4b3b00e503cfe554069000f934eb78870b9e665148fbb445efaa23aa7b5e088505791ee7559a461793c92e4dcc4c5401771d0ee46a2e90b86daf1414b425a0cf68ae874856d7eed990a52d1b073624a3fa363058c0bc11614c22a601bbf9f98ea1e269c675e5063c73223ac6d57a380483e0ed389d8ba59abc462a18368dc7e915fdef09de64a8b35c5b4cc06705f0376eef60540217be9d74385446a6b83fe29b31f8be9631792213a5943be91f49bf4248b65ac0284001866485cfffe2bee3f8ba602ddc4772f935507566470f4f115a8bfc96f0df2a78343afcb5963695d8cb77f34b45837202e38edcbb85decde11eb3bd25afaabbc4dda83e3ca70036d424eed92620bf84d766605e44604e629df11d6f45c2e821543ccdea702d4d33b032b614a043f30b9bfa0ab6d25d4c7d054d0d98b4374f0b8a31617894a52a04f59f6b4a7ce25f58cef4d68c95e9fc605bfb38bd7814a0d41b1cdb9f36698577068fc03dfec653b3769c00a2710453e8962f77c40397bc2c75f5f61ee92615b9a148a4ca3fdb6be7a72dfd755aae967b404c1ca1e96b883d118f5b04ea50cad4bab5c1e1d333a590ddf2a42c81c2f4873ef5b052b71c2e7a8898ead40baeef6fa24e214e8c475cfb202d19b2f4d8d26319104bf7dfc3c4fec1b495fac0e3129a662555376ea25fac182d72b293c783f57e2243306aa657cec8737340de6f57868b41be9576962c2bc451fc0ff50d787e43e9ba7174309996fdd8895ca67a1436e02dadfa0a1e4b4785961df50eb356fc6f4821c2ada02f8ed35d44f4b43743b3f632e73ac54bc577dbc47e495a01526a7c1f3b3bee2d008c3313a92f652bcf27f2a54e92472f55b799f1d092fec4c64fd67f2d40d24bc2fefd5ab6327da66f4a120393f135e686c3656cfbb9d6de2558dc3185babae7bb25c0f7a82f0826cea15e00e1f4dca5ea5d4aa236b171046983052b566631567316877987a6e5696def468302e36057aeaec786cbb4fa03cd6017fe3d3155766d9a36797cd52adac93243167bae457d5b5f3f64b8f44b78448ae1f83f53ff15444cefbdab2152f54088597472966876e59a74937346a7052541dbc08f714420178643447e54879b9db3130b0c87ec0cdb0f231a6ee22170614ecf9e3b8969e41acf7b1f0960dbd0281f66de7a5615850649f77b30d2f8269e35df5a760246d4addf30bcc40e30f80345bc03f67fb35100651fa611f7e49ad39c6f8bb81e4bac9e7e6ba787a95f6cd5e5edc01e20afaa5808d7b2366fdf947f738f523ff8929e3014a09d2c7e0512d20b71cc9b838e8e0844ba020f150a1094337b098aff060630bee72bab7a857218b28a64ca5f5a2b6faa9e9ae75b8885ca1ae60c9d3dd4ffd44b2d65b9abbb11bac254c791b9f69563f7b6f6b5f0b7caebc4631d24cc19a082f46ffa7e614571362bbfb59b321b7544bb26aa203723c0a8a12fca9a2c685ce9476d245d026e52fe3aba06d2582047a554847908a4bf1fbef0269c9290a9b3fa51ef6faf8c0b30ed30a7722f37d0a0fc80cd3b7a3e7f63284603d2cd854f65cd23e6a9a42406834a192733e4270f5aa02585771f7263e9a384ef3a05f453db59fb583319527f8077662354a760384bf706b7c30c1a1a86f59222229593c01423f5f27f46bf401ae194c5acb54340ae2412d3d640b60352298245fb849041149c829bc637d3be60c17d9c42e088f062af2b76953d1133e00184c8a4fb68387fffad205ee8845b2713872d5e5d0e941281733b01e1432a9c73afc9f622d60874c3e281e9ab73f53841a06423c12f3c178445b859af755b1ed1517dd958f20d5cdfabe4b8c55ad322f43057bf7e58dc2253f879bd3c20e5c3f9d378e259ee3dbc3068789bdb719a7e0021388c37b7ca11420245bad116d1c3988e3bbe7fbc5e7d50193fc561b3a19a4a7afdadd5b71934441632384c888333354a88ffb9f62c5a4df5e8dd9bc07107bbc540ef1507fc05189a6e884d5406beea7d36d82c7b402e6b2bb6125389200b976ea36399955ff34ae2740e943e4df25ea711c21347e0ed6f2302e44d613839fae9a7236d94d375f8df12555c7a3878666325e5ff7a8f0bd57e94e9b9e5f98267ec1ad2a97fad84665c2907197b3662996b1c77f3a7d29429f13ed1369dcc524e46ec7c1ab9a545c436399f78bf9bd555a42c295a76f3a973323199e15db4e4e4f0b8aaaaebdbbd80d7dc4dfdc569686c623dcd15d12ac3b8b7b1be2a6b388d85c0d21fe2238ca1c5022e81a95ab0c207e5673a1d4b64c2f2099e7a47ee792f76fc34aedd7dfb520ce85f89173a09bb57978c298aea787d8230fa5e912166ed4ac734f3cb30e3a62873c8686d093d0adf4cd650d6c5bba386d6b7f0c623e3562fc306d8cc425d15e6d2e4e889ce74f6fd496fe8365fdea706adaabc20ec7f39d4b9ad7c0ced61eaf8e2dd0f74843ff4d8b27418eba0fa5ec449ca2ed2c805ce98e5c2fbb5b0b627ca19115c2b55063007e2281f31051bb97b4066ffd0e11b046fe3e9f15031131c2e314bf46b5cc379bc4f0ac80b627e80c0be7694cc1c03dc87696101f8a71f6aa134d49761c16045990d4a07feaca92f724bdf8cf6ca08e72ad9e29238153c510f040cbb5b2127e6697bad0513de9fe20aceca8dc04c8362622523c447037265efbf67cca0642fa023a61c2aa1fae558414e275b426725fa6e331e1186c5460080afbd2e7e2c5a36c5b364e7da17351c8267b4b43dc539a1851507994579931ac86187475fe0b7a70fbe2971098deab545793f7094d32a369782519658850b105057eb124d6373ad006509a8afd61275de6118d54211179399c3c3d38feb12689138f9ba10b330f6270caa0867f9842cdcc217686bbb238c9d60dc184dbc28f980b7bd933ee18cea0e4a594398a7e1a93ead1d5be04f757c100a3e11c22b51dd9431f433508ddf3e5fb6763e6890ea14cc714b70c284d5b4e02efd04965f87824394a0547a3b620a5a2f87af0f2820d7d996644e2b4c93b43bb478c6a67c3b42b1611df0decddbc89d069f12d0f19e2653238cc7fbdb60f9c636c0962bff314ecfdc3fe78c0d9597c9eee5c97d2b8aceb328b51866db65cb04bf071ae326f7c87f6cd6c6f81fa3a4f934f903d5dd5bc33f40a127bb4a9e1a0edd4d2de9bf7783565ac0fd2894555294cdfdd339d7cf665c507f15ff90802fc8dc2e5b1892ee958a1780be6dc67b5c65daab8ceaa90f1f112caa4ea80b12308fb56a581114c7c3cf56f48c109c5fed0ec567254e33b0e5977cbcf02f3439d01ab4a781e2479265b159f7c235f00c70e9a0c952bcb99cf78ed476590ba513db5ff647f7b405001f27262657d0ac02824c2ee32dd6bcc855a0a894ddbd3817efc37e303bb85a4c844c1a7e4193ddf79af9da01c5f12a40857354bd6bcb9277a65f233e1337afc2d61ee857232d57882eb026837a5679c1f06c0b688ef6992d7832d80f3cda17c56077428316385ddfb266c6c635198c13bb374429a52c86a92d035f808391924d0ac1543f677ac13755cdab7eb6c615e7b49499e5d435b44ff778d8c1fbdaf460cbd9a36fba3cd70871843bc14a649f4fc321aeecc166ed7416ff1c95a19ad84f7b4a986c39ff1d987f80af63a6e75ca837083d98087346d6a0a28196c9933978bd4bec745a568f2b266bd32ee892dfd70dbd6cecfe941941113399053925b9d570a47ff855ea81e06710e470d6608479121b567add9d989fff96ae8055e2d78338754d69696db98112085218ecf3da30a1293c942eb92faa6dcfda9419276b77c59b576d51a02547ae1af06862b9e5f503fd44bc5d1968f84ab96b228387544dbbd9b8cf856b14141786ce7e78ab47b6efd6c18e2b940badc65f2b96a82da717a20422353e3a55fb8f2b8c21446257c587ea121a631548e91cb585bf9e6d321ace27f9bce7fce2cc93331c5f70c2deb1a9340aa35d5777a2b15e69e6bc3afbf9bc684e0648bde25fce1cf2dcc1d3c706dfa975311368c59dac5a4f4d393ddef6a7c0e7643d9ff0fb8189f521ddb981b6f7f3fb22cb4a0a1b0e23468d5cdb76ad8191fe064ca9b13cfb2efe0339a5fc1c2e2b2a5618444a636b92c5152d0a4e2b1a1377912034c4d4f109a1767f93085c8ac8bf4a9ca3e0c9b1730ceb912b10a86df8f35580327228fb9898a9feba0103e2fc6d20e342e4833e3650b48d15555b7247a658376fe65fbd936d1128075fb1f3b9337258d2ffef75b197f43bd5b29ac9523ae7996b4647659424ce580863fcb254c7fee6d33822e1d7aa4692cab40bc4751b92ae25b544c345158bea52fb5a5334caa76a569a49dc31861ca5218b7044e571721bf7ff557c6b3d9c5c13d2a94e84a1d6ea2d1038745c4be28b0cba3eb82ef18ea2226d1635816050abf78e065c0ded791e2ff686c369f36ab6afa4f569c529abeeb825cc92382306df72109d8fbf4c2c40f9a731d73a7f8877339beb10ed2bd42e548934ff61962950098b2a2c37554c63f4dee35a70321d5af9229a67d6184201f365e9b8ce6ca17eb66366963ba1c88d2f2e8a4fc19b3e6997566c69237a8ea2cbc10d303b8ba9a88dfefd8684ea4fc4f1e389d6d982bbf381e027b2b4dcc437278400f44715305ff547ba41137f0e20bd408bee702f73027aa9b2019b019ca3009366eb32fa9bd2c690c9e424a726074b21d9c0d42cc84b210a044e846d4fee9d9bfc8d349e2fc28eab6784f27480c48e7ebbf890bc8a2197b6c1079e3e525359ca42617959f20953e9fc9e120335a61157039f3728dcd01feb169508f50f8f3139c28aa8771d501b77d5167eecc10236a6d5f64b8e8cbfec2c5866ca35d4f30131d08ce64ec444d2e85cdd8fbe739b4ad19c86d55a1c19f6e049f2c99e6b2704a7243a25679fc587c33428f4df43965872177f3144cf49c275a949384394398a717f553100b8c9863b6e3abaa70bc154fc44a28eb076c66f817acea1ece57445fe19c6ef9ed84e59f6b144ed20d9cc7e1d23f773e333f6b32a7f0ac762192481eee37762f23539c1f61d6e588523374092e8055b9c20cbc8029ddd41cd068e135419a50076e5f1f7abb719349e8dc7c3827aa1870fc8c1428a56ab2c20ab6b8ed8217276cd723c9e6884f208bceefd3d12d67b18fd9fada28a349e74f2b9f5d055789c745580bc539bac004fd8e9a762371d5695c2308aacb0c8cca26141adfebc1ce916c278ff5c99bf2e9097d80b2da803152ba8678c8d8d6028af6f5659de13333ba21a77766ae38ea57ecc3405e72598bac7bf6e9541133b93423c68eaa72b395b80bb63cc5bb411a2034a9e395fc788079905f1c577eddde0748a6dc88a2fc66bf3abb46a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
