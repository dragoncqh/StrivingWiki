<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3dcb3f15bd7e17ea6a470db86377c1e421ecad8b5b03b6a448a56c4f47ba99b61fee2f4e2866512f5b99ecf1b33c6b6db4ca61467e7e536214ad41b4fbc39e45cadf3f78d8d300e918537b714e0c99476c7bd4a3b4f81c7ff167cba24b107462148e91b61547c593362a97c54c3e0f37cfd5c19c0377de68eeeee2be9ae515d215e6093a5b5e22b4fc3933d5d7f0cb67212505f66855b87c8b521bdcb74c69a200e458c655f9f0722906b1e538a365cf45f84ca2fd091cea21bd06fe3f95fecbcda3a8bff0b2d2c6c406823b8942eb9af49b405eb4a368c333e51fe0120dfaa4abf123b7828387e30044b1245e85d2430b59acf3ec275f66edd950fbae8e99d67d5ec14caa7601de813e4fa8d303cb89c737b5ca541fca7257aa850e5abd6b149f991edab8704512c8d15fb4263205783cf96e8875ae3fab3169142fe97d3e8499e709a9ffcf4eb5a62e4cf26917077b1ba78139a54e95063d12f5be6104d7830a74acec1454eb08fe5cdb0f8aa5ed83fd2adf4e2599cd287c4484ae4243a76528c6e4990c85335bbd6f4f28baddc22eee52169ad2a10e7c6a12884a3ca24c83137b7bd721b9d9c1466e07b31601a9e6195c73305cc4a25d978a43efdcf8ff12cff5608d6d11bd412aad8bd6b4cc043147f1c2b8eab76442e896f0ac676b749b52ab8227bceccc161f6b45fa516aac5df22d74eaa8fd09772d9dfe9e59ed56c05530084af8b794a2e47d75ce21fce0bc2d910ff94d35767eef2c9022780137cd0fd8314f5a0a2d5f6fbb833c7042380e8291d64521b447add796c0115b1739e0f34c3d234388407af8add38a37c3ec9329d7dc5bb196768dada98b2df0a219c34fc6e27cee491b95921dab7b4fa64a11d6b05f254f30413c64c0235ea37c1e1f248578c56c2a96ac6c2729445173feb853f1b32708568f5be9add5f29c555d0c3b8e3db192f64d1af87fbbee7bfb7ec62423bfd5b8dc3be16a577f1488d925f0822b5dda6ad2ae4ddb9b12d304c6510ecd8e343175a99f7a7f154d9bb43392bc6a7a15cac71cb43c764b689f06e8cf049e6572841fb14e4201c90bf4664fda562a3c8784ac96e1e46e5dfdf9f8c9744de50f093b2a4b4871b2105b7990ad870244bdec82ad70d9dad41886700a93b6144b27ea1077e93515a884bdb31da398fa724aba7345efff6fbdd576703f0f6ef7ce727b87be9e3de8245ac961e16e0ccdc105f1c4c3652dd39a27ebca9a1aa51489a0318df884f73e6d9baa2e27f2878cc52fe2936c7a9b3a376753eb7fa07882760728f291a1a2bd272a8ff95bd0273b855019e078017cf41fc4272297da46859354d5d87d34e1d1610023489a1303adfb58611aa0a51fe20e765db8cd07893fa75c1ad7adcd23b0145f3918836f155634f88174c8a0befbb37590f54895c07cee3ea550d2989eb848e57318cf624b5749475a8e253e526f59e3224760bfbdcb2d2025e3ed28e1de01b0fea725e5f9cada3e3e9d810febb9063c8d218a5d1f292a406a2bce578a336c9398d4b4e846efc505a6b00bfe042a5fbd826d58bacdcc5f216e9973ea28e6731fbc1808eda1aecf7a1ade5762d46549cabb9c7539ad04a7a4d9ba14b0811424bb4daf9fd1a3921aae2a59b88fd6acaf9ecd8d0ff03040ce59ef55d720707ee0db8e1193fd4943ffb122080bb752de7093a5fd70bcfe4d7a252170c316bbc366cd6074f02c76b3abab09e2fe7d5f4717009634fefb4aeda0a6415e70b2f63fb80e066128840d9d4f84b6457ab9593d48d69ea71ebece0f5029703c926ef87d409a1eb10a199d83b64fa15c4a6fbe76ca5f8e78a7f0da2f880d1f5483c90005ca6c99ab17fafe4038e688e12e4d7ee395f26cb6a1a059f73ef2ef4bb36b3dbf3ab7c838f9417ff8fb7ea1048c65c88d80a49407f8b546905d7cec9e6e1303e35fd62bf85a561c0a8e304d6c3eeed7ea2845a486592579b4aa4acca2f467e3c2b2b58fbcd8a93a3934fdbd9eab695e32ce2bcbf9cf0bcc418e6f97b2e4fdebbfefafe637ae14094f25d3fc9b369d25a72026d8260905c09074bf001cb11fe621fc563c51aadb746dec32969e595e539d19a5ecaba097eb87b71f4cc260d2b6e1aefbcadb424886c07ce167d4ff858afd2dcaf7941c5524b904a2070978679af64b8094b055df6cf370183dd6541ef335ccd784d3c93ad101a03f1815d885281ca67264414fceb79356ea8d56c39e620770fcdbad7c0843ae3f5733af15635db223dc800a57686de033dd0cb6944381bb3c7c25ed229245f464d14ff8ab4258497ff06a12592a9cfd9c6301f5d7999aa65155420d65ad63f3c516992cc028ba48040d7a941e2d34c72c50231e31a9407175b6730eba3045ad97901dea8b62004cc652811955484beb1da4824d27232e1add2a30c539328008487e44918001151f0061479df1869011fe65b9d105712e66e7020a9e911c32cbf5e0998c8f51288f40a372fce79b233180c74d09c021e7283019c7160111bd3fd1fd98681b969e18f5bc6f27c18b60c90bdfa60380caa71bf26ee955d5e3a6bb3d89fa3d8e5981461463620edc48d751eee61930dc9b31e9cb7494e3bf2d3884756ff021bfe882ac7f4fa0d0f9de4ac062728f8c6c31c5dc1c151ba887d8594b8738d2bfa1b8eb4e95aca1ae2b894a69d17e43ee6b46213ce50ccacaa8abe63e871f9aa4925a48fe444b22991fe5cc52757941c65dadb8ea1b18c526e6d841b9338ea64f4fae8d46a6a528e9d36addecf2b9ac225af49b28db31486634b1da1b9c3a5e702b52ae1e4eed6e5c3eb627933a2b0457de11abd6a2acce7a736c8b3eb1971802d352fb7de282199f4b008d2aa89b78db4e72c6c6e22750e3e30a2d782e6a989e96ae2e755ed4351b42124e7ca0ecf4278d42f3be6c20b1733199ace1cfb3665efa7a11b57aa9f4de34bf8a0f36eb36d914435dd724124077cf9276f4e1c5107ed9787188d4c56b4b2534605a7b29b0d0edf9ca6d52ad35ad7fbe2908eee67b67dbf7ac536ee1536ec67b355bc926fb66b876ec7cc8936d873c5bebd186a5e9e4bc99228c02d92ffa0e4628dba080d4b1519249e0a9d2f8e097eaad52c42a44d2b4bdd318eb615a046eca37af2156fbde5b0cdb95f7f99c0724fd851dfe20809bd59012db1a1cfed0de45bfb2791fd1169c58761e7c950cc3e10232fa262eea3528cc37b73433f3f66e279832574955685ccb575236b2855c8cdcb5b590440902c201d22cedc4fd84fca6fa13e567c24aa54fa4d6b09ff40a125818dfa40849b3304249d56dd2b03f14841a8fa93e5cfa8b85a4d248615a2a1ba16a32353c452b9b3909900d09893796bf39ae21f9c832ecf98585239f20a47132be4ea54b852d6c9cf62ddec204cb7d87508743c7cbba82eb9ff38a1c94e151caed57f5c71fa96f79947519692da23ffe1bc972d6cea27883578a231a82fc13b5e565f0b5e766e116690a117383e7ba212503df91665f1e47b0239801a27bbf784eefdad9f4b2bebf4e747cf3c0fc8f11c02eb2de85f5701f085029a729556532a99ff80ce50dabf1f37fb1c4367eef13b1cbbf8be0895b73a6baf8f35ec1a96ec31617b2db72dd2c779998ee2ffecc810591d0d8fa21a5e1f290e225aaaa37b80f0415c54cdd49c966002a53d552211e36229421530cb1231c521a506fe6855bcb7e261b9d7a272feaf3e617513b6843ae633313e47715e2ca1ac41a95e77e1aafb43cd47635eb5cfa8aa03b98a034a62eed7441839c984d644577e06da5e7856aae49143d9ed0c29e235bc43d9c8a82b544ba950c13a31edada6c7ecad35265d73af391a390af071a243422b9b71c92b4424c8ec4d74157814c922ddab981c48052c5ba358e4593a3fd4e041bb520516e42f4b560579efe7c4145717f43eff15e11434afc9b33149326886eae1739ebdf53b03af70b6601316d78fbd603b432f730111a3bfe79a0c1b4ab8bfb8c5056933c8968441ef6b9c20a5f1a52ed44ebb9840b76d8b2cfecd0b18af362beb1ad3d348896e53116b0e2f2dd239d4cc5c27d2dad6351c0c92f8c540dd38f7efbddfca0ac6fac037e456832dc7fcf285c66102267451c54e675f0c47001e350e1ffa7b6e7cf270105745cbe691519df3cae0b15d771d53f7ec2a26339a4bb66abc83d0a2b8c4a1fb07d0798d48aa913083ebe1a863adcdc35a213616c18bf10890324bf7f13c2a341c4fe5c999645e114ba155d704eb1f21251093a63577feb93e1e8a2ced98a92a6a3b0c6ea1afc30ff323d3aa6ea99e461b41b788976a4f080fc1cbc16c7409c13ef0d306f421b7671067b2242832103769543fe009c3132c4ec0d140bccfa4514724816d6f92e4a458ddd8bd0b26d30181f3546fe15654b7d9f5c778151ad5e713a5686c746d47638029fbc0ac5d19c08a719e19bdbc77fba255ad0a0aa07548e2cd0026c2d93c7ffd55abe40cf9079f1e485c9c4c559b9edc721912099ba5b24cf02ba6094089d3dbce92a98fb7b441abd04442054716b6e679160efdb9bcfa60174fb76749c9e86b86928ceef381bf736d90118d51f7b7f7bfdf5737bb68357ea2105dab29b712ee30da2843a26ebc513c5a526e1b63d92d4d2a2a2c6d5d01b7b326df2f63bbf40db4820b04e58d967d6edd6e81d4ab73f3caaadafed62fb9c5967fb2d10c92bac7adea1db0ca01ba815ec5e3927a2220746c43c9cd2bb86487205665534d0368e39e61332cf8a4419b43b7dcf1aed299347bbf0e9408d491c61e74c6cf65378929b86e3bb0d7b334bb7f333588c015dfd1b0923ced84a3426b995cbf84e42e7a8e6bdb0dbd7c898dfc3401b0681593160381fa2b1864f9241418843f8785a58f2202ec69a35e5c3925974bf04acf99bdcb2af9f9907120b1909b0e42924a774a069730002f98688485f3021e5fb1e2f73d5be09ed3787741a605b0479e7b0b2533d8ac72405d713ed3a1dec6e61233d28769100dd797e6e02421c90de05fd8d216fac5d361c9b5b7feeadc876b6bce61502119e2d50ac2de8f73d4a10669576c00a530f3500e2b2394d8ebcf4240946e810062de97fa039ad78bcd4b7b649fe81a75f433e4e7e6c3d7f4c76ec713f266a53d455bab497cd158c20f7f5ab6f8434aaee5ccd4ec537e9b09c4ec4f1cf5a5f46abe6527822af33983a01f4af8c23c247cc98797df6fd410fcb1b586d91f690621b42b012388435fd212c9d0909a70268d09b03750ae02402b7bad66c8640e3bb98ed7377a6490eb0579aaf2ae45a952e9ff045aca150b8aec1dc1328c5aae84e8932e15fc3ae2529936116102d34213e1f92d889be235e4e127ccc5ec8152dfd669b77b945047cbe09956b9d7728c07660ee8dd91d2565d91320c3d94ebcd8b5895bbd870fe9823627930a77e6dd214b38ae09b708fd8edd2b53364cfb8aa30c21c71f310243f75499f6c02c3079e307e50405ef6aab3f6aa4f9fe98ca4ef9037d036a2479c78c12810f9ef3186629c55226ea5f48f6bb9d055b6e6fe7eb15c8bf356666b91fccbd0e993e0965af2b136f94910cbdc2ac115a0202b4538e157e37fa769187f57c8eb4b7599716fe5f599d768554227af740cc9f92a14b2cd0e8cbc13109ae0378fc0bd6c07f5d1ac88c2ab590e37494840344ce8fb2ffbf6036b43ce7afc7100999d31dc5dd40ebd21648ee8a07ecb85328f1414782039dac65d0cb9e3911e6bdbd040aaa59d51aad739e6a0a93d6fcdfe245b74cc67d4f939fabf328fe85f4d3e43399f087acf19461e07b24234219dab3beb9450a2a3985bc0f1d70af54c2e19d14619e691dee1166555823e8d9b701b6897106edcfc3d8b564c8d42b43d8268b3222f6ea128663eac9861e55a04c9981f89ba3bc74ce3032b41b7a5b81c6fe41c47563dbfd7c8ac3cb77a2016835289c0a41ff1a89e8a58586435ef936db8101bf0a0b99af16189b5ad4bb13cc43845c2c490a56d6af3428a581e0a529cfa115ad5efff6298e8f0bcbd866dc84e27effa18f730cbc9528ec6e61ffc29056e3db073920f9802d3b34a3e14c02e9c123e1c9585a651b6e2587b38edb7554b341428dd18f0f4fc7fab4f4e9dd829179270ffa38318c92d78c9e892de41dee8947a87a2a317b364e2bd40b876a399c5d8f9d6ba4513ea80b219e4ade10accb738cbbb09a8ffbc42da8299322cfaceee94079343b4f430cceba244ed02a11276b32cdfa79f2d429ded9e457b263b0e97cba2fad47811c70995cccd88248c873f7c85b4123f15f24c39791a3001e47a457dda5ba8ab382f645471d1ed3712c61c8aaed9e0ab6ee3cee7fa85d61ec683f8a2f8eec9ae5265d731edb7aa61c6c7ecfd994980b538a0aa129efc38e11d10dd76d8fbcad9f32e1df0481d4ba9ac407b56ec324c1d9214b076776879e1432bf55bd4dc54b077e0cf1118ac4642dba9232e3b823ea7ad845525ae09bb681f33ccf35dc6cc291eb47ddccaae32a1d01b5144aae335e768bd170ea37ec7f0a9c5e15194d8fe3cfaa4bdb08af3d3e41a196c3a772cd905346d87c6d94ac376b23d432dd83b938cf81a5b0a593508a8fe194be341fae512eff377f3b348de96eb46a2a0b03fcbc5820dca613965fd14e71d86871739e17efe2c1b3268c58f03013483cd82c4446e9caf93b6759f76bb5fa64ec4c4a697f6f555bdfec323a5cfd593c22d015e212dbf705280fc6e53d7e9fcc63b53ca7d34405d3c953bd50c79f9039b8d7f787c16d9c4de83adb35be4c5a6bd361fe0b41c3ce73e03abe8887843e7f9ce2f8a0f7618c5339a8d48930e71e059c1b03798c93a7c3d535bc98b7e6f0c844de49eaa9c74062ecca3960c117024ca26d8ab0a061a719cd8048c09f55cf13b7dad1c77596965d293c096c00e78377dad7380352c388697853f8ef62aeeb483f6326d8f7b911b62b1d808c314fc813d134b34b99247092ffc0704ebf342e857cc5fc96982122e20a41a59e3dde217b80111d554e2e673d872a6394ee40686841da83b01529a942f08bedc389b9d82a96ea4b26d716c153dbe26b035155e887c15441bf383c080505ed0c2f5d0d5318bc1eaf87871fbbda160e5b15acadba9f7bbefbd343ac41aad520abde1dea6e49ca33a788ff0873ea1b948d1902c6cc39ce58e1fd916f316470054417d7d73d4c6f22dbca425077486bb233b48e8fbc362de7e8c1ccb97c4f56cf04d974de304af1d0935cb86a233c116632a0cb8df7fdce611f2ebc1262dbb6090eab77d88b9c3b69ffc0da7b2f7dd9b35fd2360c48e4a0febfb76e5c94cf3de380c5d1bb0bb3eb05ea11679901327f5b1b991c88425c295a42241e20225bf157d37242bddc8cecda992770ddb0b18024b3280abf7fa6ebcff567aca96fad23ef79730c851b40fe927cadcfa09cf4511c0d3d6745b97a8d7c4c458aa4d3d539e52b60890ec7a7899c637698bfc751a2d2fb96184b2c4f813b35dc4ab1babf537b09ba24f211617cc8ed95e0af8ea589272a41d9f2e0504efac99c0b4e926507fb76a0ac7b0b565fd602ef027aa7cedc8de2916c0e3bc10830ad0c255ebb94be6b872004488550b4c88fd57d1a52b221146adc43a6e64af69fb94c382799299440b9de99314dc8601c2a13cfcfb920c3acdc6a96c38cdcd938e30fc3c490f8fe4bc2f35a934da91569bda7358fdd0bd404c83f04e180e7d83ce06c7829983810fb857616329240f821b47d087d545d779e7f16e332910cda7bcab51ebdbbe5b7695659f5e3d23994a3c8d2e13304d6b0627c584caddf2c3a6dc9be9fdc1fc3409ffa179006886b101f7da01db9182cb147fc78278114b7338bb3f14bbc1c4fb2f3da2698d3514bd19e44caae466e8b81c97b10a4b151aec1ccea8b7d8bf5e122c2ee3a80f4776dd70b0a68175bd0ca4c8b36051ce5643091b9a0a73f6f6ebc221a06a71ba10db3c98e97f8f3becc14bbcef68b76ad43d61298231b3894ba06f6a9e68d559c699060e2d011111e62a994b2f92215aaae2418779ae8124de65586eb37965fbad45da7a42e635d63c58876cf0b3310f3563959171fdfed1fcb19e8c7f953d3bd6a03050cb537217fbd2dbd14152b07bcdff87b2162b83aea31562a57cecbeedaacbfb70303e912061c9593ddf0ddcf4077d89b64e05f443157f3dc82c53d14403fe3b961038dc457932a1d7b841450312d608ec38893495341e04be43b12d4c3bd21616f240b8d0dbd19209ed70b61e4cfbcfbca63836b62c6e24509b80816f5b461f5fa2c322c8d4d5342a2e373387cf166ec3e2ce2cfbb65a011b2899679c957a6c613b60a22d4988e324cd54bbc21be206bee2c1ced0bc3a5b579c9af0cf29ac68e2de9ef2d73fba20856629e2818efe03d4e8342e57b76c85b855e9505585526e2c22e2a5099ff3319eecf9aef9b5ebfcd18929f2e72b749bfefe4930ddde15afbb3a25d4befa551d3ac6edf4328e3243763aeec39ea52c2d4e5c3ac042901ca31142899fdfcf300a4aa814a6cd9b59747cff508581f1d31bdba0d53d8d6b8419f16d707b604a4495d04b26a1fab4e1085a0536c579cee197f24ce16632c4600da35688a940a403e846e04170e02ba78fa85fc2b5b8610057d5c0310d113600f059b3dae0edcf4738b5563940b54f0de81f2a7700cf7847589c1aeafe815bcff476e82946e65936b9590f649ecd1a9c091ca627bcb2b192a0ea97482e250bb452b7b793df715c73c007e672fd4b0d56a0c0288b0603175574082d7bafd33fab92d59a7b321a6d3ad04e56a63c5b1831e531bd0c627cf11bb2d69bccf9c69fb3774f96a1a5f761b9ad0dc6ea6bf32e267f1247c0040b3c66a6bb3e1f21362163fa5df969a58e18c0bd05726f4d7fb598ffdabca9c53b08edc974805c77351ff2eabd5d65029d58897ffc03f17be6b4e20cd9f9ce2057dc871e1da0f94dc6eabf7f8040769f9c7313c62bdf2c1a01bfa0b9886758e750830d580890f5fa2f30266faa34cde35a01c6c35418395b1770dfff883100e8e9a712d62b8781e89a5cfa4d531a7e09030fdda6a64820ed7c8db46ac35d08a42006d70ab231956e83f7a8bfe9694c48f1e2c82d745cf2915d28c5f2e0fd5c9247891d3160dc9ce00fc0fa7d1b4a1e081f7f4397e7e4ae31619f7af7cecdaadb5f33cc9d1d2ce5ebff7f02715ed5a49489c29717ea78b51fa65dccf5fcc91107ef2711e98f13a01ee6d95624ae3633bf26d742810f89cf902cc0a02704584e73fb4edf51d003c36cdd51180143c9b02817912256226b7c41b9a165ecf42ffe4a4c5675e02c2086d6b07e7088e442639c038453cf0507e75be4370a4e1c058f3eb9c86928b857ea38df4a69a8d4f7597bcba21a8f57e175a89f40621fe9d5f32a9894c963ee0be6d0d67c04eae9d382c99af650f423db6fc088e66fd03e6eebaeb3521cfe6824408f4a75b447af66a833b388b9e7f825708a68ef40b628ab5abdec58d48f9c7bbe7bfad27ce7aa8e26d6f91d80575e51a3d5d1cdeb305a46a8cf422f4028b74dc42f23ee7c763c591a8e711b508b22f266c004c320b235804e3ea938ed29eaa0c749cc4298f7b3a4617ee8b64b8e2f22a46c55cbf27a6bf71b054051bf2eb33be13c19f7547ebf5d5f688c5965928f410c582fb75dfd4411687fe1c4db13f2072f336de51e194090c7302cfb3a7aaa8d30c0b630540b325810be3a36a760be3ed20c02daebc2dced0bf3920222982c4c300f2380bfed10d284a63d5a66bc95a46de90eb3e91fedffd0ccb3047c4a87d21862a873a06e36d02850616aae12b9293d65b7b0b0fb9eb2a8f2f1f320e04af338771687c764cc26826bb23623fd7088b3078496815031cacf3088235c75b0750e500c51f8ecf75f3474bf927f25d1a22f8814b207e4612f7ffdb2f1d2fca54a052dd359157d3f821a831f2de0961bc885db1d57dc6122664db299f22d35229bf5595e2a77ef1d39d08ce14cf4f716bd31a84720630472124c55777beca422196e75a6752aef531c1bace6d9cd914c38bd7f4d3d1842b51b3cd3bf41dcbe50d234d0d99df655c2a12e668bc0850e085d95ca9639989a7fd67af00b34335b12126e36e3ae8a3d24d7fc2729aa3567c8af6d1d9670c0ad5842a4d8d844ff61bca879e3e42410623454a0c9f735d004d890722e873f890f39aa6c9ddf949965ca8e564ce3e4feae0771a85d251f0f3eb7df0d20680585ee5397e59890d4ea02b110f9634c8298e81405206482590f14dcb70fbfbce8dcffdecc4757a306c153742cdb2bbcf1d5b7e1ec83d58d7b820de02c97be0581899d5b9839d6163c8e84ae7a740a67cebf067b9f19d8962d4a5f5825372c5f811c44ceb366ba313bc01baed548c9dc949a09dab39c710b9cb0a24075968899645bddf977ba20b91d8a47eaa6d3ba196fd792454765e2827b4dc60baaa29ef8a3eb3907c1d2cc0ac69f41d3090793049dd07f4df94ce610c11b16d84dc83299df271e184b36c87ad872675c0cd4e1c3117bf4b54fee42e81af95fafbfc664254d8925dafa84f97aff26cc2fe3e9b7dc6546b1684968b5a328a8a2d4327c4c6c75f28982f5cf314f8379db5062d1195dd2e1c2fd57f6214bfcd2f5fc75a7eda282638eb2a31bc9b9c7c0fd8390162f819a96dbc27e3fd696c573fb854eb02406fa8bf2119f50f304e1bf35a9addb20286c9321709c03acdd36af4e339eceb678d43ea7efb83844479c1a201db584ac8049719a4c500c5caaff123ce8620c383140dc202cce9cc6e28c376f481143b26fb9530c9534808a64c3d6126a22b606f7451a5f90d6500c0502104066c7162b0f3ff900815de6ea890c97a4f12d140c0cd56258f51bd22911b7c7a3103e303797bef02914c771a5b95a9d3e590af71eb518cf9defec8ff0c1ea2e97ffa36b3195780e3ad0b7b772d23304b9263e2251847925fa37bd7dd8c332786a4b30c26475d6a724df306ec3565ca2ffbb9bb737fc0c1e8c35f866438c2325e7977d18c566535ddc1740f2c762b138f23f139c71310d13e8d425aa799182b79e41c6f8f4a5104724bd78bd9403f321f77ab2344590cef1fdf333ec60e20c0b000a2823af1830820444f8b6674ff3980e9795e5584a1faf72a86a9057bd3a509ee2081a8a7787474c6d3d78111d4b1f411c25346330e86b2492d4e2676f99abf57c0bc47b58059a4874af7018eb838749c3615cc1b591171658436935b6f3964a345d761f1bb3a913247bb3cf5187693695d5a76cdedbb3e01e6101dd3f6ccc2f5113571f9f80178c5cf25e518e76a54061f0d7298f2a0006f67ca9823472c5bf56ace1040b93ab5591bc609a89bd3002db84bd05ce86fc45cfb0156416d3d47f6c359ec9f3d13c5d7c6ff5a9f9dd1efa81e499e5230b18c843d04ea5823ba0508bd534065e8de8d625a9d24366f377fc9a773cd1734e965ef160bf29f5db337b28b74b8f4476a2c6bd480d1a1d54edeb09eae701323231ea4831918a1989f1fdcf21203a8e433b7821c2ceeb47cc1ae0672f805ba6d40473cf4a708b8cace25145b9bf8e694ffb3932a98eda9a9445ef8b4071ac1ce84d67dd3e929af1b3c4db9a4a60ea37db73f01b5d136d1e4e53459e5af8824d690431f9ff98d47ada505c7e6b499730865499d1deda216f4d6dca6ea1d93bd92f573c74c3b9683547d8f367afeede82a108b1d9c257303c3374e087676835b478a5b4285289b72b214ce9258d45d0e57f18bf1a8cb8df7d98e554249aeedf07ba01fe04a9373cc84e83489f39d3375aea105317a3f3a8a14d49108ac45883cb0919c7e3419a2197ea78984ed0ddf1f1568818c3ae20d0f30063fb5082154e750637168e9a7484229c5cb076ce65c57ae4783c45e728c6b0248e51403d9b66bd2140ab65df94136683f9c957d379286e97329ffd00a0ff3f6610bf29fedfcae15e77dce3d657ecc01a1b4da5f28ae349165597193d3afc445098c2ac523cb6f2250777b8a650a3f9b687cd0c2dc219693b8e76c37bb0b09cb37a04d1a50175178128daa3f0b89efe209b702d5f69d4283cd20a7a3ddb476e2e93716a25f84083e92030fda04c06bd633f6639bc359c96d15ae126039beaab3eb87bed28db27336a46e82e03377e5a0ec45bea7778a7de877aabd459378d853e14f8d077ac528ac808e8fc7b9c864eb10701d3d103f0a944c988dda2f57a31c3d5ec7b2a23f0dd6e966844ddb80eecaceaa332890190dda9fef4534b841b15f8cb8ccbb8eda1ec5c4da197662d6d3afa7bc30248c6b8b78ac1ea5d482690ad1745be54e9d455c40a6c19a8b678af8c7a2fe9749283f62ae3dee1e4982130ff523d71c56d9b9f6128f63da8d1b63a954909ee5dc6d2c54a62ff90801cc018b416eee2ae8f153ef85246ac647ab721c2385ebc4c3e4f85b71be03585247c57772c4d3b6dbaf69ca8b9c702797435a12d897e7e8a1be8fa18818a171b47bac464278ce4c282b27f7e066fe53b16e7999e89f0bdfd095c5199d6f141ddcf400168adbc86bc6d5e9fb7257248496c81debec5a276caccb464fa8608f432d3829d7c8b458d3e8bb41fbbd710332fbd749bf96af563db2d1da0c3e94a89d7f1db5a98da0dfdfc586c8803de049d8c1bcb92cb979ed1d3908ec543458731c351a66dc9f1a8ad154457aa7f0f2927a9aee812e8de9f3d3030e1aefc164ed8e5d6b832f627b47e5271f9a933148b92725e581df5bc3508526b8d5c89f3f6424bbf32afcdb7d140604936fe1c9cbd79cea75ea15158cef9ff0e4bae2ecec8b9618c58c2fc8e259380196c7c90141002e4f8d216156303a6a2112c6d69183b5fa79ef2798ce26e7dbee966f379b832a1f326fb1bd3db3872be535227d5570b69681de2391a427d3ec9b780dfcdb3441c6e459f7af5462e75e4c23def5d28e46c254cffa485b95b43a0bde0e992b108a9fc5fc779e646d9d4b9cdf621bfef2f04ae6f5dc96c2e9e9eaed2fc24b66deb334149dfd2d1205a983be4e506c242bfaa686db10a3539d25ff1743698521ac437d21811db3401acedc4347331a0ed4ba29b6327182d342ce81408dc231e8dc6d8e9175317c675100bab667adb0f0216a64a7dde8393f7e88dd6245e0fde094e07620272e04114f8cde639be92ea9ab7dcad8ac1ebf2b04835f7253e05ebfd1c3a54d29d6944a208b0c1664862cbda3ed559a1e3f3bb110109e981671e29d6533f6966812c4d7d369cc5f14af9a8857daea42f34384f1c3380e1a19fa146f0f91b7fe292099f68ceb14746be90250cd32a49922478fd516f72e252d2d8f1150eef7afc636bf74d409370590777472ef86ab3156b77ccf9e529839ea0bc45b2e1960459808caf97614173da1820ca295f05cdfe45d22bd9d8e894c061519ee02c10a2a645caab5093aeb6d07de4443275f776a783c770d72f6cbcca5135582cdc92eadc8a35bbb9301e9ccaa222bdf43ae7492e97e1662514aee11b668befcf1a06269a5278a82efce8761c5e33bd583d409c47c22bfaf46d4cec30d703aa141ef90983d04a768a0a4459d48557c260d2e7dfaa5380eebb6fe6c457aa2b0134369145b56d29343ab8d68e3fb0a4b77db7ee76343508b336ea53fe4addcb2d5dedb9c5b5ceca6a1c4e739b3798544","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
