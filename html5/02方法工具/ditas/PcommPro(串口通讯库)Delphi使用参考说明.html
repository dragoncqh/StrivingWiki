<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html lang="zh-cn"><head><meta charset="UTF-8"><meta name="copyright" content="(C) 版权 2024"><meta name="generator" content="DITA-OT"><meta name="description" content=""><title>Pcomm Pro (串口通讯库) Delphi 使用参考说明</title><link rel="stylesheet" type="text/css" href="../../commonltr.css">
<link rel="stylesheet" type="text/css" href="../../common-extended.css"></head><body id="PcommPro串口通讯库Delphi使用参考说明-BF995B7B"><main role="main"><article role="article" aria-labelledby="ariaid-title1">
<h1 class="title topictitle1" id="ariaid-title1">Pcomm Pro (串口通讯库) Delphi 使用参考说明</h1>


<div class="body conbody"><p class="shortdesc"></p>
<p class="p">在Delphi环境下使用PComm Pro通讯函数库必须先引入函数声明，将用到的3个单元文件分别是Global.pas、Mxtool.pas、PComm.pas,预先复制到工程目录中，在工程使用加入单元功能将这3个模块加入工程中即可。</p>
<p class="p">数据的输入输出包括了串行数据的送出、读入、硬件线路的控制/检测及事件的引发与执行等函数；所有函数均有返回值，错误返回值均以常数定义在PComm.pas模块中，如下：</p>
<p class="p">(**********</p>
<p class="p">PComm.pas</p>
<p class="p">-- PComm Lib unit for Delphi (32 bit version).</p>
<p class="p">&nbsp;</p>
<p class="p">&nbsp;</p>
<p class="p">History: Date Author Comment</p>
<p class="p">5/29/98 Casper Wrote it.</p>
<p class="p">12/11/98 Casper Update</p>
<p class="p">&nbsp;</p>
<p class="p">**********)</p>
<p class="p">&nbsp;</p>
<p class="p">unit PComm;</p>
<p class="p">&nbsp;</p>
<p class="p">interface</p>
<p class="p">&nbsp;</p>
<p class="p">const</p>
<p class="p">{ 波特率设置baud rate setting }</p>
<p class="p">B50 = $0;</p>
<p class="p">B75 = $1;</p>
<p class="p">B110 = $2;</p>
<p class="p">B134 = $3;</p>
<p class="p">B150 = $4;</p>
<p class="p">B300 = $5;</p>
<p class="p">B600 = $6;</p>
<p class="p">B1200 = $7;</p>
<p class="p">B1800 = $8;</p>
<p class="p">B2400 = $9;</p>
<p class="p">B4800 = $A;</p>
<p class="p">B7200 = $B;</p>
<p class="p">B9600 = $C;</p>
<p class="p">B19200 = $D;</p>
<p class="p">B38400 = $E;</p>
<p class="p">B57600 = $F;</p>
<p class="p">B115200 = $10;</p>
<p class="p">B230400 = $11;</p>
<p class="p">B460800 = $12;</p>
<p class="p">B921600 = $13;</p>
<p class="p">&nbsp;</p>
<p class="p">{ 数据位data bit }</p>
<p class="p">BIT_5 = $0;</p>
<p class="p">BIT_6 = $1;</p>
<p class="p">BIT_7 = $2;</p>
<p class="p">BIT_8 = $3;</p>
<p class="p">&nbsp;</p>
<p class="p">{ 停止位stop bit }</p>
<p class="p">STOP_1 = $0;</p>
<p class="p">STOP_2 = $4;</p>
<p class="p">&nbsp;</p>
<p class="p">{ 校验位parity }</p>
<p class="p">P_EVEN = $18;</p>
<p class="p">P_ODD = $8;</p>
<p class="p">P_SPC = $38;</p>
<p class="p">P_MRK = $28;</p>
<p class="p">P_NONE = $0;</p>
<p class="p">&nbsp;</p>
<p class="p">{ 调制解调器控制设置modem control setting }</p>
<p class="p">C_DTR = $1;</p>
<p class="p">C_RTS = $2;</p>
<p class="p">&nbsp;</p>
<p class="p">{ 调制解调器线路状态modem line status }</p>
<p class="p">S_CTS = $1;</p>
<p class="p">S_DSR = $2;</p>
<p class="p">S_RI = $4;</p>
<p class="p">S_CD = $8;</p>
<p class="p">&nbsp;</p>
<p class="p">{ 错误代码 error code }</p>
<p class="p">SIO_OK = 0; //正确</p>
<p class="p">SIO_BADPORT = -1; { 没有此端口或端口未打开 No such port or port not opened
}</p>
<p class="p">SIO_OUTCONTROL = -2; { 无法控制此板 Can't control board }</p>
<p class="p">SIO_NODATA = -4; { 没有数据供读取或没有缓冲区供写入 No data to read or no buffer
to write }</p>
<p class="p">SIO_OPENFAIL = -5; { 没有此端口或端口已打开 No such port or port has opened
}</p>
<p class="p">SIO_RTS_BY_HW = -6; { 因为H/W流量控制而不能设置RTS Can't set because H/W flowctrl
}</p>
<p class="p">SIO_BADPARM = -7; { 无效参数 Bad parameter }</p>
<p class="p">SIO_WIN32FAIL = -8; (* 调用WIN32函数失败请调用GetLastError函数以获取错误代码Call
win32 function fail, please call }</p>
<p class="p">GetLastError to get the error code *)</p>
<p class="p">SIO_BOARDNOTSUPPORT = -9; { 此版不支持这个函数 Board does not support this
function}</p>
<p class="p">SIO_FAIL = -10; { PCOMM函数执运行结果失败 PComm function run result fail
}</p>
<p class="p">SIO_ABORT_WRITE = -11; { 写入已被锁定，用户也放弃写入 Write has blocked, and
user abort write }</p>
<p class="p">SIO_WRITETIMEOUT = -12; { 已发生写入超时 Write timeout has happened }</p>
<p class="p">&nbsp;</p>
<p class="p">{ 文件传输错误代码file transfer error code }</p>
<p class="p">SIOFT_OK = 0; //正确</p>
<p class="p">SIOFT_BADPORT = -1; { 通讯端口不存在或未打开 No such port or port not open
}</p>
<p class="p">SIOFT_TIMEOUT = -2; { 协议超时 Protocol timeout }</p>
<p class="p">SIOFT_ABORT = -3; { 用户键入的放弃 User key abort }</p>
<p class="p">SIOFT_FUNC = -4; { 函数返回的放弃 Func return abort }</p>
<p class="p">SIOFT_FOPEN = -5; { 无法打开文件 Can not open files }</p>
<p class="p">SIOFT_CANABORT = -6; { YMODEM取消信号终止 Ymodem CAN signal abort }</p>
<p class="p">SIOFT_PROTOCOL = -7; { 协议错误检测终止 Protocol checking error abort }</p>
<p class="p">SIOFT_SKIP = -8; { ZMODEM远程忽略此文件 Zmodem remote skip this send file
}</p>
<p class="p">SIOFT_LACKRBUF = -9; { ZMODEM接收缓冲区过小 Zmodem Recv-Buff size must
&gt;= 2K bytes }</p>
<p class="p">SIOFT_WIN32FAIL = -10; (* 操作系统失败 OS fail }</p>
<p class="p">GetLastError to get the error code *) //调用GetLastError函数取得错误代码</p>
<p class="p">SIOFT_BOARDNOTSUPPORT = -11; { 此版不支持这个函数 Board does not support
this function}</p>
<p class="p">&nbsp;</p>
<p class="p">type</p>
<p class="p">&nbsp;</p>
<p class="p">IrqProc = procedure(port: Longint);stdcall;</p>
<p class="p">CallBackProc = function(len: Longint; rlen: Longint; buf: PChar;
flen: Longint): Longint;stdcall;</p>
<p class="p">&nbsp;</p>
<p class="p">{Import routine from PComm.dll}</p>
<p class="p">function sio_open(port: Longint): Longint; stdcall; (*打开通讯端口。参数需给定通讯端口号码，}</p>
<p class="p">例如使用COM1就将参数设为1；可设置的范围为1~256。*)</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_close(port: Longint): Longint; stdcall; (*关闭通讯端口，此举会导致所有的传送机接收的动作</p>
<p class="p">都停止。参数为通讯端口号码*)</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_ioctl(port, baud, mode: Longint): Longint; stdcall;
(*设置传输的参数，需给定的参数有三个，</p>
<p class="p">包括COM端口号、BaudRate、Mode（含Payity、DataBits、SotpBit三项）。</p>
<p class="p">BaudRate设置以下不同的整数代表不同的设置，如下：</p>
<p class="p">----------</p>
<p class="p">| 整数|设置值（bps） ||整数|设置值（bps）| 整数|设置值（bps） ||整数|设置值（bps） |</p>
<p class="p">——————————</p>
<p class="p">|0 | 50 || 5 | 300 | 10 | 4800 || 15 | 57600 |</p>
<p class="p">|1 | 75 || 6 | 600 | 11 | 7200 || 16 | 115200 |</p>
<p class="p">|2 | 110 || 7 | 1200 | 12 | 9600 || 17 | 230400 |</p>
<p class="p">|3 | 134.5 || 8 | 1800 | 13 | 9600 || 18 | 460800 |</p>
<p class="p">|4 | 150 || 9 | 2400 | 14 | 38400 || 19 | 921600 |</p>
<p class="p">----------</p>
<p class="p">Mode参数含有三项，如下所示：</p>
<p class="p">bit_cnt(bit 0,1):</p>
<p class="p">0x00=bit_5</p>
<p class="p">0x01=bit_6</p>
<p class="p">0x02=bit_7</p>
<p class="p">0x03=bit_8</p>
<p class="p">stop_bit(bit 2):</p>
<p class="p">0x00=stop_1</p>
<p class="p">0x04=stop_2</p>
<p class="p">parity(bit 3,4,5):</p>
<p class="p">0x00=none</p>
<p class="p">0x08=odd</p>
<p class="p">0x18=even</p>
<p class="p">0x28=mark</p>
<p class="p">0x38=space</p>
<p class="p">不同的参数使用到不同的位合成，已经都将可能的数值列出，由于有三个参数混在一起，设置前需将</p>
<p class="p">每个所代表的数值先算出来，再用相加的运算加起来代入mode参数即可。*)</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_flowctrl(port, mode: Longint): Longint; stdcall; (*
设置软件或硬件流量控制。有两个参数，</p>
<p class="p">第一个是通讯端口号码，第二个是流量控制的设置，如下：</p>
<p class="p">mode=bit 0:CTS flow control</p>
<p class="p">bit 1:RTS flow control</p>
<p class="p">bit 2:Tx XON/XOFF flow control</p>
<p class="p">bit 3:Rx XON/XOFF flow control(0=OFF,1=ON) *)</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_flush(port, func: Longint): Longint; stdcall; (*清空输入或输出缓冲区。有两个参数，</p>
<p class="p">第一个是通讯端口号码，第二个是清空选项，如下：</p>
<p class="p">func=flush function</p>
<p class="p">0:flush input buffer</p>
<p class="p">1:flush output buffer</p>
<p class="p">2:flush input &amp; output buffer *)</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_DTR(port, mode: Longint): Longint; stdcall; (* 设置DTR的线路状态。有两个参数，</p>
<p class="p">第一个是通讯端口号码，第二个设0时降低DTR电压，设1时升高DTR电压 *)</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_RTS(port, mode: Longint): Longint; stdcall; (* 设置RTS的线路状态。*)</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_lctrl(port, mode: Longint): Longint; stdcall; (* 同时设置DTR和RTS的线路状态.有两个参数，</p>
<p class="p">第一个是通讯端口号码，第二个是DTR和RTS的组合。*)</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_baud(port, speed: Longint): Longint; stdcall;</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_getch(port: Longint): Longint; stdcall; (* 自输入缓冲区中读取一个字符（实际是一个字节）。</p>
<p class="p">有一个参数，即通讯端口号。返回值介于0~255（ASCLL表上的最大数值）。*)</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_read(port: Longint; buf: PChar; len: Longint): Longint;
stdcall; (* 读取字符串。有三个参数，</p>
<p class="p">其中的一个是端口号；第二个是字节数组地址，用以存放接收到的字节数据；的三个是每一次所读取的数据</p>
<p class="p">长度（字节数）。*)</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_linput(port: Longint; buf:PChar; len: Longint; term:Longint):
Longint; stdcall;</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_putch(port, term: Longint): Longint; stdcall; (*将一个字符写到输出缓冲区。有两个参数，其一是</p>
<p class="p">端口号，第二是将传送出去的字节（数值0~255）。*)</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_putb(port: Longint; buf:PChar; len: Longint): Longint;
stdcall;</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_write(port: Longint; buf:PChar; len: Longint): Longint;
stdcall; (*输出字符串。有三个参数，</p>
<p class="p">第一个是端口号；第二是输出字符串的地址；第三是输出字符串的长度。*)</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_putb_x(port: Longint; buf:PChar; len: Longint; tick:Longint):
Longint; stdcall;</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_putb_x_ex(port: Longint; buf:PChar; len: Longint;
tms:Longint): Longint; stdcall;</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_lstatus(port: Longint): Longint; stdcall; (* 得到现在硬件线路的状态（DCD、CTS、DSR、RI）。</p>
<p class="p">参数只有一个，通讯端口号码；返回值由0位至第3位分别表示CTS、DSR、RI、CD四条线的状态。*)</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_iqueue(port: Longint): Longint; stdcall;</p>
<p class="p">function sio_oqueue(port: Longint): Longint; stdcall;</p>
<p class="p">function sio_Tx_hold(port: Longint): Longint; stdcall;</p>
<p class="p">function sio_getbaud(port: Longint): Longint; stdcall;</p>
<p class="p">function sio_getmode(port: Longint): Longint; stdcall;</p>
<p class="p">function sio_getflow(port: Longint): Longint; stdcall;</p>
<p class="p">function sio_data_status(port: Longint): Longint; stdcall;</p>
<p class="p">&nbsp;</p>
<p class="p">//事件触发函数</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_term_irq(port: Longint; func: IrqProc; code: Byte):
Longint; stdcall; (*当收到终止字符串时触发事件程序。</p>
<p class="p">有三个参数，1：端口号吗；2：函数地址；3：终止字符。*)</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_cnt_irq(port: Longint; func: IrqProc; count: Longint):
Longint; stdcall; (* 接收到固定字符时</p>
<p class="p">触发事件。使用手册特别说明必须将字符数设置为1，也就是一有字符进来就触发事件。有三个参数，</p>
<p class="p">1：通讯端口号码；2：函数地址；3：字符数。*)</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_modem_irq(port: Longint; func: IrqProc): Longint;
stdcall; (*当硬件线路的电压发生变化时</p>
<p class="p">触发事件，硬件线路包括DCD、DSR、CTS、RI这四个引线。有两个参数，1：端口号码；2：函数地址</p>
<p class="p">*)</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_break_irq(port: Longint; func: IrqProc): Longint;
stdcall; (*当接收到中断信号时，触发事件。</p>
<p class="p">有两个参数；1：端口号；2：函数地址。*)</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_Tx_empty_irq(port: Longint; func: IrqProc): Longint;
stdcall;(*当传送缓冲区全空时触发事件。</p>
<p class="p">有两个参数；1：端口号；2：函数地址。*)</p>
<p class="p">&nbsp;</p>
<p class="p">{PComm针对事件的处理是采用回调函数的方式处理，与建立事件，需给定一个函数的地址，当事件发生时，</p>
<p class="p">PComm变到该函数所在地址去执行该代码。}</p>
<p class="p">&nbsp;</p>
<p class="p">{传送给中断服务例程的函数的写法必须依照PCommm Pro的格式，在上面所提到的这些需传送地址的函数中，其参数均是</p>
<p class="p">通讯端口号码，而内容则由工程师自由发挥。 上述的事件中，最有用的是sio_cnt_irq及sio_modem_irq这两个中断</p>
<p class="p">函数。}</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_break(port, time: Longint): Longint; stdcall;</p>
<p class="p">function sio_view(port: Longint; buf: PChar; len: Longint): Longint;
stdcall;</p>
<p class="p">function sio_TxLowWater(port, size: Longint): Longint; stdcall;</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_AbortWrite(port: Longint): Longint; stdcall; (*终止输出的动作。有一个参数，即通讯端口号码*)</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_AbortRead(port: Longint): Longint; stdcall; (*中断字符或字符串的读取。有一个参数，端口号*)</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_SetWriteTimeouts(port, timeouts: Longint): Longint;
stdcall;</p>
<p class="p">function sio_GetWriteTimeouts(port: Longint; var TotalTimeouts:Longint):
Longint; stdcall;</p>
<p class="p">function sio_SetReadTimeouts(port, TotalTimeouts, IntervalTimeouts:
Longint): Longint; stdcall;</p>
<p class="p">function sio_GetReadTimeouts(port: Longint; var TotalTimeouts,
IntervalTimeouts: Longint): Longint; stdcall;</p>
<p class="p">&nbsp;</p>
<p class="p">//文件传输函数</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_FtASCIITx(port:Longint; fname:PChar; func:CallBackProc;
key:Longint): Longint; stdcall;</p>
<p class="p">{使用ASCII协议传送文件。参数4个：第一个是端口号码；第二个是传送的文件名；第三个是回调函数，用来指明传输的</p>
<p class="p">相关状态；第四个是用户定义的取消快速键}</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_FtASCIIRx(port:Longint; fname:PChar; func:CallBackProc;
key:Longint; sec:Longint): Longint; stdcall;</p>
<p class="p">{使用ASCII协议接收文件。参数5个，第一个是端口号码；第二个是文件名称；第三个是回调函数，用来指明传输的</p>
<p class="p">相关状态；第四个是用户定义的取消快速键；第五个是以秒计的超时时间}</p>
<p class="p">&nbsp;</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_FtXmodemCheckSumTx(port:Longint; fname:PChar; func:CallBackProc;
key:Longint): Longint; stdcall;</p>
<p class="p">{使用XMODEM，Checksum协议传送文件。有四个参数：第一个是端口号；第二个是文件名；第三个是回调函数；</p>
<p class="p">第四个是用户定义的取消快速键}</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_FtXmodemCheckSumRx(port:Longint; fname:PChar; func:CallBackProc;
key:Longint): Longint; stdcall;</p>
<p class="p">{使用XMODEM，Checksum协议接收文件。有四个参数：第一个是端口号；第二个是文件名；第三个是回调函数；</p>
<p class="p">第四个是用户定义的取消快速键}</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_FtXmodemCRCTx(port:Longint; fname:PChar; func:CallBackProc;
key:Longint): Longint; stdcall;</p>
<p class="p">{使用XMODEM，CRC协议传送文件。有四个参数：第一个是端口号；第二个是文件名；第三个是回调函数；</p>
<p class="p">第四个是用户定义的取消快速键}</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_FtXmodemCRCRx(port:Longint; fname:PChar; func:CallBackProc;
key:Longint): Longint; stdcall;</p>
<p class="p">{使用XMODEM，CRC协议接收文件。有四个参数：第一个是端口号；第二个是文件名；第三个是回调函数；</p>
<p class="p">第四个是用户定义的取消快速键}</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_FtXmodem1KCRCTx(port:Longint; fname:PChar; func:CallBackProc;
key:Longint): Longint; stdcall;</p>
<p class="p">{使用XMODEM，1K CRC协议传送文件。有四个参数：第一个是端口号；第二个是文件名；第三个是回调函数；</p>
<p class="p">第四个是用户定义的取消快速键}</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_FtXmodem1KCRCRx(port:Longint; fname:PChar; func:CallBackProc;
key:Longint): Longint; stdcall;</p>
<p class="p">{使用XMODEM，1K CRC协议接收文件。有四个参数：第一个是端口号；第二个是文件名；第三个是回调函数；</p>
<p class="p">第四个是用户定义的取消快速键}</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_FtYmodemTx(port:Longint; fname:PChar; func:CallBackProc;
key:Longint): Longint; stdcall;</p>
<p class="p">{使用YXMODEM协议传送文件。有4个参数：第一个是端口号；第二个是文件名；第三个是回调函数；</p>
<p class="p">第四个是用户定义的取消快速键}</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_FtYmodemRx(port:Longint; var fname:PChar;fno:LongInt;func:CallBackProc;
key:Longint): Longint; stdcall;</p>
<p class="p">{使用YXMODEM协议接收文件。有5个参数：第一个是端口号；第二个是文件数据数组地址；第三个是可接收的最多文件数；</p>
<p class="p">第四个是回调函数；第五个是用户定义的取消快速键}</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_FtZmodemTx(port:Longint; fname:PChar; func:CallBackProc;
key:Longint): Longint; stdcall;</p>
<p class="p">{使用ZXMODEM协议传送文件。有4个参数：第一个是端口号；第二个是文件名；第三个是回调函数；</p>
<p class="p">第四个是用户定义的取消快速键}</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_FtZmodemRx(port:Longint; var fname:PChar;fno:LongInt;func:CallBackProc;
key:Longint): Longint; stdcall;</p>
<p class="p">{使用ZXMODEM协议接收文件。有5个参数：第一个是端口号；第二个是文件数据数组地址；第三个是可接收的最多文件数；</p>
<p class="p">第四个是回调函数；第五个是用户定义的取消快速键}</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_FtKermitTx(port:Longint; fname:PChar; func:CallBackProc;
key:Longint): Longint; stdcall;</p>
<p class="p">{使用Kermit协议传送文件。有4个参数：第一个是端口号；第二个是文件名；第三个是回调函数；</p>
<p class="p">第四个是用户定义的取消快速键}</p>
<p class="p">&nbsp;</p>
<p class="p">function sio_FtKermitRx(port:Longint; var fname:PChar;fno:LongInt;func:CallBackProc;
key:Longint): Longint; stdcall;</p>
<p class="p">{使用Kermit协议接收文件。有5个参数：第一个是端口号；第二个是文件数据数组地址；第三个是可接收的最多文件数；</p>
<p class="p">第四个是回调函数；第五个是用户定义的取消快速键}</p>
<p class="p">&nbsp;</p>
<p class="p">&nbsp;</p>
<p class="p">implementation</p>
<p class="p">function sio_open; external 'PComm.dll';</p>
<p class="p">function sio_close; external 'PComm.dll';</p>
<p class="p">function sio_ioctl; external 'PComm.dll';</p>
<p class="p">function sio_flowctrl; external 'PComm.dll';</p>
<p class="p">function sio_flush; external 'PComm.dll';</p>
<p class="p">function sio_DTR; external 'PComm.dll';</p>
<p class="p">function sio_RTS; external 'PComm.dll';</p>
<p class="p">function sio_lctrl; external 'PComm.dll';</p>
<p class="p">function sio_baud; external 'PComm.dll';</p>
<p class="p">function sio_getch; external 'PComm.dll';</p>
<p class="p">function sio_read; external 'PComm.dll';</p>
<p class="p">function sio_linput; external 'PComm.dll';</p>
<p class="p">function sio_putch; external 'PComm.dll';</p>
<p class="p">function sio_putb; external 'PComm.dll';</p>
<p class="p">function sio_write; external 'PComm.dll';</p>
<p class="p">function sio_putb_x; external 'PComm.dll';</p>
<p class="p">function sio_putb_x_ex; external 'PComm.dll';</p>
<p class="p">function sio_lstatus; external 'PComm.dll';</p>
<p class="p">function sio_iqueue; external 'PComm.dll';</p>
<p class="p">function sio_oqueue; external 'PComm.dll';</p>
<p class="p">function sio_Tx_hold; external 'PComm.dll';</p>
<p class="p">function sio_getbaud; external 'PComm.dll';</p>
<p class="p">function sio_getmode; external 'PComm.dll';</p>
<p class="p">function sio_getflow; external 'PComm.dll';</p>
<p class="p">function sio_data_status; external 'PComm.dll';</p>
<p class="p">function sio_term_irq; external 'PComm.dll';</p>
<p class="p">function sio_cnt_irq; external 'PComm.dll';</p>
<p class="p">function sio_modem_irq; external 'PComm.dll';</p>
<p class="p">function sio_break_irq; external 'PComm.dll';</p>
<p class="p">function sio_Tx_empty_irq; external 'PComm.dll';</p>
<p class="p">function sio_break; external 'PComm.dll';</p>
<p class="p">function sio_view; external 'PComm.dll';</p>
<p class="p">function sio_TxLowWater; external 'PComm.dll';</p>
<p class="p">function sio_AbortWrite; external 'PComm.dll';</p>
<p class="p">function sio_AbortRead; external 'PComm.dll';</p>
<p class="p">function sio_SetWriteTimeouts; external 'PComm.dll';</p>
<p class="p">function sio_GetWriteTimeouts; external 'PComm.dll';</p>
<p class="p">function sio_SetReadTimeouts; external 'PComm.dll';</p>
<p class="p">function sio_GetReadTimeouts; external 'PComm.dll';</p>
<p class="p">function sio_FtASCIITx; external 'PComm.dll';</p>
<p class="p">function sio_FtASCIIRx; external 'PComm.dll';</p>
<p class="p">function sio_FtXmodemCheckSumTx; external 'PComm.dll';</p>
<p class="p">function sio_FtXmodemCheckSumRx; external 'PComm.dll';</p>
<p class="p">function sio_FtXmodemCRCTx; external 'PComm.dll';</p>
<p class="p">function sio_FtXmodemCRCRx; external 'PComm.dll';</p>
<p class="p">function sio_FtXmodem1KCRCTx; external 'PComm.dll';</p>
<p class="p">function sio_FtXmodem1KCRCRx; external 'PComm.dll';</p>
<p class="p">function sio_FtYmodemTx; external 'PComm.dll';</p>
<p class="p">function sio_FtYmodemRx; external 'PComm.dll';</p>
<p class="p">function sio_FtZmodemTx; external 'PComm.dll';</p>
<p class="p">function sio_FtZmodemRx; external 'PComm.dll';</p>
<p class="p">function sio_FtKermitTx; external 'PComm.dll';</p>
<p class="p">function sio_FtKermitRx; external 'PComm.dll';</p>
<p class="p">&nbsp;</p>
<p class="p">end.</p>
<p class="p">&nbsp;</p>
<p class="p">；==========</p>
<p class="p">数字输入/输出控制例程：</p>
<p class="p">unit Unit1;</p>
<p class="p">&nbsp;</p>
<p class="p">interface</p>
<p class="p">&nbsp;</p>
<p class="p">uses</p>
<p class="p">Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms,
Dialogs,</p>
<p class="p">StdCtrls, ExtCtrls;</p>
<p class="p">&nbsp;</p>
<p class="p">type</p>
<p class="p">TForm1 = class(TForm)</p>
<p class="p">rdCOM: TRadioGroup;</p>
<p class="p">Label1: TLabel;</p>
<p class="p">Label2: TLabel;</p>
<p class="p">btnOpenPort: TButton;</p>
<p class="p">btnEnd: TButton;</p>
<p class="p">spCD: TShape;</p>
<p class="p">spDSR: TShape;</p>
<p class="p">spCTS: TShape;</p>
<p class="p">Label3: TLabel;</p>
<p class="p">Label4: TLabel;</p>
<p class="p">spRI: TShape;</p>
<p class="p">Timer1: TTimer;</p>
<p class="p">spDTR: TShape;</p>
<p class="p">Label5: TLabel;</p>
<p class="p">Label6: TLabel;</p>
<p class="p">spRTS: TShape;</p>
<p class="p">btnDTR: TButton;</p>
<p class="p">btnRTS: TButton;</p>
<p class="p">procedure btnOpenPortClick(Sender: TObject);</p>
<p class="p">procedure btnEndClick(Sender: TObject);</p>
<p class="p">procedure Timer1Timer(Sender: TObject);</p>
<p class="p">procedure btnDTRClick(Sender: TObject);</p>
<p class="p">procedure btnRTSClick(Sender: TObject);</p>
<p class="p">private</p>
<p class="p">&nbsp;</p>
<p class="p">public</p>
<p class="p">{ Public declarations }</p>
<p class="p">end;</p>
<p class="p">&nbsp;</p>
<p class="p">var</p>
<p class="p">Form1: TForm1;</p>
<p class="p">DTRMode,RTSMode,Port:Integer;</p>
<p class="p">Function PortSet():Boolean;</p>
<p class="p">implementation</p>
<p class="p">uses PComm,MxTool,EXGLOBAL; //PCOmm引用声明放于此</p>
<p class="p">{$R *.DFM}</p>
<p class="p">&nbsp;</p>
<p class="p">//以下是打开通信端口的程序</p>
<p class="p">procedure TForm1.btnOpenPortClick(Sender: TObject);</p>
<p class="p">var</p>
<p class="p">Ret:Integer;</p>
<p class="p">begin</p>
<p class="p">//打开通信端口</p>
<p class="p">Port := rdCom.ItemIndex+1; //指定通信端口</p>
<p class="p">Ret := sio_Open(Port);</p>
<p class="p">If ret &lt;&gt; SIO_OK Then</p>
<p class="p">begin</p>
<p class="p">ShowMessage('打开通信端口错误');</p>
<p class="p">sio_close (Port);</p>
<p class="p">Exit;</p>
<p class="p">end;</p>
<p class="p">If Not PortSet() Then //参数设置</p>
<p class="p">begin</p>
<p class="p">sio_close(Port);</p>
<p class="p">ShowMessage('通信端口参数设置发生错误');</p>
<p class="p">Exit;</p>
<p class="p">End;</p>
<p class="p">//降低DTR及RTS的电压</p>
<p class="p">ret := sio_DTR(Port, 0);</p>
<p class="p">ret := sio_RTS(Port, 0);</p>
<p class="p">//激活定时器</p>
<p class="p">Timer1.Enabled := True;</p>
<p class="p">end;</p>
<p class="p">&nbsp;</p>
<p class="p">&nbsp;</p>
<p class="p">//以下是结束按钮的动作</p>
<p class="p">procedure TForm1.btnEndClick(Sender: TObject);</p>
<p class="p">begin</p>
<p class="p">//关闭通信端口</p>
<p class="p">sio_Close(Port);</p>
<p class="p">//结束程序</p>
<p class="p">close;</p>
<p class="p">end;</p>
<p class="p">&nbsp;</p>
<p class="p">procedure TForm1.Timer1Timer(Sender: TObject);</p>
<p class="p">var</p>
<p class="p">Ret:Integer;</p>
<p class="p">begin</p>
<p class="p">ret := sio_lstatus(Port);//读取状态</p>
<p class="p">If ret &lt; 0 Then</p>
<p class="p">begin</p>
<p class="p">ShowMessage('状态错误');</p>
<p class="p">Timer1.Enabled := False;</p>
<p class="p">end </p>
<p class="p">Else</p>
<p class="p">begin</p>
<p class="p">//各线路状态检查</p>
<p class="p">If (ret And S_DSR) &gt; 0 Then</p>
<p class="p">spDSR.Brush.Color := clRed</p>
<p class="p">Else</p>
<p class="p">spDSR.Brush.Color := clWhite;</p>
<p class="p">&nbsp;</p>
<p class="p">If (ret And S_CD) &gt; 0 Then</p>
<p class="p">spCD.Brush.Color := clRed</p>
<p class="p">Else</p>
<p class="p">spCD.Brush.Color := clWhite;</p>
<p class="p">&nbsp;</p>
<p class="p">If (ret And S_RI) &gt; 0 Then</p>
<p class="p">spRI.Brush.Color := clRed</p>
<p class="p">Else</p>
<p class="p">spRI.Brush.Color := clWhite;</p>
<p class="p">&nbsp;</p>
<p class="p">If (ret And S_CTS) &gt; 0 Then</p>
<p class="p">spCTS.Brush.Color := clRed</p>
<p class="p">Else</p>
<p class="p">spCTS.Brush.Color := clWhite;</p>
<p class="p">End;</p>
<p class="p">&nbsp;</p>
<p class="p">end;</p>
<p class="p">&nbsp;</p>
<p class="p">procedure TForm1.btnDTRClick(Sender: TObject);</p>
<p class="p">var</p>
<p class="p">ret:Integer;</p>
<p class="p">begin</p>
<p class="p">//计算DTR线路状态</p>
<p class="p">DTRMode := (DTRMode + 1) Mod 2 ;</p>
<p class="p">If DTRMode = 1 Then</p>
<p class="p">spDTR.Brush.Color:=clRed</p>
<p class="p">Else</p>
<p class="p">spDTR.Brush.Color:=clWhite;</p>
<p class="p">//控制DTR线路状态</p>
<p class="p">ret := sio_DTR(Port, DTRMode);</p>
<p class="p">If ret &lt;&gt; SIO_OK Then</p>
<p class="p">begin</p>
<p class="p">ShowMessage('DTR控制错误');</p>
<p class="p">Exit;</p>
<p class="p">end;</p>
<p class="p">end;</p>
<p class="p">&nbsp;</p>
<p class="p">procedure TForm1.btnRTSClick(Sender: TObject);</p>
<p class="p">var</p>
<p class="p">ret:Integer;</p>
<p class="p">begin</p>
<p class="p">//计算RTS状态</p>
<p class="p">RTSMode := (RTSMode + 1) Mod 2 ;</p>
<p class="p">If RTSMode = 1 Then</p>
<p class="p">spRTS.Brush.Color:=clRed</p>
<p class="p">Else</p>
<p class="p">spRTS.Brush.Color:=clWhite;</p>
<p class="p">//控制RTS状态</p>
<p class="p">ret := sio_RTS(Port, RTSMode);</p>
<p class="p">If ret &lt;&gt; SIO_OK Then</p>
<p class="p">begin</p>
<p class="p">ShowMessage('RTS控制错误');</p>
<p class="p">Exit;</p>
<p class="p">end;</p>
<p class="p">end;</p>
<p class="p">&nbsp;</p>
<p class="p">//以下是通信参数的函数实现</p>
<p class="p">Function PortSet():Boolean;</p>
<p class="p">var</p>
<p class="p">mode,Hw,Sw,ret,tout:LongInt;</p>
<p class="p">begin</p>
<p class="p">//参数设置子程序</p>
<p class="p">mode := P_NONE Or BIT_8 Or STOP_1;</p>
<p class="p">Hw := 0 ; //没有硬件流量控制</p>
<p class="p">Sw := 0 ; //没有软件流量控制</p>
<p class="p">Result := False ;</p>
<p class="p">ret := sio_ioctl(Port, B38400, mode); //Setting</p>
<p class="p">If ret &lt;&gt; SIO_OK Then</p>
<p class="p">begin</p>
<p class="p">ShowMessage('设置时发生错误');</p>
<p class="p">Exit;</p>
<p class="p">end;</p>
<p class="p">ret := sio_flowctrl(Port, Hw or Sw); //Flow Control</p>
<p class="p">If ret &lt;&gt; SIO_OK Then</p>
<p class="p">begin</p>
<p class="p">ShowMessage('流量设置时发生错误');</p>
<p class="p">Exit;</p>
<p class="p">end;</p>
<p class="p">Result := True;</p>
<p class="p">End;</p>
<p class="p">end.</p>
<p class="p">&nbsp;</p>
<p class="p">；==========</p>
<p class="p">数据的传送例程：</p>
<p class="p">unit Unit1;</p>
<p class="p">&nbsp;</p>
<p class="p">interface</p>
<p class="p">&nbsp;</p>
<p class="p">uses</p>
<p class="p">Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms,
Dialogs,</p>
<p class="p">StdCtrls, ExtCtrls;</p>
<p class="p">&nbsp;</p>
<p class="p">type</p>
<p class="p">TForm1 = class(TForm)</p>
<p class="p">rdCOM: TRadioGroup;</p>
<p class="p">btnOpenPort: TButton;</p>
<p class="p">btnEnd: TButton;</p>
<p class="p">btnSend: TButton;</p>
<p class="p">btnReceive: TButton;</p>
<p class="p">mSend: TMemo;</p>
<p class="p">mReceive: TMemo;</p>
<p class="p">procedure btnOpenPortClick(Sender: TObject);</p>
<p class="p">procedure btnEndClick(Sender: TObject);</p>
<p class="p">procedure btnSendClick(Sender: TObject);</p>
<p class="p">procedure btnReceiveClick(Sender: TObject);</p>
<p class="p">private</p>
<p class="p">&nbsp;</p>
<p class="p">public</p>
<p class="p">{ Public declarations }</p>
<p class="p">end;</p>
<p class="p">&nbsp;</p>
<p class="p">var</p>
<p class="p">Form1: TForm1;</p>
<p class="p">DTRMode,RTSMode,Port:Integer;</p>
<p class="p">Function PortSet():Boolean;</p>
<p class="p">implementation</p>
<p class="p">uses PComm,MxTool,EXGLOBAL; //PCOmm引用声明放于此</p>
<p class="p">{$R *.DFM}</p>
<p class="p">&nbsp;</p>
<p class="p">//以下是打开通信端口的程序</p>
<p class="p">procedure TForm1.btnOpenPortClick(Sender: TObject);</p>
<p class="p">var</p>
<p class="p">Ret:Integer;</p>
<p class="p">begin</p>
<p class="p">//打开通信端口</p>
<p class="p">Port := rdCom.ItemIndex+1; //指定通信端口</p>
<p class="p">Ret := sio_Open(Port);</p>
<p class="p">If ret &lt;&gt; SIO_OK Then</p>
<p class="p">begin</p>
<p class="p">ShowMessage('打开通信端口错误');</p>
<p class="p">sio_close (Port);</p>
<p class="p">Exit;</p>
<p class="p">end;</p>
<p class="p">If Not PortSet() Then //参数设置</p>
<p class="p">begin</p>
<p class="p">sio_close(Port);</p>
<p class="p">ShowMessage('通信端口参数设置发生错误');</p>
<p class="p">Exit;</p>
<p class="p">End;</p>
<p class="p">//降低DTR及RTS的电压</p>
<p class="p">ret := sio_DTR(Port, 0);</p>
<p class="p">ret := sio_RTS(Port, 0);</p>
<p class="p">end;</p>
<p class="p">&nbsp;</p>
<p class="p">&nbsp;</p>
<p class="p">//以下是结束按钮的动作</p>
<p class="p">procedure TForm1.btnEndClick(Sender: TObject);</p>
<p class="p">begin</p>
<p class="p">//关闭通信端口</p>
<p class="p">sio_Close(Port);</p>
<p class="p">//结束程序</p>
<p class="p">close;</p>
<p class="p">end;</p>
<p class="p">&nbsp;</p>
<p class="p">procedure TForm1.btnSendClick(Sender: TObject);</p>
<p class="p">var</p>
<p class="p">TxtStr:String;</p>
<p class="p">begin</p>
<p class="p">//输出字符串指定</p>
<p class="p">TxtStr := mSend.Text;</p>
<p class="p">//把Pascal字符串转成C字符串后送出</p>
<p class="p">sio_write(Port, PChar(TxtStr), Length(TxtStr))</p>
<p class="p">end;</p>
<p class="p">&nbsp;</p>
<p class="p">procedure TForm1.btnReceiveClick(Sender: TObject);</p>
<p class="p">var</p>
<p class="p">rLen:LongInt;</p>
<p class="p">PBuf:PChar;</p>
<p class="p">Buf:String;</p>
<p class="p">begin</p>
<p class="p">//给一个空间存数据，一定要有</p>
<p class="p">PBuf := PChar(StringOfChar(' ',1024));</p>
<p class="p">rlen := sio_read(Port,PBuf , 1024); //读取数据</p>
<p class="p">If rlen = 0 Then Exit; //若无数据则跳出</p>
<p class="p">Buf := StrPas(PBuf);</p>
<p class="p">Buf := Copy(Buf,1,rlen);</p>
<p class="p">//将数据显示在Memo中</p>
<p class="p">mReceive.Text := mReceive.Text + Buf;</p>
<p class="p">mReceive.SelStart := Length(mReceive.Text);</p>
<p class="p">mReceive.SelLength := 0;</p>
<p class="p">end;</p>
<p class="p">&nbsp;</p>
<p class="p">//以下是通信参数的函数实现</p>
<p class="p">Function PortSet():Boolean;</p>
<p class="p">var</p>
<p class="p">mode,Hw,Sw,ret:LongInt;</p>
<p class="p">begin</p>
<p class="p">//参数设置子程序</p>
<p class="p">mode := P_NONE Or BIT_8 Or STOP_1;</p>
<p class="p">Hw := 0 ; //没有硬件流量控制</p>
<p class="p">Sw := 0 ; //没有软件流量控制</p>
<p class="p">Result := False ;</p>
<p class="p">ret := sio_ioctl(Port, B38400, mode); //Setting</p>
<p class="p">If ret &lt;&gt; SIO_OK Then</p>
<p class="p">begin</p>
<p class="p">ShowMessage('设置时发生错误');</p>
<p class="p">Exit;</p>
<p class="p">end;</p>
<p class="p">ret := sio_flowctrl(Port, Hw or Sw); //Flow Control</p>
<p class="p">If ret &lt;&gt; SIO_OK Then</p>
<p class="p">begin</p>
<p class="p">ShowMessage('流量设置时发生错误');</p>
<p class="p">Exit;</p>
<p class="p">end;</p>
<p class="p">Result := True;</p>
<p class="p">End;</p>
<p class="p">end.</p>
<p class="p">&nbsp;</p>
<p class="p">；==========</p>
<p class="p">事件触发例程：</p>
<p class="p">unit Unit1;</p>
<p class="p">&nbsp;</p>
<p class="p">interface</p>
<p class="p">&nbsp;</p>
<p class="p">uses</p>
<p class="p">Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms,
Dialogs,</p>
<p class="p">StdCtrls, ExtCtrls;</p>
<p class="p">&nbsp;</p>
<p class="p">type</p>
<p class="p">TForm1 = class(TForm)</p>
<p class="p">rdCOM: TRadioGroup;</p>
<p class="p">Label1: TLabel;</p>
<p class="p">Label2: TLabel;</p>
<p class="p">btnOpenPort: TButton;</p>
<p class="p">btnEnd: TButton;</p>
<p class="p">spCD: TShape;</p>
<p class="p">spDSR: TShape;</p>
<p class="p">spCTS: TShape;</p>
<p class="p">Label3: TLabel;</p>
<p class="p">Label4: TLabel;</p>
<p class="p">spRI: TShape;</p>
<p class="p">mSend: TMemo;</p>
<p class="p">mReceive: TMemo;</p>
<p class="p">Label5: TLabel;</p>
<p class="p">Label6: TLabel;</p>
<p class="p">procedure btnOpenPortClick(Sender: TObject);</p>
<p class="p">procedure btnEndClick(Sender: TObject);</p>
<p class="p">Function PortSet():Boolean;</p>
<p class="p">Procedure ClearIrq();</p>
<p class="p">Function InitIrq():Boolean;</p>
<p class="p">procedure mSendKeyPress(Sender: TObject; var Key: Char);</p>
<p class="p">private</p>
<p class="p">&nbsp;</p>
<p class="p">public</p>
<p class="p">{ Public declarations }</p>
<p class="p">end;</p>
<p class="p">&nbsp;</p>
<p class="p">var</p>
<p class="p">Form1: TForm1;</p>
<p class="p">DTRMode,RTSMode,Port:Integer;</p>
<p class="p">Procedure CntIrq(iPort:LongInt);stdcall;</p>
<p class="p">Procedure ModemIrq(iPort:LongInt);stdcall;</p>
<p class="p">&nbsp;</p>
<p class="p">implementation</p>
<p class="p">uses PComm,MxTool,EXGLOBAL; //PCOmm引用声明放于此</p>
<p class="p">{$R *.DFM}</p>
<p class="p">&nbsp;</p>
<p class="p">//以下是打开通信端口的程序</p>
<p class="p">procedure TForm1.btnOpenPortClick(Sender: TObject);</p>
<p class="p">var</p>
<p class="p">Ret:Integer;</p>
<p class="p">begin</p>
<p class="p">//打开通信端口</p>
<p class="p">Port := rdCom.ItemIndex+1; //指定通信端口</p>
<p class="p">Ret := sio_Open(Port);</p>
<p class="p">If ret &lt;&gt; SIO_OK Then</p>
<p class="p">begin</p>
<p class="p">ShowMessage('打开通信端口错误');</p>
<p class="p">sio_close (Port);</p>
<p class="p">Exit;</p>
<p class="p">end;</p>
<p class="p">If Not PortSet() Then //参数设置</p>
<p class="p">begin</p>
<p class="p">sio_close(Port);</p>
<p class="p">ShowMessage('通信端口参数设置发生错误');</p>
<p class="p">Exit;</p>
<p class="p">End;</p>
<p class="p">//降低DTR及RTS的电压</p>
<p class="p">ret := sio_DTR(Port, 0);</p>
<p class="p">ret := sio_RTS(Port, 0);</p>
<p class="p">//设置中断</p>
<p class="p">if not InitIrq then</p>
<p class="p">begin</p>
<p class="p">sio_close(Port);</p>
<p class="p">ShowMessage('通信端口参数设置发生错误');</p>
<p class="p">Exit;</p>
<p class="p">end;</p>
<p class="p">end;</p>
<p class="p">&nbsp;</p>
<p class="p">//以下是结束按钮的动作</p>
<p class="p">procedure TForm1.btnEndClick(Sender: TObject);</p>
<p class="p">begin</p>
<p class="p">//关闭通信端口</p>
<p class="p">ClearIrq;</p>
<p class="p">sio_Close(Port);</p>
<p class="p">//结束程序</p>
<p class="p">close;</p>
<p class="p">end;</p>
<p class="p">&nbsp;</p>
<p class="p">//以下是通信参数的函数实现</p>
<p class="p">Function TForm1.PortSet():Boolean;</p>
<p class="p">var</p>
<p class="p">mode,Hw,Sw,ret:LongInt;</p>
<p class="p">begin</p>
<p class="p">//参数设置子程序</p>
<p class="p">mode := P_NONE Or BIT_8 Or STOP_1;</p>
<p class="p">Hw := 0 ; //没有硬件流量控制</p>
<p class="p">Sw := 0 ; //没有软件流量控制</p>
<p class="p">Result := False ;</p>
<p class="p">ret := sio_ioctl(Port, B38400, mode); //Setting</p>
<p class="p">If ret &lt;&gt; SIO_OK Then</p>
<p class="p">begin</p>
<p class="p">ShowMessage('设置时发生错误');</p>
<p class="p">Exit;</p>
<p class="p">end;</p>
<p class="p">//设置流量控制</p>
<p class="p">ret := sio_flowctrl(Port, Hw or Sw); //Flow Control</p>
<p class="p">If ret &lt;&gt; SIO_OK Then</p>
<p class="p">begin</p>
<p class="p">ShowMessage('流量设置时发生错误');</p>
<p class="p">Exit;</p>
<p class="p">end;</p>
<p class="p">Result := True;</p>
<p class="p">End;</p>
<p class="p">&nbsp;</p>
<p class="p">//准备被调用的回调函数，此函数必须独立，不可放进窗体</p>
<p class="p">//此函数用来接收它方所传送过来的数据</p>
<p class="p">Procedure CntIrq(iPort:LongInt);stdcall;</p>
<p class="p">var</p>
<p class="p">rLen:LongInt;</p>
<p class="p">PBuf:PChar;</p>
<p class="p">Buf:String;</p>
<p class="p">begin</p>
<p class="p">//给一个空间存数据，一定要有</p>
<p class="p">PBuf := PChar(StringOfChar(' ',1024));</p>
<p class="p">rlen := sio_read(iPort,PBuf , 1024); //读取数据</p>
<p class="p">If rlen = 0 Then Exit; //若无数据则跳出</p>
<p class="p">Buf := StrPas(PBuf);</p>
<p class="p">Buf := Copy(Buf,1,rlen);</p>
<p class="p">//将数据显示在Memo中，并将光标拉至最低处</p>
<p class="p">Form1.mReceive.Text := Form1.mReceive.Text + Buf;</p>
<p class="p">Form1.mReceive.SelStart := Length(Form1.mReceive.Text);</p>
<p class="p">Form1.mReceive.SelLength := 0;</p>
<p class="p">end;</p>
<p class="p">&nbsp;</p>
<p class="p">//准备被调用的回调函数，此函数必须独立，不可放进窗体</p>
<p class="p">//此函数用来检测硬件线路状态</p>
<p class="p">Procedure ModemIrq(iPort:LongInt);stdcall;</p>
<p class="p">var</p>
<p class="p">ret:integer;</p>
<p class="p">begin</p>
<p class="p">ret := sio_lstatus(iPort); //读取状态</p>
<p class="p">If ret &lt; 0 Then</p>
<p class="p">ShowMessage('状态错误')</p>
<p class="p">Else</p>
<p class="p">//以下依状况改变灯号的颜色</p>
<p class="p">begin</p>
<p class="p">If (ret And S_DSR) &gt; 0 Then</p>
<p class="p">Form1.spDSR.Brush.Color := clRed</p>
<p class="p">Else</p>
<p class="p">Form1.spDSR.Brush.Color := clWhite;</p>
<p class="p">&nbsp;</p>
<p class="p">If (ret And S_CD) &gt; 0 Then</p>
<p class="p">Form1.spCD.Brush.Color := clRed</p>
<p class="p">Else</p>
<p class="p">Form1.spCD.Brush.Color := clWhite;</p>
<p class="p">&nbsp;</p>
<p class="p">If (ret And S_RI) &gt; 0 Then</p>
<p class="p">Form1.spRI.Brush.Color := clRed</p>
<p class="p">Else</p>
<p class="p">Form1.spRI.Brush.Color := clWhite;</p>
<p class="p">&nbsp;</p>
<p class="p">If (ret And S_CTS) &gt; 0 Then</p>
<p class="p">Form1.spCTS.Brush.Color := clRed</p>
<p class="p">Else</p>
<p class="p">Form1.spCTS.Brush.Color := clWhite;</p>
<p class="p">&nbsp;</p>
<p class="p">End ;</p>
<p class="p">End ;</p>
<p class="p">&nbsp;</p>
<p class="p">//中断的初始化函数</p>
<p class="p">//在此指定了Count的中断及硬件线路的中断</p>
<p class="p">Function TForm1.InitIrq():Boolean;</p>
<p class="p">var</p>
<p class="p">ret:LongInt;</p>
<p class="p">begin</p>
<p class="p">Result := False;</p>
<p class="p">ret := sio_cnt_irq(Port, CntIrq, 1); //指定接收事件中断</p>
<p class="p">If ret &lt;&gt; SIO_OK Then</p>
<p class="p">begin</p>
<p class="p">ShowMessage('事件设置时发生错误-cntIrq');</p>
<p class="p">Exit;</p>
<p class="p">End;</p>
<p class="p">ret := sio_modem_irq(Port, ModemIrq); //指定硬件线路中断</p>
<p class="p">If ret &lt;&gt; SIO_OK Then</p>
<p class="p">begin</p>
<p class="p">ShowMessage('事件设置时发生错误-ModemIrq');</p>
<p class="p">Exit;</p>
<p class="p">End;</p>
<p class="p">Result := True</p>
<p class="p">End ;</p>
<p class="p">&nbsp;</p>
<p class="p">//中断的清除</p>
<p class="p">//将原先设置的中断全部清除掉</p>
<p class="p">Procedure TForm1.ClearIrq();</p>
<p class="p">var</p>
<p class="p">ret:LongInt;</p>
<p class="p">begin</p>
<p class="p">sio_cnt_irq(Port, nil, 0);</p>
<p class="p">sio_modem_irq(Port,nil);</p>
<p class="p">End;</p>
<p class="p">&nbsp;</p>
<p class="p">&nbsp;</p>
<p class="p">//将输入的字符送出</p>
<p class="p">procedure TForm1.mSendKeyPress(Sender: TObject; var Key: Char);</p>
<p class="p">begin</p>
<p class="p">//送出字符</p>
<p class="p">sio_putch(Port,Ord(Key));</p>
<p class="p">end;</p>
<p class="p">&nbsp;</p>
<p class="p">end.</p>
<p class="p">&nbsp;</p>
</div>
<nav role="navigation" class="related-links"><div class="familylinks"><div class="parentlink"><strong>父主题：</strong> <a class="link" href="Pcomm%E4%B8%B2%E5%8F%A3%E5%BA%93.html">Pcomm串口库</a></div></div></nav></article></main></body></html>