<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"be8a006acc9da5850807f4a79f543bfe579b1e3672573f212e613ee5ba4a07adda3c36a7324822cd20a5d560837c32110422ebf4d966106a82ff7b4a5ad468e5d35903d2b5bf6afaffbfd20338f02dab035f28f1ef2ba768f9396795d06ca7864d91d2a07b670608f839508cc5d2daae58e1bcfae7eacce3aec683594ddc6ca579924d1e702512ba4a302c765dadfe2b728a29727589ae16d29598bece3eb38d7a4ef022d79fbea50589b19cb2a2a9af3a3b5c6264d2b073ebc98f0fb2d6a89772d419dbf89396bdbdd82e097cc36e5f0034df7b36ff390e3178bac4a6ae0e9a1e7c7f641bfe98c049a6038d22a8eedae1a825063fb587b2b8a154184aa4eb69f9e3f48b1930a654b759fb315eb4597f02e329b41ecb5c9594c7fc823b2d9900192e950d8415850715f8191cfd716b14f0bc364231a8347f25b047bb48e2f1a8988103a87e563d5b1cfafc2b183a8bb95f5c30eb3a4fd193ac84e988ad6935225ca26fcfb0999e9b351caa37fb9475b836da2b6427f5a55219e8ab1cf032fbee8c76acd5f8687f084638057c8888010e2ae9f6c6148780ea165bbd70473fa0c0dbe84d69391fa609c1dfc7066746170b08646c05ac6325e07089cd24329fa19e637013c1332c07407954fbb1575f737db72c7f12e6b603fa8974efd0e4ddf77c2f57244c870e36b91e17fd96b56b21e53c114909e72ea107fd77b30a0ed3aaee38dabc4f62b0c96034ef2b0f33698c9658857d014e2931a06828031ca3dbb79f9f5e8e9cb79e979c715cd451d0315fc1e601bb91adb8072ee5ce8cf1b31fe86a3059801851544f6193ce71b649ac4aacdb899e0bf236e3196fa01ee4319747170a32808fd306d72e933ab43dca6884db2a36b05aca1b12668a1a2057091055d0b6b69f56efacb452aeae86b02ab6149d74fb1924b91bf6588123c150147e391ca12a41652dac0282921115e99fe847f995ba3f1ced5263d7d95f7b5a35c6c0330bdcc736fb90336346247ccccf153399324ebcc8c45b3559344cd2c81c49864e2e699fca82e71e44998468fb8b752e0d75b65946c4d3e0933d6bad00ca1b2e77d7b4726513e35874695a82f8e7b3370b33797770678ecf0291832435fba02256e358d9abde3c4979d30c549d92da60b8a72fb03d5fa22b5796de87edbbb83bd89a384c5c68a1d8c79c1251b39e636f023b9eb9553285f78534d32b29b1a27a2001d51a991bbfc8387a0d19a1391224064614a7cbcfc30d5c3653a5d47702d25ad5508749541ba91bf38bae5ba220f41f5a6ef819da74f73e3d798ea8e258217cc8d49815776fedcd0b9d43884a83332d3d49c9c5e6ac02c0e69c3c14a633989c8b22051c62c132b36cb3900cdb792f4c1923986ba7f3683ceef6f8cbb0ff33a5e3118898b710babe52bf7f2d763db71a7dc6ef0025b57c19607fcb8d0019b576ead1d1646fa7582c4a178d555e0b51e9c07c0596fef5e9c07a0a1d4d17f7316ee1eeb7884ee5c43a4e5610972ce319ef60588e710d3b5e53ce863a8a7c5723fc72248e6cf9b33a04e05e5108c0a1550122ff0a60494efb251b4c023c4e001637994cf8ff94b36169e5887e68e0e6878eaf0b46b8f84c80c2ee093007f9390b0a7dc87994764f31616d33aead6bb287d0888d3eba5003cd8b9593d6ef13caf607427bbc91f58f6b92e8a4c9e1a4329c572871f42cb3625ef36452b614bbe207ea743cf75cfcc2d75f73d3b26dadde8afe06bf01c1fc2d95ef486f4b40a2d9a0d1344e793836c12b6365013e99e157d2613fa82c561b9a0f766ebf022a2238cc7f993600738f0e31b7ba08075d139a62d02fa6bf39a88806372df5d0a7ed623ac0c47f2648a602f54466ad60304384c3d9c4ef06e8fc121515b81db39da76dbb94cdd2a6d361399ebaea86edc01853f3f8d1408cc1a4fd12712b45502bc60958c97d3ac33da2b7bb9fd856631dccbef3a2ed4960d431caff1d7913a1f5ab1fe96e77376920fdaec54d06c16c8f3f9f2c15aee8c98b2fed4da039919b9ddf3d13cdf578eba51d44c78eb7c9538c640d04cf7aac6b5d1e9be620fa877b059854c62a4b556498e06e43743ad38a6d8236fcf433a2c3a11d71c639a7c18ef902a3b5c9de1c6b9dd1cb51c85107da50507ccd271b1d749dfffdf19ad0f9031e5c53231c37f2819021fa20ff6156be6a507d32d8cdce9deeb575949b2a728036f53ad0babb81a68925301a05a7f9086da6e5453a910d3add6bc29c56fcf7b3efcb65cf055f9494b38424b18f0212aafca42f15117f03623862ef9c30c1f787f331f54edfbd2d71cee0c1c34940d014f1d90049c73c9ccce3cfeb3a52d29d1eb4811d8ba1ece919966a069bc4df5d6bfa0954a554cf9f33460122179ff4edff3c71fdeeea2f4677b04ee14a9f1d6e365c51b627a9cd36bbbf6d540803a1e12c6aa7be13d0b9041b33bea544dfb9089627159c0d3718c1d0507f4cdcd89456c8f485e2e55d57ba92bc41f100523163b98db617720f1613fa0151a442243c428eb16e8d130e0fb2e271f2349b12435fafcf77b1598071ad3dc46b9a32c9bd74268231ebedbd7f3680b2ccdf3e7b14c135361fd01520fa3f1914fc6566a8a4d175b9950f97257e134ab27bcd744acc265d1586afd86fdf935dc36416d4fa87862f59d2fd1c1c5d255f2d37f73f1b59b85a4fa6fb609c9f87ef4f1d8204c8f9a30b318727480e9cb8a81301d5da11a7cf1d558236427d846c1b8508335ad6f55102ce0038d79fe1a2bcf84522041dfcb6b2dd8a01ac1a1460cccbc2a8fec51f41f6a1ec7053654ea985e3141befac901bafa9c309f5e18d724aa5e2f96ae33a77742b331acac45020d26ced7f0402513628a42378e4d3fcb5ac3e3067f54f7604fa7ca050fece859b1621c8c23de7234d26e81319eed78c57679681b6127bf1ee386d2b7d6905750b95db2569fa178eed2cb0e022d83841a5ef37ba31f86758b0f4421075f2e756939acc61caa814de451331dbe7b0378390a1e97864d0c88fe15cbe4b9a3b5c9b9c5a58adb0d1c9e61b17a4ec44feedcab65d36715c12866dbe23ffdc47e8cbfd449ff0d99d8e87d4428bf6f77b657604bb3c6a1ed90386f0ee249aafe3a28a2bdd04c46a4f4127a58673178ffd0f0be9ae922b44377c119097049d3b747b1aa8d5bde88c4f662f8ad6fe3441608d680de12716fd888cef737bca51549a06d64a995339ebf651d6b6f52d090810e56ada677acff86c39a794cdceb9d64438e2c5086d2983354b140f1f73f4dc89989c866ab364e17980868ae9270281fd58240b176c714c0f288a28f6a00a90be9b84ac913f56952c947ad45a15f9cd7195641ffc07afeb467e981af0d36a2801915eeff9e3659ccc2572bd2e962802fe636918d37688aaf7b5b8c5937d00441c2630bb0d178e567c1be42784f8402828fb8b91ebe618aff7e53370c279e22246bd97ce094affa1961f536b31f412c7c0e057463407e92fb442eb898478aa35ad9bcd1852477d1e796ed5545515c6c6323c02aa2b15234ebfd6270714228ec25cc44b91b6db61af6331206d2052802cc38df0fab072f3f3d6864a527e01cd4d0752d9a97292571711c1b5a2f2e18b859c4d656cda5318873404b5d0b51f88f2da0bb6dde2cf2ae11d364c579de4b21d777fff0dc65d0a23b4c7d6d008ebd96a8d0f2c00aa8d7a450493c4ad95d3b25ac8fc5afb5927bc297639c9901d2040a7f2d40e22eb813556e2de25afbd7cd94422cfcde8322a0cd4e9cf60185e1f0544ebf5f811925be9806ad43a9c74575e84dd577c78b2158f25f671781660191b9a0441bcfc25dea597fdc94c1f2c3a992ed612490d815d692ccbeffc032d6cd4b668d7684387b79c61ad5f6adbcfcdbc133a558824b3fa1fd81535c7871bcfeb656f330f02a16ff6a0ca6c43411e12ad918f1f262ef5275e425bef8cf8468608a453033fdad916d9c29b1a7ea3bee2c79432df95e0912981857d904e1378dce77e3d5073195e0f3a4fd06a5e6f6e3b8e0f18a084d971afc4178f80c89003bcbb6f664affd8d196d362747b221ba42dac841cfe042a68d496557fa42fa909af8e22ee103533499e6da1ea063684023c262f522b439a0967c48b3d27f88ba41f15fa6d02d5df21c03c67c4e40c9f2fe97e33df8bd79ac38722e44d9ad2ecedf5d2b58702fae17163332242979610613c9a139932cce6f0d37802311e2df6be36fd8cca2324211309758a673bd4086c66f5e55642539405b6d7ed90da0bd56bbfa5dd413da26b5f3e033057796a2193095aa6b7c91789dc7bd618873e52e1a6c993f0353f2da551898b42167ff0a28b624e9b8545c02d2a0529db1965223617ffc56345d3fc66f8ac8ebd1283debcd12ea5ced9a8c67bb9ce4df1a9e12b5d1473af0a1585da70423fb17177697d2149941bd2bb0b5973611851e268fb3d1e6b49d06b33fc0530b9aa2d9212d031642d605c08fecc95d2de5227239b089a2c1fa7aa2de68a44cb1c719482a156615b88a934b081cd68017a25a514261d9a2e31825f0b5d7d9a2cfa2240505b5ecbd8b9c57fe758ec18c9377e316cb8e6a13cbfe29f5a3e26cb6064c7ec991e0f47858e859d437507cb9ff204925cb96fd9c8e4a93234085998cd162a5c945b7d28d528b6af1783a3301b8f973983fe7a93d330e882953f637af1790ddc6250fae2bd17f97b2e8b864403c2e89d6eeb054b2981e10ae3f9f95686da626177d4247ab74232d808cd4049d06eb98b52946ea26768511d3735bec6580d9c4c839881560de7bc8705cd44f5294377a56981b4e5592149fbe24a0086418da45e375e9a97fbcfb9f7b66b017c9b1551d1953f7eabecfc155025e6b40a8be3673abfa58f1a02639bd28de103e0a6c5a1b17f2084d97cf7e5a59d889dbfddb31f323c264de0c197880140cb3eb3f7944221d82522b4aa6ba4c3451d618d83cfed340a8e2bf8319afbf926a4ace1b1d5fc49be6cf5a6bb05bab9342983b58011436637448536a2146aa8d2ae3b4dc140be4457c277d52c929832c33198113458679ddae978d100c42b37b1220de6a1ddb8833f945c415d13d12f7f8460d82dadf04abbc0355151c570a456f4ff027cf730a3c84754141f3247840ba027dbacf68b4a0aad35c9464b912a9fca9d2af24dd982ac4260058151e2fffa95288c0c17cc3c40e9ff2c3547a34cff6ed36928d2b51f1c827ecba8a0cda8a38d52fd13c62994344e1dd909f6d55b52eb31719333dcb6087a1f843a35e5b8f5029f121416ecc88ee47f78b909cd7a76feb0a5dadb54689605d46213489664a333b43b4200a11e744fec1e3476003dafbeceecb754d352d133c3cd6a581bf549519c63344caf5a1054e3c22ccf871d241ff4a1639ef3d65505e1fc19b0f4893a8e2a2c815722d0c80b1f4d4b5b98dcaff948e30ea06f89c4f626438bf935be8cc7ecf357a4147e535a4c905137b58430e8d8ca533d11d96e072923794c21b5757c0c6df5fbe3ca6c0d1cdeaae38b44a95ba1f6df5cbc1718bf21e4dd6934ac2b04891e554f4d3349a05802456b2ba64ae5ddeff7748588c0396ca02f531466b8702dac18ba046007fc9ad7ac735e0669c9fc857da7f7159b26a95c540c5927dfd673646f3d979536f30906180ea51c753f51f7cc38809089a4e62f8c41b4f37e6ec27dd3cfc5e11e2042a60001d7ae720d677cb1b5cd3f78dd1325e773e0a3780c7547ab4e8174d5847d77c540f2bfd7a340b557fdb6a383895c10fb6e8de7397df89428094c5ed979f69c0e6ef8950ab1fcd42850b7c20476a53411e49c64982df21f96becdc302f2dacc33541b4c88225d5f606ac5133bdc43d143764fd2c58bc4aed4bec2c34799c3a0b3984ab1b3330ecb7e7e773c04cd1a42c838743f577c818af8da973ad0e270709b76f8ea21c5b5c5497b05590cc545499bc1e6bfc3ec68a0772bce81e939ba4a01e413d9b2e619447f5718dd53ae64ceefc339c0d65e8b4d9a925fe99ac950010ef13b5b70996f6168cc1ca62b67cefad6fe40e0cae1802c0f81d318d9dcb688ca9c4b37808a18ffcc3cf214126f8ee0463195d195a30c1da2cef8d32891653982b6430fd310ac7e5bce162a1de78921a1460b9b901e2e74f5090c8284cc8f49f32d49b3f126062983601417cc57c4142937c34c5ed059e85197fbd789ceafe455661741308af12d3bc371566a751cdf3326be5dd7cd6e8bc61b77339fb711f066183aef333684efc96f6f5a7f7909dd17aff1f29a04d3caff2f368bdd3267c8e6ad08eaccb9f93c8e51ebcffb78d98e0724f668daba6239597c3623e8cbb6a51c9553448f6af388a2795167e44ecdb35468dbde8004bd674d472fef4702fd95231740fad952debc52e5540cc06cebc053e3bf36107034e3c05892fae8e36e37cec23e65869e68b93f70901de1c4f041e5d0ecbda05de4fd595353f523cc93dfa870bc9be7a70a5cce0172dd7ef060d6bee8f232f4826ba01121461c31516e06602ff2eeef14eb829240ca00b7d35f42c4d97d2d32568dc6157927ec63f648c561c69de334e0f24540cc5bb07aa5988760cbec4f653048df38d48bf726e74abf2ce02d569c251b920a858a5af7df7bd4acbe1ea8890ad0045941aafd4417f56309a60813f6859b60c7fd103734933a0b2d9e8b022db3defe0e4242811f43c0cfdcb00a721edd4c03a5919b055efd1f2ffac644fcfb360850a7b0ad9fe6375adab1ca0401d226a308d90a86eb7e3ff7a12bfb8c486168e5c4bee8f3863866d9d5dc1be5974ca0452c2ec16f87f033d1c0d6db03b416216b243bbdb2400dcb9eef64ae4ccc9af6ec1d30aa817fcc54ef6e532735b73c67fc25bbe682cf2a352f3c237fa9b4cdc60f6ff7ebb087cbef3016b6488ee683cfcbe56baa551ae5c360980d838ae0af0566aec42a177d20406a0a98250ef5f20c6100b1a6c60720028f90761bf583ebb7f73b341089bdfbdf2cec06dba43562a5cd45097575f1577d01a285082d8c7fdba54bb3b977aefd953521f2bdf707a8837f2e87fdfdc37d99ea2125c4f8469af312afe4cba45ad55a03e1b4fcf54cb1d1cd8c631b5e4808f89386fd716717fdf579a75df928b262034aebfa270544286108a35605bcb4ac5fd412ed55dcde5b84f56296de275acc80f76244bbf81e064a9f4ff11ce09cbd27572d7acc5bae1d9fed724c2b675db2dca0777f25012762c8fb2f9850c32dcee22a8b5c33282f2aeea2b5055f1250d9c43a7b3639370db5460b9c941a7a22305a7e9b14c1c548887098b6f19d069506befa7b03784531daef5aef8c7160fa424db72f6c2603c48cdcc8f3439cb85d6c6f8bd030503802ab85d5a6c2541ffd0a40cca25c0f4bc7f38c86762752361b5386dcf7f84a8920131d7a87124fd014663f782c660f85a4df81d9f99fb281238f2a6347372585e26b28ed9e007104bcdf438d33d50f1a5d7a9b6dcdaf72a07c038c330cad752fa7b6e43630dc06a21d0d260ac69ce108c192f857c556f66172e293690035dc93924eb75e9c54c8be7772facb42b853accf97b03146dc2bd2554c0b18765680bd820399180a60f22fa0ff567fcee5974d9fd118fb38266a62a29cd3ff4676d7de9b2677e6359ad598290c9489e3e9747d1f12abe3720d5c85d1e4531588693bbfffe6cbe2be3be2ce11dc5a20c4da57b8c9103a547d92cdd6d9f6850b9bc56e82517c82d7e26c52720f4f0f04153ee8474149232c65aed94e351f4e3f6c594223a7a7feecf9b05412abfbb4153a08b328e56934ac122e860d7c508c0886cbb8e8749efba9e818be990b3ad2c64dcdbc6133cfca20e2d8fb3936054f99425de390e9625ce734974b65381eb3dc86431d4a5c6f637f74d624f569fb5c71fe8f83738180169422502c575504aa129342304e7f5146993061e521008c172a9e69ec9db0e650f2bcd022ffc596875acf594710dbf8bb70ab0f2e07b9fee8bc99936107e54722d0b2388b1be0edeac184788bf97d66954ebe85a6164b2cee56e271381cba24177d062a8202a08f313545c63e742c921c323cf17d8ec4e2e2bcd02c45b8ebb4af8178c0a1f6a056c8f366c68f89bfc16911ead27e14daa92fc9231f4e8184238685560248904d8748e9d43afe7ea0b56b3d7ca86e10a57dfd801026d5c13ab2012c8cec848da5372c88d01505c7f024aab0a401293b6f6d66db24790c54439b953e47700fd848eb60b1522037a97a5f5fa2b6e008d38b12aa955f955a5a44a46e54bfb5bc404e799c88da0450892f066c3e0392645a37a97761f27d7f87fa9026ce7a6fa82b60777617f3d387564e89e777fcf015cc63c104b410544a324e69b79d3b7f92133e01f075081b9bd87e82cabd457d2edf87d181fd7186083956d0c68a47f57e6870ac3d8bb3265f33e35d656ec7ceae55485a9800ec37b885049bfd63b2447ed0c5080a2f8807c30254f91f6ee24bce8db4952414423c9d804ba8b163ebc938df291ab4f373dfc07df182a48ce3d4c8ac4faa3cc3c9a72fb9c52e19547e9a1edeffaae4b52700c861788e75caf1e69f063ad4d6c9add463d181484ee7897c08919d4006f5e917f42b3ec41e220869bc7092c853cb7422b90aa44e36f62e1fac54ca7d1a1433af2e62b328fcc31c7a4fd1d8fe67cf155e824d9b7a80af6fc41535ae4b70362f317b0f51860806a96d37e02b0f9a0ca49cf70b129e8373555af776988f5f9ff330bc036f8384043b6748933c11176d190ce232d6e9625c6d2794025c6cff81f4153432ec2c97c712dc74fe56ad2094594ac017a03470d3569402561912df9cdab9f4257bba215411020ba8d4eab12a451d41b7290863fb98d18221109224a6973038dcc96edf62cb7ce412f95f07792f275cac689084ba8b304f9f4e95eefd98294341ced3aba40ab3d38eba3c9bdf0d5c98a8edabd91f814486c2a232ae32fc69134173e66c4e2a5bd5a9036b9fd284a125513b1ef0068527c1ed237efb25108978e6f61d146e9e5c68f9b7713ef4717748b16aaea4b4e9ee55d17802e2ae5390da47c01f0b3acc162ec078ee8938f0a87427c564383d788a35afbbb424091362ecfbd0c8bcf5067f063f974bf2cf54f68ab7f507d116d18539364ab6b68da2752bd7ae5ead356c89737c8931ce0bd4a3b1def85db1101860c92c4e5faa753c4e93499c184ef46cdc2b783f6ccc74d2f67583e217cc0be5ba4ac04a8d4b110a8360f29700b25d5bb9e16d2b0205e4facc1c2658d1dabd89b5c14e70e1b7a7b66a308ee0090703cdb1dcc150639e04fff8e2e41d642b9bde0f4f0e1ef233f00259fbea44b23d7fdcd6ddd25a54ab00fa48cfc4033154161de480e1924aeafeb975e2a02fa50df6dc1810e9d1782e461dc5ea92b5d49638ed44406606317af019f95c46b93e0be9e456274fb4f13b1dc033bbd077b6877326ac2cd9f79045eea0a9a9d5afe35b4c5109832cfb898215cf3462cbcf29facca0f78496b4035eda2b0146224bbd4ffd8404e403fd84b1c7398908906c5ca7f33f81867e36ffe1974edb6f5c90e04f4222a496f028b2571129061a2fa0fe14ec82532fb934b2e9b817043403fa00974c3f8a460bd1d6737dd1c8ee0bfd37ece118bf9a537f5d361b6cc7faefc05e09ec6aa6ae14cff8e203e65b1cda923f09ee9f817d24e988728a3628cdf0966ee493a28093a7afa1e6fd72f946086828b3f1f419e6f3e99cffc29b3ce453cd150fabb02e49b3602643efca35dc7c6f284fcf8923bb1b8fef0f7a643aa2bbd6d4c87babbb19f60f65add1032270771e09c6e757e0aed699c6cde8dcdcee84d1b4ffa95599e9e1ac5ea9b23cc1509cf3d5d32dec8aae84fc9c9ea51b749d087f2a9da58dbf656d444e227af0e99db8b7fe7805245039fef026d471ac2fe203f7743b7c52af07353b3e5fce640e4918b9f70e16728a2a715efde1883374c3a196d16535cb45ef8602e47f89f00a471aacab1452f29bc1d53b1c2ad0e86db8bed9e9aa9a8b26072ae68acb404421c0a8784a4fc2c595817fffb5fc58649bbacf81ff58362c1855af389b8772a614a3d1b5670d5dc9bda4152085664a077a9b14da280c0df2bcf45158a42b1346e180e3d802909fbf9a6533581a0f8c2324790d1dd28ac158ebe4056c129a0c161b84f3e6b0277559a17371ca5c58693042bfcdcad0bd0cd6fa5a04cea0e1c8325cea3f9e9db3e4199b68a7b2bc70e43dd650f8946dd6b2f639f23071936695b6a056b14e3e0276d84ba65182b9f0c59998af9dd43596592a54a369278e31112689a6835c3d703b24cb2a5181bc3640b6b42b126d6d2b8090fe39563d528cf4fa2a72fa0155db950a77f9ae0570b549c76be2aaa6b7a0bd43ac864dd779eb47939e90d2309afeda7aafd2415ef812e45c4e354c24c7760a3af7d71024bdc52a7e599ba1ea5ffbcb9184e7faa187c674ed7a50b6a7337548f45eff74deeed4e96784f610fec9c80e0c5429d4edf12b543a7eb04c8e3517040a0e78727f92ea5bb70c27f13b5b62b056964b5527c8c39fdeae603c448bbae70c849fe20b864b046cb0bf4b31078fb9614ba00b0d7d66021aefb7212b052cda8fa7c9bca7a9ab037e6c01ba3a19fea67c420d2600a3564227c8eb1566c026ce81a84d0c58841a9373ead43b8be4282daacf53b01deeaf03d54f27de59a66323366a2b863c18922c5aeb81793139f7381b879a7769b86bf3c66c1fe4f907143906f021321a0a9d1c42bf319122b7e6754257a34f21acba44e6ba596aa129f51f028d598bf843cb9d7be3f231505232da666faae4cf4149b33f74386b88c31794cb73d09b2baf335fab182b842bdee8c1adaae878dfbef1ebf9f87eff42be9a7b011328e4ba6b0c626711e6c80edf7087f9ac990849ba3761d2a0828ba6f1fd9ff70b5f528d3a913371c966c95cdfefb862c6a6d142cb5dd9fa3295624a598e8b621bee440134425ad438adb70df6c01e2a01fc4603f43ef0c87f1d5e833079212a4950f779a0e64b83f26ae8be4ce28a46240e683c10c3be50e4a2afbb361a4894fe5c6eaeb8a83bc3701be081396bf923e73cd364b9b4d4805147dcb10dfb11bae8a2f8a050fc25b639da6dd1e1604028fb77b4bb1850c6e4f3382f4d3a0c2dbe21a3d7cdd7f9bced4faffc26f1f0bf572343edf034d24394802fd3b5fba2bbe4019548ffa8a1285c179e137e3e8ce1dc02148d5c966ca2ff4b016793df634ca0f4af3c05eb647e70e93d7a116cf733dba48ce56db6ac7bcf30fb92135149803350bec824c485bb304f635e9cc319b2e87308b09a0dc53c6fc66f6d461076345129b7df72c486a158f662e4c6e005342ada2f5d140e2a4c28d9c45b18c68a3ef5e783e72c1b6b2d2edecbf1f6398b3831371ba6e512d730c61bbcc100f424ff744ff6fdd8a1d6087a3fb7d715a68d72579c4b73dadbde687d59cbc4ec6c348a9929db4be2ee28371355d774e603f5eb161779387e73a06e4f72fe39ff829dbc90d3f95d40da451b218062a34550504c52a8d36346c978f5dfc7b304376e2eef59864fccf1358b6742748ac58523f892506e6dbf67ac4a7d373ef53e56272972d2d97b744a691646fb13c3ba0b9a02a53690d7f62628cc626f155630d75d913069e86cb5f55220b4045ff783403801f6069d993ac52131b268a2e3f4a8a5d1aee83e5ab1645643fd65aebed4c025cfb77fa869626dca44e29d7a5de4f608627f7240caf76ca28bada1cc89f81031c80d0f55613728908dec1d6cf6aad1ab22575e0c32e4606c6f096dad8cdf1ec4360de8a89a88dce7b6b0f4de51d6f965c739ce58eda34c02409156665b333aad6f7c8929cf1f58ccf05c5bcda449c6576a687197ddf2296b397aca3154cbd1886884cc8db59bed0a597cfd0cd3b474db169343f374cc88b06b3b103453cb8630d71a42e2d43ba5a84d1c02ebb8f9d80854bed21988d34edaef009e86948daf6ba4111045612cbd36463a8631e7bdff914af8d8fd000363eed44ac4f764d374265192f0924f080b469f45528374fc2b77034b230170d90e12d68d4e563c19fdf3b58119bab603d97e5e35ecb31d39a038f69f27ded8c8382094610896395421d02a32b11c00d74096785f3dfa381dfd4e7e7fa416b75853e0aa69b755c1fd0084981245ae7311d531e6d4016be381ce00a76e021d2f4272f3d623cda404e5f02385d0f11a03f3a5ce33a9df8cdbde966add4fa16e615e68f96071187cdaf86f54ce1cfbabbfb5695e9066fd75ecf7ae6271a25182badfc73dce86d6fa8168d7126b2987d6b270d22dd4e65f10d14008653442517502a3a14d78ef1fb84ae2888ef84df644c84e0f42b4a4687b961502e37ac9a3928c6dfdc678895f58102c10f9884d1a9301c313884f2a432f2ba8afe604cca7d591fdf72e0bbc3ebe1802bf5b298026f19d5a9cfcedc707daf26f3f71b5298a078e310b8e6207cde7506a1350b22d3d6fdae2959639f08e3589fbe4b23d58670a70504b5f6788418c046580b13fe24247f2aafd33b0693098bab9917ce1a13ea1374633c5681d1c74246f1ae724c158d4680e3153064b5f6ff088bd6e7e2c4b3b30336dd0c833d75b03f52f042e9aae8bb56f8b56c53c5d2180cd6805fa6eb236e230ffe118d7844521f2c758497260b42e66a269d742064ea3c6dc71d79e37be634cc4379a0d69581226a21a53c5fad454e8457615b601e926dc8b7fa649b2bd907aa749008ba3c72c2a9af30812dddc3a7fc309767c5cca630c0061dbad0672d21c38f81aa2b225ff37d134005821ad3fd01af123c4313a437b26097bacf0c4d5d0a0c4d5a90c05ef41cc08fa616000d14486c6c7b2b136c79dad92fc523b15acf73a3114c2a9369b995d1f4e659d237a26e19217123d3e8d55269805cf78c8daca81c61de977441cf155a8b9e6d51503789fec316d588fb7922aaa1b0ec321ef166e3c9bdb351f8fce4705bc97b8c8ad27ca1fa53dc11b491372d66fc8fe5a977aaad17942e002c253495a81235eca75cbed32bd1deea5025030167f1d7c3d188f565a723ba763b2874def606e74dd41efe2ab2f69a66549f2fee8ae2430d7baa9ebc263da52a2d40ee962b2108f8484ca2cdc62c8d15b2a75a5f06c514cd7d9ac023e7e4dd89d3f64da0d97aa77159e3a82d304009ea1dfa6632d7a1093089207030d721baf20ee7ef00a6e89dd4bafaf923a99b45598560e2011019df4e4d784222799ec7ee43b4c424053e9db5d09c3bdd80b667f378ab7b04832504438c8d47d6c658798cedc2de4819f88967c94dcb9d76163ad40cd1d003e2a54fb5be1841ac04e74deb9b5375e7f0cc9383f648a9e01073fc8fb24bff28d4f9c306861d727fb8c94079a66e6560cc0aeabd4d0c16399a05971df3bc79a943829108589ecf9effebf94d75dabf70d03462410a672df7e67bc60f88f952c5c83fb863ec8ed31a544ee68d532f3de4ffcb9c4c5082f1a5afec3600ae3337e3667737fe4abc8cc05c443bc8836ac8796027bf1c857af9a3b9ad6e647cab8876f56288505d5f4aa334e621f732a3db6acdf4ba6dcd5807eb45e66fed6091353ee63bf29b2e4dcdce2caf114d3a49a53621fbc8f71aa5a8f4714e7de68d684b9d09fe88f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
