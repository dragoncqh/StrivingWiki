<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e8b6175ceeb82df1b2797755c5721a58d03b701bb6b4c5f494e784ce887b1b8e79d651a91b0c0a7b7f0672b61472ce175ad2afcec01b9903a1363b4f7cd7d52ec331e84e5bc9db589dc41dfe566d97eba961a58ec3ac99f581b39b50d7a7e0a6b12deda6c868642afcfc1a61b67bc865584a8b5cce33ed365fd0026ad89b46ab2d2ea17969dad577cb49572c56ebe44b3bb862b7048a461b798454ec0aaecf720c9696316f28df544ef65281faf4f6f7bb70ea78ba023d5e5f75a9f3b181fb9b4c0de8e9b429d81f0cb03b1b9ba86e85def73cd4df8fc2276474a2a6b730ed2c9294635c6f79f5101b23ba95cc0d04d463b973c38db605e04af73a2421d3c3072ef90c25af7ffeca35dd23cb085590e67016002913c5dfdb0c6ff8ebe06f4b2901b05dd517a96c4d85ea00454591e13adf6a62f2fb2fd089f70ff2d15d86c74c4ed3034dc1102bf70e99a9168d719ce8bb5da967cfed38253a008eb7e6a44e0d795b888f0512b07451f2e666de48fba265ae3a3a80c9f4796b1e57d830b722ee827ce012dc79359cb88e0ed4f490d618abca058533d95b6e24dc375394f9f3b2e460eb7ed947cf5d426273616d9d78d76d73d17f4e5bf8c17ba49eb5372e99da4ed909401ca41e4202756576971668abf04416362cc70e078d36a769eda73b01df173ebd179b1f3df153a64999e1f5a56c7786ea4cf2bc5a2f8b55b5754802221fd78095765034e1dcd2f171656d3adf984486df40cf2a207ad0ab81661bdaf7ac31405a7f671fa2f6b11f7353eaaef692d5928ee54a928e320ac3b218704908388d96277894f5312a8df12c8107a7fa77a014a35bf36d3634dfd09b4ed8bdfa95578efdf882ec3ccd0cbe26a947f2b50c648ca6b4edce7b2fe44553dc5db322ff2a01d3e890f43725c84bc08de37c5a1b7e5687bba32eac23c4381a2bc8dd913c51879cfeb995fb57854db5320a220ee4d228341200376b8fdebd39a932c137e3574b81ea626268950d503c4048aa35a55e0af8aaae3b031141ee188f7de7ae3dd04ce4405c824b131511789f6530ecf07cd6d87fce514afaa72a5bf0053e32e3db1ceabfdea814869204b7a6fdcdadfec68fcc95c63717ca49a7b9fffcd214a0bc3268d640e40404e2948991aa1bc523438270926743fbae13c0a832535a54dc02ecbbe5752b58fceae232b10be3f2c9f25c8f9b70b4a5dd3010a7a8100edcd146ac5f7a19496b7961dff2414b7dae0825b6c0923ed33bf3de5e303a19f9aeeaa448e3f5b9bc53d4d03744bd3f934c6aa08a7a4beaac94ce50761f903613f0fe7d9564f28791a2be95aa99ebf64c3e37a60ca4327eb868353491617c67d34ae8bc5c81de62675e10bdefab9314a75dd2526f187e88d4e9eed7e0a86bcf3d1c99629ea0d6d4921a9c1bdfbb2e501ebcd6fc5af1271b668540c55b09599ee9e4ba1df26a4777eff84b7dcea8d4dc7d6a362f7541cc5cf71c1c64f1a5dc1e7a6767777fbd3c89414f03bf23dc215a815596bcbf8e970d9a2b8f575a6bf111d5edceb8b2b00b15bd3576cd4dc494a2f6bb7cde9773a695461a7fa864a0125fde67f9c9ed0c89bb91dd46ceebd8079f27baedde75111b8441cb41ba6cdf49740012af232c8d33ddbc1a1b5ed1c4cf88454297cd2e92a5ffda0856c0ae401344e61ad54f199ba4d206a75de69dab4438ec07a5d73ff15810fbbe046aa34ccfc7d005752607f0787c044ab9d8605e62a66177fa8b43f65b05279c08ab3c713fe77681563fc1f11e63ff3f8a42a2116091cc430b1834bfb1d61abc60b79dbb85aaa397a7e1148401a77d7d691f5b7bb1c083d8ec8a75d00011c5f407f4b685837f3a6a68138a21ccadbb4cd42647b8f5564aa00026da3e2e8c43fee14d61fd25c5aade8a4d92b0f31a8c2d7376256a26ae54b93e8ec38f243b2153fb173e0d8cb3c1a69dde83790604f4c691c8aa79875249f645244f2e15bfb83c643df8082c1ce61a7e2e926a2dd5b2c7a9b6ba3dff74cb9475b559a81f3f0f3dc81954b964965507c310358c3c9ac32ea7ce2c4395d16b2c4a37758e89bf2f8c2c84223b24934e98327476581aa1b958c23f4599f0def1a6ec27fdbfb6f7dc4cf67c7e2463bbf44355636a76af151d222de3714b75839b0a42822a9ceaddade3bfc6fe2d09c47c32c078e732f4ee18252ac24d02c113c50aac2f3354483333f768cfbf79d61260fd72acf579bea75ea5edeb979620525be71ed46dca5e8e3076622be23664d2da8d8d0a4c28b5face5213cb37dce2459fe4447a5fb4e658b2ce5fd07f0806a7f9e7124fb3d207743b6a29d3e3aea1e235a1c58f8f0ea54fe4d5c2147d8b89c5195eccacdfbd24b410e207685acca262d0a7135a421f3aa8ba271f3982c0cdf009268c66b173a36623e2d48b8607cbe95f98cce788a206d63ee889bc3b1e4191e1a748871ce3228d616fca825a8c97e0a51b3ef2e003ba3f26688b1292a978e453f6272af716a830410614acd14fd8cae464fe93c2ac9d7fa979412f3c552e1416fda0879091a2c2ec687e0cbc5517cc5cffad070f20bf8eb25e4798c376f703f471d823e3b36c42bca7b67a0b61b64be405c202f7972aac616e0d48b630aae12dc40150fe680471c394755c2db369948809b243a0b5d03204d82f683dba4e7c366d82d52818a2cc723f774bb487304cfd7d503e30f3a75258f76b8d82f0d4fa826ff6e8e177a5cf28686ef41d735475dc73c9ed11d725ecedfce6d2b51cb570172082ebb108e76baea3d32ec1f7261d55b86d33f1f101e55c5beae8a83356a45f883df0e71f091cfc13c641c82c1b454a4a6a70dc80b59d363dbe5148d3f8c8bb6347e5a4ed8acf00c4be6d75e8741ecab8fd901e35c04e9069e93c24edca70838ece12c03c9eaabfa3b53d7f73c9b25aa88c7d8fe30a36b7e9db6d3d9f09c06fbae3f41eb59cf62bdf01caa1ceb2f3ea844e1c134395e8e4b2a0a996a48363db9e143e1be8603588781987a730793bb13b33be94de0530b2dacc043e99857da0deffd57aeb63239aac7901ceefa603b8ceb9e24a8222b9c1f21eeed854f61735d3e0f49f134b73d63091991a8915014bf0c7c60978678a75f321b8f2751fec0e64f64d69d11c5f07bfa6b6fb731b398cf7c6dce42f453ce78c71297528a8d5a9010bd37d526f011b6981d27f7194637eb3bc3fdb9c0b2ac81c6061ef72204a0ef05ec541c13ece9a2249125baaf541e09d214fd68a134c48c9cb0f134e3325620e32718dfbdc4275c121e7e52f786ba42090c60da1879f559b7d6b362517d4dce68f5625a7caef6a580db3ef7ed8589b0cab1f6681c2f433ca84d873f02524df9b8ee7580e1371ad6ddd1646e3ac00680917a9758dff514f4158504ae77c3ecc21eed0772c897061b58042e69d9c27a04ef48ccd9d4a801e21091577529be4bc0b7182ce54cee95d3637b07302358d0e08acbcdd5b51b94685b52fefa0eacb5af9ef74949894b394fed5bc499589905f0665629fcc8d0e365fac7552fc73a854072d822316a66a09b4e9c05155c915e3e28152619e13ed0bf7f7e30be92b92d95ab333ad53513e8db23a081f72185621404257c01f4fe90508447b5f1690cd8378a1bd370fef5d14144d70ab5f14e2ddf7e4a230bc4e367b49f7cb7a631d35387427900d9c261c14f2f6835422c56f87a5b58408a6091af5d8ed4df68c948da6af0a37e03eeecba02b7e423d2fd4a75a215911f3de294b48cb637bebb4bdedc030592773a14cf44a6340e0fafe6beb44f73561e5811285080d0c19db45a9b1a60305987628cbe9bf42a161efedbc93410e8b126663d51dae2ea4e2a02deb54c1dd3246ec3f0329b0a88295227179d8fde18309bd735d8a5e910b8f96d8ee53cae17915c60524864a0065c8b73d33f52819b59fd6ddcc99da8d2db50efee43c9ad2d2244cf64d0d77f0a91f39933b70dec29d3dcbab7f8416782c05255734e772d8cbde548f1e6027532d9dffdbf6c202bc5f420ac0e8b663424936f3026797751c86b075e09cd4652451a4f6744e8859d4a1ca7fd439f6c8d5de64d5f1376e108979a161e86e25b920db96d6f0cc58b9f0ed0ea7825c1d12e4eabc7856ff64779ce4e2c6b2b15e7a3f1909c9b0cc798bfea2a7fea830c3a740494667b839fea094466711d82231b9855e7ec8ad5cc0bde555ba611ad96c7ba2006ad377bceb3595266421512b8da6fb57b3bdd4a9eb2df425680689add298051222b1c0b4f8712eaa8ada966a0c107fa5bb34f6dfc26027efcb947b05553f15680b9bd6449b34d886c17eb0d632de51567ff15b0d40b5305f13cca0310e347a91226ec878bacd74b091b3cec22d9d376bcbd8fdfd529f20acc9d50e847987f8567daf72f4c8519e218d2988a1113f3bb52f0f5538021ccce9d6e4c5770192ddf92b7e251e9e649fe78258e0f4b7775a915c7bceb0405477f0d34065a1aaaced8cde8f53d95c640cfb5fbf1d855dc09657f68591b32014d960904782cf08249de2524b421e357427b052636052179be2ac0b30b1389122077eeb96a9955c1b8ca6d89c858dec6374d7b9a419ac3dea7f7ae5dd8457279c8cb81c2d14bb38275ccd1ece1797468bc702680c0d8d4e3099665eaed8a61835ff94e8c4c11b292237764ead3f5c6eee08ebdb636f4340d664c807ff3b43f06edbc0fcb209fbdadbe2bd0ab7485b027c876cda2633fe0683aef0173d97746d3c45d8392b424a6377d13a49e7c5d4b12a13e079f17f522cab60d2341b1378fbd3e3ee83670ee5e82263a6e9668d34dc0e31b7cebd9d103590efdc0e102a5bb3e75d7239fcda009bf78f67b29dcda7e1aaca78d9eea061a939cb8b36c4668874680a9b548ea499e52aa6791841f4b42f2587a8a359942452cc1a050726fd5e71471bad0dc4a42afb66ad7d8f1fca335ea242f6b0ae7ef49684a8a904f1f927564dff0c779f6378d588d1d2baf48f0c1605d3f9d0a480e8f6dcdb8949f6b5265c02c772e1243a9795907038f8a8138f36f424b692b32f010e5877a92ab394c9cae6ee4ad02afa2c6e65c1111368292128033bd83d57062f481ad9129de477225132df296b7c055b5470abbe280c30e8defcee4a417bbcf3e3a82177e2e6f005d1704ccdd869c6f43fe0241d3bf16a1ec211ac43cbdfb323ab4bb032a01bef8131d1a3605e5d64a7ae140dc3deae397b1a246d0e53e6c95b5a93be14d780967ea60189e7e226ed4b7b2efd5866ea501e69ba7ba7386a8161e4b05bd3e6f3a466c1acb29fc33c25c5216022b89045a85b7a22c47dc501efe807b0f98af5e6c86bc99cda59038174a8bfd3ed2b03da375f17efc3e5d75c2f443e9cacae8b8588a74456e03a0a69d9df0d67dedb41188ee68649aab942c9d3f11194523e3fc3e4fb2dcd3c715ea923668ce910e94526ee817f42413506626b7460f1650510a0f9ffb15587d53244d7c2663488073ba3bbf19079293aec878c17ff20084c75aa4abe0a4687e6a7fe0c098c0dad3732e11b94afff3b69769d2bd160cf1d9de09cff5d35c362b6be89b36f8f97f73408ea1d8be360152dda1699417e940ebb4937a37d9e33deb77e646b8e55137b3699f335ed156eb0b4f41ae6c4ddc1b3d27d2cfedd0f124a4ae4647196610596676288910dce529d414cba0faba09a04ef7c5c4a9f9ade59155443a04383e0561c0d0add18830ead38531c8ddd72d6b9ac17a062a0ce0e14d05013f62072fb87ba1c427fa0fc39b1a2a2a726ae9966d8def08ccacdbfa5254b54469077c991d868d2afeb89c81b5dcb39f9b936c779627290a90d35095a3df5bdf59024008fbb8efd7308303718dfdfe225980753e41e48efd23ac7903e9c24f09394145ea0a6f5f0b37838e84e6435b587e83d25d5965e7d93a0f6c8443a4b2398da827afdcc134bee84469f13af477a56b8b0c615c18f3738eaf3cc85db817df8d09a4129c746e122352fcba11dd64bb6ed3f9afb2c9893dd4fd48db17b6ed3a29b5ccad904517f56baac0acb14b63f9d2a73c2083df054a2b73cead1f94a4fbe13b0885087367cd5e67c12b234f47a42dbe6e82bec1c8a18d94d07c4829f8b03d0bad86f1d1eb53a177c86e750529cc892f9cee39eb3a79b7479ed72ba2c9188db0edc2c1fccdd02573032bbac6a15d5296c9d5ff5e2270282b5e99cb803beaddf02fdd548ca21bfb8e254458dfe0411916d8bc45098c2b40b3f42279dabc2b10a6a77179198eef73e552d33d5324033c5da96873f0f57ebf8a0b97b4a1e96f40b623a4e597aaa2acac0e308fd286a9068c8f823088af9b4f5e2c3b26f6bcb548a3ad782aa89234e3a4a988ce92791b8ae7d3f33fcf2659327dfb8c3b57af15c9843b90803f4571905cac51327a4fe3683d82ed60829963525f5b2ec0bf9c8b1acb5f47634eba6366b944e4985190d7f1afa29d813436e06f062e42b81171250b14b8312fd2db30c53e4841571fe425b135500fcf1d618fd01bc55abb382f59a33d1fe36e16445ea1cecf02759750140d3c3defddef511b9b75a8a1e30b72aabb6e8f1e2da14ee589347e04236f3fa33218fb985d2c6cf8c9724fb6a8694e67e90dae6ad9f7bd29858c653cffd1dda8e306c9755975d12a1ffd7d4201cb8fb970437770b1aba9f04b4106683d00fa38e8fe579b960f7990f23c330006b4a0834e77043eab49e5acc42fdaf70b89140a4215971567aeb77505103f5e994300b27a03946ebe3f80f6421dba936d2fcad70ccb0eba59ca5b43c9c97b2047c67fbea924d59c68a1fe8e9d83ea76aed1df12ec343e068baaad415496c5759098bf6840f5079ff1b086ff33f73adf489468a147e512749f3297cf976eb5792d0cab0d443159a74daf1e707b7f28ace9600956afe854dbb061b503e11810fc7ccc7da944d00318402ad7f2e1a202634a113aa96966a3277c774ed346a9c27409938882e0ae0f8b8bee97258724a5161c7cdcd70f32d119bf96769b6c0838adf7a367523bdcc706237ae9b4317f97824b41915313e35c3c8834a9c63416bbdc6258ee30e1e80cde871c38a30b055154d23f8440d2abb27cd85df60362d6d4e632ca70e7afbee90d494c636628d449a4d3391740835b0f09850706c0954a063cf771b07301dcf7a798a452b0f5c9f3df5428a2d703347707262be1073df96fd4edb4e975c4d29a55ef93736997398010fe9c4807b8cdebc106e5835011e75f31f413404354e39d185c54b9df863e6862143d69b128424482253487d891b1a805542f313f49ad18c6e550389a430f18057407ff3860aa9fd74d1e0c5f91edea22965eb151aa582529994eb159f5795dba6252ea6f8a952844d7beaf2614ae5e402b2731aab19e7e3a0ca0ca3bc2b3cbf151dbd062a615ccc081080dcf49889a2108f89c5ce506d234a024949652740f4849ee0310ff4cb52bd40594edef235d2febdb73c519dfa85dc74175ce7af0045a2176cc8747713027a3b96f22630e5c5704e6a8ac6ac3adc54ab949738f18a1f21c4084607f19e1feacbb0b02f8b61a0040a118535525944853c9b96893d09b35391a4787e3e69d42b53a50baa534dcdd88962dfa582b4f7ff191e37f9514310696d8930e08a5a675ca6d7277b5bf8cb558d03f39c1df8fda35db139664f32a203e0cd1dba5607dbc10db568d5fbbeb5c9eb80a6ea2e409ffd9a468d55b6a5411fc4b77227d44726859d41ad277e5964d57c7be37e7bb8be0fd9766e3a9df20e21689f923a1b4afaa8ebbfe741fa62f7c058c2c9c18cd5e32567f3974cc430878c2046d40e6a6e336750375badf818ab4165642dceaa6c7ce587de16349f2cae486e478be5f7e23377412196f2402ac5476845e73927580d73b90138adc840ea108017f565ebd4d17ac357339eb7be1988a46dec8f70023831351937642ef7410a3e7fc7f867d7bf150ccedc5f934a1e6539956f3d0f125cce5d24755226d235e054aec2b68e44c89207c18ad14759bc516984f6b4c175fa71e9f7d4607412e6d58d51c687f0360a345d0bf5e254818ee939a1074bd192ef941cc7d3ed266603755d91de3b1018e07987a4ea0a69800ee4f41aa0e7cecd4234994006893e961ff00a7e07d7dfe5410688b9b7e3765c072eeb949c43fca61241e85beb9cda01beb4d172cf12995d9956d64f3bbd2033861d5bee8c9b6484beb6eab274ef5ee136fbaa97b86d5963b3bbb47a2402f88d1eff9314f755de009d2d5bd34143bad6016ba817ae5b138f282ccdfba33a54ef79f27b24dd98d17a47100145647de87a268484b51987174a3503911c24553ae9a1b5f1e1dec9d2a258f2ab08cd4156301f75721405b3f6acb6ca38fd33ac0db630547fb7cb5517177ac51f7f1ec9ee612e9fec8003943d610abc6b9faaef0b51003068fbe402fc61f79984461e72f02e84f85dba0a78ab9384a3b694e0e6ca5f5bade6539d10b9fb1d746764c593ae61b3f7f8e2fb427398eb6f31a96cd5467b77f543c7ccfef58df10fc06711d37537158359f740012ef0a8ecac13e00f5baf096aaa6f7fdbb19c12ff0259fa6b87a6351bb0ffa2af7d3fc7f856601c09899698be599f4c9c646367d6c93a0579335bccdb6cd9ef37de929c0f8a16ccae25f6f34dd9bd7b545e73ac0918b896d472e61efc576d5729b5f0dd75e35f072971c5b0a9ade4a4213b84c79f9bf140a7301505e6af33495d29bb4320e180c8e80a7cad15a46f53a1fead02f8bc35a514dbd578d0e7e9bb5cb89775bbd4472f3530f77723be5714a12267f4cbd42bf4b8bfa8f638b5a93a0118e6133ddc780895a5be166a125c6bd2041e24eafcbfca5d2d59063342b0dc08a62166dfc93e736d37709dcdec553107e65db88a71c0d7d7d104165ae4b5836b3e86361733931bdf9985df37dda18297cc8fe1ec3cb58157ab53ca08fd29d53604dc291422e9523ec8cb5e728a68be7a1f1d64ebdce102c082c63a0daf16c85943ffdc1b014b100a2dbe89ad7725f547c054f379e8179e358cedd807476f77d76d93e845b1455ad24ce6b4fd34cc7020d72a8d30bf79fa921df5fb7c508b507169218f349401e3b45225f3c89852de30e783ec7ed233b66f69698d2ea53d29a6547c6a11cab29ca6e97b9d9bae7fcaf07952cf236c004f018d343bc58cac823f4a3aac2e6d58643d0979d70a3997d4380a1fad8d418d5ddffa7088d18150487f288ed921ea11189c01398c19c5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
