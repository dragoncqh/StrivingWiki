<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f2c310c46a7c491e872105f9beda2e278b9f6c42a48bc8a767cce112ca45a030033dca0ae2756541196d1c4f919201fc2793ce6b70304ebf1dc4681ff21b9b8de2a6c95fea087268f19034b308b7df5b2dd4485df4e0e576303f3945cdf5620df6e8b7251b2d547b1ff54d302444f74d5ef587044820e91f85d900dbd1a8b630cd60fe8b251124cbf9f0189c2889ea3a7f2787c2bc9bd3159d2767a18d2e0d2e3167c1c3cddfa444b8f6925ad785e5a682fb913753493c9399ebde0b26fb22ae151f89499dddc1621e88d4b3e5f70eaf8c4cc812c9b49f018c719d538896697694c7147f66ffc497ffaac7682c5ec6d0dd7796491fb15d2ff2c4467f880fb7b33e6b32e7619aedc6f6d8ca53145af929a57910c441fec540212d841d0ce567b21f379e9e743f4213e6e9b60732651ddf873f6b561bb6c96819a0071873d1536b2489de073841917ad055f7122f96e25cb0ac1bf41930f55dd5b90c4e486e4ebb17b27f6068b4b568afae6f025626423a8a0e762c26964cbd9f5850a646103be2d9cf5e7a00c709aa1a260da82ee2a3d0b853dbae96536dbcc43a3c75efc4f12c969ea4c814db777b5bff9ec4697398bd8c9b4cc68f7f3bfa45142f84056052ba0eb7e942da7f94798215bed57e5635249b513ec52752af79cb662411ad59d42dd31504493695125bde57344d2ca355620767f496007d58ebed5a989e0a07a72943f1859136a4b0e2b862ef1877e58878a59fec175df26926ff1fb83b83ec27f6d56efd1bff92de41a2e9a8871d911b8e2da937a79c0de3d6b663ff33e94a71b18bf1af2fb5c68a9430015d77d28eae6c4f93e44f941be76e13ee05631d6c78db89337c8cb8d7eed645ba74107933ed6acddb8dcfcfcff46b0868f894d62dad74df4552db05426980671e75956fb5bbf72e33825ca27bd6a1f215f339592c8553efb66c2d3356f343186d7f28bb5471784e2a9919ec390b09518a9f83d8f208ef2839fc04780b33cc4bcde6a99fc17d30c8e63e162028969576e49ac773f6af37726875d3eed84b60febb31aa2e9a64038f90a4b0226d19ed4529035255bbdfeb1c88423f2b94385278f45da5f618afa753709db7f8f7cf0c04ce50c353b2c2ea6f7ab15b9f1d06cc5536651ee9b1dee4b4127f98431df7484ec4966e989a0d16e6bc82c98df74807b46db2750748008546e6b3171428dd78e1a1ddcbb856a795eb8f0e5307e31978ecb774766d29bf306be26684545789c06cbf516badeb0734fba3ae5246a3d004f8decdeba62705bc6d50559fb763a114b0c902686410af85da52dac3ab59d278c5188801f7316225e58967c8ff40ecab31802936bc66209d3e4dd162f860648cf6b73961b66dd1b4a135200a1b7da13f6f89efa204175e80c9e254b5942ccdc0c91ecf744f3627c3beb59c90f2b64423ee48e2064807fbf4c6683aa46a7c60ca716f3355b14b674f733bfb20a7ef3835e2bad1ed26d395fdbd9dbd3d47e5af4ba9637822a4d57345205c40acf469852bcd62bf3490b2412709b031533f323475b7288a0b40b6df7a94dee4ecff18d044b50223f4f476a085deb09f8de67f25bb11973197c46ddafe7ce087832e7d673106feac322c75d3c0c2daec9f264e347caad39f26d03822b5bee82cac0bef0fcad87223a1ecd7a37689560a16d15d941707c190462c99c724a4864db61daa0168449e1856f3bf7a0231016f47139e5dc223ce00e5b100d31518b3b71c59e4f2f40e76602a1cf0bee9b649f1962080db61cba5fc547c1bbaee9cb55394d1ef9275a810ca03ee56ffc6ab6d5bb500792f8de5015f89eed451a516d98a5ca2f7b89dd2396e4f5f1787eea99ecce7fab4827abbf978cdfe398d0e6e00ed39ba3ec70e5ab9ff6f46a728b0271aef555135b60b401f29a03bccc61668650285fca4fde165f62c79cfb220e088b3fc7ac7d56b78e289af6aff72171dd9de6532dbaf7919f99c77c86b71becfb9a79cf874b8bb3682746a7fdb3851d01b0f43a67be94573d8c6a639280ae93f57fcb26fbe6c59f5477556f2e99de4c18d3a58db46c0476bd9f5f0ed71374a0bf98e3d54dae9b4ddce8286af524a3540358493409219484b39f3ed111b76883224b69945b86af2f06b27865e3ee90688bd2524cf0db05f5441ac0a622c150f13e9c33e41eee1d7c74032bca1ec45eec49007093e253bcfffe602a8185d5e205739954fe572a5749e726387b8d9192b1d2caefe59957661059ed224332cf4dfcfdeafe9c693ca6af984237fafdcb6839fd573396e128336ac119935a5a7dc363084e3e6a78b2f9f559f300e1716451f220ec8d0fec9354966f24602b5144cb2e19eb03a379a54004405368a2dec6e8c5d7bd86622377f0c413159396cd36c64eceae5e7691edc38c24ddddaa2348aff8e26271a7ac9600989905a30dbc7b05d2c1387b9e5ddadaf32866e9cd60e1020ed74dbdcc735e9bca9be786bada10f956f007dd98ebffb67ec10ce1fa8af32da1b4e042a23f485e183f5dc5d1866147740d170e41c1549956e8a25042eca85d4890e748b3147ac7b988c6391f4cf700c7f0fa25ac2bee91b522a5ad4eaabcc503c447d16e813efaedb32d262200e76b191c3bc472939a2af7fb79be53c4b0f65126ab115f9c836743bd5be5a45f7f436e89c23405095346316f87ef2e85575cd96cd1188915190312d5b21c3f12397d20c53a8c27a0bc7046cc49151d90e0b8a896a7a0862717fa000faffc7f8e009048621426e6628933e12ffdc49fbd71271be626ab6ddc468fd7d19047fb05b8e5f050f03be877fbc12fb26dab317523fc030e54b8750e4cb9621ed4c781ec3ede686802e5071dc711b8bbb0cc85e237519a13b042b7fc2ad59f6b539d5b1c1f8c0c013c52b6483a9b025a5fe80452b00579007c319a64950b555465992c39464a0eb043afda971f4ccf2ed0cebfea5de0bb5153779bfea4baa36d027df942ae049e0bab4a85a3379b1cba2a215cd98eb8925b9a584584200b468443ff6987a6ea0a2910ada6c4a1297023904dba1bf0b737c881135b01f27948c1ffaef2d90c8e12d6732e40f076ff7a390143fdf07fd57ac1b3d31a676251c9c493cbabf21b9a325edade32c1f593edeeb507f98792329a7b33a957e19e0d84213bad529d597ec5cc7b692a4cbbc2acfa0b860092f6707f2aab07060b8086a427027d53650de18eaa89b611ec8067b2f4defa51ea0ddc1ccec5a13c843a1c0cf66bf9451d9c57ed2e09367aa63d72a398ce20b6fdb11cdff254d5561d0b0ade8fa8f9a85a7b0e5c7e628d5c904f5d9e4d31131370809d111e01cfa347e616ae1a8f7b1e05758b88b3f60cc58f33e84507c7180cfae64298ef11f084bd5c69d236dd08382488091bbffbdd97a4c23066aa46370ca14a4c6a4ebf77621144f379c205b9f0807ea0e63aeb12b3975aef55865c28f95171fb9afc5f3ff7d41131e56460a29a37fbcbf388189092d2178f740f9c8dfa47ad32dcba394b0b6a050f9f170df461c7cca2146c3caea8a8ae5f63263df03839ad61c399816c793747d1de8151d04111ed5fe169a87fcc5e71ab0deb6be9faad76b057ac6b50df207717762f35d58ea0c3ad8657a5b9db6ef0188a8c8ea5f4f22135afecc6236caa7e2237a4e2d2e908f2e2162c58f5b0767840e339ef5d6cdc3d0eb0f8f1994d81fcd4033b46bc69f15f6b68088b860bc3772388c0c593487f990862cae9466c50b09256281b9609f1363c3fd2ae5831121564db006651a101114b932d8a8c50f13c5caf8a500f52bda3d7e2ac232854d665c1a0459b9c9a91f93fa4fc3466ec284e2c6f82f3eb98bbd2e61b575fec74b28271ff7d05394b0afe2080390dfb434887ffed7b65de34294ac43864de7572b69e5d0f1aef5a6749a2e5f033614e049691f334eb48af17bf322049695766d7bd415143900f2b3f333d399ee8a2b10da4dbaf8ed84fe3029e2cd47bd3161a9c32be0fb0b835c02aa2d45fc0d32587f6568049c9aa1dae2462c04cf4471bbd5f04e5ec75eb30370d96c3ee00bf06d51e7e9be842bcf68cba65ee2771b62383d14ad14e4260451032cb9d7c8f54a04aa6f6f8642ac32851bfac27dfea60549d7a941d3cf4a05f589c388e79ad9606e29e0bd0f3ee715561d9c11a8acb2953df6c09d8ac81418e089f58cd193000a175f528f81cc519df5ad25b31fdc3bbbd0d7a91593147df36033489ab9d9038088abca38bdb9b590206536ac36446544967036eed41d43960d92c5390607ed68d96dc88c26d592a8b655d312d5e185bb89ec41a85616f0b1df1c6cb3d15feb8d11d2b389d9154297cc6387849aab85254ea2f344e5a82f02e28c2949b0ad92fad31e3144d9325aa5a68b9a545630c35a9fd5dfe46a09bd2eb737d3642164bb297f636fd346486f83d06d31dcc7c4c003ed3eb488979bfe767b7e4b1650972ccc717245e73dee8a3992bfb53df3b796b3419b514cdf6055230cc7c232c50b01f0675632d177e73d991df4242a1c940c7335d05baa361349f2d8506b33f9c0ac9c025fc9293134be4b9e649544127a1e13bb5fb30834e172076f676c9be43e46e57f02c081912b53c51ff708fc491d72cacd862dc7dfcb6e0fe1dc279a7bc0fb95f65ac976413a7d36ffee4280d1b8d10aa0079283f596f5589c2aed989edaf0810a50f1d950e1dda547310219cdacbff892bda1c336d4add6de9a2c3ff2189c3cfbb50389077620325492941d4cc4bb49c79a118cec48f44ededf2b5d76776a696b64f2c63163be2fa9ef3f84acd529e6f5433c7a662f54b8f5cc24ee80856ca747eb86d34aeb47a04b71bd4271f059b4a68351362a843226c509bfbaffddd862f71e6f8b549a4928d06633b86730408c553bd9358eada6084309750b0550adeb466e9b8b97695a4df1616f7fbdd33709cad28b296b0702fef4d19c345f1a048443670c882bc2928a6787017c02d154544e2d74d559f13d8213793e8021173931e0d0486dc7c3a66efd847590e440c901e055143f05dbfd53b1a0b1c94dcb7af905d28f7a2b513e76a2faa2b1fc21ec8cd9209b3db8acd551b71c7618194de502c2cd808d8a2099274186356ff97d43920aadbb31ce32683101292a6d0d72fa9d9a48433e8079f1dcf87d2b60e2a946505348d2d28368b23d58fe4a2fe2eee7d1a8ec4c7b5049cd17be19736376b53012185e6de080eb1202eb1bbf828a13b8b5ece44826a6ae417a2dca6f065d7dc6761b624c6e7cd7ee8215d1dc3bc71487245360e4ac7914c85b19cd8fbba70ef1770b2f3be09e8a0a8cedb2e23b1d0eec79be8cf4024887b8c482f6e10c70838f3e7764347f53915b9be7397268894c5218cecd0e08000f1c41a3e31f2ced3e7c95080ed224e10b2ca31386fb203db911d5bffc3a6d7db235e92b8ca8034be002953afc367cabb173e2683becbdaa9748b891a4030440e25ca99816362129f36360083388087f1e8533bbbfefda5249d2d71e52e0e1bff79c9308f6a7c20fa4d9704434ecbd15506cfd160b68535f22231f29e32127cef8255e321cec234ca7c50f72b747ab1598e35d5f85644efbd0b48b9c8779c71429bf5813adaef1695f78a3648bed6fa426116ca0238dd70e82fa45a40136de3f9c82b8e74c4b354ee731a45362285a53bd3a9c8592f66024e0cc6480c2a93500360c3fd4c0694885d73092fbc364353f3c3d58bc7e9fb688be8718eb4e4fe6864fe38f68a085808e550a41a15735ed3c1c75f672c8a952eb35a137e31416ac4661cfc221abfc4107eb7e30430e56e6e853513dc8e1713cc8c77f45555de5ec7da3db3688ddac8e8d75a2c56072e0648ed70ebaeb677b05b4d649325dd7710046009898aca227a830afe926b0c70670b8727b9abc57395764a22960a4743a4ce70788662ac66ea215f96dfbdaf744660375900411390b282b31f10771c678a657a41bcedc1fb061a1f5f013789d3f3a76112b05993daf8e9e2198c0ad96833d1d0eac9dfa137850fdf1f6ce88b9acf8e0236a9fc1dc9d7d4953001fafdb229094061bce83e6f301bdddfb189ec274a6b92c90d6d2296cb141af47cd50441b812a6279e40579cfcb712141767ac9e22611a2759139793faf0fa9229114687b407f306a6ce1ba09315662c70ad54cbf8628f3ff3f2c719b090e8b6a23d1a0d552d25120d128cdda329382f84324e3d14050a6afe5a5cb7e3d6cda79fb90c4eae4964d83299218d860897588c23a257908159a12576493e3d94613ae92f847d0a91f04d5f5845ee23aa6a82dd904d5f50d9b6fb4eefa4235522e34df0f01f7d10bc05ae960017a09fa9588af74bd15f693576e11e51ea8b72a589089bb00440cd2389bd8dcd38ad5a9896525934fc464ae5c184a6c149df54b1a95a844b48a1a9110f4b616a40a041b2c58357023b421d1235f79d0d202be49cc32f59c12c020296b268d957a95cb89861e1ebafd1263c9197a12a1dcb31f362332f963a86602909bf90713332495a1a8f637b01c7423f7b222c76326492a5c2ae244f417be2c8c2168f15b952f9f7774dcd85875730960a10c9ca3b50a649c2fda6cb5ee3ec3a507c5fad11f5af35271f650e19c85e39acbdc827fd6025cbad7c84a1da753885044198d1ff1d8b15db4e1e328ed6584f9cd29402e2b3ef84f9ddb393faaa7601521515b9b24e2b6779a5c8da562e0add4770372b6a492dbba3f6a40eaff15d938f7fa780925635c66db97c5b7d5190b5078e41b802d69363e52f316b4642f1739e538b8c2787b5ef1c97e15f24359c8e0e7d8d907ecd0d754a7dc9e36f8155b2d6425b7dd54aab2da374d11296d0a5eeeb5845c74bd7faa149bb58d868420235e5d4f96174abacd488e32c3d5987c054de0190d033757cb0aa4d2a0c4ff3eb180bfc1a5455e856e95f9f7903e5d78c01dad254184802a09c45531739e33bae545c9efe7679de410ae91f08ead8a67b5ef465bbfaab86cca400d88fba091a31a928bc2275d29359a077eac64db544967e5b58c8a98b231c22c7fa04e9600b657901475bba001a26a5ca601a72a8d0dff9093441f228ce9b799664167a43cbbfa71a0592020bc8d81b8503ffab57c2e5105f766101ad8b140f6917a56a63c4ad9fe101df8b6b2903b5be084f17679c112bf7f0e232e498636a411d0d0636d99e9e050cab91d01bc4f8de8a06db0a448f5c6acacbc150020989496ae44bf78f5eb37dd44d2c6441d118811e3b38194e58e6264f80b2ba2d0ef7b6abefca89192b1625ae506d67d238296de7df63cf2fb2c0649027e44336269316a54791169d9fd0b131f4c609bce06c6d327cd8121bdf5bd70ccee6e47722cdc5f58e549bc0d6381f221690ed74d4d8c3a350aa2da60e3add32839bf9af310f893dd58e59cca672d7f95f27e3bfcc4e7ddd59aca42e39ee24f47ceb4fd785165b4c0c6dc6278c75ec244d7e0280c6dd793b7f0766c9fbd65ef2d380b0f9ec6deb617d390db453d93dd678b6376bf6a114f9c0bd55b40cd626ef7443b4314572d8e1027f9d085ace51662e31a0515ffd665c3595f486e57402cceb89b643ed51a9bc9213cc4bd4046ccc96556a341aa80c528dfb9f1598fb0219cc1cf2d55eb82235db5bb41843f593910deacf3038f13ef00ae5ab4adb46df13de0f6b77979a7d6e466705dac13154b98c23766be633b89a8e2f260694e9c3af705fde31b96270e807a03828a1f6075b6af8a88f17b2ffd26b97b7a4118cf3391e7fc8fd7c837dd09c706a387c90c19481aa5411836b6abbc6ac65a5bc2ec4b9d28a9700234d177693848b678398e0d85c04c3f276afd3a0c74b5bc01c1200cb5209de4af1f747e6a3d4084866e5c730095f986647b02219107c24af99636ffbd443c3e46b02d27b5bd286cf80844ccb0e85ef7f27dc515a7b8f56323fa2a43d40fe848a33194da1c179907d89703b1a7315cfe61ee8f10268bc016c90fee6ec06f48a6797101418b51d4fefa1b2486531fdac55bbcd8e7dc191e1d3859f08e2402b4d64f455f4f05cb42aa1e34d924bb68016c4e953ccf8dfe714db067433fea9784b18d283a6d6e737c4e775ecfbcb731a9708b57d8317fbe63c6e44542ecb991053967372a69b8bb6b1c9b2cfd3c3e7319fc591256f81e3f121a842155b7fd7f9b96ef6043010d9db5f42893405411f1d20f6ff9d591d7a49add350f485acd9b65652afb75a98037ba1460d3f068e2421eaf6fa1c64f3c307a35eb17483b26998722e48e0e7014f83b3a9bbe721718e714d2220c3627f6ed28d857c3ee7dc243cb1cd6360b55f2de95b5cb1f078f19f63e595d8db01f60f6fb93df4827c48edcfa99482d28b233efd2c402758fa6183d5d1f490e49f2168e2774accf0dc8bd263e2573f7699781b41f093de8fdd0c7efabbc14f2fc4feff2fbbee5075f7fa135ade378c3ed48b24807feae9545297a29a3260e551904b490d60655ad8e13a017bb07a7885e9e281974e6a43c78eadd760ca717ae78452ff592db079d1f21081ff03f747d394330705404aee350677b550102d86e4861568044f5d5a208edbf48b5ab057e58684f5556538a30bf90a4067538cca5f36af29d4f590b102fdae64839e812c2b370cececd1691e04543074df3343df17e5e85087645c690f264b4be668ac9e96089746d786cf3d1116447cea31662771e35202426ebf9d6e0f191b7585616c4fdb13dae137e794298181120846574ebb54e9c9c02391047b38f02bc20ebfb89f7e194354198e19eed229b078a2df16f4f1701e5937b076ac4dba3a5811d912cb3263fd8785496afcce739a1b3fe6cc79ec1491d8d54af327579fcebad1acc86d9d0d5ecbce7e91af801812ba35eb6772ddc48e21093b2f6c0aa20e99641f76b1d49d9dd6001fea94e38886bb517f3cff1edae39f074fb9f0438db628fb641bf76bbf8479589280c96cb2464f77098b80b54a0eab6bcea27705009853f579acb07d7ceb7028418974beca7443abd18d64be654b56bd8ca544d38b358e742e2ac42477ae072fe30fa925de7c85a789a686f1fbaa8f5b87ae495a1646e4c9c5c3b7d8a063a4abe32ed7804d62d3175493bccc18cf0dd3756204373ea2553273c7a22a97c23799744655b0ce08f6f249112cc00f64d2950934b92ebaca7562746c21691189883975ea40c1688985233c6b516452ea83db2c975a6c3ee4348b85cea0211c8c9d15d37359d2a69b71f142a955d69b8d656c9377eaf5020188cd4b656838a25ce629bd78406d13e775fd5a1fcec74dac60342d4da00cb48138f0b3682362ee5553adc52b7894fb1b4c38cf8809bc8575ed06ec21a9bee1d968ef6ee99759a81a18ebd96eef22260ced8bf4f58b58a58724a043f585c56807f6452e699c0d0a6c815e0b9ce5c9acb3cdc51c39a54f34cada6aa4906590c2bb6c4c3ae2492a4317029f6b7f7ff9009c0287adb1eb34389e03b601347c98c14006a5141962ba4c849e2aecac6f7a4f95540b73f880a78fb9da2c92968e4da81bc2973f9e531331c8a43bc77ff0bf9d7114668096864fb22cff053b8b62466eaa11e01f46684c84f4bbb67234a4a475860f93b7ddbd7e7958d94cb03887ea45daf92f25ea5cd153bd8bea2f9085cb6791d498a8c66466fbf341df2ac6e0485bccdfbf87f51481cd9d2615744ee8729cf6b084c0a884117f736bc1f15ef0607f08012d58996016b8f0b9fde9bd06cdb8300746b9fb2191e7a75515068e71271f3825b35cf8191f3a8160005485a6a4bbd50243d5216bb2a361b474d41a6a33f153f9893d3e46cbcb3e5044eb16f0dd7e46ba21b416ab29ebb8a94eaded45716605232186c6752f50d4ab33ef1e480eeca352fc55c75f3c0e3faca83e5ae8cf6bdf6ad9b000543efc288f45ad9fcc8318e368718b7cc32627ad56da1f623d62cdad330421ad82bce7c38c58ff59a6b32f3523caeaaee98544f7d2e90c8c0865a33e563086fddee4fc62b906ba3c63f5b7a8b2756ecf5de16782ad5c4169a5f715eb7ad302deb2462881d343c2c5ee132a8376158457adf9baeb617ca607e3b604c819db5ad9963c4d4fb1613585ef6fee537dbda0dea44e19897d5239530a91c7395aca13712885e3728961d9e2c3d88ba338abe9bdb8bfdbb302acd6487ab40cfd31cd1a53075f8f8cb581246f86eaff59665c5dcfabc9aa8cc96f90787d3230a0a1e52380d99f8f2a6062b95e16c46891932c8ae4a97941b82045aa8c695770322aa189907bcc31d702987e0a2c36383129414027e50fb329494ad7fa01b4b643791f8502295021fcf23c57c655d33e87ba51e7afd02a9c2e42bbc20e84eb3f12edf991d135667a6857691699f6ac70df8e1aa9717ace788d1376ee36c360d390f8de088dc7a289f94ccb9a208efa069184d660974a3eff2747bc63c1bd9fa1fd9e8b9d68f5ae21d772b833a397d57315e1f67cb9aeea8608f171b342cea5966099b7142e01ff8ee9064707ebc14e544deab732bdf9947a9bb37875af3fa159e1afe92e278b5efc378c42b8c4a8c13f0517308f844b7d60d86e940c364cbde73a99014012a3b5cdcff409e75728fb8f346dc813ea293adc3ad15c1a66cfc1cb5d269b01883bf52630b599ad808330a2123cd6b2146feade77977b99eb67753d0db92a803d19bd94f1736ce7d9863bd0c8d5471af004e405d4f5fc188442aef91dcdb17ac0fcdbf6851127e11e7efd09274e5664b18ac0ccdb8f5c399646f0335be7bdc5df3bb0c04975ebf99231e9d0265d1389da097a404fb69fe7250e184fb075b937e1707cbd2f071973126e4e496d0f510f70f357be67246075db980d71bea47de6daf9e37857f8699ac01e728678787c14b51182db1dd6b6b7e2f3d45748b73a8e8b93318493649c1ef43ad37d5f06b8a7ba19c11181486bfa88cc22cbf504203314daf8cf0c404b276f6a4b3df1222e0a768bd3e43ecc26b2876f4630e2eb5b7e8be8b90ed0b6381e43bff11be1872b0692a2709b920a90d539e9bd6713d167a971fcb71e81cffaf5651e41eb30e9113031012d04d6368232f0b29f46f16e0a015db69f26da9485056d82e96063a883b110f83ab073ce08f20895e0f4791857e30e3b4bb2303dfb70b6bd3005336eaaf5f823dd2ee281d17d01211a4ecb5ac57502c750da282f2fa084f5ab44a944edbd5b3cc2476eca9bec30f355fcb67cfe58f2e47fab851d91902bccbade496531bf78a1a51255926b8bd1ef9a5b965aae2027b9a05bb80138b4e2f50384177b0b267d59ad9fd8ab511da6720b6948daab9d83d565d59cb4c90a1999ad0c36c0c1e297b32f53b7e25b744b0b077cc150015e7989082c93475b48df8f1627bc99a2638f4ffcf588eff429053626cd1be11da36c7e9c3858cba3468374d54b5d9e193af95130c6b08a347e9614446644128c70e55dd94a574736eeef4563e4ec9b007e8a081fde6648c70305d73edc42078a5553810982b6164f8712eda8a94560c4d29430cb2635d99df1793e8ec3a526236421cdbbe52ef4743d6659cf1befac19898d04c6abd817a26450cd0d8eb7563e47ab41ec5b886df94091efefaba5fe50114c5c49d8c1edd6fb0b7daa607b5c3c259a34869d92fe7f8940467a81640f96da370d42842f80646691c3ca2f0f6ad1c8e408e9fbffbfa6716c50de3b82bea408374f999910164e7027a4655a6c0ff4e44b573422c357ef2678646c60e100dc799d72cac2b2477306b148b646ed4b24381c07ca2bf274822f106798d587d50fefb6171326cbe0f683796dac4b3ef8cba71488c70ac8f9ad68d47f752b9727edb083034b7c4e5c8ae1f6667c0118d32f764c7cd35f1c429b8bd8962ff3879a10b2e0fef7507ae022724690d2ddfcb528f1dc5b8767121cdd036b845feaaccec7dd21cbe9f167c779d6cbc727f8b5adf357a90307d2fbcb8a06853c9b87f3d77a3a66d11bdd867ccd8bb5eda6885c3dad91da9b7b27eb486d4929acbeac792d41d4e160a94ea5d4c79d43dbdf24aa5390f1467961f2712eb84545b6f8415613c9fad3f70626c4991cd827be86f8a306ec0a8b169fc69b3a13bc6b2b89738c2e821d5d20fbbce9b65d109b72f096b7176c1adc51e7969f20e00d248d132e1a0450dc35841ab4708723da2dc251f9c3b37e0d834cd497883373a1abbe1aa053d37461475a4c76a3c482a74020b6d199dfc211c3c35fdc23cb82db776560451ebc107f5244c543865d3523f14696b9e2c17f5ae0679250db43558d998f8602d99e2385b1f7183e7ff90f1cdcd3589003761483cdd0e2adfac63cbe7560b01c02f5a0927cbd37256d73f6a9f3de2393c74f7a94552f5d134607dc5621d59e5bce3dcf154ff14c929c37d6a305ffb107d4f651ff8f867819a5a5c0c7e9ef2558bb1d817d7889403e84db0f07cfe1d26d9cba8f445019ef3f5acc1b8bf034fbdefb87a35edff38c16e79d9f23624e049ccaccc6645a65a0af76bbe92b70da7ab6c4f85456a9e50aff420877632a24605944ecf76e5a6839c95bb00432591dd801903453131e2c8fd259e6f11e11e30853b1688bd8650205056d1a4ff08b44725b6c3985b59772e7e30f82e695447621e6ad0acfcaa17a63feb034fb3ede48b242578311b617459393249ef9b2fa1b19740378d642e7b4e82b32eff47ce4fa27198c3981e79c6e89f01432b7734bfe439389f7f470396f43f881bccf075279b18c8c7ac6e8a87a73479212885abbc04f7cec1f048bedf0905327685ce59a8b0911964b2ac9b3310b17833e8a8ab48bd6ff9d7d1b171b5f2c7802c9f4c4ca105b9cc3474db31cfa82e8f8d924f94c1d43c85e4cc2f558603f925706c5ad4270a0da6fe7a330fad33db90817d5289ceab850e049f48f264bd7ab6fb783496c05822900dd6b0a022d104e53c62642e473d1c2b2565d121de8b83a2cbcb2cd14b98dbad6a30cb6cff75a36ee49d9205f3f738816d34232eab3eae14ecdf5f634bad5a8a3b7863c8a2fa4d1a113e8146274f09b18f716423ffefa9d753f55fe178220126678bb62f8d04ed824cb3179b9a5555fbbbb25d4c1f8a80d43d6e9557fe2fa55cd279251dfc7e4f09214ed7a556709a425670daaf6b9dcf4daf66d3b9cf47a2f934a7f0630df8b0a47809a0d97469d88dedc66b72af6853bc43cb8b3e27aa16c02ddc62500f54cd2c090fa6fef80db7f85d1083938c3f0ccb5571fed8610a57946efc35449c21641e18e208cfe7b9b186ca6e8d9febe5de70e28b932306d9e825faf6761045d04aeb52f87726207a064cf2f52fd1430292a6b28ecaaeb83926352905a95ccdd9240d9e4d87c467582c25d292e22120cf65768ee862de47d0af53b210553aa79da87796241bae9ff098dc03419f4367527bc79791b287bd52f21498b390a6055addcc333207b96252cc8cc0ac9e6ceea893ad3f207f051003dc99e95c800bdbd834a54b71f98aeb5f9ca120b172e2343a13318eabe2c17191dad2fc15baa2386c509eec8b42ab7fc76f88d035a83dacd04f1b1928bd0f911f6d71203ee29820f464da081eaa513dd44c62c9a073a0873bbcaec22b55b95968dfbe790e3dbf3ef1088ed31c13a43f8954b35a7690ce0fb19005049b8e278dddc3df6e72231b4a2170a62d92d6f79c86f4b83f422faa082b561703d1460c41b38c832f3759331ef3fea3418cbf143662e446855dbccebaa371aff56885b969f3b14df67d18503977da7e5e7f22086e8ce954d70d3551f3f14fa0749487da86d56c3de65db692f08279e4db9debe5eda784aa330930c854da71e2756854c4f7e1204ed8d4a59fd0ab000678c6bb13ef1f2879f7f2f12715d27f9ed927cc69551213af0fa1d6c1959e9dbe7f79cad67236f5899504cb7f22130a9f0362d0b3aca9900d0db5fdcb0dbf46301b7e7be3ab97660281144fb3b3bae47cff254e67f2f5e143dc3c21b73ba1ec6861eb3cc5168cc67a8026360728ef70f31f2757ad2c5ee5d01c68f79c58e034737fca7a3f13b2f737fd0da3e8bc8884b01127815d0bc3408dd8a3f26bcd2739b4dd12f0b8ba973b8767c0510265aca88db61c69c43240b0f097bc16527083dccdec96dad4193fe648d90f3c051dfeb7146316f0286faf0ef3681193ea4ca451b9870ee08f7423839b9aae8eac71f5e7f9d129288ef6708204e5e2f3c1c3f53e734f83dcdafeebde75c56658ad8a3c36e382c7ef4833f652a02f9b9c2e1f415572849b0b4394590909f937f9ace918335a4324b52470d41bb07020447ee35e2e942c241e0e6c9d803295c61b2ab2d8737f50cceb6d10392add8dc40dcca8ae3386c1a277e8f7a355d763901903e0498072013b5f7c6dc04f5f6651e42369fe49c111eebc33f0281811f7b4122bebd2b689d34fbf2c43a94700f764a365ee77f0088989b156fb431faed1a613161d45780aedd07bf33a8d1cd763d470010c506760bf9db34468a4106b7cf3181d7284c8e821d5cee8805addf9f197513a3af7ceb2c845086622920467428e5e858e1b328f84e749333c517658782df965b2a95d0f91604be2c91ed06b35c619a2a83930457ae7c60521f35f4df6b8cc70c1599f2a5d6e63ecac17458baaf111ed3e3ba89fccc30ff3739f870e811e1e692ba1e9b38286202b3e6a4cb3d029840e5d4f526d2c78903e9f112711e7b1275afbcf4849cc97ef2dea84ad082e880a4c4f1b9541fd07055d85deed24e0f9f5237cf536eb080c9ef0a3b938e779908c260ac8409972a693e88ffedca5619919e0a3cd1e05ca04b42d28ff54baad5200b308f23d3c25b58f1f3cb74fdf7dc23d471e8e73ac7442801d65b456a50db59abaa4e6daeab358088053e745bad7287b11728f12fdd9b70a6e8f2b1326348fc50c7af2292470d827d15239cd881a3d277289445c10333dcbeb9f904fcdea968c563b9e04ada51e52db8161d0206f493f20d78465f95f1b0b9f6140fea619439a42d33498488b33b0c44ed6535e0f63f73f2d34c394a8fc6990f72ff8df9cbe34d1e6778946a5d82d7fd7c000200bd3d57cd639d685a94098f47411410a320e7b942b9c9cc9506621c5cc12935adb4466e456a34c3c70e7c7a90b9fb68381a0212d653ddf3624321c9b1684025bf93992f9f2cf3d830a2bc81d2da8bb30c7674090800c30d12a254d02e89d68e91affc67396e0a473aa4534db89479af2ac3844390a0e2fa4f2a5cc5d2d4c97af6a43f9f5ccf70f31d339dc27b825e7015a5bbde4183785577cc620457ff30f537fcbfc660117832f93933e058a1b147237956b5944ff8b9400c02dbedc742357e14211c559cc65894322ca31bb1d0db871bbb19a0fa604c7bd242bb66793873f06e68ba6a57ed4b9c81cc01e06c091525c4d7f6217f1fb1815a61e680267e49df08c09ebb78ae7294716b59f5b1f927a9023fae0cd3d87f676d428386ed56f59a5ac09c9004db7ca50f7bfd543465792b795ab9a089b454ae872fa175640797a2e3d2aaf6e6dfa71a051c6cf3077cd30ad3a9ec9073733802ff878d4fb8174d25ba9710a0c9f82df060036d99c59b2eed60a515559b3ab201309ea65bdeffe08e12a93daf440b9064129c8fa848583c677cf407bb6d38e81522e3e490067e4d6a2c28e1a236e6b93291fcab624e6e5561506b0e4c8f80fc2f3c9c918440bd386a75d28ac688b0ae8883508dc6fc418fe16553f1e20127d9cffe4b2512fb7455b4cddb94031175e85bc0f6568ba178f7c8093be56e97b994c7024f7300a6ac1f04e85b230f7128302d7ee09e22d73029ce9aab81b1b0f11c7ca2e5e58cd37581ef89d2881590e5cacb28e7952d62a4ab84a60f05121c8f815ff20875069f099c7a6e9aade08736d77840ed6ff45eca8ce7762dd6d5bbd14d9fa4657f6caa2a00fc273fe905295f193c96f536219e5b97bb1f405a4a258df1f5461f0ca54481f8dc9f650d6411ca8d9cd88afe9b4791d8a7f5e1f974d5c57dabd125902486ce04ae15c6dd03a3c4dbfa22115559177c5b703a42d3eebcf44d95bfd1ef490d17f5739dc136f951f4779fc48954fb1a933afc7f114ec9a6f75a039a8631c166006e1b34aaa5a664066e9246e92e16b3a937e1c0cc9189bc503a61b1ab089e383ff860543ebb3118b781e824111da4c6d17a61642fc0b9fa5592968b03dedef7b6837b5c6a4dee7f56e1b08cf3fa788a531dc4d094ef9ec69f6d2c2ba98fd21e27d7729979749d1abdce2fe0f77b83140bcd82533ee1716a62f8b3e1231e9073670372dfade115e8742af3fba4311757cdf8787e2c8e9c8e272e9dec3d58f12b373635db29914aa4b24bb2f99df87b6b9f839a9a9c13b0b33c301f5e7800211a2eb84ae2c7c8ac091625d9579fdb8a5bccafc9632f748f5a3acf3c2ab15512cff69f9ca2db79257a073ec16520f159471d8f4cf7ecc6b0cec6a31faa0c43a2328f78274e1bf75b885ffad599fb910cb0913cb0373dc48c1fd6dba4413a90565c1237de5ed331de168810cd7c63f8c46c479dbc48c02419aab9e279aaaa148de89c857c1eb3a6f95d43b97490be83da3d8114fb248aea20b4b7ab515f2865f5797190a05f6a664ced2a5064f18a72f28826177af0a6da1c46be44dfe0f7b72dbc541cc6f8ca135f529b20d8a0ab41b98e2169266eedfd0fad3895327fd877684c53ce07c1c69c32c6fa0451f750a7946b32aea7852ae32668574eb1d46b6dd7baf56e5394a371939fd7a279dd0725c2fcc9b8b2c1696acc7b9cbf0d54db3b7943dc70bf19e82eb1e85d93e023e88e32449a0be5f3682e16f9cbae199ec89f920db84458a93318092e657f7bb0d55c03862afde5d1651b8d77cf970e541cf216c7979f5494affedc50a8f7283bf0cd257a6d0652e4438f5e927f234313cc3de3c25e92ec58851bef5c427852db87ae3f067609f928346a7e08b8277ad88856950490eea9e25eac7f9a1c2f7d1dbd136b9ff0556e5059f244c6a763e40de774e9a406b8ba53cb7fe2d651606157b677c25895f2fc0c4fd76f40c0e38097ca213ffcfcdbcaa7709fafeb1085be1b0a5c63531e5b91fe3d37c2da578aed8d35eba252d887dab39b0a4c5862824ba8b41992919bfc098560305bc88907012039b3a6fec47b52974ad4a4872e4e9ed7d7d4e67f46059b5249d78d9560f00b52228567f40dfa9b0d1b41c363100724e52761505b0981a9d59773cbf170b7d79971dcf7baeee61915e5e9b5d3d279fa286f9363784e9962edd663f1c9003e8595f9b0a58b2dc8802f5e464e63ecd19cd0078d4caa7dbbedbfc07dc6f25f6e13cd3322d2b860b86c662c8659e56d215e86d7960d2c9a4218c00f32ec714cab61eec28010f28befe782f5ceffe70e3cac4870dd832de9b3f666b9ead63e4d270e6686778ca503fc9fd8782738a4ac8bb011fea6bcfc0f74f1342614ffbaee103221bacfb262d61bc521bea4d995853393f633dd448e35e4c1084194c09a5a383b035350d8f1b06a8e2318077d9378b3d99d0cb368ff64a892cec2f2c0bb46a028ebf8ddf7b63c99542ccd56cfbd192a66a428b4bfbf719952fd983e7c82e7738d20c5ee51193d7c5abf590e076b04b67ccf37e472e716e0114ba5a037e4d9612546943f21aaf759381bfe91b8d157eb763cbbcf4f33da68e0d21d5124a7b613cd5eef3b94d8c977640908a418b1e315475894f5b4b8a4e337d3f095aa2bd06b4454e101d80b58891de49fdd2ab56d5c5fc69c3e99bb0f400731aed5d0f010682aa7bb2ad6c59fff1dd3d04792709db85269cfb998701e05422e7d540b6fd050e59954bb6ad64382fc67f79c615192ac74835c3068780d111384c6c5bdd51e760b0a09b1560dab80d7b663f9efe7f46b4d9fd1a21b3d56b849d84d52e34e90b38f2270e72b27c007d69b7d8539d41bd4a47a8371282bc42e11681d613f0bbdb73797a3f6b0873024386516028f41b919bca6db1240fa045273dfddbbcf4f15593d4b76c99c7e321fd5bb460cf19eb491896515f0a2272027ea88b86d44cc83fc8225ae9b11396ddf1969210ed1974edacbe81c11b3d900b7d922513a88e0ef8d8e5bf24ea53c607911cf63d33f4e776195c2aac44057cc236cd65a6ef1054222b5d4b8e0236ac45b95030abe2b5a052af9df0fa437d28523c2915de692e04bd3dc85cb73fa2d81c5b523e26f98a64c3cdd5b5fa3f2360494ce0f0210564fc821a95b3e5595f2ee12f91b57fce14344d532af1825bfb58b684453f0617ed7cb90e36a75eeb2fbb2a7ba38d049e3fd1e2844aa0ba20610ef46b81af2f8b9e6c78052e656cb0ed2298aca1914f679ce2b7160bdc376903f0bb2fee59ed98c5f8a9bfe411d14f8b256921057024cb6828190e583f0c0c6f153f16bad763c0a14be2d4dfed39fc18b35a3aa1745aad1cee2084dba79deaba6ef8b3f971dc3e817d88ec90c45224a315d850e9e4454533743ed1d14e789df6ac2457c8c8705e6b3647e9be0dbc60aea923aa7b7a45287cfacefe8f45a64fd8aed52de707f403d55e8e82d6640ee7bf5041ad18fa1d2905a861d4937de23fe8381fac85299764401712a8feb9e3a0584e0fce0a54094d132a6574b13b35a4706f3578ef235814137aad0bb0a48e5f78b8ad01c9bac2cfa74b53d8c336c319eb5c385b4dd4417436afcbd409b339e3d5ab18aede1514bb9bfb705e4bc10e2b2569a9e879dda2673d05c4e363cc427fcc5027c0aee2abf3facb8eb03a5b5d88b85a1b5b37365c09b81d22b2bdceafaa97feca9e0a2ab86ae6759d103672fa9b2675cfea89fd9443d5bf26bda17d95aeae67e5ba9d2109c637b9bbda44d1fa02cb4e1190f05c47a520889b5b5b4d90f3bea55655cf321933fa291a5f723157adfa1380cd9666e49e7db2307fd289a803ed4021ab2a4648818b60706ee2cc999c6f9d77b92b8a249c0a547b3dfb2d86ca84ffd0f591ab8254e294323ffbc7c3c7218d023316c43ddea2c1df02e50c3eb83b939fefc3206c5d6d883314f02e72894e3b96f33c4b8df3e33f1591bf0a3dc5319f36845b60b59e2d756dfd0e0282a971a56b0a99aae2964ae814649d40a1ed4397854c444b2d08d6e58a02917b01a6bd7017d954d3ea4c5455567c56adbcb4b9b544ad2ea778915a402bb26983db8e074b671635a82434ab5c9b7de8260464b76364098bcb796ba1c74f37db80daee2d19aa1309b2eb52f0b3688a7eb55e87143e3eb392dbcaca1013b0ba62ee5953e14e77399d3010782729b47e546c245f36eea7fba5098457a23ec878df32ca14020133a9acfa971b827464bf89e796a7536d4d61e9601508c7ee70d5aef6b3d7fdb520a0fb7c21e806fba7747a6a00753e0b6a766c45a6ef25222948e2d6ed4c44d3ac108f970f7e3ea084bcbfb9424eb90dca04185d0a83b6107ecfc58544a1053e78a9cc1b41ccdbb8e01e112cb1426b5735e0cc0c98bf36e630a8e936d546256abd4683ffc31e17f40aaa58b33921ed0013bfc35b3c7d034fe07fefcd03495836f3bd185f586d39e6efb49ff2cc3ce0d98a67cc0e710c513f0cf2908f180afd6077d997d5c2fa51964f36ad0558f8f3d4806b5a18ca0bdea516c2a5ca24d8529a3e707e155ad95394825169078e2f91fb66fc00459a799120fa89ce17db86eb9652e46d147f00a71dd0ab397e38a4a761376bf6f8cc0c0cc5c48294210a6265f1e1057854ea4f4743151c5d3f26792c52e7cd46d42d7249d423d6a90ea511666ebcd21161c61939c512dad592dc8ea630c7af93646b1a4e18e0bc8c7318ebd3bf3d78d14c2c868aeb8b62fd4a996da632241fca740792ef44edb0bb81a2fcbd5ab90001851256476e044ac55de17a6b21cf0fa68c517f3805e3ada25c70452c81d27770138a6750bd94fea21bac8b8bd9884fe202e76e8d518264d1156bb72d76af78b44358a642b23d50d37c79263f87d84e0acb1a3bba5655492753b8b1715dd2fe549c7ba37535b677f07a469bca32ae45d41e9b380a01ec45b2430ef0301f88f41fcbce53edc7b5c94c7ad1b52677381fa11636587f2b7cf512986e64c23048dc97006023192c06d68f34431df25064850befc9519f9a15306ff1b0e6bc62fcb21257453adcc56d5374902f8064cfd28d67ef6083d4ca5a499df915c0bff36b6184a9dac5e8f6882e49439497c31676262e6b2247059924dbfb3a0d6335ca35e8b4b0e281f173842a2322dc6fa12c504b292d00cbba74211ea3cc574f6733efeaf9f1cbcdb4ae9ddd6bfa9cef49f9d30b1bfcfecfeafed4351597fcc252b00787faf5a92ff92ce6df1e8579feee2c8f3fbd4eadb4fbb687ab363137d4a085d2886f3d40bf3523f606ea6fbd017a6cd036ca6a5fffea8659bbf34241ebc196d4794f710951a1d61a5a67f42990970e73a4b95b43c5dbf23074e4b68b53dbf476cad756c18e0c95477303cd11985834b49d124a01a1c3e46ff7fcbfdf38eb803d478671b1b3e7e5a77e3107b4c42a68a2c1bdefbd5e6ba26c0353aeeafbd2a2e5437f55efad74447589f4bd149f2e31bda56a74a965f06a0a57cbb12c0015aaa299e3bf94e67cd1a1605462589c883f9b3a5b130802e0d521407ae4e80b8ad4a481d0ea190ec4647bfdc888b8bda56fb07a9a1a2c82de503f6ee6d0eb403a5cf31bd7f8b935fb1c04dc191948e55495601e2c2225ab8cf3be224545f3f4dda67c619bcf3a0818183abfcef2a1b849b9debb241fe55d4dc0150f3a71c9a024eb3be6a2feea49bb58c78ac1461a48520b757f9e56984f51f72a56b667118c37f47aac393638b17f3296bf0e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
