<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"015ccb62d94a8be58403cf4fd2494e1eb7f46675f72ee3a797b5469365f9616c05e3e3ea0a73d8902a6314c59bb91f834aae0dd19b275e192c93fc5710e472ed0b7a56146bb0acaef38c75699dab077ebf90f7f0d4f6c343f375d363819f806a3e6c3430c9abfb9ac08a890c6910c89238f4d6b0179c32d61487eea0e87a60c1f6ea21c70b3a27e713a69c3118f609ff200e6ecebe3393615265d3aac5e1eb58d4c6e64c3daf78599c56a4a42ce3afbbfaee8f5a14697725adedd3f4a5832e00ac7eb9345c14b90bad73fecd16720e9095c96174ba94674b67a190ea0ca324614ea71116ef89aa779c56f6b419056f0a3ce246f540e4d4cf11579851842dd76a46b87c349f533e98747dfa172a9cdfae06f53a2443240fb45e2ffecc136b3b4684ca943f17cc6e37c07addd92f95c496f5402b1c7bb4d55326bf17d202e2b94602a326b2e594219fdc1b308711a0422f623b5cab058683f3fae5e9c61b40731512fa222ad3c511a48cdde45e04e53d4ec7d81a15d1306180daec63a6be68a556de6c00a81eb1534bb4a2687e42337584498445246c1644e1f1bc9748332e2516ded1aaafc2f8bb486700c1e6513154978eb3ad4da08404348470960bfd7d662cac08c95d461b48fe98b9b60b36c18304c2bdeec4a260591e0905086f8a6200a57672dcc4ee59109f6792fc71e6299433305f617a8e528f11ca91966f118dda09d8602adbaa83dda89b7a62c81ccf0fa5fca9ad55ffdfb46924714010289895634131c7f4d5f3ed6d795b6daed07e799ea42fe014be284a1d4c180a7672edb244d666f36a116e8c0690595ee41656385d7d46ef022ad8fdc2c10c3bf1563a085d8b1d6673d2e16289d98c3a7ac64bd13b32db5f0a9945aaec8957db594933ed75076206fb169a2737bc8dd3262135439e3a8507dff9f3bdcf43017f01486623476efbb1fc7d53252f80e25e09be49f622d4c92fd9a158c62c9a4d633d2a5ad58713f6c6e0ee25af261f35336f4dca437fedc9f9516399062466bbd6e9b43390bb2d87835be59a73027bb3da034ecbfd7b8b0ac17d44c30ea101605436054a7b1036fedeb358e7abb0ce86a42336ddabcb8456d09ef8d8c0f9485195a5d1d6dd0bc782d774431360813e15ceea87c04f3adf9593ef648fd98e8b6271c21c4dd73e1447a716df745132a953de3acbfc85e78148e31d09db077c47c28e97bf452a8eee96c8af3eb6af2a96a1d680f9dc1fd0b0dd299683eab9efa7c71ef82cd82a2c67c9590584bfac618d11c9c1fb4cb1647cb0a0246e7f1f5e5d9312436c4e3849b9a169e7d28c3cc658b3d7d9564a8ca568adaabb669e780a283c9995da192642167c259ab46849a0cd981ef6026281ecfbe53aead98acac17c0f46808c304482873fa09f1ab792b66829b166260799706479b66dd26e4238fae4e9fac587840905a1dd50755cdab503444a4455406b9deb08b5a04071c0fe93bdb3673c7cf900abcfc877abf594965fd5a438fd4ee5838bd021d83e0ab4d029f98395d270b4e34f8f66846bc610c30d38d0966671ed85f66b0b850a1614d46833c488403e3158c96d89d6cd68f6b1bc2ba6406f2e8241839296fabe4f8cb36c23e066da69b5240e65e3a3ef0c825a8b3f217950bdd23a4b603cfe9f64652b289b38594ac108c60c0fad4c5759307ad7413d501ba4196e617f851ca801d6107a2b3d1ccc07f8497c651ae963c841975633733defa5d1eae5dda470cad2a204425a086b0d329766154fa21d74fa6bb9004bfa927f6b33d712cf4a5d4f84034a4e2e36039aeacfb8023f9a1299f19db57f4691443fbe19b60afb680ecfa6ed61f4821417720f7ab9bc0266f74bacf2ae53bdab0048fabd31885b760ce4b1c07edff94899e4b2c57f33c072e7d4ba53e6d13749b08b381cb4287f65fec69de277e70fa776b8030922f7cb26c256fde55d2085145409c11f5cbd0c4352f1476f7a0413d3d7255b9d01cb841ad7163baa8b6882ba4a578d44606d813a1c5d0f1b9c5e05f5c77788297ded63c67bfad959e35eab7697e16dd514359a4b82fe986c640595328a2ec47490e679ca05372b8b5f069a36f66d42cd12c7130abc4c745ebd286c2399ab085d46bf11b0ff851e8bca682cbda13d8de64b607f6b92d98e3ece3dfb559b63119970a59df096e6a179e0359a483794aaeb4b0a0169606064a15755020256fdb625a131467713d543ccfe74617d77294ac84d5de67add62f3eeee4a87930655ea393a247e3e051765060bf0212e46a087a15e3019e4ca0771765c139097db20967b99d3fb0ee64ae099cbbe34275e5bf6397146acaff8afa172e0e75c1fe1f9724d4d6b61a168467e00ab87e47a19f68da5c4a058577f9084bb1f13fe764b9d01c74a8e2713a7a5988f3cf0d0b9516d444b478f9d1ae12399dba1cc8aa4fdece95bd1c11343161133cce50f9ea87ddc824fdab938373c03a6421f4d890ace6705c2c5ad5b82a2a376391704c7a34052d9bdb1fe09e002bc40fb3b300aed028f7647a6d3fcd9259286b11f754cedd819d9d9625c008edf385d2295d0f3c638f0c3dc60f1482b2c3be1d95ce98baaac05c76c8b2fb9b39d98ee115fc947b8633e1739493c0234ac53fc322af4d56764775573abc988d99fabd5db48e76f97cc6bcddc7ee6417c28ae84b393d5f669628683735acae89d6671d40126a5dacbf47ee18bdfecab07d5afa1c1f1d3d022a70ecff90e4caab29b67189ef8417a286932cd343e162ab12b801a91569b0b9a20551b2c02999d0e732ee0f5c0ce5b9c318828c22427b921bb9444405047e3a31970d833736d66908e709f7ee81c7c41081b325638473b1920ffde288af05decf47b738f8d0d9bde265064d09d1a7a11819601878a9234897658fd9cd7b45471080b4cda71ab2cb663d68bf66f6605475348015c6b9fe4d69a8009b805adbb8764106ef5547071288113b21836428313a003cc2e3eab9f827a6e154aa0f89ffd81ca9120c141e51864503c06d46415c963c828c25e2eb124ddaad8f7233f5742eb21c2f1770d931bb1e0b48cb1df1aad7d5a2399f44a87d9b48fa5ef24792219de438604717edd62336b783d4dc94984483c56908f357ce9484b3a2757a196814e31f08b0b6617f6def086f5631fe486b4a08605e781ec9757faa2232c21773e113d58ec5282307ab43d2db2b86ef1d3da4cdc37636ecbb739e0c32cd41e806c3dddca1f6a9803efccb6051335befb2c16fc3ddf4fca4ba4d0918d521933b6006348719d1ece0738e5b445c8a494a085295371c99d8f55527c8ba46fc18657131fdd0c917a4db9d7fec9b6b150e7f2ac30946148d4b16481d6aa7eb6e17e8306c670e7b5530407eb5c96d87726b666d59ba0c6126d88ba32097ad4dec14acf737327d7709338b456fef986077c781842af1c46e468a927d218c394b1b1abf59d1bfae24d2057c005711dea360159ba4b518711069a064f6d88d02887ed5d863fdd39658d72d8bc24b8bf9f4ee70c6c182d71a9b6aa3b55ba06d1d07077d72f0e10435b3d9729a3aa512499323ce83557430d6e40c8b3ef46be098de3ee77e112ec33c799a26ca2a4a62ada786bc9c8623b3bf6f9b0b0b231ba795fc528156c7ba5ea6af7ee2bbd23eae1ab34563b15cff7b18c7027bf07f8be7b84b62bf554e2d4a6ce5fdfb0596e1d9ef96b307ea0c46a0d47d08e28c9c98291b75c3b2f9acb1e1b89d3e6a2c74978ae35fb345b1edca1daa1b55a4bb4c89ae2fc6fecf45cd1604ac614f01172050eab1ac0404caec4198acba465d0acb2e5063a450b260d99f1732d8e9be6695228382df827643fd5738f4ddf0e2b31f88018627a49c473ec18000ea30978057b86aec853bec76f57c8756c5b7828477d6f2a141e641636dab80e2379c83bedff9f64b69c191138376398f32ab71f0ae6f63b784a0c748d76d02c58b15c4ea901dee3c6936040f1146439a1d85e8d52ca76242e7a3b4293c00819c4286b4fb0b7df9d6abafee650229a75590d4cc00824acf3f4e98fc4d2fb3268d9d545e243b626fa8a6c7c7db45ea9b00face3406d19ddfcffbb7848578ddbff105c8c0be8ff01b7948d0c35dbf11e7462ff08b77816835f9290bfa04f4c754b33aa4c35f2cdd8a8dc2f17501f16b94bae7a625d5f71ae7c673e8e663d13c269bfade55847ba6071b9535f821c5fff433d1bd590b57d2fefe566ed60c12102248b83c0a94a919daf3fa0b6544c0f3f22ea21868d09a493fa7463db33f799edce7af9bad14bb1d78d49552ee0ed6212a0c0870169438649577569382883153f5f81ed09d58d28578ec912c3b600ed01946f089f0b957f315e25c72cfdee62ae6fa4a4b4c27fd495b01f20ec701c56ba9f996e3d117772df229bc22e0ada96ca6e4b3ad648c702828648a25e14e0695dcfd4dadfcd9dc8d454a0b402c4865dab85a6ec7090b0e4668cae3ef7ac9a0d13382a74a74a9dd9e5500529d296aded5174ece5fd74874eb68797d2b1735058c95370a16776d9d2215a513eb15c8caeba4823fc325ae44bfc1a5aad2d5bc9109c2ccc0bbbc8514b164601c7143a24daaba1df5915c8a4354754535adb84ea33778169f0b801fa69b103b1f912a167e91707a7466c21fe5c8b1748524e00714c427714d17dd229e6b35d05ed1052db74a709d79078df44f5eb6b7a4c0738c271f4dc9005cb4f49600cd5fb8c8212d94dd4e9649b7c4f106724c06220c571c3e245bde023aeb8c92714e3ef6572ca1044b1c59a9dc4af697ebb2f026fe2ab1cd5c1368f5c983b3862fd2021c3c82102c981512f388a069df9e0179b253c89ddaf1eabcbe2ac20fad7538c81c523b4c84bcd81512499462ec9144fc9f8d9832ac95f214c9d1fd5f93a8846a60ba28dc5a6a50e2b6d3d51bf20f7c75d2ebcfc97f892896f933de02eb8d0220b422fed3add4ca895ddf368bfc70328f486b35e0e5d37c74d5e402bfe28a34a76e2df21d2a7a4420dc326c1a70145cdd583ab485d2ea6c2cd758b6c198e279f2b067f792bbde4a2330ddd8491e7123af9fb4effeed1d47011cdc57d2d19c1e23282f6f57ecb97ab59bfc9135adf53bf89e57a5a39b1b184f6e829c4b6f6ebcf02a1ea643f03b8ae08f02b6d01d06fcd4ea6183c8957f00b11114744ce0f8cbc9f21462f889d033c5bccaf5d98979d5a1339b89a50c782dd0581650b4c0c676130dbf960755506d419e748a6a8670f3a22823226cbc03d07a53b5e07d5443b9e288f19fa7ececc3ae50de4ab42da53af6c769731faf28d21b8b68c28de3a45e04ad5c46aaa82a6ed43867c75e7f5cb56082f9885dfdf3db083f8b8b87c3c8860b15a4003a517a20a39fe71c95f24d0ec34f69d2779893ee9b5d63f17af620cd9a4167819b0080c27cc0fbf0da22e08ba61c5b2e69772b8bc89f58825061c4cdb4d3830ce54363597b1ab0ecd6b91bee9357ce8a0a8a01f3f703162f816a34585cc224ea3b0b2a4bc4ae5cd48386cb202d99935858f410f9a1426013683a69c680dc96606c51bfb4a2e6b8f888eb75c3712b9ef049534e386c8a4811f2942e7b9ec8f7f306f97a4ffab807b8b8f015ad17abf5ef63849c30e47c883552c9bd7ab0e49d41a6ba93459b7429a9e294e46bf08a72daeeca7ec10133f638cd5712d0122da4273a1560687114cce64fbec7fdfc2717361865f8a72ab0b3fdd4d2f8028202ec75cd4134ff53012185280ebf53c9d50aec6ffe4af306c3cfa45f912df1fea1fa093b5960602db0b9c46ebc97e3f4164100258597a971bd188f44ba7698542c897b7296d145f847ae2b38e6d92c9094fee20d8bb60122d819cb94799cd159917238362192ba688b19957e68046e127108e2cc994c3295bc3f4ffef5e4599579a5fa2821a2e0ecbc59daf4b45a9e7cbf96864d9bc6ae802fc74752663a26cb6bfd4127d10951376b34a5ec12c59333f1f331590ff641554d319c5a87a8461ef93918df567d0701a57e6f566bfb5f4d15e5110d0da329f40cde2abc1f004077c15845ce6281526deb448d2ca464e5da225bd5a5527015789c8b1dfef20d94bd396f55661366f05e6c312ab1f05d57dd08f401e9725e686e759820453e683ea105f5c3defe0f107b1636494a49c7c403a062ad844114809ba0159016fb0fc7ef0b3726811cf98a8dca0055e9edfb989c3683799ae009f92cf29fde3596402a014b5b7426dcd1f8c9bba613496bf7c3f9ccda0eee78509c52a0d9f0ba22b959c243048dcae2222f6967c7ceb0d12043c66c063e103707de135de649775f4ec420a77742858271131d3a97da80e7e7e11c7dd8899fb694da2827a33e14c0a632e3cdf39668c5c9e44e00c9e5b2a1a413cc05799708b23a98b991d6e0e1907a09e9aa4295a5478d73655fb070cda8355797829a6d2b1cec551319ea95b8a4bf8dd06780dd53f7417563649fe38d456f6350624c26b7cc5b24735c0fda6425b8d728b428ae4d40d3dc38acc1d91f96117d8bc64cdfb0b314fff5c6c45fe5aab3f0267099cab4fd77f96f9bb7945820eb5a4c913899d5b79a5d505c2d669c4a99f3673bac1105da849023398eea490d8b113ce2a0607ba54bf6922baf11a70cb386dde6d6268f32062e6961a583c537f8b6403f42e4d211bcffdabffe9e52b22de918512b51360d10ca4c20d8a0be58783c15dccd806078dabc6fa64bb7b8b4f57ac714c5f2c547699e6766c022b11c679e3d5f01cff3f713f2fd30bbd29067afbd10b871c24380a452b9cdb4bfc0f60879b5530f9d5c3dfc895c363e381b8205c19958b849702a6538034fc9c2dece16eac5ea5b3f3b695245bd571684135f6d089b92f6dae5141495b8d06f232893bd3bb1a7baf2fec0834e07be86e6ab8a436e5d2c81d0971a273946782595a9f3fd6a8f568ace2a8b6d506131130f30abe6ac47b5cdb35cd0fc37d98777ecb8247612fdd976f4259aba18214509f48f2e813f881b43bfa0b1c226b0834fecaa625c1a395088b0b08b1835dc93aae0a95bad833bd53449e8161ab434556246e1f253d7178eae3dbbfacfe028a8d7b74c583f5b6e5964762df149fd4bc7a09073229904660503252b5267b468042bcd3778fc57ae13a6030eff60cc25f9c1c9001fb7059998bf6d74b8647136dc9a7ecc8d5eda48b758424a88dce56718f3bb1256921074d310ec2cee38851bf259670a4b03072fbbaf40841642d97a03cda9835b998b4cf3420030ab76a5b6131921304e936b849a32e3d31efea653f8d6d70774551b7fa306d0010b81d8d2980b37f6327591a414a42a243118751d70b61bb658e4118f24eaa5d4f87782ad362cfb091de94dc89f1ba785b468ee14a40e620566970765ec06bc12ef257085b003c48f8d3fad7226064d3d961da824b68cc5ba2599008a8a6c1e2654172aa8fa1ccebb18f1e8d1c00501054303994cdc6b43eca6569bace330b8086dc5c0584b907ccfbded20cf4b6019969cd7a790d079d27960ec1647c1e190e10496eea39c5c8e88043efbbc69a00bf809c476d7203ae44945cd373d408693ab62e9fba4721506f5a4172f6160dc377bb868b197e6ad69142626cd3522dac7f4140c51d88264e7b84ca78c955f27d1d64c5d6df062184d9b0ee0a3c7ab620a45fdbb6affe0336987e578558318ba401752126a358e1d734fca57c481ae725e4346414395f9bb8b79b60e23a97f68edd42690d5f8b2f61b958b758e73feb1a5d1e42634cacb03e6e7459f05fe37fd60f937c9b206e9a07a6a002dbd963f2395bf3863984c170aef9a336cfc8df52bd1594e136303582c91365a251e5d2451fd20b339db262cd1ca1e60067ba9970440be117e45d7d290f7c8f5ba99ede62ea7173129c3788af2a81508cf0fa420f1842680b9c45420743ca3e4c42199be5011d82a0d2aff4455778ada75878a7689eb018645a1254b7a638c3957b8ec1c1082be4fa754715765a5dd71ba804ce9fcd05acdbcbd528d54e462d35823bb5cbc226e26fb14e686f46594814ff0d7320f24c05cd32f5385fad03c9b74cda656366682f91b5902ffec84232a3fc5ab5732959f922d3ddc53d9ec3c04d165301cc7ee2c8921dde83c1da7ab1d868159a8e6805f094000c28fc3ad21a22d39fc0c412b7789f4d0dcf8fbc0be114240ad7cb1f25fad8343e36f0e1584f761e197f47690db3b9621a0734f1ca24f37bfb8090105787b24e3df63d12ce4a2ae7bf9e8d09c14aa2f765eeb717033739ffd50687ba45b06324587a9d7922634a8ecd39c66b19cd44bea8b204b0e767ae9e25fe602feb40be1d91a904d5ef9f9f9013062e8683df431372ca625db7f5d37b377f8e8e40ad326b25b8c3f58231686692cd136ee707a810748d2c39eb83545c4531e40cc31345f91833a48bb04780175ce82ac6e5cdcd82edaff594ba95fc5c4b4d0a09faa99b2925cd3efa215484783c5ffb6ca161d8f3c2172ce3e25eadfa1a1c8d4085b14315589a57ec6db9fea3005ce655f2026ba077eb0c3dc6ba6d5bbb5f29ac96ea0c11b806a6108973ed60101bbe12977b0629e1f080725e54706cdff313dec370e33d887c8a2e1f7e2d0353771915344e4caea8486ab87ece3fca189f351cf6af1ed78e0659a428ba6775911271e7c2237c7bc7a969da9ac324752db09f503d265d8bc1c8322cc58ed04b34f5eb8c298ab87f18ff593bb4a0ea395eb2dc2b721f29b52c391d0932bbffc006f68f0492eafd086ef66f33c9ad26c7e7135040bf4d7b3386dfebfdf05ed5d5031f833fd3a51c0eead8825e054b6326287e2ae0df8f36236d296b4283ca1f46d36dbe25f44cf69e3e8d6d17a65f053ddab1d0f51051f3a224890a659096c79c376faa3ae1ddd41822e8e6e9bcda44bedd6466ff582cf3cbf325c0087f821fdf696adf1f1f96ac0734e460d9bed23682b0a60047700802799b4d3500d125a5529514bb0406dfb14cefa07eb8878c8f6636fbce256e2be287c6a20919c03d29ef5bc47fe9db97a68cb52306aae014cb50b00db16168d9ef695332c7d5f94941835c8a1f71784f75571418eea3adbb2fc2593814e90af422e71b24ca6fb36dc57c1d437c6d1e9d24aa7e4acd5399b97de1dd8f878c4840a4721ee0e6b219a0798ec9ca9e9be2b12de636eca96337e9552f407587921b1bd21d245b3894fa098b2792e73a36920b0cb704bb7415c8126a880e87bb0dd14987109a7a1a71b5288cf28ec6e3d64598ec33b495b4a2f6dacff1ecf44a3fb8e6d3163c7a811446474dad50b5e06bdbdc8a7049d8498a8d30023132145e68196f3e6d9646ba93d42f0833a23e334cd1ef0dd5fd703d29cb92726573e1d6d371c7a0c877274c4fb143b3ebd6b007d58a58a18783641f454e567f05666b9ad1d1590dda7adf8ba699a381cf3e061f5e08ca6465f963ae3cc101440ff8aeb0825ca9fe94d161aa9262fa037859e8b5828d8dcb45a8410c862460f76b5038c38f240144887f1170451e9728db2415d6f21e2288d5e0610ad8b337dfd87111ea4b1dfac3240143a37e700c5df68be055b83f707da5033f84af5b4551ad688a6fe3bcef55418911b0338afb194ba8aaff2052db4108ba7a4d49840d554be82355b95fac6449241f6a5556b031a96d325c0a3f77516ce6dd393dfaff19cda43784275ca182e498fea7fccc46bc6a4d39575a5ce337fe55a185da3aacc5b5302fe927d884ca9c4d3532db1a686365b429f346a604bef112109b6d83157f13f40a0a57fd612327b8856e18642e7614eb54142f93342a2c865f46b38cbbf4d839456cfc2b3160e2b5834b0f953715cf1793787905c2d8c6306f2b32844cb2a34158de0066cf34580f608626c6635c32264a4f6f0dbc8f51f79f2e6c5459a98e304b3c3a38aef65bffba86dc182aed5acdfe00c514f128eb604716ade91ae704e6d5aaaaf640f32fbf71b62768fa441ab75100ca36e07973f8ee4e0c14434b3c97263b464a7d7583f718342d21a6f5d71ed2f2adfcc223d1ee7aafe5139d882a567a9f9c570285ef71bfcd06c9d643c9d323cf904699fb7913b7341af9857bc8e0b40a4ff34efea98faaebf4f62f33fe12cd694d6b1c8dea06456fb05bec09d6af1dd03a3140c029f856b26a46874933eea99101472f3e1ec5169d582a13c415c5145ac52e523ed16e4796ab95e1789d510f9dd6433eead29087c169bf5558580aca87db92570ddd8e63e246c20f3f37e0708cb2dbac88447ae9f20e94c88ddeaa104fb0ff193876bb00607b083b70a46a2b21c30cd5f33e1120948a56318c20fd9cb68707890fcbb53981dc3058817023d7c3a2e022791ebaae6adae945e8fd0c82849bba969d3301b097bc5fbe6e3494858d383f77ac8bf39ef38c08269c6d27f7f7b88a8572817582da625cc210a822a6250de643d2f1ebf242d3f31e6b2688e408f8ed30f42849213f6f34ea470eb08709e66deab24cd3482f2f749bd9ac898b255385535a7c10d50fec80315a7cdc1fff049a4d839b9a9eb09a056ae3bef2044e35796afa489be7c3b86298468940beec5718b8dcbcf10fd79dfb4c205961576edbc7cf32e4c16547ffa4ae8f0427a2b31074fa943fbcb6a398d14459e78a4cafe1f410c3f990683fe616a393ccc95e8a1486ce7b0be8e945c11f7faffee2310b9dc300975146628415527391da844561d03e8e954ca74f9951f161649c8d3fda5afc24fc6e61b395b4c5575d8af2333bbb7a7c27fb7cfce595d89956f79486168126f8b00d68958e0faca8bcf0073d9b30138fe0e895093a75e888d22cfb787992f9a62a1cf4a320e5b3eefac0661fb2f8a18aa34ccc7f5f5b046cdbc0355db12ba0193f4adefc770eb47534f06da53104c22233285fddaa389b4b3e495b02397e9fdce69ad89f17b246aa36243e70dd1c18a02e60a1678070f1ce0238c75bbcec7001a54c2505248e52c48968cc06a41a7b46c3c75d975b78a1990582ccff7eb6427eeccd01557c81bd0920e4fbf4b8926fab7e879da5720318c139dbb0afcd0f2a3ba0a872340bb6abf6fa2ba14f9aacb754de161fcddcd5fbe50eb95bbc4622c019c73b62268d88c2b767e7a8e803df5f60fd3215e7f2eefe8ebf6d699689d213d93c49fd5470aef54f76ea8cf267b87aad646d948ee2af2203a46cdde6cc3e1d6755aec5315ffd6523e48c445a954a546bba2594a96255ba4e844cf18adc74e39fcb1ada457bc9ede774a0543c19582103ecee96052087e15efe1b337887ceca8523a7a5836218041ee939face182c47f4a62864a2625d848f4d96546d72cf8511cac7e248b0c3a4e03d7b9ba3d9a3bf809bd0ae59fb37d6f4cc0771a89b6e2a01646b0f8d595d83692402893d6b294549fbb26fd7a6f2adc1fb07c453394f6bba84f639be50baaf5b8f080a73948bf48031e5f26f6788f4d1e36263a80c7aa8ad579ce245cf29b7552e9bf07800ac25dd93f8af46e30ece88c873ab86cf4ec86baa8e3cba5fe7467cb6082e70410cc0c91968c22d5b4a0772f80443e505d7ea8d5488786d84c45fe72886917f4bf2b6f78d9db072f6a3a96af33d04c6512c02c3ed51f2f8537dc50b53ea0a5a58e1f8aa5df19325f0aa5596a85971837d91a97628f3d7aeeee7934b2d59b5bf5ab0e9adfb17519267d62b341865afe1d87dbc21b2ff8d7e1009bdc0fb7be5cd52151588c9a5a6fc4b8dccc561a78941fba6fd9f66cfe438be842dc0884c08c4a61e1f607194850b18106d700831aa0327c96301e7727c7c012803ffa348f08c4623e96fe8ead90c7e87bf32f19152194234f6725a15130b41e940ed29fc75490c23079a94ac87eeae23cefd0cb32dc332866482bbb6ca23e9313af18fd9ee1433164ff89d908fa62c57a6a2b59c88544c4b31824d6d241f77cc0e3b7946d1be516a18769031f970787e2f93459b6145ee57d41073002b6c245a78aecb59f17bb493a613078881b7094d30a025b788a1e90424b04945f91f8075e366a84c85d9448e5da529967ccdfa30f5e18d3ebf9be9f396d9aedd4f7351593ee167e229c42fc50227f0ab589f3cd8b70cc03a40504cd56520182a318a120e8ee73d6fd58525e000f16de13db3b66b68f63f1682f51a0079d0411f627f3e2266bb4570cabdf12e9b658cdc68a84e38b261a152751505eee500d3f52032cb0efa93d6beea89493f344ca4a6745949caf7b0022c5b3936d6ffcdba00aefd6f4d820c681c4c8b7d0abe6b4cf43d1ad0a5d70039152344cabb3a963ba52fb68b71ffcbf9a30edd80c54ec4178221a4202c3490374b1ca1994ddea8d57584f6aee7747494ffd3ec5dd6e27ec2bd1d1664054539995af9ab33ad2ba979a1dc02abe20f151a3cf25c5bdd954b99af055b8d80196e37c2d3d0269f488f7678bb1ffbe6c6541d6724c101d10c8ec2ab95cc07d3ae47e70dd0f90ab6351a5d6366da9ee6ddb8ddec7fc7ade0e8b4f0d0275f00e20ce972e0a1f62352c460fa2c2ddf5babb9a72e96509d1a933eaeb750b03d444854ff55e00cbd006c57def766263d554e9040d4c632f4cdc65f6810d04b337601458ac8e7fe4142595effac234be8a309602812f4199616e8d931d5b41db1d5f260eb96e98914ec457958b2acfefd489e71ace44be997d0acab581d231736ddc8bc1f41a0e4f03e1cfc1cd4effbf689a98bf3c199fa3c928b061276dc2dc73f7b2dc91ae7f15b050501000b3f358e7e5c1876c98e7e12f2d4c2284cddcf16d8404c5537af17c85c010d0c9ea84aece776ddb109c647267f85282376f3eb4dde517fc3a8b386be1747e2f3dcbebb41fda8167d28fc56cb60a7085e68d08afff0cc465501e8351f8e78761570539137860d204f860ee56c9f0d51d85615222338af90cf0999b3146e0c44ce2b5efd9d831178bef6a17fe37d931896a1a056ea4350818fcf2d5b5cfe160487ee3966f2cdb4ccaceb0edeebbc252ee580d5133f3258e7f9cc7c7b98e29f572635a0eb8b7aac496de77f3d91eae0f893f6298ea48d2ecc59d8340afacfab9a0baafb9647b8e930ee94676d563fa2e349531923cde8ad0e2c84f64e1fa91b4807311c15b9dd66fff79610065e6ffdb45a218acdc6ce65529e677c719a5393c01a7cd80e3fb02acda146a89f7fcd32b06bfcc88b05b4fb00c45d6c28be5a7f9a07636c9117650a25cd5c58f1ff162cfd7f186cea78b3ecb696f5fe2ad243a029acd29ea562f42e51ac1c2a9c36b32872af3d0281bc60b6da9e59464eba9417c2e173bb85ee1608ea817be94b596453b5299413f6c592fcee3bdd3bde8d1ddb6a5c622e69a83e15925f34d034b3e9955ba09ffd2670c01c0b5d927dddaaabbc4ca0c0321e60b91a77fca0df6d45bb7e5cfac4eef94577c4eb763e479bf2db79fc178407421b64ad9c4bc504f326ab0730379b6ad33b043846e732e276e2e942fd32ad08606a14a0ceec26633e4fabf7d261d081bcabd1b002908250efcc090c6d178ffe249dbebdbedf9b96034fe787de40bae92083f2ccc6b7f4db87e73b0f128bd967435eee4e707e3c292ce021efa625101a3fa4b9f95c6b5b11d959d30be18b41b1abed5bc8067f8f65a84266c4e23ab0a4f5611043986c9fec450a440b0bb5935a3be31dfe3db188360cb9ce8603232b55e49afce4672c6739327d39ff58f97b6a2b204b30b693a922b973ba04eeb28af08bba84e77a682b78e74e187cdf7834ced8ab381c7184de217fa5b477658aed5cbaf9f9757563aeedacf4e1a11299606e03b0b2518de7eb9e78a494230e70f405d30cd3aed562ac2cfdeaf61e89ded65a0171f6c77667d6a4629df34b7256e5e1a5ca586894fdeb36cc9ea19074cd6174b6ef9bb903d1a66f94767cd1b46b1de944dfa7d4afcef23c226bb9e40cee2d59b7efacdd65e030dad87ef4eb6b375c186c92a7c4ab6a02e9f438eeabb6703d27642240c4d24d7f90c0ce354dbb5bf306eeb0356767f494f247c379922e74f0ec6369a8e1fa262b1f23ed1e3c78beb192bd52e0d91c56878f60a3c84d859aa2cdc48c5e7c8e66de2a2a183822546ab8a24130a4872a1fe714f4370ec26d45d6d706189926b379b1b0ad0789d6f74263858058dc5b3e46514ca314c1a5e039ab2612fd4b653207b2aa4d1d142916b57c511df10552ea4b5a8b6c8a2308538b030f06ac24cd4cf4f1d151ca9febc36931ee0f84bf0302810e7f7669646132ef8303c27f50f2ab90bff36d501b7ee55519422c41ed8eeb4f6d3ab631fc364044228401fd2dc0328d7a246ab17135ff89bd73423586b369d83df84be8e6c8c6958101c4d6af24070d04f5fe652bdddf8d00adc9141e7847f52f965b89197989154217082549783ed7a184ebf9d3d1479b1613b457c98769fc58e04cfcf09d6e71096873a2e5110ed0df20606e97e439ed9d9ff73c10d0843b02df94ba662540c82b46cab70635ad862fe4708ce41f13508a26f6e404bcfa6506b05859df924e400fa4978020dab287c2c5028775cca9f9ed032a67d2c1fe1a7e3df3ccec3f03b81c71fd5ab99a5a0b58d56b296e85c82450258a37d77d91a60507d27170744c3332209e7760ef8be5f2b2b2afbacfe192125902b99de21532e58eb6e0f09c0cec98024ea0b8e23cdf8ccde319f95b60649181e32a664f624f52a29e6da69494f260d7fb894d1cc9c3634867b418d8800bd37132e07926eee790cee329db3c1209d6abe123a32ee0f697cfedec015bdae8c192f6713cebe069f3e2480a7fc3164b14fba85fa12cdd847dd458b0ec5b300604013b56c53b6729009f27e79ba04f1b0633af00363ab048b88ed6f2ef88f18af626373acec15281f2db2925d7e00755bab466b41160354f696b664683e1610e6df9a5963220caadb090814dc4a66192e4fce33ec64401364a34ff51c5ec1ccb1674e0c91ae1e61df897cc477c92d4fc00744953290693053cb27ffd52fe97071bac837e52880819b3d6cfd3aa82196e2f3beb7a2c615330e55c7263076f6cae133280cefeb55cc5495248746c5555e35b8c3d080ea8554201a7146de867863c9a34367f250cf901b9e0e3d3b483ed811773df6b2e6b406ee9753d6671726f1defd645b7e4ccf645461ec6e82bd917fd54c3205c4a2bfab3017a53a812fca752b72b5e6a57aa351b3071ee4b42db1d9ac18f3d312a01f00ebd096da83bd866ae103191e51b3b975d5c3c3d646d4b678ff8894b4cd85f41ed568a698ab586f0b4be842ff6bad2964cbe9f6915b973940346d3104b1f42799aaf0021b06294750bb6904b29d82176339956de9cfd079671f8982fa3cb5b8a518ed0703015f550305fd7d36416ddc4694b0509f78922f93c42cc33f55d1198c76b3997d27f23faf974272a8b289112db671f1aef83077b485dbd2be1d3d249092f470d4c31d299d83c3c2ac21c1d7f4282d9f1288a395f6531d227359db6eaf5d494c88b84b9ffdca4fb9b729d64141c338b1bf416116a5cc13b93831ac92b2497fc45ef4962b5fd93903e4f80f1ab01af1e810112fcaa94e7f0c731345511548aeb5846f782898ab5c74b3839d38d8cee94deee0882d0d2aeb2fd9f684e1b19be34538eecc8b114ea8fa209e96472a3ab1f47d73b89506fa634ac18ede0a299ece1e5a8a807547beaa3459f480a4f77d7b4d3f3e2d3f38b9381c26d5cb46d962ba8fe454f21b9f0b9ec7972c2ccce9187d37002890abb61e12cb6f3ecb6d096fee6fdec1a4eae08784010527be47bad67c6eae3fc6d3e9f5596b2f64537162b43930b551979e22cba435d3e162743556b908e5b8c0d8cff51ae6df5f74ead97c778ddcd3b58d951cf4c819421fdea7dc040e12659de28322199fea07063f07e3246dbcfabae0e084b460804ae68cecf8f84eaac332b6fa7245abcf48072bd2edc885568a73d7d06647cf0cbe34f179303739ac9e17daea5aac550e24d654b59e626914ddb5cf11ef2c295386e26c917faf89e6abf49eda355f646b4e145299b7548f542c692dd63f089daf3318d6c34a572b69a637ad311ea69857232d955c7a92a038d69465204e2a47e71eb5b91711a4518e41729c3d04ea44ee78accee20eeae168150592a429652d9382da9c4fa2101994e4fdc9d6d75a620bb682d46fa91609ad1fc836d19fba0789d2f31b9de13ff692cf64b70ffba4bd13c90b5b1718e7c91dc841efde4129f7d7f155043cb28fa13a4d8dae9855a0564a771aaa69fb01a0c593c78d689520941f99e7e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
