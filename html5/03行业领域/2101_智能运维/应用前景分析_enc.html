<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"14428e797eb1e8833829daf510bff1c8d9e4194c5da506dac69daadf538944a24a6b9fc1f337c5cbef3b011c2b62e41d94f7d8c0d564de19aa800d570fd22155c15faf0f6ea1c902799fdd566a806e7d615d35d44e9b4dc6498d3d55e83a83b59f9454dde286dc3fd0c914f91ee9fb248b4c15efbe345ef55715dbdb57c9a07aa2b9a8031db0e06b9af35b4f1e008e7ad6f5512ba97d3659eb1401eafe791f715ffda91e5b737dd7db649b936e4b009b10953b120f83088af8789edb82c6d8d6eb77b89ae17f8c1cad583e97fb5835bd7b7494cfab52f479db451099166772e1aa3ed07427fb0aec931e080b2cf3c003ec44a96c1502917de1f3a96a37048f7c789715d1b1fdcf543b3054df8942c0c040141c9ecfee21c07e92ed9280077a5fb6c7ddfc158d28e2464eb4712b3e24ac327aa1e6b2b2505933985c180d6751ef93778047ef1d7084329bf51725a3e02f5b13afa37d854804f2ee45e37a82794cd95e3a01622727b6ac99bbc449928584b7782dbfcd86c65850dacabdb1a248d632b00fe2cc8c9cea56dcaffce5ee2490b17fe5fa7f30cae0f9b3201397266ecafb861e0097269df75df700acf82f1d11de66b6efb9427529f59a83c30f702c1628b4e59011e2f02f2199afce5aab24c036709cf2b3c03315a0adbc9667e87905e1112103dd3dccfefba5658370b72dfcfa607155e7eebf10a546c40c8399a9b7de4ae003bc7736f9693afacf11270c8a63aa7e2ae46c35e5a7304aa251d9d4d608254f102e221d2853f3a5eae92b13fa6ca922cfe7e3440eb544da57aef3d3c135d0b90d02ec7e380dde442312345ded15323d88dcaa7bab573c45f51247a7c93a55a3152e2008b4e30cc81a09e9b42a8829c09360a3dd88d319915f3254b1078fb7885d9d5f39e08e2835cc2cf43d11b04a66452420a2b2317a46a24e25c05e31b85c8a6d8cbb569df4e8e4dc0394100cbf416b82a00078c45c838cbe21d7a3d08c553642a5f4d450f38544b0de66b47f3eccdc3a24c3a0bbf7873ee0352a6b2f9affbf691d25d526b516928064d7ffce71f2fa1aeda0eb3f9894c0f6320b5343836f7d771bad5f03c1e692a4613034d79c8ab04f889daf8eafbc49b608259ee4f6d28a2be7c6a91e0fb155895ab424e4f8647a15a01156b596eb0646e8b747df44b8872f171bfd97333af6de303fe403ee8e48d4bc80a1aed9adc9702bc94af641c8b744c05d716c2a5d3b2098b268afe64630f396950f839742f111ec9690dbc9b986fc7f5845e13d44247230d8158792de8bbc40444472f842a973937f0868a0ac401d0c89a8fcbf67693de42de14e6d38dd29abfb50e4767d5057251453617a95e1656fe9f07bfd028f193d3dce4f59a8073f678493eb6f7416ab72c931ff2ecf6bdbdecf4de810e35399de59e661742a8e66f3c64031b5aa56d0371b6ff3f977c293287ac4e744a2055b5ccd4fdeb632b2bbab34d2ebe99518a0766ba358259252c7a3b2ddc6c6b98838d50b55b7342043fc86cf79f72a24745dd9cea30835cd64b2c1fbafb9f90b3f572d8597479dea34157d96a6915a3f1361e36855befede142d7b320a13e8f028c1a25c6bf3a29e8b9033505911c55d99b8936d7e0349928dbf86cf9cdf5a1e7cbf8f27c153dc4d32f9c34b244f8346a03fce505008d738fa48b903516ce02646751fec89f48b794506e0ce98b84da19d628ab6d0cd4b47054b4344b7cd841f4901cdcbfe783c145111c9da8d55da65b662d0766136b5b2360b05e01598ed269f0fd64afffd57cef2f2087b802eeaee7c01b5cd3e528df9080397315caddcf333b0afa0ab0e9b01695c2620dcfe5108080c97acd4f6d945261e591248c668a315d5b4527f352f66b6595635ea3cf8e2ad705aa4ca26439814593c7801c96e16777ab5388568efe23b0910c251cf67b597f497f49c7459064721601c43f42e3c7c691c7329a68cccde1dabe48b71d18a7c5b18d1fc455a2ef258b7a44d907561795429580f3b701d54e84aea25a5568a4e5fb75d0bef88dd1189bde53e3740e07a60df03b1a30b9e69084058254842ea6a38f826103021c1c3b2dd7d6764c9609e2b353ce90a50f3216f59b8420247fa00de18c5c720eba1429c41498b11f47587542a2dea7d11afaf6253354b48e9d5c02b66a0900286b97593ffc471cdc703ccd3fc071f0c5f1f2d86f526a61fa6fedced82f206a525c833f96819b2d1a7cbfa2c1e20347de3110673c9b61aeb30233815424f260f597dd8738e5efb4873f2649cd817a88c35d4c9c3f72b0acd0f71560c911aad92d04a83a6206cc7e05d39e24d0a6e0a687c40b03309742edf8b9853a91052882a1c1bd71074fe60127cd8b0aa147959d4f4d9bad11b28dc9fef5d9eaaed692aaeeb30067ee7e4d104108a429647be1115fe1ed3e9d42c3990252054ef603fb9799a60eafc115d316bb35eef1274db2cf46230ab13b90f3db56f4e0caa6a62669815945fafc4196f97064c546f6a7a9c95219e6f8efed92fb445f6fde96397806c32600f1c46d1a01b0db2f18b06f37f46e398eb35e35e90bdfba027cdb5344b9c26f3f7dae24aa8b8ec5cac857c016eb535cd423da950bcce53cc4342bc960b07a915e110bdcab328117a0cafeb4d2240b150efeb34f256dbd5d8a6f647645bacd23f63dce4a5dec570d915ffbc7f4c8c238ef6381f11e14fc684a1dc048773dc0e8dee41e45700ffcbae29a2740fdf3529446519181c928cdb9814d699717413f19f0596ff8a9af7c1a1c55d49e990e0604aef4ec515ab8d22cc2f31261a8a6b250292ea7942f43ec0b125b2ddb40fae9975c6197b20c9b48b980138eb71a50757ffe55cfde31cf90ff481574d04227dcfb360de63f345a619b375d1f67769788bfad686d53ff5c2f7b087fb3623219ef5363dd868a7968802f65a8b9bede4ee3fa0b2c80620d441e21d7966093e80e780d4e07bc30399d454536001dda661dedafb9769333e281ab5789df78ffcb5c7d399f12f5c820cd7d231c7c38695a030798d8f4fd3c7d19fa221861f5e44c970b0e2ad0839bdc4617a46c69b8a7f5909db2c4db3f923930ece180c22154826ebc4d2d0053a5613aaa5121d5e66e8d6ffddc8c99cef5b0791492505614f72c471a0169c3779cccccced81b979a6b31c557cf12dbda245df85f9f07e663412f932c04643be16c5895485bcda56ef80b0ab95401cc2de440d2fd0ecc93b05322673b8f8c2a5604c4617e572c7986523d20a9951359deed527793ba7d82e70059ae9fe4d75555225735fad26ac535ae2bf63427e0dcbb36fa67db9c0cc87bcb6c1e6804796674efd2c8df46975c3810ffde425de377ced457068b0367ab5a83cbf7b2b66504fe95c82d69eecccce3e6c2a3909d32661935e6506660225a9ab178d06c28ff7ff072f2884cc8af73b0aeb2b952632c905a2f23607ef2fc29d301099abcefc1d7ee38367eb5dea8eaab7a0d75228fb34ea263cb6b394b7876f636b2c504bc11da3dc28fc49b6349e0797596fc14551aee0ef682b84371d7706364e100a3496b968a89ebdfe97dd9d365ed2753160b5af02fb90f2113c1c3ef7cdd1bf0dd6f286dd637e1b97f0e18f57920351880967b4d2ffccac4db8ffd8636568cd4cf371c8caa0e812e1d82c9c23cfc13fbf2f7def948dab0fdb9cee16ef73f82a0826b8eb6797ff0a74dea1de36e9bf3955c274b16847fd31ac1bbd2f26e6a627a8e9b1aa74c1a6238d7530acde43843e5e77d4778cfba31e82ff7643e15fefa18f2e22827ec7db942ef826b27d82703f33271b8cb10083118b7aaa9af2b78b782f42693a212d2a3257cd8ff116be4a90f8dd91aab4c4cc41078d085f4a3fb95a3ec942175ad938df73d1bfc0249d268c2d72bde32e1925e7825362f364212894e60820b114fc713df388cdbbc543aac5a0bb848cd75ac800d6ca21f03ae93d053186cca61376261b2a3b9c34cfd12c645e4e050d05dccd82ef83288e34a68f6d163de09d9e4ce64d79067338be645465e196315b1124e9a79d5058bcac784bf78a71a3257e958c3f95624c0d160dc05efbe212d010473666f458cffabd4b345c5cb9ec809aa6aa84b0d776293bac6639530ac94f0537a9d6a23d9cd13e38fd066cd918c374bc92687d1018ffd428372e7300aa4e92dc5d96699929ad922d4406e429b7f3da9795f33ef011333a99ee265270d2c3608ab951638b9a5fa393e61787bfe5904ecadcba1b8acf567d2bada10b5cb1a929f17f8615a3f98ec06a23db2fb3ab6e016d28879a24448a6f4b022ad4e1f55d476a5a5dbf63e0d9a2679e2c1fff0138fa445c4879dc74f1a27cee980d86cbb7f9229cdb1ec89e7fae497a3e0d80a2e4aed2672b990160453f96663ba3f87fbc9aa4e01ff51101d967ad0f272e19bdf60f03417f0e838feac463240e60c0dfbf32e85496ad135d890b18385b0587ee9f3205ae91a0a9c62c8cf0e01b88141f68d5c8058b7e9f1228cdda648b2627c50b41facbc52524281e0356c54c478810e7abd967d8664635bd48faf5ef834bff2379faf4b6f27c00733a6354b58db67aef7cdb37828ea6fdb3564f978c54d29f362c18373168da97c9149c5cdbf1fce0d62c32882c57adc82f6f14c7dce0bae0bc6e7d3092ab2a1dcae978de74e07f5f3cb46826805ea8516f1b3ad2e97253d51de7054f103bd5050c2e5498a9d646eee7ddcdc070dcc73f19114c7f2ab8c8172799729758ea2e2659706ba269f30e156e44c7bfbfe9afa80dfca0f282e7538a84692359a23c8975ad2adb2ef0c1781efefc09b37b99c258189f50b658b0d61aff519eac5379065b1bf11df94ed493050136b7ff466170a8bc8eaec6c7c2a116d13fc2e0817892c57293f2cd782ccb43756e9ac2c88b658a5f4c5d1b760cc40566eb7ee83ca29bb184d6653fa0dccc9d38ab673333d6ebc27868f864b184505918c9846e9842843a824716968851dd76a0c2eaf87b72cbb2c223b9db38ded0426cb73bf961ad399e906f5dd31f8f9059e69f4e7261518849968e411bb6ef16e6f70291b4342c02dbff06bf5c3a03a13cddf5cf56a1b58b07d01dcc553c3d5a93c4a8610805fadc37ee14a2b0397a77f7a45eec22f4057e62ea43df0aed1067cbf22c86fc44cfea4468732e95c4c89782510576578e1961e265ba5871fc5a78c158183ad03d04c2c5d07b6a40d35cca6f8e14ed4b1c90f4b8103b26c304b71b634ec9e8ebdd438358e40772af7e0f9171aed995528435448ddc43eee370110f93447107ed90c3d3baf1aa0d2c8f07c5f2dc6542f61039180d1c26281d181e6de218a4a65a66b7d77d2eaf4bd4ce0aef82eb63f1b8d5291f632d015ff302165b6d291cfcb5ae223ea6dc1dc5c8d1b2254c6b06c57d9dbfbee9403cc6fd1a60d974b864b8d4d22d0c0bf315fdd5e8aff8f624e90f054ff6c157982e76bb91c99059e0c11e83133cd77d5d1987fa64e3d106b426174399cd4b80ea5710cffaa0ce074118b441b15889ac97f377e1a26843c596978e941a95886f3b8bb29585b02166bd0d61803c826b95ab517ab5a0a02339ea43744d025a969eb02dfbdce8ddcc7c412a051fa5ffa03077bb5fe7de07bad969feebb32006d700093625365bb9dd455aa6e7e7de3d43e0621ffd04f09be61099f995fc632d17200bab28f1bda3e46c88db5b1fb085835e3040c2bfcd18cef3e646fb4f9c2decbf16b73933942ceebb7838399cc42719a307a13e09e3794582ae95a6779b534ce878bc98105303cc79759f70d0678e41d77a0d6919098ffa390530e62cdb4dcd8f7c4448a42d223b54dc338699f36677b92a8a4a2f93f036b1d4cc418fddefea5429dffcbecdd911cc646d34db7ef4baa31e49e40d96fe386a68f5fb5decea9b87cd8f1a6c43ea0b8f84a15b91c61f095f0681368d70a02f2ff87a80c66116fb5423a6a3a061cc6bdca3533c70e8aae80dae3bc5855438c6e1a9239da4fb564484d5b2d100d3f890cac9bae74645194639bbb3f35d4330a7824b495f83008c3d9fb9928f27f6346211254d8ee228fead304408600d9d87e8a7f39ba3548ea73b81c27b5f8b72181e3b6928b6445ec1db6b8e07a4b6f87e35157ac74e5df0b04ea5b71b65bf7ab3fd2c2478234cc22eb44774d77a05731fbdd8085de1553b6edd5f69435f47e3708a6b5f8f15d517238435033dcccfc80c945d1ea1e89aaa5c5a363ddecee78c2990a2396f7ef67b5baa61bb56ed782a4690cef831f96a77a5631e0c0a5d8492ac9cbd8e4ed25973bda1059327f75590c8ec364ab5aeff996d3fb79bf4fae13627f026cc66f2a306195ec0054b01a9ded33ae8f46901fdfb710284ccae23cfe4dc25a5b468974ad1275c5024ccf7c19a0957e314bda6258f61b040b122118f9758703539c87b2ff7d572d58ee31276bb5f3deaaf3c115da58b743a3e6c764a969699f2c6c9f1a2724f7a9848cd058aa9337fd4941610852afe545a26417e537b9a4b83593d671fa04002359061d2370942c9ed55aed34a41d958457053f8aee3ae6846c9b23afe544a5265e2a5a332c81749abb37882806dd90d2696a5cc9933bc35e888ebf7c978e8b9b37f4ebae930d84aa7fd70e25120af7587ac3523d7ef1664ec914bd150cad75e8b5519704d1f3360049d3504992eba03e61c6f7d91d3aedc0e97e1d5c0c3f1a8f0f4c34a2f054b4e0b698368a8aac43887da5e63b74fc309229c364863e27d6608776bd82bfaa351bb5df7622bd0e1e5491dc9f013bb7ff569bf441fe4450e0de82e6ae2a55a965a825b2acc0a5096954729f667fb56aa759e578527eda1d93b6fde9a7b5f43b71269a2e8050fabbcb144b7ab1d98ec5be1b8e153ceeb3316dbf3c4bca603d9a2fe84b445f579f06c3dc8d19cb0ac2a642e437f701a09ca41b8cf0671d40e551cc7fdcc0b600c2d985cf43580d32c9195e14abe509f7da599578ae78033f996ea712a9afd75db7a17aa675089aedf873d9a46839b91d3ef13e1bd52d6fa33ab5c4b3570f0bab357a0987380d2ec2e990fe4d42f9e534f54a199ca2a02a9ad5e0aa68fd2a58283cca9b6992ed141dd4800a7f68ae70bac422804fafa8ee1890be3b9152bec652514cdfb1a1509c5dd10a880a1b2b3d5ce1f72119ccd3921e3d2e15a431d0c00b8ac7070a25beebed4cfc5fae42f28ed07f889d1248e32033398bf32a8cea3fd203ee96f4c8d21ec8bf615068c5ce24031ddb3c979a6b9b448e914e1f08a3691ebd5a6eb7111e501bf1bc38fe5b442147319a38d87e0eb5ac0d29534b505c5ad1507a35d35290874d04898f110e5a3d77a95697c424dab45a0364108824e97bb0c0ae87702b91e6150a3b1f319095b4826f90fe401b0ca11dc1ecf7b2039ca3b4b75df0e80f24f679a9e690e144b150c6acbfda1814064d4b4ddf1407b1a005fb77ef48cefd179d5291977384ef6a0c02eec138f505321d135e8c7641e01512e13004d8ddc1bc9d684ebed1eca375e3aacc39723c878cdb06629da7b62297b18fccf0632e4f155931937bbad560a64faf1e7b7741aeb5212051da7c082a06197fbcb1f3f0da6640de0c3662fe6d9c48af3a92d4974f234673a413de2b0e0702427ca76afc6e193103d9e6f5392dd190826e25d627c0ad5251e323b081c1b47eb0d6854b0b1d0e9231975b004fdd7e0764b650c46c50d7307caaa78863df117a823c982c5ad4f2340d95ce4d28089d3ce51cdba0f924d1590d9c5ca63adb2542860e7bea14ce5ba74fcdc6bba68f8bbaff3fe29360dddee65f4972acda36bef592f1436997153fbade7fd90cd5057027a8b979403d6ce4e6845e08cb223fa70a1c565aaba1e01e66875a6133dc13427a07b86f19060b7be7281c68ab166668f47494e9b03a8f22bef3c267366991416f5f8edaac60f08d44b6103cf67c78c8ee18123b3e33fc3656a514ff3f1bf3563379bfb5569dc1240cd7b02a167ac975215c551ed09f3faf84355faaa8cca4407743df515d99df9612e8cb486683af35a7af700e68615281742916940abdca74919cf392a2f93ea47976c75d8f92d1c7e2f58bbcc237517a429f3665c4412a8a8df8a38a2bd47f106916c1dbe850a0f34e6cd008d63f429d3d79f9f98aaaae1e4f3190e4f902541c75e8d6ead684c2aca1ed92c7ecaac60a1d6aadf32f9fc0773568c6662813db045cc301c9e7d1cf816d559bcf38e257fdaf3a4678add24efbf5a0dbb3deddf0f35ef852e260bf5fbb790df6f2b3b579e69ec5dfd9c9649930f523cc6ba9e1983797792a285b18e74d931731952516b468bb0a14fb9ab0a9a3f280c1f557846518f174d346bd67ff95c373943c0f1b4e5d0de7f9e2f79b0ac2b8b1ebbdd445d4ae0a1891ab035d1441a61cb448b307b9c42b423c5bc8ea5b63a0cfb6b338eca5305c23b46b337fdcd66873ea4458a1a1f231257b037f19b242a056da72e4218c6267d32e454db0497bfc067e739ecec8bf3101b802f88ed87b5fbc5a8e283ff2cbd5742c300e9ae8d86611589f0a69bccdf8c70fb75b4109662f41c7348e1b5c912017cc5f5cfeeef375139455268a7cf7138540e9a73e15aab95902732415c1399ff7b2b1cff5bd9ba3f23586344e384a1a8c3afe1ea1974da4dd19a3271134bee36c93099eefcd1c274ae65f4dd1b782ce055901eab71dab42395180d120646837083849f506c836da7eb5a0eece5853fa8c1c20457aaff1f951c754432cdfe06664cf59ef190ca4b42b4ec88c3426678e5c3914c5aca10e8f71c11d8483c0be73d377023b1ad64f0571dcaade74da018a361c8afe3d2f2ed317abbacc85d5ecabf786143e24462179a281e874a38133a2e0c5935264955cd1990392fe7b3ff30272441e9ab29401472ab0e906aa8d46c2c32470aa6ad3feb140eafdb69542c8bffe2cd082b6cc9be9499619def9bb16f232a2ac3128bdd577dd62b694ca589e16592e7b9c781061e76767d47a99a5a5683eacb0739031c9b173cc9fca496e4e7cfacd718ec52a817d338d33ab91099ef7a5447fd0762795b659bb2c2a0686860e32e379ce73e5ccefb02fb81ad96a29bc7eca8c7af949d4e7def89392211ad5fda7cf63ceb3c91e0ded49cbc8b093b2b204279ae55b36f8e7e6dc27a1cbaa6dd755703e7b67818ac67271a43384a2550d80576f46dd67dcd9b8cebd0b75ebb64c36bc8b48f83192326a46fb805ce2083465c6754827b297662100a7c8c0d6f7d8a71b27965d959798c2ffae9e1092fb71011614a13ba3b2a0ba84fe1629a5d92cd4e72a349b0e6190ca100600aa57ddb0dba3675b6d23e5005927edbd5614cbd88d5385eca2850d68e045ff65a46de25169187109a6823041ff2a9fe854975715146c676ac6f67c258306480a56bc4405b1ad575984b451a98b50208a2aa096482c0c82933f4c5992f660186eb84e12c629a877c6eaedd70cda3121087f7d4dc6b4c689ae0e5307c9066363c49a79708d0d5f23bed67cb360266562d89aee345f686fc001d607bc6a6b25d2e7afebd9e3c622c240fa3d9a8095a38904566cd1fe3925b4fcd01ff4cf33cca32f57720991d25642a4c2022cc859c681ef0c2c7a558373c07262de6a3c1487b6db55c1a8258ef5e5683205f565c3127481a64f1267eae537a8bcb6ab1fbbd63ec62da143b4a8a918e0b940492c493f83f4b396130b06cd31535730501b25975f5586697d20521cd91328f69f29ad2a432a8d28aea1552c9d6ad5facc2fa589284ecff5ee766a77c7c127f6b235f04425b7864e054c3cff9071d89c42cde2ea62ec7656e4694579cf877d674c4d9996726c00b540b154318559eecb4cf11366b3125c08c9fa432f37da105cf130a6c4432190cb17360847b5750b66577a301341d40d4938c73c79aa1f65fd97740d69c6e49be06f9850aec44a3a75fb5b3334f0171ef7e855e11407737cd1421427b3b86baa2f814e89e36133da2b069dad41d02cc00d5e15ba857e6211d10eb759a85f94c9bbdf42666db39935a949be9763e1f948609e8f816783e15e2dbda3f7aca88d80208022c9982365d19e060cfdbd2273244086478cbb011959296708ed7dfd6cc50a143d95c442264d4ac127d1826fade9cd5cddae56f989331d43401340845c2c4eb0e9dc3373c171f28fb18e8782fcd2b67035ac10c1a2f33df8c5f3726d0221c4fe6ce0996e13ba59e7437f9068918b819b1167ee54c90b06bb6c9a1f642556686a8afcaf43780031239430b16d2d02bc906186bfb66e717d5eac77047457f25193cb374648a9a4cadc3aed77fd069d0a687497eeac560884a59d4bc79f632ad55254e55d545a7e2fcc5f6835f9d0b6976298137cb486c1317cc9321a0d6c31f043fa8636d260f41a8c7dd4535a334d500dfac4ec04f1abb6ddbb5b048336cb4a5df02bc36b8bdbee6f056175ea37b0ef23cda7c45d34d21104cbac8c71d4ac56df3132620566b63b350b4ba8024e89049a326df4d1f943eb272be7f2cae66c01e2920a98c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
