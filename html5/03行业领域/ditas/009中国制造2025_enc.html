<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1aa270622a24bdcfb1814f7db859da645d0e24da040db07c8fa4a1121f4f31762025d6073c37f70830ecb2fdc5216f712840f280721648110e5691d469dc8d92801fdfb2c2cc2ed3d4ac65c9d7c2a44b69315299079c4e0721792746f04ad39493f9679ec66798ee4cf4a4e6239e9ffb382448d5152f065fc61fbe368f12ed790589e5ebe519c92851dc0e445ad90ece5b162061f6d184f3d710106fc975d8187f34699c64f6c4049a15fb282a4eb1487e5d75436f51b6cc6f45928009eed2acc8b8231183c8812c288f4d4f67327e89db1e5d9d9d1478900bf80aca71eb0e9763bce58809d9fac22825e524fb2208c2f7b370463fd449d5be0327e519a02dbe7d0c6c941477e4f09c1e1548d72590738d8855a6deeae7209d5be81f3151bca1c2ce6f600c11497eb783748188289db4ee95b7d2b119f7fa9dca5c0f9821d62ba029a47232339e47e28f9868ebb8b62046ca24ff2e4bbfc9158ccda809ff639a90d5e43bd2bcfff065738983386e417a75da27952dd81524fc008d6ed03cbba17a00c8bfc46546e66bc9226276f8da98ceb3325e6a95d944cd3b873cf0a70d764118a22a9cd7b9b081dbbe8c4d5b313a4fd5fb697808db39170580bb55742a8fb1c692cd5f5288e3a114a3f273234cf1df047ad0122a70b86039a598052c33a446cc0167d223227a0d6f0b6b71fc872faff54186cb32977c0e2dd35269b29fe47f9b7a519fb687685dc6ad42a8d8ada9d968a9b2422252236b92d39206de24323b529fa3fd3b5cabb058354b73ab655130bce74bebee6988d76962b64b3f4a3274d0eef1a5af24cc5996c110f8b1d5fba4c4afdbdd03e68af70b35aba59f49e84fdbd75c6185314648a1addc86854075ffd0e0c804b96f0b57e1683641642659b3aa7a67a01b3293ac0f8fb7213e95d6a2cce57fcf8e4d2a13d5c489889f629a6cfa97022ee219ef2c8471276318991ff4df0a87a9c6310613a1a67be869fede4e23116850cfae40486074277ccf16ae32ac4bbb74831aa10239d2f709e7f08bf87f2cdcee69f9351dd3a6e110a37dd8161278758b006d1733e4a2315518cbe22d79e8c58b19be3d23ef79ce1d592f65e66118478bd20af950e85a50facc0461439f4875c9b2e7868b9bd087a32296c58c9b7285c3d9f88a47974fcccb548b1d57b81663ba651e5e6535d6cd44b066aead8af64cb3e2a19e75626a36a50352db7e2de958aeef141e940f3ca9ebf0d38eed0826ee683b27e16e5d59b18b6249fdf5edb250c8cd053e19d6ea20b52dc97fa8ae75a373a5d041ecd93f7765f2f82e8450a29bba5adf8289f6de49538bd589ff0d18c10f09e03eb3dceae82aa8d14821f8ec0e16a083f9b19c800704adceb3f01c9a10d00ed4945bde7bd8fbcb7f87f3568de96b00d13b5a8502cd9d27228c30de510fd9c74e865623f2c8fc248be16455dd4153f1a8529a3a533a83fe42dffbef68265247613356442574a8a393a7a432ce7b99f778191542a2eb2c0170ad4aeb2710edb592cb1b1a1f288ca170aa25c5e200adca94328026fb04e791ba31290b232104b7c7caa013a379e910f6d957fb2ec2af7b55e97a774287840ecab35ad72143022c042d13e5cf19d000fbb00afe4944983448a7f64ef78c5fff473fa95a0476ac4cad51a3a927adf34e7f2458f499e97340ac6ae9919143efde2cc617c1640554cdb3ed0dbd592594f07679dabdc0f699654f54b65d0f0be275308808d53c8b4984a2230fad5fd6cfae09ef5d825c2108b89a356a17a3b41f529ce691109b4a5b7337ea29af726f9874032037975843e41dfd5f4ffef1537fc6eac4dbee1e67bd8b61a4325ac14dba5face26ceff4e231a17c8aa1cc2540e678514ee7ad7ed7aff339ef668044702a7c62d93fa0a3676ab8dd85f16aa0067aad1ace9314f9a66d67910f78fbc0ffbcb4f7af1221a8a9158b5b94cff4d1f7ce2ccd33a673b664f8b7b6749ca12fa28c30f2b2b03ef0c1c600609a8710fa2cb980bd7a4c25b96e6a4b00aad53991a69182ddbcc464775a65067e2734e9ae7333f8e3113155fec917e28bd06198a671d45421d0b0674d30192f41e1218b1ed90a2d5600a5682051d882ab2df5ee5f0b1297ffb615a46d521026f9655977ea690b467a4f61fe23aa78604519325d3fa3bd816c51fdd8ff1706874a27f15e3320ad92621fc0cfed4c83e52783be7100d375035af024b9d113fc69e4315d11c10f0f23c0c88e465a8df88fe4768c733b468fd7599e233da1ea2b477e6c36124a80cf77fca4dca2821905a7c755ee447ff9b0e24bfd39844c1c9a597b931ac77367d06bfd70c1755d00998de28622d5f58088c3c1a81217b58196704713f9090ccdcaad79db4ba107df213139c8b13b638eb721155aa0d5397410f4f311b2878ecb27da024bae0be4126fdf98a199c40521a9d7b0dc82bebebdc0aa895af83bf5b74d7c5fc68e0aec3d647961c90c98386e2f19f4230114d791bcb36c84d43e2899ee193e9ceea3186c293373f320ec02919ec3a168cc1ce9948f82329defdad11ecc2481877da2841adebf55508d76a0683afbc1bb2859111220d66446a1f19881f21edf62d69a342b19bf7839ef2665bb61fc544d107a6c1ceda4fc7323af12ac69a44f2fc6e4ee0e2ad8a1ffbbd0c581cf001d729ac036d59afa527b17e937162f7ac50c79adeb45ebb774e266a71eead6dfbc0c61dd835b4da919ab78bcbfe2569feec146831cfd31c81cd495d8b61d8576af94c6c7ca33848e560224408d4a92f1409e583846d77b2d94255ff9b7f46d6babb6cbcac75cf7129671a84ae437dafd7690a45ddc5639ca282c539b0a2b3cd44c83abfe941472341dba4dc488d286820b4c6d541b85982be70e1a00bcc45a0fa69e3e87d791ad6acfd49ce617ef700e3558b7e19254a32b9ee7a8b0c921c0a8f17d2f28ebcadd9acb441e1914c46a8e3c57387f49b156ee5a6dfc9bb35ca3363cb21dc7a76514e612ceb088e162b5e2f24f0b362adc2c1b0c7b8a3633ae0f7958da2239c4359b85c052706db01aac4e54bd30aab1f3f0b2c552e4155413411896dafc46b0484b8890905536996086cee961e91e48c2d05bed8e564e8621b7f986ad1b2fc7d6059df875da8eccd8d03e82de25fad720089d80b464902bf2dd304eafdaf012e148d3e31f6976c1d5c8ab9e6c5e17f93053d216aa39b19ebe4022fb99daddeb3da89020d908d4b8a0de40d912a96f29ed9ec9c40996e974d0c0a2719deb7485b29f8379af3cdbff4e90379620e65bc818442b5bc805c9110468d253d7229cd215c72e3a32bc12f2e1cbfe3299b325f2d5fa24ef0a3d1c54e86808a2254be11af7a2aade96024bf1bf07f19a48db09afb38b625978e954881d1907922d0db05366f8b5e68d77ef24fd14a676f35280f97dd4c00ed71439370009e3776fb9a1a65a6d6a447b23af4e836aedc7df5e11abd9dd0b6909c6802757b2b83e32e29c36a735c85829a2e5e43beac0d41bc2e7c59bf6480c46f5910836d1b8f260da79dea34efe70e4c44fbe81f55457e00b5e3445fdbdaebd2576b0e1905c34d758dac2f0132248a5250557bad96be39e43cdfc1cdc608293fe4502bad5ffbfb3f57ae5a6ed64a8d48474b18e2d60881b09bec1aa80d3ddacb30f358104a83804764c73a0244df0083afee389967fb4622e6960be59cfe2d188ac08ea6af099434a967e6bab4bbac40d2837aa863275d3f10f75e7631feecf9e7dd30dedd1289705d5c8a5f4f86ca7ab329f08b5ce254a011dfbb3f6c14cf117398db17a9163fdf66b966ad192650810498fa86fe934bf991b83150c6ba3d575dd0dd9c2f0381484a716be1d69c59e14403d06bc503eddba334da3ae03fe949938f0b9baef651a8dbed6cd7e97243461395c86c65f857e884132570f3315e0f1dbbdabe08523dd8d2ecbe283bc22e8713d632bb7c16f123bacbb1f46e7e008b6e6f89f3e3f10700c51704c45002d685086884bf21b1c492342471e07b8c90ed952f67bd33d478c70925c7cf34ad5b8d3b415fb74abf0e14446e010c22cf877c88700f3981d145d05be1a9cc43350e768e495aa59d9948362f4baa73c79ee348b37f557579ac2c8abb2050cbaa1533a6db265e2b5a5e7d5df1b55b9be5dc14f9f55dca9a333fe28e9d0b18d227be0f06d0ce627615b3baba1b0fbf6775d0973e5cff410fc22861672e255b9641f0079d20675196a831f558924d804541f85fd3a833f344b77aa3e6a43ce2f474e1591178565ab3f485f9c0f70e124cc8be723c0c82be0f63affdf273bfe69840546e3e393564b163ac02c748d69ccdf053ecf3803f52cc7d878d77d567759e485a5dbd476e485d76a116e92d5ad9b414cf6c3beb3ef533376428cf668b6368ac3eb95e968de73ff1cc85be3e7f5bae562d1b27d419df22c85c27f3898085b629583eb6794172c3034b6a88180906807fc0969a94dc64c539493ce20268c6f47b0814e46a85512f58323141555a70ef7662ee7ee2a96f19b31fb61d28924c20c76deb2a859a1447f8e84fa86c999beed62d3980cb8fc5da2be5e2abeac0fb75b2f115fbe65abb77c9e03ea331ea8aa8b843f5c62c4a4029da1beffe3a4eddc49209a2e40e16b1ac9af4dab4db7cb7bb730fcacabddd4d2d2ac2da101d64a570028dafb4de62bcf80f94dc66346c67c6ec5a13f63c7a3363439c6028f3ce94c6eee36df11997af06a71551578cc881f748a05e0d895918c3b5ba4b8e9981ec7f5115e68cecba23c1f40eb378168d9128e27d233b58e3f0f6ae15d02cabb5a58d342bd4e7a949cab2b0641930a2f3153bbdd72e4021a857797354dfb27a7be61d894fb8baa50b66ee303e8bd52fcb95e3107292903584c6b0762e5070864f99d97e91ac0a77b21f923a4c222ddc1965ed96b965d8ef34f2cf008a2198f19548a2f03b8a357c6cda2dc84ade90b51bef3e53cea263bf0d2131185902c2acf2efef9b14de40d613841776a294ed42a23432ed542e3c41032474095ef38fd5fe2f445c18ff14b48036b98a604ad8cb7fe321156b9cef82a6bde8330d81e66e65a868541e67fc62d2f1a3c27eb53b30db7a5039b7dc7851432e9ef2baa4ca1087821314d144d25c915d9b003ff1337252534b27dd85efc6ef75e3d5f94e7b3b1061b38bd3b16fefc2798e894f6cac55bf22187ddfb257423eb3807dae3a696abed1ba3cd16fcd191de22cd5c68d25b2964b0bd4f88d7e481b3d1ae773c029873c1c665823fc726d2f7a02fd50c6661e28f32c48085dd0b56833b929745c1d070103a2db53c00a0835729ec3e9a97d1c50ec227d853e4e947e13b5fd3f7e303ebd7d2bb6fa4f8608bef6dd7af700244457cf357560bc6bf2d65d0e6a377ad88141caf7dff00147c60ae299f53a0c87a36572372317ebe081b8c5e039f862db75b717c403c75d00e5e5024361836675452f25c5ad1243fb5843a16cc6b69de2f47d33c5e263a2f20e1239191872ca70888840f1a813d7f76e1ea06a284bf802be0e3f8c597e68106ee61e21bbd346431422afd935eff9f6136b21f562e72f7e4661e6c7e0032c203a7e36681c5cc1060498df976ae2f90b75e878da5573f6883aa589197634ffad477f1cc22541584b14a4d07f9b9a15940a0380d7b6b0e7913d570e843a3759068a52b78f44c5da1763c7e96f7a008967cea748ed2f4da7655d2f900bdd0460801db386ea66d8d9289c586501bb014fbc68f10efc1c96350d37fd169ee5669e1adb11c1b5f5dc51fcbb2687ac1fb1fd8a0688807be6227ac7d1c97551e30b16531d8c8b8a54fb8946618b9454a8ecaaa5464898f653a09e21408cd74e1458665f29644dcdeeb90ae8728ad0fc166d37dfa490c5df878970e6889c81f9caf7c07a19bb06d1653164b9b715c3c452cfb034031900e6d3e67135d3384e58e52ca6090a005ab8667dca1a26146a7c6db80ca2e5dfe8acb26c52d2158b054f3340ceca001dc7b38af92cfffe97e7a39540be107e8a267cbe7497c9bcf3f101eba97bd4236d8325f672ad3fda19d52b1fe03feb338cbef4f68ed6c9f7560cdf974bf2a73515300b256ed0b326d307399018ade233be1476e30840e57e9c016b6c2b52203998e79ed0aa73c59b5ce33cef640f3e96cde41c937db0aad570640a15dab578e5921ad37797a9204429353666786f18f22b7c4c7c221426ed67ff691ffafb9dfbdce5bc3e6818c732d13c5540f7a21f58b4f228c44ca66860b077b75122c8f9353253387046d7a938d960912c7f0d8787caafb93460f94963d8d29ec746fa5a437f3c55c39f87c03f974a0d1467ebbfbaa93095f062ab135511e1fa2e829e83e5f8df7d2bcae543256347aa1d1e1c6330539e4edee51772818463c73a00c233eb4dd03a9053f7fba2a6787c84f854537d961364d1c54f0e92d56e834abe90bcea3231fe72cf4d2bd7e801377d02110a60f3f74e271c08bb1705493c541166ce3b88cb05bc4af94b189e6bb988186ff31f34fc45133a0eeb60dc166fca953bdcd09b55830eebf5819b1cda1fbbe1c20b27bc805d343f59abca2b237be3e41a512b11340ef00779773190ae3c02380be458cc3923862e9ec57e6c2a37c4cf8d5c874bcf35eb3a131788d0f2598fd47821b7be0b588b95b620c0317167a6fb7f0eebd783d7bf656bd221c408be64a9ac8c8b4015a73667115eff012327061c6d7340898b392b31e3245e5c7b5d5402e84f9b8f3242bd29ed52096c8c3955c10441c6e07d2331a1fabd82cc0c1df954622334df9b60a43011dfe54de4d144ada716e965e4f661b72ad258a25c6226c1d84ccc9e8e3ed76554941d4581cff59f6a2bd0b79096aef025b9af95d0df62071fb5e258f779562d24584b2ebc7b8dc504f184827e4cadb0df3c209ff70fa5e452642b8b2989f97c62f1c719881b72b569847f2f2ed2d97635cd47e097cf63cc25261fd25b603a3df1433193fb30299cb99332287ec5f266690320fc2774419e9cc6fc5fa2bddcd15c783e800a5358a4f37fc6543ebdfd6ecd368c852f678af07bd6f3a70d41eea6592eacb9930a83644998cf2c6c8a2db1b204102ecbee3d39c894a499e724d88aecd8be68f5d928dddf95d4e655ba886da1104efef8fe19f2692b54582426b5ba5035a11f2a2a0b20440880db8c42218d60ddfacfc55c137d6c0d513f4f5c5fa3f59485b710ff103c3656d13ff9a3feaf36b8d5690c81f439dc5cb2a1bbf9f9a24174709826dd2738d3d0be7dc56bd761857ceb62c29befd84d8d7b2aa033e55b1c36ca42aff118a0d0eefcce536062f792d65ac833408903ec6324d6dbb512d154fd643ccb6f759ed454014f33fe946267ac9cbaa9b35d598d5a1f2e98a1a50d2a51e82fdab5ee4bfdcc69eaf983b3c4bc1d0de4851f3989d3f7b01cd10535417f603b5984cef7dd655a85d219b75dd046dcb241f3108703e5e1d4a72adec88f26c9cc4f65206bd37d87dff762bc4160c347961f7dc0f9172babb111f9220743a7bf64bd6d840f59fd58a85868de6ce87104c73c6646e8e61a4b25773cb0b53c83b5c3d78f111a69285bfe2d3d85a215568e93f47edc957ae5c4634046f2e5e9ffbc1ee96819c9771a7e6d16ee12c7f8d8a1b845c03aeac430ec2f2dc612882b5ad94d76f23a400814f07d25cb3e9e4f07f988a26237792b17ba080d72a62259ff2eb3396ad35adb407f45e5554a8adab1bc319d138fa323c1e0dda791c5a473d88dd4c8109740e706c1100fcdff976cee3ebc8ad2d4760f03f9ef6f3495d653ffd537287693732c4ab86ceda243a5943244ac31e177d3d8e17f92191d4b416526805b6a9fd7331257e52a62f97bf1d4b7b85c7fbeab5002b86ce2eb102f8495f520051a1003ea8083708b9d77231c63a50e1c978c4dbc8305572e8e23375a603a06fb7ec2d7bbc63be9b77be62fd0395f50b97045da388205981fcbc95a81e9f83ac83b32b933a97689f613495aeaee3b8c707010a2e21eb33e5a7c4b807ff98bc3de5ee70ccb47150214648f5f1a42656a946a329da5d88113fa88b51813114d096a17a4b78d52efc15b95e4892dc316132b4f3124f08c0db8d7f462c151b7f15781f5ae6b5e1cf7ee8517c462e879e7c6407c22d8108d20bff66ea2b96017ec4a8b1d50f989adfb02d7c36722b247e472befe41bd9e3447c127d3a1892725a9744d35be3551cbb0a4de7792b9049514d792b82759ef50b984945d4b86d489ee6563035c01fd6e034ccc05ff03014d229a222485e84b6af7d6c65d937a9f99a37c27e6e8ea4e4f47db7792256522fc338141a036d6a49bb4fda54c59d394c6b0aa766fcddf6f3bb5a6534233e67320be03a41fcdfbb69f90a5ddb3af5065808731f2c80c4279d799b47b80496b6f1f9fcca288b7732004ae24e78af686856f4c9c58d2407195934ba80a0849357d2f755b99a47f64e3ef4717fc5bfc10a0585cc628919acd544e44a3eb1fa8d0675b2fc34218f3be03f4ea846293f15b57ff9c9ade80e915296f69944aafcbede6f5f9a12cfd2765869ed1814ebd07a97ad6281c27c063dbfc5527d64b66f541532382eb21fecf1876375ba6f335b201d624f7031c896fe77f87ccc67ca3eb67446f8ad6e18aeba9bc84f0167dff3091de26dd8384158b95653c931adbe6067abfae90837e346fa3a0a97c644942725fb1645897802a42e297085d1cc1a83e25be7631fab8d61f1398d5ddf5dddbaad54035d71a91658d453992ecbfb0c586c07da7f70a8178cf822d971a6f885b1cb5a1081787ec4b2b3a3626e66c6a5b28d73200deabeb6cd4bf447010f790e6fb5c38e3e1380bd78b96b5e01523a10e40d85e786af030aa1cd9b8e854f5d31d2bff76e6ec6f80cf9c8f5270206ce4dda523ae094893e8ee040b0d4a7a1ba0b97e5f9147652f717410ec6be014e151e3fa150119063aa798aeb2830c73e8161eaab73f99db49371b88c7f44e78f1a4901ff6767db0068c3e013eea49ca058c8ffeb8b1886bb9c97060035915ac3ebd2ffad185ba13f01f2fc4584ede512f9120c3baea3d8b231f2003778bc4e5d70233e0c7d7688d52cb82d8c48db17231ac1e7030d7459fd39d470c77292b29ed72b55442d6c9920e9687e3125d1ce43f2dd06bc61cce3153dde5db7a02746f0a8f01a7d274ac790bcc082b2e5c87d018cd4e25ae46be47b5eea6748b28008170670ebb900cfc742fab483da31981a96ce990f6d8e2ef7972f4c20f35b47173c4189c1b7f56e5949eb32a0a46504fb69e79bee4891e8db90c506f24b4d082cfcb156dc7980f3ca30d33dbfd302a9aab0a3b1ea69f48512d7d416579a615765ebea02f7a47c6a22e7a45e7d3e821a4c51819e21c848ba8377dda463986ccc24609001aa4de7dd52cf0f6f8819c7b9d5c0a258890affd502086b351a9d4e98e1f3d32c0ed042dfef47fc9e66148d307b2418983f6a0a34fc17c876c3c3c2e812c54bd5e8222ab7472cdad1a02c3bd3f5f11e2998851c90d291e665d1ce19a7beecb8e77a9be75345845ddb6ba59b88c70d1ea383d044a958781889eaa05d92f13e6570b836efe20644e0362b6363bdf9aa680d3f137894107b51534845166d13ee1538e06bcb928cc1f25bd025b3d34acd3d7b53e39b468224f4806ec05120bce5e4620acd3f0b5608fbc476083b9eb356a5f8bb3b8636a1d15ee74cb0ca3c0accf51469963637aafd6cda4e18e8823883526f9fbb082d7ed75110666afc3773814ef65ecdda7b593470f1a41f952244e35c3b29b27f16cf78329df1a1928eead28140d7cf3ccbf7b94b47e721ff3e5a41207aaa5ab0f4dd9822725a4a596f5a3c3675ea84de7a75622b3c7e4d8afb7cbc8c6499f3160a75be1258e4e9dfc09c409b16a0d4bf8a5dc53145c7c96dd13a4f137ab86933c97699b6d4f620aa8c0b8b8b7b64c332b1bb31ac7e4a7a78ae9ffbad004c34441b37b52507fec2ce2c20d85c5784dbd378882c989fa6a7f09be98cd1b4424b085343e48cf12d00585db300fc063729171d98347650ca748b1da76817f7335ad21eedd208f4cd80c2df651bbb839bce70a0e6dae4da41b90b429180fdc52284ac957a0ec45b474326bc158c48545b5926bb7fd183e8f0c00490425a603d1ca905aa2c8bbb4d4d37f3966f9e1b0c2affd30cc8111087b235fd021812ab92d75b162d2c33a90f8f72e5ef808259023349c3c814f60fc256281c5a23424353c6e248afa55bf206ec65540bfd18333a441621157ef88bffcca9d55dfc3779d947d3700ce5355290b20faef462e8986b9ecc12f1d7a3c8abf63e443bdce9070b69c6648e133278aba8bf5ac3b5b272a105876339fd567961c0dfe909c026645b2b7e6ebc7126b153652679f190eb17cb2c21651dc9be3b19b87c8aa72ff31a37769b5aa852ef4921110189df7389adb1f6c48e9b4467a9f15a9e64b121b8dd5cec9547699889d5f8ec7ee4c35c066e327351faa60ff73bcb9f3fb73ca7d2c76da1a6edc0031387772ba80ea629591fb024bdb543ca4146425c85fe07f22af0f3367a2cd8357716e812d5cc80ae6a00f9b1202a412afa309a1082855446e1e4d166f662507994025a867a3ae6d67ad0f919ff723d9354f4be2cda0d3c847e510cf3548729e9cfe25b4fef36f6bc8458db96dccbd0a96262ff6f896563fed13102c0dac5e1fc1341acdad22402ad1666b4081cb3af074187a3b2d15de335ff00ffa8772aa8362c2f9076b31b5250c9a651d926d6b5d0ca747f6a5f26b95a3a259a0c1cdbed295eceb485d6e37a0245e2a4caaba8fdc5bf4391a2cd7832e519895663b0f13ac1ae05b9524bacb538fcaca6fc601ca9610960aba79d3484dd4213691612811ea22156c55fccf23ea2042ef6b1ab291babb32d5b9ed6cd644ffb60bb3f1a6db501d1992a7dd13991caf827350069d7d1c325355e7228f9c6e73c5eaec30ddc44759ae4742e8745eef487d9d8fab4bc69bf690b4331483637e853642d25d7836dc06745dcfdca750924ab8c20550f0103f9fc688256e21d9019d99bdd8fa8639d362a2ffc15d62951f4863e7e1f7f0840d818fe8091448f56d360fe6a058a2e475131c8e75fe589417a8fe3c1efcec552c8b79754676d3a1acf9614516ea1663de82996b0c8416933cf36ee06013bd27f29534023366481d77196dde74855a9fe1dca9e2833a9439500ddd1ff1f02ef0b0856e3e9bf7cf9af331f3ce436cdae5ae8dc374bccb4c59ef060ff329050fe87b65e66222c4c04455bdbd8ad90fab2746578e1a80b9f247612eaec08107063f29c76371ec50d596f73c4ebd608351888a77c7f5cd106866d8e3771760a6c989e8076775d8174c863bd15fc71b22d36b857482a8e435ee183f1e2906e0509a4f816355dc54e93b6bb476cbf0adf7a169894081cd656fb4201eb29f4b0f9b5ded17e2d1091d613ecacbabd9e400143463ef82bbe499d90fcd96ba8822e7d2fa48a4c9d46a8c5364c11bf79a9b23d67f90b6e41be41ccaa8a29fa88173dd3d5210453273f79a9c89afd030d5b5c3de59627a6250f370e22baad0cc2b5166e684f2f34a68ba45f956981c9f2c143ccaac647c945bea2362516a754742994805ff69c80688cd3dbda8c73e68f59a859ddbf0409ef90da38fbafa2f4c3c85b92f8c70f4a579980b3ec7ee116c7eb0e673e8f1bcac31834524829606436c7221f68984e37b74324f3918fd3efb88b1323fe98ec524da6efd67dbabd7b58d55af5483ff6ca25b51b36bf3801d562a2fa3625f8e37cd9dfa5136be5f372366a426e9e3eda2ecb7cdcf8a80bc345e02a8b8440d1bd04ac4c0b099caed084235ab261e68e3c36f355697901424992761617fbd0eae816e4523b7ea9bbbdd6a28047518499799e1a2021872bb8c867bd3a2f1e63dbfecac43e3cf360907e9d6ae14cb474e7b2fee7ef0bab0ce6ad1461f35c9354a6a5488160b76762637c8d10586c342b0aa456b244d5ad6bb0b496e791903a15be47738ccafbeab8fdc93a4d5437dc1332f3214a0a3c9f20116525bc9e3b35412765afc420b67176af21baec1edd6edcbdf003ef7e4c478498bec11383e667e01a77cc5c5ff8743f67e19b353449961435f00e343d89ee90c7cecf9e078f017652a186baaf287c3c2afb872ed1a700d8b234c0997b8df4a6f597a3eb269d8d9ca852168bafc1bf9bfff4f76e47a275d34e8a84ab116aee021d4edd5a680aa8f176f517945b84f58f901bc2b38ecb488ba611935818c95399a4f75f8ca24ae9f02a72940d506f811589e5f1ffa61414d682322253afc05b7ade7a34bec076ede8cdb78ba48a75aad69044371a35f35251ac01a309415dc8749c286c92e9a0e0f028fbdf0fb71254e2520468d65fb7dcf6e87e055b9e342d9a8d0a920572af86a32796a5da9fd8ae1551b9b55e0edd158ed43d3e176d9acc51413379f0d58debb163ab28488c2b33194c5e9ba540af817bd66e7fe4eddf4e5c56c6f2e59878864c2998d06c9338224bea5dba8c2b2628afe483cdc7dabe1ed54d81d8d5e9c7a6402d20135c9cf24ae090a4e20220191d093788da70d50523a39dcd26c31d7bac2d840189dc466b6d27c6e0e0005a689c95d36ec5fc6f3f5155d9683e4c25c913c988e369c64db28bfb751168e1f1864f2b05a0a54a482b3a893ad9608f56a5f601feecf4b3596f8e93088f0e01705e1726bf1cc639b3aa1ff373f7155adf684caaf224bdbde4cd62b70e5f3075f332c1ab42701147f02d995085954ac683540f4d217323077cbb7a6cb34b2dcd0706dece174c06b91c03a97497558b141829e0e66bb2f22d4e9507e10e080eafce5a5972f300babbf4c2cc687d4a70cd7418647b6ecf3ec129cb92fc7e8ebf9509e6f91b0b8d80f336daff758ca26c451512ffb94ac4ae36337e8850a52c91f24ed32f8fc4bd9e45a521649692a0b93b9ad97bb77f0a86731004a8f2df8448fa913759389a7f985905bdb372e6ee5c9e99eaa29405f9a63cf8a5fd29185659338c8a87bed3dacec867359b56cc432eff1910054e1b5db596cbcdb43684465bb4cd51b5a619ee89af645187c268b0763b0aa43cfd058cedc779161cc1fe1b2f4b2756bd6908c385bdd8244104b47932a29c0a077bdbaebddf330c4c028a0edf65bbaaf8c13237fea0967822f77c8c78c47ccd3bb46c9c0fe7dbacf201dc1bc9b3a6999e26c92813afacc60bd80720e354f5a7711aa7c5339511e021796d40b4d04c41da8811c1292fda843e40cfb45134663b99d62c2d03cefddf8349c894ad936d9cebe1d2303ac7d2e247b08629ca469eca81ade5ac7be3ee68b229e8434697aa406127eacacbe60c0102db04863b4cbdb1a3d4b8fedb1f7753777d7836b7eb75762ae09ae01f0b795867221df4ea91fc9d94f3a8696618e251af9ef9e3aa36ba1e3a826781a7a6b1ea5b72fbfef76b7aabd642b25f810f9da83fa57eb2630e266be17bb6d9f9ba34b0c2383ccd1ede6217247c0bde826e0208e6dec815c380d9134895903df716ea232a8ee8b8d10e143d32b08d732bdbf51cd64860b10755cddf0137bc309704e04d3a296cdc4b586005ceeaaab5a84fc851fbed55d4dd7ee576e422a3eeb3d599ee2f86e0600ade48d816e7bea9ac9ef350e54c3f45178809c9e8eecff3a65f802427ea042e6af8b5daad1f07a68c01c893052f300df840974f7077e35030b9bd4f0d11bcf696702b02a086c23d8fe5375c75d944867f155ce5fb7055c842faac2e043b8859036b937b993788a29bd40912e543ed7d7c6ebb97c5c272ce4a4859580875a3e4576d2b84554f35375dd7e5d4ca6b322d7daed20b4dde37813609ffa8c0e3f28070fc0b500533850b5f6eb92be7217c4426cfc3b80546051aa03ab6e2938969b89b6b09bb860009a37de15c9b6489b68bd551e85de73321b9b3ca596d1346d70874ffc18b6816fbd8d1afb421696cf1c14faf4a40eeb0453189060e068c88fd7694c62b031db503f4b842e56a37761117aa1b541cb4e811c639cc9269e26d7d7ba588c1fdee1afed425b16bd320976873040830d40cb2a5a5b8b0859bacf883838560d71cc51137569d8f9a455be3fb35e0f2401018113bc70fd7b1ced9738e0a85ef7d5acbbad33b395bdc326af0e2efa0980746ca6776f50f17b1660f9034f63a943def0993b7833166be430fa36fe46fa0c15b9ca88c4b6e21441718dbe7f3508b2c6fd1c7b015d43c4e20ecd6822567755dd0182f37911e5f3da17cfd4395aa73487e9f7808bf1a38d5fe9fba3f1b4e53706db01dcff72296ae6fa2f643b6f1c902d4a815d47320cd2f5ca7e68280ef118f303fe7ded5ca7edc80a93e801c7024ef20669fee2feec9e4ed53b5041a9e4a88072f8696f9653ebd81ad4f1b0e8f8c10ec461e8b07d2d919e53b0ac06946f2c0a6f3fc73c51551883848a3ebf508c6f64ac77cfdd3e579e9e8316d398912e84f3372b63514af6aa42885fa07d5f8516b31b1ab95fa5007771c5dd30f9a1ab01e762c3b59d7c6c9fe33611b60583bfa555137c55c265dba3ceab759da2a4d61111db0982ab34bd24968b584ffe4a0ab9ec5c8c1a27dc0b07de5bd1ec8f874892b7873c7c776c4aedf10036b843d133978194283b1849c8faf93c58056f702418a4a6fa463a5dfd05104d4ee431ae138315174977d4ba74c9bed30af868220229ce9563e452834490813949073d83d8f9fd2ac693aabc642c5f650d52a4740f9a80c89b21e16664318c28c5bb839d5290831b3a76298304a76bb909cca746f8dc3e175b7b8bc8c14b119c988cdbd2cd58fb283a6ae2be4b13d43ee6f53d8329e462967debc7f34102bf15ae008300f7e106f05adf63df8d1346e149658944e02bb4c8969651945afa5edf2560bb2cb4bbad0f20c61f3b1d6e1b2e9783e8e6471fcbcfa33e08fde74f85223ac2aa4b4784a7fe6618b9839583b8b6001b48a02b74f16f36319e15afe1e53d17e4a8eef0b2e2fd970e2b6e39744ef3b0d1f9f9058bbdd7e96635a531a3cc14d0349373e258bf608c208095907ece4e1f7e014e2e25c729d23d50f32ee44ba332b8b7b854d1ca5e287f4bc97e7b4b36b47787248d49c5583db2ec33783721ad993989247e0709c6eb99e54ee25ef1b5501a37797ac8f9b49a0c6a2ea6ea289235e5533b6f494ba924a212911e2c426740e82a629ebc515bf7fef2952610da8d23ed24c95c0c8b534f9a75e078a1e1d01da2bd224dcdf16c170e7298c9453a03fdc877351e7041084ec548c541793e2060cdeaf2227badc6bb8f5cad304c460e4bbea5f3aff5333c3d1ffdc9003f0053575b4f4047ae11b14964fb96e31bdc943d1d6ff85739fef03d9ef5115a9f01d852b3400966dea4a77961a63a3bd99e8ac50e9f6c4db726cf5e4f2b8a942fcad2eb6d82fae51b5c7d4b8f40ba085fb0d198cb1595561f8a18bed5c66e1f441d9e37f73bc7e06acaa5cc12a2876648813ebb3ee9b66aed67bc0de9adc6483aff08ad954cf5f559281f9e52e958aa42678077f114a0d995f64edf1b7a98cd07e5c7dd2866870661878545f02fa16243209a893b56d25ad1b5344493ccc76c5e67b73cecaf22be69528dc2d957015a5319d50ed42eb8f7e0428683f51965e5e092fb8b56d38e5929e9efd9d5125ac0f023f9bde538be997fd4856c3cc4a471151e9cc8aeb3171696d5ff48294c835cd863814cd5d2abcea7a53d1cbcd59ef9d12cbbae50de96543c3c25cdd420b5fc8e79360c573bd732aa0edfd45186d48c16c84e14bfab397fcfb616c1cd9b5ad469b795243cf2b9d9cfb75b0b87181b8fa3df5bedbadfc4115b64b829216a6db7fe4443f4cea30923404b611a10519c4d18d219d02bcf26804f8d477db4d2aa79de9da56caf66a0c839714f0fa3cb93425b698be261fcb3bb9567537f558c881260c6dd61ae0aaf33741677a315f31e4a28ce9fc4f55df5769cc6233c5128fe346aacde1756953f6845460ce801a52233e143e8f0ee862e335584d9bf7db2ed6abf5b4748df379acef2c0330e6fdada54530153dfcb0aeb8f393fcceb3303c8276502b4c12f4002fb88ce74be5f38cd3ca9f18704f5e715e76b4595b0816b5be4a1397ea5e0942c66f6d8183542941aaf23344019bb09f2f13891bdd3bb4583b4e902c134d915b1ba39e890a4c1dcc435d957f71e703486b915ddc774af74aa67e8290fc14ce208a49ee220299ed4fbebf08832bab3ff15ed7cf9c6540a1e1adeadd440319ac0d208cd82c27d59f9af987d3c10cbc0637c5dfc33d8e5e10c3659f4e987368d4334551c5cab3f21a8f1e5663142d4255fd5f11428979ffc02e11063758f9374c8cd3f57ceaa6603d9f5fd1bfe867cbc5db1d774b77924b1310fa257a5c11e73d35f7ed51c772475e85491abe06954480753457c8adedad4597ae06f95dde9f36bd00a42f01b92ed37c640c27e70dfab63fbcd66643c4ee763f32f40969689d57c36b849438d0c54135a810cbcb1f36dbe189817a5e1ada6edd09751fb43c4f964d7a9e0d25171f224edb5ec2e1eff2ebd617c542d4772ddb515cadf7fbb59be66ee3530f5a77b732e7dcb0d8fb04583b2d873a320069de124a869864b324a047ffe095af6de4ace97becab8be5f03b56a3c56d8b34f616255e61b4393d54e47d18adfe4bf8d50280c8a7db246ff2855d7bc7d14a8518d7f42adecdab9b7fba854083cf6db74f268b5a263d72522573f8c624e168f0e27ddab2bcab36de10751f5cd46d503faeeea720bff67a8c54f9ede207927c7fb93d47a35ec175ed39354fb1717d657b0164d4fe1c9898f7794ca43466123a57ed89c36efa618caf9ea2a48a7f06590709a1f199f66a6f515ba19c3d47dd335ec609719ef5d24bee77cc3ad11bdd84a18ca09b481df737247e7a0371e375231ee966bd4140cc9c542b96941eb1bdf71c7efd42f6ff2e78e4ffd07ffb6cf1b5c68713f9411d9c10510df789c1df0f77e5df7f51c3891555b9e0476016ba197dcb194a53a487a14052e6b514a991388f76b92f2ee79e1750d8e58ef6dc0b498cbf2ca7d38157b78badda52b195e5b2b4bcd63b35124c12b1a537d1ca416e6958cfc3402291dbe1ae1d5a3de8846b6fa676464cbfded4786c595095d5b3466236eb6d44c61f08e95643512c58d382b248ff316db3dcdd967fc8417f6259938014568c0b02d9e5fdec68abd2d8cb0c50394ed50b715b3ca7410765c8c1efc3965d5839de7ba76271b77e8c4c9ee46ada41a0816f9dc0a6a8fb283c1d7fb38bfc5edde390a1b4dfba42e3c5db59d910c9b9f6aa599391fe1e734b1fc48e9916cde2e6ef7d4dee7f97457c2ec7a0fdeff94ccbc5f03edf00efce39ba4ea04326f4435e150aeb8dd2a304b6cc038a7f3b72d5413e13ba575be39f16df9510ed1d77e636ad2894b51932802f16ae8475d4f50684639c593253c667154a4353d88a31927f5c03f52344ba7275502f91a0f235a8ea47c7732399269a8e4e139d5db307826a0cbdd8872867e683fea387e094384f6ee413141e457537a6b0848d8f472430b4c5be187759c6162945fa8ffdba067c506e352845c4a29871d85a4b876b18fe3260ae08c8322987a1099aa6e5472ee41722167e56e02e1f52be5082cd5547746b17dd31ec8865fcb8e3c1160d675c4470d4500216cebe7e914734e4bf7c0abce78d34cf92566973e16e13e507fbb7b7e82f6f31fca1cf8d2587dbf2fc7a0ed97461affc091ad4ef42c307fff85d995b7599e74a5e62f1ae2a1907a5bb3297a6b775919cc67e4d99f986a58ec4fcb806c94f7ce804d01060c86c7298b32958c0a53694c082ae042106407747b8ae90d5d50ad54ff37d6ad29e8e57383bd37362f4df68c35a3ac7ec4c1485b81b17aad8b8852e115e1a3f2bfdde92be9d378ea9fe8c19795afc9b66b6dea3c21fee0c734b50347ca0c7b302b18ff195351256db294ca29f23bf6cc157049d04822dfe2ee7663f1ee5ed178dbdfde846f0fd00297f373ab283b90c53fa1b14bca8e2e7c8a6e7ddc4dda93635ed7c23a9babe7fc16409cdf8140c3b91413011f460c5b5c6e2b978014249e95528f26c2446a13b7dd76ecffec7e988b645f8ac5d488dde0ce4f7c060713f97d7441d37d961613cdb89b293cd3919594410d13ea29c21d95ea0ef349bd6f3c37548e87b30ccbd7bc5c0ac5240a78171ce82b34af4a4f106a04816e57c726831a89479de33802e4b1e577ffd62fe4c2b2eb798f1d6fc00a8ec42939ffb6f83e77da1c9c0b51e54f1053df35e21620c7512928600e503eb81bdadb31008f3293d089f1b91cb44f7d3057a4991a010e3337c13d058b100001f1c2dc8c88be56d8164a3da3f14b5b038a2cc932920c72642b5128e2b84a1f385ad39ad4d7aa718884c260ef8f7b37af74a67494b164d5051416a1428ae0b0a2d0cf7c34a9553290478b3b35a946f399ad208b7e8c417705cdcb9aaa24374a585ab75dc95192d3c5b5c981aa18f344203543474fc5fdd73cd05128e5621b0d22fe89383504bd7ef0a26b575793f5432f264a8f00b11d5092f43ecca2a0a8c9b248786ce33eae43f678ebaa41b4a74d8d549176e31a7be97a17697d47ca8d865042fbbebf1fa60f83d5638c324c9bf78ad025dc48767f047de03e3e7882091fe1b06c6da5c816a4a116cc05eb426166b06662fb43aa30ded0b2c4b58c1ba2a52c9dcace13540d5b718563b5df7635a67fd0670fce2d65fd76567a4d3aaaf3a701bb2299b326347326a43b1580d05a606c9516be6de73bae783f4cb0e4bcb23bc4aaa60a0e1dbb0c342197e988f7ab25c763c6593b25d22e1b0151b57770ac873d0b91aa2d21f98750173bdbb015fccbcad50c49e96a5c16a10d587f8b41c8f68b2f6cafd7529f31f4c9ff8fa0ccd78e0e2c08a1dfdaa4e1982a82ee3ba9b6a9d0c6532b6de1bce95b4a634e35eac905b0db2e6ad3a597fdd9a16974b534f8bb06c65fb55e77686eff6dd9b3aa83919e2cebd42b857bd4b232526ab8bb2b0cc21ac85c22de957878f0626ab3caf90475fc482230e432c910ef4fe6f0fc9895445e9e0ac2322e2e656e0cb797ae2c25804b4c03cb7b5ab3d1c86ab5129e5514f85bcdad3db23a557155c5bbc4860bc86578c7d08a261751ea3436479464ce98389f7c854731706dc977a1aa9052a1dcced7265f881ee14060bd5e153c504633cba073e2f208b161b1a8e7b1c1b2c9a3ca120481bc79d8bbc17843d389371d8bb5d7e175c06b656196ca22334b89f2573e39116ad1af90f4d5d3fe7c65c04a10744d972aef22a98922db9b65d5fb91ed5ff2c6e483084b6c5f7c1b85185b8ebea979163320bf7f378bc48aa66ec864106c41eaf0fbfe6b9614f8558015d1c7d1fdd492fc3ccf38089ed4e35de2e227e4d8e9c70b5c42d964ef2d93e8edc46b1479e20d5423b33f5e6d12b316396cf9ac2ad4d6a13eb74d7e89448df82280c604f355f92b76f4758715ad57ae868206bff86e8fff6edbbe4dec472767e45ac16286b1dd9e9ee375e5ec7839b1347f58dc9e1f68446f2e53fa401f347e6b319a05f2e21b68a33659d51de2a80290629fc8dd37bb2e7baaf25ac7a0fae1fba1e79d0ee92b4082f9772bfc38b637caa344d275f602c235693a0ab6d8601795bb45bd820031a1d87272849efcf607de96cbc77417413347cca29dfe59be66462fc8a72de2678d855d068882067365e7c4f64ea238a32c35b5748a57e8c6e4c929f4cfddabdc0109f994f69fdae5200e79a29c8d835cbbab4212ac3ddae3f1c3356c021a485f2ef15c415cb81f032210d2e08a78495786e31ae47a5f1786f972f41a8beb5c07401f4c1be31a1a345afff47d54b04fcfc00be8a1a25646f4d096810c0c537e2d961c46b7bc1157a490e066072eb3c146ee1a33f0d8bcb7bdaafbecce404c1278e2528bbd9f2f214ffcd591399f198672a6a2df76cc1a8b19e12185afccb8d1f5b4d3cc38159299be4c7e25971f7ee05893443b2f2b975c7e40ea01f433da43f846eb654f741bddf6df8a2f0dfad3a8f49c7542ee5969d6c066d24c1c9d3a12f6794267eb11a4074bb44fad78c3477f3945398066d7f59f56a27df4010688a09cb011d413d18afe2144cef793d34a3eda4ce49b4ef4d7fbfa5b86bc9e3d61e584b27d9d4ed194deb4faaa9107a02171fef33dbfcd39bc802a9cf829e2c180897c931d87ee964401cf49c03b4106cfeacfe21a7275ed3575286f543b2d435a6646f111331dec9cb4c126552c4f84dc4ea40b70a141d5f202be7ed6f187b02102d89d01071a9a1550097de87d296aec6133d1f6cd428971c6c34c9a5183a7fee54b8dcc93aed51984829357883b4c489b825bde30cfe10dc91732496799bbd078647db65854c0e9d613a782f35c53372ab8a5214bebf67cf1e62d5efc72dab51d2f90d4815d8612ad77d2e32ed93b5e3ce46a7d26709ab9a3265d7911563699473848885b143939cb8e49f6967b72422e93f13baa4312055df7c1e1d91064644d93a7967d43bc0094351105088453c8442f5f9ddec2437e3c659b2186ee47fddc32e90ab86e1e99346f7fbeb6ad290153d8986df561be9e200d513375c004cafb8d11efc4c9e9185d516d7ff882b024cc878a9ea60a90c5187069b108cb3a1048cbdfd127b34bf737c6ccc64cc13c1d0412e97fe42a24e2e1c857e71c4e76905275f3f5e153f4bfcc3","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
