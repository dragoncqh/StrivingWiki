<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"db3ae7a3673bf53acae044bdbe7c0b645b81891464ba97fde6d6c08a6a3d3c4d9afec569ad9af6e0f4f5b944249d775da607fe42064c3548f39d7b11bf60000f0ae9d3bf4e38917e157b07c2da77c690c5db8571d35197d49e765ad586437f6f6828a4a881f1bc52c9a1bc9024145a64fbe9388891931cec1780ae46f17e980bbae350f34b2a2c3880fc7273c3c3e68c5dcb49fa2acd1a89ce4533470909a93cc1eb1dc362f0b3d071946b449522a69d1c2eb182d43899953ee741b40c8fcd79678a2b40e36cdd17b880b7cd219648682f43cfb7f616e6af1785d36fd8eaa6c29671c89ae3268610312a7dc086d63f25f1f716129cd3237a7e51ff728bc9d0cb4b4d4e8490df50469f31da7cf9f70c1ddecbb8e770ed898a24aaafbbe6f773e5cbce95ff0be9e003c6484fa235a3a8a4a8a0fc7fe6f1ef7399013ad2ffa9f2183bef1cae36403a11f48c0984b49fd72885586ef3978c976921a9a9d6a13e7bf361907baababcb18253a37a578b3704d102cb9d2b09678d0f10d6fa28b184543dc3556729f77d601e7cddcb5a17321d6302e338604abf25479a925f689730b31acf7d8b7352bcf309a5473de59514e3964b2b1a7833f8d75c92d76f25c7b6555446e006905cdbe4721db719e480cde2541f286b07497de64e7bb2230b86f9dc178fd952bc53cbd04bae22aa4592e9403ff4431dbf1b68fda577da41d46878604f1a54cf4da350ce5fc9fffb5ae34bdf27013bbc7fb5aeb40df04d393d903ace3b0ae693ff2b103367face985842ad37451524514046f02b10c76a1c29b6322452a56c323d18d8b60a7f474582a35cdd30d3f38bead9547c066aaf7c2ccec61b82b9261d1bd71a75a3d21e358bd432d6f02bcca01b539da4cc22ea54798a3fbe1338cae97d7682ae73966160c342a71bf40469bf1c2d3d43fe4867fa911845b40b895d25fb2ad5e36d1d2aed974e2981cb09a21e3409bcae89bd99264ea8c25e96bd786d2841e2a705152e8ca61eeca304a3999665142cf13bdc1ecad806f3d5e50f13e176b7ff1718bf3bea92f9d53dabb1393c126326def928975cd244a3184c0f357ec2059a207f808242db82befcf5bd3b6dccd248b7b323821985b36a8c4e40976400ca6211a2fa17b17a09e9f6f7aa0fa8e76cdfe1dcf88fe0ead93407974481eb369ae78ea804fb93f11f6ab498537164b1f0e030312ae49dbe451a45e2e4cda20f767ca1d2c96302341bd4726ac357fddb94e66ce96f298687de893098768464689874129450c1ece6eb448663a03c63bf6b3b49a40b8462694fb41bcd3692281ffe058c636e81d56176352dbe7b159c8f43d87b1a6b86ec6bdff054105fe3d169ef943885b9ce95b21bc465b557c7d93d9ef7e80411158bbbffecdf61dc321718888785d0dd9a1539a9ed4d968473cfcb5b3a938a48a20ea7c4ac00a2a6f4fd5b89ce359493ebce5464a3b88353b455ca81f7c99728582791ccd7f90a4bb6bc49b434c9c616b58fecc2fd2d7d05e31e0b67f194420500eeec7ab58358454a90f091ec3976dd3100af65eea4222e43dbb4e3cd020f1c1a38ff21c6e902d1a1cbdf411be7709b4f3f0b345d696a0255ce42d7532461c2944f75e3a81a8e0afe1a761688fa11e50267717b49225231df6e02b3445519ab18b0e6a78ab3c8b6e5dd5f9191d8c63079095973d208c9c67956c7bd0bed476a854182b671f71bdf85c4c09705b5a768b94ca1dee550e4f89ec1209e05988ed8ecce0fa66804bb69f4ec8ee72cc3c1615c10bc83773a4cbf9cbb2176b84ebcd6d88c1ebee374439fa612e962718693ab149950be35ff79399f5c195325ac2eed667ae02b229c40ac34c5058e2be0bbc5d0fd3f540b95507c8d1e336dcf288419116c649a6425a462fd2eeb483de37add12a020b3a279d145b4109222d77c85b21a804e7f42b875b1dcfec816de204717ca25cccda804849d5f4428ba76acf49f8c6c76b63809caec234bd2db13c16fbddc2cc717aec19a4c39d5f9dbe091e52ea892a34ebafd2ee7f3d7f9c2102571d369532bf655e8a977cdd8c25f3ed601dae98a3d6474a2c3fb041d334df3278b49c9aff9c1633693ee66cbe45a1b0b4e9a6425cfbaf05c958da3b16f599ec3895f65522df66611fcca345123150d81b431d1f6598fb6f72a7ace3b971cf1951eb29237222bfa19623637d5f1248d5af893009b0bb358df6031125cd621616e746d3cd3bf396c64fdee6bffce09bee7250cfaf890b99f234a367c132b2255d565daa71efb36a6586d45f7daf0b8bf75cf4058655cb107f7fd1cce2eaa8741fa6d4d6a5328f3b586f703e7b2f943aa2106db61c5649d9c8c43f96920231257a246c6da799b006da3b4ed5a6aca13c4d4dd0fbf38ad7328428e6a074600b6417fdbe651521783436d257f4aa20ee28ff7037755390a23651b973659fb5bbb54639352e23605b75ef484487c586cf858da1e08f970be60f682592e27daa640f327ee9b77a58dadad70232fed112fc7d2e4690ac36bb8f4d149cb28c8bc4cd95ae94e136ebccbbc55a56ddcb244927e6b6c174c9c33c48c0bc5ed28a37e07db11707a0b9b153d508f1d6a6845cc746fd10ffa1242c53b3bf57b312c05f92e5e927388576be9389f0252749fc35506b75e6f92669cf5576bc87694f076c449b947e59263c2002367e2fad59af108db51033f3ebdfedef1fd6365d108db494ac661f727255f342d2012434e18f9d49039750d47aa2e31be2c4daacb58f62d3ca816f87c5796849b0311832ab9f33691f8ea8a83ba8fe908f30df53dbd763aa7be6d2c8eabd7a633930ac1927cbe47a71362028c5047a7ed5e5897649e2c1bf7a9cab09f1ed478cd3b86e78ed04cb75d56bad0c067d3b14414eeb9b23d3af200c97a804e1791af45185b5fe3aa194058e34ad178babf174a31c27838330f2a4643feae990a77800e562b614743f845a77199c51fcbf1f2e0a15117b929df0561a3bc3d32d4b7e5cb70826c78f91ae9d5e77969988d25454d5f18dc4d8514d6af61dac9c1f89e1e42186d25359bd6f0602cc981d16560cc823af84760b2b4f595dc39b7c9fddafde0e22e9e22ffd175c5ce2b63cbfc0654f67e516d2113ad80bee37434180da7ffef0839fc43f12696dee7175af783d1720126024cf57831412ae09684fec87c0769773ea756127b24594829ac7dd6fd952050a1d9449480b373f40294e01f4834977859cf5a5ea303246d2ed96a4c05ed938a1a66a0e8182df33f9dcfec85d111df6aded0488c678b0faf69ddd831409bc39856e89d27866a2278346e61291c48009e2b63fe704bf8bdd70c370bd70e79990a66e2bc51436d149386157ccf449756db321f441e48b39b2656e31849d06bbdbbab4added3e9d3487c5c3f97cffa6476efc81d7e537eaa2372a8228ce5c53bfa2dfc156ba2e3211b367697ceb6451d2fc921f068d61c17a853e1bac3ff310297ca6e68555ab1a3a7abef3bb2ead481c495441fc77bb7b9bcd3e9980b9d40ff3ecbf6aafd65e3b2e962840e35b7001d0f518d0cd54aa3ae65b7bd764c81075ae613220bca795031205a0d04c46f99db21a4db41c33b530514f864c462ef8d749b1a6b4813b3044aafb818edce1b8d9ce3f821b99d0269f60b86428dfbff2b4df1fc89ac0fce2fa508856bd92b84fc8aa94b3574d6806ffcc501e898aae9e4b8cc6a03f03fa58a463f10711979f13f0b4e410e9dd45816c80c33ae3715332849d4b6aa2273d8cba163b6f2b86c397d5f967423c8d229328fe4fbe7ae83b178dc8dabcc1a93a623c98381818e358b504c1ea270fedcb4b67f49b68fe6ab71ceece95e98b6926252c14c38e5426600aff81f804ce08f898aaf65eb6ea30e70249626a081d6ab88070f08762ebc280f3a03180c8581600345b099455911582bde090f9699f8e6c0e145cb4ad6195837fad48b18b7e60e0a1a4dad65f5c2538bedda87f7d5192a21ea0e134708565fe625080f903bbfd902424467b551f6ba5a5bb09691e7cb1880de741cb529e0644950ead2caf8f659724751b9070aa50a62cd3cdc9fc06c0cd0d8be7211885a05413eb1dded34033abf279940ef8353eaba09afd64e6da5c3fd381df8d553e84fb9b6e61ff33bbe3e1977201e99e7a211cc9a55b2c7a3621e22b4d3bc7c7f2750633b3fcabd835b7e626bd50efcb5b1a1562f2c9709e5af24d292a341277f2a61132eeec4fb8bb92059873a87fac32c9bfbe7a4ee4ecc5a9066bb4d7130d96e41977e42d20dd0084a9dbe4ab83aa43b0a5c6dcb1190badeb2732837368dda7365ca2fa6efc07ee4c7bb12a90ed8348f9e781781df104d703acf45b3ee17877b76741cc4a67e7be0e6bf0894e766137e8c80de0df8bebe5ebe9e6dd0e93a2a8c6610ea1c6d80b400dff0ef4122a027086a509ce8d61b38fa1510298da9507d772e776084df3606a2160db1883b2c30cbdbcfe83b20e18038998c3cb9775391104f59319e9378a2c808d5011decd17544705f21d3f4a294ccf87f2e18eaf3836825e841ee5a31134be8256970c860ac2d73fdffdca9e645eb851343126cb874e1ba3a3cd580b6dac64e11b44410f6f0a7daec318d3653b0d097eb04d4dcdd8ef0878c3d1d0d639dca445a5c715adbdaa122c165e4016fc4d046cb93d6444dfd3692420b0618d85337125daa6964600170c913fa73f8c20513394aa8fd77deac678b644f57692082487ff17c71d5e553670af141bb1008d7a22eb225dc23160741ccacadd6491f458ee957dbccf3e1cd43edf8a697c9b0ccb5f1219cb4bb81627d3e9c99af7755b8ef4803ba6e67e68901d18598cfaa9742e98c7319216c0a988ed7c0504abba193cef58f42b118f98d03f6879c69f7476ae5f9f44d749caedddc507fc9459bc85d9cefdc3d28e3c79cfedcc5acd2d90681ab0bd9c73de975d61666a042bb5303d513c4ce3cb384e41b8efc4707e529093c4488f8ae9a4f543c57a80680cce9283026a17d98c66d7b2bf5aafb9160b3a8b13237d5b862d7e5a29a3b1ce35d3177ee0c13a4f7a8c0e7edcb7e70282a1ca72e39ce3cda1d625cb33a85a8c228565b9a6a2746e9deec142fe562cd753d313712e5209610299611ca4949c53a29d0d5572ecddfb30805f0a6b94c40f5955709ad08b8f8d816287d08cd29f88c314b2e37310733c01a7a2d40a9d82c837fc3619cb20813bfbbb7370ee5e442355829c482a73e3c52ae31c9ce5776fdf8e3d52233a3fb9b658b5693b457510eab9dce65c4b12d51ea1ff2fae2c6a4c1958bfc3435925eddd63f2ccefe33a5cb01feb49e9724d53e9b06519cae9544bd94025a0c389b55926a3cb5e4442bc81aa8029ef27582be2433f6604631ef8777138a8c423090ea9a0fcadef95d09bd871169ae9453a90c65e3d7adff93f61157cd2398a6e4ca3993d1d32ebcf158cd5c0df5cad17a602867d3d5b4a3e134c93f7be2f75c85522a002fca4bd9cdd6e829c20ab696fc5401163fbc83958d0f4afff4dc0168eb7c4c3decada4c41bc839c46fd3748533355bdf554d8e4f4025af2e2f5c811e79e0b69c30548172a3ce47eae608e90d5068938eaaa75a9e58090bd353cdcafe9c4e0f0cba17c3dc823ef959a38608cd5e4807380f0ae650638147511eeb2868e636604f88f88750dd2608dee415a8410a9b2f0b6828e9de49a4a766cbb7ac0561aba0551f9d9d776d90649b2aae381f92a2a6c8483035bb178788cd3ad39645a8e32a60a2363739e8ea076b5403bd84afe5f46e28ea2897a384d9155928b7f610791fb304cc53237753b8703c64d1d04e64340174164cff12ebf54cf08ad3ead9460fd77d797d23558e6695bca967718fdd589ad9fac3568aa27e99f213e9ba99e78062762ac160d5695985dc104396f4605b65881864efb35e562e78e793f24b98d9aa150665720c3b4a2f2db1eb88b3fee2a7606f1d9fcc5eb48cfa377001bce6e0bfc257874d159bd154f6a0d4ed4b0cc3cb98174efe50b510ba1213f308dd66a6ab6ea81be72368e3a728507b1f5224d3faf01e19838a24cd4f0b309cd0333fab62108c06da518efd45168b4bb8631a1a6d2baaa2656ecf81038beedc558b06a93c515f062b962f6a259362db7905ab7bafa1de0b8188209e643794e947693ebdf2cce510620131badb0db70d2fe5eaa5cd64c9a7fe4642b8f686b65c70d204c7a349c1cb4f4eb2f77904bf3760384b7ae71040ba8f67aeb8dbee24cb8eb50cd2389c7c9d2553accf625131660e369728a86834d04517c23bface86becdcd488e079137ab00830ad3ad7d1aa50bec396e8e2673257a8582a90845bc305beadabedc6f6b3a6170e00d679e6bf14e2e0a4b5c88ca5fe081a27a2cd0d5ac1f576812c3ef0299bb159dc2df9f248ac3ea3c94d0d34cb009e9819fbd602333f930b0d37e8285fa924c438e7727a9c0cd79d0c46d080b4b112cd4deae2d2563d1a3243cdc3b04dd963c25c17a9717ff4956ea70cb72eb21d96bc952d1fcea28ff9a7814b709d962ec2290d5f0887fb78f2f32fcc1f7c02b4a88482c1075253e7abdd94a4bfb97652e56a397d02bda3fe13134f6941cfcc3b3a4dc9f676fd36f04b75afe0d0b235808a6492696f45823dc5c35070ff52aafa904d91a9c4db2c69ba9fa823b7ef29d1fa1298039ef62528115c24b426abc05e97b5165776f57f3962bd7b03778605b1fdaa872ae37f2e3540255be636270e3cf75dc8522d52f3b8bcc43e88881c89124c60df66b366d8bca13f06dda5b10bd9a7a5f557a33076c5646c497a8db47a49f6f1b711977c21440acbe104784a918a2e9e48e3d83a100ab319522e1281409ae8794100950074d382d11540a326b9b24e74aa6ea66ff9856dfdbccf78cb6c6a45b865ba768f02d37c1537154ff2cf21e7137e12c531319717e9764a1003bc099893a6f0cf1f0c40ba8d313dbe2c3aed3b16b42c2f6d637ef3075bdf8324d39d046a354c8567e8a1598d403f5a9112c10c73910a3d5fc9a5bfa2377b083f11e0c47108f21bb895445fa5a3f660a1446e8d03f737285be992f29b4f2dc4f944dbb981a43c9b72e599cd61fc414a60eae21d396dfa22931bcfa5eefa491f72b86932b9b6d6f437eb951cd8214ce69972e31163a76e8a1c89809e86f36eb21d024de4335a6d091c3d705c883ac42f19c81dd2a23f9d0614fd2fb84e5f3a11e1a6c045f6858812dd8445361a14c959fb322c83db59ecbaa2ac1de2b939395676fa5a12509f49208576ce0d19845a7396024d9e00e73383b2808be04fdcc63db4886779269ca3fb4b96794041f0a3a869bcfca4ee58bd7b36f425f960de1f9e017a95149e673671cd93aea7e3d6c03ecfb3ba4fd0c3dfb683f993f506d0552596b9c2ff5c50872c2c670745479490d2ddd63aae2ff87fee8309f704967c3184426b96967c5e326987e4a0ec293174f83b5570f293265396229bd662e42e8a8284edd43f8f8840cc36dcb164dc21536b2898eb0300e9fbca41e8496de28633c3bb29fa5bcc070e6b1bb2745e9ad9e5584cc4c362219e7d2f58ec6e540fa93e2b922e8514aecc5104a977baad03bc68aa8eb96191921b1477b42fc708b6f8373c885d1eedf435e191a58b21a3c1f86465b5407c61119d68d8b5c00181fe23589b2b03977f415e58dacb7407cd50d5efe3bacc655248ec01274387bf43bdf95ce59a94a819511b78c901f651f83c1ada86fb2c9c23bf671fd5768313a6453cf2efbce573f109d1ff7e7e730b8d65770a95c97fc692b4f577dbbadccf88fb07df88ad9891c983584f7ce8376e662fd2218dd13ff29776b6dce26943f7a9e45f8fe12e4492d256c01f345bf1146c2534b49115b6d0977479ccf948716d354f481219c7a55eec3fece116ef7f2d3d04643783fb87e90d0122120d39a8a47142ba8b21b3d350a6d63cda16ba8592e598b19bc2421a1918e8cfdd911fde0b3df927d589f212262cca0090bb34060fd785b7c5903525efdac3ab9c1eb872ed396658497484ec6966d7c0d8b912568a918a669b2f50ffe81b0ca658253c2364f32fc1d5ed7d1f81b0e0570d6c0adb5638b5d40ba48ae334dbb39d70dc63f241b1cd8db8929176284e2c51d464292fd6a0a20e262095c4db79d8fcec702d67d5f412f9fc27feec6ad6b83e22340e03557a6efb9dec81c6e930bc307a18eaf24b9e19e5b61164410a086b0e3d98ea81efd3941263894b5619f3c92fab7db971ff4c058359819b9fb97e9da3c38a09f4d33e5b361ab873027fd66c1b089f4917111c25dc33fa076bf5b5451b928a7ddfa85585a4c64eb082489c780d690586674e54a029c344142530e0f9e61ba013387332946f055e775bf7842564677f8a4cca8cb72dd50affc3be3e197699d2232ada9e9d791c13f1284c952cc58940ba07459c28613eb8a8540945a8f94559e12300a987bd0086732761d350d8619d43702c6af28c99ff92f5f7c4b31db79133593dc68a96c652d24f32aea1de51cfb0c7b60f6ce1cfcda5d1bc06407cd396668990d3eed614577f9be4c59cc5eeaa7583483b9966dcfa7fbfb77cd39cf177edbdb333d901cc5e1d03936c2d849288886a81f9cc33016884250e580d9fc415d49b510cab46796ab852d88e93407b979a63b2c5904c7b59681d5613fcec971d6d882b18f3b6b06311c55773ac30c74b405a5b397ddeb84d134851c0f99d36f1ca5a303718678c38daf9299da826907a1547b5c63848798705d31f3f4d2ffb5ac7a6ae3437b1c8b3e4ff7b4021e7ff0ab9f15c2a3a4839aa61fa8f897d70474f15f8f8353502bc7e78d0a0fa119dfca89742c6bcb1010e05e904be4adfab9336c3f29691673b93b6225ba015a76544ca86dd60bda7841413b9ffba4df21a8f0e94429419a716d44aa7bccec7a7fd94f9b62f5a66f75473b28340678ce2fe8918b1bc7c071748ff31e16b069e800941538177f695b4f412ce2bd0bd2ee55b8077777d955977d84b5dbb157e4d44fc870d4f323a8355cc01e7879405b73b6d9f469a6e9fc61e09fa788cdf535a53bcd5cf6c0bac669584daf21f975f4175f673c73232f3f2e6d30f0dce26c3ae907a0ca8817533ebd04028296c86d64fd631c082d7082d59c7a6a4e692d91e005044c576e1ed00c319214f590348a8b82e6b1d6b904439f8eaf152575c772857316ba473d1057ca550b263712a5a7093faf71475af85878448644ed8e9811d87b6c66871d459517464a9005b62474df24d51b5a65dd949a3ef8472d805b2c2c97d5b1e9098d185a8389ad3164c6fcb1adafddba4c64eae815bca2ca2986c45c76f3a5ad90968cc6478a4fbe8c5239da76ebd6874b6f579248435a7c9a1577c64277253228edf3a0c649436e2933fde3d13a84aad2c6c95bc8f1252d0b55b41185cbbc6cee81e648c6cc69bbc4443a313a2c4c5b4a97a022b1f146dbb70818289ca28bf7c5da8a9299f1e5080fe04f327861c4bb200402f6314740ea7090ee383260c97d333763b9f473c4ca534f08ac2129678b4768ce5117761a4b9a7623f9754f3a7fc10c5b1ce96efe03f96092f6f2a2cec7adaf72d3cfcfdb037ff8e784ffdfe24678969733af24e2f92955bf5ea69a7e5a2673d88db787f3009eb33940b79f004e0765d1638f0bc70a2ed230098ed44ec7438b3163c3e24710902c5ab6b478a96f9569244a6cc597648096e28c4694948097ee24ddba2deeb0b50a47711747210ef7cc373a73fd9ebf489bf68609319c7abb71d90dd5e6a73aed8b1503193fbd3aaac061edf4847cab2bb139d9c0280d09df68695b1509bfb55f7176abf9ea53f95069fa8826221bc1e529d9647d5fd9b0fc22daf9b5d85353b21b8c928939bb1bf641079a8797eacf7fe6f364a63792c6852d5b546e71fb929510e750eb348f5ce04b6e2d7fdd3a29bec32dfb86b793534d27ded95d9a80b53d1d5d8306eaa57a18a2c8a8d6e8beaba5b2b7a8972da611a0a4c5d0fc8eabcd503ba1715d5cd83469fd8d68b5704d99b8cbd11718aebd0bcbd01e9403be6f73dce4e918478a74a5bfda02f75ba32c7fa08237cd5e695aa1ea5ed4c88afc06bc405f9ea379fdd8cd47b03639656db868ac476d4a4352a0533f7d1a2d12f1b22e09251d8ae168dbd63ee95c77ed651d449d861b76962e809194fe132ac0324bcbb3bb85cdc2c34fe6fc0f7887e4a3c5cf054265deeb85a3e89d4805e7aae8ecd4bf682699a2b99a5d381d2e24fbe932fee5ef1690e21294a1a247e1bfa876355d4db79f636c007176ef7b410156255736d8a419e5b2f050214884add6e68bf8e2dd2097265705e31e9d498084283bec69409c76075bc62aebb87a6aeba07ff4dfbfcc9896d3e6697dd76db6cad9c6fe0a27f515362ff4f5f583276cbf70599616adf407be4b52596315ad59ccc4a1cf7821af596b1a5c340743a560b40a16e8e9b06f29fdd3706456f30330aeb585a49c3a7a311ff6c9899e381be3924d84efe9dceef442b58bdf2d22ad9e8a1dcd56dfd4d512aaaa39084531a23e4aca54ec25aa189e8f8b409ec0bb11a4d5de98e29b2fd176379a48c78ff58e27ece2c68009d1560c60bd4fcdeaca69dcb9e259ccc7e1e0b16b77c5eaa8c240c7ae35f8abf53b2a5b7e6d909dc913cb234fe4d0acd1ed57f1446622f5717eb202d57a1bad830f2198820e905f9bb26425316001ffc6b88b1c2552836e39c91b97bf4103bf78d38260aea5571072eb700953180567cdd7f744f58fe8ee9e52161a3b7a3612bf68841dbacba65604addf4c62c70b51c1614eab1d3abde0d04223014364d9484ed426950a67bc273f75924eba45f4a65ff81cfcb15036017520b7c8bf1a88dc9ec2ac9f1e5d700b9410d8b59b0914b17d0e04d7435529e593b7db8cf30b649a785179f3c9383f46e8077cb66ac438cd9eebd295947e357102028e6e0c62ed4e8123c40f69853c72be91d530aab95bba17671ec9493059f613dca3a8c6cf7f4e48bec35e46db4cc93e06b55761a74ee78f773fc9823d03d3050a4bce8b13cf08e3b5be157177c9019bfbc188022ec1607d7578a1123d99bf5606c571bb87b84cfde0c6f298dd89005dc4714b4243fa50eaeb391c47e1196832a84ca9eeb148cdb46f9e371fcb2162adb8378ada726b1fc7cee2891066692283837db7f1650b9aa4640a53f2d3fa512d6ac2e70a5613246c997f11074445e1aa085bdfab8563c5b0eb0eb4d29198e6decc43ba136c366ef966704d247d261e6d323ac118a99d29af1b4090e925c839330375b0dce61cd004db41457a5edfc35dd7d33d8dc434f3a6bea8a1160d8a95bcb69c50bbbfe94f90095cb1c3fb1d56922c4edf181f246888be589ac91fe37f4203130bdcfbd9ab00ae08543522fb3fc12d4365b75a6df26ff62d5dea770b9cd3c7477bbb690706a6c566db97f1efe90e39c5196fa5dd9ae43b67ac79cb1621c55d91510d91dba5ebafc559c210561aa471b0f3c853cff13d6a5b0470d61bed795fe3b1bf87f1be9a76cb12f994a0c4093a388f5a7789d88974a824b0a8cd10a2738091184c8005ac5e135ec4e8ee12d0eb4714d7a0b3b72492d893e9267c7e3997df99f8ef0f89efe493e471540d01abad1cf121ed62643cb6815a00c7ccaed1c4afa5fc167352c901260443a1a7191180e0d5fc675efd2b655c595a86f797adfb4078d2a78e784a6fed419cf025f5829bf68ed93d001942d89dcddac97cf5b7b49d1f0853b6bdbd43c0f8198837e6dd0ed593684ea6b80e48b3c2c7b248e14089240c8b28439bd5e975d7f1c056b6bc3ef8e71f07b1b7797f85d5e0a9e51ee845cda7f5c06e65f7950b2e260f0090e69a88a6619e4aa2ba28f6fde74a6a163471f85317e601ce950a98c5a224d83801d10e5896e69c1e93d2de889b85f2f6b4454ae29ce614bf01aaaab056c847066c9eef18fb0206b71c9d8b05de8881be9d24564ddf70573b23f51b3f52cc5a0cf9db69963b5002b4a809cd54ad7fc642f181a7947c2b2a3ea539612379c43801eabfd19175ce1e2a22dfdf54fd5aad12457ffce919ecf1515456b679cb635f72f31740a52c48bae0a9f206ee98f5d829c958e8f6ce9cc23d8e205915a54f1639c7b61db8d5bdd3cf94999f208d2edc6c455a39284aa6758a2e72834b4c6e9ca8fca92d9d6eb47c6f5c02ed4e33de038b8ead71058c6cf22eb471b7faf6ef7c41fb6e999971c4295a3a8ea0e008511e194f92c0ef15a97fe82c7b857776304f07d73719a99a98f813137e50b631cf136796295186b2ee8118c5f59846f9f7e8b9a8db7aa485aebbabd49844342eefec35df7c077a7aaa3e4efcb942aa852df35c52b520c79ded3857c7a4cddc3cdf64b7eff2fd8fb9ecc77a4d2a8a7f5e5ba9f1ce9c4cd7a77e53eb130b88accd244e481262832703ea3817bd8397784ae2ffcedb9e366efdf652e851cef0ad088f6a8337b64ea510dde73e7b7bb1aa403a92bc17488215a5d087d40718e7886241b4aef2f98a5c8db39a7fdc903983b03b88faefa469fe16c316450817f8187a60a606369d659e8e85aa12e09612a5960dc77124c220961093b2244ad2c10b19289c6d4669da4c9113cae827dfb6529ed8bb323aaedaa7ac66900a07b3035d3a7959b7a34e1aea68c9709d3fa401934d2e7960597b66a9393050b7232daf4e5346b5ef44d2d96c3b2a5ba894c4916d13fd807cc69b0df7552592b34f6298c3fcb6471f2efe129c91640d12f2a681382797c99071be89c3cd01970367ab4948cabcf5ad9226e8ec027a2ee555818a9b408f1316cad9a158df7a8e68e8c146a224ab55793677948a0ff454e8f44dae8966278962bd664a3121244a940f9b1a03b64206e456479cb4bfe4a89432aea8499f555d520255ee6134e95628b37fa9497872818280a32bd27b41058eb83c338222d6257968f32fac41b664584c4900cf715a67ce55cade38f52257cedae3c5809988886c02d089b90c9c96aa3ee24acaeda95c8055be5231ecd4c02d81c69a37329760d6f05df18472c96972724b46c7c899ae2fabf96f99acdd10fa9fcfbfea3c86ab89acd9227150c16e411183ce3ce1cec03e8093caed7992607f44f7abde888b0ce9752419c0ad551be76cbeb26457d45e6781d3d4d8015a146765056ff722eded6c775a74242a44d85904d5da0cf98c89295047e1ee1d5f3ea4a8eb7cecb9656d9de7225ee95adc3967a7d4ea4462ac4f5d98fde2f85ac0cbc849aa71b0807d96773275950bfa8c42396d7c15c145e98a497e68fb882760a8428c441bdbd0e52901c5ac4b5ffa295bb3365a9c343a1e37bde4c6b20d2254eec050b422c2988db3ac087f2660d3e122daa815381507aa25991adacafcc12a37b689b1d1f630160e9e93db94466cc6b535bea5e3baf1ea94552fced60a27318ae340910f3adb96934bd4a6dafdb33c8a33ac939809e8ca825e0c18618279a9488","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
