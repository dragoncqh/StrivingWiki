<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"52755e8cb1ccb5b1abd8d04514ae74feb9f74f5851ccf5f1c7f58591cb8c9d280ee8182b7f8fa85166a4b54eba6f79e59c5fa396374aca9eccdd7621df976e65ce3a891020b2a14b59559e59ee3ca6175d57dcce4ec996eab03574735c9196cecbcc8d2484071625c863d93393b9a032d5d74b6e8bdf3261359fb45523dde5768c4fd6d89b8aeb58420b659cc0d199f77a90d13518fe775cfcb73fc66359d7ff47b3a0da7853f814a0a8184d77d86b17d954cd9b7907be57dd276e449d56c7cf99fbd1a3b342b3f8a369812f3919d5ed9fdbf1adeaeaa59329596f09d9345ba65bf6487e4bce6d39e66416fe63f7066ad42769b08bca2c314f7e24aeec9bf0108ab619c3d09fa5da924715d9a845540abac217a3a12f0d30a337368625445e5231f56e444d7b9f55a98d5570ef535913b2691c97e869a288573be2ae837f9a13323c8bd0f2c4a7ef890089fcb7bc3826ae763626d024bab95ad60352d8a5e28fd1ae92d541bc5e106229bb5d6c57ce46cc46b993faef8b2004969633eb8e54015ed0a71e4718b5ac533e92255b53bcbd7425b91a354094629eed874475e4ef7c70b4f8eccc718e08a58cb08d4cc3d1b9478302b418f8cc05ca81da1227cf701c9278eb93e317c9d5873f56b52b680b2c491666ae227faeaa0d61afd2377afe3c39e44d96d015e8f669fcabf1cf51e7fd2e7c81154bb4ad2950f0e5ae7234822866400d301337c2378c95cb2f840c2e1c886139aadc33a6e7549aa177d49fe84b377219e77d65c68ce9eb2aeed3f23581cdc7852fc26da0aea128cbcd1f9200ab95b8cb9acc5c323c3612c875a7bcae9cc371718e59c08350a5f4a21730a186282536c8ff34c363669d536c270048094ff081019745608deff4805914a4dab74920e25849225b891bfc4ec9aba4ee789999d772392c08928930bb819c6a840ec3931d40f2f91609703ea44cab1cf92bee19083f8b0787193daac0a73da3eeb200d86451bbc2b61cf35f411a902126f5366293f39fc7bf48caa93de4232d017255076f8632d8d04dace6d2e56434d712dfad48a3741305814729a152815bae83dcdf23dc4a20220dd5ed6a6f3dd86cd2682eddd5841f9bd066e57ac52bbc3cd3bed7057114ed2ae240f2c937372ef1241eb93b78626a82f364c70f5f37309bc7a0715600f66312a58e7336b01b5d7361c8f64aaed2d17a2ab45e2b4d3bc3898ab27f1cd41fbeca5acdaefff1daf7a8d603d44ec418f6e993d515c23d69e6aa40372886c13b5aa9adab59979df569e1f4f6ea57b9769d15a0ae0a088c07d826d247f7d0bd0c8ac7b93f045ae93c24bffb7652d7bc5610bc269998426bdfd478e6aa833aad0499184cae23e8f07042216153981a139a3cf87b817335cc0302b3be2d75620c5e25105707905815dfc9c5781309ffbc65ce2f0eb51fba435c6bb5aaf2f3a98db8956ed640c1da2054c0bd0a95191e595eb3bcd2db8904a43df23802f9e6304aef720e06963bd57fd5096880cbfa9c47eed162c6dacb2e7e47ca9383aabf455a5bc6cbf07db8bc4c02e854229bf4deb1437b13c97e40fa7f9b085762f488e6c10e19be354e65bca29da199fb48b890d433e5da0f58a90b4f4c1c1cbec6130317030df2d8a1b7ce4ee86d908ddc9c998e07766efdda6f13cbe84681139fd2d334ee248ef2fb81b971b922910c6f382cd61e7e39e5cb427111f3071919a223b56ef74cef146e0dfdd816af5c59f1196d00ba14e571ebf07b6711042ca76026a94e80d49974a7df03719099aaafd7932755b8060f4de867008dfad856566120b2e5c38868c36623aafb7d34ea7d99438098150cd64e9658c140fe262d63bb236dc72078f5a1783e16dab831f8bba1c9124eb243f0bb7b8b9843c70acd10c874ef231822aa564bfc66886337534426474ea7a20b866eb8f863ed95a85a56bde2433018b0557d9433fe01496a22ad10718c026fce57bd3c253a2c918fc3e318c0f809d81dfaa1af1cf0d29f9e090be6153afba8b1cc913ff5103c68949ee81a69e740fac0f791da1f467ccee9d1a8fb1f8a0b4639a9465e0f94d4079dedd749417afd8a303a42f41147e90fb38bb2f7ecffdc880ff317f3e951b6ad801a34a8eb7f73b7c6224ceebe04e4299c1a47342669e174ff66e7e7a9318db553bad58dfc5e2d732b2ffa881aa6ccea08af6a1b5a45ace16a48d01886d0351e9c7d855e634503dc44a7dd4c79919e2470c595615842a59ee1719a0f15118e46a43819edcaf1040c90449321d1767ee97c2c9ac0da618fc45f4df2e20cc6816eaa9014967ff28c12b6dc35561f267545d0760280059c8531b7159ec804a474d2d177d30060f9b92ab27f099a8a8fc04f2abf14571f2b0b07472600f3e62c1c66b3c14ca48f9dec3ae44055f4187f83f1048b6c3599c9d2d100734af73b0073f3e0ef195d0b2ef35ba9c4d61e2cc35ad321348542320230e880d817d433f5c6d0ea725cf01d3ddde91d2c4ddff8b3cc668905a804306566f12aaecbc2228e60135981c103c1e5276272744c70178d227db227c695a062d1c280db8a40ad45276f60cbb1c130222ef37255a4d39fd099ce43c7508a6d3f3c959ddfb9b8b01c9a905ac590bae1985a0d449d502c8efbfa516be3daeda5ea5d725a7d9bd81c18b408cb477b593cf9215da645a99560c745b16148259afe23746319682ad94e8d4c60f11729d85b5bcf41df5ee270c780b7b28e074b63bc7e4ab123370c8cd44e42243c804b14b8a2b751d60919f63adf686f6736b686e70400c37d8cc30041ffb76ddbb29720455ea57ab9e9e04f1091a6abfd0c123335cad83abaa45a84152574a16cea20b27156618b0f849d2068ae88d1a6c9e08aaba786affd8abc3ec0a7b6611f81d1a5dc11e6e41b0acc223aed2a21254be892aaa6e7212793a65f1167db984c11579ad5b1a22f8d272dce3dcbece7600896c213fda539b195beb44821966e78ff12125125c98b602c936c2a076e624c1ba15133acc39e5b61946addd4df41267af12458caed2a9ca35b7aa03c20d08c1b537702433acb16b53609ee5be24537c627d9240b536c079508d44f9760f6102d835bad70238cdfb5449958a0a4064a59e62fc6845d2b40bb4a142d34c801f3aaef2f2e1d608b8b2731acc982ab5af7c639d1c648c06515e988512bb0ca63021d54f424aaa246925b3adf55bf4229dabc1cee2a641e85eedae468735bb2816b8c73309a0cab9d8f59949d9f50b211db38cb0fefef31bd2f1e7944c1365592f1cd5b1ef40a1db0ffde87480c3f4b6350405dd2dc644196b9159983799ccb6f87d76e2ff9644dc40c56596085901d4fef328662e55b2a3ef3f1fe99b7ce8563934d741014e380fc1f60bbbc951ab064fd7560781441af5a18d45f40544957b7aade97746e4dba0f284cc5ce53819d08a4b359eaf4e1d51cb9352ba2cf64d1f1fd85ac685d2d57ba2ff14b7a4bd42a88d926e7138adf6526a9a5487c9afc5a9def8edc4709eb26311608fa23733f27d203729be105d33c03dfe539f1da4f99bbcd770e21a86f917393aff923a7bf2a25e97680bd5b26638e68a3c03432e44145c9214dd1e573325d21808792d61a676c291c6155e79581209f99651b87e2db6450d1ce439dee8961a64dc18acd9c09f1483212da8a35ffa1b889266149ca2a2c9de016bc5c5bacec4d8379da312b81adb0a64e041aa7d2147685bc7008ae81407748c9a2de01ec88732d3a7410df3f8c9752675641c8b7d051f39153434a3435cfab89fb8e2be423581626345775cc16a0c95d2d7ff298b9a21dab56a9dcf380c315e5337ca38b00976270e725743d21415260e87516d05eaf3a164e0aab5e0e3f92f4b6bee68a7e5198c30f8e6cddff1fecf3d675c153a5bce9cbc2ecb16cf1917b01704ab345935f128eb103e72b56b985efdbb7fc69ddb51129f307570c7be52e6c51553c2d0fc81b75fdd43e5540db6da533df4c3ca5c83033978dacb781f8e9edaec91760bf1015ddf961e86d98e33d9b750faecce87bb5d8ef31a99f4e82eb9a151096ff9c20420e14c616c090787cc45192b5ef4c5fa37b8c2830fc209db22d266e1701de7017f777485acb6f377de15c10e87b64391acad5f955fe0a5b270fb13d71503e88b5d53c01256c06675d219a54ae3fa0dfa1605dfe24e5257ca13c777c633e30402c508181a0d2fb41676238af40c6a7881b1069bb938b95b8eb0c2690a3d6ab3efd40853d480c2d7a7826df18bd70a7b8c498e23109565b8b138cddee9ad92280afb0bb890c59cf28132b16ca994402d7db659a421cf3785a1a5e09fd6e50dec962ca534a1d122b0aadc19d2a4ef0dd41202e34c9f7ee908a56b6344ea27c7a8cf4dea5f79be9cefc7330cb548aae8c9a364ad81dbf1eeb41ac5f73e4b9cfad615a3ff16ddc2b681050b2ff1ad58153a41ea151c8fdfae38e41ba235629583e75da8192e164ec8b3a3d2d3e4ad1e3f52fbe51fa3c7ed275cbde9c469703ea566484de7cb8caf6cf90cc1ed6a6b3de17648645fd7f3730d772f658e99424d9871ea38c4cd2f41ceaa4c1b045ea06b2685c994eec408a75a46c2bc6570035c6d692798b6ca1b327bac25838f1667937d673a4a14cd17408773ffdbe6c82a21086b0c839a6e529b9531e2b107a4dc6439f8c1c0eceed09ab3a9471ca951e7c78348653c5c4c09763ff1d8d2743c6f3efa048c467008cc61506a294e7a66864e07d25b0b754645e735083c44a9a6667945d5247bd648b576cf322eb893a50d61babe805e38d1fa062e120170aef9fe1729d9a8fa217d18787bf554ada94056697e36ca6f297116b1668a358bde37aea7f9f1f46afa31b9e0e101aa021542b4c076fdc8479f79de71dbbf75390d0caaa7d79a1218affd22d044fd2db022ed70b9107d85f5e9d27fac15a7ef91c8859f27c89d9d28742a001866b76fed85ad89f8f15ef1b4e096f17035f69c59ae04ef4b4a02e8f0d50b4c470e5fa5cb8741a1ec10772572caa58515213c2ed5ab54085e82649fd682765c06d9d9ec496bcc8c99f16cfa908a26cb0468fc91b629909401a948fb24fe2abebe4c6f948f5864b2f5956f425af152b2f68230792eb166e98402b3e2827d5635bc342f571dcc27bf0d2267e6b269e0c969f674718ab9e2621aff056fe3f282914a945da8ca5f1ad75b4440c23fd9d1b06b1b487b093dda5c119a9fa36598063e77a802f37af0ddded983ab11a4f8e55f51cba96bf18ddf9f78dd9f6e565cc6c881db0f3464b2102231dbd159fd5ac0c397f8dbde333d5dc7c5091b3ed796e51f312e84a684930511e0a0732e0bd8a3bbca16abb2e90fda3157d56334213636cf5800fd8eea35b90eea84ac3b30768087c8c0e227c1c51edcb600b2c2fafdf11329d8ad381f43c9adebadf97bfa0c92d22f8cf7d4c8c30df6acb405d052c7713a3b0476f4076a9ef4bc7215f9fc77d529d7894e2d2df11058ab37cb570ae0fa02305e5fe31be95c5dc33848239bd6bf0ea8fc97140d3d60665fb5ae856d426c83b2ba6d99e2521e6cb287d780ee9e55fa0215d5f7e9a0dbf068b70eec483cbe6ebcddc8fa9139c5518143ffeedc2ef76d6f96d41560feb8347a6365149ec90b9844300b5b07da6d6216d7b60c77c83bdfa14af4814c22228e5035bed00f131976f4029e7181c493d5d0e2517eeda239626cd7e17d0ebb7d6331e4197822d3fbb29b37fee4334e7bd50858f92f197176fcb18fb05373558ffdec1b9e2d23fd4c58d7198ef707892bfa459e5205ae893aa93c3c880fcd0b192792debc12981c921d6fb2ebd2dabf500bfcb2d9d86965322d4c6137966e68644f90bdeaaa1dd5a8158f824966f8e77327fa05857bc3e391c16c2053efbc6823180534a1af7a57af0d2e75716b028ca3e6481d49444a829fec35bf7b14734c847c296a44ea663b533d993ceda2a1b5c63b23614c3d2cef2e7ede2726d34982a41003263f986a773427693b4a7460f93c9b93d499de81ba5842eb6ae5fbbd20096164bdbc85570411b209299bbbed8a441720efe605c5963e57b00aff5a852b318a90134fb6dbc0976404f65cefa3eef524a49bbf733906e82d5cdd3d8dfa30d3e77f8d0ad0b9dd4551fd44515e0ce495d536111389e6adf24dec7704ff5577a7806e37e82027f539835cf9cdd8aee626288a66134cc04b34cb4f2417b2dcc1225a1114d37aafbd28a26c3754ebe72b0fcc6edf46f4d6beee67118c09dd5740f3ec530a2c3166ab60a69175136803b0e7ecec68200aad435ed76a4b25237ad2ea146fc4ff49298fe986312ee7efecacbcf1793f91893b477d0659145039ec5bf80d9121096458395705137b218444b7fd825d7f52463d9b82175f31c5ec7f4a56ef62c13f113559ad18049764aa47c303d438a8246d69044b17fd90f296a2b31daf96f9167690ccb9adc280abcbacebf91c0bdab8ddd67322c60906567aa5a02c759039915d0a85b56cde916d4dd204a5138c6f6af2b82fd0b2624a44caec1553da8501ef7173aad49c4367afcd8fb0d20688027f534e2c66babc7705cd7d13907a0da92d438ed58a8e2d78eeeabd1b3242b9b6b2f6cfbee3ed3b9a81471d403cc36d9e4c85060cc9de79c1cedb73256361f182ec2da9c0cabd5648572439c4408ca0ce9486d5f29ec878279fb6eee1c6d84dec7d14526f4b5975193cdf1767f54ac7a03e805647d880d448c4c2cc6054530dc723e4a98f0fdd113e3de66dca00b5ae56907365368318d675ca4e2be80a8bacecea583f39c8d7a7002d6e3b023b5defbcb0d20ad7c242747cf58c4324f4c6637b30338ed26bcf4c17cccc32f9503e53fe066bf4fae700753688fcaeca4eb8f5db12c3360bb816c73cdb986b99b983f85269a3d2bb986a87938023b70b181496c842fd5712556fff1c8d3297907ada67023f6a36bfd136f797e1d0f4c64905ec38eab72b684bdbbe69f6d15805496332adfdac1001ce2921dc5322e703c697c4e9623690d381104c00a72c391e747e59675fa061f194757fc4abbee16ef264491769a39ece4e80c0974a5b985fef4c866fbd02a29c7f2bdf44ee772737c185c170c316c2c0b8ec0feb988503ea452d2c222f7a1aef3cc5f2a3c2532f75651cf1abbf5c9d152ee8f9e2676e6cad5b6c24cdc82d7897d9009dfb78acc03302ae8975e7d2295277244f75d8d20b519ba858d5dba82eb53c5ed81cf01dccb29c222b7a379c22a4a0fbc3e1e84ffe9894fca264e5c98b8e5ad66ad232617767fba497b0c479fa36bd4934134f1b6f819e500817a464c421f6a5d666388d2df7c7033331eb7da90f1196cea0754a043701863f6ba8cfc90ed5d86c0c651ad06ae1bf42274177ae293317a1a334f8a0ad4f5407dbb40dfa65c41dfce68db474e27acd43644f1eb0b24e10df9898bb0925faf1a7eb0e8509faccf5af4977566e2c90d41caf7f63ff0cbaf1b02a20ef597d302a78d8f665c8c870f50ee3463f169e307fcfada979980072f99e2a4838a98f5929de288d3fb7102cbd6d24c7382dca87b32ef3cb3e88a12ae40822d836e7b4216c35218bcda7cf68a0a823813bd70d05f0dc89b07ac14589181e44c710788ca81dc67bbf4409a97de73d22387315df0791dfe38a2485b7101b8a29d8296dc5aa824020578db04af6d5aa8994ffeffd7d521a4d31b23e6d7e906516a9344a2f39be0b9e54b905b5e50d5eef3f9e2fcab764ade17d9b235e0cb0e3571ebd7640cf91301ba3dedfde33b94c065d6b38356d9a85b20f367b1ba3cd75c847529249535509e901161547961158a1e7d8a3223557de329d2f1dfcf6c4c49064dbc254f303ac7f437a33afb470cad506e192fbdba898a574dd19355e755a9eeeea670fcd3e039c60ac21f2ca506e4b5e42b199aad298aec4bee48ea3c879817aac86879b352fbbec0f7c78dc1e83a5330d17f58fc52016176f372fde3c2e7be6e7e3a4426841eea965b8b8ebd619359079a9b4f3590055202f48d13518c995efacf8e45ad76cfb4d1c973a41e4019fd15a650372a27dd8f3ee247bc5b95561e0d57e6359c308d9ca8e4f62288a78715d023cf80d3f7dad1969d2d5151bbee5e20c1d4b2f23223f9f35fb51b1d0fa4bc4448545890ee3674de718954e69dd5562eee1ec350efe95bc25056969f7d3a684bd0052e87bebd5389efeee915959f3144c7f593ab41cda0d725fe0919cb3b10cc6ccfb40a8754f13746c043507e7d1562069620cdc0ed33e55fcab0041b37104875f7ed7914c40830ebbe6846da557f8548061d49e28b611202045964da062ba7dba8e0bcea8b915d1c2738262444c8e48e0e0f27487f4c304fdc8a7c6824fbd09db091f9ced4dd08defded788756cf55f4b786e9747326f0b690e51cf33fa1fb083e88fff792c39825cf9834d71a1796b076780d8950673c05b62b0f4867df6e294f005047e64178437f0661c2ecda3bd6bf515a2bc45b124cd123d4252da0ddafc6cc7f2675bb11fe4d52b58456b7339171865ad73e516fff56b1db0dfb846039dbfc78a5f41c094049181fd8e427edae4980c6f16a0abf45f470ddb06fa513970089a083a57c7c7663d4297f28dd4a4d613610633e25263a59768a71104b292310f4848465fa73951a0139a15544e75fc22925c742bb9fe301789a87a506ea53f9a86f2859ca2ec0dec48b3607a8d2a25bfb84ebf5cdd7361080295080fa25eb4a193c77ab7a8f0d4c575a049d74665c7ad9f2df8b228d7840219210a3629a63a67180674b957a656494164cb5acc9ac4df26df50acd05dcc2ef796faf84098fe7f8c9d115246c57f3baa7be94780fdf752b343ac98d6f8c3cf53ed90329748f0c082b2b530968d473db4d93f24ea662e874a4c602b54f1e9ca6bc07f1ac5c7246fed1f88c85d6f84b3efce54a14e923a50f04f178e5026cc5a4b538f4bd8a67e293fba0ce9ce561f8f797c125430694ed0d1e8fcfa1478a761911d9404fa227a30d66c2e7575d73f67d4b7c3a5f06b84362f19b6b1e89cb57ea74337254338e62cd7bf11699c44fe194b457cbf1b7658fd72c755781e2a2c9a799e57352e9616ceffe0b918c1433486b4bf504f8f869a6e075c88029e8e9af3ea10ae3407e8503ef1346397aec1790b99d1cdbe3ee3d1022d80131d61680e1a8847f6c999ea3877c74fffc7bd34c6b8aef5db988df63e17ffa25751d9bd2fbd4cadcb372043c3f83e753762da92e5a94cb4b807f5a3dc677c10ab9e55482545c6bd9947dd89493b4a723631ce972a2c828620ca832c30b96efe4cdc49e3135d43e6b4d3dc3da1e4b6f4b69ee9e151304ad45b659bacc389fb4485e0862202f3c426f35edbf4a22a38958fe641010e006dfe1f3a183a00a3dbf43b102c9f54f528373b6b02b21176f2ca3ff782f526b1ac8ce7a42c239849979dd51ac93bfea19bed6c1cc862aa67037c12bec23ab4f8e31ef42fde15d4f867651102f47fb8d362802d7f7d7d29fae0c3b31b2c99ded403c65955188665b5a6d01963790a3dd57e5996caa4bd9ecb82e3e8c2c99e8182800bf892377db3aa46e9a458c94f6882100f345cc9711bcfefa7022b3a3d2a46c1f399f04298fe00c5598dabb9db4cd4c427b358013e5e67207df894c5f8e6e7f11ac7eda1170b12cdd2b84097fea7a46ce75dfbb79649cb09b68618864268c52c42e533aa9947458bb51b582f1abdd5f3754a56364d8e52722acf0162bf14046bbc4bab440b88e76c529c16f1d5f3aea40fb14e7762e58e5ca5f65f20b05d6fe923a4852d36d4af33768729f08db7da8dac022e345d77fedcb3bc400f1837a6f15f1002776bca29adc40177c48281f5c7fc260aaffb6fd318825df17f32d70f0f63c289e4ad85c3ba3d2558dd0db16ae9d3730e50626018eb5a9438dc975805c13e8e774c89b27dd3abf779bc4755d3b3c151c3d9230554eb9c46203e7c9e6d0abe2d8fc6330347432d577d0d2b558234b1b87fe09bcd97b5583cb7268c62d206aadb1d4dea4db2aaccc734cad77ff0036a08baf702700ae","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
