<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cb52efeafad804311868ee12a38d79f01f022343fce35112848ce7a2a83f4342a3bf31b739b2f567bcc1b1b067935c615c412ef818d80a2f18b55605df696c94f4502b5091e18876bc5a7f07a0ff7c65ebd5ad9182c641a48f1e3a0c4dc75e6f41ea2ffb22b1864dda3c3f2ea64d316d99506f06ace905915b4c84c44b346cfbbfe5a43f930bf9b68694f9c0f7392267d91a78aab3c6f00de882263ea4bf8011b6797d4c0d470d10ea6c3526be88b6b34164ee149b942b796ed7f48115658f4dcd87089f0b241a4c5eab9d492970da9952b2e93768e593f7a4ccf84d167dbc33ca6170c62db1e7a02039bc3c79ef97a05893ffc6fa877a23485897ae9ee13de9fc153528a019c18ccb3d1f9b560b6bf3deb1ed7b8925f350b9c93668372b2f60dede1d1e661eb6fffcf2be2aab52dc42899138585079178b61f8a589458dbab88f4fd305a5b3ff5a0654172d669993bbae0809fb7e30fe374a60ebb3b24a2f1fc4b967e18a4601e26290f5b5578d21a1b992706a791b9c58f6b51f2788f822757a8db97f75e03aa1f0511026559cbbf5e8c136b748e399d642e53ce76a6b16555fc8603722d4161fcbfd946782a3091e52db9e8d4ed5fb529cf1c13c7b21c096d107f2f137eb2f2e12ac74ce82a40816566ac2bd290c31e68eb6a557adcaeee2e94da2a361e3b792509863a21e7a567f4d5aac36f508253c1497fe6ae94231835fd1c7724966a33700e26f952e342641ed49ed882edb6551bf685347611e62235a338c356e29234bb6142d1913a7f2e56039b8fa4e40c6ac1cc48ba7f7b39229103e1f36125d0bd1c42c6d4df1b61907c31440306e95b23ca7c85460cd962f6a436862069d5ca58ec2f1c94f563491b32710315c5a488ba608a67a76ddcc2c8e01ae03e3923edfa34c665104affc47479df8719152a8fa1e0d089426eb43742fbe657522c10cb83a227d8c806bd49a8883b3d845a7d9a69a4cf3b5d7e53af4109b64dba0d5def6537e6423319718a755d91a10e67447c2f5ea92f41dfc53ed03d126594db63d2b8f6e8fbbc2185f14f4b1764f2eefebad85ce2c3f17eeee2859f240e8104bf62f7c41bf5000a13aa18602b32d532662a3721b6fb7ea4376ecea2075e1e028c43ad7e74e49124d0f883bd09b787f59334fda98393bbc1f8122beb650b45196356bcb33c6910ec9e1138f46136e405f8d300625864c668721fa5e7bd46a08ac4fdb15cab1b441c0485d54c56018c4ec1f6876854b4edf9f9984e0b60876bc00cbe97ad118605e1813d1ce6cddebec24ea857528b54c95d25ed60701b4ae5880d6fa163ab2857733e310fc09d2ea27d89e2953ce7923c738637b513b85086cc328d6e81dc8c8e6e8aa655f5a7c430f638dc0d73358ad2c3ccb58f216b676798be67c46f36cf3474ae20f0a0dffae99cc07adf05df0a798f8d4ea53c2fd9302b91973dc6c9a18f2ee3c9f1c2e03d42216d9afce4a9ed04e759f5b486a7b7f85d082a546ad5b17a0261108d7b3b21940edfb46143750967afb9e36d8e2b43a91456fa2fad5a07363fe4382c7137a4244bcd0c25438cae2c20c46c43f903109c7fdef46f7107e1d55bf086832bcf74863388395e44a71eb100b1585c94dc314e2463df0e641d57b74095a55af8636e454f30f766fdc8f367ac957b4fc5cb608afad2c6d73decb5a68394f43bc18566cc74cfc7f93d69584f8f7c7f722a311cd670a8ba5487a4f161d97f67cdb00840df2abeb3629704c9276b284c8fd3d51e1290b3a978e26d0fe0349632d02c4c6768340a91a08112be34ea3d1631489bdc193aee6d43b37718de5d0fc062fa3bfb7ced451b8efa34150d5d8b20e5db6adc2e782f89f523385f718a2901113bf61d5acab02f9c777c0c006470228b66b000080a061faea0c2346891542de96947389f848df1c72eaff99f652236aeb223932496b5a0de63d18f9abf4b89ee70b5efb4dba3f63edf558a8089d756497fc998beb383d1e5c1926d23c110510feb2e6d66344afb70a6ae8a6dfefd21a6e05bb68798346acb019dc2fd048deda39615df973dea585a54320963d3e6d4b83a744fab58af713fe30477920336cedd98265492d93a39229b6091978489ecdc3bb9eebeeb5092a3a1edbcccbe805263f03d74f5243d3c0fee11bc23add95cc34091348dbffa91bee17ddf385327d7de9260edb41e56c48cfc835ffebda601c1fbf87778ac807cfc31336807c7fed7497618e41a582f0a07d4c143b48f483670faa20d57b2eca04a3f14a47d7a02f3f8a6f44d256920b3cbafa1a3058e969def70553acb754c316a603e5e4eda5cf05a0afc436204f3cded2c54cfc020f2ee304c4eae2bd7bc5ae35cca33458873564dbd948f94dd9e1294aab9c34e5827dcda25a2f492a813e7facb64454ac15103cb6f7f4e3f52fe8917e14199ff1411b261361f5d27c1defdc018bcdf88d743371674b31e5475d06ba27a5f5f2e8a1098afe96059044d07a92fa7c9a92c2db7727f40056eb7fb1b2646b3502c2bd50438d73515771678d4e220c49ab166b69be282a348d036fb17b1c8cea0e7d3171fd98670f60ca20887f86ae775b7bd0be947f4feb87a8d3075ab1bd5bb0813df2294ad7185780e99edc2d5f6b51e52df946ae9e60b2b7c9d9557c8c3a09c6e9de2c1874d3a3f42238cb7f9db4bfd9b2f117fc91e449983a757909d3e6cfc858191c7b937b55500a9437c1489d0ba786c8f877bec37c499ad5dd4a39208780d31436ecbb729cd8e1dee12e5eb810bc95cfb9dd5a890d30bf08e7a923cbc022866f44b5af4714bc24f70764d7222cef95ac5302a1aff62a5c47f97e9bc031ca9292116181d36a84addbf119b07c829a409c44d2f3b16f0a8b77026793102719bf99261c7cfe135018992f66772a0129f0152bd3034c4b8f9dd9cddf6667ef6331741070d7f686cff9408d33b28841fd3cb0d6652780f4f0b1bb1bc5bfa1c0d2eb5396bbe780a8d21c2096345926c24a65891c3d5af29d24c67b4e0a27f7867d82b5db6a213b74bb82506af68331053bc60a4bffa58cb2d4951b9a6cb52c06fbf4d44d5fb508ff32a9b0a54ce486ad23c67c363d2d53f38d7d5db9d13d2bc688b190cf7e976f4e360d5ab3f4fd61838689f42db8ec3cf25550cf7ae2113837f91ff259422f2ac6301e3d1af0bfaf8f96ca50ae7c57fe76e36dffc61af906b6ccc50a0f9d943cc8dcd90b60db63ae650ca50e1f32a577f5fa6ade1b865f63fb3f3a6113a8bed212c40f47190e502d94f0617ec2dc2c95d240b6f91340a0baf1d150702950985d47321763f2627be6776299da71c871c747255224125d53c40565a2207b2cc1619cff92471f58b65668d2a977911da32c7f220c51defac274374c7794364db9291ffb71d365658a981488bd7a6309b6f5206764c9d69b7ec6b1657430248555e2eefc96f70eefb9474152e90723bf6bba6fdbdcee127e7d17de75d51a9004e4fa803b7d703fb848d054649f05a4f20b222b0c0ec1c0d34814df921b3546ee298306968423c3d1a66a3bad0f0f879ea65c147d2bac75f1bf947cafe0bae7581d7e2f148059d456d55cb77c7994461a19e486e8a26150139254ff51b682925d683cae816bbd1dc8729de5483989045c37ba61e27a3173987c731d9ea78dca290777b160a7ffd0e322823b990dec1ca52609c0b56de61dbf442a56bf26d1389ba6470078c825dbe2b62a4d53ad325a4e41e3f22869fc0d1c90484a28b81f8eb66a4892c7f6fd6fce03c966d3d5edb6f14bb2a8f07b18e1b76aa4097b5a7dbff45d20f84a398363da3f63d0aaceda34e31285387dd7451feb551b65962c5de950d00391208d2792010a42b15f63f312997b47d34c610f3971b117263db95beb9b2a5b693170450d9fd8afb1f727c5d8c40634c019967678c44e81f49f47c438619874e6cd12fdd2bbfda8b933ef71a55ad985edf600c0b4226491922d1c284a7b13ba5ede1a1be7525ee233c115ca4fb4fe0a406241b3a10aaa3091873cefc78e68fda22a3bb5e1574221f56d588cb5803b664f89c7408c94fb70bed9caf9ff86b22314ac550a212635b1673b53cacdacdcbee02ce9e5cfac11a41da7440aef2453fd8534f613ef91fa6ec8790506f50b67132b1fe59b5b596db7b606c15150262188201da928d2fc4b58020319bf55fe522875609a1e229d93587223e97770550b655d26f51a777fd60d243ab3977ebcc7159665e8484cb9714dd2f8bb17e8659b5fc84733c99a48d1fa1286379946b8169a6a25df4d233ba149fea185532037ddf69ed7dbdf80c9c1238c4818118295852c8dbbd2b03cc48963e72c4e618741f083d3a1ed762c88d64861b11a75f68d3c0087cf15bb88af7c3df19944694a4123a1b90620885c0c6b35a917074d6de9474ac4319cadcf07ff0cef61bdfe17f06772a66427a7c7b179f3f112386dd84036eaeab142fe09ef145cef32b07d887f263c07c449930cb890adf4fd1fac6a5513e0b63d6bdecab1de0d8b1e379474ef7da02b128491c7d0372a788c798e29817a5e3de1915a3f75706b0f35a63bb912dd105f0a580c0ad9f6413b163a0f37c30ae02159884ecd08aad26bca0c25df2be1fa1b705c7c3c144297651f30c31969b24bb8af8392f7b0d064bc3e9fee5eeb455f08678df7e012723562e0a3ba111cc496d9c0e6947afb70695154a55f863610c687b3b78a893cd92be1363f4c0b3809d389001bd6becbaf312501114c08874216833d97da320de2fcb99dddf4b4810a14fcd9b3d6a97a9fed3540a9af63ef3987fe0a3df47c4f3a5cb4cc7d133818d0f349becfe4fa168dc6a3f59c81a33212e8f6a0881bb90ebc2b2dd80f4f314e532b57e4624cfcf5da1ddcfd11a6f1f98b88ce564f6fef433d0e9a2ba6d1c629a93c48e2e229d42f5d6569c036f19874812b351f5e393d2c243b69879996683d506ebc225e07f40932e1816c7e4103b0cd4df3608ff7c3df92efde9c29da9e6f83ff2dab603b99dde4c49ac980ca018b6348249f817703a889222f18d3d74253e2f465ee6188d48b0757752674bf74085178ec38430e0f52819fa42d8559f12140bb9cdafaa2112e29be0c1b06f3d268534bc9752abdd650952f4bcfe7e15c639bfe38bdbef7d5fd83c00e6f413e1db08e2f531a8ab5460d078a7bfea5ba856500747dc1083486bb0a9a2a3aebe6ed6ed89f94fac4ae50a30aceb2b1b916aa439765ca743723e170dfb54c9aeaf2400b2c4a8663b830057db9302dbc53d60abe6bd7251a963763036dcd3f79235261ff8f5d23ce5463e736c553f2a290a81dcf3d3ec612007eea210010336deac4dbebfab7f95ccbae133bfa81afea190d1f841c7ee1d68c72e3daafe56fb03f27b490678b3fc331ae66ed877aaa6381e2cf2df063199b0a641754012eda694d61a4b90d710b81da737b67b37ce0f8bd4e531625f3e93eda4f5beb0034c5d0fae2a2ad6dd9117e1a9adeb6b230b11ce4917c6381bfc13b93746e1820e42a6dc79949b4885f3d5bca9296b823c92d3de0e821ba7b1f1bf97d2393a3574d229de311b9893dc9fcc96c592cc0fdd315bf101444faada785fca5fd2dd655a55d91f8c4756c094f86ae4f5574a7f44c7201216005a5249509bcc49440136942d082024225374cf1b2b5d5ecbc479bb34cdd80b14dfdedd211caef2659d0c4de80a86c476645a32612901639ff6c45d21c5c670b9fba22f1c3a9768014bb43057a41719a22804d951ee9ed4c686de8bd0fdefc99cbaa7b01e6a7ba7782af75b8d00e1b1ecfc75a90f166d446bdcbf63d430f69f68e9a46edd123a213279dd369350d84ed742043eecd6b52dba36e38817031acb52a2bc9a5759a2e8666e8998c94066fa1e3f820b7b115619bedc779aeb94d7c30daaf83b0bfcca15c74e1ecdb06492335f24141cae9b480f44b805c2465568e3fa19a821ec3d0d3f93aa0ec2aecf0a9d9b78275056d801caf0dc8550b919336e8ac9c8f150c087475f71ae39d8ee428963df19d332be73e872954d59b8b54448da3bc02efd12e698c212f1f3c45401a4e0a2c6c2c1660ac029f713b33bc5b5802cb64305464ebc49cbcec1522c6e6f01df8e84632c3114a4effc77605e2851397fc5d201ec5c323c28d2ce48fccfc7caeadb7f401d78071a6c6ca2caa2c23d1e1abf92f986ffd1bd292015a088eff89707743d75d874c22958095f6c905cfe76b458efba81c03f6b871c9c530116df5ba345c3e7a84e132e1643292cee0febe69ac0422d6404db6440c086995cb0119bfe5cc2aa034fa1be64a04129248c71552a54dac95c3627b9b8fda55fb09bb6806711e218e161e36d526fa1900e3629a7c51168561d93946f5419c55c8368ce61dd0d41e673c6a67697c5ce4e3b47e570efa5cec400ddf4383e036f600aac8a5b6d7e6d505291cf23803146f49cc3ff9e4ba5d4a27c945dd7544b4e5ccfb2fe1a605cf79a4a2e22a8f7e3da06126ff2f1def1a13e9f408fb232b5285ae2f7f6cb99cb291d4231b27b46a73dcb07746d0ec0fa1acec6504174b35d22e48e0ae6f5b37cdb294af0a8935fb5adc932f07920e7d7350dc5ac0dadc6537a9f2f1185e3d6d1c027fc1415c662c2283a8674b6b2733caf778785fd65752a99cd32f7d48afc3fc5272d39610a5d3fc5d395b4455c97c6c932b01ec2e4d6a6e1565344bf12f77ca60e30fa8c6e4e1ede967376d278ec8f6ee1387efd75fda37f798f0c797f7006ca09a7b03dff0a962f359979f5a559eadbb48996715378239e114d3268d9d2b3f18c8596317eb0ea6ceeac01048eff52d6cfac2551c55e8bc840fa3df5e2548828cc216ba1bb1e1937caf6870b343e9d2f2bcc14950a11afa794454f9a94e248eb880999523050644e8b45df3ce3e99c40998bf474a7fcaa8f99f2c07a395a9023c42d8165bb807a60e4ca815db058822b02530530c867245da5464e66ba569c3ecc7443e61e84be5729ef07b883b82ddb7cafd45656beb1fa0d84e3d692772a48c54d86ed78201d392ab2dcb8935858846efa467982543704cdd4db107a744ed70c4b002254f4815710447f7b222b1d301973a6c6baac40b404c5827a5e262444d97ec2be5f7cf93edcea2bced8d8d9cc68a0a2031571c5c9887923274103eb48a73fc3256a2abfba9ea15a4f413a6befca208e412188fd81c54fe8bf0caa8ed95e56b22c67faecb24c048f6945ba4f6f8766a4b492618cc8b0f2814c01f54355c3ca39e52c522440d333ecb2d16628ab97cdc63d72083b1ae696951ac68338ad22dc792085aeaab46ff921963a9b8d6ae1534574c008c839c0bd012227331f4512435824f66944eb6b72c97d04b7b0d81a0df0bd82955997516185b5c1a6bac30d790c5e34fbe626feabca5b4e56aace1650001f86a547a8f95b7095195d5dfa42b7144288e3490c5733cf8ebebe5eaa8b135107126376d25439cd5de024294999ffd3de7e9aaba1389fd72bf15e67eaa74aec398f271defaeec2d42b00674acbfef2aa0e45f1e03a18839a8a72f71a857f02aef2f08313ec340e11190b13e033cf69bf63c4c2770844304c32dd51bd25bea23d7ac880be5cb91a25dcede793dab9196fa55a29c620c90758289ccf432cfc5ec2b39d767b7e1be0e8932faa5ee1cb9bfb7dcfe3dd735b6e86160305510d5412148c765bd069f071a5e41c10f6469f2738cd770211cdb757e12e27f9d76885628866fd16777511f072ea84bb90a7ace3d1fd0912dd4e5d8c1cb94a34f4715c7a1c5abc1ca917d6fc06475aa73a9a999d1b1a026c3ce8dc9fbec3883346711ce04f56f6b064d6e19ef8d9455646bbe95a246616bc5588055fe807ee2f72db1ed0dc6ad449a3b795cc141a58a652b022dd7c6b54c623c93947b2c10124aeeb532e3093118028591a3d1f4a621e1db75080bfbfd1cad31a5583ba361dc4ff5fa4198bf5ae0eab708b26e72a8d049e3a3a8893ff518d017a1644d90e2d8a18411e23f60245571926f28bec089d8834a22be16471d52ed631b7bb5fcdb563072aa4f39aef222acb2fe87b17a09d916caf7f036369ed6380e14bafe590a55ed3db7acefb2aeb2f949d4c8ce387125b387feae12a5e9f8fe45ccdfca37ddc539fa86b68831f3fa2e384755a2e5880dd9e7bb752f89b530c06a63eed64713902d6773d672ee5b37424e7061a7e3aa1f722b2251bf8c63b2b6136caef7f21effe474a20bdaa49f7d765051976460c0291c6287ca626cd9be55dc04acb73ccbc58aa0f8614c0c8a186c6358ce7d6e393c925c48b428b443c3585e93fcc09e39b9f1bb1efd46a290a8a69ff68b1554457f705eb9e52e079504a4c66ae450bb947f420e8bba3418aa1264ee97abaeeb6d463a69754be5f51d723ab282cd0843a9538549a3193dc4bbd16baec4d23b8ad36d1d39f0648ba74ddc13a2d05997369cd85d18d91b915f875ce10fcc3b10a581325dda24ccb9a1f44df9f3639bfb16eeb0432acf9166d181eaeec04f88abe6281ecbcddc3ab99b1d5bfc4f6a22683082632a01c6a200359137cc7188879f99c0d831e20528a96022c2fbcba74d73b3892e9afb82ea99815fa22553ecfa627602dd32ad47d6677ffc3a6ac736de7669b9562d151fa7c7673248abd66d2fb70bd94dfce7c7c0b24e618b1121a3cc0e14d1dd94cc8853a306e10bdf796ef06e00c5f6ec8b1b95b587870c9d6db8a36fe984f343daa19cd518002c31473c6cc1744b9eb6c72c9eaf8167351852f3190c90a1f6ae82a061e672851a7e1b7641e54c314ab4882e4db20db4c5ef4576b33a3f6581a77253d0bbc2874cfc5a0d4e067f115de13a8bf33c66d6f03158e7a4dd6ac5a0afce27c9ee12fa1cab014b000ef083707574c1ba8e92ee099c40d29be66dee62cdc7c329d25b5200d51d1f540cb23b6634643af3c043ebc0d4f115bed2d54f87a0680b4f84dfd96f590f02ad8a8f725062145d215d844b893a0fde5d3cfb219fa0b877580956f8edd7f6c00799d1a5ad565359233c2f058a76f2db42bbd29bb115f087b4911e27198894f6a1ea2ff7fdd187c620758dc385c61917a67f1aa6835c4733b37e7cdfa320258f7ce9c91950aee3a17fb4aeb250bca68726cf9d059f978265321a92d8edde170c0fa243e90eb46da8953587033db71477c76b2349131255ada1a944a626160caa7d381910a28583d02acd20f8afbad2635258bb253117c39757ef0f2b2a82aaa2d573de39fbba9a615e798b34cf2548e8ff50ef1dbb1cd6c7a8d63ee26858549456bb133cb8f622371ebf6b643c9229fa04082f523f83e538ebd81da0c14bf815b2128f2b4ee2125cb50a09544ca8aa46cc55943461d772b7efceccd7789c6eeb061a89e5acc2e67754e6501a88c376ac0ac78872d35da633ab4e314c8d8890d1caa79b0727debbd32bec523bf32c743149b99fd50939ba7d9967cca8a5b633f22a714fd11cf5191aaaf103d8187182b56760e74211fb6422dd8e857ff3b4251a75443181ce16ed0a28c64b40491bea86f47453487da5e7bcdb0892258b89a6e07cf9f0db865948739d7c2b883b5ded382ad95608ea0256c7bd022fdb5f53a28370ef88e4591e9caf30803551591e7517a92b378c2d9677e1c21f89c0fb65b25cfa8e7a79d91e26592ba7a8ccc7860f7cc710c5f0dcc73cec98324e79ffd7928795226ff2ff6b1b2a9fae7dc891aface87f6c0f3bc2599b3670cdd61bb55fcb60d458ad6ac1e6e836a77a08e48aa4c759d3fdf9bafa26450c71d748fa6e19ad105b666c947b7209b1ac79f34d87982a7a41b418fd36bf1f2eadfac2a441f3a7c7dc649e21b19e581716fbcd37c8a9bd321fc2bc466e75f9c0e33a07c54e9ffd78950d0aff35b5653c8ea89f59a79787fcb596238bd31c43a65e4cbc8b05b6791e180422ee6f2500cc25ef3a67e3cb75001840080d6fc464ba0ef5b3fd52c661dd01e7252aff52a450ca277ef6c9f93dd4767f489083bb846d9752523b27577e8d04dd0d06edf3ad3515e5495a43c910e6b47282a98aade76d0e8112d5477a4606290e4a2304a13e19ea84a53ab458a51bd59d49552ae4b4d8143718a9ce51702062aaa5d15ec572a3b7ce990221a043e4af8f8e60d5ad6606a34317917ac4cc05494e63239128c72b972735231fc56b8931e8777dc992a48cc0b1493f61a2ca4a8c92ae80d0e67955e1dd11311b7ab75bf80bf34af01d88b8663ff66cbf5ac9ec3618d6542e26c24e2b0e70400dd00878095ce0b0a21f2948ca0dbcd6e23d9b1593fc5b00c690f6f3019efbb2db288484519e33c38783d07d7cdd8adce45ff44d09dcfb5866abed5b3fb6bd8ac0dab19ed7bcff531f557ed99b23a216c0285acd542757c2f2c2030db1b2d540fc6f87a6e812f26f1089faeced41a6e9015bccaaf2f3d658e027d2acd209a00fd9eab2d1cf367c364349edf1f2c4b822a9afc771efd454d1c5b6f4bf857f838b99e04d988dfa76ae78d3532b8a8c7ef338faba89c1e284a9a3875c8df6f3b51ccc620de5663d22ab41a4260bc6478e0df74c3910ef1c7bedfc8adec081b7e39e67e156eb11c282f61c9db7f1c5c6a8c67298316c299a7aad41df505cbe52223d9e3be816f0370d421527a40196b5c19213335dbc41ddd03d555cb488653e469eaef2ba7b64d31d15d9ac6c7eb9d560fb2884611c1c170efb0180d9409a3aa6627f196d7641aa56d9676b6a618bf3270694a455219b05acf05193cdf5c93003d7c5f801360e9507d212afcb29054f1f9f1112565c5b2c2aef0677da3ca4026e05b0b36f98c2762621660a1ca0f727d6c9623835a960cd397290bb2741f1a5e9c4f312d064909e9b6dd5914ac95f09f0ffab9d5719387a70bbf59f019db7eaa4e6aac28b9955066bbb06d2f4aa6070bba59f3c3a1259597ef2b8243b067805229c71b57a7295bb91841e46eea5810dc318de2b424262a183452e673260cb9abdb513d3f08002cdf7e3b3639c877bc0c35a2483d6768bc9579f47c3bfdd45dc5c92d5e8ddca014a6af5c19f5f392cd3c83d7e4f6d3e0f30170728aee6d573a8b70e0b506dd58204dfff1ef5ddc82be8d8e75ca845a6bcd132e1d7919d8f2f86c55c6aeb68f4e3e73a0b4d75eb3400b0dc8463928d681b2fd70127e2f3ba77cfc04b2e4dcd6ab752c8fa0f9ba076b23dc2704694a2f6f124b35f48d60640c9dbc1bd3631f37008dd2b7525144f73cdca19d9f7aea2cdfb7979152ddd67e98f431eb960838b0736c342aaf6f4d4d2b381323451377379084b7b4b793fa9df7494e08da1b60bc85a408e734efdcbe9cf382449f5a50aee7eb9039dedaaac93005c42a85c7cb6e916b47dd256b88ec44966a2151b7302f55ecc898a1309638569da68e91f17108ada36f85cffa762de5a7305c6c316a9c1af77d34abed5620eca26639834e6ca780c026664c543ad349909d1272ded93fec227736f93d5fda80183141275cafe892ed35f905cc882bee068274e98a58d83258f84f30f2c090660a11734729a7d0ae8353c5b467ad84c10bd1f0493abd4531934fd68effb19fffee1cb91da46c6eba039ebcb6595924fd7e20b3c4a60d49c7e395314cec3db41cf8cb63827a1f8bd5c7c6cc803358b815d453897c176355e0c27535186b25696c4ec482dbdc9b13af58402c1f594561efec9fb3da6324520c4a5287595f89aa45e439a7e0e3e0e48553bf5315eb20c1494180d6002295b529b3d37a61817c98c003afca12777728d410ae6dd5beaec5ce21d7d8a6db6109ab7ddd5e60a45f869f644496420b4dea63577b658b64d6656973b463e70dc332820a977990d3bd5ca9321dbc3d0542f14a0cf64220b98894e9acb8413840ab7fcaff5d4261324ecda4d209f606b2cc0dd912649bced4ac165fbb9f368ed58c0ee16770106147a924676512acfb2a1e4b8874ff708280cf2c29fddceec2ae598bc8809235d4a1ba0329afea652c6b74d8c27cb63b72ea7949b04650424fe475cb42c182e7eedddc6f5296bbd09db2060b3cd6e8773595dbbc89e67596ad3512e2ecc0b7dac37f1c8e835b86173359af1013cdf140a6e41290af07cb1562577d3407336389d60502cc906f94a7973a0f9c7888f0d35cbc4a71042911e55528e0da2a55a56bccb7dcf482b877eebd2b2427acbbe7c7cca51c8e565d7a52ffdf77908250930b1f1d6cdea46a0a7cdcdb86ea7e22e74a612dd145297488e6146f243eb8719794ca1378bd8f9729fbbfc04dbf9f74a904f783c88252d7d353a7a62648d792033ac6d7b3c3468bf3e202beaa806ed1c6789c043a80abdbb5a5430d10cf551f3a971bfe50ce47345c7b2dd50945b278cbba9a6ba729111d1ae745d91e2dd47f88629e851385580c3bff51674acea2f79aa75dae71f189b34c77ce9be6240315f17554913afb7bc4a446aa35513611361da7918d1f97132a4624d4d44c93875b6cac7449b695c913dde472b934d66c5e0c0763bf946fb63c926dc53b56344961b25b385a3ef64a5bc148282c6e544b8bc672399c57453c094ca47de308cafc593f590ec39e5192daa2123df0616cc88c5e6b5f22de56b9ae8478603c63ae32864629195e9d4265c1d84d47d88aba7a8057708af00828864deb6f1af47c221b813e3467846b61c0f0d7a6e3b7b89b415d07c46db1be2312f38f3a4728c6b98bbc424cd5148fd4efea996f6f79af896d6cb85697f52b9bab6dbeb33fcd9af73b9109d0cb91cd97ac00a14e43f369bf3628518b64d09b4ae1aa2b5a56625160a0ee4bcbdc2b5b16e7dbf8edaadd67f1be47cb56ad282ab7cd971271ce9aa712e4c09b134ef675be0dd4fa1828fd496743fe1b6fdea439493aa2d7161c757b927eb457849a0d4dee7ac084d38cef2d3c938254e68c11931f0026a42c3f67f09ccf6bb620033c8471172500229c9c5a861d9162f25c1f2fe213acbb534488cd3b3530edb533e1d1730516a884f8edb0d3786677f0a5f0514aced1a86afb5caadbbd4435456ff7cd43aa3d5ccb66b1c003bac74267fafee49b7ebd3f5c3c8fd8e6a575a7d6b6d07f8a8da6701ac81d71a33c4683ec324314e437536d1cb020dec3e259eb0261aef4a30fdfc0ef805411a25dfa4eb402d0c86459e23a3e5058ce50310fd6bf94b7003e41fdb7ba7451289fbbd78570fc8efa68f713c937959c5849586c03ee3a7e7f8ca93d726f02e89744c9460be747193ee193a5045a955e1b152f7e93e65e7456b9e16a0d916546c4dbcf7f01a8629455d04592f62394861e6f12b319ff32ea0c5a8fb569f6290199a85f6ca95996f9e0a59f290d4e6c028e520de4395aa4a0cdb58e47f449ddcb904c5284d7a3762e840328211e910de16e3675aab7526eaea203e665e4f59868748df9a45347ae6751026ebfeab18a842fc33ab1feea594c62f62227048f241aa09f6287bbcf287ef8839f23f4c42e8bbf04a653e4f176e9e52e0af5adf4116e8f40e4c4d79a38f3a338ace3fa8ca865c89b274b455c56c83c1ffa192f4994b6a51c9f9af6cfcbf0dee2e7ad8f07b594b7f582836c411b10582077cdc06423ca67f6e1faafd67d46f9c139ee17921b48910c9404bc95c995eedae05cae6597952e44a0530d486df5cf022070e4f26c0f90c7bd00fe40fe022039fb538e355f46303cca87165d074114aa86ff9c4598129e9e19138b589855ae6979ca71a2bf2f6caa903f589e5aac9589e2940e8c5a496f84638429c9dd4284134d6d2f9be27208e2905efb39b1ee9fc529f1564a1c5cfd36b718c1ff3ed63652e9db756aec4ee67292ca6041c515ab03eabfa688a4255ad636d1511bc5ab77cd8d1289b4fdeeb88fe745fa9f776f2b43d3e5a452d6b998381b8fd627618bdd308406cb30adb3f8a206a6faa328ceb7eede5ccbbea62bc96378f9d6e419991c33c00fbcb8a83959c7ddd6cb36175dd0d02f352550305445b9cdb0ec68470cce784759815a71cbf1bef6224ffa095aea4d7474333b0b963f499320f74bc2ac0b07ca89d11793ebbe3a9767bc79c464ad5e699905b1dc0e996c25af0c08357e3a804aa86fcb1ca00330db13dafb6f82ae514d2b9d83102616b2c34dd7d004db86337ceb7c52d4882e69de7507b6e4613526b6edffa326d0b6b0d70e68459a1d9e926c83d53cab85002f3897c87be601baad2a18a5b7cb0ee7246fe45b7fe703900cfafc31d8d16194ef788663a636a18097e180c0ac23c4f718b9298ccc6080b0b1cc9a43a7894868453d8a1369aab89b895738421b8ccd27cca1cff48f262de3f8402a5df96ddb1c91f2a787778143d301e1aaf96951685383c60817bb36477c9d3331919b013626beb9a56edbe26fde96557601fb5251a2c63b476a1fd71752368f3a91dd7fe5e14bd57d41cea4e30f83e66e962881b887465563fd21050e2788bcf59bc1ef3f23755d20250940385ba81c340b30bf6e67e0d9cab029ec0dc0fc58a3898439aaca4d6af773e884a0df33e3ab08bf8d130954407dbf9bb14bcaa52156eba3a022a06a07dcb193995c1f6ee7da457e6399827988a22bc2d3060180d40d544badaf02c66619c67227ee960eab2a7f1f75048a785d686ead95e944fa9913e01cb556cb2caf2920cb1e12fa50e123a1732c0f1c7f50b04b74140338860c2a1fcf60b4da410374ce31a0346aede32ce1ed6a394e3ab63dae2ca0fa80a08146b9ce6a7bab322e9baaecd1704664de96253c006f841118dfced88a031b0ef4793880b99682344bf586e1b00996e70319ca966cc6526342ff2e8dbff5c0b1571152d1b3681d1a59c3e2b9dc6c5e4c30baa2c6c0c4d2f7e77d6face713cf543e72845def4a2348d6b2b9495e2b65cdf3f1568bd3fb7b6f8cbf35fe36804e817f270494a1edaed8e4a69809d82efb84329124949252c711d6c072e93de3808f3955793f2eac28fb934578fe1a7fe2ba7b30a952f05df601d0f212f85a701f3000143977ee7eb96f6d6e882a5773b0784eddb1ae5191131507072b6b3547f09e2b7c04fc690c4be7e647ff985bd4662a08ecb5ca7c1bf9531a0dd27d743d42cfdfbc3f99c4c85c14a8dfb7ae8f2a1be133de64c89890baabe488cc71bb3b92956b3cc6989e068db76b86b412d838b93deaf9e8c330a4d92cfbf4f1c62aeea7ad52a8c5b4a535522232e279f384babbca1f9f91c7ab889b2563fedf3a8e255e6daf5b00a1a3e15647392ae71f491d082c67f2a1aceae4bdbd4d75b1736b31b52c1c15f2643398782a6fa5fe828baab845bf3797e62677532635a4c921efe5a9a8c8382b32a655b2dad9865f8e43889db8edfa3bd330653558db19b88dcd6ef0945dbc7ecd567453e9ff67970eb28185bae96bcd79c2333e6d2d40d3ac4cb56669dedb2f25bc477119ce82cd9936caac6002579bb1a3ceea0b8dc44599d1545ee66bcadecfb4b77f33e7a90df88ab44a2520653c4a0d12c6abb4168d96fa6290def89493cf320b20f8e3c0011dcbef8637bc848bf0be7559151cba98d7a569b4dfd60bd450e1a5b04f365211ef4a5bc0ef74e1bed87d791cf41006193c439eee4c00fe6b23e9d1d30b1f9767d731f38f71c53269feaf3137f67b77d912bfb3bd48741a7d309d27c98da6647e210a97105d817092aad6a4c2db54995fdda83cf5456d40d62be2e84d5702470a8161dc7bf616805fc1e7a3ec0f2344685dc8cb70c66719052a398fcc62c806f3c67e275a5c902bda22464e99f8e0d4521dac7ab0da3b26db9967a59aaece71b4e1a59362f888ffd622e120926062e222ddad9ed0fa6c319d75290c43c0262d3b626952b2d265d2b95e0e2eb88c8b8cb6f338b0c76dcefc50b7ec0027e603a4d56e04863e61df55a1bfe9e1bcbfa8cb97359feaaf35459606efac20ef0dcd2099dd39436e25fbbdf9575818ab194704648cb4f0e603f94b43821248053b35d4ea69cc6e7eb62a8c6a6e6bb7004a0a40836206bb8c4cf4d37ebe8b673ae4bcf53be31f9fe48eb51f01d47390b83989e4a919bca8671e078da1976116cdabfd92f160e5b0a5788ef157727caffa0ae209f08be1ab9c916d9c7a79009e0688f5997dc76810216addd8e11b32529c6ae6860fc32c80de63513fb7e179d8283d9bd522484b0cc9cfa7a2d125beb081aa102219d70c5709b6d23582f81e85e0516a4efacbd3dcda04224f12bdf34a05924ce7fced6acf983089429aee0503e5f10bd40c6d50e53b4fcd18a9dd4173d017d3dde2ea5674bb8d7bf400361d3599be39ff79d1e448c648ebaf9ec654fb31222ce060d5677c28e92ff43598ca3d1ca38521fdb26a429b0571490cc5151d3a3218b27ae87fbb60bca5f7d8a2f617a486084a70b339e443550ac391a0d342974f7501dd04cd08e5f404093255037ae74d784681ee040f2b8679cd7de95e4578972b8cae0e48b46d5c126c7bd95c0b2b8b3d61854704144217ce3acf54425accb36c3850bce95704f2964f82cd7e675afd05cb68beca75c1a80753c588aa0a98980868772d28101e4ee44b106632ce9e2e5df0b1d9ab6cae8dffcebb880ab1cc8b4a323832e4cbac04ea1dd1613e99200f61998125d585f43a0fd61d5918a19e8f31b5424d8bd56329ae44c1b79343095291edddbb6b1b3771e6257549b2949fc8ee74c036bbf44965a10feaad87c3f3c5cd1249ba2b848e4a39cb3281451be95a37b06f6848f8d04649df6584dbf4aaff1a1330fb80f0b7b4c02e38cafe4b36e079f55ca25a45b35ec9e5ff3a16c5b9645bcaf5bf6606158448598a7d5f26ba7fadedb5db1e6119289148ae8fcd143d28ff3fbd18407405e4164304eef774881e7503134aeafa9a713fb42858cb7458c7209f97e60904852b0658d51804eed875c13ac6ff8fb69a6183bf429c321e6a396ed1a3108e98ccfc31acf435bcf3a423431369618ec13f4a52526f9cedb61e23b665a65ae6ec25a76615901f7eed4ab4b0657fd8fcf276355372b76c29a835f4f2c050d4e9c09f41261a709f4af1229024fe8f115038ea92922af10a581f66f4057ec7e42a4f1034acce8bc6086cfa15cdd16b8295475f427daf664fe0b42aa969115e547c6d2ec41820af3f8194467b3ed31f0f3c6cfbb64e777d005ee17ff9dbf05b07c0175142936e19fe3cff25a7d8be7e71964b92b0607fe875d9413aa3e90924e66b6bb3c6ea7a2cd5fa6a0943d352615e4beec847ef998085debf97933f8c0cfd820e1ad980a4dd897c63bec5bccb411999bc7f3b85e016765851495eae84d8462c7a12311c6a974a96c69f0033ff8f1d20c379253e7547c27357bee877d78510325cd173550de4b91750f377d39ad76cf7e919df4f2bced77b689b994a5e66e9f136ec6cddf51747594dc0e7d9a64486e6f2afbb827b042f37b7365b8ca12f583ea04e5827502232d5bd05bb3559688fb4307637394bab611efd359a456dd37707ff73c7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
