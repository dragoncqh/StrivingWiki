<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1026680197a7e7acc6fff57a19a8681f2159111983ff888485c5acc65bad8067567c46c0839d6bace01a80b6c7fb3dc342f23219b0f65e6141affb5a0987dabbc0e2b63a65a93f8f20d1b17d76999a984905618c7452e9c9fb13977ca1f00d15a27e6c0a5e0dea82ef5ff1e54bfb2d9755b49d18283c35bc2abe412e8124634732e829e5b29c4f4f1bbc73a7d80d7785831abf7ba4766a343a91bb19aa63e5a72c47bd3893e79b9d43f579b5c8824967a1de2fdae49e7deb5c935ef0aae8b5130449e7089db9f69b1dcab80e7cc7b5858e078c45df82908664540ae4ff28b7bbbc8c48021bdab4d3c5f43baf89ba390010fcd02a92c83cfe71ed9d2ed865e7dbb85daf6b176157bbe65fd8371c7e4c5a5a6270eceb156c8bac79911f237cb15a33ec71247eb8d98128b2d558a5cc619d146c768bc0bbccdafde63a1186a71dfccb251b5abc64a760bc01396541c5b1868db8f6d210296d55ccf2c81e6c690ee8d616f8fc1f647062a6b9122ef161d36b16349e6dd28921480a0816f5e952193195c214506ada771523b43c04327c9c1fcff5a14d67a032769a4652af90e59d2dac02989b0058334baacf26fde67772f1dfda80ee9a66907085026cff13451e40a7faacc4a6168e581a1f2756582135f2acda54eeb9dfca8263f1bf775e17223683a694e956117e3a78cad7b7626ed85104263c7bb3660a1bb22643d4eb657482bb1c5c49b1cf63df291390ec7a70c11d3b9840508338632042901190c5cb9d94d7d339935f682e996b89555f9fd33105e915e3b90631d07d031edc46af3cf12c911ed2d78ec5c3533e23f033c0e960d0410b21bae04ffc31718467b94bd0c84f73d1dc1b887328d6392e27603ccf15c1740f6d5d93c19cb5c5b03e0db16d52d4970a6d67d2f745f51c5e439d3a77fd046a8ff79f4129f1fcab85ea9fdf7d28441eef721ccca73a7618075c8c696e08c96fa1fe4a839d300cb7509702be5da9a36e71bfbb8316c9e0aae31e943d2085392aad4064f47bddb95f3f6c88c5361df42b4effb58e1980f2033a4cb51b3faed241a7080a52e8434b24f5b72051304cd58ad82765d4dcb77bc74f316b9025022313118141d1fd2afa39daddde830dcbcce4203002d9ba5598c18808c7062af8973faad1f46d143ad7c071d60361137439a7bb356dd1496e6b000ff3ae7085d4ea6666b63716c43c10dd0b17f44f0f8a6ba69065707a864f024bd3b49c009d99e59f7a95bf8ef5d9ece532f6ad89354d7c41b1560ef54abdb057ca85bec8bcfe770eee4808f86051070a7ce00a0becf5775fe4be6f1827262dfcc0cc392d26b68932d3c00c19be57b301a46873adf6bad6637ca3d89440d9d2d3e00931b7f8d34534c3cf423be59df8912db220831fa484900b6ada7a7b439087a141d098af9071449fde3c39274cdfa1841c7791bf0c2e8f39050819a1668e1ff566d39385bc91e6a1e756917f8aad4902e48ccf4d676b22edf1f525ab5d8f94c7a6f8cc7bab52ad14fb3b5cc97f3885dddae539e0983dc2276fb15d5231cfcffa5dc4ced4307c6e6812787966469c42b10e3de3ad60699253af7b524258c99689b22815a589e771a4a389c0ef2ce15993acc9304e1150c2a04cf04994786289a06285e647b19e9aa683c0eeae5aa0f14f458b10eead221fd4a4a328798a1cb2d3e828f100f0b6afc77371c003e015bd60da8d862757a34cebbade2f0ce498b763b70bc514ecae59d12f3324ce71a54eca346141570c60467431d8e966089e0da15244774b5d9fbae4ef9af7907fa57689d211537f39aa7d7578cfcebbae7a68536b99a05bdc1548b12459348742d2bb717f3bf0f2d8e9e6ed299fed1ee1fcb9bf1418501d22f472908db6228ba5b8c9a49b62e28f183b34035c6c37a0cd5e82c872e6f7101c053169df535206538e7a557cbc3c1370a44abde75f463c50bf8968a7f99b21265aafa80f63acb29e907142a1b8e98f84e1dba78e8b342e6502da737b50afdf8318946eb7b4cf74a7c240bc57471315f19f8cdffc81b417977c58c77eeb2ba022511ef22a513d7da7efa3b7d413bafbb5b55a07853a022108aaae12636628c58fcf513ff0571dc30673b4e67cff4a5baf32b93f0aaba1c21b95465f45223dadd26922d3c3226c75287979f8109470068b792d765d55b5d6d2ec6e10488e4a8e46e77b7e80b1a091bcfd7809aee994e370f76db012b2644f0e6a6dcbc79952fc183c50cd1596c952bfa763ac837a3ff5841129209946467ad01fc5a1b65856a1d4e502bd9f975ec64105841a91f898c9a6e9f4d3e4ab71917f5aae193b19cf324c121576d971d6ac5d16f108d9d0d17693092dc83670a3162204311061ea431765b56aa4945bd16b7d5551650b00a8dce00ad3eafc2bc3641dd742ffdeca6f9b1cd5899b86d86feb367ab7d332896659931c955ed35bb482113370181e5c735b2cbd8f7a4f4de088f68bcb646bd1f95df03a885bfdc7b63733589ee9a3683a9bce3f29aaf577334d44d4fd2cdf6cd97e25f534d4bd3bb36cec9fbc3286872b6834ce904b89daf2865c166637177099a5cc2044d3157121e295f6fa5f9fd3db96c1374b396c59e6f620794b9648b027a742b49444db2be2e7a3ffe25ffc0289f6a48f796b476f2a8a3952a48ddd2453266b56ebcf4e86c5d007ef2f1ed14735be670f7d94c713d60546ef623f087a51a3436cab7430b7bf27f3f7280a54fce6adf2a18f8d4605bc84d7a73ef153b724ea56bd2fb48b1dacb5a64c9f5d442e024753e87e4ef7fbbda12f10b9d12b121339a597a2943f52686540b256c5abc0b843629633c7a44eff9cbd488822c3eeb85c075a083db071594d38e0c81021bac63c5d6e98076c64fb7390ec899e04d29f2ddffc0678a22853e830377873251ce86e008fbedb16ffdd7d8ea1be78221895658b0bd1d5bf74def9fbb19516c4273448149ff2046ecc8e11ef42c13ecb83e8ee57b0957472a5bfd116ef339da332bb08999baa5b473ae25ab76ddbc0919f1e841f07e3a892643ee1d477f0cbad0e514800ce14690af1e38bf864d9c544970f1be7024335d76a0488656adb3072a0b3911010d3264a7406843b398845accbac2ee8ac71c5a679739708bdb544e85777e3dc971123413e4cbc8a77bbc82c1f2d87f882be726bc2e01edf143f0da0778d41e36bd99f576ed3b753961a5b6ab6b48f4c351d73ec4734aa83e3508eb33909900205fd0122c4ddd090502b62b9103ae1ab08bf3b607df352063fb20561fb0799595fd68ea9e9fa1ce1e8661ace1f526afbcfb8f22ac5cb08148af9233627062fb3b4a5f7ba01cf31dc5436dd3e506bfc21b71b111164884a6c891d7b32303d77883d2edd24edd56dc7d1fadbdef82c4bb52f903c5fa97a00be0e910535f9aa09898518c27cc7cdc760c373705ad7be1436e2469adbd535ac7aa3322817301c48cd2216c983f1be107f1a2771ccc862e6de30b95850f872dc7ca4825709ebe2a10ea9cf69e7f63d50ddc1891362b4d2a9d5069ed8fdef6c4a66964fccd8d87af4479ea685d70f65cabd8cf5b739615cba629e02f9c8c9a94bff0ab760fb490ceef6b0375cd539ade7611d4deb73cf07acf6c608fb452f83101ffa9ffa9228ce2cb2e2d8d7e96ea27033a87d2a6ede19c8d8eeac610f0268d20a30c10bddb8e8450c13b005c1fbf52416de6987b4c2df3d8aa56b7a66059931a2576dbd8ed7fdcbd29dac59a1bdab4bca63c964339bb764fe9bb65ef1093a46bdb9923e491ef650c79a257b5cd1f047aa4b55c5f941ba3574a5ca5d8d337ddfbc142eafeb2454368b2a9f4b6059c0a6508149f845d2d57d121210bf99eb4f6ba2a655a77399d3be86e8cc0f11f9ac592ca883a991b9f44febeba330c01216165d35fce1b1e8d731d2ff0d7fc47ed27301a18eac9cb8d1447c90573f45b45666a5a4e0d19a1c5c95430ecade8172d972b2106d005a335c2cc04591a601172467eea2947a861d1583cdb25d5b400c76e9c2caec7f3895d4486ab7de9daa7d0b344ec55ce93eefefdf71609d54df9f2a9a1151276d24890e47b4d9871cf6fb54ca62bda16d10f03ab07b92b9290567f79c87c66aba8d3cc3e4e067dc9ae45e9d75f2d5cb1d193999f10316f38ba8d2693077883453b07b1674fbcb7ba7e910bb5d3482fb964cb0b5227ce7c6042dd36353d66d989bb31b4b246e9bc55416192b64d4786713c28a3179f0ccc63ff34001db153584bd8779f83474a9504baa7db4872dc35874c4ac1aa1aa47a5e49f8fcaab699e7a77c220fd47dd621ff64f668246b59b6a1419aabd6648f92dc5cd3a381f0175a6fb142978b2d134450e53829304b325ded6a8aa75916ffbd7e8e544306ff53da720ff75cd2ae2dd4c23fdd3f9b9f559a8207ec10b4adfb915464443444a91a696de2cffec682205240ddd6ec2f76e63106aa965bc3c2ea6f2aedef738067ea1c39c7225f011d683a0efe9849186a3e578d505e0c51b2c3cab283b1aeefdf5e91b8c78959d96c16c57d88f150bfcad060cc3dfe32f3951faae09ac22f4567767c31e627865f0d9cfd30d899842e42cd48176316c29343d26f31c931d83912e71b0c7c314f314e9b254cf4a93ae12a48417d40489cce66bad74e9c2f51e0be7425586d746649a4dd0e4835b304bfc0cff3f2b3e1e5b1c660cb4d6abe270da5b02e03404a0dd893eccd5e11409030ecd2753238ac376aa8c7a7d0a9a800592e3d62f1b95673d09bb03ff4ec6413ae037ad9a8a5ff62a0b6c4e5f4e6a00511cc91ef34349fa39bf4314ad8b8e0fa98b6e3e14e6b5c3b6c79ac72af966277365f43087e64aebc8d0e7308c37791520b25bae64c66e88f40eb9f948ce3c521b63c495c12a9ed98f074c52d517c43e1a4de58bb3e895013df83e3873308d6777598248816427dc2c5928f6243de959f0b5f54743c3452c2af47aa30553515a35432f21a05ad9e7e9098ad50257a4fc73cec71d4497e478e4869e6a174932f0495d7673eecc6d5ddf97cd4b296d740383fd1b131592cd5dcfda94c08fdcefb6365ff3506601e365a45ba85d4f9826c958236670781b41f07e40c33761665f4f975990e0e6716614fc0516974fefc06ccc3795ee16456071a5c830b26ff727cedec42d1f4a20275679546e715e1c74e81c6b5c2fabcd5b05fabea68a741443bc362b6f607ef6beaafad1bd45a5a3a00cb35dbdf589910386b51eaf2b2d647142a65cd8ff0d04965491d16722e995550ebb823ea76c6af4a2a9110a2af354d0209add9b1e714132e803325e8d5cc257c2838243b723ea84001ba0d785332cfa87fcdb456522b93084cab9757f44a729ad2f35a387a19998fd73006c8fd2d1ca9d34088114c49adbaa940b1814b95dad527af492982f1112f5fee16dd21ae195383f5c36fac16817836f6e193a3751373889b25e9b237a23743da06ba01807680ba3467389b138f046adead20d5234307d0045756c4eeb7d56595792bf4ebfb44aa616f85757f13d4e67c19ee0684d3b7abd5b2ae0f01013d87a2486f3960b20273dd596de7f8b25bf806ac38b5c091fec11860b4e9019573b9df777454f7af95efa3c3269cf200014f0213c67a7aa61d319b885d68f9cd4f87e05e86820b3c30570f375f55ade67d6e88d0c225476554ab350da79456f27d207e5cb30817a3be803a199b2eef35ec839f4a0d3fe25ace0ae4d9e1d78b88c7fe59efd978a77d44247004fc2843471429ef1646f56f1657f4ca422a4cc166ea20b9276cc6b3bc78427e2ff0ca0839372fd204bbf1c85ebd74776f1b6992f94d45c1cb081d4a47a0c9ec90de0c63f3883d07aec32b47492cf33b8326854d8e55ecd4f3a855288dbcf7d1d70d4326e1ca89b5bbf6509de0d741257307d3b664898cbb138f1902454884fcd8eb057b784aec823dca439a525183f0e44739f62ed4eb04a520651efb96b7424414a8102ca051c5c68c8d6f33b76e5c07f8f641e1b0e5fcda5719c0d7c28f6230295408335d2e01025084ef6bec3963f7f9fe07fcc29c3f5e4a266b916ff59ee0bf557ae572db9f0ca17a47d783b8e217a5527163b8b9d1c2cca838a2d54c842e2c22243b4ab7318ec4f1bbc7f1799498a384fc3f6c796073549dc52137f39978c142d864649c58a1760be586cf6b741f12c6077164d6d5196805fb86d59e76bbdcb1bb5f070a3279e144600a99ced07f1cfa5ee28a9078d66aff48c7bfbdafa8f7c4f68cb22d27c0bd42a084cf61bfd6505474dbe54644e960e4d692d9b23e58273e599c56198ebdba72505963adce6db65b476a76be3771d53521dd7f26ddfcfaff1a4b433aa9b6b1f33427d3034d00f085009d88a97e17358f21369aeb4a228ed411735564d212e87b06c5bf04af8b8a0165ec38c8c565fc4bf669e52c3fb9f3cbca876c27b45765f2a68f034952cef0c811c007d59aac9da7672deae84aa9fa398310c8cc7c52cb1112cf1240aef771553297a2ffcc5bcea937edb7c62569a9c4ab9ade0370e1d1ee4b0a1c24477d4acc3def74cd63bfc45a4f847d8c744b04b6e535ae1306cb6ee38a1882a85e502b4e9f9007509dc8a50c18ce7ab044b9f4c9f7cfdbc6ca01b1c9a38716fc791e1f3c994f6f772b4dd793a1a3a5b9335ccea0cc1c114ae1e6006fec16e58863c81fb7b55fb30a03f0dff6d89bd3348541cef11d4f9f1289bba1dda110a121c0e224848683d7ba2fe895109334bdeb91790606637fa1184673e2f684fc6d1791e278e11a37f3dadb6e50f864430aaf5556430979bcebbadf1394b51b55e8b0e20d3984ca80e5bb0b701662efb30a152c5595256a5a3a06e1c2bf1ac5fb10d8bd6df2383ff1a765a84dcec1a1caa2f07d5844575a96745210b92866f7ed329fa33b66cd52c510434b3bc81bd753f4b293d68a1e930d3eec955d2ecb1271622db2abe9a89c59f26b5c09a205445087303a4f31b4d8edd98d2f722de80c5e5e5e1fea29f2f027093f5a36af4dfb5b021abfd7ea768ebe61200dd750923b27cae8771dd9af482d69ef0f14b132f5ae7c19ecbd78a4699f830f40094493071c0cb6966994d9801c785ddff48ed4733a1600d69fc466962434b1b963afacb91057997cd86624586b3fc9e946d9a08b40c6b1b6ce75736b7bdfb38db1b38a8e199dd90a719761ddcd583a38c01580ec75ae8bf04ac7c3b58964f72535bebefda67771da9a4913d09f94572ae4291a5bcc333320ef184789354735f96bf6c7be085da05656fff7e3b0fc425547c3510162ac89527857baaec88c0729e3a9f8589f846a53290a4cf03c8649da1c8046030fd3da52e63e68027150f33a59779ce345c2f99d1e7acb87c848b8e33cbcb2b840f6b5036e8ba5a562e62803dcaff3e9f1860653d5507a8377c8d5bfd94c6bdc148fe5e720364fedfa52d3871cc4bd326db9884ddab04f7178d6b67c964702e6363b1d10703a469d73bcb500cf96d3c9c4caef50350a5f74c9fe20f868b288624a9b52aebb11edad3adb5418f54b4dfaafca2a2a52e28860176c4fe308ffe783a583c195fc84e0e698a8a2b6c11adde8b862989de6bcc86519ae25abf85d7a7673119688f1ebaf5b22c61a072e78ea0d7c439c557337789b7010c9a8cb3bbe71357702f19a824b945dcdd15a87dee27f2440e643181649373faa0956aa0f2ebb6baa5466424674b106366e81d15f4905a06a4ec304e52c9e4a951b3ca560fdebfe028aafcd2560f4cb92fc6b0447219d36421b6d53a98bcca0d1fc224683d0c402cc360347bff612f959cdc9818ad6642a44b2a26af4555e2705b4034064dfe1364b592b61f62f031b84927dd504f5437d1974afa3b1a3b23a924d3d7d2694c6499d88349114dcbdcdf0528c407d4e001d8f2c0232f82abff947dcc264822efc426391d4609500c54a2588ff42c91453d41a343ff055af3153f71142843431cb2c440509c8ebab3c079a7758ebb6038dd41e06f61f38fec93882469aad8e23384b5fe931f88f430ff241378192ada3f05c2216018f4c5f6d636b68a222543bfa93f1be8301fa6596c3f570688315a57475742b3f8c2ea0d75a606e8b63cfedd366e9e25166100e7da80e63ce08744da98d4d586748892da665a3dcd14f71b1294ce098b422772ca3a06599097b0ac286b75a056be577b0efb84ee990bda029f8da4d01d301208c64cec58e55a56a2a54d7c7fc502ffc9c6fe7df68ea4cc3422a243ce9e8fd9020d370d55fc3f0a8ec27280912e52b230cb821a76aac24a0fd87d0fa9da6b90842a9ff659359aafbe87ba8eff66cf1854b74ce10d735f75abb6d6dd7dee666008f41c033a726312bdaefa93e660bd27af32147d7216890ce47f723220ad3f0b557c29993a25925281b3566cc33729553764f47571d9bb4547d6c97a917c7f7a116d6c7afa90e7da925e16d6740baadac1ae925e204f4571e84bfc642c185ba24cde59e930776337eaa72be400526975ca54e71679dfcdd203ee62fe3054cd8fa67845941bd7eeaebaf6eaf112dc767c0792cba6e05355e66683963cf5b3b7d530d647a9151877d39979a907ef177a13bb82e1eeb7c72b8c80a4954ccea72ac24bcc4d19ec53e574e545c0a9b0822fc14e9af0ed6b3b522bb74b23540173140431f06cc12e2757942c604e3f821604a8c016625834a6fdc9147ce33df4878165336535ecc183d81338e3c6e44e3cff43f3efb83d35971b33cfac4de1131cc54ddbf0b030e9d7250b2d69c8e8e2a12c2f13cbe0050d0933891659a8216bcf942f776890a69d74d3846165585da21adfb77aab226a939d927e735930e76507ada3a06526e30648c83199384d602d4b313276db71cee12396883cb85926087c769b25f4ceeee5579b169d3f7566533b39774a3b3fa948911a085e0f4c32682b2c2d1aabb182d66ac664817e31e56a63f781388bce6c9ef3796c2285f9138a0fe4da3763616b4f029e9df7f5548978f846059e2f15c85fac6f2d0e8da59c5bd98768230faab855455da938574bfa28944953dbca64fe81e61f14a94a953d96ec400412f80662ed0f49854bf57870031df4075944a04ae9fb23927e84eb3de08a6770fbece85cfd5ba01c4a12d69da07e577fcbb62fe3b4b013902124b66fa8e7c8e3f7d71cde5f47e69026e3d0d3c0b6069ea2296e174661d75ac68b94afd219be63f0caaca1e060967d907b918f44d5de5b5f6cc24960786a374fe152dff22ca41986e3cb23848b0df9c1220fbfb264b5acda606f7566716faddc1ff9bccff0a29710e07ad5badafb3f3ea6d01715095fb4654352ddb9c76f0c46545a581cc6cd7edca7221f5ae186fad04f548535bdc52c146971c0e4e5d90ec015aecede79646babb411b8281352eb15140118660fb28fb81d2872e4ad6ed416ff6a777657f4654279d82d911ac8dfa5974abd8c498ec1a42bbbd9ef17cfe42863f6482a2f9c5f51f8415681aab36a8b5d4b70cc2aee05659475ffaa350985743bc7b22d09ace0b4ef5dd9fed61611f06eeb5a0fb488928200df0b155e8a9b6f7b67d2630315528f225df3ed7a4fecc9dd1607e26ebc333e7206bc8e1cd8c2defd732ef3a3dcfa154c5d92aff58e5d3f3fdbadc83dac2e38be0cb2926c143abed99a6ee2fbabe0fed38a4f984905d1f2d2c7dfddc30a54abbcb336e7a5433a3c8db98fdecc0a3c6c111986a6c124bf43ffd59bc69d7df4874462a14c7bf5d671ba6b9fcd90a6d43122cab57c0ac46f3488b86050cefd62d6c467fcee3cc99a687a3d286fdc68d6b379767c78df9f15f4b481601a4ca1bf9420563ea207995bd79a4bd46050d02f50f646b3d368b3f20ca20d1e4df2cc3439f6d88d9788508633a9a35cf5aa6fb4ab9ed6efda191acfdab1e85354a3848785bc36142e8af5569c5a2400428ccef99c068f0d002924999a6a25b2b141850346d4e33b35d59319dd5cf67cc70928d6f4bb285daa458a8375b0b4b4148229e6efd26fdbde0dd9573b935ce7a9d985eac74b35aef2834ac2452e08e86678685e770eeea40d7d6cde590b9c8e6e20e092e42e4c66a740a197d706216b5d1049f29ed563a05aa08ed2599c0798bb29504a4aced1fc10c80fc44c87437761618cf59bd875ee55c3676e92762973022ce5f26d068f6e9bec305a8b43e533f95c3f5a0339178ec2664d7fea7be3311899afcff6cb30c8d26fb2387c06858e5d48a8f70eb1f39a294e008eddb9c64312f3cc85c6b59a4b79e7c087c4dd218722e5f4b6288f5152a952b397fad250891a51737fda8a8ff21c579993aef2374cdd1ccaf1535b8a45d89bdf569fc60c7b398fcb2ced6d2ab09452ad60af6ad78b38b2ed89d0bb136ab0f49d3fb8a4bb0743962aa907cd7ee1378fe434f66bd3b69ecb08ba4b1b9713c4e44a86eb445e3e5592226c8e34a293eb535558f1c83cd87062558bbd4c1c0cb4588faab10661af3d52f643dc764aaf49f3328726dd8b48ab7fe86404739737bf5c90caf913f711cbb58e1c424ea53ffca95042eb6daa08ae8dcc925849cbc8678c7526f7ff9127a07b7381f17712dbc3edf4d76a3e3ad7b063f9c0a4d6ea10fd9481d716b378b9b9c7ff2b4c66ba952f6f6d9e1576d5f70b1ddd45f52f26f83bfa177a0c55e95dcb612eb4fffe90fee989f9a981bfe1599b45fd6e82d479206eed6bf5d5f3ac9cfee99d66b5e88d72c3ca0b685b08fb3fcc5a98706c8fd3b3919c9b283306f16a85796703e8164ae93b60fad80564b7700c611b5e47babd905d55167162d43c67ffd06214d56beaeff6651ee5eb928400169a65e8137eb2a768feda72c4171739e34af65e359c2ed508b6a6fdacb21431e5f5f5c3fae280cf8a6304da77dcf4dbc8a778e72358663fd2da82051e1b6f53b84a4763b1fa9ff80f2bb2ea53bd878342d2941f9b15cd9f49f05f4466ce7f3d071b318167ffa62c3d8679c2474e56ca90476530b79ec5938ee6a4851a165fd854e327e4588c240871484f7e60fa3a592407a6ce926ad2507280882c78a6c9034694e4e02c0cfe8d01c6c393839ac2274ca2ba0c043e30634984e32c512bbb2746d9b6a01e71664e0fa0f555ec182ceac3c4181f6092bb25f500ae4650a66b09d55d3c91639d8ae4befa4228421a9f79480feaf478487fc28b8456c63c8a1d39ed614a474bee1b39aad71537b27be8e96fde125628e944dbbbc0441af02394c4bdca39c50e095c274008dd431b89f58cbfa5f1127d25ab75215454e056d4235579453e5773586a5491e9e3527c2e9c7eac1a5f15a91cf171c621b1bf3880788122ed80f66a9f106744eaaab3b25a5091557b439731d5ca1ab5ff2acb5b15980f904397c31376e5f285483ec5eeafe8258e940a1fcef20048bb777529932e3fd464816cd93aa325272cd8bafae8d5e8cfcb0406e426219a959a02940e12098964caaa1e6cfc7566615573c5f58bf5fbb02096d365b36891c896ee3010e5b83795e58f69b070b33b5dbd94ff14acdfbddced0e0b5993d94a13633d75e2e02315cd0025e20a968c8536c9fe645f321489910fbdf1772da15a8b2ef337f3d42647c6fe78b83120311c634eb106b7c0d54418fc83f23888c470b4979efd9b6b9d469a41aa1c60cbd82834401f88656c03e742595de4e2e369fbb96175710a04396dffc7031ad1004859b35e75cc7080e7f0f113131ddf15ec83eec0cd5f48f48a6b0c41e9cf70b7b580a8c300b6a84796784055a2dff7c4cc4179765842218fa1c154937564c7fa2cdcc19d83203cff22f740230f701705dd84ebe58c7ba0c3cce6077c9c27b9def9030747168c7007b64accdea2162fb4bd4ac0fbbaacad9bdbc5f3a9439405d94cc59c91b939f8536a9c618b47def7dee39bf5833270a6f1c7eda0edd93d214b25bbdb1a54d428d56281bff244665f1f6e2639c3eba5f5703eb160764a0879bad57f7d71fb74908cb2957a23f4a7bf3745d4c1bd80b432acb04cb8dd7f7a3fb4c0ae94d605c6a5f3a1d08d0741fcfcbc2c594cf48870aa725f2cc35d912fd8b6cd2eb352cd46fe0d41ec342b30d824314aed4bc7c3c90243883e81070a462823fd7e0d52fce9330dca128cacbf2388ff9e382fa50ea37c527df8fb9580b1af0cbace236bf3bd8290e4bf73a2366228d1f553a1bb505c8f4dba1955d745bf153c5bf6d2179f270b1665a28da8f349bf792d826e3483f8fbbeec577b83520bd9b1ee26c2c5c649f7ee1e1a03becad6783683ed59bdd3c56361fc2b5951adce62be4aa3ae5568dff8380581b8718e03da29d2467e79a76272e4b2b9c6bbff80bf1415318625855be4f5089b3ce41afc816e57497d3ca1a29c14a89034f49cbb098961d84ff61b2d42ea8e207ab32fb716ea6d04fc5e49dc4dd1c3428908884568a81883ee5367f5470e5b88eb3b472b9c8569a8a85f28bba33d0fba91b6c56b7e03533205040a890bac5beeb2851bd8cbeab60a8809688001d465f0e5a178b0077d0eae81621ef57333feb1c868c87b32d5548d9b5227c2fc8612f6bc4a67a4c3b11597cc15240a951352994cf4b2a54df6f2f52e2725c48757c7ea883ddfbc7416a0dba16464d57e553a530d9a07a409214fcc3ee4c1e13795922be4dd666611f531c590bdf5b2505dc9d825d0da198d9f7c7efef8ec9ea89e9ed1644d9065945f4adad57022b8bf575ca81f93f636c3519c704f01662fc8e26f61d1c954f4ecd0e9afcb84d7f0bd4487a9de95feff782c74d1f09fb152336866a1c56a27f756f90855472c0576e2e6b9ba6591c5860c8fe876e0c967a50239ab4a9c418d2f7c7b995c7d322bd296462908b5c13f487aacbcef6e7ff188c8882c9d3f562bfc684d8b6847fa84bbe1c8a3aceeaa61dc97a6cc3e62fbc2e6be887ac9a1dd1d4c760329498660e06c99eb77a8ad7af1c01f87a0e1cf3f452802b075cd0b65a681125eb57678759c1828d5a834de7e6988a83d277c53de8a66b6c840fe34e82f76b4b2cf63a6cb86f326bc61a1c856b2a79aded3740cdb7ca05095bd8346f7bb450a22fcb39b38cb8d9582a092361d10300a24bdba34a46ef186ef866167dd0cc8756ed91cba8521fcb5a808933149566350caf2d738dfca59a490b5347f300e8d398f49dd543d784822ca16da9dfa52378fd581c23c7fafa72e235d15472ea06510133106f70dcc655fa16efc655c65efa51537dead6b67475879b078a39c69e033b3fde600b23eb3fe9207ab34e9b626e210353ca6bee17b957293fb60dc33c4dd83b7d1aa5e291b290bce118c296ac74e07c2229c9034ccd243c632fc2542f1d49ade1cf82997859d8867bfd96214f9359ff9de03531206038d6cc3d4218cabef1d1da2d7f7350de2a640f4fc5dcc8e2b1ae0d383eacf1e4bfadaf29a243c5daa6bc050e42ce22072550f40595294066132382b810b7cde7cf138b8d7aa10823d80c0dd5cd49ba6feadd57d0bc3fbd8e1401846f62e6699d6a5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
