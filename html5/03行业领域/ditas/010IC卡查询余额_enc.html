<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cecc3c91f2f98e7e0de151f226a516a99ac944f8f3ccbe89d7b31f2f802acf3bbf9b8af3ccd0a32fff77e5e5c1b0630954c8df06a07fee2bda793cd3aa38fd558735fa0a0298a8cea6fa937e4be0118102175f97275244c85a882b42299c3522c3e2776cfba96a8b9903ecc126c11f198285e47836f72925c34770bd527d02b41a51c620392fa84f11d14d6fed837dada52f740870f1ea290955b81c14e4bef6032f2f063eb73b84509e713b0260f1c19e46154329779cb9244f70e8cdfa7d69f8a47eb17003c4016f354c3aecbcda34d84cd60e378e6601c73a47a8de89f271ad37704030c8d431b53fa63b159d2a78cb33f94cb61b9ce3d65f55058b598eedabb8eeff86663af66d164f0658410daa7e62680b27f2f7092833bb9b0549103d6274d96293ac7d3cc20fff7b57502199b7182851836c255ee877bf2c9f73fd42f0e88ca376badd4c4cc3a9d57fed91cfd4539378169477514a1f690586a36fb99501a3c2b94043daade503c574f1e4573b7c058f8fd2dd9063806f1da4131035b66d00580bac1cdc494c97ad847facb2892432b12a78e9196518f9ca787af7a8a6296e3034667fa9767837bcbb1aecce21314dd4c54dbb6c34801941e9f8133a9d3a389757cf5750cf492bc727f1f1e1f849e3aea7c8df9bf113af89414cfc3a6182d92680bfe239d17f5159abe578d8029c97fbf681a09b6816ed1cb483ef676eef3cfa2d487200e07b7b5e41884413126eaee79816990b9a524a2fb4f21d618150159e441fa7fd3cfb5cfed46513a63b95163a8e7931aedef7c639d1ad8361fd6603b04543753a1219c2f446c4d1b15e0c3dd211579ca32e92587dd6929159e70a7b37cefd4360461a257d13bfc2cc6cf2bcd03d768d79ad8d74f66692a201471d6bb9d7b003b97abdb08d620549bc14f3108da2cbac1479de8157f40c888ebc27166faf70f67b0561f68437f021c2b55fc68a07c5298f99ed9210179bb8a169e761a03692c0d73a3ce015b3de073357927ae3e170fc3eddca74aebc6acb3c8a9d81e09a24037b9a7a61c75d368ebb5afa4e73ef731e1ebffb2da0ef0dcedc68db8e3876afa0fba87299f9174576ea554b31e570abb60fc00b524c2ed65d7f6eddfd173b92632015d2ce6ad83e8c8b8ae72d25416be89483c9f9aee57aedce8b35c7af303b498b8af5c9c7b370549ab00916a6f72cf380835788d776523abf07fe341bf389c681ec30a314c7f2e791e14263db447f2573e92da62593409301b5ea5a80a6837d32dfc235d275c66ce434d0a00dd826223fd0cf5cd663d37995877d54bcb59600b1c3bc13e5ff6514f593871d4aa0f78034309da19b5d840e47666e91c81c47b927e6b805851bdb50ea5599e74a8d19f0ff89c168be5ccd38d6eb7c3361e1f09265ba4f14848f6ec543d6a1f1706d7a32bc27f130f9883016b7a38c7a4e31aaa718f6da7e40b8f7a9e63df5d496df5968ba80c443f0f0b17dfecf4690dbf6a9ae300605fc4694807a97ad715fa4a90b4c073e1e01b6aebd4bc1d18f1506fd615f07c5011b19826dab558ea839d6da3cc0191761ce60738e7cc6e0caf5d3ce9a3059835fad9b31cd5ad9582f50dc79ef8930beb54a0d381e20adf1dfed4999df7260e438ece04d4b20ba112334888103aecd034610f0396d7af6e2a12de983518e7fa2422ee670d03a61f7274223e8a734879a86ede989e827f529cf6eda190cd997f68b3d822479485c8369dbb88835df438ba4b599868bc91db1fe57800d0964a2cb1ab8c04d91674388a4903ffa620c0b80a52c5dee5b802471e30ec73f4ce3ab0caceffe7037a686a6b4a306b38ce8c064dda9ab74f715ec753fc8d0564c54fe03b3dcf862c3fee60b8fadcbe6b282b40412c34f4f0203d6b284cdf4db4df5bc3d446c3849e403146ab3e925c8de1d40f2bc26bf10107d68fa2245564034d3bc954d3cd7825513c68487d851b282788d3c31e07e218f50728670b816045ce72ea5710f1415580ef1480dd67678be3e113da1285cbd941217639e23108ca9835fe68600e6cc62e0f0795123587179847b343af233cfcb65cd49699620808a34da430751881896065343899dc47228a8ce9a0ce85842583d59ebde9c5074e584b4ade336f3e8399cb1713c044345dd39ea92ed7468618ef9c7f93245a72dd131e28438a10ae5623af341dd5f499f31bb41374f6c7bf2500f1e85c7bc028176d6a87a1645ef6490f71bf4cbe6bf5cce7886638ee9b1663910bd91204d3fba3e226b9a3332c31c8e94f3e8223d78ce1ec153bad290726126de1bac28233cbbbe9f34fc585ee353d3ebb574e94de4dcc242e9d3ed2312c1da3959bd2475430a92516e6e2f5629ceb4a4b81582ac4bc2294ed3c9878ba25b9835f8a06d49c43bd2d1175e87ee4dac11c4ddcd2894ed61278251bb7d4792794bbe5489662161f2c1c55b93ce9f51a8ff1603756ed28ba8c2ac362e6416b58ef480de465ef29d05bcedb90c5359cda3d356c2b43273b53e980a4bc80230e9a5414a6a58d29594079c1e66bf2ffe7b22d730401664161b32d276653c6abb41503c3e3f4f7dd3039d998277d5014f8719175d59a318e3e6083e02c615b09f0195124ccf31b5f1b08ec68ac39f4b4477fff0905fdb33c6e489bfa4c40ea961607b422b632f8f9b981dffb13a10dbac561fa636f11032197470c8e40d013ec6737108da4b32261cd3de4d40a2ebb958d19d10b3b906c7154e5057152a20ea918b3ecab24442875073f438cf502f0c086a09d560170743091054592cd301014d20edd071443688129a2cacb20b9ffc31bb9859e524cb7ad98e07306439bb85896878b234bcaaeddda66aa1d19d31b74422e230b3e07f37b6895e5c5718f63623a5bf87f5d2edebf6c7900ead6b1f36657c579cc8f832b256642317c76580365ce1150e08001b106221082a7c8369a0b1ee108b7a329c108afb5e483a8c4517755459a8a70ce20ccafe270ffeb3d9fa0a6602c6cc337d0bd7a59cb8288fe5439c24c019b76bd339cb91d5bff97904caadfafa7d94a0d664311f5b690f80952877c2f2c00605b13aa462b91600c6ee524fa04743d5f2cb94a7aa9008f52a634d7c5373dc9d62f226835ab15a2a7cc939563b25fd070565d30ae18c06046bdd3b607ae8f733540ca8ce3e39aca1cf493937c9bed72ae696a15ebc4845d29b541fdde6b49fe019c6aca9ff0f776f2d7b9e5f52ee473555ebbc805d9786811b5c9df38bfb8b55906cd58d25dc12d994e804fd6e0be237cd5301d9c03941de074d2f4d85b54e2a39a7a0ba4bf1818b8623588579ee3a653e9c84e8c59d92015d6ec9b8c5c8c212fa44f4560684dbca9891bee5b395f8daa460e2735323920f4852297bce877d64c6f30f359eeaada57b4e860bb9f136dd1bfd27e8e4f7bae9e26da6ea1c5f06409a6f4e2383269ba28b8650a74f1b5d0381138c2d96640aca5bd0511a9e5bc005bb5bc8df02fa95151b6836997acdbe84361eb9e211aab51d2a9e861d4f17725a1a626b68e6753c3d000857a77de3066f097f23276b99958f2b2dc8c9d024f06c06abd030d35b71b028705dc3cb4fe494e344f3732a506752d952298b82723533a6bb66eda4ac14181066a2bf134e0ca45e3256108b5839e65672b34438b3a584dbd3fec68f98213cac516452ecc8e125bb7891fa3c2e1a90da7abd733d3407863070164fde138ccd475d470cfe2dc0960d9f868f29ab9c9a5f10e70fa3bf0a6da58ec66bd6af89bd3c2d076f20cd68373b948d4e0aec0838bab5d5bbdce9c9a7ef9154a719ec6ac6144949ef48674e23e602b429dfc5d5d17bf0640dd4a04d000c8238aac5ac6a401c945840519642dc18c9b8bfbbe9a41b70ef8dedf520c9896ebfe0e63f1b420b2b16eb75aa7fdb8a6ec0ee78f771089d42542cf86530cf1980a635c465ce0d66d7ad8f6d6a2e167c7a1eeed80d9fd5cedbb92d1eb3621f5cfd99b0d621772898718b2484d1a00333f6b1bf4c7c3fed37c4dc53b3bb5de7cb331bc9d2428eb5b26ff881863500cd516a868f81ff2ea4c60ae558c5feb3af242d1d73a59531008dd7bea06e48a2ba21b37cb3df637535fe4dc75074c3aaa66d436699fd1e220cccaa5c0ab4d70ba3e24749f2057b7dd183f77e930f18931b856d41a22b8f553617acf091d11deba0d37f986fff01cb5cd7fd165f10ae2cfac318042c177f7f0ee79f56a742f6fb0576641d10b2ca595da0549a66cbdcdb0c670181ac88787b59459607005899e8b8bb03d18b567bd3ca7c05eabf54d05d6b4d155a3dd59e619b76cea091816677acf210bcc1aafc132ce5e6897b02dcace06dade60eb8b8b5ebadf3bd20e5b1f1dc70a4a2ba631c34f76bd13a31ae8156224c4e1b85be500079df0f28e1a894fd1f2fbcd23c24ce95766794aaeb9d86e452629c34b042f141f7bd7b53b632e9d0b883fd95fe268644b3b104598991bb07f20e441899288dadcc67afbcaf21d7436f6082de2d04eb755ecc57ee5ee5f6046027037c0feda70d399a7b9bf689816252119b968ad240f869ef40e2b3670ad82239fe4c95dede0d5457060fd5c8fc37e1fa7853270398069fb51c4f5cdfb6f62dae63669ef82245b8b853dc8affd612dc8b3547421b0829709fdbdfacfdc3ac8a0a37affbdf1c35068bfb8b2975ae06b4ee27d016dc8596962ab70b552c564c0236941338a162767860e96818c09ec8a906022e39815e0985aa40dcb1be60497f0a262ca7390003c74e3945088836be8b32ccbfdcbd1fa16bda768d6ae8c4c631d37b92c61707c179844b233226181b545754bdfb064eda5a42adae00c4dcc673e157b53e16f0bbcc17de3b9989702ceb2b86b547529e31b8e596b5e8792d5e54195629cd5609603247e114df88f045b67574154e18f7b2c29c13187b417cd3767ea2d26a89a2e4006d2302953e904b0e7f537b9e0cc4c5b0c19c0979258070aea65a0e9d013fb1683b6798a35c05ee73b6615a378c3f681b4431c253727e348ddbef4181296eae6408f63c8c933ea7314184bd5e082a481bba367bd8354e8adfb94bb7b88198603cf680102cb0f0deb577f2eec604fd6199810372eaaa29b5309ef1828d46d31ee7743bf9973a437b9f68d824ab8b6477f2079b805d9ec7a0f07dee2aa1a48079061a9d5df25d0093e275261675a546e622095ab9cd3fefdb2e2a28ca0b90f7a53c078d601bdf8529b40cfe6fa0bf4656410de76605fa6a811afac58d47bda484f2365ba821d4d7a1f1d7085c96e134eef7628b9ba19d6d1b3fd814c8f8821154a00863db436e340973cbfe60dd7e09c1864483fe88a096dfe13d780d39c2b540b95d9e1c6af8492bd44cbfa2d099e021bc5ca12f0cde8e7c47f169003972cb4bdec627b683e1aa7cacfca69dbcddbde658c43edfa1fa6b9cd89d4a9a89be79e7e73e217b8eef9f5a24cbcb2b0473ee3e991d761fbbce7dd1ee5000594a6231d541417ae1aafd6d9c8f82a7d24ac2162d16b011142aed696309896674094af1ae89ce22ea74cd426d48165445349a9acb2b9f1380a09795db7914b0b73defe8e75603e03813dc85d1bde7d741f05955741f29faec9fc930f202de5b5b44e107e24a8fec47f3eb02d9a4b090cc4011990d59976ec50f5a18a3d8d587075b886345a1cfdc31ed4faf26f85f035bf04ca664d94cecffd5ff10b8119bb45b4578400952b726e457aec1f759378df63223819f2ecfbbd73a4af12fcdd352b8424e4c75149b43b7d3c9afd888e22510b38f78703c784a7190a35143ad00b910461dc7f3cf044d35681918a8dcb55fa2f937cc14d95ac51e2c877958c94f68490b61dca5a6e0467f2d59608d50d00a9bc2dfc100ac7bbd6c53a38a6917d9315e05540b4774b0d58a6a4e5c798163fd4daf6ae681c322879b0f0d2a0c1dbb141d7b785b42387c98ce272423137821a5ac6848cbce80e126b0ac52624c290dec65856e963697a0d086f65175466cd3539aa44432aed911e14a11c1505f61869c76f3fcf5b91a6918e1c13242dda633aff36c281a779485ead01fdbde8db095d7e25b4ed09133fda1c5fbea328c28afe45a7ee63028398af4e0f307576a59588356c7d29d6ab31b8f8dfdb22ae69f8cccfad9151552a5ed9c0ce971603c6cb4e01760861f911d4cf620a98088d4a97f5605904b087fbad1f5d4fb8b136afea010fe4172966c6657cb18802dc42e6b5d6a869527f59e696b071c95e433ccca3ffb14368d6f801feff13e17fa5e9f20170733f591e956bfed61b11e3fa622f61df270b654e9c942da7924936e2ff8f46931b27d09ba0578f18a89624143cae76cf8cd8608bdfef247e415b436cdebde23018fce732e36cd8ffad9fe9855fb323ded8f480bd3741f3177809db1553a4b5dd6143d2f70c31e0b3c866b338ded0d1326979f03db4d5eee0d0f0bc6002ca08c2876270afe117bdfca29de6f9af3da1bacbed254307a8d8b7d5eb230059b3b31389493f46cd87f1001d258aa602ff9b0ef00679a43b7b4bc486403fbad07c781208037a6ff3640e7134cca6b6226dbf8e81b893b025fcd91a4121c204d21ee6b1c9123b316d2016c7685322bd633c1ebfa0117623749ce2ae4a0fd2bf1f1a8b3a4aaeb616e9a7d853e0bdbb4aa7942e44cbc5da1d3219527f6baad8df213e72a2b199deac52d981514e6df0d1eb5cbc713a1f28fee3203cd0590424ef9ede3b5719674bdb9b868abd122140db8f08a3f6c05c1f072a48a545bf0d1b8e015bf6a181405645e63a8e6716ba958a7310fb8863ee46642a5da53597a014e117f34c703e84c3d486af443cb1976ad0333d6b37d79f2263af2f162a3ccaeb790ab785a2ec75f13d02ed7c9ec2ddaa1f48b3692ab7cf6c07b8109f0a1537fae7675f8d65ec5c80333cf1cfe1bd0cf1d01dc954e4a86f856d729b128da8e8772c7e985d04d0e74bbc0b249eea7deda8d538a70563df1cafcf0272e7ed8eb24ed6a3198343eed79fcb05b5f9da2bb30cc51f0c9826b198c19efeb0e641917978ae066faffe72885031a176eb89a49d7eaddb671cea9be5461fb2350917e24b9898147b570cf890646482126336bfbb8fca446900f3ccbd711121c9def21f757d21fe0d4edcc6d248332a8fb8801da42e2b6cde2ceafb526b2e640c5a1bfcfa15606abba67a00167f06c2c44a665be5cd0679feb493f22011eca1a97fcb4ca5ad261ef158e52623ed447c333878167d8f6bc0f88680337abe9e01e22d733ccfe864094ce5a1c72de9ca7985d8d68d3f52db54fd7e5593b233e8df4e4329df40c623335ef85c9070e559720197a547b655ba9788194abbb6a26c123816dffda3057ef5849cc498693bc6fa16853629ead97fd0c63ca6cce22bfe1e3aa334a11297e98485d3add40004d978db50a7a1097cb3c6875ae779ab02a42b8ab069d07c94094233f04162bc4aef6b47461541076400729f80f76948d245b2916dca60b48cdf0f9a04fb174ef5d8db2a57911c233e2ba26e18fef286691496a770d477440d2797f1e49a8c46948a1b958b67ada986690dd9aab68c298306d93e57aa01fecff013459896304977ff6dffab0ea5ea2657aa8d171b861f67714a9b7f357c5f1a28d860e799b929826b9ce2f916d7fbf82e6a07ffbae0b888fefad921b121f3c1d68d6a589d23323a42672ea712dd84ea16e9238c4aace793b40690b74d6904550171fd0deff1c3496dd4b6954ed73de841f9076e5464a473fe93f53d7777da06ed30e4ce92bd6f371159afa05c09c88d9b3b0e93b8c397fa8d8555413b087cf36d77c4533ae3997f55b8ea48641e7e02ac4703a424654d378b2ca25f3b0d2628fcbb6a5360af6303cff1433c4a4c8abf7dfca90beb23a93be8d6d498bf4fc555ee1f1060ef8557c61cc9bcdd652d901f17abd74cf0dc2a2d54deb132164548fe0a9f4fe3965d094a71f79c0a5641b86c7cf24fa1e7a4cfd7b998043b1e82e6c3f393c9b8926b1743376e6fe0d24d0104ac66a3424877cc66b37c08bc91f2002f1518308cbbc02ba21c9d0ff2d67b36bab1f8b80ee90ea82b315c8ce1135f0253b260bcd4666cdf48e7d747ad1b4f04f46a4c73682d1a4df651f5be7c09d5ce18a2158b4cbcadf8011303633b2eac865d62f014c8596ea3f5d53433d6aac293f357692319bfb0801f7b9e485e527590f1fb474965d0a57b21c0857ff05c981b8f400dcc2611f6e4b790f724653992fd081ab6f4408a34246a7923547b43877e5cef592ed6a701dd00f109660bc838cbe4ee08ecdc9ebaf08b1793d4a5ce90b3949ff07a1a060583af13ec08b0e392734e5482f079f63451bbe682366d0028fb9bf9b0a3fff6c8039fb1708a7c3526cd7830a27160d5673ea01bcd44c3da132237f70e891fce59bda6f4cfd10c74d2c8bc8dddf4641d52b4b674ddc6270210e5b45c3a0943112040007e33187299bf9766a92ac1b24a3db6335492f065e958bda1518b7f10cee4f1d5f1c9286204fa95a5dff616642ff9733c2bb56f67a1d056a4d4520bb51dbe0785d2b86319898ea9de4d62a17ee8f9ba74bb121a004925cd39ff4d82c84f4cf89c3a27e7c65cf89e871b3eba94972da961b26be145407a4f6f639521d835eaf70d752776ebc4e6d80b7c0c2ab75ff65cf48a0cf07a0ff6cc11e40118957839af39dfa88cf70f3bff025682414f94c26437bd52eeef90c1b5db4945ad71471b8ffead7568cd165bd5419e89a1f9b6633321d9f7af56a398935c1a3bf9270f9e410b2b336ed115e685813bdbfc378641e47cefb144c2790454f25791d2afc295a9f5f07657f7a6aac1643afeaaff98423e47b991bacc0712e2cefd4a44894e58e7814f4c2338dd434e704aa29954ebc9e5c0824e2e2a393a8d34992b94e30848b59d902901fdfcdda4d7feb18943548b9f8bc1c63ef05b0411ab7c79d5cb715dd6fb821a9d067efaf3e316f2812531313098cad99f399e667c0996f40c6ddc2eb7e9eef2f86c3ecc277847cab9592bf6a5af1f20d1ba3a3573af9494a7091ee057e26ad342e53441e7b8031d14d7d5fc85bbc6bbe6e5cd01982098db9308e7aa71a5d054f1d598a8fe9a85512381ef06be34f2cc9e2bc38cd819cb31d5424335a34bf625a619c94c202fda9a9751f4eaf91a315c1cebfdc028036491b1e2f683ba0e6d813b96226e43e473e5e9aca871e936bb5c0b9a83b7d3c59cc03af823b44c7269ea7e72fd710ca274ad5926c805205d1052cbe912e9285cd0d2c828548941144329b7508efa9961dfeabbc78ae897b61346169085868801bd859fb6b910f1845164587c2306c7a4929fa0d6a5c27c7a76c06643b5e0a75606c1c092966528a8affca29af05f4236b8cdfd5ec00a3401dfab347aac9db680ff28a5a256906c6a0ba81e7dfc5b1889c277329b15cd71a0333c2af7ad9ad4e83537bb3657ea8e775240364b3e2169624d3ba057fa61c5b9fee9c53de78dee4fe4be0bc2a15fd1e3370d58e445b54baad02322af8d67678bc753ef4501c6c54b83d027b76888c9bdd9767b2374265d7a0a8e9dd2c2385439b63e3f5fcbedbd2aefc175f64ed9ce96903f69a27228502c6cf2f99a2a59aeb2389ae6f409a7a2cf12fce5532b5c6ab32fe421da5829b08affd561cf9507c6ac204418dd1a4a8ab3e120ba9705ec660cac5353092ccc232a96ae7d18680186cf030ded3ddb8ac8c4c304f9f3d3365f3ec50adf49be18ffea662bf433374bb4c0f8688ddb7862b4812e6751d89e790601a4344bccc926aa07991a27765b738aaeaa188550a01e1954cd5508705420b9af9cd9d5065edc5c6e65d2e36aab4b080da604cc3642ce0da50b06db255a0b46db5931132a9486f0e1e892bed5f37c9f12889988c207d574881cb8bafd92ed0466bd042d886a0f54f254b74943dfce1faaa7d00677485b7b7bc36be36fc8e7728058a4596570469acc7c3ac020e1be3a543de5310f7f273313a4a22f153ea44fd2c896b2997a5d2cdf044ea9f7fe795f5c7dbcf6be9cff69fe2b82e9c5ab3b48b259b144d61ccba4528054a05e300f893e917d12eaad3b5c2446486113f4faab44d12dc58911fd211754c50484796253ccdaa4e0317eea2f4f5332a6fec5b26608661bc29f97af1d1c4cd8854ef1a6e37b31389c6c8c6bffcf323c2f67ac1cc95875c1f2d86d0d57678557ced13105a3c54c4b7224fb7067787736e659f22f68dd64b1d1942283cfc5cf53911356edb310b9509e4c65d67014e437cce1bf2e3f5229b3de6980c7dc5395eac7abd30dd69c2d0fab907687c3592fb9c05ffeff83678868e68dfb827d8ce5ff0a4ef2a37d513ce40f12ceb787b15768d3783a8aabbea8974f7ce07a8c76ee15a1055cc943f7a6e1f5ab96691ecb1893310bf5b98fc3904033144641537d0fbe3c2e7833ce7aa32b8af84223a98633968adef1e2d24db7cc23c0ca6809475bfc5e1ae212aa274fd953a47f0efff7b8e8c6f2437eaef99b17680aeef8f75d9923209c066e5b1aeca416e28d14f8f054f16c55c18c04d4d42d15ae071da1a865089aad2f5f63005e96f66b52e8dd87f2757948bd1061ada395f6403ce6cfa02a321915fca32e79652c7f35861964aad46fcbe99ac274946f1746d170c766dbde4fe6622ae61cc215f4b5b65db0123648561eec38e20ac0789fc6e4945f3c76f66345eec702e61b63052fb8c3925c4f739e83731e2b86353e02e16989243ae0cde95fb07d222b820f226d814ad11cc64f792dadcd21c4ca726dd9a96d63cea2187f51243206af0aadeab914648c0d3e9c567d1bb6092cfdc28583aefed0eb26c7464691cf01861dbb06dfffdef76719dbc5c5c54a81a3c21e487a9809689ce03668dbdcc8aaee1661a4c6a69e43e1f1afdbb0f8f668f9b052e51f7dc0b1248a7a80b820e7b662334f8dd37237508024b5cd9966dcddf4c05e3b483f735bed04cd46de3ec9451e74c3143774d61a62368b1bc4b5426adfd47297b2713c7f7fa93991fae21ddffde51f0515e9463bbc8a8e5e1fd10878fba198bd1e3b3c9a82252ff828ac7aac4df08531d228cdb2fd8493bff63a15ee08e7bac89a02cbba5cab76cb585f90112a0aba15fe5fa32d2bd585a794cff3b20760f5718428b2fe27dd1cb510a69f9f031e9b84108a98d18773b2618d86424a974c081c40716ab44dc91a736fcfd33e34627f6b62e505f996d20eb7b28487f0d2cc6ff43a5f46837b3e3da3f65bfad0e2ff976bd394bc186d886cd56a995a99f7984d2dd88bc10349123cb6bcff54262e29e996592860f9d675d8c03840f5a13555cdca202157f08fd0a90a7c640cd017d87ab6ad77b2cd3650164faee373f7f2e9a24ec87f1094c61d7d2d0cab68006faf83648e62e2659ccfe00d6bc44a23ac73ec0925e061eca5fcea40f7c7dce20ab0577c93d427372d4efdb5dcdd318bf68f2f356a5d3903c794ca6c00534299483913c8d75f13493befabf38a14efe16d235eb1eeff07004697491a6425b57f20b3a7135a58161cd73311bb8f17b64f144304ee98eb187e18244609600ac6b636e3fc987b76a5ebcc2a46cff900111213ea0c876e62a92d9ba2c6cee3fea31bd23824d4abaf632f16b63fa1647a5a23c63e7ece4da5c6c53afbd05cf4f38157b65d5186c829662861dac1a483b772a69aca0948d4b299e1d54a4b872e156fa71ed9f5b6d401746d3d6e5bd3496ba9de0dd06f6b58f3c68e82cf63c53fec134fec4c55969712cffbb4a05020022e41ebbe4524209fb7c49c268c3c1ad109aa32e4afb53a989dcd6bff0af298fe5cd19d8d45cc4c4b5f9bd4d2918383c092104c913a9fd898697330a8b099b7a5771e8ae2356dcb7d8d0a1e2d613fd17d3b33dee164bf315da0f7f55cf9ab93114f35ffb16ab345bd31dd4c8e6ad6f3f19dd86a47917ac29bf27fd98bd1768c11675c6cd7b4660f41e3c722d7286e69abe1b15cba546ff136b8688551216678b2019f30981ca487bb9a3b5850918cbdd4d377f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
