<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6e64abeb82a8088eb72e9996d64307537355510c78937e9b35622d894b8c7924dfec69d3b0e2a8516d1b14807a8d649e2237f06c826c00603c07f378f34050181da7fe8d73145553d8bf131443059cf51d22509d9b0098527174a6a3f51ca091e88ba82c21ccb2f2ceeab560d76d746eaa3b69e96679c8c9dacc6e0a25aa5d52edbeab9787b931d91e485531d42da7e8dc8b8edb7602ad47427b0206ac36d38173c9fa42034a5ab6a943930777b0d2b76f3ccf163ece0dacbe732773c19e4d51236d7686511402c69c1463ffd1db542b775e8e602e05d65ccbb796c8b17a9f533b5350e252de6a011b1ccff3f4fffac0d7668f5395e8e8f0fda19f4ef91b448157fd61c5f61633814851a4ac83cbb8ca85b163dc830e745147bcbe6a57f5ecb93fa8afe09dafd19b242cc7004a8f76618d8405f2a1f4587049afaa83546021a6e61651092c9ceb803e706071390558fe2b5c48bdfca537c69a4aba1eab2ffb02e634c3b74656b0cba185a3e54b135ff0e0d217d81c605f1abf28fa1c94370081dc0b84929514d7f43bd80e4584608b8268e158b4654ec21e86298c4ae7df3defa0478ca22860f0422b4d408efb9ae2532d2b6f5885e9be27466c71da825aaa3b2e8dd37aeddd322ca87b9427bdc4bbb9fd28d5b0ea179514eccb32e9795630d63082a7884c9edde680a6f042957b2ac45c78398423c937c13ff29d9b9ca494090c3f37a4ce71d9626b5698020d5293fa193e099f51d6e6a9d9823da074a2e8902648ccc94a197c9ccc552104557c4430f0d7e30701e8263a0d24639f8549488f29d0788d1280f4a7d4fc012b120c8963481b09ddc1d39f0b95d2c357b6ffb25055b5febca16952dfba5388eaf1c86ec1d3f606df10cca8762a6fd3cde0be33953bbfa1a7bc81b500140d512315853266c4e8c026a80ad059435523f07abf593d8554841cb09939502796d4e7e7ee11b44961da5ffd564e20281ab9378eb0a2635b4f88e6ec668e8ceba519acca6c60304fbb823e983d15c5020c291657973bfddc008bc4970371f34207c579e6e5db0ad19b06dc0828ca338d39d83c49df7a282e988cc2ac19fa21ef6517e0af4117f8275990a08decc3c249dd74519ba9d7bf4e9217597be5d152c140fddd794d18b9159d5b73a3fa874b84310665b30a5d50804f7fc6aa98bd5e2c83ffc7340d999b2e878eb8b40a82fa5ae8a8478994198b775f07e3b032da3ff911e4bca23bb9a4a167335b196387f13ee51bd815ca598ca9cadf3e13bdbf01634740f27e7040a189951b4363d9f72ce83f49484e3311ef607c5ed05da57abf0c250f98b094c740e6dc29369d818f9dff54b6aa7470608193861b667464455645fd04b659e1e605c0abd1ec6418ab2b5470a8d1df8b8833344d8216f9fd118c8f01d725860fbde7940c625ee18e45a60f6edc2e97e6c9e1f04dc8ea17ae1faed51b297105d7ad92bfd9931e52d3d8910c5d1e6993feeaa43bdb084b3e7ec89a06835b7d0b7054823adc54cec7db1dd203e7b790f3047a7d92af7fa359494f3215664be0d98835c8a4c43ab73b9370b1db65e6da64d2df780230840de302525a14be63da4f47ee71605178b148f15d072357c5b902b65237d164d2e852db6f4dd528565350f63c77f1ff8d9d2f3cc64b680de911ac23c907f99ae22626526540a86dc39100f82322725b11a8c0d9509f14760391a0dfc96298b721ff09e8aa20e8fe598333460570f0e38444d8b92bf84ed4ce33f1137483798d0c1653cdd72eb946c95f9287066ccc7129d86a5b3dd42c7b3ae4bfce71a63941430dcca2e700453becd6d2556648318b79dec029ecfb58b4bced66393adbfd6e66730f69252569ae329d6a7e1d565190685629529f6510b019824125b146c79ea4cd2336fb7f26cda2b33f5650c1b31dae613f2485d0efc8a3a49736644e55e51d4217b872864d3336dde56c9e26df02f74199055698eb336a9fbb76fc63fa3785a24aa5e05fc4b816faf8ee8eb1b4be39ab8e72fa4181266a86b86f57241bc1c1c12004f93aee5599b491e4f7c454834fa0e184e88a2465f45b4537d8bcd58ac953407ce9de0ed402184f579b4a18006afb73b41109d47515319c38073319a3eda0997c34326bb43ba4d180db43b749225243aeacdbc09e0350a66cbcc312e543dcb6dcc9eb1759430950d7ab6ca90a68589e8fa55b455225a47cef4c1f4856762865b5c5da728a4cd9d5af2562dc70709a70608a4e972b50f4924adff2170bae2d7ff002f63d688b5cd7c1bf8b919432439ffa21c5fc99ba4d5bc682997b83350aee8b3ab385ffb5b849a54dfd0cf1949a739b949163c44c00ef1e54c7d0e4ec048ec5f98caea49b2507a0de43937d77a61eaef58a57a7149b7e172493c5c429efe5d3d85fa7f379756286e812fdea9fcb734170a2927085e1d25dea2d92da3d85971f19bc19c19f7f54995a2228552204aa916a512865d0821c0fc532c77f36cd4eb5deca69d6df5ec33919cc0ca7f4626b4e6d4629ad198ca87763759203d8044eb4389ad077a0f9ab1cb95814bb8ce339024268c5dc66bd2ae91520aad7714dc05501aded9d2f964800752f00e4bec410956b8f55d67a44bdf88892cda246b2c497f26887e5d05e04e481d16f29264061450fe81625add770ba7700c708ca52debc753a1e4a73936eaecefaffe7d38647e4c046e09d2324c311778abaef1991ac571c7eb840c1aa7e0ac87eb98bec244fcaf15e38ef21c6c164c604c2260d54fb48b8f057a868da3b16058817a5dc80c71844a74f8a4a8d34ea6ba59434159377c7a025c025a70ec290dcc137b236e08bda788248f2b4c267e43427efbd2631cf153bac1aa7c365a2c019b6cb09d1b878e4e8344afc0c0540fe67446736cb2b7137b09cfa56a24055af67b37381cd8c494b47f321ea35a56d30ad00b2df286f68415594fe2afe34a8439c371b6c9e6d63e526d068585999475f27c1a680dbf92e6644fd52adf0f005436100acf6741fa795a140ac840bc796bd35b297911d0c81da5cfa4725a2946557e2591c944ba20f91f09b32ac7d31a879f4cdb5a34b40838c12b510d3335b60416cc9169c99b83ccd2b36a62b2e2237d2b4fed219189bcd40e7452f5b52870c0465ded77aa6c0f9f8e51a0fdd174565d91b4d3b108aec548e3d62d38760ba2b4f32a9f3bcbbcbcd0319d426bfa87fe4dbc9d5d384371939ac8e910d32c4874a9d5596e7276111c9ddbfc228a3e23159b0e0b038fe0c79ac02c7d6df47956a1613176da4660ab913af4aa31c6137bd41861b64bad497c254e1ab7fc87369392830c5061d32f35be4edf6db0e8ba220625d5ce3040bd2bd5b01a40978ba4b1ca9054769efd8307e2ef3fcb06dd0cf1d3b6ec8f9899ae59edb89ac02f4cd9d8b73165d0b893b6c16c2e6b625471fcc89041fc7b8d411ecd5a49176283c3374ec17b896bf765843eb8de1bf96ab792cde8074c1ac87b003b55f9d808f7c9091f94c296ff533f7b512e21a134e2d42e8a9ec61ef4c29f3f8933e85d6df965f4c0618473daddb3d442a4d513c9bb01c7c15a8c207203a5d52a526064e62e67a85923ceac887c6c45888c9d8d64b05180c870d79b5e937ebb6ad7b2c9b82b795185c1babc65feda55c29995807b1da526a96dc2d0c73609f8025fe759104d5c2e6f5d910769b98984114b091b18a47242884be6469491c682e817ba12f105e894400f69b1e227a583527d122231e7b11cda356edf944bab159f8f924a61989d7188f799925ff02049129ac364b373ee88e4b0d1900981207b5eecf4afd08f8002b8a192156444182de3f25dcd162a1543b1c6d395ba397b0194aa885cc027039100ad6c8b11a8df9a97a351f563d3ea2f86f7dcca1dbe1302f65646d83b61108bffa69a823276b7f76d02947449da7cff18e34ea3046d0929ccca1c49c52d88d397f94bc12b1c20b5029d813eba184280816470bf993f29f332a3666c638e36c5c59a10fdf897b2ee73ad6b8e9ac716977c0bbe2f84e8fe8368259c0fb0626c9aaf28e525b8c579f3636312c2886721670669077b3e29f0130c3738171e4aeaa29fa00452493bc27c08e023835fd721fed1fe57f1d0e3f601f0989f6e653a1b7b6758591c8144b10b83815901ff24cb9db98533b398d8c1317f7d09a9737a66a0c90191ab0fdcaec92a2ff0ef34857ee31038fa696452b17fa7d90942be3075b0ed590fecf5c093415c7c946339ee1e1503661c94cf2124a62fd7343c9e2ec0fabfa28a4bf893b74113a1c004d3151ff993ddbb3f1c051294e14f9d0e50037f6a7e8ce9d1541a3af16efb14943470edebecf43adceabdd80ffd05da3b122a5458680d4e4b3777b5a5c46d32d66d0cd699f4452614540c680a2ac0ccb9762177c7a31bd6b55211d7678244795cdf647f698f745b160d3b93afcbccb386493b5c88a2889920ab5be4f4ab5646182c005f6f19aeed2204a76f3c0273d22ea7b12ac026080e0f09e24a058d0a0cca944325c7867a0576ec3b8761c5c3c618ea9b4ccc2189d199538413d42f6b4230199f81b43c06f0a2298c36c21b0011727f43928784fa857a4f752bebb161255e817a294727554c3415ab2fe5b9a8aba2e42732aafbc9bf405fb8cc0dd6f413ca8ee78b2694af8795cdaf00fbc044488179c6f981bd2a25edc46d01625d5ad0ce5363255f83a48c0a3551b60d2322e9c3bff934279e913674ee3397bc161a9d2820eaed30e80b781577efb5764811ded4e1844ccca9670f8fe403a4d5705eb792ad197a28f21d0aab2c34c1da5ee4709a00a303a152f737845c929539e01c03373979853308d670db57ea216151eadf6949872ae081bd960688be0e00fc4fa2569339e411b66b17d29f9b90e19b16fcd1076da47c6f1b9bff833995f2f609cd16dafab68d440f034195d7964c7f8206be54e0410994361d19f0762ce029cf59282b7b4d08512ca321dc3b6a1ce8875cc9c1a6cab1272522cc5d142a095e663ca8da75e692f6cff083f8bef179b9c706ada0b7911dc8b2d6c1ed22437f10f8a12daf79e1685b7628a4f40c0b8a1322f2472cab3b0e7053e564c44401b2224ec015963ca432c243164a732fedca8d9eefdc857b70c939e3d1de0a2823361542f701ab2bbb6f912c3e795f823026b283c79e7844ca4abc0a4fe3393acfd3a467fc306734e8158f9d1d6418247c86fdd6ba93f141249090614edef269b194ba1d83fe07f90b0c88982736bbf99bb4b1a9aa4fd2862b56a34ea6c0f9de3cf48ac807222eb854ece4b475f6fa9d82da3144594920261c9dd0ff040656bf2493b458beed8371f43e76d23df5e505c7ef2fa32a1f16dfd3cd02cddfc69cb273de8e0d6da972695a434007a1d11bd6c2defa26e7e57983f2efa3903d73292e7f0f4ba864dc57d6bc53cad6df5f62d5b7cbcf42724e26f97eaf19536533ea41c28e9792928675613f45b5ddc5d4bf69ef5ea70e752aaf3e27d3a04d01538687fde057dec936a32d5d17387050c9764b170a2ae3c8e73ac56acd22c1c7b1b695b20c0c9809fe4e4798d10d92572f3397d3df01516fac64ca151645f72e909377f8b25252d7acf76e6709109eebe55c3dbc392ede2b155e0afd65c442091d17154c11978725372213d696c95d2d64167fed25075f384d36ed82052b60dd5b9b76b1b606aebd0633575d481bb4b0d1c245195f0b0b0b70baa64416221ff6d2d4ec81d295d322302e60c1bbbd0a7d2ea8c50f1d6d44c2c8993be873097bbbaf3ba88fbe85956825ea43f4930f94b7ee5b990f7f558ce61bdba04c6ef1cde18f264ad7d59a40c325f49dd063c2d12b19caeb5b463429a4547515385bed55498d5928e9e1fcdb89dc18aba2764a7c2bc8950163edd2053aa6c1ce09eb1fa088ed14c6638ea26558eafcf17d02454d61e44907e47f65583aee4af9d49c880897b481d453f64dfa0f719d0552c61ae65fef66793bb18ab205a5efd263eb80e9cf65a807bf148d3078689420dfed4067777aaf0913d9f50b909924b1695df3cddf42cf4156dbb8ac221cc239497c77a44cf2a14fca40c125cc622b59c0601ba1d7d943822e52847857d58527fe7af59470b6f2389add43c8d6bb68610e32300aa24df520002e14a13fddab8a030dc154850a3f338adc84ac840bcf0681c86baa3952670501e9f61e408b2d6941c2670bc7a22035beaaaa53839dcc538c742738eb1d0d4e9042d8ff6e2d46c2f48a54332da26b8dc5a2c3f686f4853a8a64e491868db7ea64dccedb7e5519c4440559d588f4efdd7ab0ddfbb3b874203ec24e416a2b8ff0bed6499605bcbf345f59669bfc409ea0a63222dbfb38e7e1060eb6146a3f34b011278d0e32cb84f098c3f15fe251d450b2b33b86d77d2978ceec00b15f767b14ad733f23a89685b08fc8a0d3e2b3251315069cc44d5526fbf12fbc2e7ddaead1d4688fc453e10eabf69aa4df539cc965d2dfa8c21ca391c2e927589cfa720b5809d2584b5b23f7c0746ff2fb14179aa216fbf7978b35750d4f41b4d1455753a16f1f1d51d2d1662221e98bd5502c8d5a8e36e20d70a5a2aeae30fd251d42bb98e2f5a6bb62fb4cd96e5e95776173db85225acaacd0052cb4b980fd8459f905f5c158bfadc119b77218eedcae510c79cebe8344f087ba33ee20db033657b78528131e651f285470d5c3b313098c588d120a202ebdad5fe339b42a57be4730ba11a7841b43518955cf7e05f1d71b052adb3185fbc0c8d4a71eae2b610af2bca29c1073fd3f5d624c5e36d9d7d93d2a4acea80e62a86bb5596f9bf0913ece93c7d004ce55285161c3d4c80444c5d422e49579b5fb1c9d6cf2ffab478f27482c5f4d9ce861284195bd385fc2b9f32cef922615248429d189a921c35197571d72dda9b3809f4e6ff299697e83fb5a16e4dcf5531890eb9f11e407876905a55933780794a314778bd6aeda2b6933d00d4e2934aa653e2872821b0d74d97004414ec5aa3fc2158ebd05e65df5966261571b178ad30fd811af07cfda5556a7b580658ff10efdd43c1aa493db07627c54ef50f13a03099dfe604015bafd5d15e6a5d0835fa2b67caf40af6915b3b4299253ee78f8d68d40728fd07b499bafee70649b7001c7c9dd1509581b41c82039327059a622ecb00a5f377e04bdf450c96ec3f41222c3e922a25c046a5c86c73c8d8774738e84acc25cbce95646b44b10f50444a9749034857993d62dd6fc216a002937787f6ace9344c4694339e36efc52a84bb5d92f4bc716042a9fc176f60b9d23a600810697210cd87e665ccfeb554c9ff841bfab98972c53adb2ccd95f5dc3aaddd00249b38293a53be29089221ef423b77bf3aeafba11209aa3f7dfac52406645a9d746b41924602dbf6102694a724f1be7d4e93d82aba4bcdd38195037c73b5d94e11769b31e88ce6201234af621d56215d5b07241207c027c258f762fd2c4c67c6351a75fd961a8528ad7508a600718497b1f22101eee786d9cf5ab7fa20a154c68d5267fedf1ca62bd14e61844821402e45f726c721fca2f8718f04bb7ccb5e21036e1bbd936352905659c3bcafe489560f72e77ce66efc5f3b16629a486964b6b691aa783b26a078efc20480f799a2a76f9b50dc556ce1cd87ebf3607a78d54aec036920fb2469abe0506cd0777d48aca8a31a1da45de0c72376b9c074438a5f757e34b12f01aaa0b876134c94be4c5cbef0ee68ac6138997d559bd6feb255f35b13266ded536e01dc59dc6a56e2d41c5f54616c03c26e7cdfe307d747cf64fd332d10ef6a461c83289eec1d6cf1d1416347d55cd3626b38d2807a9fe0edee423e66757cf1b51400234d70fdb892e17e22bc7a649ad14ebe90c369db13a05fc1ca3a2a0555bcac0b869cd40cdfe6a2c78295bc4af6ad38cbf334a051eefb5983b5756475c7930e760c7c45cb63acecca71ab4fa88db9961a64b9bcffcdae6f98325fcb902698b637f0e7f7162f8e0c1c87adf9d74ad9aa8223ba3be48e5d90d022f71faa914f8712436dcb0f8ea49a3cbb1602bdf695cbd50d7680d5e5d367293cf029316418312620b0976c358d607cd173f3afd50beaae2f41bfc283f5c118a225a3e5c1817e43ab45e50e95c6477fb0227d51e7ea6e679edcab2a75ea4f7bdd04067f7c52562b1583fe5734e2e1719bd28de7f684419450021b650cae02999441c1303126de5faf762ebcad844343d93e36e019069e1d719ed233611eddc730f77b4dabdab18dfbbb44261a6f5e1d256c7ae6a35332cb2a5b55a089a3f5f267b9b821f871fb0d34453e3e78b6993aaaad47813595cdcd3fd7bea86893c3c5c868ec9662291f4b732e08d6e3c0c5ab938d5a58cc6272bb264697c04c982c43c725cd74a6fd875a25d1ddd9dbbb3193e895b4ac6e13257a7f525f41c711785985c6ad24176856c3201d70ab14353f854710e0303b0471b65e85e6bc69f08ca7c12d870d794cfac000bf1a914351288314ec88d844237a7b8e7f8a07448f339e61a8d221913d3bc3080323265c422eef052f99855e2f1d2db94decf5fed79943abf5a690d598b2ec23c533a54aa661cc348813abebd10eb8602d9f0c2fb36cec80a836f5ec2e84012b3feba8160ba58042312eceee343644e8c7e661bd680f13e6cb0944725a9c98aa17474c69d43b2e24a403e807108689307212f9e08ceff9ce85eba5618c2be92758d904080264b80c7591f48a853fe830493dc4d488dd0bbeca59e44ab65f1ff2a9fc2a63eb20428e0556f5f9963be6e0e661226d9bfeb84b68e6b5d4947e2bb0b39e0b47b705058ce80d09cb6513fd0acdfdab4b09a54a7a501002cfe3947e199ce7ba2005ff4387281114b768b1c2ef1bfffc4b27f78743cd241bf44dd9c9c906b8bcbcfc47ac93739f7ce0add0533864806de3b9d144426104c8f7bc3bdc528efb6d2e17ae391f02c171ffc095f78b2835e0cf1d6593f5db5ec786d29c329039f262d709e5286080e895ce698ee006b9ef231d57980340b561cb97f05fbea801b04516eb9f7eafde6be0529050e41d4b39a8b563efecc5cf6a8b6686637e9b9d38bee3fb678e396ec89a40cf07ea0648e53fc4592cbd3378a2b9b50dc4b2c8274234d3b11c44eedd3bf91849a1988517662e3ee89521a57897d32feebb191697ef433d935cab439473386ea843adebb1884e3f305868fc8a740a7dc0f2aab0c66895b31c0c6cbf4ffddef5fb8e4c3de92f82dc909369d86396e5405e9a1253c915a09d1f04c2cb8ce430db1c47ad338083a9ae8e2b087ce567066f185428d50651f10c6bac9cdbde58bdb47248d62dc1d6ce287f7974ac1975e7ad54abe7ecd7ef799bcb3fa6702d7d10c199c13ec41d7ba95e8396e0f693701849976db3a9678ec62c6e543896c931a29a8d2829bed00692c3a8b9118df808414b5abf8215baf980fb61424ebb07772fda0323066c76a56702b63277395914f549e8634f5b7246a1e9682ab5e82fd3e74f01283beb85a4337a3c67826144c311a83811b04100d5677ab2ef1be290cd2713c3cae5ed339f8095dc4ef549e9a2831e903453f537a04541859618115021d46cb07a897bb0602d3c218987731bc2a62c430f919ed2cb8057a000db82232b14c5981dcc01e2eb1193db3470303736fa0f0101d48523e8eb1a7a4b9af87e64fcfabd31680617cd4c271be56280083ba01f7e1cf258cd36e474c43781ce21f604dcab4bf5787774d62f5cd4c1455137c36495f9ccc834f2f9e61c341c47da35614adefa500e4c630b640c79b150d1064e2d65509f29a37925d06c49dc09c9188ecb0aabb6abb44aba83de2b1659743918e7f4fb891e4cc532049395c89b3af5ab9bb40cd1ca477b92a16da47a33685210d601474b346d6bcdf0b2187a98fa87daae9da6da4b1461e61bd5e5870b081de3f9358611066c3d47c4a1828bd31f709edf63e6b3a0ca19d103937a8542ebbf167a2fde8d8177f1e34616706d670a464a47d6004e4bdc373412357d5763acd34128ff376f4fc73b3d562ce7600b0d42527239bbf713086da0277f0edead1249215d34b2627922478b2a8c6e61ba7f6ba3a154d5845b20da85acde752a1b58aea8b525807406c7ecb714ccd82b1c881ef4291e0d6ceada6099d09ccc4a067b0ccbaff3832d25c0bd43aa61ae3793b9290829c0189c0f85ec131adca54eee3b8ea32be0255900b91da7a4ee9d96940b68e181140108c3f53b573a577c05ae1a9d86a71b469f6ca67351e823a5ec4207161b4f0ce354d4e7535ae50d55de9e3d18fe7babdfba8296d79c5f36b8865df53182133add7b3de714d4a4648e8cc9bfe6a42c760311708fcf350cc5e6fc198adacf3848dde59c45944b960c912d580ad4e625f3a45c75a3fa993ac5f74f86428fcc8cdbfa8a59af5b977634d6ca48024cda55687efac7b0c2a5ea1f9523fe880944ab345f6dc3c6b7a3cb202fe3066ce6d698ad7da43135bc45a19e2ba4fa52b94225d73ab86c53d78ec29c9c510a5f7e14e964eeb0b0e581307be671fab1c8d4fa5122e08cdfe86afa3b5017cb4a5732d67c11c4fc87cb395d2edf9481711ef0ee8b12717b6c48715153c26d2577e165e085f0fd31480968d0235b8a9f80163143ae615c916fc4fd2d131fa143ddaac290f76ef2d09ef7c3eb573d75ee23138ba5227507afdcd8f8a793a9b548c353f1409de9e6fd6196aa5382920034f6aab874ff1b8835d136cc35343783e257952bbeca806a43f0f3cf1da5ccac9b88f6c517d747ce81d110f91c1102355c7354d2d817911d69b32a75cd4a94eeb64e686c7329cd1cdbe48ab6f412a9b32560eed1d401e75f849261d3d3758f9edcdc152ff3045029188c5bf6646ffe5ff76614f2d1d0f3fa2c91e36c5a5300bf234aa68c2d79fbafd816b1c5a1fe0af5e62a4c22366a45806cb4b90fb1a1c79ef44486d8edfb715f82d0143e779a8e37dc06ac5878a09829a226bdd4fc802cb8531690214d2c2d556b1d54e9424a37dbf7da899df29ccca80c066472e8981cc0c4bad67a5b6e4464aa154f00e8be1fac386a8253c643c261f9cd77fdf5b63e28f74ea8b0061624de2acf8d5c5ca57c4ec5878c69d0170dd9b18053ac87a28de762a1e89d15ba81334ccdcfc2e99a6386d9d235ec1f6aaeb644e99a36163608f453404e0f5dbf21afc8f0daf6a88e45cec353544f0991860ee15c23ec883669496ac0f9402607ada6480e02e452c3d1c01946e18955e624bdfbdaf1bb835fff2dec27b2463927978313a549223115643b662b3c0eec30fba0125754216f5b28b3e950ca6c42ee05785aa03ccd643d3471d0243875c757dc45cdca4d298fb9067837cb82a615c8961ad9e062b2efcb1ed619a56073114999ea979aa43339628c15bd5fe9796e0006d971713f7a4d8a92258efea723418e3f8b682c47f9c999a29a12a923b19f731b9465fa18680bffbc4aba0f5c70618c70e4e20a06b1a31e97249bd47706a6e36cdf3b878f4ee466d2a942feb7b42de38bbb2485b1d58855db8b7c004a4343732f32a45644791152984ad7d8a2de1b0e1264b3d9eb0159ec782b861afc06e96994e0d5959324333eb9fba97e08dc1520f8daca411f77bc22f247c34d2e47ab212ab239a968a231355de5ce919e16d2461cde5f0a65e076ecfa7956c9fd4bce959b9c3fd38730ff3d514c31afd578d4d875a3d66af62a4ca50a396484dc6070336ae657d3145869965cadd184f397c70596942a30a0d941ea46284db43c24df06993a8300278afc1de45a256115912695f90cc8ec0e2ce3c14a1874bd4aad7879104f186b53e0ef3238e779add6167bda9ca9b983b63e3fdc5957d33ee18923ea7aa2b0e3fcc4dbab6e82abdeedd9cc8c7be290abb309332a302d003c0eb690f8b7ca6835dc00a29dd8c1aff10cdfd0b0118b91d3518c2cc6a872797404b5bf61e6c88b32f815a00cf324d50d0de26057d7283149af9e3005c50f0141d6f355921545834a1a10b38c7e424892e5b7ec58c282649af2b84c5131926ed32df91808de5dbcbacfeffe6c069998da5976f0cf67085304f6bfe8b4a812d9b7cd33327c108badcf4e12a1735b211e9f98a911e4f45cbd18e168f8384e22e2f861ec59255ff15919efad99f5d9b6a544051d2d5ba1876486b4d7a95edeed0b1121e179925ce800e0fbbeade6370b2cb377be399fe2d77d103f5dbed6f4179e20a2005889ff73de0561d415d8920fda1304b945f80415609406bab6ec9ef3b332cf2582ea19e69da855065a28e823c662f334075f84932851931f63339c825c96ce7cefd642894c2875bc916c096e29fe3a8bf30f910d038ca341aeaa1e4611980b3fdf01bd4224e21cd6d7c0a8ed8df7c5dedee86142eb7dd2c688c2f22a186d4ca46351d6158e4f6eb15a36500b028ae30c1740ec88c2d4aa809695540294d9bd596d3a97a3b00fd3e10ac1b572994bf846cad076262fd52cd01fe02e5df975de4e376bb47772df5fef3b9ece6cbd9eba6e86d34225747a4a929bf2922f74ac2af860b5d2680025f2ed8f803d7e125833638b24a2462206f7d59a550b3f994600b56836e3f8b3d4052293d5f76e0ec086c2d5b702efb8407a2a0077e0a9444cc67307a891125c0a4b0251f5fdae330cd25c3bcd723503fe809e680eb251863ee57ac18221e1edaf0f84b42e9a824f0f53595c1144bffc88dcb9efbb7ba8fc1ccb59203405b0a7189b840588d835572f1df2c00ecc9fc4ffa1a8d1cacb544d17c48c445ca127999c4aa2927d6d733b4ca0ba8a65e87d5cc2e378e5995a5b531f724a7953fb1da3dcdcf6c3b82fff9a620308e78c41d2a7452e02ea8c5d8f1c1a43955717c86888aa1d346e3ac4109d60bee9bf4ba66bc57d8b4396430d16ed3f83ab5f914fbf13dd82902e6060c4882abbf925eb64648391ed63108826501fe4f276806050dae8d69d050324faa27308a152c4a1d9c5fc215cf0551c434034d1843b28d622e8c00298a2f669d42b8fd35c1840b09d6d828e1abe1ddbd5a9e08f0e8f7497e4b20e654c86261154ed070772699e2148cb53a0f06b3829f96edfa2ad69d036279ed7bf70dd6780002f7635808b8dcdf7d114e96eaa5ff8ac17827ceeec48cdfb82a2b9bcb8d1e24c9de73f66f2a4bd3ed95f63d59c086972a1ff46c13e432d39cf217769414619bc9f0dc0988d8943e7a6783fb524936ab4fd382014aa60dd2ba037c0a0a376ee9a0e6e3268e580bad08d6c5ff5856a61a897c017621eb6a32f2112171d7b7d3c886202fad378e50890a1c8edee97aedb3daf5d3eb0cb9388aaacf271bfe1b63172e452b256fdf318d5c748d81f6c113f9fcade777d0fda4b856022dcbdb2784bb6797574357605b624fdfeea556531c06ac7cf5cc84a728875acd7ce7a513eed2c9df162cb93248e2ffcb82b36cfb9e0f03bc0b3537dffe28889152b30cfef5d7fdcec2626aa71d54cc99f7f29b3539d46e01e32c882d619a4476c99c6dc108ece94b4b1034a095606058fb03bea869e61ab2b4daacc503f6323c180e6d3c9a52a094a09a48f28950d7e25f2572a65bcefd76fb0413d645ad146676f2405b0da5fa10d925f1fb4b72b6e0015a8a70fe3d01105","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
