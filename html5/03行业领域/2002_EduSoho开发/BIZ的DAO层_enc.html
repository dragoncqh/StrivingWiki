<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3c1654c759f2a0b4cdc6a8962432d0b9da4dc069b0ebe49cc3092f452df276d470d9a94f1d54fd55d3f7bb22de10fb7c3a1ec94b784939aad74d8a272c95e9166a541920fa0757b949f755b12c5e71cde6734f7747174dc8087dfba519517f30d39c1ac1fdc97386a83903ccf9b40d56c5dad3dbb14dd261c6302997a4bb82dbb9c9f6bbca5d5dca380e70f074b7b5dfad613ec7af2a57e324976f7aa045a91b32f4c80b697d63d80cba1244de4b5ce333f1d6c6081f5ba99fa4fb9b08ff087c6f04e23a672b6a413c335fb761d3fd6ffe693fce67116d5950f090b7de560c98caa115516684392df8f5a767fd1ea68b51b2aaca3842ba39d6f64012602da60a461343c3d6cb2dc14d9a9bdcc0523cdc44badef8286d73b67405ea92285993d8b7189d5209dde4ec7398efc4df678874809ee09168a181cbaf7dc87c0f93b99af566da2006bb4bb2c3262242bc8846dc381483f06b0dd4a20fbf0c8d9e275be93f3725d62de5edf383110a35706f7d3868d3530a9906073a037c4e2499959e953e420dbc2d4bc82762cf11f3aedb7ad7b148c38548f3b6c6d80d71aaedcccc9b9088a6b4478aa158e0cb5056687c0b771416b363f34db185505d8db9627d0b305d72c6d5284f1e7d2627e445a7f14ba07653ce139afd7fa4181af36349ddcb243092ac159e5ab18b2d6c2e72bde7f5315b3be1468588ced0ebb58ad018158d10022811a5023ec707528c64cbfe23e55abfbd613145b8983ce1023958cf38f8d6f0cf40cbd576b08f1e4601041c239ed82cf20c31da33ad2f3a1952edba0c196a24f88dd329af8c72fab0d2c4d61dda4174b1fe96c0085e71f6bb7a9427e9143d8b7758f0ce0643371ce88e057c76d62ff74d7bb5ae3e388962c0631c00d8f55a24cd56602e1bf1d7e5f568e961dea745f1d52e168be40be0c64d60b49cefb54534eebeacddc6a0ec003b57fcd197ccce51d1fa6c2b45a2b6d041702c3247ae814a80b33a0082edee59910d443064909b31bbc9a230627084fb8c3066d7e0cae60190c64a268fd66ea19a11a585d3577b640d43e597dc47fc889a5a7bac1704da321c2ba10b67b4997e0e94630bbc0b8141f88eac4f13912672b05ff28e7f67a9f24f981577b3afd587e8b0daae833d797b509299ca845c21658ebae48f3c438a2f37b2e340d2baf719159d786a7584609a7171b24e869cf0542ac8acc6887369f3e9c693121bc1260bb4e8c03d9c55ce0c35f0956c62243d16ff1506688e51c187ffaed8e14cf7835fbdedf27e3d3cd444629506d4df392644f95cd9a513388f5d1208aa030d393f20f3d04a3630aaf24508004ae6191a135aff5fadb0c696b0b679dff68bf183dc055c1ba8caa39c4841c386aea0d0a78903601c629e0ad9ca3fdbb20308b3f3b78fac2f5aa608aa3f9afa344a1b9bb961b5cdf98115fadc7d42b75730a7fceae699107b2a4da15533443460cde3f7280902a9d39a54078f8c35230224575d40139ca674f2744223e682646554ac8eae653c6f4291239d29ff9f979aa8c3ce6017fa3ca6280ef94395d871ae5a8f8da43781429ffc58f1ccda3505475cd9990fa090f8ab69b990e5865b3b3c598e268e6a26e9c7a64046b4885780cbc58190a0195534dace87f6be2e91d6686356387ffc069bfeea8c29d7ea2680408d98ade11b3636fdc5f6ea56f95c79e088391fe7904880cc6af9c9d4b11ceaef83eaa7312aeec831f635ac353a38b1c160a8237ddc3c0363c67ae5d1bda3d4baa3bb51339820f65468eb08bf2df9da6fb1799d7e2d475fcb30e1049e7f4b9ee70acbf1d0648af9b613317ec469361bf3a816d1e5af4ec60e0f1795f8ed82871aaba6b42779a5902cba6f80d6cae02e97a8cc47f2dd595a7d1ca1f1a3d25adaa30c910c95d406196c611f57f0d017bd78d9ca5894b435347c0df936ff1994758f43b38b963abb7f3edb2b1474f596b550754fbb66724075f112e0380d6637808e6fb90bd10261bb8e66a37044ba94588083b11922d169ae6e3c384b94ff8448ab1cb4c3e8a1a881fa1fb9f9a107b31eedc05d73df1b31b518c0fd52aa19c70e697203a2243b23833701c8fdde36787670ac7c2bfd15093d8ffec465c61d20dc0c58e67eb6b656b78dfb0358fa9d0ef14a4fcb72be435dea9bed53131a9edf66d4d084ccc6118e143c37ccf9832df3a0dbe442acd57d9e092440e4cf1cd2a286a55bd3bdd0d0f6c6530369a39297f2a18ba2cc0d8fd01ff983ae464705f992a44a56f7c28c3c740b7d800815fb2dfbb121626641a19375b421b35de841382225bf05834557682b5b8c368715b22ec9c40839c62ee75c60a4dfda6e7b925ef6ece27e7a5ca043016c44ba07aefc524033ad0871940f2cd65701f1bab3a7310bd98d10303043400e9a30010500ca6c6e594f37bca0c5bdd136050a6cf639f0bc36022b3c5d88e462f307d70c518e7ec12cebf7ab8e3bc63fdbcb55561cf902fc68f5f82563b4b881eccdc822f2d5fbc880355c912e8a4a0c63dd952e842c98ed816973f46550f27b85f424f661dc19355abeb67c9df622807f502d57bdbe5523030249a67647ca907c68e4cd2184fb3e4c1e7cabe3fd510b3553394fda30c3ca71cd8e37b43171ceef5e6fe93cff1289dde04d404aa2dfa97c93ae0d24043c0aae9bf8fee95ef80646059c1d3f1fd92b53b594e6caf7f35a2bb6acf13e7ae501c3b11607c293e0024c27a80c5963dc95a0e89a33bc485e6789241d73897867731a2b2a7d4a92734c5b3677bae689955393c00ce8f58193dcdd8e80123c5a7ea2a407a397bc74b0bd511d2d09375197e0383a0611951d0fc210b1a1137f920fa16cfa01c4a1c7cf003aa37dd5036c8f9e06ef04a5b780afdbc00dfebb4d00118c99d2f25bda53f4bc6d6e6ea60fb2749b456b5f30741c25f75bc9921344fff1956239d8ff76f9900aa300f9aae24c28f335f1b80df60a6cb57dfa1af9d2612bea4c0db5dfd9e14e3531a1bc1df8d6b3efa78d544311417860f6d32e636f9be729bed62ac5717c98f5d43c648cf09310be7c9f059599e2a4c284612b4a5dc7f2becf031b92cee0f9d630fa3b43fcf4c4fd8c5aade01ede3f6e70d525bfba5313887203f78e3e0897da70fa44e04fd1a76afbdc3c9582b6fd661a4d554a3f7267cdac902eb791ab899848ca285af76b12568eb2d8a96c4cee344537d38d92b870b0dcffed56638ab68152cd00d43bdd269a238b54d7fef8dc00e319bf84addcd94ff34a01570d1c23fa7b922c37bb71dcb91a466079dab51fbf8b451c67ca2fc1ef413999e7f4d23a8be74c9f546a8c5a7cba188f5f87a12eb458dacde05bd68ebffdf32a5f8b1ef3e62a866e184f0de20ad1979317cdfe0be9c77ff85e3fe953d09fcb051913ed52105fd59d69946fa0c1e7e117b185fb1d6030775c975684387b90954cc1ce5bc243413f76056b18a4e243f180a9efe73102616614375f8ff90f00a0c89367f38116189f90601eac622554c59dc074d0c95ec7e94c622bf7652aa7c4d93808c43c6023d4522536ea81037ca297133d47cfd8cf8d523dc0bf3ba1458492119638096405f43166c5357d08dbea4912228b1e91a334e459ab78e6707df4a307713fcd24a3137f807587ae8c77f767ba66ff24aef824391932f292120e07ea7984725658ed389341c1f5808dbcf17af1887f48c688e958c827746a9ebcf2f970efe129b755b0f4b4d83d5ac23ce401ff0bdc48fa36a609d7602c7be2640db78b267c96ef2f74f4bb8eb0b2ba6be234a5d3c79aa85595320b5e8119e9329670946fa1284dc3b2979992d8f2d4651d80b1bd4d3d3e481c8c33b09c05f9e5d1b304cd8608f99b885921295d26cbe4860ee373c311d3773cfbf193bb25091c7f97b1b78a8e1453bf147d992432674c955a2b896fd5a6eca0489b273dab8e59345f8e2cbd6c438744f559807561064c3be970490350c9bc658a203ea28b2f5499db6a80728997cb1328c197ace42701411c239f9edb66f2d0c4ad066d797ab13fe027dd2ebc6ac71e5d5a258ca1a9a6e569f7960562546e8045b5b2f4b48db554d99ce19570c5887016aaf062e8d5aa342b5b19727edb409e0988aabb13b2dbcf140c7922f366d40084ce962b51e7fbb19ff33a5bcf370993fe3a7421adad608f2c491ecee69a20e71a3aa06220e1f0995f50d8ec24ad732a608e2f3ea122d97a58c7468bf2159db6edb0626f3e0ce537bd092cdbeafa10f262d9d9b9e246ca1a64a2e4676738bd23d00396236b54db913ee2e8f572d6f8e2187633d5ad0e95e7444fe38134824dad9b7cb4b443fdaeeba7173b71422357b3dd2fddced3daded937d9c49451beedfa03860290877b7083564cecab1c854b79ef21b312b06217fca5beab7eddfe89ec2830c08dedc17ba36b0cec17dee892f2453a24fd586117656284f11a2fa368f9ff2972b8a821d965f54eddff0dab421c507ab3376f471e010299fd650db5afdbca703c072750913abe0947e01aab7a93eddd4509a0d89e459f2af6c14b2e4a0a697e06dd915b8869f6ae84e330a44c90cbdeffe7d5e338438d243e31d204c57d3b0c0d2780757abcea71290698131fcfc08cf70b7972f8f7a51866f5387a362080e804d9c63d6849144c014c22ed071f29589df4179471515e2b3687ba29b8013eb35dbcbeb9b62e764be11c51557ac320847244aded40c33f48d45ed191e040d199dd10645e7af38618425db5ca385596c98297b78bdb9353f705b56deabb0c13d264ba4d0dbdf2fad0e92fe52a1d5dd69766b0d912064a7f7ba776132998bba2aa0d4f40834a336e1b6c06d989807cb7932b1e45064c47b1c6d46927e2d6b1d75b0d02c07358e2650e36bc99092bd897fd316ee1ff494fc2c55bb543b15f9a314374e1a4b37af0289074e37573fac60765ffa57a33be106a320f343a746ad2fa4f5b20d7d50da79c79b14095597e63719d38f532c70c1e541e628dd3f4ffa94ec152db982c827ec87a5f0f55666d4b53aada42ac95e261f77e13466a80054f54d00ced6b422a5173aacd5f3d1247f041f928b31279a3809e31284dd318b7127ab04ce138a19e01dd058d448dcc148a82165e035cc78ce66451f292c3606900c2e381f97bb2ce01c003f1b2c17694f038bf3161e3c27e54d796b8ed5e7437ef5867f36a4acb640b0c10f37c60928986e3b1129cfbd08184f255ee618988b692053b8b843cbff38d02e3577a2408775665395c4a242597e4e8757bc1568b7e3343833d4f23595f405c93cce6b4068cd0dc372bcec70a216d2735e96af4f8f3185c229f2650efcb1e8de796d01f70635bf3f70bc8e1f492d03975ecf9e6c6251e05f82fb3b334458351995562b4888850d4551024e8343bfd6bd224ffc9dc22a48700dc347617ef607cfa352e623b96d023bc01ead67fdfa95cb42fcbfa30db7fe4bd22180b3bdb357ee70a48404c8e3421014f19c4c7afcbdcb813faa02fbe1da8f41f376ea0c93c682a3426efe504491318072366f9796d6177768065f08e0e6d4c61a01a2f8c9e2e8fe0d274168c7ff2de7233b6f363855944648cecbbcd07b1676f69f3b756cb60ee216868a6b318c9a3ce727cf14a0385bd57d923ba844235d35826aa620f542d26cd3c617d227b2763ed57331ff4df6af654a0383fbde10706e109a6d05508db98b4dbc5c00fb317e9d4da0bb285d495a2d3c16037084d6aa33145792f2669ede65dd8387985d6b7ec368609277489086c97360e19148f660683d21099f8e6bd0c7aa3512bdfd2e031d8fb110e2936bec17e7d5d12428ccf57e6d80c5579f2ee11becd2f2f83e2c59619600064c3b508630aaadb8b59d00e3817769ac79bc644352ef74ef1870d124e527ba1319a33fe20c86b0324e402f6a22fe46352ac942bedeb5046984165fe4f7e1bf9381ab23a0f934db95b17d2bbb04bd4398e4aa95eb7b5a4f90ce320c7f823d99153c8bd7b84410603d037df5cc36b05a209920c10e3c5c7e8468c675c0f23b4d9e5aba737064aa15925227b6afc057142233bb664029f454cad0fb715a643626e9c633679cf7f4307b2e8e07469a89186a6f489b31e10a0bc80fcd8c9cde4bf2270e787d3b9bbc494866cafc45d6199e5c371d100fc7153e13242ea04b5298951c971199428ab4d6a1508fd00e30bfe0b6386f833c2960ba61708e58edc453d2b45e010001a159940312612590cb16aa1b536fce738e37d58e73d7a2a028f8953a189a10f4937f890f5e9390d607afd99cc72fdde18a504870110ea718443706523a658d34a129bbd295c9a0c152a5b09c04f13572ae21b5c803d3a0421889ec0bea68ed84bc7b06de527ce4299055ae33ab0188e7131a4ef8bb262b77c8ddd598ac3ea20cecb19a6229ff81c5d2dcf151b9bf5354b8016c2fb04d1fa1474e799a0abbbcfd744e62545496f80c6d69dd5322def4557998fdc35d0ab699d313d173c3ac5c785657a48dab38df600d01d534a7bad702779c26c4eae3ea5b0bdb704172d4babda1185d3166bab90e6f065ced01cdaa6237748bf4f19836614b627ab9e317405fc3828a4c922f13f92c1c7d68aed6509ea28b2ada090a050bbe26fdcfa810285e70eb822c35104397f58cde49b8dd320620b9593a7fa2df8c5a8af9eb67692d5dee0a85aa85a1f499ffb171259cbe40a8dee723c7958bd9ebf86658ad181e78956549e924fa155448130a078d0a98912045688be8f6bc9b0da4c7f22068381524ce429f74c69accbfee6b3ed97de363b466c5f1733fe5a2729ed06ad8acb778819b0e883d79575db1d67de46ed47156a808dd06aed1ecf05eb44dd302801aafb746c8c98cdd80ac731aadb6d10831ec40955583c3602d2b6dfe24efab100b8f91adb2d172571f228954e26e14ed525699427bb7a20c05643c2e9c1edd8f0ab2cd609fd9adf7787b7ce9b0f1b3b0fa4bf039a1cbfcfe242118e0ee655e6b1beb800958273898dabc309e30ab0dd6098a78c03f3c5bb2a0b5d8340e411780ce17ffd4663c316f854b07499e8b54e8a22c751afdd94d5ede6d38d79855caf4c53389e2f9d1a7209dcf73db4fd376a03de7320bd71d20fe7780c5f2a1155666867319e58ff68e893252be597cb2511cafc4001c4b9cd2028f521c2c4f6c59fdae1eab032f97f54f4b2deb8a52ad9cd93ee28d36fda74b1c2742d600afe0b16ab4842f5ef30d77c0d290440898f419bbc19e9ba401c93ec7ee4c59fe0f99091874858f9c7e69c2bd08268b1905d8ed53f368b6f44e0f4f96d2308bba8e5bf0316f6449a1d2aa6de321f2669de571d0c98e67f8100f03eec0674e233df0072439154b0178959cff51db78a6fb873003817c5bfd59f3cc914bb1d6c3e5013c895f0a197fa269123de8d2dcaaea45736897286531a130d047a52463cfd42e92a51275d5a9da5042e8d8ea0fd076a61fc02cd703b9fc0704b369051d3fa80c766c3ee87062573a48053b6c6a2d04c54266ba5b681066467e815614a527b32439e9544c4ed749003a3ad70047145d56307224bcb8b8f968babe821d8d1a37b79cf0965a874f4e215b25da3098ed97dd32c2005a41c2f26c619366b270cb27758d9f83269d22796e5a6edfea323c4328d91bd87bed780408e0eae5834855c36da47b7e2f1bc3a0c65e110269731510877ca8caf6271e0698329610b74348b470aa868f61f54b9990cb88c14ab6d51da4c21d0727e02030e7fe068281fe9600347f49c6c50511af0130a3ee92a587bbc24d22cbeebc487643cc10a94a567ef35a170155979ae748004e6ece96880f4be2a50e42877927608c16ef4d6a7a905c4262a9c3d24549c76922d9982a7adcfc47b674de20a6204ab718bd9b0f1860b65d7d89c6c0ed43802a8e76b170730340f511f5ae6c4e10a4fa12c7a1cde83703ca44d283eab4629dbcd8381ecc7e3cb8db532b0c248f4f08958a8a9e4b7c4025fc62d28bb43c22205e250127c61a34cb733d16019356e20cb29161938a3bdc1c3c2a2cae23692a879179141d56d28cd9d688f27ae6fcdd9848090ad2dc34bfb1447e7dfede3ce4974192345d7e34c50945869f53894007edf45312864eff59292676b3031f9abde96c7d869bc3e9adf61990b3135229b2166c633b14ec4ae14e680ea9c3eca7cf68da19db3fd8698a1f6bde7fb5d496c60993bfdbbdab5911a80ace8106906fca0b465548370472dd3fba090ca528010ba063efd85b0ae920a33bb1c94e3e2539a4e266c269fb0e18dab0d769f5aba6c66f40628b7aafc9b726d486a74d51c22977093393ad5c922786af28b50ba63ae00be7b273faf2b8c520b778d0d986851e3718cf930be77221b617a367c3a8304fc2f13ca47be17d3b51dfdf099facf735071adb3a316a64c02d4f407df5422a669d7f11d288898f1676b75c12c5c55fd75e828ce1f7379b40f7186a100d8c5cc7fca552fa6419ecf1d12014c24d1f03ae73a102add8c584cba99f28a05d6cf09826b4e73930ad2546e5788661e7d15a61288be908a18ccecfbacfd0ea50043834651ec7e42b97dd9ad9bc999e4078da96a2831a987dba74fef16e9b2abf2f3ab912ac8397a35afed00cd9c8f75d6cf8ff4ba9194f60ecd16e930c377e2e8e35c01e46a3610499d93b84302b883706f8eb2c96bb4efe826e5cd506fa3cb85d0ba663581921ee1987762134b2344df29c006263d136ac3708faf19dcfe648993ae6677551f83d98b432257b1e3b2fda095a68f2f17aea2fe2ad33d2d2d0a38a6ee028e9d9a69994c7ae1297c409ea6c1953af42e5ceb964af866ccb9683ee0b88f6cce6b15deca3c59b914e25ef103572c8bf0a052b82c1d5f7c35f09c01e16aee65ceb6bc4cf258832634212a20d864e5f1f9a64a2c132d2326948e52cfaeed186813ba5419c5436a392d36adea888573fea448979afb409fe5597c0f5e7d977e950b0ed39f1fff265067c4eadcfa93feb42b156b5e34907b63ef7f5fe7f90a516d5a2919c49bf35dc5ce2ef7876c8baf90e7ae9f88f36b8c47471026bd4b100c3cd2eec8e875bcb97f8215e3ac53f04f04ef09e1b9814ff713ac3c8a346decb0067d6204657e028aa13b7d1ba098e1c3cd8ff17197427899a51bb4149d387bd2c1b6227590eeb39a4ca48f01c03c6bcf7ac762b47aa5100b2f10ee407f668ddb4224f8fc3708ce19f821f33940c3842cb62e96dd4c996431a244c2ff60c7ffadf25f1a3cbd2710f9884acc601b8840e5c2ba6c4da99393660ee95aceb973279f6f2f5c747a0578a4b00864ff6dec0da763cbca42e75506bdae659d4388c4e44b87549a83dafc5850bcc8e0538039cea64975cf9d5a63cbc22ef01951220e40bcecbfcf0ce5f87ea3d8f1ec9dd56c12e4a93ff5015ea16d4514ad3805bd8828365c8c2374a8ae70094aa8a62ee086aa22e23ed6adc0bef2759ec37e6e519d32a8233c30651a48aa4dd95963586039d9385e68e1011fc63dff644900d862276f7cce9ddcab41b63ab8b461bdcbe32f0863ca82bdbc95b0596084b53e3cb642059e3155e84889d98ee0f49b07b1a9775eb7c46725c0cd822341c83a6f6f1d5baa226ae07e5c6408b1451d95eb441fba4f27aec162327853cd833e4ce8a118dcdf6271d5191b00d1665a5e57aaf8e27b32d2bf84771dc7f712a8e393e1bad88a92a3329ad0e229c65979d06ef8df0543df7aca0d531fc06ab98e4638c1f95bf6ffb360153c2fafe414fe0a466d0756011eeced40c179af12382696c1df1a0f8982d127378b395f7491b45e287ea97949ca53dfaa784c11b78b6e732dcf2d436cc1d2e9ccb5d888c06a9a463d4d9b00469953e09c00845beb5b04b4c55cd5d74c3a5926a708749d32cae9a10fd068474a1f1e75919a7f22105b35c68a3ab97fd0540b1aaa808e4a90d09e48ab19b7945b55c636237b7b7e41ebccdf1de0319261341a81272bb38290e52c3c53edfa4a590dcf9668b170302c369bab9dc6d66a2cdb40fac08ddc83fd5f855a1220f43f350c4c234a48ef1c876f522570742aa3f1c3dd598c9da65508bda6b396d844ec057a70d8383535bed964cfb0856fd143ab309b9c5b16758fef41c23173c06ce74e48d4fc1d6e83aa1546d57c1131bbcf500b0c6217abe74f4c3dbc62235aaaed1978b388bb5e3d95b166c3dce774a694ae0e77e9079f045af0b3eb0a785d3a1f82421d01f26693e14370eededfea218ac2bf9ad6078fd24e6a449d92e41e6cb1bc7321ecffa5ee88e0ff0427f4f7bf1873ab66b0a2182938464fe1442a48dfaa48c8eb74e6e184589d592c6b7ba49deff42d8847b64db7d8e7e3f8e951ec1130db76c5c2ed7df594432423aa0c9086fbe1d955a753ed9eb91c35eee1062221118d4161b645b23327b545785465052cee53831ef208f1af03e00f056cbc2d743fac133a58a0c71930dac29199f83723eb259c0146e1e8ad4807d9b2f5f857aa8bb2076ad6510c0ea05a22b3c4c8713aa3dd9ed9beda8ba3a8c3cb5d6471d23e29b50533b86df1e7a5155f67e8bacfb6743d148360a4d877de4764bdc28e1a915e8969f96c0779aa0c062728134e0d4bf82581e527ef8fdac2e9b9200b40c0544069d3c5b7afdc05d39797e5a22aee24c285235204e96446e77185b0aa5f025d05663da500affe5c7e25bbfc117f341103768b48f3c42ed4d1ccd48b2da48d8628f8118cb61e664b3c089d73e179a4b557466ca1407ab9dd9f00d8f67566a81ae2d5391074f76dbb4672d26bbf6b43ef44fd410b10ef74620727bc8d2ba46edb5804f277dc0079c87cc55604aa3047d3c921d83c9a9a61897687bf67f5a85f2b210a944a2d0168049ff92f644f6d667fe0a5954b8ed67bdc862c893d9eb22310bfdde96ae1b706942235b6d72e324440ce115cfcf01c4097f060abc78d30189f8fa100333d5fdd04df284b03284dd74107385aedb5ec2458e19a0a12cf33f7ba222d4a4ffd2fba8fb4bb35cb38c3dd292670c2b5a1abd0865b5d77cbbe23cf15458d2cfe76e0d64dc2eb7f8dbe33054465e8f8dff939b724191a8c583f292fffefe8ee3c04acc99e6d37b99a0e8fa65a9e0d514816a2527db32ac5d97b829891a1220fe895243839b28d696bb8ac0c044f2bcbdc8ddc7a9a083cdbafe8244d93d7bff414d61451b20171d6aa6a5e18a6088e0285347500b3ba320325f17522d3c64aa636b02652c94944e32a1bed20128cb4cb4f8f7dca09fd9494defe0841b84bef77a7ae41e0a47b002289f22658c0bf73427921a9a8686371b503e9ab434c493917a5bd36004349012cabf5c619123284b6fa3a37a970225faa20f8ec62f8122cbea97a80fc312c0a877108247cecb19bd17c21a63d51136cb734f3acc1e2feab831dcb17177e17807ce539d4fe3b0544b70c1217d7c504b25cc0d4df62840b5893ccefdc14a6ed4dc08863a8104a0d25e26c344fb18f2678458ee20780c7aacc5417cf7fa1a7502ccec285e288702dee8fafdba78ea2ea7b175f67ad9746e5de76f28100780172d0a0ab297b58dd9759543e73b1edfda02a9dc8c9cc373bd71388f5d1594c007f955ad438d34744a0d020082cb46c6aa0a70c738ad15b950bcd3449cd0d4360627ea607f97330fcc660d7f8471ed285e7176728034d7c52c87f3e0cfddd80ae64bb726f60757356f4debf34c6b89471e21123b55fe7f7756358bc3970eefa6cb6b379582186907105cfaa79de88a9c602daf404bfb69954763d936e60c91ba20ec8af414bf267ec763e75e4173770f4e92c041b5665da66d782504852c86276dbb8e7aa494c6ca2355c514caa0dea6401485ca857dd2401771d08da44f85b28eb88ab3481ff08a75b9a596d1f1643f539fad676bfe697545627289aadcbccf5512f85300d3d257267d3c0b43e274e080b628a32e9d81feb7a1d22d26bbff76249aa929a65600fe87516c85b58f4541b162577321b0da9f951c5ffcdb60934f2394a16902fd4a3df2e06e9aad51dcfe4abaa3839c840fece7d9fbe67b16d377c2f03db3a185aca6cd15b254f0b9fe5e5e5bfa596cd1b863fc4ec40f743d30622270d3392adede3f5002d63aca2f3aa2b465527a8a1c4e21334d37a6476c37183f439fcefc1b924740bbe5aa3c5127902214678818c04b5fb3e36da300ea0c9667f664b6b2692727b988dba4b372b7811da5c023f764a1f714179e8c59b8c6b1f00dc9a11d85b09e95eb5af156d8bf74e7c448f3810bb39ba7c8065641cbb029203a5dabfb5e53df69c60eda249c7a2e82ea341feb22e84931f5fbce7166670e348af35a758da9861ec24924ecc197c56a3ec3288f622005a332b43bc6a7056ef9461b3f1222c229cb04a5e24f2e6436cbfe9a5c93e80b3eccfb3da28cad6bf9c7a577d79a8cc9821461ea3937b1622bb6a94dcd0e9b963e24c3223119ee4604163e73645be95b714e8d7737bc047a9d9e98ed5039e7bb51661547995a0aefbf6629962ee1d090ff13e1f370ae404a116cc6cfbaea122d820981093b2f332ebe88a9198334f16f69429bbce41535db3c1daaa3eb57a629bd1060e596a882b837eee0a530bde156db1441b51eeb544b3e568655175b0ac17c14f8b03797c2ba91d463d9911295fa0b72f0de0bce3840830abe1b72dc8e6afa7065046045d2d1e3cf064d37f0f14b3566f6151ecb894b522d0720a9957d9b5e63881894e5d4b3a0f6f2f6b1cadb1aa4110163ad3287726de93ad1c1c7161be3d08f7421cc1f84a395ef0f9095424998a505faaa5fe95c1ee532121d6dddbf99a7e49d18ff6c892f1412e0875240613b29bc651c218023a2e4d1990d4d0f0a4907c88580bc68bb02164d6cc62377bd5d95bf5d94cfc37a57821c7b29a22dca280a22d28abf7ff879b3fe24774085f9be69cf1c3089997817f972452279cfe4415109539066ec859d721ee9b548758bb506e455072ef4581f23accd5f34090c7929db62970e5fd1c2967276c7f1e2f0aed09499798e68d13e00fa85fff6ae6be99ccc4d7acfc134b320fa3070a78b3a8118567bf065b34a3aea14822676ed087d4c85dc314349f96dbe3968322723ca5f0975ee4e815bfbc537b8602ff5fec9de7667af947d9a11c8b69781a96de98bd1424c08d14bcfc3b853e22d49bc486775deab06e635364f22ea691c91dc134510eff35ac85f711836a433bae4c28e08685664faf149d46c413ead53558d3a072b46f50732bfdbeebf87a2afee33e1cbe2052d45d05af5d9e672e7393156ba7289687715ecfcae568e10abb489f13f92f7c5f911a28539ab52d8542368821fd17aa50830460ea6261b71e5190b687b61deeff532c21f90f08a05106799063f3961fabcf82e1486237271aa3e392053213331639101c26e9cc1014519bbdc1537f5412a9ce3b68f81f01daec2883079f396ba143248254f32b4edf20589b556ad29bbda947a07ab42aadd9798717d6a1b302bb8c3843f110bd527cacca70a531689eae4a966d7f63e2a7fa4b5fbf1329cc5493245a09f0ceabd81378b6545f6deea5a8fb845192269845fa4fa53e95e28a59f43fde248d98fd513ed82f49987976067b5c076ef76b1b190cd02d78b5b95a93c2a7d238a2f72bf39f5ac3178991901d14bd507368360ac95659e1fec6fe90237b1352c3426c6c930087e68d457ac62ef4e45e356495e04c58ca644636468d35868a1caf381239a9a9bdd8639925c67dfee2296f66d44463cea6c4ebe8d1d62a8294d2fe82efff089d67763ff189fa77bc9a3a31e2cb2ac9284be5a0e4b16e037a17b132dd2e2690e23e3c6121aca890fab1d70cf74826cc0897fc86d97586da62bf9cefe8f350620f9c4ee6d314f42f8124699933a52768125ef67e5aec4774c24f1d669f0541ca0de9c2e432d4e5f7ee6b283158840964089bca5e60e1250bc594491fcb1b88d87386176ca1fd803adbe98671881f958c0f18677b423f5b2b4ffc96eabf394e337f7085e7778a2c401e57c11f7b505e24a4a92d37b1dd8ca2212a3532fad4b11a164cf44bea3eca05f4d7b89dca8b28a9c612a9935e6117fcfdb66086fdd29bf9bf30d2c1b2653d11d9204a52816c9a6d9393d5193a82590548afc6a400142527bb086e149f77fc4d20708ef556a4d27fba1a50286b45ff870682b841704275df64f1616e058fd51c147842f501a833a23073383e48c368bc3bd59f9e6d224d0931955ced6a34c0aa5a308094f930265d5b393361cd5f1ef147f0128a319c57bec4e2ed9e3c2f3c0385e9b122494a522c62f9c3e3c7ac9e9e5c7eea274659878df16d7a47cf9db04a321415e24b26a695b3d5876fef6b163dffd1881bf3f3d1b134cf85cb2b661f62c7f8100cc9119d2dfd09fe905fce4510a2ddb5a45a1d180f2921a74a781cab02338921185803f198cece0bdb6c78d3fe448f58702d6c7e62da504b35f96599a8c2614c08766a5c42e47676784e1ba90372f75d3e4f6d84cba33dcf9989d0edc0bdd2dbe628d8e00de45c9b95c0690e759b37238c6d1aa3a6f5db6b9751785f4d24fbd724e665f479886afb112c717a0c863a0f840ac8e4de5bf99e29dc898078b78cda58e7e7a6f1c865f746cb63ae2ff3fc461a2a4bad32c1bbd0dd3dff9a7c90af1eebca9693cc28564fbe0dd741f783e85253bfeeb70a509b32977db6378b40bb82c55568872fa1360954190200850dd5416758e321c99317fd3de8162c774e307e1e2bf24a1baf8f4bd8b3bd8388562470dc21350d76f207c0e16c095c24a22ca94629c0b04d05fb2d48e812f7b0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
