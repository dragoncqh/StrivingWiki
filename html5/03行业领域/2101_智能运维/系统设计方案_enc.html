<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"59e698243ef83078846f4180078f4d70a013a7ad2ae0934b378bb55dd19f50c8a355671990d45015b5600a7c68dd448f3800028f9e161978b343e4b2fd5d9bad3ab8eaacdc7576f8642eba0131929fbfdf925d325616cc252e712d04867f7b4c4a39c0a0e9e4704110d9a3f4505c56e39b0a42a61f044b7e365465659146ce50a84c9236cb8d69a5da24237d963032dd8455ad76c40332880888e07323ec03cd7bc3a7435c2b23a49409ed097df8992ecb1374672f700df17bff75b29f501c42f8d5d9fe9622306cb3fb50efa82b27065002c4a9adcc562814f098fcb8c9f6a2b521c19d567ed0174ff39c2902a45190b8edc37f90f4fd79fdee6ce9f04276904570bf11c70918021af6f7451c6078a4fa1a4f6a8057076c63efe56a11e0d5dcd816f262694a07dacc556a7096f9a8ac561c8bc2b70d528bc8b36d321bb9d475251d5e3760c55737d0cbe526fded43f35eee9f54a437413a54bc1fdfbe6b7f220d2b24d48c144c4710817fc9f7cbd5ebc7dc1d72179bfe2ac8cbde6d84dbc4a719ed89ec236c6e71df9ae98e35e4ba39f3f8bd155af47e88ea2c9805f9fb653b900a6fe73d0c9da23a885b48e7e42c4edf64f99d79ba4824d18653c1b44c5d3b42e39d9fcea2a8fdefefa9ac7098793f8635c4bd2dbf3362775ffe336adf77dd117abed99d9a236cd4885efe730a3c30050be376ef791e2c586b9b15a78332dede679fce3f2fd15361f9e8b3f55a3a8a9dd1d19e63325ec8fc0f94e3e3a4cbf280010e04da7cc1c38c146205c4cacfb1df474d45604b6b4ee59c4be081b444299306e241e0a0fb6666567dba4ce6f1c9d8072d11c4c07888ad5a2b00f11a67adef5cc48b0fd9df31a92f3351dd834ceb71918722912ee937bd7985c644fb8e09b9fe8c142703cf32951ccae076c4bd8f75df75e90ce4a02a19ff544ed4e14eff202adb92e2cfe5d5e3087f4b050b78db666001ce2f085bda7337de7a91b8843fa30090e37755952632edb45d6683b2ed23be0291687c4b873b947b73878c6592bfbd1e73ed6411ceb285281ad36d064f0b4caa02b42f4b7077b8ec4b801762d742166e2ccb9e32cd45049a485294a42e98424d323c3e12e3e372ff79f54cc77d72dd6f02b7e9d6544aa053bc10a7fc52c08ef9c10ccd2eff153708b772b1407d5a8f57a1c41fd1247d1fbcf8f14d0ccfb865cbd25c7c13483fc7f57fdcb39eab6e38b960e621746f2598234edfa9717fa160d5d7b9df42c29f0d86e32c2b872ee75f0213e864c0e0050763efb09ccfff64985791dfc8f79a7980f99d753338e0d92d79455712ca0c1cd8eb8a39a7d48ddd09da152218e1c6a817c1ae8213ff4029f3996617afa5d5a2137b232483c789eeb789d69f00233db79dfd8a39c4f97f945726494a7578ff3de911bb4d1e5b8c777cfb14d59244bde6d827b563fe9973b2a8eab14238093254049fd4b336d255ec333bb307a80370bbdcd2f70e9e9a346c87e0c3188db6137ba6df693ec786f2250b3ab1efe0464091b43c39a82ae3b9d396c7dcb99aeeab2d98e71c2180f10de985f1e0603222b0ab75d0769815f6568f78304439ece24b9351c8c6660067f68e07bc043575dd037b34a23e89cdcfb7be4a3faf79f4069ccaf05ab324c6e8ab68c3c5965ff7ba0f350208ef304454b02098b99ce2c77c0b530d6b3204d94d6922b79ef8bd5d94e07565af0b70ed26939bebab72bddf88cd287398fe9c259b5bd720de3e955a6d90cefbe37d3d962346b35426b4961127095d373251889f4000eb81e6aef7833b2712682e03b412e3e9c49277f7b944992597309f8e0cedb0dad650ea26927a33bd8081fa7ab71fecf43ebb9be3b606665de2d43c4b6521d916709b9cd7191538dbd18c91157ff5269441ab503360be32318a438e44320ee55fb7531f9042341b2ed2e6d63f4de8d3b1355fa84cacb1f91c2c0bb04f40ab75df1545cf7d62b85d95d06c21bbb7ca22c8232a95ca6941d69444fcaed8076e5ca02e6f1e53cabb114ad83d9c7ba08d1f30b4fa513cae5f84d3f6d334cd9a2eec46cdc6d84d60cae7808665709b442ac2f5a68396d44dfee85ca3541308a9f2a1c538926d574e6f1d6b2dccc550dfe441a74a8239bf571ec23b02e1f8c0d66b40924bca93abe27ba5a2a732f0deb50f80bdd6a5282ec1293dffb308d62819ee53e01ab82334b8974e7294fb96a20a1a992e9aa3edaa57190457a135a4650abcef7992c2efd2bd1e671f3bfcdcfcf67ee05718cfcf1997f13a6454156070b7f5f0b9ea2d804fb344895b3cc25b1a8d95c7d8ee4bb337664f02a8eef0e2ee8c71d271d3edb6f8360ae0b38b138a333fe59f6219004e918bdd6765734cf9e809b32716047ec383b8d19520995a109250156e1201fb96d86903901e8364acf09a2cd399d2b24903e94149eb73aee151de8fa3a5873be5122ecc6695e8a30687e5baacb99449d34f1ed2e5afbfced0aeaa2ae76d9e7b6079dc150f2e4cdc71047e6af1cfab21e5ef353da2ac7e6d91f851625d870e38fc2524bf8cc4f2b6d24603da547220861b1c37a9e78bd6c3dc80392b453cc05fddbef4727b39b53109922c585dacb607fa6da0954040bade6773528b5c18575d22e03d1c523a92ad2bd1d13e3f5fce9b86b6e4afe49329bcf0d633dbd528b2f0712dc0caee50d7c364a054b122bbb3c92a87f7a401c7bbc91bfce32bbd3749063f31a0c7a253a57eb604ce84fba50814922eec7f3c036a351b6cb63a7b899ff9ed8da1deee825cd7dc934aa2c0c66d475175ac96190104a7ff04b347f5c88b57ffff5477b829cbbc0b03d5c2fb8e9f873da07a248e46bf8736cce0a20e061bf79f32d1dae2674bd6a08e9daf39027e3b33473c735a43079f7aa7f9ff9ba3da5d56203b98e3b8f5d543c6a38406c51dd18a60f5c40787e30db3c28e928a2f80c25aa8322e44271cee8f20ba84009882a0c1ae5a57444bc5374da4b2a265ea46e05ad62360e884ceaad89d40c3d2f325954aecc9021521a124fd75bbf7a559f80bb87598d8a5332962516d865a4b47b988392557a8e108a7a8ab22fce89978463ec0c3208f7824865e5499ee7a25322ecd83d5fbc94258547a0c841a652e67144ee76db5136440200fef4a0c656853859dbc19ab6c0fb601184122ca042fba00cfbd1db60a78b97b507bc82f964ccd74d00ff9ecd4fe85740861d6c3452928ede1557e3b5bedba1553dfc669fe3df5539b356a4b8a39fbd74bde247bfe679e71b1c97a52b6e61e7d000ff1f5daabd107a6c6606d2c675c22963bde9612bda5ac666d2e154a290de9d216c1f2bf693ba165b009765ccc5f15f7e3356ac6bd4fc3976a08aa834f70ad56d0e82dead283b1c87e298f981bd05b07a574601b902aeff2b9b374e959ee8236c2041ac992ffb4334c087baca851311e32a296a2d56362790d319b1e273aa2470fc3918b8fc05917ed661a501b4051eb02b22e8362ab4e21ea9e13eebb642d509ea050ddd2d7b28a460450f4c4e4363d8b6de0447b0fb82406cf5326fe8ed41f08e483cc1abef9c8da46cd00ff2873713541e4754d6bdea48c24d4f4fa77aa4a6be04a77887007e9ff6b1bf78f1708b302038c5fe172ba705badf5cbdb84d3fccc94f0352d71cb9a36bc97804f7cf19adccd73cf9b6cdf8548d4f11736d448e9b96f030d7b2d265c11694534f432a3723ddd4924138765497bb9f92f221381919cd9a17fc4c8814d775386c241f2f8541371a42557bc12099cd774a9f9f545d8a9e7bb03e7145c6fdf12ee26d6928681112588bf7f63cb035e3112f90818741826973e342a8c8bbda1d447b89ae9c9d95bc017c37ee00e6bcec28788675d6b24aed5968fa138a986999aec86b794fc8c2d16ed8a7a0dac95d065585b9be62fe2abc2c351cb933f34e503d115bbae102975557f7857dccd3269b6238bf2be2021fb17ef9139cffc626843bc18867b41b75dfa332abaa55d1bf79232f5fcfdd881de090df45e1d127532f276b159d7abcfa634d4556355aa23898484d159c27ef42ba637639cd0dd2ba48b0f59b8ad7c9a6f9e3d7dfffeca332217b97e1bd81dd2e9fc7928d55d51abd50301d23a3313a9132c7d87cf73d6ef49ed5c099e094485fbba0613506d75da1946ccb941fbbf648a8707351fe5e2185e3615ba1949b52afc87e04403d89230a1530b0e62f1edc449ede7ef12a54a45f1c57a6fdb14a134339d7af69fd2dd9132dbf92016ef9ee3cc9666178061ee58d464710ff42697b4ea511e1c64d331b72199f99f7aebc8f42660530ecab9a1116e449b8d071e5194acc43ba2903cbe5453394958f711111d54d6485a437f64065facc1e714e9e52d6f04885f15df190980466dca01e4fb8cd29fab314cc25f5bffe4966dbfab9815a47ae60e935d554a143edd7aebf668cb9df1f9826a010c6010f07b8e2d686fd369ff39b2a3c2784fa87f261b9166877c2bae639cdcebba504ba48098f6585f77a914a76fd15b9eaaa33140216c5eceffcef8f4f11940cda534ef9b62858a49e506943465a0f71420a3ed7965ff6488cb6c1d1768ff16020159d0b7bfded94c0f088cf2733b8e6759afcbb024f7f9ab25a80e7c80df395060ef426833756f71e471bc2c661699e57784910d36b14b976f2046facc9bfca255e8f7968cec5ad9405c6930b58435429433b392d29de6a657fbe470835e8cbc8fc2a17982c4984eb2fc46ff2d5e1711c4b9b131e3874d795eb0d3660f25b3f22c7e1ea53183a018eb72390e86032d53c7802c6198aae584ffe85c2d596b1fdb1fe2d876d5c2614909e4ad28e0a3fe95b370c1ef8670fe84488696c994795894d6ef72b4b44e6294feb7a912b308158b9149f71fd63e8d9f33cb22d4be098241f2af9c849c51f5c16cbe537d23a3731c865b920228c5258963765f9b4bb51f8a841ff11ac19217234146bc7b56241e6e589efb12e945ea8ce45a1eaa5cdb6ab49166dd4491bacd21d3222957254c0421d177a57ce4ab7137bf3db35f1012f05bc1a6b5ce4a959b60b5f1de336bfd05f7d934e56683ffcbd89eb5a41cd9814e90e3aaa587260a321b117104844f0c1e46ccbc505f25d2cd7c1d221156492d9d818b347b64d0452883332788b39547771b63a1e76a7341ef10a84fc76ec4e51b61d55059f1987081c32a410cf68c43bc69ff1c8b4fdb60b4c5fdb7fd94c6b35869ef426d4f77d8b855abf6f3876c78c64c9a92a89377d8c1affcf0ad14f6a47d6d52ede3620de222aa2a42b1adbb354e9088c1830d344b628d40d1cf36263f52f29a9224af2afcf4194058cbcf74a60f1ce0e4bf4be1919ddedab456ee02623bb8df0b5ce6b30fc24df6257679bb4d3131290cc832b869c29ccb22dc3c97eca849e1b874bd3113b88af0dfaf3bb91a9a04e2fb7f9825992f38fd028db49c7477350b24be94ebbefe41c761ed08afba62026545f888705f70fc1e084f96296277ab43be7a7a10f2748383f0ecfcc53211bd7b3ccf071624fad641caa2f74ebbd32cb066de63a22dd13c0cbcccaaddf3db8b79f6d51251102a10d9a505b3d59173fd1c0547cae45ce1b91dce89fb59c3723cb0c6d433857df5771c20639ffebf870cf0f896094ce594ee378a55423b0bcad0192d9bc4a43525a02065f9bd01a9fe4be49e0f0f6885c2808dfcfff307f7e57adf93805b7c27c7184bb64e7ab2636a9a920f9ed37d8c8d29cb22005640c7e418b7ea630666d2db6b6453ad4cde883d4f91b55ebaac2dc3a7174f63c015da8cd7432ab3d268ae9d52c19e8d3d078401bc438072362ffdfeb483faf6d643863c4c6482554a01bffb497f7dff8fffe5e48e16e12e43bfb2cf5e27de2d474499b83119796db8d0623fd455e3fd266688bde43f976c09e29bee537be89f31b12f48abb80ad037b5334e74a704f58e450f0fb619c9404302f8b03ed840e624cc5559a40b3932688720ac8cc91273b06e64dc993a62d167e6d53f10a2d7f244e9be5fa07dc962060f5b481747e27fb0adc0e69a216c407424adc4f58cbda621fa149dc743561462771ee155227b231e21308a17d2bf2aa8da3102a01342b461e8433f4f2f52e0863f4f5fd9743c11192699397c99bab9f9d326550c05bdbd31d9ce1a5738659f1c90e1453b3aa6ae81b396c39e6260590d43ed40bbdf220795bf4412f782aecfe41e33eb4b65a1b12c90b34d24c6fd6a0ff49e418a2a86b8889ca426bdbaaf1269347079c9c02ec769055d457262bf5c0c022511737ee5dbd32ef566bffc2493651e1dd0208f98257a78ae4672421e22e2b2cabe227ed8637115777892716019a9fe45324b6424686be6dccaace85dee52a5475ad435d00dbd305eeb5d424c6b9666428213056529c41a871c031d9a5a84c3f9aae5223aecd2628811921eeccce80d832f63aee2a5a7d4320c9a74ab37d00064c425b568d9efdbcbaf7c9cc2e2221de4b41f4aba55e9014bfe680aad29375a609c9e6b423202d77e9b74f76cfc25353e6ad87bfdbdaa4855585f767bd6a3e7dd443ede9d3b32a5e4744f7986f10047a291dd6feff685520cfa18ed0dd6a6550a2e23f144d31284b6bb15fb846cd1628e84b54d9818ab1abdb73611ce51575cc0f8b67a9ec3146b0613d957c75105d70c45f298c591b9dfa02e9b11150345ada5d3181d98610d12f65841f83183a2a4d8955265ab868a14f011866646b6a3d819bac314fd764140dd6a480bae4481f1ee272103154033f65c6eed562da18f9d3de3ba8b9798f9ff5b18bd64f7d344199fa652a83e58cca17f02ac513e43e5ce0a96fcaa2167e26efe57d324290dbaf6c115bed0b60d826bd3d02b5de9c844f14c87d72674bcc0e634a49aafcb142e56ddbcb8267a14a94ddc9f327a3a16b38a104fde32c49c2ba3b3df4b59dc5136c6c765f498de331ce9d9197b3d98029e80aa9cefee2161c68ac473829d086dc8ff1f28c0eb1d65516c5cfa3d4e89ec133704944b77974085af45024e3b89664e8c14d18553e3768c5eaf0c50f5c40c718df29d71ed6e2484ef38f9fe0a32cd750b1b1c00283e835d67148f44c33c5da0c34c084ac7cddb93146e8f638f75c5efd3b8950d4b69d7043a62bda34036ce308b2c478f992f1f40660e358b7d06a47c1b89af81900c487ee1ddeafdf6ce6bb7abb37dd8f8ec743275571794b58b8af8f7b0bdc1fdd345b9da0dad1127b8601142497ae2330f850dca71a924effae9a8637b2f5ce0c5d35f00716112d32773eb84857896a8fca7d484f56113f0c8265af89bd05032106402c038b94f167e4addedf16a701974764bbc8ec7c0d683af6102abb5a9186fc080f9486ee98f6e21f29523e9269e299791c4f7a7d3864baeacedef88619a0879bd63ae50c4f72db07b865a2f9f7a3e1661b5adb36a7fe2fdbb17b02c11c1ef7810573ad207e5e98eb98a92c281ba99ece52028b89e4a3ad236538c19dc929cda424431545b4219c5d751e041b593cbc0ed1149c25ebb2859357f238e8840a8b7399217d39c847edcce8380a7309ac443830e679bef6246313b28f4d6b9c019a139c2ae0c767033c7998c7a1eb0d2d6e93cd868c6a3d79bfa43816fc4c535f016392cbdcc89dfc4e8991f5b5b553e8903539c43a44cb429b1d876d55122e6d41b5afc2e67018e9aedf01ec670ce5d3897bc0a51a3fc933a2624b440dcedcc4c20187001e5cf9f31e2e0b88895b0babe03fafa6555bac9e0de078a2636b31e98b35812b9e1708079b3d7c3ae609464dbe2b847a3dbf6fe642fb5804a9bc1dd33d42b5ad3c0d0bccc33df877922dac2dfd91761bd917fe219ce820a69f4ddab530267d4d01691b246855d008718a5de41456af3ae032447199e388b5db0333eabf1e6f395af438c217a15a8356dcbaa066c2f84772896b5e40be5951266c69639c1b2fd98b063421216d7fe5b81e9fd0025c689d7e0906974ccb90365620f7ef8c4acad254482d4456986d5624878924f44311bfa1210ae31da8438d0049846e2fd78931ced28cd29a5609c2537fa812f3121f47265f30d95a9f05a1051911ae2fbd9baba06d486a4e6012a9b6a2907498050f79b459a2402a322ec5c2223817877e2fa22aec89b03241e9b129dc84ef1cc7bb2576d52f2bc65465fdffe60dd371b6ab1ed6452744b6390dcb0e29587afdb527166fcbdf44f3d28eb5e8964bb54d723cf07e0e57eb498615e29168d4e9336cf94383de99d0feb84a7162d649bb1defb4d01a83608e44d268424929d1abeb8669c75e5f1de5a9d84fa3b3e2931e0772ffb711a918818d0763dba1ae2a7fd5e214fc985326043549939709f1ecd508c9521aef224218f031583246aa6ec26e4efdc3c551923f9bd281a3529356fe0877b458d456b360460a1a97868a9d8cbeff1eb871676d8bff119f74f05173931b4d9377b18e3012ef162ec8874906e2cd946e34265099e17b210e259c455bd92426b2e7abd92d963649292f9b4897820d807ca717844eb5b104622da5ebf3c45e4c2df4dbf09421c6cf118faf47b882f39543d0068a86d80c7ea5b517fc043679a0d02deb43da58f77c8ea18ea89c08e8ad62d3ad7b2d054d5b052a7ef85ce59a2ca0900b8a5dbb11d3014740f94e1052d7a48a11c392910f0873fde96399ddb437175a43a45df0667025c083ddb005c03869ddf9bd392249ed0aebb78d9c522d215b9d4207e2f607552b64e16441afd7946f4956918a0796213e8f404d22e3250f24543796a6d1ba599ef5a807b0fda33a0607dc1bb6d3156ed5ee564b04cf79d24dbd322d1d3f70d17802b31e5ad1a4a08d7b133586a05a37b9bbbe7dbb78da088a8a1f15e3b170ce88c7671d39ff76952fad230784e6848215b21ebc94711c63749cf3f771dcaf3ed4057bdb05e4b770313be932b6e968a6f3af459ea1cd407d27da072de7857c4d4ef5a1d8ac37b0d7b7cf04a9b1a3591b75ae072eb179a85312949eb5d2768bcd451cda1dff858f1dd4ae70da947a1b3a71a57714f5882ac3fd00ba7f3db35ed4dd3be8ba1b25d4998938b89672ea346f5f48c89ceecc40401f8fce0721f4b53cfc69098e695db08305aad374deeff509e879ab8a9a0f3772d918335e0e63cc47ac0f2d0aa7c16e5b99b6eaba36331f05905b9643e732fc26019fa295d27805396ef44811feedeae6f98cf6dcc0f46600d2b85eb5029e0a516a9e04bd2b5d2b90eae545c26762f313cca1b3ddc5c0f7d4d94af62e39e0d39f909db7b76420cf7337150a1ddfc8205ac235e20035f0748299bab8cab6dd299f37b42d5120b735e734a865f919418db94d73a972a1e3a901cf0eb3ba5d6a9665c99948a3076d7d752a9fd1328e4c1add855d8cd493dff3f4e1f098078ed81f6f63328160cc41c2f07bf17241e54e491b8affde6fd2d675f582a2fbdec5841b56bd605eb3e7ee17ebdcaa4c095142a3b30b8afcf1b05d0fda35ecb88aabb6c31a666c197917e4b9962536ebf5838f85678eb528a758e34a73c2e18970752c4bbd2f8fe07013b227fee6907ac473cc58aa9fe1248dd5db986005d12c32fed19fea68c190afc30a62e39357397ec5fb85c61c69f2587f0c8a6d094a86f6f57a04bc74ce106959f226d4ce58d962cfa743b132c86d99b2629ebf1ed20417c0cb1cf6d18c2037e6372e08556d4b3d48f7e88bbf5a1505b94519634bc690b344a38d064b67954a94493171e8849529b00ac6e566c551bdbc69ec3b4fb269d0948523742379f15428252139fd0d2e0e330347e48c440f630e1a0c506a5f42a6c0e45d56bf0e972e6738a873a2a0300a289cc707cfee3f47f9347853cabe3c97001d1fb2f1e03801a76d5db217037c55aeafe7b03cf58f9abeaf4d47ecbba3d9588380107082da620b167da3b66ec56f0d5a381f0841d5cca076de367450562f9ffbab45e93bda591cff34853890cd4af76a0899ff2cab76d2078220f65f9db24b786cc5229448ddfd43eb45ce35ef70b2a8bb01df294129da81ee9ca8f63570385eee337d6574d422d8e03d3612f0d3415c51220e0dd542e7a74f1b64ecca7adc8081b3a943c6c5ca43fa158cc03a4efcaf183164a5164c2b33a132cd904e7364f8b77415e907d3f333c28d6d36682ad48475beafcf181d1c28ec56bcc92f7aa62cd02e564f0f4bb2827cea72c22989445119be7aa72a364011cb2a7cfb10f5e0f1482f5cd8d624cfcb22c7f3c731660a0a680ae6710a5b44b4378b499cfe190d171991d518774c4b3b3509ce3a7d6745b59f949cb8b0826d78eb5b94a80daa0c589cca78a1372d933723a13017cb9e7ce5f161814415900755ec75788795a6afb8ccf3458192a2425baab5562964d06854486db62b6c004edd4f4b357c812bc381ec9c7c7e83f4db56e3cb633a37c4be9f3f1e5381824ad96fd22dfba1a98c99ff382f6da5e4afbf20356ecf1c572775c0db85c9625ed94e969170ffbc1bdfa0ef665a3d3bb9216f5e5e1f43c577be1bb6eb4864880c45c562b417cd77f51f8ea105d256bd83c4f6f873f146e45c740f9524e90d8710913d31734666986633c5c386b11f3a2daf8339c891ddd681cb31faaa2c0632729f6919b51aa856b677d7a95c333192a6f7e31252789c6f949c4dfdd3dda69a14510908ec48c765a94977283f046ccf24108df3601b5fe17c5a18c84f53e332f460c8b0e1b71db236fc6cc7abc9258174d77b66482cfa2911e9ff880049458c3e7ee6b6ada52315c407bdde8874b858f758fd7caab9612163e91f37b2c623c6ee1bc52737c9bec2dc9a1e3cc28424a2bf173ef50419b7ca15a5a092a89974afab3afeac2549128bab533397dde6dfc54a4a66c54c0b21d11f0e69ba37b8ba0db8bf3e05cdccd622cdf49803464cd1d46df9488af88f08ce2bbc7e70f3a5de41f6f379b7cfd167c3c698029205e54d38043a4585054158ba18e01d3ab50c3317d03c37e718ff5ba1f5b81647ab734603d0e4437800bdcb3a3e4a45f655ded8d29461d0517b2ef2a11f663317d5509a4310d1ddf287db8644732e65e609b48638b78bf3f34b85550a06a125ecf3ce2fb95d451c3efcfba2df3181571dc9d717ab7d50a0b1b4a1bd433cccc5d027ad4962dc51b08ff6b796215cad996fd7953aadc9cfe1b33aa8fe3b632926dcc3bf0fc0bae1137c299f85eb4e57926bc3337efdfa9676a5b25cb78107dd47e1448368e70d913cec79218e6c523efd25c7889f256397fe299d0d0f487c34a4164513a9e57ef0db3bf869f35391bcc80c28709d01cf980eed2d7dc4bb0f8c0a0f6d6f6f1c5cda85838119b5d1d37c39f46d68862828c565aee7bf4416d7ce4a007f4735d07831835167f170abc851be85f48aa6ee7dc1834784fcfa390a18537bfbdff14ef678471f14701c7c1459af31e7d8b8c078b71c6e6e10bc6d5681a96a41ff31de3b0267977e4a4258c24f83016a596ba0142d3c48af9874d4ad1abc42d007c46689cc5f4862b7b3fce0c121806e66f5370cfe88c1cdbfe2e40da0dc235913dcf9e116aa3d30b1b687a5a0e2d804881d1b875ecf6f0a24ef02a3cacb164ee2366224e1b6240e02fb10267135b17833a95a78e2de977434e97a4c970640a1cc73c356dda915913207eef1b2ca6941b5224e536ab382298b8ff45821b3e84b70eaac6554a691aa482ee06d34b34468ce58c28b9c32f6c83fea297615410e24adde87989c22ba02f1406574e1193d906ef80f916a2d5778e4ebe38f26a271384964daa0068552d8afc27c7dde9d148ae36e00747c4f782cf1cc61ac987ecae5b629115a4d53cdf65a4a91b671b5c2ccd369c9aa87c1700f6cd20af2540a56d7376ea32c7e0e4e0016a5cd51839121b7d5eee533e2e3ea45c3af42447e4b4c90dc9b844b58c53904c0c54facaaac50a15de3dde7213110794e1b00e09de5c29a001d7f927a55925b8be38e9b578ffe82683bd4aa37e64da699e8709d05154548557b574d009dfa0fb1673e41331c14f312f171470f6cf67be651be7b09b36b793b448d7c876a72c16b25e347bfb52d65fba7b7559b26e549d636ee25a2b7cce0fac32c75342d18f9a5e96584aa49dde20716c0937b0e0e324443e40e6dfe5a4d228e4c0682942e2a28d3228288616b3ff91fce2eb121f80828995b14bcfe91fce3079a8200d78c40206f1f94f5f5714ed3c2e54420c1f21bcbf3d5f7cb5400e8f89d00a4d14e6be6140fa3359349c71c7635903f28e7a367e54c486af53fff98833facdf9a27352c89d388a6254387165a1a61aaafd6e15d04d250c042951edc2fae493f3c9143cddf28c10743f60167b2720c8f8304a2d0fde4549db1ea839fa4a2c0503e3ec173b8012bc28e6843e96e456798d28c0b6b57af77ac8c02e0f842f99a2126222657a002ff6b2022a7894f6cfa42b1b1b6270f74f50b8e371dfd628a52a0cd8217fbdbe0b1f71095c270f363f58c4057b9455368ab969deb3e3a1b3b9594fd973403d1ab3ae7f47d0f5e2ca2b47a33ddc19d96bab6905dd8384cb0dc2327956777497270004dd495364bff16f9c3b5ad73775e65dbadddb561a8e81fb2397b92d7544f31b9af8324dab1e721c13894dd81433de764290e81793cf28deae29c491b251e46857cb4f77966d5ea6258bde0965b7abacbc6fb9fe12eb5f358015af8dcf4c7be20b9662e390a91f93cb4c833d3fa3da181fd5b0db1bdc7a66829517fa3d0298f29379ef3ecc83b188994b91df33cf5ba3dcc1819ea45ad90eb91b6084c0c07b1a3bc466ff874782e47f0ff2eeb3d067db55fc72a3573cb2c9f22806e5b459cfed7a52d4e5ec1db6a10ffc207ac39d02c13b0baf59025160d8483bd6a2c8fa424d01c6c3965d2f675204db5e527bf9b8835311f1539ba82b56b4ecb486d5f4b5d29c33b910d3e8c2fe901ab4885b54979b8865015e59c97336f39f03fd79a894ac748d2f461e8a80e0a9b17f2ff8b68418afa1667d30d4737d41a724ec395758272bff4d9b8c0630ee20ce55b96b35372441334d9c1cdc3ba91029c5fcc6a0b54672b70ce51f93055228838e57f20e981c253986590775a6afd121f1222dbd3eb3d18f470b32c4c1c0e041f2d21901a220222c088e1cc9c08be11ddcdf6d89ac5f0c554d029d5c4767a4dcad1a7ae176968f7fd5063db37791e8d475c336e225a1bb1cd2d15d27a215a228f1cc4b75142276b08ca484fbea2a0751961813a39507faec9999d3c551193b614dccc95aed55673c1c968f63439d1e85e4b74483c0f6dca183dbdf10c0969fcaffbd034c31704f5f52f800164457cd2e78d561967139162a021f6a2ea5daac1658408382215454f70a9ef925144956c54cac57a2c648b63b083091d7f13506c977fa1a42020023aa202f548f414efcffeec29d01eb55c2142d02d1cfdb3a8350485d1e96689a37869904e4114caeadabf83ff93ed124be0d53b196ff549b7dc8","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
