<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bf34eed538a87326511dd9a64ec8334dc615edcc8c143419e4a11e85401abf2c60b02d4d9006f071f031a5142766ff52e1916ab5085a72eef7a6115a1c81d909a8e54cd714af84d5077525a17a829b674ccd1b64e2a6ff5bb8093be72e28f99d9cd43b777075e295359c8021208a815dfb7ab753068d90e6bc278048e87c26ed94d94e06069b657d7ff8f0bf95e56b5b920aa9a699d8e88342c12237b18175e343d24b5f4dcbe4e07a5b8874037ca488018126078e2bd5fff9b65918df44569ebf419f17737ce28a7e3d43c52fe5858c0bc106c9366caf456148e743e5651c12c9dfce350d2e151e49c065b7444aa301228292e8d36af8889a000cf2bed4c13202744fcd01cf2922a8fcf2cc765224ea1faf6d2473d87c010bc532574ea361f2ac6f2c440c724b119b8444b3fa44dd18f14a3909ae95c561f8491c1c5f64980997dc782c707620989c0570ec6b986fbe19b55e0d2239ee1fd23a18586d21a565b055e884d1f414b8ab28ee369ce2d1f64bde6e4bd4fbc05eeae510e69818c7cc91dd13e40a535e543e0c3ca4cd8edd6249edb9caae61d1ede2803b6e01fbbeacdf8345d014d13020ce6f421e4e78e8d1003c5e02c2729421bcb0ade6f373e25f573b6a514b4e38645757ca5e379b5d2971aacfcd8192cb7a27b926e1c47133d4b524ecd3d8aa3bc8087c5cf96726ae25a092fa331ec2df92c06d89018ecf5be690e03e76e7f20faaf6333012aecbe33dfc7306e76bb92d6178588e279e0ba9dc43913082380cd3171927f9d41486709230391d216422dde7b14f8149d156d6155c22e8e04a971158958d305dbfbc82464e96213fa59e008667ad8d589135eb4a37d8a89b97a8c44c67742274ce3b311c6eebd7e60ac7ea8331110849540cd6b02342959ebbd9327fe606ce01ca86bda9659fcdc51b5f80e38cd07461ba20cb22296eb780dd2bc1510ceb6f660980605ad0a98b51981a2ccff5b4bbbc0995bf3dbc62059e3df3104b028cbb83ad7c01f793627dbbdc25d1f89ac39b642790296f285a94222e4ab62820d3d2204dcfbab452d4b66c09e9e3eef911179f46fb98df5d75a1aed181fee555706b21fb34296976ae819a62f2011d0c5515b6ba82567efeb0a566d54e4f9b7d33baec65c8d8c4d145d967052e0a33bc592ce1ba4248a186394fc97ac2fe2851dacd20ac7dc1f39f8fa3fbd4dae80ec14a179a105ad9e516b155a3240a25472981e8efa523ff87bdc7974941035ccf7f5073856ddbc5011654772d25db25957ddf1e967cb7e616a837fe0cb6eebe46a5c9fed152a4add79acb1465e5f5ffc98b10f56cb86b164f2adbcacd0883ea0e6c44abb559aa0f9ee0eead04b040d3f6bedd9177a2be5e3e48ab86549f3bbf5418865d97ef0aceb494e855778cd7ef9cd24ef5ac2f14ed187d710848978af5ef1556c0617d1ec61e7f4c4861e39f584f562b745840e4e91a22630b134ce5d2c3781b88d7cc19ab9d9cbc6383245a301e0df1f9a9dde560b035dd319ee1b458bf1e4aae89747c2fb5b370efc9329c586ed4d14819d8cb180a96a198a8f70880065e40468432a3d874080924a5d39876ab4debd84c9f80e4e8d287a92e821fb27420b0b28782b66652dc9b918157364c7ff38ba57f1576ed9dcfa925aeb690be41d4687b91272919f143789d4db0a43b61d96fd6962bbe6494360b19f8eed0e0eb421ba86eeb486fddd42720010a2edf17109e21cbe8a078e50478d526d5595a9b74b04fbf2c3eee6609aba7335f0d31fc16160869d8db1e8baa7a9638ba766ad1038c485d4e81266aff8961023ca8fb517f0853d9a17be0ea46854a82bd8164311af05966a1c8cd48ec370fa002546f4405ec2f7c3cac5cdcfa954204a60794652789fa3541332b0a3e1713f095dc6acde8de56323fb213364c85595ed97350adc217958fb506009158091d51cc77630f0817e45cfb29fa03f61d6ff7d14a28424a1e1dce8d942ca67de647fe3e184097cce1086b64611a683c79fd73456f7bc35ff1a03f252ca1cfaa2585ee44c5c571a307e931e42310c984df10b3dd96e85e0cdab6ab0950a80facdf21da5ca214dffe301671a3fcf22eefc8fcc71f683f2bb2bda4a3abe7467877b64ef5b201b8944d1a81a43a96b689d98581d9fddbe7379e299d1a5af6c9ec32a9baf5e048f0c1a45007e44513a17c3295b238364d84fa9740449bd945456506f5b6ecf6598cb314b0955544bc40ee973a92c7b4c244171ddd94ef794a704b08fa8bd142554904a41ffd6a9e5372a7160850a4491990184941d70434fcbb50f70c1c6f7a8b0d51e81922603eb984022debed6db05516304c434fc303b99643e2f6f8ab45fd2d8a83b78bcf90f211914105ea978cac44f35d82760080f6bd3ea5b803df17b2b2a73da7fbc17545731bfc93af0f932685d039f57be95c224f6ecd39b9ad3d11339f6b59f90b42d2b8931d4476fc14f434b6bd22af7ef935840bea035aa4e77604fdf711eb3172abb1faa10eba916eeb255a2ac0b63fa772db8ee7cc9080d537afc132f1e602390a437d70b1115e51a8687bb4612c4b56feceb8fd9595e959c0904920db886d5d851b975e3feb8de008485ee851d8af2766d98e8ac22552d95ddfd2eb01910a730d8fd3f66280b5802f66af673ba4970aa05b8e2f498f80df841cf677c61697d7d6466b9ce5d288ce02ce21717f68319db2e83fba213ee88630f8fe44071664d6fa9a68630dabc5a09b788dbb66d6d2eabff6180c6a8d2a354f574e276888c5990876920f65e24fbc69f76d5d946aafdc58711b860b9e1afcbcbf3ded79b0ca37ff2726bf5751e56e9254ae417bd73a8cb146cd60a240b0e77689fd32a660006b1b594d658b37e8fd177cde814d5588b916e592b8d43b5b84d7a004c053695e54a022ab402bce56859eef49dd08712156a4680437b8675abdc8160367f228edccedf4d0dbc21531ef00d76021cb9c91d11e8d4fef6401028bf13fbefc648b31d335f19dacfeb94915bc87773d8672ad163e79dc469579a97643685b7f17b790e9936ed47911a54ef3b19bb07b3c056f4af1451e45a2a24690902f497c7cb9b4b58aba573bd09d58978696b69cb48e3b64c41ed3a70062deb10467dc4331947537522c81b14f0a56146f6b3f7944cbe232556eb3fc7b84d3014a7e2cc9d84dcc68f2580b668b265a242da1a31acef9e0b2c27103be3a997658948877f8251bfaa16f7127fa35ba6713c2fd6148a336d1cf305b69ea990d5907f69f9bd2ff26efda9f8f7524ddde8a62c0d39ff0967b826ad6cf56e9637f753a2c49b9ce3752dd98887f4692641aec2f9e643722e4dcf116fbab5526600ff9154df9650b04b4028968d9efd224a78cb859a93d03a4eb8b7697179d51c0b8344b130848f7a1cad8642ace991cecb63501febd34b7353ebdcd2e5fa8d10528e41905039434ea9e66973ddfd9269509fc5d05c27e7d7506c4826f46b8698b7a76ee2506ef57ddce7ef8ecf04eb1d1e46009cbce8d26ea87dc37f0afc9ecdaf178d5cfce2c2c452755ac75d3af7ebff74656c947798b52851d4475b82df6095500bb28b93356eea66276d1543b35e841f9ae9f82ace770b8379f29d44bfa0d29fbff54456df3ad07cb7ad6e6e84bfce42e60e099c39e6a1a1dc5d50c291687240d95ec58f035268190908b0476095532fbd2325559b95aa91f04fa80799763b9a03dde5af5b91d951505f8dece2900a69fea6db5225f6edc6c552252c021a8242c3bd4a9ad38e62976171e5bc5c3d729510aeae6eae7fef6fc9b294a75df52071dce9b1a80d718d9c6fa4808d0057747cf62be34908ba036b12056f8066337b7def280cf9f4dca076463053000d18e2ffdb5d7ccdc301bc9941158242828bee6352d0b9b63dc02a02cd82772fa7e07f7d576a95a84d7a1750aad7cfa6dc2459d6dc79a6da19b82b3cd9e953efbf107a23ca78ee34f1085c702da2e3541b6974bffd4a0cc2115ddc0f525abe3b46f9ca82f5d86f21910b4758bbfc2ba42c1071b1de610896b0698f8174fc133bca65f26c1f82e6eac01022a594837852be8041bf4addd0e6b20b207478b122d766a3bb39c92ced223462f1027c328404f3636d685ea6486f0c5503d179e23a62519dcf37ef022c68af0c741a78363caea2b69bd945395757ca0fce807329a769f76533b026c5bf87efedaa7db805a0bbe0bed76f8e508dd47f07a2c399dc26a0711f0fdc9ab525a9489be3e433c12f38bcb8cf0a93ebd36d98c667f2a8540a214a1ee76ba5a29438a314586fe35c333b6c0c067a1f23437ac7ec82735c91101c92f6da805a56df0c4cb08fb8b77ad0267a27397947aa946101a61ea4404223182dd049154e152eb16104988df8a68330c2abff4679d097166e570c3e87ca8f4ec6eacfd229edc6acdab6611d77b461c417cc160e1bde26170407f17625f7a88ad5b488c77b09230c398b362f24cc4db1713e3c0bc8ed598f774ae1da40aec7784f466675ca329d029b495b8133ef9ac54b05819a4df0364d5a595e724c036aa827e2c0fc9f6f9fb81db85a2e45bb7c9b5bd3d5c39d3f7d3e5727c3ac4f867537435f6fe09a24d22c63d9493c145998997eea16261ae2fad01c71caa3151183a390b28199bb8d7458d22ab914e227c9de030169174b161f3555e0683ab07b61bbaa57f89d795b3e6acbcf5727cf3ece8c97d5286addee4b8cd0a002390117d87e758b3db2a64944423876f5bb053c977088d2ce734d0f036b508ef6f5df6cd22448628993d955d64cc2bbb8d8117b7fdb615893456e3266ad2f718542a4104b3bfeffcfc6f9d3694b9e819d3b005f749f96b8b67469be9c379a375c6291af908df029b5733e44d472536c55d7f83a298c764d03cf1c5b76fadfd60eacc8b2c9d2f85b1503b865e5546e0d43fd6ac4b6cdba5c21544be10532a283fbf2f7e0f533f3335ef98828ca66f71b258bbdb2477cf09c4197655e96952a8a2a42144b56cc94f4cc6a66003e1d217786e064bccd0a753509ee2c952b741e3868666202beb51b78f2c313b5e91d220e4595ad4639edd8e42e838f5e41bccbe248b722c33f2fe073c3148a844e58d388b36656c305bcf3384833b824fb915610d00391a085985696c912fc3385a7b1b7bf9c5c18d02add889cb11338ed7f5ad7925db7a42c23587e8b0d398dbf5659745f0736a6c716312b092e781b0acb6443245c3315966dd332565fa539de1555743201744122929619384b60af8ad63b085eab11f933c7519bacaad944a0738dca291638029cd4fe860ce3dba8b8eedfcd9a4d4bfeb579e63543e2c4b1fad3fd347b292d840c8820dcacc6858111ed9e074f4e54beb9da815e76d71697be9ebf3a06634ded4c9711e836b3473257df6f9506e00010a299f0e86bb5152ef8dc68c29b56ad34659802741aa5c3a3c46f7bdae02d7a9aa188b38f0d690b3083d50980319d21e1addd3c924a83362f2df7f82ee349325d8211fd518ec73d93b7d044bb0f88cb83fd69f156bd8f35c46a9e57d61892ade605b2cf437f58452a8ebb46f7a40c6f6d219fbe730c1a2c0fff103ec582d5c1f61ded77eef4f56f7d9cb8f720a8acd29fafefee779e45d26a3d6b9a1be29305053e79a80cc9c7e4de2f7c12df3aa0c4467e5175db5ee0c408aa7f22cdae31f743dca94890f0136d85854ce7b90db5f99ad0507c7198280ad598d76c8800b42661ef96ecf032dc9307754c42597d966fbe7e2c0ed769c8542ca1b16748e59b9be7dccc70e5fa1674e82054db3d36ddbf88a34ed658d370b8a087fdeed59c7b69cabdbbc294b400d2d242ced7ffb9b7db8693b8603a709492ddbca3409ccbabff68d6e2eadb335dc4b09cb2cce08c92060811c780bd735d7aee931eac32c9c0c0ae323e01b8f67f161cfafe758e12bd3ad8dc4ef0b8a8623f81e3a56a25b988f518f56877965774cbf7edc715dd3ca35894553671a205213141be18b91672ea6856f71cec666df32e3bf709a690b0aff852588c84b948c64a3d4c32ae1a77cc9951d25a1c2f6b12b341137af69de92b6155bccb6bcb9ec472dec27b65e9f8c00f86d764591a90f1fb81fe8ab1c789c2ded88c1c4f109351d94f097cf26269f493ea3e1f76da963b16594001a2600f4d16156f2f4842703a81e65f0b284203d657d8cca5bd873fae97c36ce6d0a838f8d3fe7024f1ff731de735b8cf57c21f311bd96632f487f6cf19dd5958f9694b45361d817715140497ed98a3011f726ed9a262f0ecf85a25cb32d3bfb2e8f8f5cdd0bfb6f805f6fdd9bf3b99825f6eaec187e2e90cf724c89d56beead26e22e5e222e138a7556f176bb7d68a3d484901e5d386cc9327fe37871b840d70d9265aaf8c37e00b788cb2ef31956bc6820543de441652d03b598e9724fb8a83febd79c6d7539893be3867b2a477e7ecb6e49d24d1369a001957405de828f36b8488c9bde5134e854f86ba4d0c3650c07bdabd366e729f691885681fb27df59bf7cdb6ac3e3310c1920061710f46a2e656090d0fbd4d4e8465b729898509b62baf8e1c5a8e8afbcebe1a31a0ace6c6703ea3d9a283e635fca13ccb79451e39b8d713c560ede5164e5560037b1c9bbdb84e931f4fa0754b9f354150a1cca0675def075a151185665d625082900e25c7bff65719b3f6491a9d73420ea09caaef7036ca5b49f4be5b79f1285aabeef1dd9a010df0bc41a676c9eda34e6ea55e98cba5543a9343bf0348d09c37e8f9041c2d45aa075e356fa1f89bd5d2d39699d07035616dba1e0499e06040c32758d295aa903d61ebe9c78115730d70b94d826a943eaebff5682c411c00d49e6c32eb9a5c2769e5900dcfc954275847a3fc2ba39f5745dc1ac74e90becb42524ac166bed55a2aff7d4f7445a5a4d4ae745cdd155da8092e2b0af4369666ff3e83fff8d89eaa2dc2fd15eb45390b880d4590d4b7c55d21b768c9d20627d0f36d581b7b0a0522309988373b5caead6300ce06f9ded7bd0931ff4fc9b95fbea6709e6f34d4ad349eb04da62f2280c53015737bce00097dc4d4f3b16d2fc893acd68d5ff9059e5b7888c77c104d2de198d9f23d491d05cb2eb532af8e001dd989a51bba08956ce3422f3d08f43dcb0ef745ed72647039756dd5c69a93acc7bb5e5823ac65bbbc26efc3a37fb8cd039367eb8c3b21b5c1da42dadce7b60f4615f0b2e6d94696627bf7fc74a6ca843ea281d84d7b67a0722cda98784262a3c34aab47e479d1b2b8a35e001fd55881ab1241b6d8d8dd959981cc194ca8d774f95efb0b346308b476348afb255bd268a64ced42d95468926b9182dc8102259de316d97b688f47d90e0f0395fa6f1a79943aa051c1efa1e882a8c320914bccc0f506f1f2c120e942f4c11aef6422a95efd1cd00021ce3ce0e8daa6961c7a08db431804ab719d4506d5a9ac0efe9e2a2e1c516de3847c7eaf42ceb964c2c971be2ff892f86475306113ecc5fa548bb6f178b60394d0f5cad03a841348a22d504404420d095017b7c192b2547d96a79152dbc963f119097bbebd65c83e697a6d6a00de9cd71b441970b0909ff1735ecbc2c4733ee23d7164e26270b3e9d4019f1ece5fcd301fc23fee8636c1fba0843c305a230b6e376e4b0c7e82078ed027287f4ba45468f16b9eb06e73c6c72b6ec666d2eb26a2c5d8db88202a84296ecc68597ed364ad1a5cfbc221470b5c090697cd5cc8bf6d195ab09ae5f55ae52f405c7e06a7bab6240e5326434ed8762fdd9bca6e3b8e34b6e348ac571e5a06f6a98ba2fe448f8a429aec1e5341d4af2c8a90b78d8a65d380043a6e8f2c2da0cc7dbe487241fd54f3a84cf1e98c9ab236a372443f07d48f14819e5cac0aa2c0d9cdbd3781b75619dd23f851996dd2f21e20223f415a5c38aef0eebfeded9650e076509a318d50a001e6a38323ddc7701a963e3d2460f7bd405637ee2b995c1441a1ba15fe45cb9e5479dfc31c124973aa8a3d8684cc595947ba91f46aefbeafe35c4c226e7717dd5604b9bab95deb0225ea022ca43cca5d9b22a38b2f776df2831a322a2f0d4905dbf001680139ec4b005d0249ca2d54be3232f4d8460da56dcd5194d2b32b5548f27583fae6bfeb94331d45b681061a472e234243dcb7f8b5ad6892174df6f4e8ad27261c8793bf6661cd72b1242f818da46d07f862ae16f52bffabe29fadcedbd41af952bc433d3bd239bc2673080461ad2302d70ddfa1da90987a20e1583d5d6286c0e997fc23289726ae60d5fad92e1e29a5ca864f4f7b598368a0db8308b4296fe7253afbf490d8fe20790529c881bc1f0f6b83551b57b2d6849b216693cc96444d95d32175857128552c653c285968d56651b8ae11daac27b429013ae7e26157698e0e4ad2503715269d48521abc66da15b70bbf405d9241aa096264e44cf8eb88a884e892429314b33238113257ed66628cc93e3737106dfea1dd6a13ec3b2e3998659055cec98bd0ba9124c064d6d1ef667a15a902f3297eac341d51df27424ed240e68b5bd67ea74868b7831d053431457469da36d5fad3754139bcb8d37309f56fc743a33f85fbe5f952d7bdd0a9dd37b3980b38e5caa2b27ef861b9a1916cac12a245d4731bbdf7501d3667c98804e0ac7df4005b82a7c5dca8a02d083d24b3049c39b67da0a1579c400ae0e0c9533f90a1c321295298d7a09cccb6c3acbe7854ed79e32b3c95cc474122fe4bb730b8ca0adbe1d226a2ae39afb6a31dd94ee7cc02f0a7b50e2c1f12181a8075a48f008f38fa51c44dff76983a9bd91c779bcff03d35bfc69e053b79aaf92d13b0be92174f4dd103d04efb53f68e0131d63dcaf1c578a290ec5f09d226a3c475f6e3b35baeebd4257d752e9d548d4332d0ca10a1e9bf18dd02b89fdddb70ef653e1884f1d6dcbedec82acb64985a4251a68de129568542358984f6c11591f2b4f5b42d340feddd0146890fdbd09030489d2fbdcc4750ebece9a0727218239f472203ae1a967b6c9e60732a043476caa59f3f20e063e98fa32237a8a501509699974fb6d6a7d267c86b93e8dab6200cb7088603f934d121c848279be55b5fef7acbb6f14510bc616a2d76200abe62e329eec7081636aaef043e02fc4c8c7946ffca1ede6851bb907d33398c1144038378f0968978a8b7affbe00ebfb87dd743e9c39c61b23535280a4cbdf6d1b0c3a6d941bd18e999b2f924b5a9d8e30fd075708cf8155ebcb6d329c3f6a92ddf925ef6e3e729556b9ac93632c7a9ccd82e3d4293a8c8b3a3da98ccc0a8fef03da17cc95822b26e1243c3963c3ddd77384971c9d1fdcfb6fbdba5281012412ca046995f09ce44be6290cc5c4eb436647bcc675950619a67c550650a38e353e13a0d2690b0678c989834c769b0dd3df1d0bc160701d3c61160f780148179a0c85c18cedb7c47d4066853225bfb81373303d56d5d87182baf64c721928396adac565306c8bb5ab2526e9a296c6688b81c05f797693bc7052cffcf8f7c5c3632ac6b9d4f9fe5d86f45d714dc90a411b3fc9f19dbe5359b2ffee25c1214ac7783904f7d083eed1db4e3032ca4216e7a7a17f32c5fa9831069416687a38ab313d1763eacc4419149da8916fd49f038680ee7cf73f933e6c88b23536c6eac8ea7579806483ccb89b7072cb8677bdd5fe94d2321186ee69c5118ca9bd52ba5e045a2fa7861c4fbcf9884849fe30e1d322530635f45cf2f665bbed5af70f6234c5f0cf987ffbd245070fc9a5190e12ad9ac2d97aab1b49d96647ac0fbce7a46a85d13eb6d149c72f6a487e0db2e43bd705cfeee6977d1fade77c2a970dcf6f895732ffcc609d6ba015e43795687425f2b5c3881dd051b429b195326e9927de4476a9589fe8024200311e5dee6219710c70c53d902b8a110406b784fc4e322acf3f3e69690ec17127ab4b2c0165fc75749a7f97b2287ffa6204f135f5722dc95b8bf2cc0bbd64cfc8bac832999eb27e7360ff03b101808caea2f8198c01195f94e0357a4b9afd1382f5ed4ecc1c473bb86878db7f26c0c6926f98fb786d3d41e7c68c85a2d9184dc07641a5c98294f537da45e00fe5c15e9687fae4683822cf89671dacaa5804a8efbe4d96ba4ebaaa390f87a3ff230ad856b595411e9b64a32fcb4cb42d5dfe47cee85fe50ca32e960210388a7caee78ccec0912beb02e8c65b437b8384b305c53ecadc70bf383781a641195657715fcd3aa1c643b8d3bd4aae6a6a3cdb84a54eb2e4bb91592c93cffd5a297ebcc48a6e1a72067456238ab5f79a72f605dc4a591302629c48e1e875ad1bbf34b44120331671b2db78be6d2848e8c3c0ea317811056a5b02deac49f747e1adc81302a7e056959acee608d9f019908174b22e1f3237814e63428afcc40e8a39d298346d513569abd5bb12f4fef923eff588d6005231705c915e2408831e3be9351956da3e18c4c401a8434da4a3ee803b64b2dcbf8689d598c2fe08840c285a67993b1ed3297af1f0a8b441a39be0733fd5a52fb23d476b8720b1ebf71e5955c5677b512dedd9f45300967c3a54280e86b2b58eada167e927684544a5281c783d9155df427b5c34990f4122355d55f4a65cfbfc623031bcaf56e868e1001df11da3bf1fd5dc4e5583704708ec610b4c11185fc6a93d34acb52be3697226d99875d51edee03e3dfc6511481cedf23b2ab115b57eb9761567bbaa600913f83683883f6d24e1f08640f1db2aff4c86030e43ff08028ad9a112256e09670bc8b8b2ba8d804f7c4f3db67e843b5908d6d00f14673662f5ed773851027f44ea505955235267502e2ae4946c9f15aec8c34e8e56b21ad29f294061aba0ce88b29727b7d7c3d2b7798a3d4f5fc0d93b5e759395f4e2cc81507e2cd4a67c3a8eb4b0d08294693899f1bdf60c9ce5f4fcd39002475aca904bbba6a645395e913c3b5de18ee4dfe2fc9176d301bbf60b4cc1b7dbdf67cf6162cfc8f1fb9797db2dd0976854d3c08eb9611d324f211a55945f26a6869055024499a4b89568f1976336cd81bac843b092f215a085587a443af497bcade0051c3e579c8fa45b3297235f912f449592948558ad14a764bc5adbbe71ce3a1fa359b39afdb58d2b25cb784c35df96b64c08cce8e7bf6d2f28e63094f4b959983dedf3ae50d9c2d84c44f976836ee6af5972ecf9aa3cb5bc74da62562a3ea97750248024f3d93f42877058ee93a1626789e3713efdf8413db377df91f5c4aeb7c938d9751a8340c90af527bdce6b3e9c9127387b6c12409a2201e7670ff5670c3c30f12b0a30dfaa189b55508457e54415558781c4566b2cd3a4f8c735ef12a9ce45018b85d5091160b02c8f6dd187347d20a9d385ed9d6325a75a1d200e0416943e0e7e19ea2baf0f6c9493eb273d933de1a0493cea59e591e4179b5c38db83421d66fda049c7a61cfaa57b52fefb6f37aec8498de145e752fc4bed24c6f8ab165aab4f40d616cc3669bd2805f2ce6546b39e454218dfde4555dcd93e6a09bc5c6b4b7b9ac0c3d41d7ef3893c7e0e1026db6ede359befc7e75df46155b8b8556a8ffacb2ba1aa877ebfddeb11f614d87195b1fbb702e5eee99f8b5ed879282dacaab2f4d5f0255eac74fccaa202ba96f64db027824861e78208a0d098eb41d08c1954b6831695fa9257b10ea1d0cd43bed19ceb90afad92034929a87617cf7f7f893696a480b428c6e562524cdd7a3e91b75eb1de91c17e824730a31ab40849b5357052afc21120615d8885a56a9b19c5fe8cf61a2697f36ca65007935fc34ca742cb115edae6d65d2f16223dc681f6f9308185cdb8972c4219ef566357a504cc4f59938015e6f53fc46a3e3e6a20c96642b6772f24f7a0783230e02d2dad1d71c7219f845dc6628fb51ca7e573fb5bcceffa8d998fc4fda537f26eeda3ab15c1ee13477f91cdd4fa6ebc2e785f1f59fa9bc364e8f00a8bc6ed9704928140a1029dd5d13cf4eeaebed01af603988a8d974511c87fbd4960c5c725bb214dfa9071629ca0a457558462276cf7356a23b73cfe5b050e5e208fe7c93a4f11202b7c39e536aa2d3b757cbde309d120e9a58363ee2ecf1caeb8c6f3b17c16b6b5c67d46e673e8b277446638d9e54848056d91cc7533e15ea218391946f50770398b1f89a6d4dbca0dc373e12c6042ff51ae65bd1e4f8941e2144ac6f086f205dfd620c5ac49e96cda564173257056333e9ca3fced63538a8677bc380f3bd8e54bbc92af5795fad0af1fc8d8a9573474dd8ffea4d2a17792a764ae5606962f0a490861575d38e288fff8e83ef166dd657585374c42b22a7be6ab2f37fc2eaf502f8442001d93fc42941b95866ede5123adb1be9ba4b08a3db2cf1dee6e891f49396f79c9ee28fe462ae1c3cf2f36011ed99695191e337b72c1578c7cb4f05c020e5e259ab4b25449875b1b6ea7c1f7183af99e51cafd1322afa13e889004638d6194093c43e9ca6e53757b431a5dc5ac74cec5688a048e47daf8b2cdb556c9478c0b9ab1ce00e7272978a89b17520682db1bdbb6e92c7dd4ce77974ce82e36b147e64d484bb0df9d5dce200c6ad42d3ce8c13772523b276e7ba2491300febb1fe3cef4df6a0f6ee7e5629502dc249ddf4f05420f66fa5442427293e14907521db5a7f346a385e9f74033922e398b3f91ab1bead9bf860cb7ba165ee57b8479386bc6cd86109b8df86be2b0e568173c40b0a494a3b7a8750df220d90b1662d2911e97b0a48ca56cc65ffdce3b5a2575bcce4bce21bb0525f35985627565323438a2210aaceb30acbe18eaa30d129adf3f0674a50c02d902921e0842713722abb5884f909b0e4fc3c565f64c5f906510a53c24227d7184eeb118e65ea32212c83d0743b412190a4db9a6e0b37c09a5f7fcb74004100630d99dea0b8f4a483a47567cf1be62a2f900179b535402adaa7921cf6e583f114043093655f3679bed8ad27c01a6e1d56cacc28b52452913cc7f1d05873eb135a9384d2d7c121f8cd06a0b7d83063f49033a4f4517e37153ce12392dc01ef1808e2a5bd75a5354ec6ca0bfeb0b22aed29d4f0bd0843c8cc4404fdfb9730a8b48727605292a8941c545963e3282642019970ab3b523e4371be72925245c160ad26c86b8f3e91cc3148630d6f454ac38d80693879969ccc47722ba707f38f5f413cd1c325050bfffa2c0a61b48475bf237d1cfec402d04f54390b1fc3ef601e6c81c93e4f7c5b717ae8da1179bbd4962a46eaf89ca13303b1cfad8097bb5099884febfd36af752e168ac5e3469591cd59f04c2ba8113c2802b05e849d2d87ed2b09a0659b6653f6a46c983d85c8c39f34d30c3179dcf1ef586d827f57b450f4012e57be45274ecfd49787d673c9c3df9604f3aca03762ce0d09acb590de54062d710a2990ac661abb0b80e5095dc2f28a93e4ce6fd1ddfbf542a036232d04a3179247009fcbde72f694e453c677b91f9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
