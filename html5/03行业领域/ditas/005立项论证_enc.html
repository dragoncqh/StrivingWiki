<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d6c3a5f1fec2c1a7cef7a8223bc7a95fbcf6b6eadc49afb074b98fce869579e6e381bf253697179078c3e2f9b9f5d5ca1f268b324b96a9b1996f9a16d3c8f3d20300281bf5a986a78c8bf2b440dce36acfb141036936f88b216da1fd29138dc21450f991e73fbc0e4faebcca10b43670d1dee76807e57e218bd9c23e51a15fff297b062d7566773248d6ddfb234223183de43bb6e8354ff81cef3fac0eccb3452792238713374b42704167f08c6405d36118e507363bc0496b421f0a163b477b222bc4eaa6df4ad6432d91f0ab18c1c3e1915accdbdd48b9c0d833fd4522a5e97d2a24b3dacd532728727c5a229fb4e16ea598a325b4747df5a21e52f3b91e16ce0c9cda01daadbc57e5d3bda25d9758730d26a8d1a7d0a1d422f89a3792be51ef86519740ff5700b7aee4c83620bab3248347f47f0b1612048f50eddda3f1a0e0fcdddc73b6ff3e1ffcece4b0f70a75cb75cc65f821ded4331bda9c629caa3775888b22556c43a23a21683bd41e766bae85e7baacbfd8b8103bf6e9e76d943942946faf8fd74455eeda0a47a251e6feeaca394e34469d08a56e8f8c93815d048d27597581e9f1245d9b85715055092f1f46addfc314e5bd325af1b063c94c96be7b1d3fee710380a3a0c4bc1b93264c383043e24319008bc0c5f2a3ff94443d85ccdb3b448e05103a14262613b3b06559514adf28b2cbffeb1eaa9081aad788c6e1298281032704e1d25ad6b136ced0a51e3d56be2ff88298b2f797372ab1c2e1337244f877cb742658596f16998c91994e8323a50a1b6697f5aaf64fc18a5457296a0b0f2418eebb76a71e0aaa59f2877826f32c1bfd1d5d082af1e8e229a40f26e4f710da13547bf296a6f53332c3d6ca0876886ab3f64ecf30698e35c9bf3e798bcbebec892d41182a1bc44056a2a1be0af90f93ec26434bbfb4a3119c854d19e8bb08fca7a580390ef07490e9b2d90862d3071cd5b7c6db66310dcc1e63495360b74016d5fadb59d9552887e1ca13d9b181e1ee275a148161923af0f2ba785e90db281124acfecaba79dc57829a641ca4a205004838f0def3d4f62dd440123854823ba42c66275fa3565e6e69ea851cb30ea0eac31eb6c0e195c8fdaac6dde5291fea209c6402c600168d80a88251318c3575200e7510b8afbadb53cfd4f27b2d1023dfdb516f20a135dff23682fcc2f54ebe905f03aac7a3afb2e34c9c79f6cb495085383473274fb868478db9c60bf5e980d7be6e0d8e2bbe631809e965286b616626644cf33ba1aecd4f1f3ad6d31646d5d67c4d792899926aada0f685de8d83aac1d4f9988ba0ea6568ab782854f0e50b5dd9d80f889f94a474c8c791ebfb90fa56c67e39be5f9291304577487bf4f06aa432ff3a2d8a5066c9ff1108357fb911bf42ae71c0db3180cc496cc09f82a99a4ed1154b9e0c4882aeb77038deb5df15f536f138fd683ef7089030e9811d46a33aba85e1651cdf08ef7afa67b03b4f0f1f6876938d5acacb8a8ed6b19eb321f969d7e5751a7e6bd598cae84734a5ee7955ad4ee97010381a1b54271f8e3a80fbb1b38feb504ccaf8c0cf0ba1252d1104bd837d25562c60eb2a50ae457789264559a3046f7d17edd29db492a2f24e64b88eb88436d1232e85d8b0916ad1060e03172c7cf30ae78dbbb4c02b883122435c8398695f14a05e1ef1598c60a02b871932342120e18f0b100d5a3a2def7523b8422ce278334dab20dfa58e4252efbc4cdd1bba1093c5ca9c56f55da5a896b69a69e829df8a93a073390881c7ff0ffefcdfc51270b8311a6e086bd8d3f47e23ce7d35190f1aef7d635e7cbc1d72ba1d7ea55f2aa8ec5aaa0abf159d43ce62db676c3049a18403bf35595a310c097b49a76bd0ffc832a27cfd7fbf3a68d3afe57de22fa9707345b2cc000ce4ad6f8f5db5c76cea202bd7b5879ce3bebbd917714180ba80a6541a153e2a24f1c89a64088c2dc6dfbf9bd91d66c958e9cfc156598dff0fc9c981f95fba6b209be805055b0fa23a3c92056ab4ab5bd0a470cee9adbbd1a251b1e6a2f3168d12a5c6a98ffc04c0acf66ed8661e1255e3f58adc61a7f00a19d6f0ed36c5afac42572ca8035d1cdde5ef6560794de88ac91a8a0d51ed51e456612875343dcc66ce0159445ddcbbc101fe464d5240a16637b7f4e077a7fee70ec5de38714b0a7a683110f28ddf16aec98371b66a3359b3b5a7915adca36e5dccb7aaf0a35992e63cd127fe8bfa5e485b8e5a5ef7216c14d319d56198d4d65fbb523b0b86084722b2efa50def9d5295cb4369f775cc11aabe7b35afce399c93d43046e807a1271a779b20ed01831425fdbd32c144b493550edac69dfaf37c7eccb7a4ffacf35b993e937bd99261e19b94a29cded981e77bfdec574d040e9c15470208695d0faf5596f5609464fae806fe55c5857c2a087f6398f9d7a8f6b52137aabff8c4c49fb0100e7b43a070cb96353cf4640eda094c450699b5cec9fd1c9b82290dd992396de1cb95967b3de7a39080a3ef80e8ae3d7d60ed8a22a8f1a6ac093ddffd16aaf0c3b19637b3712dce73c14b5faf5adfc35a0ddefac884464120290184e08cb54ac4de3b6e558b822f2f45061173c0e32dd3b691f0ed144768bec7ce021b4fddbe26f0f561b93ae8c20053cc7dfbc7bc971a48d60ade3f4728e40fd6d386f6554a35e0f364e2db068a0e076f59912f13526599063dc22754d2af1cc95743c9964ed07b43c3edb62ab3acf32bd9fb1746e28f68ecd4e2737a56d3cb549542c36db9194ebb1066441ac924d3fb68d870e8c4c2120f80e18ea840c47721a0e7259b738fcc5fdb5ac596e0777886465c83b9b4a36468570028fd6769aa3373a85572ec1009eeb881c278792badf298711d5270c6bf4855d300fa53856b3c958ee102c9597b4afc1c006acdbcf31456aae93be500d9c1084e57b896813b74d4e776069ae31ca2370b935c15e38c73d95cb1abba8a0bfed732e705b7dc2b394642a3ff1acebc11ea9b35e37c102d1d7509b479eb9e8cb1aec6a3e71164c89c42550fca8ea4577de9fe59940daf3ef8fbf2d9b3fc04c663168d6aa1349519d122d11a1c410d5a677b9f31b572d33aa3a20b381d1d166acc23fcc7c877f3e09b9a0dc6451b0de4dce393be6da705da49050b79be909d7e2662973e2a2f5af317b0a2bd464ab5142162a1cd0eedefe0839714e3bd68898b088c63b047348797ec22e31161a77dc24a083b0090cc1f0e1fd4300d5f3c7d11984c18324c248f42f0ee541737ade2dc02b6e2278904e1db713fc31cdae0ccc9409dd8c15244b42fb1b7342b73ce4d878c8d254454ba627c55cb6b4ced80b0154036e0ea71910ef7d3b52b9477cb423eaf9eb837e3ccbeafdcfcd3dc0466de3c3dc9c6dc4560f64149abc7b402f3aeae51ef6b9d09dc187706fc5a398bae6b5e51204e7f941d1e00417847691f59db5f0b423c6f80a5ba826f61206b1d9e017ebbc2148622b2cf005ae52d32cedbe871ab27a0faf85402661117281706a2f9a330a6c8688f602328ccfb1960ad34c37fe91592c1b018abedfc328b01a1f6deeea327a7a71af564aef27a1b032a99fd30eade97aa6bcf867925f32a66b229a856d85dbf185d1f6a1637e682449629847472483afdc23bac32a3af24045a4acb0479ad85f9bae5a63b387c5afb01e0068efd7a8b26c8902de8233aa262e31d37353a42f0bb4e23f41f671af4170d92c284d3f20762014ed6423746995999c0cc2a6686f1266f79dbef1f2b572ceef2217dd665369d30fa93bd243b0fcead41f15fe6b6c074da082bb49ae88b3f40d7909e6d79dd4cf4f60e9678b31e114ed0218c313b561eb188600337114f9afa1a7acfe08b7ae6894cf7910e376b5162acf1d63f762bb68055c6e059eeb31ddae2f836a6e7e5fae5de71bffc98b3663c2da792a118588d580a65068e40d4c82189e0d7cb9cceaadfda5afebd03876c2b612d7a1b8233cca7bf6d23dc8c4aaab96f6fd68c36523745fe4197baa0ec4ca3efec154b56d19b59b594a0c904074ac7fba4ddb0b5360e625f5bf53ad830f5ef227cca6ec22260f628e5bfd9a192dabea067ce0c7a035037b01fd95ba205713810faca3eb5223a2dafa6f07d81320a34646e9a740da958cd1d7047991af3b3ae8e5901f06f745c5d80a048242acfc37c09d949307af9fc088cbe844cef5ffbd86e4a219f74027839228359fbfbdad0f484b34d692417970bf525eb7341e7d6a22b0464c39f5717f70f9e5e68a3eeeee4a3a19e34655aa79278e25fdaaff3e32d0d45cb83f793f31ca5fee7a89d86b106dffbe923bec7822e31540912264fe093a958676f7412473229890ebd0fdde8d9baa903f3fb88e9a8fd7dd9505882bcb8d67564023a39c2e7d60c3e8dbc29320e652e118cbdad8b1adc2552e50bef0d98ab57746259bee3a58050fd1fa51574265d89ef6be9b9b5162e434b12ac776d5f18ca4841695569b7ad631f7b070996a92392f76b35fa53125af890e8bd0eb777c62a5779bac01338c2847ece6da390a44e5fe0b2e6632cc1c3b60656db22f1cddbb9154dac093be28aaf100bb16bfebbd232daf222023613ad0861cf183ec20c2cc0910b8c19d69fb8173770b74b63e49560c46ec3ba0ce50d1d88a0e64e0e74ed5b6b02fc0c3d2d95acd91b451935bc372fa70bb36610df7da5ea8bcdff9d5f3712de5f17cfdddfd7a1b634344010f7655708698caab8f98c527d83790a1bafc8d321fe00f2ba97de5fe309695adc025246772bd54e26cd78177db52a2b7706ee8a43a2473f01ea252ee2706114308e199446ded361afa126cec47de0df7501c9fc7d10ca09c1ff4af27c369061b6efd3ed216fdfab903ba0abf2303056b32ea68a5284374ac9c00fd3760fd02e27854f33b1704ee2536aefeb4798d9498f3a72b68f45a90f2aa3d8862d5d7a2eaaac4c2e668fdb01472b95260bfbe6b777a2e7fa5494fbdf5935ace8b6c6228c227e8af946e262dc574b87616d0dab78d53b7bea9ed6ae746ddf1fb2871cbd9093803abe3703c21a7d257d6027dd6724163bd17ec7c62c99db618315cd4af6b4c4e2231498e62ad06444b3fc569a491348659a7c33a993db97e342586dd92c30e926bbdeeab5f715063a9bfb4736599243cfa0bf890d9bce895384b75ab3675f2c56fed5fb814a356c426331b966e8ad61a82de1dc9dbb99922e6dcfe632de91caafdb0d76a3be36883746d754a98d8b0a54a60d619fb5410597998e99bff1055069ecf7e691fa64896cfad7c850084efa02a56e33020c2291688bb693cf25a2d33d0dc5800f022f0826f582c6f49b2ff51cf7ab9b438392e0cc55ae93ca379cb21e5c381e7b26eeac1c61774b7c9b79d6bd7ecff600be8d7b0776cd8fd379e98f71158b14877bf54668c750b2ab3dae0919799ebf9aeddd17c61f93331d1cd3e7e644fb5b0ff4035e245e9d70dca6b8538b7489e75877219240d5133d84a492b288fce2f08593985f3e8fb628c64c4301af0c4c5e6e8e558f6655b2b3fb1efcd8233811db65dce92fb594ba3329a3b2f69ff09f15ee3ba35f834cbcf82f8ef2f831eb7a1c49e47f779a4886c2d67811c2eba3948a9fc702c8643e9ff689e85a74d99f6f4fef100da5144eed66a5cd8b00e90d8652ef9da619b077195443ae02a3679886f12baca366c9e5347e0b6d21145cf4b8c05e823a16334e52fb5c98bcbdb0d34c9b955e3952b2125a477c6f0232177cc2ecf3650437623c6f10a3453176278dcfc38729fccadc84fc9d09cad0efd7e4be2f276dca17a8581005f1fb00305fa4940f79abab8173fd86e6f526b9e547dae3a47f96ac4ae8d84344b351b83aaaf61b07aeca0f73c709566e9be0bd705a8ebabf0879184095074a5efde50f3f6a5b3052d87fac6e6c877dfa743efabd640d8f58e454824e4c93bf085b9493ba31023d2485d6818690755b76fe86fbac8133436611ab571e5de5f03172e565bab63e2127ca49c553df4e9134dc1eb55bf0d9545b6473b1ecfc7ab41605cf7cfc143be40c951405a615fc229e1cf72f715d7e1f6ee7a92afa1360fd7d82eabd3e031e5c5e9b62a1a79364378da5ce8d1873cb2d39648d5177538550fc1cc9af7275469f05985336cc7bb3f53cd8bb8813529d3b17a0a67cb1f5e49b1cb3144b173476b009249e21e9f389ec76e02aef1850aff2df021b69901c129c1a9d37d5dc11b6c8720e780ce7a43663ed26765fab63c45a46e77a2e9745ac0eded59be11032b5cfee516826f40bcb1b6405fe1cd81298eba3d119683da72323d4b84cd50bcd34441f4d26843650b8555fa00f57c0b1d6799b1a45d7f523501361b6047113ac1318249073de768c894f7869f27e97edd25d074c98b4f13e46df7a36c0b7d9cc86d00fcd5a54c9ef2b3fbeec4788977b4d9f38eb3b1a2a7b7bb13bbb6765cc6ebfb00ce78e61171f058391646cc4d7f41b8009e89d7a8f0fe612bb7922c41255d6383410d0ce45eca1bc2880e29b4be96ad7d2f3f75214cecff4c7c110f4d47ba2d8d13b513793b36490499f811f7a237e4e5cb3be64e2cf24b3d1b277f6ba6cda99e8270d8a2782843eaf045a9b2c0fb5c98606257b9f4092c19a236a4098f57192502bfd9e18ba0b7a1ff89a7f10edb342ea685bf23ece9c7a66becfe60e4c04e502b4dfe76bb4686904c8f7b2845bfe061a22fe7627616fc605301ea1aa07fd3816dd9bde7cc68d2c8940ce0cc3c091b25f98e5e688ae3fc47ecbee2c1d4f4bee2938dfd1424bf66b1a52a9ee3d4b44367b548549669e9c7abd035c8df5e5cb4423c8d5e2ff58eab044883049605023d2e3523dfc68f001835b9bbeac48d075a900bc05c7851c1d83385d3db25dc17563f33bb66c4a3eaa434df641ef9bfbe9f2a48db2f771150f394c0df6ff24ef049c8e569d6f207b3766b6a739c5002ea5c908bb9e95e99a3abcdd3dc4a4220e23d9a6227f6ad3a399f471f19a82f406e265908dd5007b9a9cb9ae262a3b13779d3dd28bc5160f9e0c00cfcf79973f1e1fbc0c6030bf451564639c540a53aaed2ae1b3cc1c950ef3e4992a6ad82fa2126e83964bc2f62c5563b9f068387fac9cc13d303b72bd4baa415d639df074e7b48cd7cb96c7a57395d9450fc02d3240f313d06f0a30b6f0c43c17532bbb4053d859ae15cec8b8c979ac3982814b2ebe0aa6d5b3f1aacb04161e895ddc28dc46fbaec9fc6115f25452b0d96ab057459628754d05781d212d5df5138abc22180d84a4986b58672813f635de0dd57d7e45109ab721949aa5e01efca297e60fd582722a9af64f8f05a9f796d7a721b3357b3b85cf189a8b92d270f666b879aaf2adf0b5455d4b561be6e66d16eb5fc1f2677a4e245ffe45d25537780348cc88be7f3f5cca0d1e3e1a5f01566c76b6af1ff76f5e45274a818f3dcea7be53da63ed3b7fd004f0838e221f4cf96f36f4f929217c1d97872490108ee731b3b1c0520e2a3115895b84ebb6efe827db3726eecef72d248152a47ddc60ebfbdaab14af091f5c6bc1626f993cdfe586c2eeae4904ac0c2b325d6580b030bb6b8b61011d2c5cedf7b80d670d6b3d187ae14c39f3331eb8dd684a1176510ec3116c88be1db60d42f499351383770adc7a4fb7453d21b4bfb5d19d57b0715fff8a555f6056045382e65a9777c7a1b52ae1a97b1776a34493d0d961596f4550bc4999a406cf6cad92aedf723b34e8a6a5b4d21af03f004d67d872ee234d3644ba4eda823f1997d36880318fbae37c9552925b3c0d2445c3a450c5c0ef8ab78494207b0b740174da5945803d55217fdd8187d711e18e0704b71cf11b86218240804f88b728ba82e8519c4b68453c299ddc701873a2b6d1b6cc68bf867845605771bc604628857d815d79f9645f1aeb9753eb5809cc3c3d4afe046984d476cc7ee6f7eaaec03615ba2f4ec05b6be6d45cedbde02dd9d3fde184f61ae946219bd6635c5e54508fa9993f02245f40ab8ae6e7e4cd9430c6927a5f1e7c5a6a0c305aeadf3e29e1530f7a3631520193c20c2f89cf0609f6c47d6d7aaf877dafebf9ac4d0ef19432af894990852ec340a25b34c52ddfa8d610a41e22e72e682c46b0e2a87f1a631643ae9f87d2f90bf2d1e714892e197b70f4247aa1a460af9e0397b2c105c04c05dad6bb546b627c6eec08e562f53538a14e645cae61b10d1b50ffc23ff8fbf3adab709e95af299cd9355f83776699764b3a3ad8b06e65b2f14897e4b832de66b9315ddf1a89963df1048f9565507bc6ce0c001672139b88088e80fb1473c17d556ef3f91cc78ea708943fddab2ed1102dde7e88fb50cd671c73c331a6c254097f1770d264cffed85a1234176fbb87f8fe46801cdc1b084c9a91de2c64cfb0960436eb1ca414b65923f4862b1de967a682ba5b1350ea5523c8c93937758c12b222a8cd265a55bc3d8fce5263a9c37fd716b37332478eeb713ce3157e19838cf73ca926d7decdb81b8235d9ce0bf09e36e4797bc9d83d2f2f482ea675aded583f4a5f06f8ddae7cb95765b2339b4796d9d3ad523c5343b7c0ac2164ebbce0ff5d5127176c8c36d0756c1ca930f68d1cc933ac5682e19bbd908b04f533c919795934d2ce7e027c626a7c4a7b635653ba603ae69b03a2cf224f515ea35b1e5a283d93ba429447b7ee1d991f29ed26c0db7e9f851c71e54bb958630fbc39a269c2579afb7eaae96e881a5d2bf81623d194b652b9d4586ae070df71013f3f4d9ad672b3bb42586586096a450845952bafd092284baa400519005dc7e134c4ab90487127551f2dd9e24e9a6581c6c2faff51e9db6b941c5f206f61ef1416f1a55611356f5dd45efedc390be22a07255eda44490acae05aee694ad96a899c509550060f3bf11a1f10e9d7795c36131caed0be8767712f6f16cd00311aab6fd3f0462788290c0834a3a6daf7ae2fd3165a36bdc7e0e5e137078343632ba1db8e4322b39d9f3b281d31ba849e2b9070be5185781166d957b3483ab788a9a904ca2016029ec05d227dadbc0521d21ab5d0d395546ad4d25f668dde1de4daee16ba97c2553fccd55b4a027fc044f2ab240127f13b2410968214257e71aa79a010fded1a3ee3aedd1d11afcd3e72966549426f5f92b867a27dc5cecc030cae03b7f06353fb8d42fe1f8053d8a72f91fcc46e4f7a0dbfd2b18995d85eb6aa72feda365d5b3b982fcf273737ace99789f1c4fb7050469233ab720091148e5c9b9ae57db3793f8fdb398984219d2facd3babeba5d920de8b9100e2fdee2ca3be3844196f666d3f0c403869cba261c0208354e02f7a0a0951a10821968224007096cb07508080fc8c849745d9f5413246f4eb3f4c991c3837083ed58a8ba351dfce05da87d301cb682ee37d67c24420af2b4dc17091dbb9c88a20f480db5a5c34f1e18a343fe56a3c9dd6c8fa5280f69a3e10aa28dde980bc8ddd7d385310adde5f1d1b329dbdc945aa5d4216b63436d6143241ceb5da0ea8d931b8e88527d2e609ad51e7aa0ca392bde657a55d289bb96911b75983a07f2a5a0a16b8e5da3d3e1df05c0f0bf2bf51de0885fb507447848e737a08637ea7a848e555e53b01c54c8f4d82f68dc799c10da3c69faa1209b35ddd86fdf32f3eef24e1623c7a02fbba28fd23bb73791dce5c3262c2ab7845ae398c88a4934ffe7ed3cad160ae1b738505fd8081ac9d958aba4d152e7d249af05e39eafaadea64eb6be3a9850d81fe4883eb516d91065066fd4f246dfbd9ea166ba95b0319ca8d70aacd3f306e8e31c4ebbf71f8116b96d8b52a9ffe41f6019e0bb1c3af91aeb6ac34f6ce63222ad0c77d7ed7b8db33a93ea4a8f1004fe366a096352b64b30756a9396801acd21493dc104705177aab0165702ec7d3556829b6e0cda855d00fb1abacb49d9f84d1be6f4f20fa4b21d7a8edb5af2fe8924b5354c1f4bc7752fd031adcb22f2d90944a9a59a650b9a11108ef9d092fd6c29c3bef904cd2cba555d74a807c6e95e2f1b1b945a8395cdc6db6105a193bbee6e2787959ccfb32bba14bac1510d4b541f521bdaa19dc95c7973f9d35d9aa220bcd5e993db08c19a6f69bb42763d0577bf9fdeb14677f818ad656a361a197b5b8d255325fa3e10cadf480949d7a7eddc7123bc4e5ba12dcb8ca8da0e6fcd93c121c8d7e4b6e677e75b9a9e1601600e45a74812ec93873462f2127a76822186ffe4dcdf735638437b8064c279f25c6a81454d7609e669b9e26fce7352605a3006ee4ee4a8b5db155123490ced1caab2e3166b2e4143a4f7aa5e2216f56191438561ea77f3b3b8ca591da7f19a441a28c538f0cf3bed28ac1df59e40c97898b22fefa9b0f54cabad5781e5ea5c6dc43d6964a1925cb074d9f4dc7a2acecd1583cb83cb4145446043c2593fb1c3c5aa13e16705df7d7f8f75bcd55b7c6922f84c11f3cf2ef3cf2f7caaba51d34ca24cdaf082e453172bd1a615aa31b76dc0e295d8e1bb2e66d50942e52e9cee6439b3b49f6e8499a4fe3c79d77fb0cf233806fc897141d3f8e6353fcfaad39e82a44c363521ba7aac21be1add3a9c31b81578a3379bb53f999ebf7d97230faf7aca7b98f6629fe2c011702b91683439f4946b3177c6d1d4e580620d75440358abc6bed327a5fcbc55fa36a7b0c30489a85039fb30e12852fc2c9b18adcca5e49505071994004ce7ae0d335db8c3d8a0a69d0764b217f1241fea1e05f795b28df80a182990cf97ec974801137ea5ab25abfba4c2c427d9a903172c96a1c1eef2561c3c96f7606afd3522801e798644d261afa25815a81815b6d2656e579c403109425d9d132c4002c0bab77e22d2194af77645b039128c6132f12db9a7234651827beff702078dc77a610ec132957c28d462d4e0cd09b6ef4af279ab44decd0d2259d27cb4632fce5271148079971a3ae3260f6e9458360166a7ba2fd18bd04effbb1f47aebc8e8a5da0db2fb0480d8c921e28b3968489ac9fe54c56113350ab418f1ac1fe113ac0047284a39700969e576fbaddd0c31924e28bc60f21878ee2e5dee98fa04d3ff238c39246e9dc8d3e46c748c2e13bc69519de24b45e2adfeb32a300c14c9a34860ed808903f008825b554fabb94098cc997294c620375e180246268f1df2f0088e7f2c1fb874f3bb3147eea95c04f9e51b1ab1df442093ec47e2bd32e0fc48df27a8e51094ebe123d3607f70036c5cb96f3539b64c4e3157249d4f221d821c0222feb7a1a78a4ff2600b45d23f904ab9f4dbd1c101f91d997483b148e28f79ae33ee7d4d83c5663b1337cf9feebbecf9ad917c09f194111ec7dc3ed46518c693da951cde4ceeb493e14ec9434e88e7a56574cc666d641563a168408a1e74006f8bb6990fb57ac9f3b7be7273dd343f2a3f0414e991b30c4e16e97fe2fd91b24d56d1a33cbe47c787d8fad560ac5ebe457dab3eb29f0892aa09e60cfda40ed0bc685ac1763ac55d7df1f8b8483c54fef353897fce861207a0612549ef6c929d1e31bb69f41393ffc04ba53416f0fbe530060a11537d8abd114bb36b902a099acad31550251e79e1e0d808cbbfb02f15f116a3ffe71ee23586c57d3cfd56610c3a9c5862ae0191907d813a3900e52589fdc81705c0148e429887253658638eccdd0469699e0e82669d5c7c4d558b71908e3fab1ca96d9dc59bee63f99f15f1de337612fda7285ad114c3e69c66cd396198f909f98d97603d6d98b6681984efe28e14c33afd47d53c24c701a460a1c0a98c57a084ba1ba1adca5a59fd64d184615fed1455853733e0220da314ab06e4c6996f3d744b92ec3a60329278e37519c7550aa9fc2bdb6cb39ef8032e2b81efe91399dfa6877b08caaee9995f8d5a812b05ca8b92bcd8d1bbc0e12472af70b523a5100d910ef5b109ff0385863bc839996a0688e87df0f239c54b31be645223844a6237c4f1c5f1ec1404e029547365fc6c165af999c0423a5c7591d68a35402076abe2a7857ca001af067d830889d29ba57687d6449b0c3aaa02b05db48a07281187484e2dfa8380b67506749c38ac6210fc8f488d69fe1a1519c95556a01c15d382ba7d9a6a06e7caf1f4da8696104c47f89ccf5be6bebc60f4fdb2627ea879e9ebab93175953a63d96fcee7926f7135b2ebe6bc18c06236493b1b8c256607a7937845e1235dcf1017776323dbd69c5f75f101154f0d440dc2db1ff3d24fff7d15bc90ca0edd66579243edd1ae82517004748839dcdb23b49f72a2130922166d3cb84bd6e6b14a4e41e5e740aa185059540ae479d6f7323b8a11278489aacc3ec3f92e170a6e04a3afcb4df55252b8026b13e10a6553a8078dab140b4ee4cf84c52025fca4510002d428d05f04b67ef2d18bcd1869c146b54549fb7adbd2bfcae778dca00ccd0c488f850297c2cafd54ffa726a61294da3c4bfd36dbb365de12ce040fa4df4c1cdb93367e5719a74403ac938b93447f5e00bfb4747a5e26938f69cfe573f04815ca3718dc26cb851a8ab45f704f44007425d930d658a7d06a42682f9ea298600486d542186fc95d10046f77dfcce59c99aa423e495c58ec36090cb63cd5f49db061ab172938d438f47ab98783a938d9537067bba1328f28d9a3dbe1187c4800a7a7a30aafc6fc1175555462b3d5e00783d68babb9f2f3f2b5e05e66ef87f894365528d65c36897020a00793e9c11da16e59bfa94d0cff82353a21db02c3fe7cb5a5298e94c9f45ba1bf95499eb72697b01f4c99befaf37f2b4ddb9ccbd9c158983f3abd5d8e7554ba3108ea93fa8d569ad0e64b965c39cf80aa569f7d43cf66607110da2ee8ac751477f9b420b0d3a126cbb86bba34fb32017651d41609fc8e065f7262120268f5e2de9c31583d231708b830c0c643a39b392a79ead5acfc38a61834bba4977638380a97834ebf460be2a0cb3103408d401f34cd851d2d53df0bafa8f10b4da778a586d52e03f8f01a0e58fdfd2d7ab8dced0abd0d33fa6d978a81203db87f41e1e596e2c7ed10bb4bdfea96dab412a7e421f8770feccb8248abfdee653e48460718373fa56c9fdac02b00c03650127a920f19f5f668f17f5eaf586f5e4b8fea6ee7e284c3abd60a544b66c159d92f89590a95daea0419703da2f9a0788ae4058c06c272bad4c18943915c35be83657d82c942f5603e8b2ccdea3bcd6c3b0021e591abed2acada009d664f63e83475813f01fbf5f6c0008463a9d1bc6bc94665b66eb1b72287ea0fba5ae81a73dabbda3446d97f2bf2568ce050b1ee153e436eef6b3fe7b363902d9a4678d94420b1fd0e18987d8cf78b5b8d863d270a12ea40672ebb4fd36cec419be3ee583a94465200bce4008d988f2bf28f487e60f72eb29a33c8fe594e95bead780fd55b5c519490bc520d3b5e665c3a0d212998fe88ebb7ad0b788b438f664711c224dc8be76e87478373ed2c0a2f4bce6cf0eeb48d030d4df3e47e93304ccaa4811402ca1b960d81250157581e82ff9cd6f2ada9fe56ff01de84e81ef67b075e562669915dd7667c7c268671dc72c32edb60deb0ad25d018f22084b7dd71536fdeecf212d3dd780998adff84742723ed63a05339b00b50a321d251eaedd56eac50d630cbfa617ef7c2dd23def0bcd9ecdfc0613e5e97e77fa32469ece862020654558227583662db6a198bf987082f3045d6d3c6fd0dd59575f3bf0e9caa059e59e294a2e2d9a83e16c175b1b81452cb4b8afc2f38d15a2f2b6c2ceca9136aa59ff1f8be3c438df084c126184e19044a95c7f751e7bc48e03c0a1922c23da53c9e11625648d05e760851a9b04963fdfa82d60cb8292f2146a90472eaaa293cdef4fc9b1df5326cd61fbb799f691ec4f16bbc7b2aa4352d28b09b4ef3afed3b4ff983cbe07a0835e25a0b5c668e2ebe5a179c4ce079b51bcd63b325ec38f2a367180e3c1ecd9c6e4cf44cd08cb46f588f35da05bcc57fc604e1e310c5f16fe1b04b75cbfca6630781d463d65b99e001ce834e49950860b4a60302d9fb58e052d5147127f1243d99410a17e89f26159509747a43433bd45393063215a0e4b50dd367a4a061e9f6abff3d688977658f9f59ab8f6241bc586bc91dd092f07743d2a6d34d07afa121b3e0b6203f4fba69fb80a28c6bd2a764e384e9fec6d4f6a367c08344e33b47ba5650c72e7c04b39ce2fc80fa05aa894ef9ecc69a710762572a62519730e97b279b4859fdac13718d6f191ee849d96916e830957b02356a6352193259dc8c55b270416ea82a7274a03e13b48f4cef2d0431f1fe30a975e08be627c946a38fe50ffc293034c5fc7929e0c934f821de4d4d33dab1b1aaf0a235916829c03399d9c84990850a8753c38ea68df9a378611c5fe3e4d59b36ef3a13ef2fb90061943909e5ad5c92d3bb72fbb983b6c6b9be35b80f66a34c8acaeb4e77d9f644e421d4fab9070c6035077cc4be04b108c01d1a1793c7cd3764afc1bd606b4f6ba0066e51b84364f3a80d462393d10dfb8eaf3c31ad0f78d15f88434b8384714b5f1bcb092da475971be5aca0c6deb0a0e0500837639371d0c4010474926809b2d008bdcd54dc9e4b15203a10c474a8eb6ac486999c30350cd4426ada4b3c104084b9c39021b2e187e4f2c5962e0d33353c0fea7cdcaf5eb2e17bce16f753f7a59bfa4137e6a8e9b47f8efaf759ba8db611eea0f83751bb15e8212d65fc6a8cf11ce829ddd0d34c6d363caa3f7a73dcbb37204ddeafa3cb94709d4b085e8e2dfbf1de09d559a6b5f3b19aed5b1961e0f2b35ba94e3711f3c0338c2eb4ec23bb63e486df955012ac32f23b1910e1a7eb24b2e14eaaf8badb95ab20a92251d2dc9e98a1d94422f6938104cc330ed6a612c19141915d2699a823290ad6fd9311cd6739e2261902e5eab1b2d17a64c4b0d4847ddd930334c3e277d15801baf00ef5b186e3222c08edc2ccd97739d25f34a6bee0602fc87783c59a43524144338980ba59fe8e41018bc87aa0496aeb08cc04b05fcddd83f1b3f5d5d7978370e67be93cac5aee80684b0864ee00af365e6e3ed83ccb7dd2a738e432eb2768006e4d6dc9f2816681c5de163ac8b10c35f18453aefdc2c2a0bdc9a578dc2cea27fccb69edf6602820c43eb8f1916dc84b8ca3f36ef22ee7f69660c532a8f97b3b26c890d94c4d5c53e5babd944e052d9a196d4665066fb480d8dd854ccc57980624a17d8ebbf0f45ff513bd19f3bc6cac7082fb499db41dcdefc82489f7af2107f626149989aae95f1bd12c45c01ff0477770da66c92af5cbdbfb7224352892066a5cca7b55cdcc9d0e03089f9f6a25f690772a7bfdeb2d88681ed35034dbea246a691fb29f5bd063d38714b6f2d98da5e59e5afe7cb04b1e2097d212918b9434565afeeb357180e920a2a02a96b2dbe7aa66646265ddaeb8fcf4274ec1a033e1b29be2f088e1e228bfa1b2ad7ef5c5d53684631d6e2a12aa37bbf766a3983754331b964e49b3ccab578ebf9c9844581645582a5fb8d3ae65061411e38c82894d4ddc06afc1e32cf9b276a3ab9661ceaff7fe91906f0d831e39d17ab95d9917cc12582d08e2c08946001d700bfb3632fa1a0c9895b853ec75997b2b6cdca5f3796f58c742d96fbd5b58a72f576018bbc1fc6290e4d4c260b572d76bff951454a08f220694260a97d16cfd697e19e263f712778b89928bedf8e6d51ad6cc8eb321760c2d7306e08d631ec73059fbdb99ca95da7170a5fa85b7d6660d04278f456cab17391983436d2dadd87ddd4742b1fd32881fdb889fa5c47ed84a6a8e0353046a70cf45b7115ed84bde65ec8ba3e267ba1d10ccba663c3be2f140a7201873cf005ef5b9178acbec0668d01ddffeeed0fc33e0c402e02a853fae915e4b775b435e60ab85add410613c60c0e925001254c23762ffbcfd0415ef0633886f790fad513c832f33ce45160efe783e9bf8afdeee2965be161e7c4399a65f5f1bf761b086282387830bf09cf9141bc46dcff7777de39ad0244a5356a8932c29e05e4437f7da8b550b1d427a036e39ff27643c04cc1dba780c20b3c235d6af72dcdb7a73dacc4a6f09382207d07cd96bdebad5541f8c35f41f301823d02f10ebad738b119fd8643acdb5a48eceb7632b27d00bba8e67b04ac7d50c19e81c0957211fb73d58b832c29361701122b0863464cc892ddbd766d26420e6cace9dc1d240a6cb78f556b8a2850f31c90018db05354a02132ee2853c97aa374e4fcc15d00cc858b125699157e5d116017099b0005fff7ca9e33d94b1a344a9898cae7ca8f685259b94302a3a09c3b6ef3a73b4e34bee53fc221ca77bf1fcc8075896edd7f517899ddddff93d915367833b93df77bffb4accf148426a086825cc955610ac7930d493540ecead16e9fe9e0a304b09bf8ba131d01581a43c35a63978976e0d6aa9be38d3cd75bd6b0adc9596f146c8f1e78942283f253b08cd81c15272ddf207895007bfd6acee11765fc94aa00a9e4343309f5c8708c7627fef1f3d5a7c79b8f50db57c1870a594ecc6668e5e163392a2413ddc537f4978d9d5fc1695a4564764634451e4cc24a0302c0bb3e776c863b4e03182be55708216fe48e5d1f2bd32230802b6584a039a57123c9c2290c3b7a8ce70c5b534ad3fbebceae5aea11ec0712bd99ba956bddaddf14b3c2ee1fcda87606cd9557161f29f1720c2fb4daa91b87e5cf0aae447b522340af7ef0e8f18556d98f87e1716552bc9290c777b1f9853abd89e392e0fd4c1fa7c907fee464236392f0651a0eb04bd74b22ce42f6c0cf61b222c3a1ec03d1f570c9bccd240d4e7db1224a5115036c85f9f1170df434ea69fa111f900361638820c78febd4b67ea8a80478e58349a97c2329c944157ae10cac47f45769c78f288e5f2fef426b02677723186f2fc5603cd2af3f6de511d0baa33b7a0808a9c5a0bac5543fd0c8ea402cd70e21a71ac0d870094ae5b6a00fad3a9d8443ff037eb1456f7e7002c568136fab4ba92126ad42f2afc9b7224ed5878ca5aff5331c961cdf9feac510f529d102e769315a9b914a00e967b167f3dc968c2e978cec1618c2f1700552ce276d522cf82cd3948b75e11d016cfdb21fe177c593e0e6103225448320e59f3515c7e486552f7efd4e774f5e1c567a0027a43df36c9adf375606786269f39f311ba54165a431923f14ff44f6ac9c1d6e93f30ac0636c7b0f5e93ea54fbbdb0ebebb98262ae1b10b45822bed47f89e401048aaf471925c51dd29b8bdc29f9ef1d36344e3405de05c42664fab50d5e3a73ffc5253dee1ff7cc289a74fa294a87235cccf24d5e33c3a8418041d66f259308f26200b9ae33285066b49516066f778bb67f11f65cef24550c1aed3b18abc2444a14b4ad16ae42b84a10742ba258b45febbc94c547a8b380b63f4d3f9d3bdedac4b73187e0d9dc4cba2c68e9f1b7d406e4325e36bfe878a25b32a8058b6bec3c7392215e7ab4d0b054e3326970059ab2ec8249e16cc1dab18a2615cbc5660b17c2a4c10b4cc9a0c568bfdcbe84dcb150dae9291edcd1cf137b366cf56627d1e34547da99f9aeaa0d7f6a9acbdf5183f5a195cf524f0c85387641000c1e43c18b448d6cc952d4398c87bb881cc0caa1b9c4792c599c96af982e4b1acae42d81fb6a4adacbffa1683c1a59af8eb05fa8ac431c1d995e1cb3763d09101ddc268417181179389fa987a274e793ed352c5a71923668fe464edeccdef77f012fb1a7b61af34e93037210698854818bcc4bacd9c9308a8de2cd3847f355eef772cb2b936b4a9bf00b3501cb29d5a7a573f549f4edb49a16b732179ee2d0621820b7939c2715ea3035e10b48cdfc65b6fbedfc720216dc2fc34f8aa32017ce431d8e100d31a55fbeee6769d4615228e51e3864aa79348961ecf71bc58e3eda3f1b53fb2deb106efd9df1ada13ea9f91b4b794674127add9424fa2dcdc059b5d413b64265c366d332af41e24c2f8e225a5b9f3094a725d92e95edbf38c432eda211079981575f338445630970ea4eb34d29b87e3da01be985a23d7d535d9db7857b7fb3fbb0721af3f6f994f58c1adecf2077ae28849f83c4543cb6889cbcf96a4e5ce6db5d701c7bacb9f90de4a6c02f553c4773ad80ca084abd6e822a3fc171f1289b1755cf732f7768bef4a9bdc4389e375ea6f88bd4906ed0d867efd5efef249aec27a2ed1ef8cf47a0d9e9b3b41432f70ac6b00e538eb02708884bc76986928db117095d53b10bd27c1ad32d5eece924f5df3580afd4663df70fbd47ed042cc6e20c7a74cb82106b5149a9f77871792e685a355a6314a3409e42c1affc499343685a9d70195960ef56c953317513b592c8958d91835af3b88dd09feb5f07de93a39c8c5fce4a05008eddc06af1e67e8a34b9a7060edb9995258cdd9203b5c0053a7d2945f3d2f809e24ab4ca5be3459dfb6e4bab598b7c9e9c7a456c7aa1e37675a3eb6fa5da62da24a353c300c0d4e75f701532b2b8f161e2a17edb35e7753e9ce9fc9e5ca9d7e390077f93830b1cd4f32c5a1b9a7df61ed10ac35dccc726b7f08658b80d0df0cb515600efa326398ed7dad88b223e80d475cf54eae0b0c5ce6f02a0617deea4de6774e573e39120febde99503f13ce1f55eae8062d86d5a8b237c2d9da04b4d1c72f598ff8f43a4c44a9962d1f6d924a4c324b635a75408078b6820436ac6436d4e2cc1429337b281b2c501b3e6e91710c7729ef33132f27033fd84c0658c8d03ff78b38a97dbd93526633dd42ebbe442ec13a5f3ca34232e93882f6eb8cd2af542ca7e93d74a0cda6882eed15d572c6b47da0300498deb20b5793676efa1c120363430ef256c967237739bc5baa346bafb3fb8d6962d0d4d4aca71918790e9caf880e8c3b2b5fb79ab024c1f33d13342943fb2babb5fa5796778d6c1b4cddfa04c6293b7adf32c0605a62dbd4846f1a80cdf29fcab68fc8cdbc0a36730a9e389399556b5fa53496dcd5db5e82ff5ceb54e4d64ba1dc35dd896fbc823343b23b6520a34f52eb7edee660091e2955f08e03f1fb82be57f729e10226e731e9972a1f62657bf9f3328cdfd8417cef43c5043c780f9779e23ab4322b35da25e484ae27100e56f7bd095c3507abc47a1f7b1ad50607ba92766b31a44be002a43d360cb37e294df8b9620ad8c254799773af9fc5f351a72f5abca4b2385628ad60447797796ef31eebed90e949dcf3152199e8430fb77a1b1dd0e3abeb5976831127d1848edc79b67bde181a7c0792a08372955c7698c5329032b6fe2dc351473ce512310c50d71cde9ff3024425066a8122e3abad3106f03b0497b6d854892474c5c850812f30cbbb0cf12f30da89d75ba864cecd95d2dc7216347c74efc530faa10dacb9465793ca439ad858bc988ba42a5a4a7c06237fdf8ee24cc72eb1fce243a76b5a843565f5a494dfea35888732d22952ab54de689b39ecd9b026","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"24a01070979cfd17831edd7a5ceb7405"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
