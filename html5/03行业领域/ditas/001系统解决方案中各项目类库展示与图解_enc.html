<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"406d95149f7038d474da040517880d58a9e6c0f6371f8bfecb8f69a0914432212af2848b879189bd7f5ec1bf2ae66f979a6d140fe9a8b2c6dc09ba5305814fe873825fcdaa7a3701e48b34c3691bba43f7d9419a5a87b0cc76f9c73c0410e1c105e58c0bb755e0a7bd9bd5487600f5c996559c9de24c688c21410d219f572b01608b750be6c159a61fb8492586d56dc0b7051a93aea8e7b104812f309ad1cf32c93c537a4ce0794c0fd9ed409e914346f01a9c9a516ce2746ea96989247e5267ac41cb576661d022508d72b09cd308c94678ba0c1e707963da0d1b0f6f0eddaf141b263929e49f2b2e2c880471f3b3de9081bc76b236937bfa5e1e20fbdf94933a71d02ce9ad657276abbf9cbc7d0aa67465ea3aee6e2799d40b9cace85fd681e46d5a5062c8aba7f05586eed2cd93b8f0812498975aa19931c15e64384d874dbca68e2fdfd697774413347c8a0ce3774dfc502c601034f6dcbea7c6109e1b49415e6a8b25fbdf8d5a47768e70216ec5d266916d2d3978542520790b90314e11110b882dc7dd948f47d4ac51f3349a8569d1116047972cd7dfae723688ee7189b08e502d15b9ab3cc406d2be6f078d6b8af819aba61bebe905edaed11b11e798bb70c7f9beef32d60e8bd33ae75c75a3e5ce6508222d20c6eb71852c40881ddc4bf9c24ada400ad79ff0db98a5b3473091556b8fe239d611165a0e31d26695d22803fd7928e00b83782cb60865c3057ba9f44fcc3ca28c02b5e8f3d39136e098b78ade65d52a694d2def1ce9b18b4c9dc49e13505c820fbe8a25d3d441a8827ab03e14989aa8774690a4f4e5281c6f1c6c9c6b40ec6bb752a0bafdecd4815e465d3925257158adf441979efb8194906631b544a6cbeee6e1ba4edf9c67560c2cd02843e477d52d83aef042f48215ea412270f96fb165a78baa3ed1f9f7d4bdcdd67fe2b492dc40b4c153362320eee7f09f41d97c0949ae67a1d00ca99ebec2c57d613b608c88177d7e48270dfe00e4c800e2f8136a292bb69a6b266e4a79e2ae4677945cc545f708ca718ba8ff6312d8de404c1501e81937bcaa40cb898ac7a8cec36418277c8bb8d92e7ba4fcc165e25e3e30f0c29904a48e49ce0f180c2cd168a2098c0acee8eca21cc4b801d6861194cdfebcffd7db02329e0f0cb0915c1f33355f13a8a6584280194a4bb20e88f5e8e1a03072b45e86ee950c4d362bb4b14eda3ae71bad5c765eff54cdd5d53f653a39eb96798df05806ade01fece902da0be10d2ac99f1d6b64a53ba7677704b651bd7eeefa6fb28a3cd6dfd951dd3407f9f8dd121b2f7f4ac42f0839a60f84214c9b5e16fa06ba6c46f559174e777349dee7f2de9e06422956fa7eb982a74fe426215c06aab4afb0fe307e652c0baca4c871f3fcf5e94d66c1a1c950e1b82508a6c073b8f96f04a9a57b0b05e465bee1d1019669bdbf845ff796c2f5ea363749726ccadf1c6c29632d14e005e9728b67f9beb76cde79198d20e8e277bbf2a3ac7c1823780168c89f9186b5fd2dce5474cca4f0be2267589e505c453e2361b9364a21b502864f0c66d5ab93daad2ef71528a6cf8d8e3771d6465acd74a077c164edbda15c1a19ae28c6e84caaf6b4eede8d9d143a7d3ef06a50e09ca103ff537311a9686e586bbb606bd730d5e1f7dd0cb4d5a82d3013fd55dc668a2e84743d3ebe859c092a6fd6fe3a1d181a28a66b0ea683af39c09f3ddeee7bf28eac3f1735ecb1bb4241f1f2ab1cbf1cd127ca6e1f504751f7cd058f7671418508908daceebdec1c0d8e53a5b93639fb2c71a8b58a9e600889d4874205e907a8ca1384679f07a9cbe35b9319ede25b31736a21957bd871a4d77350b67acffc3933e2d8fae71b9b181cef5e7cbc8785565439b69d9e6e9a963d8e91b9719ce77bb4390c20ada2d7daac1e489af3811cb5388162e8dfbc3cef8619c6342d556b98a263589bbdf8c96b067a65638e1e721eb48ead7fdf880f916c7b3f1142f97fee8b2fc28ea7cef5bfb042efcb7ded4cd1e247b58b66744e13e772dcf1ead871c4421a17ccd4d5c8484b476eba2c72e33c5618bc7253c3b38af5105767188f1ae39c3e247f8fbc8fd53ac54e2ed0828404807771523a0c45ccd4c3ba51449167c8726fa7baa2bfeeee5a30618fa22953a0be9aef3dd2cf19a7891b924435463191c3795f483d4f8733debe61ce6e35c9a05cb34323cf033b206796b47c0deb24aecb8b9cb3802646cfc902eae4070e1286a1ce72036c8d1fe6cbc3cb21be9b1d112690cd2ec7145f9b7c22cb84a8ed6b06cf5036df472b1e6763941e15e4d554df096ed438150dfd348239e3ed45b475225030625688e59787e3ceca73e58348021a0a67f2af2be381235be5adc50b76834348c66da22f678a11f2ed90a3e63122848dd33ba629d8edfede6c45caa4c9e39c94a968f89783c42a833aab58151d1db0fc6a5fcca4fb70354a9fb827420c3edee0134d4d6ef9d7cda881085db4244472b48e200d0b77873468731953dfc1aabcc02c2c741a38942d22c1481bef820c0446a7e995bb73ed3b92db06f1a192087b2d5e1a55f2635b186db11ff13895964c6f125f775fbbd21edcc5cdc26f9a64fbc74ffda6fdf3adf5d8c0193a7263afda05f884cf24fbb636e1567d18d5c64b63b4f8dd1431515e41555e4365b9b3250a977376e3f7988ece027ae4897f4af9fe7faeeb7788b6551a439b9a4d2413bab66e685fc29915e4fdedcfdc198b5c1b1644415389117a0d5ec3d9f85850cb8840578f783059df2d25bf58036b0c8fd02c3dcf92c2e9d085bfa805cbfdf9ea80f63b1014b7b7c4156c7d96bb88a151ca07ec47a197b02ed1169f23992101f79a8dc2be25bcade4a0cdca1a6104fd5bdceb45c8ba58eaa70360fed5c36c766cc3e974f05039ffa2a4d272cc46235c147e2dc88af0c26e469f3d528ea5a03745ed971c9c29dd00c3a55df4318b71e770a98e4faa45924f937c3e892ee345cf2a38ad575e4f3c501f02e4791bc082f4b45013a2fb1d6f825289f269957df51bc012c54e3d2f49168b0a2eafb87caebf7f4e84edf96b8ba4cf83e1152b61dee8a66b8cbbb6956093b9fc10fd05e291c902c1c8dc5bab1e6796e5c8de579808f62e0ca580cabde217d81a947af81afa1f5a56fa3de3f83f0f30a01efbb1612b26c26b92308603e9718defea38b870144de317ae5942fbc4eda57fb27adc2e59011850874689c2cda8281eb8ba0a44a97aa7c4fb9bced4c2631b52a110c503b7f90fd5a912311ba9da7882e6b0b3ff5b4d8d3f7ecad884258010600b8025b7e0eff4fd2ab1c73e8bb03bdc2d10cb95a4d063b514bafd126301683ce4c191509531155b74b3b69749dd5d41eeaad48eef3414d43ab1b663906d716cd9d3b1c61e8cd5781569c7736f9a940a6b092156e8981b5b54055d5a2e9ee7ac9084c118d4354308ff95c7aabad4fc62dca515688d0974e36f9a2a0a63ea09b6e31a2309891412bc4cb9b766b89a87c87645e34c1e7b11876488c94d224e087428b4a34dbc006171630cd0763377371c11778c9fa3b363cea5879efa490c80f71f09784b396ff390488392fc18cadc211065c25fcdc250ac9deb979f76c56974043c495e90daa0d325cbfc6841f8cc9ba69de67d95ae58a94a2191355a39e6fdf8b4a3a6f48c37ef8a7c8f11ad3879145604d4ae549647e83a6e64b9525b5ffcab28c4b8ba0c8d38d8c5fe3dd4122a9765d846c88ba4f0dac763331954b97725a72db5161259540205941d10b79966b898649eb83b1a99c14d66a112045b82556e8c2c7cfde15f1bab2f003b77d1d46d2b64656ad23e3700282f3c26934d251f556671deeed5a7ff424d1414f539f6884d0c6ecf8a0505c01d3ce3f7d4c58fe2787117b2e458fdd8d79d637d268be048a3b06500bb4eb784f93419a450baae1a97acb7dc892907ae044e5290c00e2ba965617fd4ab269c4f946477562e71021126aae1759e9bd80645912f58045c8f61105a0c324dbe772bb785c33f8de8e0d67baae8ca7aafa9c0fe1cb0e7dcdff9cf045274fe562c4469116b05e5f29e2789171cdd44d6af944c3d585e8b7c652523ba0ae4762e45e41b65ed2a1db29e0718925a31382bc1149b552665328b9cff765df966f49cf6139d3132669f39c864f840dc8345af106bd9151be5e15f726a8a2e05640ce8813d86f8362770d3ab60d004955572a2baeb11874597f40374d7f083a4a789c74d07ba979a00ea1a0a1a2e2787b79f4e82e1cbe43f76069a7b2b49b02392cc0523f04f10a96e012b86eb5feb3f8a3fd03ae5d9df2a6cfdedefc8458698fd7fd5e4e97d29652f7cffe5321b2ae4d6ffdc33b84ce0320b4a92a1dbbd43e4b4ddd2eb84d0f75e36094db627d7a34f71b1e4c583eda5baa10e82bc4c3927d30be56c275952e515265c5d63100a993d70a97e68f6adf05483fb09f51513475444ad7f66bded3774c7bdde33fa53f8bd76c412527b355ccf997a0c2527bd0fd24d1dee6b29981268e7bfa7c5f65d4e0058bb2cfccf4a6b7d8036bf50f76ecd85ef5e0f86945bf9527ea66dcb87aa484e8ef8467918bc98ad55206c1ad9ffd1cc4c93272251e07e0991e82a5f89f0f377c69fa53a7cf4e41df0880212a467735a7aaa3e68c5e89c4c59c64fe2f901b78cbd962e559fd6a0b906c4d0c19aaf2fc4c75c92bd589c88b6e23cbaaf976cd86965af09a1a1414ea83d86f55be9bd9845c3d48b880ac4f9f029053801a443d209e971224a97f2905e02fef095c1bac733394fd4bc7e30d58140a234fd5e1b0642330c56e79288ce28f5949d63e81108c6c9d70ca73889dd23a13cc1c4a3c2c3efe7d9241efa449e24ab881c19a15a93b3219d8c00fe402933effb7b5b6f31c5dd410960861dcae8265f83ac729517cd394141259d22f4cff261ac5833446de61171af3e73b27ed9ceb5ad271d8a0c131a5afc198ff017a82f04c900f3d1d36ad54f76552e3b24581789502001111b223af0cabeb007db35430010920ba74f609012e96310147d807980ab38daf8552c6f1d844f805025faf09c58baae9ea417ab049e84398050a2bdb760e4cf96db1bb3e8e238e4a4544f44c24f64c6b6cb73a016233df253a477ca2981ff18f22d80ad0b2b768e1a3228a85615968269d48193f75b923e9b9a4086f1c9a39be7abe99c0939d8b2b13c0250c14001af18763de911cdfd52f7a345f7121b06b6ef47e9717dcac31b6db8f3c4e190dea8004a24214e7d6db9553a421f9fef28939fe27ed0fa1caae15318e8d213528b097191519c3ab3376b5a6366c908dc085ebbc91cbc47a1821c9ed141d8f17834dcebd040ef7e777f90ad9fc7b21bfdf1de3f5b7c7656a95e2dc0402e5cc1d073fe0054b767b9b3363afe1794fbe59352339b02d2e32e5852bb99d7ce85e9c042eda24d281db80f3f372e5abff853662fed8f598ef11b2abe09a9ca99d994652a253b5eb9b3aa3d0ebe4b5427ebc59a27a4a44cf770c11600a697171a5ab3566160febe82d6f4c59ab22dcd2fcc08d9422e4e30bcaff75c9f562a3ccb0e1cfa8394e95839fd436502b5d31acd21a9db176bcd7d7f28edbbfaf585dbed78476311b0c5baad0ed8a39953a5111cc2accea960fb5a0d705c11cfddc90da76658d6a0660f5349b4778092827f7997eb50cad6dc65485cdfcf988a92d8f4327e7531fe439e0cd8ae266e4518e00e8f7d60d6f2b9bedd07dcc23531ba07fcd6ba8b85790b08a8c4a3fe102691166f1460168ed394e75a4ec828ec1d391bbaf2fca0fc78aeadf87a6df71f5e2fb91e7a79506f4f0b45c02130a48951420fd6ddd1eca198213426c85e335ca55a50fabea9f746a66e9fc264b7b6e019f198f9e0b16c84d30eab40df305bf8c850b47565b9a103c9fad5b94c7584d4cb66459bf17589a94206a5376e9f524c6f133fcd2ea6539f6b60f7cd4516ab48eaa2e97c3b1c64aa665d5030ba2a184eb1225ad422ffc35f45138b37bba0a5f7b16e6540e478503df8f2e12fce7d429f58eb3c030113e2a0f7ab5ad2acc5099c0a5b4d0eef6842724054f1610c22f63b9685698194a8be596fb8e66a18609a11230614c3cff75d7059528bf5753c0ca799777c8f634c2d5ea0dc03946fe495b5027ab43f445274702b78bc03f5cd8573b3b3f9c10973606bfd379a4b6d10b296905a0569f8e514d5cad5668f91595a49c0167c04524f62334ef78567bce9404aa0e04d8fd5a8cf0f662fa9f03ca683718bab0042c04306a5d1dddde1dabdc2938b007fc1fab8feb3db51c1e060e8e92a0ce8d8aca56892c9b89813589b8fbbd23469c8c9faa8dc50dd45e117fcfd2531317639bb2900e132f862c1054530dc56d094469ee4df7ac37d1ea94e03e2e76b55705f38c684fae92866f4641483808ef0b699f17baa9cafb5fd4d2e97f00c0fcc054ee368be32bdc7a122ff3cd0bb9f40ca67fe746d8d9f66a98aa42d6d7c76883e34b15f6b27c4a9580bb400ecac578bf18b130de11da5463673c126144e7b26b3fe03ce696b921302c9eaa9127b75a4a16c1ebbdf4c78fdead2abacad58c64d42055f7f5d7e3d382ffb8fe2262dbf2841a93ad5d4a9135b860a42b836a75ced2466e89cc70b07c074df89291984ddb16ab5d4bf26ea2959e2b011e6f639493ace7bb28287bef669f142417cc9a59e7eefa8ec0e7bcc47b6b2d8cabfb183f1df5852360db50eed7540aad66dbcd657813f98ae5b17cd823360165e18a08029b95d361025028cf452d754884e9b36616c3eb5de60d85b6d36c9ad37eedd8456ca6193ef48c0f9b5313db3fb5c41226cfb76d561ba33183f8dcf56041c11db55406948c004ef14609c31f76d59b4e769e3f1744ae5b73e640d86c324e5f24993bb9dc7fdd62a312762b5b31bd11f3c23040310d9ebccde12c5d5df1f10adca98d4f3f902393f9e7c9eecf0b9f2f582fc0a35e5521a0cb9bca459dfe90e1c00b9e67657528c98e4f541d578dee2f5ce326ec35e856dffaf3170244017d9a559fd4e79b7d5613d8d159c880eccc77476be7f358a2163deab6f33734acb8fdfa3360c341300bf13a2598bf5cb46ec07277bd689d814a8e8288a6594905f509238d66bc3d7020328e54ec81ed8d1623a9ce18a54f9efb23d3848e53a1e9d286d296ff37b23ea71f17ba59ba865854be032c245c928b4b32b31d6ae","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
