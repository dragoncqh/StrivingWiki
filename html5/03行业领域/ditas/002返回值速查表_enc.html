<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"161c029a4aa85e5dde95cb2a099044c8e739797e56cd53b1f398b81a30f0e59a00a09015e874ac618ffae9856fb2d3937ab5bc1edb4fbc999869975c77fa0ce8b88d529bc90ae9e035753c24f81d3adf71dd17a4fec2885b351ca5f6b4b1e73058216a9ad75bbdf902257aabf75d6509517df0cc536c76e8a52127a19d8e99dd0110c13225d08c675f385dfab31fdb11a24a3e9b6608890fc4035c7d8e945db5d76a638322a28e5050cb0351ce33b0eb2b3b6da1e00c3047bd53201f9f4b802c54b984ac27a661447de659151b7bb4510447ae3cb3ac8edfa0bb14e10cf7d03f94b0a76c9c37b898b13143a671650d83caee3b75ced296c780e4239b5d87c18098e6906ecac1da2987d7c96fbf31892029937afb6776de2e6ca89d9e90c0249cb095ba3609600e3459e2caeee0ac5874289f33d81c60c0f14f15bcd3524ee90250b600ddab5b39204b16f12c0ca8e6ab00ef6909ad3593f6b26f4f598636b11567d376da73e6a20759de13b11e3894845c16f4ca4ad5af665847db46eb987a7f888228c798f85a9785161056412cab28782824b56fe5a6280ea882c3a9d1b2b0455ed38d85251adaaa1bd18eea8ce2f25ae20176291d18c1757c6c3cfb88481832d4d2344211f7124581e4816d844f7ea7f5322b10650d3419ad913fc6599c39604fb8c77fb130d82be3d756318cf6fb4c23df70bb824848fe6aed732ac7739a0d9a64a29929306f5a0240d91944a7310f1dbd72e7553bc27aac5f057ea9a3a1217f5d51c16736d04f3021aa9283e1f35b5eb12221fc27475aff4c85c11061894c62d40f1da20b491c3eb51cf758c6761995b9d34237fb6b09dfac4a5d18b5cdfde20552058539115d9bdc402d6f77f23a697e46b0c75c64dc4a57b79d9c625b4cdafc9b083a371deb3325aab22ff6a697f84272230f687a6a8f7392b592489b6f590a1744bca0613b16ce41ce8f07cd18133ed6fb79b1258d993a6015a56edb649fcc9f49abcd48213fa9acee5dc63b1a832b40ee0836adef15c6c0bc94d6c560c3a4342f83975371e1556c52b9c5ccc90f43d7520e35a045ccc41c77c32187f6c816b48ce119de2b992a456c957e8bb2805c92490012d3a8b93d648e8f9e35e8cf5e8bfa21e2d601213dcd811186ca4d1a30cbfe2e7843616d2333bd43b703dbdd72a5a6ef44f7dc915a3eb84f0852fa7210c1ff2d3a35c75b4e748829db0c10a9a452570238f65cd32640e04aaea1dccba14221d762402704d34b0f0fd173a58ab18ff3ae34d8f9f373288c908a1fff3f8193c6fc451bbfce8bc4aceb6d7fd3a1d6fa80c97a05fadb6346244a827ade2dfe45f015170911814b99a3c27c5b1f8be1313d70cbeb9d54b0698838a0a9d40b9f0a4d7c7506bcfbeb6d386d0d9daad2ebd3a8c5b5de1f9ef8ab14546093acf83ec12d2b029a033e2c745ec85e500fbc3dd0f5e616e50fc80c0f0b174e218acc1f5f642dd61597c2ec2f8e1e1949d59e7472cc9e153a49e5e6a487715541035c497dd1b73e3ea63114d22d5d15a04b0cf84635eda5c55eec2718f4fa7ee636bb2d98b84d0a43b68f1b482fef383204f22b89ee588fe100fa75a533363fe622a02cdac00c168c2e8f727776cc749ef1d85bebac91edcce625bb55c17be4ea9428f9a0d9f7bc0f6630f01c98374708d93ed90ad6c92a7149106d68588fe1ac1b42e109129f34e643371ee24db67044ac6c7031f88ab6ce058fb8f49da199cfa58679a1d63391975006a762f513728a155bc26d30f450fe7cb049ce161801fe1e36f99cf1274b05acf90ad021e3b1a1f624b9e92d91ba2e528bc9c4d457c70b1b96e1aabda678481de56591b00d4cba0ad9efa862d0c7425a3dbccdc2a306308834e92f2266b923810231246badee29194955c0e51123407ca5d0ae0d2186b02b50de170aacd60e2bf6c483e5cdb89ee97d4b4403f37df583937f520a43a35c1ebd092d0cbeb2c1f08e90c73c2a4d50188630366f77fec721f0301755a9844a1485fb2b9ae7a6d059c334f02fbdf13612dd5fe3b9311a92a779ee56ef0efa359e6667b85a7cd9906c406415bdf6c7bfac831ea4c3b3bd6910122e6bdfdba4c5aa6ca0fbe8b08064a14a329d7d762a6cefd4ca6c3aeeb38fcdae0a4769f21601e09aa0705bb5701e447f16d97909d3957633dae348a6b5cc4a8e45a5f73a5d4217c881db8a580a3cb3cdc6bf4e8fb81d115d31b61b688276a6a2d071391779194fcf6bbc61f5be6269f11d409cd9657c5b5de97c0d46e6cb05b4b67d91fe824ae01f3a10558c3727d978174ac43123acee095b375d20148cde9f172ef6b33943259ffaddcbc1fe936f312563da81a660079ef658dcc591686ea89a3e60642faa7e1ee0e2102561a5fd29e97c314f0a1c6a5ebda615a8d736eec14e0e0494edba1bf1dec48e821883dbee652c1507106e7dbfd1867bf7e642b669d308fb46327b0171cb4fe504147c95a683f454209cc6886febd75a96798d50c41b07bf391c2a9b95ae9deecdc9f70d792dc3c18c01522c2be9cfb1cb2dfa0e32d5ade7aa770d27d5b2ad92728796786ec4f985e8cd26254f81f5451234ebeed1b7c24580d174afa17842e4b85780c90401c644dbedbbfa3b9e6288fd9a9b468fb0ec1ab66a603a54034550dc0648ce67775cdbb6e4e2a3f6a275ec85885828f567cb108c87e99f65251d3efcfe4a392474a6c543c688f128f455483d14ce1bf399a8d596f7988205ac011cb01068c12d4eeeacd28cd373a30f3571099ead3a8b567e82fdc18717b0e974a875c93af2097e78d30587ac6f95f77a9720f8f171ef267c87117eb323c21ca5bc9f5df9e0d909890b94a11bda23c24a815a5dd114f7feff4a4b928b62f0fce0e370706e467bad8d0833b7d1b86a31f83d0c6f201ca5b3cbb5ba1348149e72e26c5d4265ba6975e2939cc72195254cde64d54bcf138a326903e8a05650c5fe59dc1c18772c188fdc67dcd6bcd5aa00894037d50d9dd9a61e47efaa0d6f3f288c552be5e7fdb1aed875b1daf9125a94e1d7f1a91f3fbc4fc929ec0254d8c6f04ed586e56ac1ed58ada0b2487c2c523d533149d18e123714cf4e19d1bfdfdbadea62a718d9f1ca55d0554bfe39cf81abd6c1c3779894e80f35dec06a4efb0c36390fa73f95e7d99e2f3f6afc0eefe31aa28023b0f0f42f4be625b2152a18fb8d86100448853780ac86348b60d64dfc7358b4b564d8b52bbe69ce524e71026773d01e1eb7baa34ed521627debcd8613a0a4ce361a3f900f681fe8a75aa107cd87742cccaf8e6ec3c529525fc5910c75c7e400cfa335a853bd4c73b808522bb7f1ee93b130c1908ee395906a9009253ed2cae36804629c1b813399f9640e1a0173975f5a67dc0714c661eba11505d38f40ab88de74c4b12bc996a43279985087f36f3653277ca429ef3197a2d9dcdd80d551eb2189ff565425f2a4a79868b59051accce622de66c0186cb65e8b22ebdab832fd3481a45681c50f7d276959c3efb514db4ca598d2b535b4866afdd95d4907d6fc951a10635c9dc360eda4f2108d02ba0588a1e98f7428221d171426617e7b4768e4001fdc49bf18713a9191654a56aebca206a6cd5a4eddc5971d9c94fabfde9b582519219bd1debec003405fa16eeff1aee8c2724fb782736eb567d7cab19b8fc7d32b041c2e9ba81e451d72a4fc768355d10be11beae5fd9ea06788e79add71ad5fc61b03f2f8aa169434d3fbf2bf07624bc0274ae82a8764e9a8102937a8c80c12b401575d8c85e4187501726703c3b1371a2aaeecfddd110390d89060e857cf34a3c9db7f1b989b1b0fc70fa720b7756059498daa8b46d9c14f5a5784e906c6688d8c6886f6d537f18a404e7dd70d4e5c469c3a013da301d3c4413dcfc723df8d59a3d158b1d128e8db1e3f397e13046e4686afb7269c9f11bc5890dd116f5d2154c018ba5486e4123c79f4abbff2f6f3e66280e93a339e118d2e905a9b55742381ba848fd2a6eee4a58e22f2f43e49e93039dbef1b98894f508c3329304ca198e895a920a95c1dff48f341c9bd9fb4bd9ea497c8fe0fd3d84ee265dd70467cefa3b602b729b60f6ac2a11277e551f195b02dd68e0dacabacd907c1b1b1248af03d5f624d3becd20c430e38e7138ce85f879e2e0b463b230c8e0ec0a27c3ce5275a6db34f73c6554d5755f735b1774b39b194bdc13af7aa4bf078ff0fb9e1e97694f5a85cf0bbf88d32a932bdb81d120dfc2e9be59cf27435dc5c69d7fa327c06b93b35ba2c2c8437ceda01a1f3744cada66f6f15feab633dcf473772a58df06de6d1f0522bdc924fc49225d72c3d62c53ddc69a8527996773a022f9b03f3e117ab4cb4c506e9d45310f322666bfd668a743308270d602642d1fcb53382ae198fe000fbd7abb507065c4356cd33ad749488ee5d8d9f1bb91d7acfb3985a3befcdaf3717e1bef2a5997f6755fcb0e222f6ac37f6001c0e96ef3ad8acc4172152ce1c29f766d1335c6000f02bc5ef886e7f967921278ccbcfcdcc0cfe0463a4d5bb368791abe9627f1e9b6fa95c9e9b21d0273e8bcd6c1a5e9af5f5d161378ddafea31d45e7a32d6f856dbab1a0ed8e33bb175f5f275fcbc1729ba1304e74417f18b14e9b35ae4260257b183bba770917a14dcc60aa3dc21780f19bcbd37c12cf7ae1f2ebe9996aad6c1a48f5afa071736d6ad900b54ed0e633f2bcc8041233b135399011c4c04cfb7fb3608537f531c40399db6eb1eba28760060dc9c398f20153d09269d782b19ddff5a2024e72af453d9d02edee6860d1acdcfbf7dd10e2870e0c68cc6be4a5d4b0c24dea2cc1c109f8202edaf3471fd76cd0bc54f50f038de31ea9c7f91a092cfbac3ee949d069039b8b7fe1a94391d636ce5be69fb857f5544ad8d463e9231d7c37136fb28e6352a5e1079b254e48b27047320105ea6a3121aa1a06e9167d1d0f5acfb03eb85a96d75ad78d02a765fb2ac461685bfaed7ff048844bb7defbb96eb04faa023d41d957c561a4cb0491eab3df38efa2b06ac6b9e48b50c23a2dd3bc127450fa1b65d41832dbdd94e02b515c1f6a776cb96da794be229e328bd634af3000910b0893b825b5d227d7e1bb444abb78bf68d0c773e53dd0ebc2fb7e00985501296df725bc28ef42c819bbc2738740c634e00c528589a32fb95acf3234d6bb3a3ec453d58f39977e91dd64aeeaa63b43c78f903a3c945acf1ab3fceb4ffb2c5c1487036b480ce4ae36075d52d344fcb77b3b9c9803143ff1a5ecd73fd01218e5719983eac28a255499dcc559d6e6c4c520dd4ed7d2f2fc8cb19fe871283fbc75adaa8460e28c0e88c04d7c2a29f98bd3bf20a9fdae38b46238dfe7c767154d6c1512467a1f600fdd4d9db765bdc6a7be3d68e93d5e24b292e9adc129c7fd56b65fda3df79035a118468ba0d5b263ce3dfc7dc7c0cd0e996dd0182bfa84cf0a67c02cc13fd4d18aeea637f5e0fbb9b585f388b91543150a8c55a48475af3f9af0fafc997e6f4da9e4428f3e5fa8db7c53c8149cf0b1710d4a2419c5589acea91fd577e5d7a9dd2e19f321b7f2daa2c4662bf79eb5a88610a296fd3677429ab3ae2de8e83ab0ba546d63954ccd307d493e084af07ca14c511fe94c9dcfa5a0fbda2990cb2fe043b66a648c74c1981a4f6ea3a9cdbfb0919237dea4fbfbe94343c59cc8ae2dfe92c077906f0bfab1663eb74be61828ef654dd142f0f05a615f20f2af9f34daada32d58eab19e38d9d06e3f3e0db5c98f6c14e05bbcf835079c4c70a720aae3bd4887333e55e80c2d616ed9a07a3340610c15d0399f20dff9520e8815e7865e73cbcf91279e62ae7d7a1c3598ebfa9812d390e50e8c3593df9333446d71a5168c3f8636a7660232649daea26311ffe56399439e73cb916d6053ac4b373e6670709246e79d9d3f133f4b68b42eb808b1377b41ac27d221054345aeff426eb26dbcceb9235e733c9aa40714c71b392caf914569fe24b3b885eba50d9cfe88eb9e372e840d4a4f026685e6e272dd8faba83b95c308e3adc6673016dee96e6cb90b9ab86b52d211eb30398b2d859de4e34d6e400adbc39dafc03d8e1e178df7d488e8654b834c88ba7fac89b26eda6ed163f2a17d9bb227446c9562be32df47a239b4004c92d323e4ba8a520baceea6774f903704f9943a59e77930e65500b7a167f9d248d1b10c388b23f2db77731c8f0639c93c2023646f391a1646d1b6891858e0c9a4912a2a72c60bec7f994468dca1b81264f89ca9f6e2c4c0df540a2773a080a6ddc3cee6295e86d88142554f9288ea7eee21e6d7dbdd6231a0f73f0abe41dec7937b06a6817de4f8ade7e1cb56104bc4db8eb3be1681cf17a35cd756b533e22ea5b1dcdfbc28ef52134b1e9259fd22ec117eb51bcfbf7e14e5922237cbb6636e19dd6d6b0d1336647d8a73d6bc9cdbd38a114eb23b98fb9c1b1bd38b46047e41956beb4f5a70721c3c5a2efee94e5a4552e1834db2988605b5dca167fa745dad2de5a08275b61baa9816b018df7d318c7b3c680377fac91ea242226c00399088387193cfb852e420df738d3af0902f9c22bee917456345a12bfa1be9ec5be017efb6d5c48692bf6a34da154cb437b0d33a062b14b5e2244dcab18bee699bf02b1a4fd9632c7386811b99142cf17afc53a0c2a0adaa31c886506b7723624de81ae8ec218e1cc13ec1de3a7fd70ccab9b68914b84afeee8153d0acb866e50f20b0572ad922bf254d3983fd5f31294be280b9dffdac24d5bc660145a15a1d3fb36d8b078e2ab33ed08a9adc03f8b122ca5b7aeaff6d0bd8a6c722c6a47dd5645df0213e94aa92da70973b5b6ee73f2518e66e516b7e91beb7595d1524093a9b5c78e9d26921c24f860c4785739feac04f05f231a5c05e1c2f40e5722c68f53802f6749cb083b816ad2f7ca1d2829f7d8dc5304ef7115efdcaedff99db794979e75d4a695971a0771a33157f2ccb1351d82d0c88ab4c4eccab31be32f0f15afd7ff0782d44aaa17fa095dcc9fcc3b5ed1385fff35cae21956ab1604b4cb52bf24f3897b43ee6c6ed5cd7229bfa45982fd2be0d619eda65b1c5c41a415cc520d6ded203472667693427ead5a9a85b58fb7c186e6a6dd9dcb9e1ac080e8febabedbdcc0da8f128120e17ab5a5d1de63ec2aac99e131cfd5d85f24522e154d4584b8de72c2c9f6c13456953240c18a2d262f2c2770dca65418d4fd616bcf4bd476282ca905eb3436f7bf3f7b5139ff9fdcd9f9174d9d3ea53c8bdadaef8da45c1fef05a27857404211848d6eff9655a330d64810cece6359d2a096802c64406ba989cc617e3398fe11f8bc3f3b3e231300a5898ed82d30733e7cd99e1e961d559f84e17b3241ce27466d8958f460829954509daca16d1e6775c9e80d782a1d831e82f8c1de86da469ac1c7fc0fc89462b6aa516dd07dc408ff01cfe7a523206bd20ab6705e9e1168d30b2adbc26bdcc59c62f9050d06e2e59904a846607756f6195b2d70c0c6125c112f6bd2e7361115bbdbbcb6fe1be93efccf23d37e69ebe97245c1409442eeaa7bff86baa088ebeeb6730122caee0ae0b36702259128ca3e4f69c06b07a46be187b810c45d8240f5b9903e6bcddbce7098643eb9d3afc624eeb1c1e11d80480279345d234d3fa2b1e91ebd3ecff9f091120dc63c28cb6e0fd3ab7afae52e1658dd2a84dd307fea60326575cf6cc9f01250df78c899aefd30193f4abdea2e5a8e87fd5ffeb34e3d1e0e845e050daea08e9dcf4d93f8f3c1857114315724fe91a30bb8f7bbb31d06ef6f066174e8b0319b7d41c43e7737839b09bc0778afe8351e1ce449e750fdfddc31976c79291a814bea7a40e61be44eb56eb1287ce0eff77b1e11dc5b408c60ef39db3ab696b72cffe636baf36b1730c7371c26a53c299a1328c271b4ece7ec92680eae7146129b2efaf4e1acfefac5f8576892b90669f045dc09c627bab68a0b01ff2e13c1e8c0164ea0e90272ae79e3b04f80d543519d65080b2703c58cff59768a0524a39f3d1c171238ee54ed957fd830a14416cb8df141c3411c1f22639fc4531d771b9136743ba1c9ee04154b57612d453881ce6f50909bdb8cb9a6e0d3156c22c9aae510011be0bafe624117dfc3c8026b37fadbc9065e6667b8d4d54bfdbf7a595400572cc7895aab42c665b038f82f7bb62e56c8910c833dfeda85f59e8db00381a86e3c56c335e758cef7a037b97b40122824f4e69cc37d7b92e9b49dcce9039dc54e62701dd0f3f2f1615b71b8d62a4d098c3369923bbd3c36df10ca5b4a6fbd0ab3663e19bb558dc56e7db489a4cf4288a1b583dd919147d74373d381cc879255ba0afa972732388fcc62593cad73509cc1786baf883a933d175130ac637fedb037706c59628e91ab0f28e559c15355effa4edb09fa5b01daa1acc0673829bad323b97e971c2d01bb734ef5195277bb6da364d46a5dd890e006ead675f57d6073c376d4cd8fa2eeb52872c8a08b7e0242960bb939714de7fe9d136cba255126b621457c6266792c3a95c0dc9d88f11cd32fa2f2b8460bbaccb0c3ac4aa6b218ebd2e72556357df6ff8f7960d53d6b476b31069af3d5e999a7fab2ab22bc3b632f917cfb0c30f1de7e72772e8f28c34cae673d7d0e03aab2a5410e74a4b068332e2d196ca7433e31a395eeffa0803ee7c15a4b6d3f40d3e975768ace5fd0d98e4a7c2710bb77f7f2153a010dcdbc2ad77839ccaaab771301fc5292a01700d7145b307b1ae5648eca42652ab3c0052f4e720e0439f498d626eac6b29b35c56cfff37d308342fc2deb8b2f082553731475733ba8957ca5716f44f913742f45d91eb8dcddf98005ae311a9e96b84d00840cfac90f4662d573468a9af6388bdff003e8145907cc6a12a73166e433bdb0a3e8b16d31bcd3dadc9277b6aa2580247c2f2abef170c316238910206345bf521b1036bf1e6082446392a141b4e1631755d3f970da2df4974cfdef3372805688680cffb2665181d580afd0afb63cbf2c72b57311abf01dcbe27ef5b89fd91a7279a35687b65fa03785ec67fc0b2cb83ecb663e13c58bb8a7b32e1a3d64d06ecbcfdd39ee3cd11d3f432c08c4ec83179525be70cb56dff7223f8fd696b1666cef41d25a9875e712ee841540899d080f2bbf17f8756d7250d4b3000f0c273fcde39941f6e73ca2a6cf81251fbc88bd14e94ee550844979b4722875edc2164ce1848406b534d4afb227935b635d3c41c391825eb0f9cf0d1bcea5838ac921459e91367461bf0651b07ead4530e90b1f3e21dac5e4b9f3e464a535bb68d3fea6fb75d0ffcae2a9a4538f8264216bdebb638bdf3d3693cc0cafe5649bc7754121bc0ad6d402da7ec628a0769a04b06b5df36599e2f9569aca0a3568b71c7c193142c50e484779a11d8628d5cd34ce8afefb8b19cad31759ded34d3217e4a2e09273f2bac8cf778c1dbc3509f809793fb4e02bcadb9d4c39aa06d0b25af6463310a373cfdc718e6875a964b6885b8b7cf2ba700759ff8115a092175dd34967b598957e413db082eeabbbd5d6b9ed9859251ec1ca3bed1238ebb0e304a13871ce25a70aa6fa26baf2a6926d7b48e0e2da98df7a5188c2de6f92621e8f2f8ba05ce9adccc15d2e20a9c381e102d396bec062102c50a59f61dc4b0585964bea0ed45b37bc090b5b1621e0b53b296469b80af74e72cbbb4d2f1422cfef1265eb92766b7c73b11f2bed46afc869bf10901ad7ab03185ae7c81e1772d6223a93871f9f57a13d4566fe50d44312ada32075d56e5d9f220496f5b171ff5163cae2a8b1813ecd9bb66104ee3989a779f47581be164140831a076f4df4898d81fb7a15d646a3395c553163a8df4352cb8458da46be453ead566646bf913b05cc16eb7eb74521ae37298075b8c6289f81837cab9b87b9abb5d695196f10c70bc1819606a3541e22da7dbab37240f64957cc5c9012e90461a3de57b821863cddb5889d9b823f66a1ae40f0ae67a8290cdc8f9b7e5d60440fdd859248caf558a10dd7aeb88640a6499d19bf67f5f0685e4f92f06238c79f21d16d23e47fc2cd63187d994ac75e4c56d740c2a470042909fce3225514fc3041873908ebfead6327c45c187c7c54667df7a627588321bbcf93d52585d191a3c1138bf605065d57a29db8b3bdf0a8379a4567ac7c3d8c715d66730f44e6930a69ef5239e4ba228213d3fff1977619e97d51f2cbfd8d32f9b4c775349df6fc80df673b84674b03177049ce1a07fbbf59bfcf51bec51f0500b2842914c40c0406b7aac3227257712ff6a3bdd66ee73d33d660c5677395e3cc6cfdc65b508dc276bb34f3b83d73d24ca33ff398974e2eee1534cea83ae7033077b5c2bf7d92d05bf00b9f6516bfa380c5bd48236e38ab4e9af9ecc5f149e44a3807c184b9e944d1d203c1c553b56a22d44feeff9da1693b4b473a725d9d0ed5259ca6bcb4d3da93e69e287fbb6381b5f2b00a08b76df8f5b04df7e29c84894123f1fec8f2748d57fb3631ac84f0ca7071943518c010469f1ee13d0f0bba9d2359d0bcbfdd519e4ec5ad4901934664881ed5249b26f6d905866fdad2b4eb79d96bd9bc25575efa7d79819f3b1cb884667e63410ef30b3e866b18a60acd9d52079be5dadae73d7f6612ce5cb563f2a0b345ba92202359a79d523d9b49c8f9b40ffc7d91fa85a7cb100afa03b1ed33c50e61e4f3d988efb4011036208529504d41b520b5f88ffb32043b12bcc0855eb50bf38565a4e8ed7902cf8f2f02190fda5e8c98af4634b917716840eb017e29726bce7c10605d3bf57a7df4cac2c5e175ff35eb10f1e4b38d24f23904962c43f161f893405c2f996f2a88c6e6c1a979a08881eb8fd090617b8328d926749b672232ce4bf9c84df7955abce8f5e04eb97df1987460052c7b5b98301cbe3a26eb005b6f2494c98492ccd250cf2ca2ff93b1d198e38f0f1d5e045b675cbb3f3c586dbe92eb2b99b51ac9b662a00168c4a2b16c0513b6823914de97554383b4d860087fa7b9930c7c079877fdd640ed601d59714c588172be31ec5d1a71a36c5759323dd54c36b47aafac693bb6bb45c207d08269689e8378b2ba3583958803d43d727c9af2b218bec97937d781d5031bbe33b9e6c4aad8e49cdcad93cafb61019505f1a4d56a0a6c0bfd11b28c407dbb135cbc4ebcaab7cb11a743e4fc3175119a020c51085317395ff5909061b224290cbe5789d3012d351f0e29123698919efd4931e5e660016a521bafe16c26f2957b7d38320e4bf46130e4c862e98a12c1ec73e85b3e342ce3c21f0fac88f37eadd9bb99130ecdc7df6cc905b717d377c43b599154d425a23110bf8a6a11a5d6f442ff37db7e1dedd0c94b8814efe63ac57ec83530ea9535c5cb803cf00981c6ac54263f506ff539a069af2a87aff0d4c0a9d03885d4c891f607dcf9dd861d085b41505571123465b16ebfea2d9d1ba3de4ce4b2eac28ac8c2acc4362c6e925145274ae616043dd39f295b390b2f9a632dbac0a3b7811c1a1eecbebc57df71ca21216715c811e8d155e17b82a6b97fa1dc95f94e6da33b38bd51cad314c68c23d837231ab4a058c6dcdfb43d567f81e6d2ab8b7b4edb5080028781e7b6f97fbd276fc34b8ffb4a77736b429d0c0488bce53a30bfc03d727244b6f8a38e3ebd343fbed034e332981969be107df54587759114e69af2e4f756418d3e196e6b9fc426955350d56b9f36657d113951e840457c57a23b36ce45902da36a6c5f146bfc45050bddf972e5cec0a3f6d7e30d92194806829816807d7d1f28fda63a08df16d8f0c4af575263616a749758b9db66a7b1c96e0c6018092410994ffc87aa03e8acbee12c594197af31efd4f44104b08ec06f186d3e93224ee81cd3e98447cae0467b7037603d73e21af46a97ae13be1064028d872a1f0fa2b5f4f83862f87aff01d4707be9c97351b8c5c6528d9cdc2a6e17ae1c4070521d2caa765dd0a96aba68f52575097649f3661633245b47fd7dbf7dd04b019b4744f6aa552c449dfea2e7858a525e086af091bf172e8466d13bba595f693a088c460c3510b1bdab39d6f261921a45f00680d5b6e83e7abc53987ca461194e9b2422bdb5d7457b721a29e29d3c88d174f6e66fc6f2d6ee57c14c7930cfa4b73b1235031ea5f1af498e89c2d4ac5c9a98e5881b461f50679e8a194ece9607d3cd6c5645902da53dc9d7424a76629a66d1986f6f40dfd03e7f0eaf2e503357c3a7fa8f516228f7941903b3de06ecedd4f1993f6b5128c06d9edc1e9527e81dfbdbf8499d864f6fffababc83e559000e056e813e0d9fe9278c3deea67de9098dd15b85e8cb6b2f402539f6ce6a3175ddee688084eb326367a67f171dd1deb34a33109851eb9531744d66404a29bf1e858e857c79efbe627f300ff17a5c5b5d9f6378e3889cf3c3f6593b79a7a523d98a84d94a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
