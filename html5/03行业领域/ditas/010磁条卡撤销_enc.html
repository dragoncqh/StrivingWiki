<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0037bcdfcbcc3e2f38b4116a196b6cdef7a9116ee7e831fca49bc4940985ee6dc576761d6bcd8627cc843e0ce02ec6a6030e054b1088843d1a413ae7a2ebadece9a931cd4df95f007b826773295e38c0d0ece5fcd32e636725ddf2fd9cc3babb6f31da410ae37872a0fb4433a3ebe931ad0bb818e37209019d4075d639ea70a69b71860665df7b2c4b5bb884b515366a34d75dccd59a51118cac4acdd3caa2205cc1e3e35c49d6f75986c59f85de190fa1464e2741bbf9d9999b526671fdf8aea3599742e9523c0c86235b543cf33ac737ecf325fa06817a3868bc82bf135a74f870ac6e81accd1c8b171ee36c92638c8fdca96373f8013540ccd63d7458d4cf23e202e5ddc6da66c2771324c0e58a028b623cc6924b54fae80b2da81fead87c2df96b66942604a8ecc11ca8490e0bc0eae04b1fa947f4fff31c41547171de4c7a0c87cf245a67cbdf81438d9b8f503acaabe9243bbf0fee8ab1ac39fb398ab3391edd9fde30a8c426465fc62102cd04341f3a5dfa85a78d70789aaaa5a88662004294b5f50c0ba87441238b31d7236ee122cd3dad1dbc805e6f4c74bf88a80b1af890da4d9c61c562efeb75842071ef1a5cc929b53316fe7b4f93664a866fed3ec7cf41f48932a0fe310a5d7fc6e6afb49f111b6441413fa56e0da79288d2f2e71cbf772ec844c6fe43c5f3e18d71b9c88ee19d5d9f3fe33367b529dbb69cf5d980f0439d6cc3639940118c12e0d79bbc9e4dc57e89ba60e8891f72037ae284bbbc843cdd7af8354c031cfe86d8dd0bbd77b1134718b10c0f45961878fc94ea1f3a5f7e0f80a1ac291570f92ac6dffe31c81eba0a3da6c65315f7f85c5a48aea88d39d8079fe63b0127cf0801f3ab5fcf68acbe804f8e24187d77722e1baeffd2266d4819d77e64f94a67d0a957d41441178dd78b517fd7be84a32e96f3c0048f3568f4ca9ca2d8913f713816c569b3b6bbd7904c55f229f340226dd0af63bb869fdf995a6b6e40a7ec1069c90a88a183af204c13659609a5b4aa2a1fc6ebe6118e7d7d6e7eb8be2daeec8c70abe17bb32001babeeed5818b304504646bea5d2348a4326af7217841fb7a9be9753704d48a08bbbb997b321622789060fe6da56249f3d4f935573b53473cb0fd44f87fae55bdaf58486583dd5161bfa99ab0236f4f290eb617d97dcf207362488b10411526f6723e133ca0b9aa314be5076026839a0e68b54782d1a8c17da7e531ff2d42b5b738cf2ed8e6c10e3a05e058d11dc3f23370ae07f68d71d3b8028fab4f7b0fe8667631732dddea07fadc7200fe6547fe4e7e604978c16631343d39c639bc530b9c4d74a2d47ebbbb83f6782a38454797d5eaf9db2c8ef6e7b55157894c9f1bfd054ed7e4f62f5ad201b32e829b221c3c222e78c2912ba915cf0a566ddf423f12eddacd606f8762a8567f3a3aa1ed7b0675290156a8e8c94e0bd644447bf00888cb0d1d5a14b923ee3f43dedaf48eb1b7bc49d1806d9f7793c6178b85d68c40310256bb6229d55a92ad6ae1477328826f3269474c18cb225af5f4fb2c861472cf8dc9bbfda8b3f4ff63cdcb94ebfedec0aa7d92bf5a695372940ed13778297dc08cdcb7584cee2917592694e38a750841b0dc61b1e49fb2bc6833746bc6a69d2b1f5916c2a7381349cb98565438b0b64f1e0d8a34aed17f6a8d2ca0cec0afac6c5d59335be800e03aa1981837b5f4f5e972892a7c335943dbbb66246dec0c73826f8993bce7c60a0e64cd9bfd3e9298bf593cf03de7b99095e31663d34b2676f3e5f1de088a2f1b69eefc975b83f26400bb43f926f4ff1a25f256ca0efe339b7582010317c9481bc987ea32d273c293128fa2853f6cc668fbfa9aa1d13d5be69b96759aa8e0c36dd7f8d7de53799d2168a68c8a1d1ddc3352672439d4b334357ca78a3b3d38e2aa39473444f2894086a7f3cddbad3781173f5880541022873815574389e6b6e0f39540492bfa7f63dc9e86b4ea6ddf5db656837cbb204194d18f8e9409e4ffecd76abc2da471996f6e448727a88b9cf8ba77e46e08f2452def6f554138696a7c8713b1a47aac20994efdb494d37f6781c6807696fafbf0720dd19a72ea228cc60520a623db3d76eb0ccdd28c7bc288a323451472230d31a40e3e7e4ba55088f442932e29ae1b75ab817ba2a747f843bd4902111587527cb182dc027c166c8da94db0eb0dc3d5790ed7ae318671d2afe5fb5b526859bc44811747ae5f64e9ca3ae1397dafb408fe40077b0b910ab119c2a1ca5f6803a4aff383d9c028508bc12ce802ffb67b0e55a04f5b504e5f9edce312ae4297814eadfdcbd2eaad57645db32247ebce1a5f577671964727034871794b81c45392e906f667b298643f6fc2b2eb18e45ae8da8c8d42ea1e71bc7de0298e2741213136cfacff8fccf8712638c887973d3c8d95b9ff3182ae5012f3971c81be4349e89a2e8b802d1c0c52904b63c7a6d9ffc753eec3e4c11c09b203817c7d9ef9e1e9c9397a6cbd05637336a3127df5f6ff2e802e83b73fdab3876a37c13bf6b71e0be4bafc434d5206a9feaf184cc4a9c0dee7befc17576c2a42566a9d97fd0363656177ff0bada0ed25949575704d0ce43be80d49fb9093a7feb0911688643ac444c31aa08f09ba1c96cd1263d94b78ec9719a9020f1d4803c427203a8fa98892b641bcc2b0d5fbc54b2a4c38cb64518f42b5a15c9d5aeec9f21c772e9e7c7d08deca7892ed285563b3ccf5f9a4dd93b45c5a99249fd923348f8b1aae6925a164f7ef3d37f70c08047a6db7496352ff6ea962c140a33167def619f0557069617354ae74100efc2cb117c90697075cd8226b7b07845c1ba8d5375da5789d6bfccd4a2803abb051d24aaa1cd39b5ac3b5d30b77063738cb47f69ea14ef89df295aacc0b334b823fd34ed4c4085a57f474dae0e0d94c7a97eb6b9898e6b902feacf8f07b71a6a2b772b74daf1b4a1e81c6fcddc0415e4e090a621a317c2393f85effec5475f54be39a8ff28ecd5e49501da8c3ecdb90d1024ab8848ff567a00b05a7bc4fca79064fa0ff5dcb5a6965d7a8d71e5404f5449860961e7e4c63db187256849086e0d836e76d5699e4a9fc8aa56ee5994685702e236f93db3b6a2063eb849f35415e24bba0f1066d6bd58ab5a5a4810fb5d6d1c5048edfac4223104c86c9518a749928850c5d55670cf85e908f68e1f6a5f9069c8260694616de59a9df0efe045ad6cac586e345eeedc59636d1c8be5191131f73971a74d44e15c6fc891a42f1785653c3ebf17943e66ff907740451d67e10501ed9d2048791986dd32f7bb459cd181bd180fef88b82c36238f8a6b05086dea1861045961ec1bf8466924587d10e167688393cfbc35af2f04065e2820034c4b2e729b889798b947341230d581f16aefea20f08a83725dba14bc3a2d07fccc71b4dcb4b9445af52f79e2aceb1223cef8f4013b9a51055089d83b40f6dfd7bc149c8ca2d40a8048290f533ec1940ac5667f6ec37cb35149246e550e590fdb5069ada7ac36ea1d16d724f072dc6351fd20504d0a29547c383441f4c97ccfa05c7adfde22246422e7fde45b7f74e0ab27011d80e0b30a1640f799a48d304f0d9626bdcd528e2bad466ed0cd9d661d501835e88c20fff60a8f0f7d092b89a161643e7f0519dee09a9f9da4a19730c7d1e9d9f7f8cee6d2702ebc9087cd90c3457880b43ff3ae7277c1419db32bfdc3e14093af521ff53cf171e8fc8c443a87b66ebd51277701a6dda619b934de33a9493f2bce041edec2c288e44f194a5be6f8ba04c76d4b7c38b9ec1dbe327d366ad80947ec95cd03fcfafdca27d3b4f1306adadebd7a4dce815892d118814bd85ccf54a79f1014c2022592ef176c234d967ad2c0d66d97277178c963e9013d6c0b1ab000692457c3d39bff05baf3e48a7f319d9284be45c10c735f7cce023d30a70bee324cdfae8dbe7e0d5794f23d2ce869b664e02d6e84c51e3f0f0fccde4853fa0f0ee576d817d57bbf793edf9ff2d26ba53e020823823d8da774742bb7263bba1fb1b7f6b3e269c6d295fe809c3c0ebcdebcd9c55543ff78ca7fc614185fb8ece460f03df82169a3d1fb46c7f50c2c1681aa5359a2c2f7ae91741dc8e76780df5141931b7b42b5501530099f8e5f7fd3112c3078adcf50876c50418740d266b425c8c075707578da633a4b113fae3a71e8f6a28d5fbb38cd5b5347eb1c9e72ec83b25e251e3310227ed51ea506535d1bb2e95b6f7cff7516f6de0b76bb2fdc495ac30106921702548974480e2782c594dc71daec9b06a21e669f26dc072526eafecbb7fe2b4cceda555661e58534a5295bea7590d42494b7664417bee65966e030b7cf90539f4f01a6a4e23e997fcc8373cd1cc7c535f4784b4c3cb7f576fe1c9cb326d8200f7b76b279ff73ad809c2ddc1c70c3eb23344cc8caa0dd1e2d6de5208c09e2508c788b723a4ea335aabf69f3570ea1f25f7f511c80d814bd32d1be691de5e9d843f38d134097ac1556ec660dc9e025f1b6e2686f62ac4a3173acc14766ee38f941fbd769fae5149808799164857b3e5520de596d2ff701951db2887f97118a8cea1784eeff359c26694fb9b8ef247adcb5cd2ef1661e9409d95c6acfaf419e5c89c243f3ace65de049b43940f79ab2a5c9be81a1d827a99b9e7762a17c8c11d710bea7c897eaa9ad378cc31c2321a7e411608c9bae5f10c987dbd382261509d3dea55739663340a4fc0a290971c179ba1b9d8391d6ac96cdf96c36be4be6eff4fe5c012cd392e028cc4003cfc32f6c28a00d5b631cd0e7d7206fe6c41b4af0425e973aa521a531ed9b77948b24acd70654f79dca4b6c2347d4dc8c416188c5f19120f2888732a8edea0956c5d37827c95664bfc216bf92eafe7ffbba9df5e09558e74d592aa3efc8abd3fbf447d843af91af1054d8f50b0f9c6603e0942c3d49f2742b66dae3ff6771535bc17e87fc0f87c7e7efc313031b6558242b2ec58bba05ba17cb89a8c84e8502ba1303cbd7d3f351bfb4cfc2548b972d84c5a46b79428f5cafe28ba8822c3a543990c6060bfc23579c776efeabf75b88656933ca3b8bd22c418b657126875756af4ebd69522dafffa4e54e4608f08b5ba397ee84574fdf353b56009ac487af2e15aa0e9f7ec694cfcc8e53590c6e5621d1096e49e2d332d144e566977bc833c248c2c670ee1bd91c44537003bcebb6caac8875dc0ab667ce1ec9232f0d80e20bd623b9eef6af5f023f39818f13c19b2eac24f4e80a4031805062be92a60cdf8d8621e3c89ce6552409b42817a81cd0fa11385a9f20468198d2b99615be4a6c43a58dd676357d80a4c65db69757296267f6af2d3068ee70e025d5cf7b3b9d6b0920deec3bf440d720f10b3abb99475ae9a18a76443efe9c42942f45b04f44b66bec047c8bf6536935ab876cbd4e280247643b838bcdd2ed490c04ca12d66b70bdcf2cc457f0dd73ad3fb9f77054afeedcc63457fdb469ba77012d015716eeaa819d5cfeb374d4fe20262bd5b8751d8cdee170982fc3d8916b4b0445e197c5744b283b6abaa26e1d8c46cd97214582c6b10372bf9295b19d9a0142541137487cdb6ad94a4350d1f5fd6e909505a400159ea98d4a7b7c2f764b80bbcb96903d03bbfdc3c0879e20d8968dfec7623fcd92fe9fb6a3b6ad8c88c5cc6ebd6cdc46713ef0cd2a4d6395dca845fc81acd8e9966ef7ce5f6531f0336374a1a516f566dcca53cd002ac212ae425fcb2326c5229974b02f059af5ff1b1e8810e16aa02f70fc93ce81793260050f52fee6328084b45874896ddac5d87fa086cfe1dcd7c5053862eb388f40fdf4d8f0cb9a4c59395f7c6b890bc300aab798124fcd1e0cb1dde28ce345c408212428a44f0bbf7307b912c4d4faf4180dde2c040ace1acaffa5e34156d44fd9d7bb86961926807b3ad52dd21fd7164eed04d7b75b49776e72f484f08b24acd96a141d1b4afebff4e229f01907d0b6ef4f6cb6aaeb8f4ec3ed2265e3ea0c2cbc50d32a52c55342adb130bd1fe37c733cdb159785771fbc873ded9d5fdf33bccef18b9cc7ae89ea4ff930a06ab8c7750fd8af40950511bd0ce16c4310173dbaeb2d677187e044562609dc1a6dce915099f77e1825b546ef344d0ab259f3a53a283129c8e4855712b68ba052cc404751ec52efd668dea49f46436f8a3a2709b784583c21bc3327ccadaf7b0ec74d437119d1c9656c4dabdbd4f2b07aa04bb6977ebf3629a646a3415c5dbeb5a287a6166cf0e5348807c778c3eda93e4a211181f3b59c5dad76a94883f4bb08d0286162e77009c481b6e40dfe867602b1b06cbcdabdc19727013f486017e8ff4d1f5a01175ffb8f793f5c7c675a723c06d006aaddfc073e90de5902131b1633f9581134d2bbf7923a9e8b4fdb4d2644e17c41e293a702ea43f0f7c12e1a8dbb9da77f4f755bdbc818dc2da6bf6b2d019a8dc7a529ac8e2fd3d7737aaa83ffb157a6af05eb6023ca870ec6dc388134ee551aa34f911adf3cab3cc3e4cf598e7ff173e447e76e03bde66592c42fe4a48205c15480f5e6ed0eaf80dff7408704a72a87b4f34364c35ec70666b3428b780d773ed69ee00c5e368341e5e95704e91841043bb13836be1c7bf2ff2123eb532d0f08ee09ddbe592c7992cdd015deb4a74863fe7eb0f5986fb4103f04bae677920c9822fd9cd4a290a5c75493f637c01429ba12252cfd44f5ad6f04aca6403e23e4005c5587affd12f0620e5e071b948f46fdb2501e71e9c9f65843e72a8702da6a10f9b81b47262aab89eacb0545d53b9449502a96341abd85d014fbdbf25f4d9481453548eca77c63507d5ae77e4905fd813cee2a0badcc16b9cc2f9c1bf29cf1399458fe9004502bfd92d55bd21d1153af7be1692db38adb642f1948e15d4fffdf3405aaab63b89eef6ffbf79eeb2d7b0dad1dbb2629383152e23cce27b937a618f57e8cafffa07b6ce42d6dadd12bd0fd276d083fc3cb4d9b81f6d117ac5e3f37dd2f0304075f36d2280e96d130a7b9b5cdea75e7ace5c4b5490c1bd972687d8b121e29cb882787b4859ecc941e3ab9849c4203f660a81bbc6462ce754ff96be393c986f158bd707de276cb483db26bc2b17c8fe154fb673ab2c413adb8198a858ab00b3e7c050a7e054ec1c125363a14f60ccff34747a6e696e6bcb70f8265e3be4cf2e5c165951646aa8e3bbebda925b3855bf8f6df4c54b6a8dea17c037363500356107cf2afa3698244e5f21acaab395acb5f50f3e2241eab467ed14f3c1af419cd24931bb613420691c40e5a98e0c940dfc516010c947641174eba6b0e061fabe9b61f8c169cc59bb1ee53da542e29ffa2b79baf0130e8bae7e0f8b9c78a7c04de0d9c2abbaaa9dcb77e22026f77332210dfdc09d503d2512c5b5fbe6724b2a83a1b7a49be7fcacaf61807f08668d5a903074d9610875160cd91233ab3ef0f1537900ca7089456336c4400c3e97658307a27c798c05edf86b4a89593441edd1c3745435c5d6ef7b1aeca9352f0ad01e21035ce52ac92d848f35a5142902eaceafceb836ff540d9e30304dad76aa8f7ba8d21607ba8bc1b64224ce6b276640d0e6995d97e7d14f99a7702db0e0bb0fedf30656c16346c5c8d77afddb99b5f63f888381209c507708c9ec3d3b985234ad08ffd6ae5f651ce73991b64ae8c15029f778f3bb5d5676da25b68f68b0f8a7f376243b90c724ae56bb53d52a31e867f17d92e737812bfcd344a5e8c2996e2d706bcb58e05870e110bb77285e6ee137ef852cb0b0b2f16cf51313483d5bee743bdd4b4b2fcb7f7867e3706bd8d6499a166bb663de94229613cb26861d43585d3ce25fce6fdc5023e2a106f186af7ea7e7ba08da74bb4a6db55fc20b7f15b9fefee291093b8a42a4a615bc53728fbb45bd000da8ee9e156b0ba63423662ca6bc5522b92e7ddba41ff304e32dce787b3c389e2cb0d96e47662fed896ddcb1b800bab3057808ece2662ffef7f0264773a5b7284813c4c4fe2a88f31a4e500f1b76e2041d6d625980504f31cc1f41e5c433bfe7aed29c0f5677c457daec21667323234f409a1622163a5e212f2c1a2bc53902090d38f841e3bdd4d2fe8d67fc071d06600e0cbba5d4672f64ff2816d053ab0ff210e96323021b89d0106bb91deaf1d7b3df9ec789613ee23239604608a49762d5cf037a1f62f5da0827fcb01b754677cc405fa4751d73042429627d2d82161d613c8f9745ed2c502fdfdebe84182bd2f3cde7e5a5e3e3840dd478d2595fe01f4eb67dcc8a5365eb512836ee4ec2d0a634866ca7193b028ca76ca141d526fc19c80ed6869c6cb468e235f33ac3a2853fd3c46dc8bea32d6e027cb2ece2a77297387b23bc9cd894aa1d72ff0a160b6aa74d79be391557506ffc2a7ee43d8a2a59435b187f75a89d9f5a8f2fd793b744bcfc1990763a0a0b616828c37df1fe8730b650ee321f6afba98b649a1601920566d4dfbcf2746f7fa117326578e434239ec827338e15f5f6d32d100dd2ea89cea860e6c574f06e9c80199893ca70cbed4558b2b58b6eb333e8c77fce58ceea17fd00b65b1f1dffa5c3d47b1f68e3ef1748756da304f90e05691f12ca768f62cab70df0997960a81096edf29148a124fce29e821b210af95f264e54f563f15abb6cd05a5b9d52e19d374116bb40072337c76f96fd334a0203174e14056954b1d3610226b9c4352ab3a8ff14698944607f11aa50c3e9657ba069db6de134c092fcdb669049862bb766dbaa7b8fbfbf6f2b85d132b7e2da502b34fdeef3afca471869fc9a0b488fa324d8db358fee621eeaca7dbff44ba4e63d6f5ae968f088f59a35d55236e255e8b957b78088bde2158d5a23d215ba6eadfd51d39b641b3cb4854a95425fdde830c38123d02241ee0b85cce303a78fcb84179bc07e1f9b763869867266af4040964d7616d31a7cd66fc79da58cdbfb2baa992d4237d4220af26220d76d7b427041a999373ada251d276b58f6b24ed168da53eab65fee61ddea2e01e87a57a948aa1d39d74405019d2c2c7135707fac8e00d15bea12a8776543ddcaa56bb4b1ad4e79eef980d5a3e367a50117d8ac088fb68f162193758dd3126940df7998d5e24f8ab3c6f3d0872942e704eae696fc33bc9d1f4e3ac688316dbc31dc116d35ce2f62b4ad2ed92a9bde17d90b944b1cbe8eec63eea4a9f1d81f405ab7aa83cf7f69e58f1bd7a48ad0ff136a66c428ca4abcae2db85a052332a50bf4a9f6f6a13ce3e882a500dfb7d68c2dd6f248161d703b0a1951d5cf0c16aa947079066354bddfc62dc35738801842bd4c7b9438adeb17689dac6bef22a1a6abde2d17b5502c8566da537c59b051732f683a6cfe4dc27e9c3e4c63e197ab37157ab5aa1bae9ffc0f684c95003af58a811e21b59ca46c2a5c465d8169fc2f850c710b042ccb8f0b534bf4fd6279b770bad9716fe39dd654a94448dffb25533f2dfb772b95137b3758bf67db165e91268e62fb81edd8174c9c83ae23d8d3511767cc79dd1a857d138916edfc55bfee01fc62789522fcf9edc7e09652dd39af521c35ba3e8d5112085e29a6515fc0341efcec0b06b8a56ffa823113b7f0841f6350cc6b197f64b5ca331789ea7b7540de900c96987b95ebc5257f6d419953e17ebb16d9649e82a6e4bbb7cd45e2403b580e68e778c273d8c81fa89c02982ad6fa0a369fdae1257ba50fef62452d027a89a7d6f5e24d446b2b64b6a9e306b2ed51ef3952ceaebeb7c5e54fd88cd76c52de2ad24646ee59c3cf5b1325fb1b5e6fe02cbcf192327357d217c486b90027e7cf618271d10c8eab9fd606c87743eb843941d3fd0df409e823f3433f8f15983f117502c5d9e3683b286f6ea2bc7ffc21e2e5c68bc4f6f91d33a842c4a06d59152511af7d2f727d12e1baa00ff016be431ca15491796592eb5fd298f23f2cd33177d3f621ccc7d2a55b2a755d4cf2fde854bf7f74377dcbe4d221a510d4ae7eba1cc5bc856900d5f1e91755d79f72d1b3385618545549441a8cbf2d8042fad8adad7ab7c7c1fc2139c7794b6adcf935e7d8a596640d34137ec7e5eba7b438029fecaf52771c53f623151f0ef05ad791a369175853aef5d999219c22b503bbe892960e641a2cde21a8e6c9316f05da1b7dc83fce968002f88627f3858b6368896725fc5032e81cbe31cf06ca0c10ff79145526da0c3608843722d65e4a03ed92697710ee9478960c4ae3975afbc32a63a8bf90982141fbbea821714a9deb2ed4be7d0f6e82dc35b40513f7ba4b1cb8da82869f237408981a5df9896386232031c08b7ebd1dd264fde7adb6ae1733a06060498ef8d813aaea23c2cda85d90ffe390b4e90284ebf4f3f30e276b1e59ee09d4b7dade6b4b68911bb111f3946cf94d372f713b592c3e5221d34d06a1b8bcb34c6dab89ffcf697a35224f85c970ad4d5e6951","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
