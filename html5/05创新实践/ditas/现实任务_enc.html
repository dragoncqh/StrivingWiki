<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"73f01a3906b5fafef89947cf12633a138312f71fd72562e0c77eb203ffc13b331f9bb1f980a2e2b0f53830fd69d1957e832bead350a18f657488ba710af362b6a2b3da10ff7f07a3430c69ebef912673ed66118bd41b6b4e6ad7a98f6d7bbeca4d1d3845d0b9b0ada1d231855673d6e141be68395898f9ef4596eaf7d60909145fe891726758cf59c39faee126199f7565ab91153abbe2d1799727a0bc090f025363be9726ed8cb0214d95aafe1d2854cfd8c9cc3dd38b0730a6dea4010a09248de364732e9fa880ad0710362598db6d5b96a9dffee54b643427487fadb0644529c4ac555898ab3b27f2d0e6c02e9d3fcd88ac6fd044bae88d48b4908537cf8ab1a197be9350d65e44a6c82ddf196b88efff483897c120ce58bee2b58dfcf4a97041247139cecd2ca0408163c86d0e46c0cb0f96e3076ea80c695e65c29f06f0eaafe778acc351c71e5729e3963bdd29ec4b92b470fe6e65b76d05329f8a5e9af6a57a5020a318eab1309aab3fdc2606998ab3f3a2e49eb276d5183e89b289d27a8b5d62407cfe22813d2c182e287ab6067ae4aa06c43247c651fd668820b51b2f8de32a439f3a00ea8ee52c139d6ce600a3667656de9fdf1ab91398240d4bfa7676b619351fd14f38351ee4e9d353c41d4940786b5a1167d628667678412a193c051d37b4c5635935e34d305da93dcdfc55172ce7936a05aa101e21d1a2f22a03f182fb002abe86ee5673d71586670f0ba5e369d1c456b87dfa17734a3400ced527ff80b6f6f6955291ded3d4b4bb04e7bd92fd2b0e0ed79fa8fd981da75a870c335db5438c005742344590f12bec9c2d42df660b34c18b1919ea33f2a271091a9e7d393ca3d44491061d9f772bea12c1c9abd8e22c2e77b2c5b5f8c3be530ea85f81e73eda19e29bbb02f5905132068644b4b9b760f70b0997cf19696168d96c6b069aaaae8ee8bc706c9534416b12ba472c1a107ec7fa71ee1d14bc58c2eabfdc23bc7a4f268e6eb71a6ff32926a34ae7b1ebc01bae5243e0ce44b8ccc4572332c3ed2b43e93be156ba61cdba219553d07d9809e65ce70da6234768eaa036dc6328dd7619e6e9ebe301e8678625a2eea238788de09c8774102f4dc0e9be589de826ad3d20646b5d42cd290e4a2b26dbe6a906fb0f2fdc2b5af0aba985cbc38ae82b8b109e80635f04d95df0c66dc5285d9b6cf12d27cef88a823f174386d405b3cb389972f26fb8b9f07c4ddf3a1feefd2ac62c3caeb6305569c8c77e0b58a17b3e639d82e1af9c9b7b088743d9c6f602c093d2fb368da02c1c4fdfd18c3b6376d726ceec0fe8b0b75058aa4e292160d827564304cdb0e8b48debdb4f121e920916b1a52d2ec404d0071d362c8f155c4ab3a23ad5536d5c4d2ece0de2b26adce3c33034103c8ba93396673a2831eca712251e2ffa9842845985b319740e5510156fc9c7f0df28bc97725aeebfc78cb05d304e2ef42a54b20aca490ca5c223b1f2155c3f45d010f6ada40b012a4b79198b8c874fa788376f8847f949984ef26b2ed341b2d7c1a3eaa77cf2616db6cd12332a89e4f9ec073c7bfc5451ea8c06ffc188f630c916ae950d147f370abb90a6e72d737d2ed2d13abcadb7002cd13b648946cd56f5a3ded2c7eefc8117e0bc285b012ad78f13ef40cb3695fff966622d7c91ed19ab49f414bf0b83ac5af34c79d858c7299065d5e213e97914618667b684b5c40edfdf47559423abb8f07ec5bf9d88e04271ebb33ae7c4e1637fa7dec383db1bcac7f331981fa7e288992f9134d78b2f351308ecd06ed78fe7bdc7295f42ff422c431ad000190c0c7547274c205dc945480d9f57e5ba413f2223559fa03d81f9b95a17fb844f95fadcd3c62f2e3b53c0f092bece86a1441cb5b60aebdce037a543e0a1097bc2f465a199129e2dc1570340f756c9df4570ac542f133bca057b6b272d6e704299d570e80e02f4587e8d5d2e35eaec5752a1e8aa3bc79fda466f79694f1df9ca4e547c8db7b7beb305c10beabbdcb3e0b4f84eac709c2ef3c11ed8a1c42ff04275f2670db5402f475e3f96f7ffb298bbb53bbbf02ee32f72a4c3ffee9502a51ebddc8bc963ba86b22811479e3fc6a16475276ec3ea9306669b43df80fc43d29d01828c0b198cc4cca441bb6878ee94da7fde979a3fc610a8d0858954bbf2f29ca9c0bfa3fd93590bf97352a27afe0fa20fe9bd2b5697dddcfa179cc2d1078b26822419028455436639b8a86e14406a24a90fee079972fb23d92de76bdd4d061c8eb5fbb4630fe84decf5db4ffc6913d76288f49c34c05fef59a5d06ed6a358847ac624f225ec773c6dda8f90eef998e0770108dd420178846d3168f77d67752dd736cf3ecad5c3cfc5e8a8fbed6aa82b53003da6d5bc8a0f8f1011b3eade5d9fe9f114e8cd3adc4364b4bb474a899db34e230eb9d940ca60af4ca6a36a7ed4daeb09861155fc4185079e34929244adbf0ee8de1bfceec2b29e014a93a1b5ba55e06fcd7af3be599a71719c4becc25d04e002f19c2aa678c73f3f46c7cb043335243295ece24205c09d074740886a4d3aca6447c8f2a720c4e08f20a3a29e3c4f30c675629077b9d8e54699a89f047cc80018f4a9902f28aedffe6965bdbceddedf3dc198476706380568f2480d6e2912fcba113cd47576e148b2117fafa2b0ef0603467a63f5a15577740aa3eac07ad2e87cddd589da3d6b94aa389d0429bd1745d85fe4a1223c4181dcb10d8e41ad187fed5d51448585153d70b05e321ce60060ee1d5ae72cb72e29c7ba5b0692485fc16785a7486b098219b99d25c9d4fd82a99238a4cc58d0f91196598562a0e261a5ecc90592cc473391fbdead836be82977a178c5eba1758c518b1f3ea467a00bcb491d74c23414858eada07adc607bdd92f0ec0df3de5aee0c1e6bec1eb294f0570aacff004042758d0ff204e439ac94ad72b277562a4ede6aa44ada0a87c78065c5dc3e43e84dda4cf429b5d87cc882521f7183c6e405df742d2f9b00461c512679878b59b15add2e55c4b642d27390ec11fdfa8911968c8e9bb9ece211a8fc65702918d15c2d18c9727e1e9b71395a882a3f873fb787cd021ba24996c1fd9fd63a2c673c31bcaf830d5c5f371f902467b62b77169a12f4bc3762e13ade8967b4aeeb4241e2ffedc9041b57bf1c21baaa7b4aa75a5b20770ef48d1507b8914ef21427955111b2f15ca03e74bbc27b8b0f0f97d86a1ae0750d4cb8375230c86b7ea1d7b624579676640dcffc576692d84a2afa21a302883d110c7b90d3c5193b6560e170aac43de609108d920bf883f5551b7304207c02b7192524834d4fdd451ea67616a7cab5de6cba223da82e091405c67140e5738f852adb0fc913ad4a120bc2721e37b558f73cbf586ad34b82d9af09a2541349759dc8d9153d82fca6e202b806401e033b8edd0b6d6fe312646f33b0c0fa90f0315fd67bf589746565d634835fb8ebd154b8f02468d3787254b458324dd2d13d7a1d188e94f82c62715a13377d675889f48b1b39a4c633f1b2fab9c26f9943270b0a4ef2c5fe2b58b8351dc7b9c2b5ca4887945ecd495e19c037d47a42ac67524dd0cefc1ec4e0c61874d1c53ffa57d605fca9a0d918a5b4822bb5ad1077d010ca668cae0d6bde5d3e03ef693aae4a50d2f651bdd138b9d893847ed46e5501ab8cf80926505ca1a2053d3d8276bd860da5a71735323a2e227f47e137c6d10978ccff55ae01fabbdd03ec78fdb15d76a523eb0a3fb94317c4859f6c74d04ac847307b64804037755de7af565e1d04e28096bbaa8983607742cf7bb7170c2eae823e7a32069d48194eed2bb14828085554dc11371880bd8f6e84309aeb2e465adcba90e2cc6add645e61ed94bebdd05ee31ceb1a3b18d385b7e926ddb54e4187dbafe83f8754f91dec58f3797f03af4828946a52916957e6e394967e2cb5699cb7ad91c6c09ce55b6a78ed965eeb0a869f76833e7b6da64fb9c3ca3d1645cd087ef6918c1afe337df83cc7d4bc7ec6153a1516781857ddfcb396a947e3e155349549b76f74f5763a6c84da6db4111563868ec17ecf2ff414653eba363ea3e27371878d0df7e4cae6d35694e828ebf90a595278873e6f9761b2a5579eb1b5afdb5070c6ad8919c5fffd5875824b8bf7af89e245101511bc7bd4ca171f8fad7fa329f588a4f31d5bc8e7bcc3e6c6591d0625dc5d10e81f9a1da0534795a79ae9b60497ffda43db0819b417891ade4c29b9ef049789b80d0e6236cf3db8f9b816f80eefd919de9e9d1e440a64574b8ad05434b0f3d123039f6e50f7a4313905b45d3162ca55f8f2de3e10e517968c55f91ecc7c32dcb5362b438453371f806e9dc08d4df01ed22e819d483af70c6ed775b7c86f60d5151fa12cefa49f866137ad828f273b7852356ee6d829ed3d70e88dae593e54cd4fc7cf6a7be3c266a9a85f02ac42cc41917bcc0426534927a02126da1a62d307ba95ae04bac3b888b03cfbaa91e4f550437faa7b02089a5e5946e3a89a9d3ddf405a720ed418b347fe9aa50faac225259e11c8053d2c8494d9821a8c44b9f7c7153b78b9a58b588e7389d6d9aa9f1868e68b225240287c1f4c931a53e14a2bd494aaac4c6d0bd83bf1263b4192f4a98c3789823cab1901283f052f4bc9ead5ffa33921ea121499541896e475a333a9fbc9182709848f4a5eced1f686afe57c67ccec84257b8abd1cd62a276b903a05da162317b303070fc5fc8504d10524a6f9b65784820c0fc2a46ea0e6f5916090957be6ebeeb92c906fec690011788483c4950cafbf068c0d0a32a756248d1896eac971fd55f0627dbbcb1fe1930eadd75c950c2a82143ac2b45743df21a22bfb4ae05d96d4c6ec9b54a9af7b0bfeff97c90020fb0294fb5154d7e188a77403fa46566018bc6d3307ddf5534acaaf91be7594a822dded02130d55938d4e39a7172d565ffcf80e4a5f32b7f5699afb0990f53130411cd448fdcaad2b0c356124436c70d235a7e4b1087b01677abf583ac3ccdbc8eedaedf5e04393c188ca959358dca70f39b23fd1b118dc3cff57d477f6315b06eaef054051feee53343d72b1f4076d83b5dd0cadd0c2842dd4952d7b0553389fe3f651003e0b8cd4e0e21a7c6aadd1549ce6ffe9b61415ef73cc2dac8e99204f3162a8d94629b4c9530469c587331793d6273f8be0af82ee2a46d59dea853e4031a515655ad518227d637969d1daa3e846effdcbff373d771272de04151ded7989d1a9382e84fe8fd8073b66eed5d7378c0fa407339dd564a9e57018159f7e2664e44ea52c76c3fb431046c1131bb79b65130bbdee2d75e5b689120ec2d59a6c01ffeef14f8a4caebff6a383b284a12f28c096476f752fd92ddb5d56665a7cf4c8bd93809b79483df576cdb75babe53362c8567d190a6f13e05407b2c18fbf2ffa53fa9891ad06fc44e242b41b83af44b6bd511343f4e2e8d6cc71ea860677d62a3e591b8970379fa05723e33369fa4c71e8c84c0ebad6f174ddf86de4ab6ff330be4019340ccdca8b29c9b5ef7d945a049fd3f3a6134376a969e3fc4510b35851953515808c1697a52c1a5341aecc1b6169962a62e2153f9892cae39be140e0b2a80af4b10403e44d60131537de6f1748a0dd06e910615b91eb9ed8e9a88f66859d1fc5d979d0b564caf980893192d698f7a5a5677fe12898d0bc59f1a2d61c7f2694fa616e0f9fb4910e5f4f3b92450677b96b2e436660c7ba167530104a86ddf17bce8f3c70fae9a235016f781eda36842efd05d0e17bf7f19a593ddb3a92e19dfbcd36c207721014bf740c8d8ff3da713fe8bacfbeab65434b1a9ec56029e474da464c5fd4d14b4fffcac5d15d594979a37b2c41f6d80d23b7e399d30beb69ba98898575d39f9234b5b186523aa68afb202eef69185ffa67729711402e0ef4743c1ea4df1e03d079e9950e19e1c191a1bb2c29090fbeb9ad826e3404e9368e4f52d5c7724869c3c0e08d6e61d44305196ef92f7420ec7f505bae58fb98c0963502591dd5afdf489bbcd6fa82bb60a912cb972ed1f75845676f55","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
