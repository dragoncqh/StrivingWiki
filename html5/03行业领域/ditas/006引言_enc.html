<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"24d116de6f0106df44264cd56caae0edd03f136248cc7d4f6638964ec787d9c1ceeedac18bf7271e7f39cc1900f54ad2dac1c8360c8fca1774711653df856e813adbff6cc8192fb52f234c4245c6ad113f1280735493c00c5a13281b7be39a73590afa04ea8fd478997b0242ca784055175074431d90a5a9a46473b5fbeea9b7443259717a002304f962faa22e4a818a1bc887490b18b225962767846e8270ecc3ff399f6773c7399e70bef267495b76406d137774401ca32a825ded8cfeb3792337217936d56de747465f63d85e4b4d412be23c413cea1a50a43c437c7b5fe15808f3a2a15e42461f4b1317694bff653a5b8ac8eeada87e1c1b3d0b886a72658e9f981e00e58160b528cae6be032c21f8ced5aed69a1ef96022f453ec784c64160b411e0917006c5454bd117cefcf17459d03ec03d329e4b9b085b82b9a94782da6bb17d1df775d9d126a30ffb2949e39d9fec099589bfbd621365d8f63501a68dae4c36cf6ae041c99190adeeb46bdc42f2664831f9b9bc21f1dcf648c86c659b702cef7936649ea130ab01940ce37e50a9ab142c7f512abffd9e814acf038bf08393ded986ffe318fcc7f68ab652b77348f21a6b04b6d964e8cca86ae3c54d595a54e096d61838901265a064335b7a711438dbfd5f524240e6673ee95947d60fe55afef950710fb26c268522e92ba9296e6f002e9251c6a9eb0cbbfb566f5d1ad1cc3cb669e8ef284ebe47e08554e38952a06e1ec3e77b069380a9cdedcaa6ec5dd2104008cc11c0d495c0e06670ba05143487b68a063fc925da2d503aeadeba0f3114d116ec54cff8d9c689de0f24514f614ee31793261eedb12ce32992ff418909b7a1b485789e46536f52406529ee569ff215993c70c68cfe3e4e42d65ae1948af3209b7b4718303d278fd4b67920af7827fa8e219227e4fb280fcbe3453d1b034b10b76c74064059b8ec5b721e92fc106d48bd27aabaecff2f65dee83cf4cfa0ac2ca995ebc7202a32d2a86a0136e802bfdcaa7fb34257fc9b5ece6a5f32f6702a312b560cb5062aa05d46cc54b054b53f71f100a48eff7d2cb620a2a5ee95a5831be484ac79964120c6d5eb7d5bde704ed8852e333bbd43913b9d000fa26d39d0a8c157533400c1c011db882f1c3bc78bb42e057e81896a32cfd728fe4d93d2572e356bd3c723ad3a5ed31bdfef03037a3952542e7870bfa306b390bfcc758c8b3997e63b79d414f44c915da80ed1f335f47d9c74dc0402ca1febc03f762ba231f98222d85b45c8451c11cf89b241c24496bd194d12f034f413d0d8b8c5c0f2b02f91d501f3ea85c9c1657c089797a0d7b265e86505cc19094cf9202830e32ebf9a1fd2452a7b7e829a723153c342b2854fb92c1dfced69393f612d7e2b99f5dc5e7dda68f725ec35eec7ce422afef475cb3d91eb1bb17d958fbcf511fa1bcf421f69f307746f66ccef63e8ffd45fe2b016c4b9bec45eea679b344367c853f960e89b0c93c967f561ff87f3a036a8be58d6dd1872e3ae2bfcb86c64dd0ae6fcc60ce34721805d1414a76eabb4ebac0cef89875a7358c5261e7c17498c0eb106da61c2b8d335dd5511df091ff947f1de824733c609baf0c2d5f9949abd2789319e6c587a27baddbd002547a4ead9467e6af6e2e01f0173261bd7a31bca04e5258cbd2fc8e6a4e212346949bd86d546f0b6c048703674a34b0a026ae71ffb6c7f50bb55055ad5b4c72e654156bd7a4758a2682c78d046422a62ac194698e0786b9afb80d2e4da13bf31094ee3b64ec9a8db6dcb63298731b1413b1c257a0e2f53b2844d1182b189c9a87cd038f917a879cb08f2a990f27ef472c17a6948b19aa8ddb0c3e5e16fc6140a07640a0b6eade8658019f2749ff276bb2dfcd0f7c79d3ca8d1e19bb815f6932e0159618506d16c1c272083d179410150c5a767d6e2277ce2bcd941ad6597af701ef3578b0034bcc968bb15bb30bc57473def1f6a5611ef0c13cb0da3e3b472734663d1e8334db10bfbf6321f47cd60f46a93ee3662f9ee710163cdf9e3ec340beb6101485347e81ca57b5812167038471fb8bd7e8314a51b236fdf0437a71bb0f0d16fafa8faeea4e5bbb5785371858bc402c189a3a8bcb46c8c20f72172bdca6843c50657fc5fe8fd6a58a7bd6a692083ad71b95ba1579d8f2c0095972884bf290e06c11998eea61411b90f86ce96309a0a9a932c6e10730c852a444857a89e6cb70da58119977b232637398f4bd0b5eb233c0e7573fbe753a88c5b5df097e9763ca66b0c061ca12858d136ed2fb7fc7222e0d18dd63e7e79231ade8a75fd627a3be32e0a151ac19c85753b5a5e77c800575ce4adfd9e843240d7ad85719c371cdf0508df9dd7d9636aa8ae5ed0a61bda306637df5ac01c0a6f9bd2473c0c536c43bb59164f32ea1e43f99ad5ed5099d28965b4b21423c82ce4b77e537ac9a282816bd2f8bfc0c28922e77e74941aecafa30277d620f54259b9a1470191390e47cd40c3d250fad710ce57f909bbe36d59306ef6c3f9519763241b2afd9c701edec53cf528eea99ca032b92b881b80b6be9963878e4b148c502f5643d6fa108e62d1afc1712ca66bec94c2bdc15bc0015a233ef246a85bdfe776099aa8417eb32d9552f924bf984fdd0cf5bef1432bb5bb55f390a7bac0a7e9f37f6603c0c8cba49350c36b550e65ed699480f436e6438d1fe3fdda104442b3672bef71a9b2380f57d555813f42ba40a009cef045c235d3feb0b15cf30b4d99c67018737c239d2bf7a37a4a5ce4ae44ff48fe50c32e44869b87d5cb6708f3f38d0273cc2fd3b5b9421feda9191ee9e3bc47396988a0e76313f5b44fa19126e30d1771f59123c9f291c4523c75376cc001a8c4f8a3c1f401287b2eb7d5fcd05f8fcb177a4e1bd1f013ac35afd564027bcc54aeb9a4fdebd9cfd1aafe493caf5871169457c7e6e903a49f49db3ff4117b6d5e5c38b1213809832ec261d4aeff5879a9bff32ed7c02e2a96849b8d6fd9f543e02be107dbd2dbcec9ba29386a54f86fb07a4cf9a12cd7f676008209fe497e7a15593b0bc21df4d1c72d1e5c39a67e96d5683c40e768e9c83ca46409c06cd1584204c0891b013b9a961b6e0fc708c574d4f3d3001526b107ad473f70172668e6b6742ab0cb78a0cd036a43c78acd9f21f75a37f0a983e68fd024aceaf865146bb6be70c0b8a21fd3bf9f751f1439eb6b0acb319b8344d4b2197c02619f39f032fb4231d1e27700f647b0ea510c0e9141d943edbae3480f10fdc1db23621fb2e68e3f9c006d82b240d5ba48980adb5fe8f2c17e6c04bf0fb25e03781b8fce5ee8429bbbd275f55606b8c5be40729f7f5e8e27ea89451dd60021a4ad377543e19517160ca9b44ce1c7721fa75a7e927c5b89783f8d4dd014b99d7c348ba30c44aecc37d5734b4adf3b43613949857406d55ca4632d8fb55eb7da2305c17b90e1cc48eee43de00bbc739cd6575398fe730cfe8bc314099defc5ed7793f6f16efe8642c9b181144827aaed3e84643a66a17a2bd83287c888aed81877a6eaa1a66b96f634f46835a566dd32158748f5d67438df8e2e70ae5363f72db17657613ad9f4dbbc5dc2883a6dfc14f6bc6ea917269d5391077d2e0f60627720d0d9e009419567fd8ccd004dedf6fbaebc52662b553b6fe58c3f4964468c8314dfc791f3b278e59295e511ba7f920d99b21a9d234bea25c1ade61ff0e7ad73c543044af51753cb458b79e642dd88535339af18a9772fd3e8ae3e0fb02067e42289b27b5cb92f964ef91a680f16ec04a277694e442a6ba658ec9887d8b2a88a2fc25a06009f13f88322d806fee3a1826451e1a5462844951822872b44cee5e268be020fc3ae195bdc7a47a8e8a0a95728237d59b41a08e05da6705ae84bbe343bf0fc2f923372e375c8b3c996471e02161e68040a669c734e731f59ad14e5708705926c3782b8e878eaa5484df9d0ff1cda878ddbc33f1833286ce7f6bc85f77adc2b4a84d57449d41bbb89ba1f041dd698b8e60ba6d5dffa6d6e0c03d5445e8a886c36ba8c84c2dae6d73bcdef572bd507c154d1e465472d35511da22611fa7a4b53735af5fd94bd0a97c059a397d6ee4a7d451f07a41f3b6a1bd3911ca9ea441c7f84e744b43b8f6003055c62d8dd80a77e3b68f12c395c8c56a827156d807481eba93ff39fc9449c3691046f71ef63adbc24505b29a5be240f5378fcece9b71dad71ef202d78e370458e26ca87846742064797065b6ce5307a9481bfa49984f30a66dd6ef9af097c1d3f457aad5ea89f5bc0f3363421512434560d98b1e8c3bb06ff709cf13fd235241873d3dce133952a006cb55796e03337b839c4f87371b02c7aa30db7aa552cbf6017b762314f773f9b5a6253c992cea071643d76f7c117e77d612975ab6d87c1e733d98ab37548d2f0007eb3fbb4611c380a1d330cd5e89e8dccbb6a672c9e64d211260d956b58cd5a01335ea4d5b18072cb09eba60ada1904370c1101c9cc522630f82a69901c64df8338a3256567a12b61f9958c8a80460b3baaea3cd146d6980acbaa3c7241b6e23815f6716eaa4a72373526e300c4ff05c79498744f8cb97c63ec3c35f597f3cded6311ce266a9ee2afaf210b83e3890537127a1ad690517ba7476f27f5a2c9d6942e7fbe2e5cf8e463ab70bf94a648f6b7edcf29ee2c31a2b0bcd986c785ff6830db89d36f94b378d135fc256473e5d03916e8e050b882792297f5000405cf2dc85363139b8e153f6c10e8595363849794944ca5fb9dd3423582dbd2afb21239df61b0105b867b28a84a4b4b4e471a12c1073965e617e789dc02ed96359c0c685839653932bc81bdc11568959ddbd17869d9a0646f07a0e681511c80c455c255a68fafe765e4b97879f894b10b3e2365a932f0cd695048439767e6eac369b3200eaf80afba272ffdedf7c364e5400a8c6139f92b3e8f2e0728ec706b3e560cf044b4c8a51a6f5dcc1fe08b39817fcfad39db8aef33f83d081de3dc60599e5bee87e75968a5fb9050a767026481f60b77fdab75e6b3cf5e238b12966c89e5ef9bf6acc82c300f255d61fef8be8bb579f0c1bccf89b2fe60e05f0e358553cf2f79bb157e50ae85fd4124a57d38d7f9aadedd812117e3e5c8ad547581b4ddac58ebae85410c1e0d9c5e5cfd8d6a485a1b3dcc7d6c04d9963884243f48608","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
