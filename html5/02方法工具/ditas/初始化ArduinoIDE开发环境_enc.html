<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"83901252de7513faa81f4308343d1b17bcfaf818a736536841d29d1546743eb69580576e0044f95bc778c9760bcfb7db2d188d682f7a457dd731ca0ff80ec338562ac87fb95c76203debb6b1686da20fb663540ba72beb5376984eb451eb3866929ebe79ca5a399c4902a45bc8f5a2d72ee587b57b3b5c66fac5301db5cc054e18f35c068d38a6b0deb7e78ce5558aef831b222fa1ff57cae6b8bd8f014ff741b0f70f451c584f058204ab66bd02036fbf6845ce79ea70c1b97af6dddddacdf96c3d3d5fa7967d2f2869f097276848e0855cbe1f4745701daabadf83a94ce16fc588e44eb7c423f6b1a3d9016006e6205afafe0d8ecbe21a1f586426f7bf562373df54870078875fb2a3d8db9d437cfde433fe850ba4078b42d7ee036118e7e5aefc9400312fdab89dbb1a17e26685f74daaace23a11e0afab893858661f1822bb7294c8d866655e6864d99c1a00ab1d5b8d9817f9f72590ba2e1e017ee4ff2d90df6d969e25a8695a12b79850ac6a554e7e5d85e558131e23cb7c9d3a829ebe547768981edcf188d675dfb2c492e47b53c7c83a6553da24f815b1cdf3eeece6d01da378a5f763c367d8a88438205e955a21f8a9b36e9d4c213e316ed6a8f328d7ac4f89f753180ecad69ff01dd83c060cc7082f8a800169a6412a3bdb7553460ea615ac95f142cc92628c18cea38438a23586755cbb379acad90adcf243d2da3f2cd94098d864767012a8cf7a8ba41de941178434db7795d418ba0320c42deceb3a8fd194c3c900de1df912998d6a10b519004d2c2780ec8a954fa7cd5d40ea34e368d82ac614dd49dcc275e255004552dbe05d32d02a12e84bd2d8caf9695bdd195183a9bce7814c80dea193a717026a839983a84789dde33a11d939ce1bed50ee51ba82e48e213caab0dadaf255f4b4f9d4f2d1f12fd31bf3ed305d5e31cade07582d35e67898e90c5db94ea07e703889bd51b61c9bd761fad99bc6dc9637ae3691598e4f9a66c9e5ae59580924516e191fbe71cbe9bf15f182ab98f55e7d3c1053f430b184bbc96fe8144f4d730e31d426179b1f05bd0c4d4fd7f222d50967bc018781233e99894d8c1e71cb31a87066417b9f8df040fab1dcc692ae6cb0f13ade198a9c8ec22dfddb986c3cf1ad5a65116e1bf0e95b84e515ee23265f3a1e411edbc731f1f4aa1146371c1ec39e1536cf6c0720c30b4d79a05e873d39559e0e4572b7945cab78821b301587ef23e1ba9a87f2bb4f6c869a9c434107bab8186d24fb2d78678e48e4c29bf8f8a4aefd031b42487c61ce56be7b300181875735b275f9208c0c5598f98ceec715b37e79142e72963005787ea1ace8caaed808d06fda444d130fa568b45e8e60fdd280273fa2f8760bd16b19004fa5edf5d9dc22cea5d963c4ae0e1e044a71e612a06cf67b9b62e0eb310335c8c5df239f9a0edda2b35f233e65a82e2c2181921dada752b97fade0913f8956cc122cb49ae718ca3231332eb216f4d65cd0cf7147d6889424e8e829213d7cc5b81c6bf7f4bcfd5426ee01758ccd46780c04e7113c92e364a02adcd026d002955756574fa9552227c50dad9e37201587e35469a28a1536e6fa859a2b4e73e34337b3fd6c4299aee9e5336a1d8e24c22ef7823cb2d80fa9fc419cc12f9237a862ab35f484dcc5e4826dab46c0a9a147011dc81077fe487776cb51c3ec1aa2fccd5834d0c3e725d615ac9421483d82979478f0c7e9f197daf6fe13568ac420f59c8132c7aad3cff82fbab29160e525a55b1d8eccc369b31d6180c9b7b0206e09ad86b3d80ebf7e837ead045b35999c126cd79d0f0ccd37c7470286b8f093524ddabdfa7ca70605dc57f50ac45f65981aa225c264ad4f3c4cfc7c31ef379af75f6edea4e65c049066c6bd0f6d5e9d16fb8aa4d48f13f31ad91a73862c4470a9c46ed158b10751a7008bec31fc390d3abda389b5892c2ded32c05a5440b965b0b96b59ebc6c3904bbfe7fd6c9175ef2262be231fa61583b58fb4c935c1b6874b7f2ca85a80c142cc0f213a703c2b702c6f4cabc1bc0c7c861ca5437b9fe585c6641e933bc2cc492bf3d284f60d93c2fa61674185b418a2e3d9e705b671164832a80d141e5d75d78e72fe7416e2f33f3ed1eaa67519fbc26870abd8e792682eedcbdde0e329a79a5afae5abb263f5624358523f61e0bb94026540a8be6f0f142df4d5d2188c47e8125784b68f0d8157d969b5deacfd2e306e527bb7ad7ae23e538dadc6550bee1eaffe03f21d809de4d532fce832629276e64632d67c2f50342ce1bfef49eebfd65b59192997c7b39d2cd2f2311daf3f606cdafc433925a5f37875bdf5cd1ac92e6a87931f72e1559e5334b4b832008c239ed953cce5aef32034f0c555fd33634f1d6a64c89c8572be6ad85548205dfc4c3a11123c4fc3aa4033e455829737c9e71acc448342772f550b5fd3545445b15883db3898a880441f26a974f7013fc4a8f088e4a5d3217685782c64705cd5d9b5f8971dc71db10603003ffc42ac9453ae4fe6e85123d330d5558dd53c91685c69b0ca58e83534e91b9c72d8a76aac60f2f11fb851e98b393f2c563e9509b11d4029736da07fb165f9d307f76fd20817e5bab2759c43ae556cbc9831d37452259057873104bea987073da9cc1ad745e6a055cbae827a3952f043d585942ecddf94af02ee43b3107e868f2c7de989786de52ad5b96d3802a1805b19984990151fec117c3ec02ab300614c8e5231649535ffb5b6d276c6ced53ea96b6f3f037561e866d52bc43d9a61ee79147b7339dd1bda9b876d5333465cd72b2b13b073fd781e5db9c70df9f92e85d1543cd36937e69a1a823692eda69280b7038f387d0ef01961a8178cb95e0ed41e9b597fb3aa8bb26155f4d1daca056a57388c762c73a7bb82636979eba6e197de9d3767229b2b03d97d7296b36e542738dc81e106f65d91743d43279dfc834aae27db07f79836cb4f63a7fdbc6bbd257e611e626baa4511b7e89d7dc7e6f613fbcb956dbf4dcf49ba9f21badd74360aeb6d75388f7d8ce1484b029ab8c20efccea26bd1fbc2aaa43b3bc464520df0dcc741959a973fb1afc65595402045e6b159120667f1c7503632b6bea6991507f83e0f328f43f44c5bef9ff5d941794cff9dbd4fe205d21d4eef42a2f30d8bd21f74631eeea4c302ecf3a39aeee54002a92321f6f1979fec140ac0aabd9faafba4c67b335b934f6daf9ee181bf41480f26e5db22798a00379d2532865a0b775e8ce65060be272b0be458f6c3a3856d7200a4f55ef5e3113875bb4d479d2c39ca72f55e83003cf419a53f191c0b69aab7f114899cc462f836b0fa38b124ec94cd5e1d4d15ec0018b06e7f15ce8883c68670ba0e7b415ec331f6d5990586fc5e1d510bec098829b6c04692c56e2fcd6a71cf91cb18ee56328f417a51c88d0588ace0c5d8d4f509b35407422468f0f1520af6c38490d3a84ba5ab4de11899e8edffbdd5ff734d1f72e1b9f2d9da827d57418172f9024ae9b5bbf94422e429e440f43929c49995cb8b8a554dcbef8862e37ad5f40fd8d0760252994cf9e6ca454b9714f3e40a136da0f531b30144b6640d6c007731d798a1f980bfbe2f5c0848fe1e2a9100b5c0be3a2a30dab3da454711887266957dbc29a2f8c92594957ef7a7239f78455692f2b033d8b4275d652397e9b2e1b2a3c52c87b38fb68b92ce15dfe58c4bb28efd26f398de2cf3483bbeab798d77a523b84648b45d55f6744355f0b602376a60f98205cb0075f8afd152e0fad3b0a4db31a22fc2b9b2f07d86ed677711bf52a413cc5295a454a033a40abda6b174e37276859ccead8ef03ad26d18502be3718a97d1bc79f1cb97c19b2c8a923a576f258c228671a667f6f59b391d2227cf9fc98bf6c62433bcb3b4ceb5063a28e4a6ddfdf37145e51f3bb2143ac900cd4fea5bc331f6cba911becf9e677acc336206a69420c35a1cc1de980bbc63213df0767052afaf24b2f769922daf3471f272406dabc2db692f6244019ed9766f84c2df55c0dd1b97a5d87f9bc947c6fe22cafc2b6bd970cb0901266630ddf48f405eebd650f22b627240e47077bd529e3100d2074a149d7ea3ebc38e572b0061a9dfbc5561ef38bcc45c0af4cd3c7fa9be21865e5b043c21849cae8283c33d536baff91ff849f05952d1bbc45b29e9e4abefd092e1e8354ef3a2cc9fc211f0b53a27dd6d3603fda3d55a40573981986f70bc045194f3aa17bc0fb0732dd46f658e93019c0c42ad9a46c0c5aa76be843a5c765bba0044b144da5239e5ef9a8f0628bcbad376a2259d46396f65a4b7713692adda988b273e9ea0fa3d1cd6943ee7cdba87ec7398d42b283f0ad3c14128be502a8e74df997154262e534cc0b7aa797c72887d7ceaac53904a9d8036da6692462177aaa4430bd9fa938f378dabf1fc0af54b811e3c4050dbf61ee8dbd68da523585bb0c10cc019401e272f2a10e31e93c5b2ea00f549f4eecce4a199ebee1765113ccf1dbc6af4fa292e08ebb7747ef031e6463ac761ec58a321e30be9a88902275104701e835dfbd738c1b6d84cd1b4d4c44feb75b2c0a0491a87730a98eb48eb2a39e26c779994fd32661e24c9c731d9f506e06d381992a77a50c51bf08321a7f54504254af88e0fda865a1872a1856409d25343bf10d37c636fd9c9385a89ce0c82e4faf359261d443d344106dbbc9444d252c4041a3262e0fcb1c23203509b6f56b1700708ac690b7f640086d372fcb4fa9977e58d1f9b69615cc721a8d7a7f11c477bbce40acce57d0fe52afec472cb561b44ca21d367ea56b8b2f75d27f304481bef0cb6a0c79410ebe3dd506f61fa008b190dcf2f2e689991385288ae34404728efac19c23ac3f41205364b5c625f9f40debf900aafee14316e803b525d74d7ea03267e2f4b1025cd2df4c1365b795868dcee637710a6286fd972bf555e76b9f7d6020bd86099cdd9f38dba222db979f19f36472f2de5f728f541eb3ec623c74db30331f5ae94191e93cd8a7d5514fbc980ef817a1bcf03596e6e6713ae53eb407f5861388d9583e172ee21540536f0eef8a2cc5c2dc27f5deb05531cfa70f099c8ebe01d3d2d937ee0a5ae94f145a345b53b6b5a80975b3f14b5fcf1020e39ff0a2196f117accc7611a15ce821a7e0182488d204780ed7542fa1c3e3fcd1fdf2489d809f6da82141a59aeae9fb01470831645ab84f3d5cc38ad095cdc89fae79c13d5a06d770ffb859c610d1536bad29dfa256558196a1bcac89ff2746380f73b98b15031a7cc5c63d91b245fbae583ee5f244a1ed2eabb83c2365c4b3bed31ab895faf95525f9d47dec1fb8e6dff1d1ac4ec34a4c5fa8547171c5b8e9015c1ae8b29f39d5eeccee9cdc4f1269260241d1ceee97c4508f27d6ee20be2b4838f9e6cf6bce2f8419eeee1423ffd1a8fb0e14a91bedb609187dd7da355ed649d04a0dab511d89acbc33657d49e1df7be7ae1a07f0ee9fc7404e98045b7b77daf4f01467d53f1e981ebdba5d22ca4752cbff00348da991e41a860020f551bfcc53012609ff6771460c1ed42309a94feb8a67da9718cf3d59edf20ab2016dbe957f7b3b7682ce2ad1c72cba4fcf84120b17e3b046b46504eca422996dab983a7bff63751f10c014c8ebb71bb8ca57898abbd4302e4bdf5d718f976deeba8ac269b30deedb727e905f4490fdc68ac309f6924aae08e8084dbfbf154745d492bd4eec4d47f3b107e5dc17523f13dd00e6b4eca85af1707a5230eb458ed4e89638af40ce2a9e00d2d95c0fb8366555a2556b7381332ca475b5b3e21e73f8fab87549ac293c9d892a809bccf8a6dbc9263e75a687646b207adf96050eab68f57a367e5361fbcdba1f144f765e440db0403b04ae278ae807219f46a0b936604bbf2558cfbe223954549979e3a02bd378b4c361ea02734f5b29705965a178f6d9bcb099fa56576a3dedeffe3494395cd92a3a747e2f0a295d7ada88613b387af10160f922e60d4c01c75613869a42c36a5136e2089fa86d43a2c747261efb3dee6f921fc35fbdb297ba99cdb750699973cd1b4dbdcd5e142346152495f5ea87da8fae4b08a8689f055c02f3c7006beb9bec25508ef8d5cde257473b853d32729d014b01a853ee1e8e5e86c0bb307f24bd7fe5c6fd7ebc1face7af20d374b1566cdb1a1f7963088f3078855eb5bfb1386b414fb33fe0ac456bb385c4bccd1950b9bed13f895adb6681aa3bbdf9f4a6ec43c6418ba0319113e0b9816f8a43c4863445f4e3c19372b773ddda1bfa62e46f7ef81d17ae24b93755789ced81b825e71558dea2a796cd8bc3b9fdeb2ae9ee1804d07b0267e71b7cc88dd3a25ea232faf7bb0143a77987279932f3bcaad29b9cea7d7f51f5577d156b66ef8e73b192c2d60751d969b79d0e3f126cce22c3cf80fdf1fc75418c455851cfc3cc5211d291a1d407612bc632d2afd3057051c1f8d4306846a8c948aa508d467d2fefa82e098e7851ce75eecc412c10ac023b79a79caaeaeaafa7d7f776dc1c206215c1f297588b4dc92f91c970a8dd41e40eb3ed9acda90da396f7773c06b8a3f1ca9a9db6be20082b639cb56d0393e1fee6628d2c01b5932808b3a08cad0f17f75c9c79c43be87146f4a7c9c76af19541186e79f0a0fc9cc740ff6e5bd00de5600e977eb8a69773b2441fa1bceb914879ec992e19b5fb5051a6fb135fca01985d4d6a781c5fe16a406ed52a04599ee35df3d1f95e48f42f4bcf226de30e68fbba5fd333cb1b73e44fbbc81aad990b701ede4e61d6d9201e3e8e869e37dd3462e2775143b51d3b03cb92442af13140f70141d8e533b51778976feecca2e79de63f83c2908d99a9b3e75b6807ba2baee515fa3741cb5907115a467a18140e988cc82c892282a67ec11215052b15f0ccdfb0470ec6e746cd1344c2394ee63c14cb5a4643219bfdbabca674452d9fb154b4ff9407af7b686df27ed850bb40a80bf36406b5d22507c5589dc1571b440257682067ba5fb5f7e9ea4654d3c5661c6f91b4ccbb1e4849caf71dd9f9f6641e9795afd1c540018137338a20effb1c1201978b6b25c129121ba44c6041309ca9e3222c3fb54092403e22e8d9697a5c86b4d0ff444a387f9987c2c27bc61bd26ea8f67b520c8dec4b81253d696bcc64f04d9a4242bdff8d76bb8b7931d945e12661cc3ed3c101bfe4b27e9c2f5f0c85f512eadad74f273f1948b6d2fd0dd5f8245a713396031781fdecb378dc5196f469e59afafaefeb32fb29fc507ceb5e11a1747c1f94b171d005ba99633a5f2edd029b77f0a1739a754bb7858f90becaf6380a6644bf2995234e3ef3f26d22224b5a181759db41ea0d09a681da58e43d8dfccc69cbddc0564cabd9d1ce4128af7d784bc4b7150f0f8e1fc32e358ee8bfeeb4267bee70852d5871fed00cd7409747cbca8ce197d67b24b89ee985abd5ff4cae41f77c568f66e27fa982d8808e717c5b61770f59842920b6a14b2e72cfea8ad1936e4bb8f072dd6fd5bceaac188aba399b0776986f4a7353e28f2239ae070d5a0f2e6ba9ee5d0218d8d8472bd33a597de31ac0fc495143c71f436832f0cba04d986f1d3699b7c9cbfded870a3b8fc727e45a02f30909abb3f2f31c2d5cf291cf965d2f33ed6f4bc1717845069c7fcf0dc83f4030292ee68dfbe6363d2a30b0372de34b10f46cdf1bf9c601aacb8136f6951dd6a4b28b06278efe4e55cc43d95b8ebe4be018df807945c82a693342289b018ed28df9da787ece053dc3131628a3e7e3c0b533cba513d111fdbf7cba51893857ffdab89c7e1d5fd1feb60f6563a3fcf44f5a9aebd723ab14851789540a1a44fc2962a008f81dccddb36172af081f3d3e2887512eb23a9b5c0857c8f12804c012305426e0162e1daf75b7b86e36edf5c04bb7a509c3a9cd1c333e725fc46165e8f02dcdb597f6b9c011c649ac5b7d53357b58f14dd4bb7deb17b9b5e13fdd4ee4d3c569777c2653fff98b73afa23fa0f601d3817961bfced1491f5c12d91694d8c7b10ded9456045c9768c198b0a4fdb5d29a7b534f2c1ef6413a4885d4e4e6101c92dfefdbf2f00d31950c1b997278a722145c08cf6d77e6ad31c4c1f15298af202d3305c5ccb3c2ceb4930b4fa6165d163fd3bf529aa7e439cafe36f772ad1ec0fb67665633615d0a751227d136467730d3d2ffe70571a4d4b5c608335377aa7490e215b1b62f22a6785520034bc96ddcc7f9b3220d566d16c15660bdbfdd649c274203bf6bc226d8329ba8cc1dddd4d9b97c25f39c256fb3e0242244941a91bcde96b8e7b760981e14096f526d4ac9cc274d0e1d6f5c2e9dc2a7c095847d278128d2273db7f80967e8bb842a30630842e22af809f739dff633c857b15c2d5465b6844b6836f84b7d6f17ac729b18f826c6812880989684dfe14f84a9d31bdfe4764545ee9a7aad461e01ed348ebca1e7ce14aa43f5ad67d40ed89862c1983dfb613fa838a61c3eaf7f2d55782367c85082509b6791e2f230ffe955e62098a78ecdd5b7faedf70933cc4e6bdec1fd84bae726738b655f824f3d5a40aad9aaf48b71cca75379299ec4cdb496e98aa9201ed153d182563a85fa6cfe47505eb1fa785ecbd8786d1eeb8cae6d65c31bc322e6f4ba78fb9d5da182b7bf189a7ae8f6be0cb3e0889ab882bba2be7ecd1483673a81e20b456b042850a708130bbaab8f23c7bc0d0177dfe580ae704bda68e88007269367a1e6a65d49af73b6a9d9b8fa1d6a85c079aaba76eea72649add8d86caebb5d991ccf6845c075329a8dae9c62439e1905d96902174abb82e49b8d9527aa69e921fd808ba68ba508d8850cbf1a4ee8babad2b64aad7007a2747b2c364b6c3955b7d16ddb71bdc580de7ca838b693402f678714b4b07ed38b41824bd2672b78e411ddfa8f18c6b996b3c3a5d57220ad049ab89697fdbc0e0ddf6f37597d972267b52ed04ae4d324552a9405ba24be708e0d5af67afd6485c4f2bd7578558fb591a8fed9ca34b9961971bc8294e26a54d6ae1e9c1233b53ed0358110cc47bce5c7e9cc3ab1d908519d1dcff36a5811d8812790d1030ac2afaccbde6b6f5dc143cd8eb6a30079852409d0dc865780ee4f8f684c387bfd5dbc99b421c14155702eb76fa1267f9e2783365f16cb883e39676bb40a4ebc932d267b0b5f9ad8fd5af9ef883a80f517e66cac28d89c83b13680573e68bb0b46045737f499ec67c3da25a2bd237ca24d6eb04bfd6c9aed5ce6bec941f20013f86f559f7b27c2ce0322a8b36d8395198f23e37fabc5c8a97181740491efae3dbc68f305e59908e2b02769cfc2d27007905d52d20f89d013f439acdc7221ca167cdd8319c6defe540df0e937ff8e0c3d3e135f3c891ea32abd66faca0f34474ca3229044d72e7d11b4ff3fc7611949b546504f62c6f5fc34e4e07bae2d666fbe63bf520ad49642395e3df0b6b936c6ffdfaeaf498cac2dcecb6a7b4f03b05301419aa33a818efb02f4c47809731502b730040e247e174a035ef663e9396404197fe5938cae4d2e9d9e455651ed2309e769cae19a2df231cd9b3d9bfa25dd4b3c2be4c1e4bb1efa22a2cc6130723b1d723ab80c17865d9b4e0831f83fa5e444de945ccc3e2ac1cfcf312831f82f095e8a8038ad362b1c2bb0fcb46fefd23f6b5917eeb6082519b2a64f7886ba6abb21a7b3b5841c534032cb4fb9971dfb7b78058a236a0585411198ddb6a610a3e4053ba8b6c0baa29a7c17994e63dfc5ea094b0d4d0d29d45b10ef2212ba38eae8459332e9d3b896e506068234aabecd6a45ae17ae0262311f2b5cfa34e488e5958acc855233c3514635dc4b0139bf973160e5bb867fe7125bf9f9439883dea3bd30efa3ee020996a1dd3f9cae84042a6cd3c12a3bd01a86ff0854040fa360fdc520ebafd0a325ec18ed8b148f3918093de284275b0215a7e3f8a44951acac6f0c6dd24941de044819d0fe45f71af963d5928076865bca086d64b8effd341c039ed2e307f5e45142d8f0cf694ce51940663fecaf0a45e5c1d6badf5ffdeed4a95dfe6c6185bef5e3c24edb31393519deeaca680eeb454fbfb8e79b9c05dbf2fdd791d90ceda7f503eeae70841bc06f4c28bc3a7cb1e39f92850d9d93b50b073494d59f0ccafc030a350b6560493c292feae8d9a60f203f6f653141fcdc35d535369ee4042ed72b7ea80261a9c678b056401d0d4bc139da39d7381f670c57b87040be8f544362fa4b3b5e2a5f55a898010723803fb5c1a86d080214bec309942614866ce671b57a6687af7b828088fd0bb12d1e908eec50bdf368f26d850aa6cdcdcab6e12eb248e021e4e7da5cc0c30cb3c59e93635a87607ce0510c2bac11a5c7e9eec6257bc4c8dc7cfd2110f22f1751e65c00b12c2aef3eff74f3f6b279112d8e3a4a1b60ce04aabc15b1d32b10e44a760aa433d3908e84601d77bbd51b35b64d99655f33ad79a4de0ba25dbafc46aca3af11755f5aeacb616ae383f2e66fcfdc31b8754dd61e465629b34be593df163be80ab13b50a6d9dd8a63bea39315fa150113747139099afcd4f348191955b176569edfb89ecd321bf9638d4215ea6d5bb951452d4982792d6d25b62f040d71dff85bd5798a89a047afbdfc2ba328fa11b237b6829156a477a9cfc55e0ca961c41f566431b32e4ccf1419d941a19956ff46f3b6e374fed6ee4b7bd3d974bc122e2756e3e04942770e44c620a864a1060d009d22a48cc8bb85eb7fadc387ef00af43e90ead7265ffaa9e7ecd505fb7365f17c943ad22b82c975d45a8a8eead8133ec5abd3f4401e9d8ebec641ed84fe3b8073d403da4cd20a7bedcba01f2000b9cf828d7371b776bb62827fddb9a5d30aa823ad42a3201fd6590dbe45800db15de4a1aa4e98c89e34cfaee4b7ae0c360c3590a5e3ba9d2edbccb757a11958290a98cf8495b2a688c0392d18a8528f51dc6e0780ebec8a7ed10163d3cff2ec6d9492cea6b7480157c2903487cdc81aaf993b8a44a0976bdfe2c1e00db1ed3a7b778bab08831ddfd3dd78661589e8f7077254e30b3a1d35bde62a43368866d9306ccc7d3fc9d5f84740b2c62dfede8964dffb6d6ce158dc4b9401d380552f3b13ee4693973ef507b4ba22ec1bb8f5faa2a9968e226dc60fcecbb9b2c7c883e2fa1a710f4fb48ae90b95f3a77fc","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
