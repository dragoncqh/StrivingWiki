<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"98f4827fdd09da387f091b4ce573eed4b8d2c54ff5c432383fdb3af3db02e6bfa95d400e47617c02b1c7c6cc15b91c203ba2c702e7c5c4584dd6004ac8dffd76c9109df3c4df0e46ca1733027661f8307800352bed34fa3e85e00cdda3951aa545435ca5172dc186c9dcda7c68669973502bbee8c340dfc3cf1fbe5ec0f2d13cc189a0798bc7ad978e2ad640bf756360b320a5e17ec3729997350b6678de4ab126e27cddef3da1b4c0ebc52b36017d5de6948e61e270780551b0cad9b6d67c048dad38a4637c716d45b1a09074c3f08c41356b36d4144545f5f653baefc2e89f582d9fff9b92ece693f877868e7099cbf00eb4c49052578bdd25fa0d65cbb1c167c495e0a44df1b04e33819b24a34123966076dfeeaba176df4b33e2c58568520f44e76e84dde1c2e9bab629554afa11e4158690e58443e8b8058ed566532af324c65513db4d44c0d622af07c75f7066672a33b97b9d50c6eab14277bcbaa37cbae7e0dc28769f73e6c681f6e101d302fd5c96fd17584be50b3d4142a239856e3dbb7d41bd8dfcbd0a07909add62797f549322d6f25ac89297f884ae87c31846995c58f93da327e3f039e400713034c50cffbcc945e0d4e86ec39b5d1be881fadd0dc85c3950353dadea2b21a5276c951ae5fcffb17ff540f219f026d16eab310ab234f95860b6e852fece17264c6be5b10fa493834e36a0c336c5e796f852ef072f3c9d8e9d1e6846bce10eb3f9243ec5cf6bfc2fbf5f4e4f6d72b3018ab56e481a177bc1cf0b6ec28950c428011c9ee2c96769ef281923764d8ffac9d69a270da0ecd91807dfb57cf2cb70573d2be4e413ebedd1bc404e1035747b01cfc537ab4023ebd17259e9d9279bb2206bec074637c6e85a9cec18b3980419daa27c6985f7d5d56e7777d1d6b302767cab498d96b64e5e96a71a3a3891373e48953f6de03f3d8d87c135a340d65d04a4de84283f1d2fb14b24ef8694c290266f0430faae171375746e1cdf63a4f0e35e0fa52936d6275f47efbd4d7699f3a1aedbb6a5dd5ce02c050d6645af51c1927697610cfd4428e015285fcef1953cb75764c32abcc72644de277514707bdaaab38dceb67b1a89770310eb1f00aea72a4a0a55d7f4e6004bb3d6366acea3bcd76ac0225fa908c9ea0b63655b1bc18f4dc7f91c4d84c2c48cae3488965fe37eb06c0f5be1b7a81a957bee9b1f3b5cc24e25b8673a2aeacad899d6b73ebe57401070d454df2b711e4cf56eff65af348fd6ce03511ab0c72795f71b1ec0b2dc12e6c85f2dc45f7013e94f7f57647fa9df82dd8052f338642d7d1d82e15f2cb52094ca12f7a016792df7003a79d8a2de98e4ef2c143bdda38570dfbff64bc02a76da8cdfe3e3fabb3fd4cfd7849541f43c61b51e279f534a940d58abc2c545e1de9ce965dc8fbd874ca421f69b9cbebc09bff1b146b53b0333ed0587f88a4f1fdd66539a2f06a98ae5d02a8d791f34f6b87995d9ca48c2a969d207ca108e8c57bfa311d37f764ab3a86d35c4f4b904f8195520435c2d934069fe3f5a72fd72a298ec4e9db2e4bf5fde48a69d9a695e4c3bb59373ceba2764097f5bb377358d4eb2da703f91eb478f8810b1d703681618c4be074d51ecfbe963ddd26d5dfb93be7a4034d309b9685e7e70ce9723943bd0d7b2a2b75012e0cd5351e7feec405e2f307b353802b554b565ea6d1f7efaff01007215022200fe8ec8ebf82e2c4e6168c0234c64d16a0bc3c2e3d28eb62840719a406d8bf189a9a02bd377dbfd5844f5e779febf63189e709b73f4ea78a7d28e42701cb5b2b068f8f9862d361a338f86d632aebbf3b1ba7a7bfb4ed8fc969c50040423aab62d6608f39943ac8546fdf8c1ecfbaa71acf210a3ddc8d3a7f962a4070f4116e0ce1d31d6e171bf48cb27f1532e39b984da1f2879458c11505b046c233631486a6320abde59f7d73a2cbab49a73a3b990077823e04675020d50f3ef442a5bba735fb6b1bcd7c9e74756bbef62b7eb69383a6672197353f9adf731c2be78148cd7341300414a2b2ffe6d7fbd0c855fe6e49b8d249503f150cd9ca34f77a77d1dbfbc08b0631be9c6bfd58fc71b8009f965f43a884b5f1a2d881e8318c36a11cbacd183c8778f79d7dc7d0f9f13db3daf2a1cc32dd44788d639be1b97cedfaf66232e7816de0d8f7e7cbb47dd687a90361df28803b0616770388e57cd0bbd7ae9dae2686a59fb0a61a902f35c5a2e9a12506fc94cb4352a2af4e3a1a233d3077324a2f35e32d604fa18edc92828fa6793b10f0c1680ec3a9a39c8c3e36aed5cc73c07ee4841ffb3b36f694fdb53040c913f64b8408095662854eb2d678f6c1a9d0b2426719802a69f83705d6d5f2665e8a69a331255170ca4911497d5f8530e8e7db43179ae91f0a599511482dbbda8ece0aa8780b41f2fa1fe9917539fd6bd5a81535cc4b8e94527dc9368a461b95ffba0f3e59024c9c83708bedbf2984a0291734476fb41004d73b8992b8d016b6454a036ad8f09d3f5dbf85d641e8b95a0ecc99d40aa171b44a2349d080db1de01630a2ff9564e953630107e4e397b14a12ed3d0d5ce24e4d676e2666ee308ef2602a45ecec62e98261d402ba499b9cc3071cc567530174417a795629f653c58781b798994c9971509d47eea23c8c6f56ea3aa8827a7586bd1b1577e9a98044316687def6b711df323f0862f59165e8ccaccb7a70391c688f72b6ff248d2a434371865df7531ed13ff28cec77cd3f4cb77f237f74031dbd2b0a504da39448116efe6c0476df1e54e66e7409009d795ac7f0203cf64d69a10e60ba58d79efbb0bc5f9b167d615850fa33e7ae615b460a0d77b6aa141f202bf406dd73d8bd5716acd67b613b563c1e97b75f37ba0d8d9f3b66b34a42ed9d80911d245dedf55267a7e7660e5b82a9551cf62e09fd29464e5fa2d135b1d04ef56c89ce2768e81b83f110795325902830267596bed970f1838e45f5fccb606c630147d53689c31b0e8b4f5b13a1fa81b8c2e5c4bc49361017fc566cedaec3b99ebdd139bf2f3e9bbc7cb1f22cfabc6dcd5e4b168992611db07215df8ac7027d623c272d95891817ca76a2f785807ba38f2c3dffba3137a275a18eca6ddfb17d439b8319befae9e986ae1de82b456f2579c02ecf84be5d0e94991abee11c64666f3cd2fbbdf6d88ebada18ccecd77d08e46c3eecdd9aaa0be0c4380a3f7b8c66f169b3488c8c302e52987d79d758250022659bdc9d516fc5d2d589cbcebda84165e226321a6e2a7d66a15f1ebcd93636083cd1232a622a8bbcc8ddfdc729070ffba21248aa9d15bb7b0d160da481350b56c87213b73fa841907a3433f760be0c051f8afafef0f7f932a55f402a639c5766611d16ea118c9a4fcd5775b4c1b7c5305bd77abf7e8a0164bd22278de3836277f1263f7df13112b806e84123f05f61a4fedbbb4692196683c1f7a0cfae9369838a5694038553b99787108e278a269178b024d93859fa20b14fbe707260a39ae3a743300f96f22afb716cceabdec2aff99e49db60b4abf8753cec934bb933aa43307004411722b404268fca6f3a57cbd9f9b3a8f6961b1ae63a9d5db88d257f28cee5322600b101971f2c9b83d022c9c3665a66899bd99f09dbb5612c610ccb3c7eab99d8c797ae50b41144a436d5da7e4fc1057035d101bd0cd1d1a83f9e1cbbe520581b9239368efe54e3958070376e79f000ee78c4d27bf6dc302b7010133772e625368d8f77d570aa87497c944cc931c4e09a14984fd05cac91bc1b8fdcfb5c74c06c99b1284f76cec50ff4d1d40de520e4a530cc56d3e9ab15d99b8fe6cc71a92e09e5ed7e09ecc3f95a4fd7ac02b320edf0027dcd729caab0948994f7d3ca9a50e5998c60047f2ff16ea5cb9a2225023bfb1c734f90dffac7410cabaa49322c0d1410fddc59cde0ca133b108bfbaff73931b82d8499104093a2e9d7998b92b266fc75a8a887eaa416e9f4be8ccecbf8f4412e5f864a0bc2ca1e0723f9fdaf245b6c2c4a6b2977f0377710b55c4fff6090718eb4edc5caf2159b83280fe5ebf7021f0cd67e226e68af95b66a25de1fea865b9e5da5af421ad5ea896b41a9c043eac70aca8aae07c3c67b8ce7165fb0382437e3f387a12022d3a20df403fd90cc7d67daaeb49902845b9998a79e4ebeac6c31133c57e8ac971efe4ffed653989a251e8ebdbc9a725fa04f73e0e548cbdaea2133bae0a28dff30ce9b25fbad599fe8a13859b469dbd0e95f26cf498a71c5d02e974c1545830d7db367214f941856d227a7534a3470baa220adce2c88e4caa809d7d8293951465aea018256a7703ef5685a41ce4061859341289b3d2b4c1cdb2287311eb8cf86222e3fca4b1505714eb1c27b9e9f492e083a8aff25e0a62c8ba6e79d6cb59e37d99e7dcf5ddeb47e8dee49d43094bc43b9e2ab933f11fcbaab93c01ac8fcacc756126fbf5cccf19445a088de28d8d30f2df88fbdabb5870e25022a538a33aa050a04952569f4980672ff81a16b105298912da012da96a776b6f6ae81fe6e6d2edb6873eb40d0292c5c2d77f2d1847da35e4872f49d8d9aacd71ff40ee174b9f434a227155e6e036f21f3d0c72d8b5d398ab03bd2512b5302fb67c515c17455a84fed00686482b24fde2206389e05b748dac95e44129e70287102bfbe9325ac5f321bfdd32caf5e9a32d5878960ac023981a0766c0f43fc249c784866a2942a1bd98514d573ee3b61bfb4ff1d45b08f6076076d5b584e18fa1f5ac154a46b993b1e51d57b1ae5d983dbfb2f87ee3ad8643488e30c4fb567045ed949f1a3f2b14271f52227db5176d0b5373accdb8010e3d35283fa93d0a140cf09a72b220c3b6cf9de59c44681d3a2e88f1d93688d66f90e0cf79ae27954911ade9b83ac66c32f30a02841c277fbe685ff2c83d9068bcf5beeae71083005e6430b8f54bf9436135afa92c22e6b0a2194088c08a9e37d140e8f48b930356d45a0d10fbe4ac24c9f2374e233eaa25fad8b22aea9072709cc9a23e02aef039ff6da2a688f397b74dd4a5af1927ecbce4101c49943fddf9ed97717d96b52f43c1baae64bb599a5c38c5db68102edd243692da362026aba1347562aab79a0baee569ccad5c1247bb8a47b31d38e97e349318216509d4dd9ff921486ca658326a46551f6ed89713d336488d7bb5003fe68419f56d6196f28ac1b7c42d43b45f7ea2deb6c628c961938458a84134b6206fa72d491408f77434e48ad382a915505824a787c34bae132faf80365cd3b83300701ba18434080c0ff6a768148b87de0581c789e7ea62213aaa37a7073d675a3123a3a2b23f0cde614915e7feabb340b691910765dd8309534c86e628309266c15cea8184b75e4cd22267c297c76436eac4aa556d02c146ba233129dc86942e4890ac58542e180133d0b9f7db917cb176e5620f043e37fda81d5f4dd1fed5232707ba6806ada9c5d53e2075eaf13ff6b462e5b85d42cdb734890a73c994190e82c337402b0d60a4b6616603ac9d2153acab93bde85ac6d5df913f334a3978cafd429332c37118481af3184d5f17c8b812639bae5ace69ed885408bd9c577fae10870891287b5535b3986d7a396375b7b03320c3336bd69ddc1202e9572f7630fcfd5c20a443fb212b84381d43cb8dfbe0ebb9032d3125b7c34b3374bd11945472e83e6bac969147a380c241a60674690ddbc0b8d3edf270e2b586d62e4fed3c13338ab4123a19e329b86c527fb33b39038dce0e012fcc952b5c35193a34e06d97cb5ea16a8ce34732b551c00a5ce4b5fa09076b7a8154a30d31c536ee3003969ea8cfe2f35805f30543518d234f14b6ae9a821e48c6fa8ad54f4cfec3babcb074a3904dc4b23f0c3f653112993061fef5df2b1d00ea4df2cc845e226701c919309bc158e65efb6e9c6125af679431b3f8dd941c9ffcdf1eb175fb49d37bac8abf9c871f9400446524df91b73615f050387776e34434936ca832bcbb2d5cda044151ed2cbde4034332b7d634e7c577b706d9aae5903658f0da1d0227f9889632250b3aaa0535699b9fe931aef58e240310e5cd4b755d1d90ba000f00d5d054bc47d5d8254e2a15d119b27f97dafa7f2211983a5cd5e2d1a25abc205ebe22112b945a281f974b5b266580c465de9f4a1fbc95bfb7f2d179ddf8b5b0ac7290de8117364fed07b219e6bb7fa36a128d44b3e55a00b2e66e83fbf9fa6dd836cd43e33e816de820560666c9105411a26e7d1ec4f9a84c4d10d113fe297345fd55f895f018cc0b929777bd3ad7ee7aa2160e73322b91301c85d4980dcce4f285f6733b48eb1bbb6125b32a344108e5f571c277949fdf177fa376a0b0390c8749f0a717f5f4813afa6cab9c4f5ae879198fcdc0d66e89abc762403a7029100c4e8ac37d47537234647a912f553c6a5f20759ab8f6c2dc4b415d1d7e90e2746dedc404819ae60007bde0067f5e4ea235db52f7caeeee16fffe26d8d5c839a7c2296d714550ed76012067e917054f056269b5169c21302054d3df87b79a6b7e2052da332f95f14ac2f7d97d2b7bb671ae1818a8142d9e8b85c9b9ed659feb5a30a69b26717cc72791fbfae1c61a75e5d73f0e6c11ee4c411e35864ece8ad841d86fa47d336a518e1c2d05a9796eb594b429c0dd094c0dbf5b3b1d2bdd4a12b1252d752b90055db783774244c2eb67d4262c112413b2d830f8c41a69149907edc1d39f26cf9b4d12f6593bddb631af1886c041b13de55edd5455089c1d3f07048fd698ef930c04e17317ab769072c7fad0d5e3db061fe7339b63bb7adb5b8a725b8779b833fa8900aac04b14ce680fd81c0b33377e0a3e9b42d57f7e86eed83487b1bd78656eeac7baf9c998d3da73ee21d919a16a48dec50d136aa026bcfb662517312ef413600fee8743688785e3bfc9ec6053d1bc0443811383f7f645bc402b18728d9279950ed9ebee496d9c7e0cece4733cac3414381e09aaa26e3ecade05670c477891f19fbd1c1767d21d35117b2e9c4e262748f14475e4cc5442feb6341e800181d3fdd0eae4e500868790143b31e85ccc9a2efa02e49ef7e22adc47f8d0e35cd1638133d26fcefb0d0ae3309c06814993a90bdc2ce4686179897277565ae9879ba25ca6e9363c54925177758235d43ca5bc83bdd9011998221a2caf0329444e39a4bf45ec15ee95e916e983f079503dae9132ca1664be117f588e1fc2ff45ee17f9abacf5880aba2224371eb17bf54f39184690824799f63f053ea5110ff9a486d1218b3a7015035967733f7d23ad592984c8c90f5cddde76e221d8154d927a0581181896dc2a77335508ff47953f635a641c56f0e74be6a517b4b98168c5139223d66d4af85ef07c53d24ea3810e05bda77ab9caf8b279223c700024de00289bdc5546f73c7577af070a28da832f8d1f54c3d3cc88282a7dca7289ce936ff2d8387e517590e6f7b0b67fcffeb279fbce95ee71e32a6835932f488ef5b73dcf20d824efe77381e224374a329b491faff8c5a2e2305fa587cc1589b8a6f89a5e754ac156da6dae49d95f51759099e254a394e282f2acba64fd6ec87573a2c74f43db475316497138530a37b0a20b6229db21f48fbc1c325c6100ccad4601ba28687d5cf23d031f1d8c3eb5dae669050afcb486d0a4bab2cefe44d634dfe78b51519c1f23d377dfa5a524298857fbbbe665ac032e80dbb01ad3194fb18745f0f09692ba4e2905f30cbe4a589d07867f706d416fa332fee13cbaa36d112752eb6e773e79d32aa854b9ffbc9463850b2aa968f27fd9b0627e9acc992806d8bcdc9768f1b8d2593164b12800d8d5565f5f0999f2433949153c1984539b92ed7ac7318e832fd15eb1bf77dce89cbf01820c5aff63d6114117c87741fd806fc7bfe29cd10c0f5b5bdebe124ebe50d391cb9c9764d9f2e24d0521c9dff62da788eb32b7bc895a263fbf5787efd6b40224f877b07074f2eb2cbd9d6b37cbaaee4d193024cf8a2111b5607c2d75c74c8a2e22aa6a8fe83c8696ffc59958b5cbedd4e40ae192e1cae6f590ef2ba578718e9d853381ddf576f9fc60a0eb6e894e49983e2f6c9eb7b2f3980f5863c0ce917a567799692286a457c9e6479d34af96863a4d31aa167901d9ade371c97a4907438134540f715375b7ca15ef0bebcfa7afc68775977871526dc6fdf48993d193fa5dbc80e52a2317b8b9da1a9dc7d94f2db109c4e0f821cd878e2b9c62efc2bc0edbab84fd71a705aeb694f528f05ebe56252ffb297673e7ffe68dacbc78e5f66cbdae09a627f0348e9bfabe33600724d56fc4bdea09dce64381c2320687bc201e03d7aedebc77bf0beb290014128e94ed1294da0b9ff1f9ffd6efc0a2ced6712e510ccd80f19aec9884bf6650c6f973c45aa08ba6047fb6783a02d5fe80847385acebdecaed9a061f4deca27875678d0b95185ac49ec6977d4940fccd682ea4b0b76057c7017c20d9dac0305fc2105378f9586c564b26f95039df5f27105dd3d014ac875ccdd79d4192391e1b38b5afb3100ef4ace5a2fa86dff469eb63342db2f51c40a05a3e198d9659e6914b077483737a61dfaf6266009b18ceff25cdfeef747de30e6fd167b2033ee9fb2fe559eee2aae1f99e0435346dd39f2009463a749485fa64a73be0de0f2062ca6352e6c30d95844a7f8d5f2d77b0ef4372f5d0ea9b6cc8b3f36d823163128fb923ee75d3c1fa7187fef948bc9f0cb0b9aa7b224504d0c4e3ffd6055c325ce5b14a8fa2345ff785e4c20ce997b20a02a2ab276a729a8d83948b39ec02bd4d55e9de3d6c8da38b740cfbc3455f96b9ccae43aa24a6bda05be2442a34669457f73de86378ee14be4958fcd9ba638ae72e85af7b7bdc6bde9f7d041f2e1d76ddeaec10862f95ee3960fc03529df144082835c4f95397578008f13484ede5219ea256793f9f63cea4ee96420994a00d0e843edf301d9d38d15b8dcd518d5490a8c2cfa9338ed5638c2ca81a69633dbf6a1dfa4f7fa70941f6c7c21b979e291532e7346848ce83a1a66603df7a73fae6608949f3577821f47390ebb44a35e0df440d56dfd93e2f9f2befc2d85ce250200aa170cb10a5fd6a02b494776d278fec172086169b258451c9a8a8415d21342ed80b460a3d2080cadd2fc1fb4d44517305d64ada7fed00fb98b456a5fc72d934d475f18a0de1d332ac928243b0b484c99bb6d6864c8943b0cfb0d0098521c583b454d11ccc9a362b9269d1be2b6275f663a52e825fab4ca4e186267d6338445f6a4b61d62ac8a1e9f5b15a5885d6fac76c23742031ac1cac3356ad4852825b05efe84a72dc27f508a2e4d663c1509bec823f2e94f5ee16975cb1c544841bd4e3deea1e33576eefebb72566af66f9e0f27ce8aaa8f7d87790eb0a47771acd7ef5f2618a592bce41f7c1d78133b0067e7041aa3ec860b4f81c4aed1987d3c09791514736eeceb396f23215ac4e1c675cd30926add1f39fbdc19ec6d60fa9f94d18cefd4e577313c251d47a1e24bab850e9e0c4a46c94b6ad10018c286aa46205e5beaa88ba3c6dfcc7c19bf2747d7611567eeb048ecd4ce2034708617756f7fb68d6b35759c5ea663f0069239978e810de39cc5e5a51105d8f3e54a3db5ce07641e2a4c74df74bad17f6d276b6c825621b163645604a7c114367f6e0b765b0bfd6270b4645a4d8c9f16c7de0b3e434ab9437b7d98012e85767598804738f45150f0fdc33caae3ea7d9935965fa39d0ddf09e4b244b7c781b7b67dfa8c9b7e7038cd7f398a83bdb72ae3ab432da8719c3c80f47746ee00c039ee220f3df05d5421d1230586213ecc79f5b38da29c41be9ad67618edd108e53f330facf3f02855988ab253e59f95efc974d53df338914ca59904bba789906eeb34fcc119ffc7b19f31743c77e5fd1721e3d70f5c26cf85111d8e4669551c1529d83b50b397b7f28966bd7e45f2477d244cddbe05acf06c277ad37d77279b111064d2dc0c812b3bf80c42017affbccece0baf9fe7d9a506a259b4b4c449dc1592547737c9ccffda29b403a2033ceadba74d9753e0e8f3cfc692b41a2d0fe8b7af19ec7505802be96140bd86d64e6f76e4d4ccf8706aae9e62b09985bf170ac73f1eab06de8d97cf0332f9479af020b58e885ec676b9ccfe95e35b21bb5ce28841c4f5ee8d01cc18f48ab9d4a5042c6c8b823e5d51d7dbb06de6ab38f73c57511a015fe51dc20f7912b8f5d3b6d7e7251fb15e055d19457d998811e1c309850ab411373d9879d1c39f9f7a98d5e8dda310675aeba91c385efeb594873746869ea7b1b7020f132cc3b752132b4251d1fd12b5deb89cc3ae07eee375fa9e3a5813578c94996d2cc251479c70576963b40c2ef1cf279a5af753fade64d8f804d89fb9456854ed88c0c08ffbb15529a68e515013a8490fc29b23f4ef7a85967f1a7ac4043a5b7cad652340b9f9047a5eb7aba71b8c8fee7a280d89851ee031f47e41ed79d2e8d5a03bcb5bfa42df916bfa6888f5c5fcacc3a06a7d97208ebcdc8ce75152bdbadbf7c3f5e047df2a332927d1c800b45ab1c73d9891375eee23f7ce5729893766fac4a17f51137f4d959f069991d4dd465a0fbb16aef0e6624d7a496353c3145b5607ea6d40705c5b1316d9a8740c2909435f4a5e8edc42463b511ada50e6a1107752fa96950c14132b104dc54b90fdfc6ee4471b5a7d80c8cd77ff6dcc6c589a0bea58ef44e02d32e65a39bff8834df6fc4129dc067ea183a7394f7f847832f7e4d6465d27aa26bcd2bbe1eabc16fcce7ff98fa2d217928a7624ef5888613cbee0d2a3f446c98b29a02501b743f00cdb7a6c1e4c570ce4530f133c869295ec289c6b560e417db655718aa0fb8dee476473482665ef6c50bc747b49a68f245cf24755921c64e9438c8983c0f4b63bc09f65d88af2e5664f563ed12eb5101ac13d86dc6117985ea13a0650a44c290ed6e1ff61fa4dac69771c136349dee6e30846435c6b4380734db9b0b48e9131b03d10223a194a673fbbf52802036d6ebe50c5c33e73e9bcf0d580b5f923a49ce2c19b026fed09f9e57da980830766d0202e9fbe145b5bca9f9118798a9a16823c9019eb62abbbefea494ec129e980f3584b860b4dfff7ef6b064cd492b689318ba6c49840d553b85f681b555dada09a1433d857a395472111bbeb362811c5b098abaadfe9b91cbd24aa5579064f01241c81d82b88e9657b05d9d4ab6955fe6c5e95a253300dac2ca5764c88a1c567e114e18bcaa60f84e4796be92ebb44796362af70b814fd90fa65e2bfc402a0d12d3021ad4529826621fa4768a703f97561a20ba36ffa9fb221cef314647c34282c0385a074786cdb8eb9e8f110b4937a119167e08e4ebd99149e838a820b4d1fe6688ef1fb38003bd97498fff3229fafc1002efa5c6c0a9a25e755eee7998b66f58f33124b6d54f3ef6c6ba1b65feac7f6433364dbd6b6258c6ef8e9dadeb72aa44aafd98ddab6a7b8ed1f0d37fb648d2d8f68f2128bb420055fd5d882dcc3defd2e8a690afb42bdd0f6d7687d43bfd1c6c201258ed878ff7b2ae1ec3c77d5f0b2c186e34c564e7879e78c0ec25bba5850671f1451f01c01c0f6e4adbd0ce50c1d9c66f3318349aa2edba930ab20a38454575acb8b1ffe014861814e60174e403c89b461a35e20f503281abf52701d8cbf63006b536e28ed3ac38768cc8d6b89e7567f5135da1b1d0490aafa83f1ed6d320fef946b1ff1f7b312f90548fe2372d7e482f067ee1bcd58f643afabc38b93dc0da31bf01adbaa42c70c2695a9d36be96d6e95c83f76c4f64e0a1b03bdfe381ed0fe27a5d810e5be083aa30788264bbb338fc2267062b692c9d916f8dbeef7faf0ba4b04886494d25e077deb250973548bb9b544749306085de9c2bcc0ddb5ad640e3d6c148118a37dd90f52be5b86ed5659a3de910fb0e8736f6965fd8ae570c661867f57160f41719b25f7b86e69fa3abc94515d84bc8abb3f10a52df0f897cd9791db7cacdbe373cf74d521940aa72fcf1a15f12bb6b281a457a7afb154a95520f8873696b94016de3c6fe070c3996fa363a9440f3ab0f67821f365dfbe34ff3ce35bcd63c6439c1c6409eaec70c9dd6e06a61bd8ba3ace0b1c4688d05274840368edd625ca9542ee3a2abcdf5ffe58142a0f94388990b3a8854cb9374c34e70157ffce439f23338f767e7667d16b0edc5006b2d8cb3480b2a30bd8f92f1224938e7d257b4d588bfde7899b0eef27a3008ba71f12825855487db5120c14d0e3be7d18213a57ae218bb8b41d76c9dbfc4182961cba57584503edf883c62033ad3adec1f1252e83b4755033e5999ef5c404e482fba67b3abb8a1bd383954237c761cd6c616055825567c92ad49835e51b6dbd100379eac797e590fa41add988e8156d91baad7da28023b74774e8a8406472b0382ab6c8760aaa95ce5574f15a10442640beb08f7400cb2dfb88c2eb255bf91697b79d5aa3634251a902dacb2df6748b323d921f48762eafef30a2abfbe4777a6365052d6d48c0903e13b659f262fac805ab0bfe7769a3979a27973b78b560209fa60e3f018e0fd82febd241ab9ad16497a997989fd38d9939daf7265f51e3cc0c99fd0594c75ef83247948b6349f3bd9e261ad8f7cd0730361302d2aa3b35684afb2888b0cec3388df4b7d6b5c32d37b04e3df51e0bd46c8c0e56f8da77e7142e54072517524d395fedd1c956d4ce9b1b83f07e592dabfe51ca1d832344a580ff4bf6ade70b23895a16b8f1d3a4bb2dd5033436ce730917699d4fa69637a4994be880b165af4fc3db59f9fe348261fb9166e0763fb685cdee3fe07d7e7dc6bdcfd8ff0ae0a57d08ddf298a6f5d8d2b9ee2b65eec9b31d7976b5de0d142330e97cee3c305f32fa66721545f09b2ec98296ac9fae366f06ff897dcde7704967313e653b32871403232fe9d8cf1f72a35752d5534c3ef7b7497ac04d8320a105424d6e7e2376a0656ec24bc7c03f3059406c9359337e83a0d17f55ad098bc23ac417c69ec20979a8430669fd20f6f9064a56349c2b7e8c82131138d1233048015fbd6dab0019c5b047221c49adbdf17f2e44814e701c73192c2fd43f7ee4cbc76ff848a771f8b98d0a82dcf56ae5108af2aa8b8202f10b23cd884d8d46f1d85e6de7cec41a70a639b2311488ff7420457a8c43cc6be8490007b77252bec63990c8fd46edef5bb56938e0e254a961938add453b28f5d34f38b5cf8afacc39795eefc569ceb88f33031921a726b89a23e3cab5c15a4816b667da0e4cf4cabaaf32ccbbcda63c7ac689241b616dbe325da3c6b1fc4ebbd9d3052ac2cc3b2127848999d11c9a6b23321285ec9f67c0e1f73f2f12362339ad2061f99257180bec5e6caef006fc31cf0b93958eb1a80cdaad86e7ae3422b5038663650ff8394c92e18e4d8961e908cbbf50d1aa6b23c30f4ff","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
