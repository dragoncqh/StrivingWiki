<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7de61d9d59a17d62c4b9160ed43ddc27dee480a57b521e496231635e2ffc759f09d753f10036132ac0df2fddfa982ce6e5c10ffa8201358be41c4e6a35f632a14059dfa9f0bed6a5a665c7b33f7732cc6073fe44e247235e8831ce59023f1debad9770aca3bb925d922f97e2f84d9c9cba227e9c7eb0d66d7f46cd3f1906706f16d4eb5b0ca881931399cc19222b3b6c86493a23eb864c68e2123de84952bb551b5d23a0b58cd72b0946858dea9e835f42493acfa368804a17284d0377c6883ca1477e2ca754fb1097bfcd432cc26d7779b3348b50bab92e423d7d91d76f6ca6908fbde7b16fd357673c83de452b873945ce6d284953e0d3d5bb7e11bacfc2f25c5e446c952b692e1f5d7f3ecb86cd2012197007d4560c571e005c78f74c617fd665976647f1035de72fca2fb5e7c12161259dd57466beb0a5cb3c191530d6851a80870c461c609c3c6b6e1a84955bbea78dc9f52ffdc00909b354491827f2918810b6f967dfad31fa1165685493d596d32be1ecfff01c98cfd7be1c8d561c035b0909c2bcfbb940e44086ebf496ba2a6536f0706a795727ba7ecdade8840bd1c1a91b7aa05cd29e697579b843682b2d080d2441aa13f8c70bb74bfad7da665a60a814ee7c8b38c1f0104f583ffd4310ed517fc7ab0ac2c34cfc0f8b6e7d992e8c2d459393800af8360d65d9336d1bc6f7c489b7927d9edecd0f2b916f00043f4a9a72e3cf9669cdd697acf3d249470eb50b49fcc38acb9e1ba32ee0b6d50a27ce81e29f3d49ee17078a3ab06fd773f25e1ae87446522d156d84dad5cb883890d9461579a966fd03a77e37087b8204d75bc98f16716df70e05f2df8c90a4176467668d337ad30f443e3790a6e1fd9280240743b93efabf3263bacb14645a4480e6b79f2bc4a2136dd71e25f9dd8ed43087d7e8d7704c04f0b3a722a7c815c845d2049b3a2feacc10fe04630b78a59699e563641abea47c88d2270da4b45d3aecbb1265aa93a250f6d327e2e1722fd9bd8a860ca9348d244db75256d56bf46360fff945d48ba3d00820242e5ee755c9e94f78c1107cdc1ef16a54ca924b9272151d58585f2cc6dec87d111ae794db9f602780988dafcb1dfb13c4223cfa3285cbaae0c7bc39049a2dd847ba406bdcb9e210e26ff23292696fcd884a99a39d1213a76b34d171d1fe260685399630429d9e03731ad4c460a448d5b9c180026f0d93c158cce7a5fe0a14220754bbd2d844b28b43ff8d4d4e26822ec01041285d1cfd07371b860b4bbca9b963b435800ca60d64388e98b2675a705a64ce82f7f83d7b675ac21fc1bac7a166b60984cff20ca8a88d9b7bfa73598b8c73aa837a98db4b294cc274e9753917be998ab7e4bed812a028e864656f01368b0daaefac253eb2ea75f89423b9ed57a28c530ba7848387c5ca098db6b1d2be2ffcfece17f8adb571a2ea1ca5abe5d20d1a52a5fe1c20c0e8ba56b6f406f59e0c201822994bdc2407f40993c81132916e428385039c525f26d08f8953c1e1c8635063bbd475ff5efb85d4c92ab93ede32a412a291aa8c508d36a830749ec4661b376335c723d504ef24b210347aac9b1124c2378ece660b581dfa6ecd49cf56a66c857ab08b64ccc7ae12d6a1f7436219c632b563ebbacb82e80b2b769ec31fb072480b6b3127891a8f480da64ee3018ff6731365739510421700adbbb3d4e9a7bf5f98da26a865fb204d978b435eb19c77fc08399dfd4764b4de0ac72d8d0fce7d3f92d0a968677181ee67be60f3db0143665906da74690fb48bf375e1803f21285d0c80d6bbe14493651e04122fd8e21c9f0f5c59c10a4cb998cf238415317b2020bbf256ae66e5f966cf5f71b5d10c09978764f009397c5476dab12771e0643f5869d23ea7614ce5f70b93a5ddc2e900544982f22b59eeff4c2d60e6331644cf1063f4924cfb6f5b70d632794fd933b4f2b89c1c22a835974f4ee2cba9bff540c39a7e46815b4507afcda78846c33f8fe5c51ff691067b0bccbc477bac92eb8d6fb3adbe9f1922513d7112b37b4967027621546e0d6e320d145e30588a02be49025706d2581f8643ff4da922e855c7e72efcbcebe866f6eb92415d38a83d13c6bb6aef8b9d52139ae824a77f75adef17ec9a4c29b188383f7b2b637d5bac96ba20ae23bf3e1feb7cf540e7502c0109c77b1938a4f31a4907070fe76783cecd8ee9855580f69f42a5980dfa52af8e969e6167ef78d61780cb09864fedb9bf6b9552b6ce5630b13b23b066a14564a2e140f75e64eee50dafd59d898dac5ac258e442c34b9b96f6a4f9c569bd1b8d286d17bb787b1edfdd2b8f5e00345168727dc24113a037823821c9a72cd77a9085280276ea41dc9905f1c3dad5da48785f64062bbf8ded83890034f0a367527d0ed954bb4ab3dc95cd8b694824f91de172a18d1113260df3799cfd582d6a8fb00dcb176bd83c39682384b5c0efe7e2abf4938d232e3568553add8c3470f16324fc5e6683eba41c7902aa1a739666fe6ebc2bb0b54eb493cca35a7c3fa1fc9352099743ee14079dcd18228ee5e954d8c0f6331222dd63560d9d3842192e38f48b14db8d9d26eedb580a319f382149466f050702036634b87aaeb058029443f4a28693f40dfee7c32b676dc8e9db4695db727b04d3840957943e9aebb97713ed347452827cef24e82738b33769bcf8bd764e8af0645c3688b05891fe01b8b6a848dd9f6f8433c9fd8b63c9e18a3f7e2fa244b607312801ba14c68039cb30e88168d236432807a776c9722ca7fd10618352bacc10ec9837b68f66833af45f41ed5fda2a9cd233ecd6111328d7facb39ca72884154e7bc3d6262364578e34fce667997a79ad2041a991db7d4ccaf73fe992a81164e91862a978c871edfc6b80f426f044a137baffd13befd5f13c05f2ec0ba69a1c7f17551bce6c9aa7bc5d739b1f980daf9720c39fe415d7c81d9ad46853b206e21a34ee2be39fa1d92b9af24a5177ddcdf1a8b137f41cc20cc0ea71bdd20de1a7cce1d5d498b38472b32b2dcdc96ca10d5348e0f5079a3fee23fa081ae22df66db93c942ad25fbfdc4026dd651894db759b7e598894ad370a701ad5e2951b1432fe2d2336882d6f67d2813b6b3bac84aab6ab7853a32e9eb42e7b5f1d7b62efcfe764c2fbd78178037e5dd37dc38bb3c8735df508cdc501e1a09fcc01ba07e4bbbb7ad61cc42010b680dbcf3561b88b17906e2665f9728372f976e55bc9217ae09b6b11f508cded48f40f0397133dd6107f02177f8228b42258abba2fa6f54d024d292dbcac43accb1eb976f029969b5d7ee451f848a4b5306040fb8ec5847f0a8ad5af5a6a3292526a8399cebd92cd9bd1acd4cbe9df1d73c8a03ad4f8ecdf33ffd6a46ceff6f254b45ec634fcc79fbdab7e17ee736b5bfdec5c33539249ade300cacfa32d4e62cab5d9443c0f01f7b4d05514a37cbc94c9cd165d5db669242800407ae9b8728eabb310f6c42f8545c33ad453206bb128a7692ec7cd92e2428849d54a6a4ae9fa355eaf9394c53992cc7f6ae1ad4893c53fcfb639ab8400602de78307a71fdd4fd6c1912ec7bdd5ff0629cbc561b516f7d25402b130a6a72cb561dd350194ae62ac3a2c46903ee2cc17f5a6bc9394216375801f2667075a054f60c84192066f5b0edffff03adb0d4bbf37979d46ae2eebcf3e997bab49ba71827227a89cd521e3329ed49dde3d42cb3366cce7f317f9b2f470b7c07a00281197bcef70deafb7e3f6296b264ca9d199339e7767deb7a7ee625b4c0863575248b4fc06dc500d1d372b952ee9e7ad81da83a0fbd6ae90ba8e775dcbc25e5bebc6bde89c1a563d735620cbb4ece28944b8a7e408c54722129f48d3ed34c1e2df0acf5cd501751ccf52266393f1f0ecedec8f4fdd5a5ab362d2d79f6c6bfc1a5f526568bd073a074b1d5beaecb0576bb8f8641855f69f46daab5749827cbdc8dd8e1a0a6e98b3df4a5ab1ccb4abfe9d10c3b4fbefc091b13fe8296b5ca3457a15b021bc88ef6524e265f6d70f62be9c0807d3512c60c8a0b8a91ddffa88fe18aa68c69ace900a62b2e34db90c63669bc284b7dfa7e71d9d482bd1bf54c3e4ed38ad1aa3201d4b080b59906fcf9a188a35ba321f6931409b75dc6fd3dcf996db17ea8c5b92b884be8b62f20cade918b51c80fe735cfd584ac97c934779e0cee02b1dd0db8aeaa79e9a2475cbd53a1c7e4b7615abe63ae400764f60429a947bf71241eebe385a23da21875bf31aff56843f478463e74923f969878c8c2bcf092e7d13963e64f881933b92d667b9e18f57f88013d08c6953be6ca603cb33f7c11a039ce559e9395e86a456c14306d11f501552e948f816efa2ca4b2f5cd4087629cd5fb8e045a89246d7898bb0bfceb182bc03f14eceda69ae674357622bff5e1cbfa89f9cd3c4040efbef15a2362e7d9ef6268db278260bad92f6f21b4b80984fb6ae326a6e1626fc2cf556b6c322fedffe0e30ecb547eaea4fe65e34072940da3064ebe2dc2fe01ca991c5ef52348442ea37f72b84b1bacb320870666710519e35f7e42b38cd3531d71f891ed4bf5e7ef957138d61f79d58a356f3a89ed40d759344a95800bd26af74b17feaa118d08d9a35e48dc763a90d3b8d137bc31f1da23415f74618c5f6b27029aa532a7b0627a53770e064ebbbe985d072bc9d005e93a37b80bd3d3d209fb007c7b0f4c50ad69e2c77e87d6ee922119fc24cd8607b5f6a4e58dcd9da73bb29e74e745b7b216caebe6614886df513495db19f51c751903aa59c69dbe77cfe2f7134b90e1995d877d7c68def5edb73a57a714d692e5fd49fbca1513a6d711aa2dfc6732c9cb3b2f54c7660a31c0d54d713ea980b3b73865862c153ec1e8c65e822c984d79be5ea5a5ac3ae6076fe20d384c3a42375f05027281467a6aa7551cac1fe5818b8ba4cba57e8028e5c00ab03b0099e09ec6849f166911cd6db9b770cea1953abf95894e81300412a55569c367928a7337e4f6f361ba422d91796db245acec9b035b98ee0750a795a04b8bf7aebab33e9c68d6b026e89a1970b6d01f51bae37d3b4caf7dccb10dae08c5645244f3fbf5e5753d151eda602fac7313ee9997dc8c6343f13834407f2447da79ed1a5adf611b09742503a8dc402e01075b51fc862184e3baad2ba8ff7c559c6c3f867b480bf0af5043d5aeffeee8cda030b3ffd8fa612c299afc9c52c20c5171342db0bd198996481ea6fb0ad8da97920a84815a9583c43a32d53ac7487a8db51f6a1703bc846a680316019cabe6784480b916a90e55c47dcef257bb5508f46203e200df5ff4ef144c13b432e71d82abee85212f51ae2ab0b4edc7c0a09893e032f9eea2c652485376f7c1a0ae0f408c42445b5f14820c55db6e09246614a06ae1edce9918c85a191d8fa00bd059365ece65a523a7627811590dcebffb9b15fed400fdac63c2238b503bf86f3a638774dac11a6ae3f0d9023921afc10af873f624b389f97bae9650c2491dfd1a101ca386b6f7ea487bfdcea2ff3df04fdb224dedd44a3c269d3effd09fc748195058067782de8db52ff79f3fe7f0e21f5e9d6710713bff64d0794c16687f15ea3df08d756bc98e50e752ca09611bc440d6b1b29e45c0d6b0c323295822a8518a6815ea12babce99bb78b9abdac0d4024917a7209280b6e812ffe493baddcf16386f39246cb653df71620a6321e646c44a7a5b930d3efe03bde2f7eb73a3385afc35a75853a238b68f4d452f7d9aae89e9b8ad3a155d4c2f4ea1594f9d9f181686ab8627bdbfabf0c7a0b219c30ea6b9ecae6f49883d99886cdafad61c282af74e89ac0bea0a61ff90bc3e49fe1cf3046703b35224cf12452ed57c4ddccd4a457a00f69c6feb0d8608f1eee769ceb0af581dd804ddc0a7f1a97f7bf792126fe1b3626124e0da2a4d4ffc8bd93c214ba540ddf87a4c8db3356fee1b2b411150bb1e7bca9bc25be6e8ead73c49a69bc7830348362bd3a5b1c9ffe5e62c02a50c73d6661ae824d3f544954c18ca2177313706fb8b8e7d1b8914836d31261ef107143c93cb924cca964badfc96450d70bb3cb47c3a3ca84c5dc06f19df26ecd0650c25cf0b51853fe303bf63a68b3223346fafa72d200bae1f38b281ae97265183979aa886811a3a648eea90f9ddca2812f843eb8f4c427ac6dee7f7376bd77bcdf81c981e862e598737fb65653ed8b3dae7496dbed538ed25f643b011d2a6d4a904053f84347d916f4d5256ffaa7088c65e455b1b32b08a6d92522d012af49b86cb705c07814e5236bcab1870c72d24c8c5819310a7c5945d6c5d1d0134b275929b4812e83eb15206eb37f479d684c5009f975fbe30639d83c9a2c0789a96bce83931f90c55b68c7ec65ceeb99c56e0b9bbc0d78a77639e8724357d2b2793991505ccca6375e923100e430089594f4d47c566d2d516ed42f1996e4c6530f76d937d523c40f96466eb00ed3a8fe8844fee531d2de5ae9acaee523db13ae05fbafba508fce083b3cb821f757e761444d5f69531834f8ce2d551bc40d1b25aa9cb1ef14e71676f9afe581e0133c583e66e8340385c3d9d26049a3638df2c04f778df3ebb7e550927b08d8722f7fb07d7eb4605dee807868aae3f56885041d1ab9b9dea5caedb15218bcdf0741475e48d6e09330b21436811aa1223342d8fb0fee491b4a7d52a8e5a03f4824af6fc8c4ba03bafd232d175d047297898ea0041b6f1f895b6beaf3a766ec75e2a9ef74b889673c54758e677c9f05c5c3099698c053d2a7b8ea76b129d617590f57767e60761887be3eeb8230e274b87bd973e27393f7f434d9db44312716469bc9c6f2176417d525ac8e1642c3a78d45b769e2c17cbd755f6c6cfc04e96251c753adca2df9a8a6ec7316be4573c00ac00a16610bd253d5d8cc61ff068f874bc8477cb2786924f0678d6818a501aa11b7b652629a45381a56b2f17d8d90a20ef28d455b887c109e3658899864323a4c2f480a567c0fca52e266521df55318d888e9c6432584d764af4830994817302eb4262c51f69a26cd19a60e6eae58683f942d087f66083602a455fc2295250069dfc4c8a5ac658776238d5fa09f484b9ce2a4ee9dd1ae67d8d4e66d9934ca888ba45507be18275dbd09b55b19776c259c5900975e4aa97ca9609bedc8f0fdfdd79b86efd4be88cff9d75249a7a645bcfb8cc204f87a90c12ec2dd5e784e518062f31fb2312b6980ac8c1348e81bf7377100741539a4b9293ab5776bc5a93bd31aee6ecefc5b9ffc33481f0b748f6fcb37f92f5c494b7aa1547bb6dcb06ed52214d7632d6cd480073baf31e558f9675a6c11c16138c62bc9f0708658f48d0e12e7cec168a5d3dd2d0a7c56b5ee3b40ef19d08fc2aec720cbc7c6d5758e2f827a73bd664e8b13738f51ea1027d80b8dce046f74616cf168e53abc9b94dfd08f28111362f38b43fce95b4ebab528d56d0217f8e4011c3ef897bc31ed7ee408ff1c9d8ab2ae5cdfff52078ec75cb368c80aa6c990ace18054466fdaa91eeb07b62cbf8151918ac8ce7d398bbad58194d293afed867db43d5907ef3bf3b3498d4cb94051dee074eb677b4b17ed8a86d9b96b6b462e9277c7c52970a83870c9293cbba4745a51e3445dd46f4e55595a3748fbd623524e38bd44eaa0880dfd1f2cc43b5262752608c836d4a946d0165ac500a9bac5412df5fa8c597bb7b631652ff73d3da0a0a9a2684171b865714f5f6c34139bbdfdc7cc43987ad09a70f8c559e1ac029cd0d81c5d53d8e205703b37b9cee6eaf3348187d80c1fe41a018e9fe1c6eab502e3a34dda9ff5cc138da523c8c1848e983ec46dea3ac4a93e36f6fd077cc0ef231eed9e2579d64adf57acb3176d5f01d310fb48699125ba097c94a3ecaab81a1d3708ded1a74006380842a96c8674f3b829f5bbb536c7144cf999c93f026663389c9d23e87ac8a1a65cba0178d7c0b91ec8466c52f9e2de34a66b38bef5bbc54353bb37540dfd6ac2bd15983e51a2aba28e3a02d2b998d198c9ed437ebfaf0eb4a4538bb82da1fa6b63923ed6b89b0373d2e4b0a8340fc3744ffbf50b5b8dc74db2bcd9f99893d999eb10634384d2bb4e9cf69817a828f304ae46fa009fd3fcb24522b27a500f28aa1981722274c3731b99af109a5591336d8f4f741f687f5bb052941524c0e93ab28fdd3ad2c68aa1b7efd681cc456e194f9e3e2d85dc25c9dd6fcbe0231fd4494692ff4cb1495312e0e4e178dac3bbecf59f7b8d3d3756789c715b5ef63d08913cc98ebad30721d2b6ef3b1195779df1420a7f522d12378ae5cc1abf07b2b6779a36ee01a8eac266019f0b4f0d22c973aa4b446d66239645d98c2145452c7be7ef90c3a8723bdf8247ac7fe71f74b8940a9782bd7780fb9bddd12de11bb6a984198c213f03eeb44cb63580465206d2468067c1646ef16e155623e730cfc7b54ceea000320da2f670cbbc853ab0dcb14b009bbd44193085eb774f30248cb18304681b1f7478c509fac8fcddb0d6fdc24a6832ccfa30c36145c3dcd793cb5105f738474e706ff95e520d9826d921cd1aaa71928a26ac73bcadbb1c5434ac77099395576b7871047ad5640772be78792fa2d3d1a476e58787da9b9338541a99ac4b82f08e68291ca42fe257681dff39d5ca0b7d3458bef998a63782d804c81ee437f0dfc9e367969bd9c6600df39355787aa42657c07aafdb44410d0148bbc5b1212b6d88f6155199b4a17030b63e181eca6179e2b8c4e098185ead822a40154c4607ea1c2016d970ff4f5fd0640ab679da0c3e377cc802db180835277ff9fb3d5273329e6b9ddd62508714d53ded94fbde74702813ae25052d88580c521b6d8e2b2e6f2fdd67f446cc0051a01a896d5b3698a68ca3f91524d3e9a5c7222dda007fa55a3125370fa2cd4a58e1f5f0d65e412acaedb9c5f43d6d973c7644db417988211e1dd216cecd40c4fa95f399fee63236bbd5710f053a4d5a4ea9106e080340dbb60da80d24db2873cebde0e70a3d4803bf36aee8042a593e99c4811145af6aa051b069887fca353966f65596639caf9763c3064fa1ae97b04ec5353c4dff6647eb52f753aa443f6967a4504237039b1ea3b8ab7cc45c9b61d9616def04d6f6308d9693d9846bc1229a6106556808e0757f33bde3700b39eefa768d9b89b6fd2f64aab7067b349d3b82d03896a0ecd40343785f33b1726c6b0daf436de8a2bece5137d47a374564b3336c9c61b57a41d72d672d00d35855b4b0fc159e4c4c1d0ee87a1ee7497940faca4af90d98a1145a8918cf494a7c3f952ffdb6eaef726f15ff596332475b03a39bde1556d0c4c42d80b3399c5b3e52968d32301efe004dbaf3663f925af9ee8b6b16d245e92704b1d6cc9280ffb3a11d735865579cb57be3f0d67ade8746052f55a7ae979002d931c8cef98aa0e2b6168d1f4340456825174025bb33441955a2e02dabff3f34af99a08e6aa5d14366d43f9256f663092ecf7265b250033e72e6c88c4c3c4feac47c0c55947dd69c95bc801b2c5f0bc5dbe3785e620ad5c61abf6cbdd338c6701ec85f5a675d477dade772c80d3c64583cb72b50902007d6caad2edc3087d9ede680bb755157686af2d15f368675db9a0d4642ceda995f8d36486c29b73ac403fb791f399d1952ad392dd9c64bb7e5718384f61ee213a44e3e970331362fda2b01f8ba2ec344e11eac110df8cbd1889fa2884d8388f60257d09a73bcfa97557e7885a3556d4e8ea4b6ddbaa32076049a341511818d8207c1ea96976f4e779fa831c19d305bf653f0c91a5494d4223a2c23b9bc2470876ca3e1547354791ed96183ec18fcb74abd0b2e3041242d723df4823663a6af95bad46c778c207e657f5182d5e670528c9ece133b5eb502a85ad954485007800846d3e1e15932098afdfc4e3fab75686cbaed0e397cb43b0eeb3b0e86574e52143319d28175483f7611646297bdc851bf83ea6d7e88a33796a18674dccd3a1ec5f8607ec6214426b39697a306d2ac3f5bbde07a0d5ad04fa764aaca0a11a9bbc322a78f89154bcaebe3833c81bc1f6f36833619c4b71ce95a17dbe6b4f64b0ef144354c44d4ae8efc9f6e6162cd42fac54a476e59ded818074406f07e222db89a4f40a4edb47c65c77b1beda0b5b29e45fec1d15b9db25321391dae0cf262bc9e6e82d55b5db0de39e960c696fec9dcf77689255ad5c6c548cb144a94c3c9e49c28b2ac4b4337fe3f89013519b5c48e354b80661d1bf7749344721934a0f272353184d7f5437e8cb9dddc8894c61e5c34a82ef03eb60f9a1eb1d915734f08f56bbfbc4d4e89779bde829f86d6d10584872902b71f41aa482137021f32c00829b44ef525f45f273a7680649c6d27f32af04048ca11a88a1033670f5104ca824761832d9d11c7fce26dd6aa1bd364c010773d94bcb9120db5fb7c17030e02b33c30a3f902c4c2f3ee62ef79dc02673137807e7e1af29e2b18e3ba7b36d37f1a61ada9ef3029d8d8a56945502ed0024834978cf1a618aa6310567f865c67532e5ef24784f51fa1faa6912d4b7bcec2325daa0518a1cd31dbc735173ede1a8481b728c94f39d32c0fa341273d234ea856e3161be88ef8162526068c92b52bbaa5e7003977cec2a81513cfc30b8ffacae9db3c3ce46ed87c5a8c3367b1b50708b4079b06d5b2158514248cd4c0b694d33fb0c3f9d7f7a422b070f4003faafcb83e8a73388bddc14a29b8c54c08a1144271647e93597308edd82029f301b95258422180c2f00e23cf07b696e703b6155ef87f6000b473c10874ca0ea46b8639f1778bec6e05c7e9422493cca84ef12c7bd3da987d08e167eb30247a071064a37fa5ac02c9cc51f51cee24b8849734487b7daac928603e29547cddc347f2541d8486ead2ebba3272bcc9e5d44b05a0b608639b741e5bed47c4a591b7b7be33babd6972e4e831590fecce6471388c41f944298f8481eda27309d33845c513d9ac50097c9e2a69b0d423af4d8545dee691fdd64361f1ff2720e4af85b04e6b804fc9974f6c25155c68973511da5d2f6ce4cc562cbd5b0e166989e8f7e8659df5e124dfacdee5d95aa36ace0941b29dcd6703abaa88464122c6a8c31506fa71ace68cb1af6c9e96e9cb47b5cc851793fc0dd4a661833d9017fb18fddcb1b3bd0a33359f3215b0976c6648be144cd3f841d59150623fa75a2abbe82c7c3ec056981238903e2a3a7f9d80c45f69847eeb15744ac20f89e9329b5afdb1565fd0498dc9b1106e4fb22b9c19f8efb938f5dcc9370d322283687d5615878e78c49409e02ea9378f28f868f742e073e4623ab1930035a000f9064f682dbee380458c502be722e4dba5614123a925587595f4faadb682e09ce7bb08983861e4605b8126579a2b653dceeecb6af8e1f250b16e640ffca657e3c894bc83052598a6968088b8b88bab177cc2bdd188ebf221ab2754f50e3b456e56fd45cf7967f94981e4f4db8936b47eb1e383a3f28469102ef8f08166fac2d4f16eb0bc0a781079e510a3a9475db072c484","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
