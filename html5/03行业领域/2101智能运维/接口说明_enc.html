<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ddfa1a759109f4cb0858d25581c9c78565071799fd4d32c5201554c8f548c8dcf97139113dcbde8ff5d6cc46131e84647475cc442c2503d7d0c1bc9a50f1b54f58cd3def6651d31427b6cc2cb545bd4823dfe9d407fc29937eea71c9c96b6aa91b0d823f7ed5ad1a176639c3f89cfc4a1a9b495e76e219c45b47a87e448770a5c6025ff4d73ca8100b9e5474d20c288a24e0704bcf2774f86251e8f62a0663210d64e1839a7deeff13ca86eaf9fecf4f9dc1c5ec508eb259b99bb7d6f29cfd74a57cda40706c66a40b4802cc0c09bf33ca7b69ec4494cd55cce9f67a8c00c75627fe69a2237b6914010ea9a24898e1e3a8aa8faba9d5a1a279faab71790ae767d963f1a6ca24683d0d7706adda80eb8e730352b9259d1cb3cc7d454cfc6126a67eaecb98defff399b472e4417bebbab468232e1ec53e550ed4f28ae82b1457dc7f118f93999a4b28b18517b265bf7ff7974e1f1c9ff174af91d87362641a271bcbe139185ed416aecd50af7f07eaaa5fef74615c4c5f615a8cd3edbee9b9472fc2c7af128a87e5705ddacb10f18da757a021d2352aec57e7b6a73ce92c3b48bef72585909f38fd860ca8665ccdfd437e564f6748452a722622735469b776096f252d1a976bafbeaccf31b71bb579c21910f10e17489bf8c8a24936b245f7716c83c9969e24df0dcdff26149edd7abfd42e7e6917a199cce15f6622d110b9d7c5a85510c310daa1ef2b430f5d219b036db649f059d07d7c166a5cd87c569a2a04845430b2bdbcbd4ef55bf1666d58d5697afd752167d23053ca5a0a12f1cff229c819a1d837f9502b41708e6d13bb632b681f862954bf4f60d5bbb06a6cd8eb18bba8524381ad30cc9f6b0d9ebf60a74becbe72fd08345399771096afaeb8a016d52ebf67df659b94d676f4216d0f6f72dcea045e026a2a078365125633f9589da0c8496549001e63a06a5d556360d12aa85464f4efdd669b5ee1741b87fde5fe7e9598fa1a442b2d66bfc486baa9fcf284aa744f11cc3f3fbc5b2a6f0831ec8dbd677af4b0f7190c614cb41604504292e20c9307f1cc57417d3b036319c3b52435cae7fd95aa65d488117c81491ca558746258f44e699875d16c47774332c1043b82f583e6353c60ab245fcb9962ceddc5259ab21fe75554598e1ae7152f1304aa0bdbed51bfce7e74d198c7cca12b63b963207294c233779707a23762b15bd306b62d2397b16e28a3a3a6130e7191c2e5b3e154b1fe86355a64731c9c7b5d0db007b954fa4a7d88248bc866004fd341b8a2a3bb3209276e63876471b1fc943a231cf759ff72f123dbf837f64a00591d1bec4395c2e8f795c3292525b5cfd94a1ea8187d87e4cfbed0230f4000accac236c5f742210a1429dd645569d074642d5d899b7e46423aa3bb3e4d82ad912ea884895073a068819bbacdba0d68b515bc702453ea56bf5e5b218ba8ad080fce7eff7b08b63996920c4e3e7d2b5a9a188cb5bfb722d0752d643238c36d717d2d59f35f38f36fd306443ee453b4bbdc539628619ebe12c5e7726f22a385d1981342d34eaba9bc1593c33fbc6e232917e8db9dbf4096af1d1e8c96af23f600b7fa59e3bb6a9c83ec057c2ab95ab0ac48e2b0a37cdce4bf3178e2f2a6e6c21c3b8ac4dc9b32bd7096c0cf896279388adafe02b4c263958e9db00f8ba6209d8debb3397512a541c08503245ec8d196eb7c881be2902d8dd225360f963da34ca5795e78c8ed7cabb42ffc9c251ea009fbeae11d2c3cb4b9cf08e6a04f0477f5ad59c701d73a2c3310f339d8106ba4398cd67d64214ad08f166a503940b5eae33c7c1f63215a1178368add20d4ac824d8f8abb879d05da4eaf33762ec326160b0953ebc075cddf0068cf48ff1b0421c7a95ec92a35f6e9a41d0b40b4eb7afb7d5ee1eca1b6699e793963db0aee32e829ad2b32e31ee313a30dc4a1c2c3b9eb5ec8bce879fc4f9cc97dc4c6e6b92dbae45a2fdf3ec4a4a50c4a75b35718c173d49673849c5ef8fc3d1ce50a64227d4f4e190d6e15b201ec38871b1becd2a0ba32172125290a914b27cb3ecd585dc03c138e13e493ab7fe414917ece24ab537dd2585df44bb7d8a0125b924f4caddba464dec9e364ba80bf456a558d38ef2369f466805a9d835abb2b3a5122c2af26ae643652976d9b35cd47f3dff70246a3ae5abd38453e23bd89574242c94471bf034f2e78c1864713665ee685538fc6068084e179dc25b6274eecfcc78eb6c007702fa8914e51b120f083e52e670746401a97598bb234987c8f2e1683674e4390913235c89aeb51bd2b2c44c8d1585941dc59368c07bc9fcf4ffe3e7e34cc4e66d2eace4021acee421e7fe9cfabc36a00e7215b51b0319d2158a39be5b345363ed776488d6313c79dba7c700ac00a1dee8fe7fc73180a11d098bfb557da47ef60760adb7e24a1b95737054966e10d9a0852751d8630cd85d90189ff1972cae09ba4bd67d13ccb852d1bb85701bd50cc9fef8e7ee549a44e145aa355693b7b441df4ae05872300560c3e5d74a57bbc30b0d5794d871b6adc84431f51e7d294424ca7ca95f032d87a64c11d7aea0de630d22379c571063bb5c936124622eeb30f45f71771622ca652cfe32d00f36698c914bc7ef71c42f81d048fd51e261a1550081110c9d4bd5e35888f2a5e22e5431c0d2d2fd868decc5a3e341517b6c9b89fd7689a0c448d0e2c4da1ecb5f8f199d63d71b8c8d3c09032bd208d6356e1ff628e41ce904a9b37cdc720892414164e4bc1a2bc7e0b9de109cbd2bda5476294d5c39f1c2fde24c4d4347423007def7275aac8cd0e0eca5b411f5bc5cda09c73868a52d661aeda7cc9a134a62e0d8c1625b9e3857e0cc8a94687f57e87a6fc3e2f22a7db3c821eca15a9c8998054fbe7975d48f7c616e879c45c91b474e58b596b83f78462a81baf1699a76aff4e5ed36242ffc2c3ee54120a50b4d02c7e56563f78ba24d2a02968e6d1529c737af474a53094c9e66eba24ecca84dd19889da3358676418e3e60b5d3591a0205ae6d572cab4f7b06b3cab3c0de517ec9b87c177ed16c1a737bf30eba3d80a6c1b8e7476d3e276f069821fef5fcc431f9bb86c052085ba43b0030a514ae67120bea2f0beb10b6e469b33b391f0007a9dd2709486f87f6e075cbd541667609f475d560f45462f37d4a320bfcb7dea3a1229f72f6a2c51d63e05e7838d5549859d5890babb7b5451e288636710d8b99c1ad6dd9d2b54704e8c237678041e2e02514fad428ce23520c6a33ac0510ddaa70792a9bd21ec2e157f9bc9e38cfdaa637660df3b66d69ce741a8c943162ac60085a7bda114d65978962aa531270a4caaa32bf1841bdd7755c47f95c65c055dfe0d7df3366a6de20b4ec6f46b7b23ae051bd0f99bd243d8768bcd082a691d82d6706e259fbeaf033cd9cc3c273bb4e4cadb462f46dcf0d8d2f4c12296c87e530a46869f6c85bdd6d0950b97fc47cb0f4e78b0d802d507a6724653af692bafb1fa69e66e0c422b55a7e7f32b7bef0a73bf9ceffa341969f4f1d065a529f7dde9506b7760554c73477af7c57614917523d5cb5fb5e0edfde604d6721a093f02968b3bcfca8122033e6efbbc0ae421d3cbb42340ca00a05c97dce32ecf752ed8777cd53f1fcd43f6cd7a457006b3d879bf5b11f905ab89544a332275acf9342be631c8e311172e94d7c7c96621d7ebdb269c19121bc51d7193674012af957a0e0785b22abb4e4e5638b937113b687b2c26e95ba52d604f6c565fdb640b1b5961be0e869ad2402284d76f193becce5aac74061a232c23d16ed50037672d6ca8ade051d7d97d22904ae24d9f42fe14348bdea5160d331d4281515766bd8e90c44055dbfc130b1ab01495d62b1bfe7a7ff7474b22d9b30cb04b92bbd7e3211b856a488581654fdfbb98d1d8e252340370b3ea1fd9eb506d50d5dfd12c5ef5a2b7b5abe2c72813283518daff5c8a5fc1a832653e1a68411d60e47e31a9bc6e63eb66b880289360b55be4b1287a7c7c33e36aa1768f27b193bc1ba2631171333a8dace957e865d35482e7d7d98146f53b51776c59f1135b66564d9d68c0656d536d72ef39331d5e91c17295a679e2a626937257b35e5df5eefb21237b2b1521f5ea908e58a607ef9b22dbeddafa1a3e44f0e9ce1a4807648accf25154b7e42574cb01f103f7c3b02abfe1d57537d6c70554a249a12df92f68c5044af7b7a33fb03693fdde9db75d423f5107805a62b62a8e8724a1166c767aaeefaeefeaf8a5f405301ed250f21b261aed195420c8bc8f89afa510a6329f31bc155cbc9bb642164b447cd4bc5cf0079a5d595fbde9cad27fabecf3f4285cbd3a126d838587690fbeccf04f81e4cb7f1024a4aa91d4c3e5884532f9bbbcbd56c4f4eb915a6a7461d7f17b3519ab9f8b8afbe40c3e0ec17d68e53fa79fc83335d8c25aaaa04c17c3714edceff47488a025ae7ad8dda052ce9306e6412076ea81e0890a04dd9c9a7396af27aa14847c1f0f626db8bac56ae69ebf058d920eb9ef77bfb90b711eca4ee9f7ee986a3891e031825af267935d0c1d4af397a63d047585d36b025e54fe2d7add00644c282e94d5873a77f11806780f339abeae9bcfc1deab6c8cda8a7961e3f990331436a76f7bdc2d4262430c875b4303789fc47d05bfca8a609cfff212f32498aa9cc3cb0865a9b6e5da5ec4b9fe63b66b6e91d07db98fe15a59323776d52ee76be09409879a6f0ed64523b2bd2af7a1f1ba81c2fdd1921a556d79979fce3a31a499560e93839a50a1d5aa7b00b0b912d35af7324c256f4198aa206361c6b2a7cd44abeb4e2f74dd428679edf3728d9c9d849450b81876d170f0761bbc945cc760487f383e98845991feb523fa2b81b20dafd6d888a669c0a99fda9a441a2bfd5fcbf41d1241e234d49cf31336a1d80a8b7ff42f76604fff32110ee926c4c032b6c363fa74f1308ee6fad89bc0bfbddf7f2f20a28cefde859f20f3f3a326a26198335eb7175cf200bb248d35bf525b87b26e403eff9a7ba9cd05f0d4b43690bed72a96275d73835744eda5bbad75997c0a432c71cc0ba232659457b4261ab1687283e8e6dcd415d981b2f125c09c482ff48fbc1df9c052468443db8166188db24fb16d19dd9fec5aa20710e673b59fa6cfbd5aca722ca282535ab121f700fb8e950ba4514976b320244bb67ff035053ebd5a2bb9bf6ff12d3a4edba1e98b9acf93475e0b6a147d35a7c29f63f62dfceebf6bac7740daeb48131062ec7156d9c5cefa3de1deed5a3eca350c16d1b06035d1bb848fcde3e75b854e396424bfa63c41c0a0221ab234f22a284c6a14fa1e962b76e00f02b5ad913ce4d0cf90d78475ddffbc0d778c69b0721e19ccca52c5ab81030e54af63b16643ec7516164b3b5efcfc0e5d1b878dac30962a2e0afc4aafb6a0c5841a4df7d643967e1bb13ac7f7d9928185a9a19d084a12521a130500dbd44c2ed22d0e69c1e5e6de04971decda1fbff2c7c148844458d3722c7e22abddd08fc55c149dc1283f4cb25550e27260be0590dc309e426d5f88d156bf7ee0d0672ff91bd3bf4c3ceddf5f4f7094d5072b21a9e20328e0881c2af614ab89e0fefc8b78bf68a557722ef75b3ea8eb513827098071b41092083f2c4bfabb6a84f3b06f7625f939e86523b893d2d4806cdd5b6186b3dc43be445f9c61785fb7f4c8189ad64c1e09170204a75746d4e4f48dc489b89df9e1dff3a1b5ea6f1e45aa6447a229b96e845b859ee52a8204c9a1d2d920ccb7c249d496fd6b46268c4000d5de1f8d582f496375f54b100b97131687787232929570739777441aac573197b55e5f6201b13b18b86985d3190ca0c0d75809aebeef24c73645f9285fa6df75df1ce31deef6818a135a7408bfd6d126d2cb468c04db0f86f1f705cf10c784d7b46b74ecc0d5a31eefda48455f146cbde8ad7d2a0980a16e9fa1a67ae91ebc482aaae69ce5844607f971d939b3ddfeec3e0e74ca97f9d8eb424a592c6d222f7f5171a34867c0f0bd6acc12323cb82e69447ace44bcb9e218cf230dda53436726958f702f95b5ab1db3483c8ef925c5e9921815106d1749a58870df761dedde17849cc1cdd0d7a730be889a365806523dfbecca918dc51072bd10c1c00dd933e976ad26f3f999352ac8b85ac95bcaf9963f148d0f6d00869585b4660a4d22125180e8f35d708c8656a69d10c5a5901c37a6487e47475e4048b8753875a9a13561c235e8e16990acf5509bf4fd5057735087d7ee91ccf90634d2aef6019c782c500fe0e14bb234385f42f60ac4c75a24b2a72cf83aee9e1cc9ba75e6d79522dec4947a4f183e8de140a0e6d250703b42ae0083c61c68f19f103ecf67276a3f0a634725df2b490441794cdbbcf9eca6babfa41301c02342834665e9b45b551a875c16492a787d7710e20af8ff9332041fd49fe76d328a56738e662fddc1110b04558e2835fd9d94e5b5f6db4f99c1b43debcd59612c9dfd03748683e28e9d0c85c8129e3dffe543d34ecc8d7c2674d2695c350b362f602926d6174b99e1053d1e2dbef8d46e79404f45b88f3e2b9593d97d26033416f3d6f895380d0e3d8bda8cafd92386912d1a5c1aa33a5f55af6429fba7c722a55fc8ae6261ebc55aeea2fccb2a117a3b98b9408c6504ed2edaeea9418abb5507cfa60b46632ed85c4d16bea818a2078a20a5501ab50d4deafdd439e67301eca02868eaf353c81be4295a7db7a62e5271a65576d42a2bd9ca96b471b5a6f562d30eb2dfd99d88caf74e0ecd31203354d981fe9c7874552abb9a7d3cefa8d5f1e52c1ded16e3a8dcff683f69dbd9ad5b3f2a2a055f56dae4d897c6646e0afbb095b5fa031874629c9c7c69437b55ea4e4c4621fae2bfa9efb213e1515252d33e5bc8870302548951082df1d31cb9027d738bd7e91ffbf61f5d485105b8b44965641252db8ffe6b1fea591f10678cf7d645dc2b36791b864b131019462d7e3cfab171e0571ef0001a35f8526da7cbc54f932d9cf390e57c527df94156cbe60a651fcb2dd4514f4d5eb339bdee816ea68ea88bf110178f60f43932483e37341ecdcf5e6b711438850106bf0959e5d50905c0909ac7dd8bb5104e02f46ab7d6cee67bc2da073fa797b2214be62a784f51e27f514ddd7dcf2f0e3e28f4dfef3ca1f902b6152f14646befc84eb74122389f0509d7392e698934c9272763dff5c0b15047d6ace541bd6af0e17b80cc2cbaf48368c729dcd53579ed0384f8435170c1226ebbb35ad42f58f7ebafdb9657a7a17e801b128c6637d6f680fbaa8331002e705fbd32c89308927bcb56405d531e9d5743f77a8a22b0432f8ed260245aa22acfdbfc2a889c23b91304d548e5eeb626c41c64d8ec1abff53802edf489af33c37a428cdb4dbe5ed9bc9e2593da82b7b7e5848fe983873dd90182521bdb7ff95acc96c172045925606cffcb185f0735e8b65ea2a33ba1bf277c6d16ab9db9ebaa65d64e8ccadc97ad1c5f21d86663a03918021664dbf702c1f943cffa76f3f18bc24f83f328bcc80efac5b1d6ea7b0919edcd417b822116e646a0b0a9b46ac8192176979d11082e9b32a4f10961b94f96a5cb09fd3cd048ed3d7a4bc8c4740e869ce4de15345b39d60997a0aebc7cae13392c1c71b46837be9990501c4dddfdc7a4b3600370c09e35f5e321eaca65f0f86b2277d3d35496af9ee44ed4b8e161b10568d4ae5bd6febea7f5b0f7bd60f474e60e015ccbdcbbb43ba5b77f33bab022b6bb78b8bee0d8913d183e874e3966b378c210a5a8cc10c8fe3e3b2dbcee93c288dce12d227ce2b894b9af00839c377881ab23c92c32cad942ea884c54f52c3f7b629a70cca4e8d30e86aa15a292a100040c869686d030d912ae5ea11d0d16cbdfa0d239544d30887d71a606542e8f3b69733843339cf05d23d56f1f5efbe2a8d3c867ffe3448dd8e35581b7c2a60e7db6396bbe9584b11a071d564147f8356bc88f648de2e864344055ca0a8f3a1fbc43100984b0bc2d52922872fa33d4518ef7edd1f23fff9536f9a0b45a3a87915d7f7edda829aebc8d78b964453e6947a5f1aa014d5dc25cbd0074ffa803d994f396f4e3816035aec488a03deadb7792d0b78df11d0c24bef28bdeefa2859a0c8b6b874a5ebce49e013d817d4dff887ec6db19cc864a5393a9d6403f52b5f0b09b018c97ffa366e8a717409f72c3239a95b1c5dd6f5fa230373d5905729c9f94057cd6afbb484c783bf7cec461ff8038a1cd7ddb32419b47c50155bebfe56f54392d7aa1be5d517b78e8d2aec9a72933dc0560f5b9f5502a3417b240af5e656ab7cf59b4d909702ab4d5d070415a4d39079eed2f2d11036c9d7dada1dae2d023a71497f3560f682c27b72dfa5a604e3f71b9715146fc656ee627bae7343ca2c13ccef947e928bb56cf475093f9540b647157f582c85873f14ca372a0c67b4fd5672e153baf65cd45da1ad27e8e4d6ffebe534c27a05afc2ca0884ec081e772c7e4f398195e51573ebfed5a18e7b135032eeb986e0ee99c18c8f05c32e3f65f4eabeb2c53e57c95ea5fe3637522297e8ce586170c358a08c852164a4a4b7c3101db1b68fdc1c3cf01914a8aea6110116595d13a211056a0042e22cf2b6fc24e517ddf6eb8159e999a68e099c8151a0ec84ddf8dd8bc9d18ba2487a27c6944cc84bd26dfe7bc5cf26ed3e94c7cc5542d1fa901c9ae17eaad425cf94aba592034727c39b781eaae745505b3cd1ccabb575b22c928403d61aa49318369ebe7e77236bb686e759044d92db85d19250edcfdec2a4a7d7d5c43cf74e7d2ad2bb9472929823ef552ebff4847b87cdc3c06643e983e6bde011c45cc467a3a00675460fe9b12ff0777f8d1ce4c2d08c073f9436f79f1950b2acf19fa830b0bb1645ea4ee4c09bcf1a300faa4d26d2c0ec637c877f7ff3b840a6ac9ecd1fb8dd9e36860bb61cb94b5f689b737bdfb0f46fd5173c04728e0fd9621f859ecc2a61d1bb7c558bfcc74827d8e45f9cf809da743f309f6e00651478be5871e1e472d71ec4f6da03a53bafe512780815483030198fbde5348f028d7d24fdf7c01f25f1c86bfc8117fdf3db02ac0bba0ec32602e9472875492063704bb0732f73a8e757484ca67b632312ca294e11061db9b09e20b13374eaeb69d48e474e674ec34f8ba443ee506e9b30875bbb66b034988fcdcfb3b3fd9c19101eaae419d458880f93c6b18900e365d93eeba6ba81ccdf97f47edfdcc8423d98b2ced8694b3b3a9027d41f10e7503d26169c17364a9cb5828abc261871a1e6d2d8433da5a018cd44a5e69e6660a639c5c6268acd8da469065260e35f2f384e564a89e1ab20925c6822a340fc139c74569930c302f4f26a53ffd68e2fc8c50cc9759b61ebf97b05f06c80814a0f0a05c82b1fabd036d379980f21f019f169a5a418f73b5e8c7572f10c60254a6d69a33f381ad86140be9f8ec243346d9f0dc16241dbb04d2cd7b8aba9a0ea650bd0d11d7656b2f17ba47d43b2e76fabbe1177be2fae16673d60dea28147aa67","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
