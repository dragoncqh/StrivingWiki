<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"22a5083337bacbdc715a9da579925b368abc85ce7e7eb7bb225d16dd7dc575083bf18d87bd12ab323454f10de8b8040a832d34bc104777eac8466206ec8cc60ad97d6b7e523658b4670c8a262bcb9856aad9742bda7308cd4221e638988e48176e82b355338d23721fbd377db5225f2cf66a2f4d832b04916b2806f2c90f2df85c5650a957fd0761cefdb70e8c7eacc81e2f3d4695831e0c1936373494004573d2b2f6017651d1fa0120cd58b8430b01cca289e444cb9477b2dcf9eb70aca42074456d0f4004ae96bbf328988c1b48cfb5a2e6f21189f007b758ad862427eb8a71d674afa2d2e55d4f31c7bc70d0f19a9608fdc2772248454d896e8e945363d81730fd2d806ce2f8383029d26839cf36cf810af31528284171c6b0c301bc3f340f34a5199e409e09f779b552e05dddca6b27b61ba915456eead42989cede2164c2655e0d4ce16177d03fa56d344d7885718991d8cf32bc5e7869b9e1d7b848fb1f86c012b7118b1fc9e3b7aef9b81daec3ce1b1edab2cc1bfbe78f44b35a516d2bcb51ec0b4f93cdd279e0f0558bf9789777243ddf6ac58c635c98f7fa3ccc627b33730025aa83dba6ccbd4e294b72f5434057e4cd702d465d525798ee61319befacc723a1ea7360fb28fc8bf77c6ae84060c6fb3e24c913e7de9066622befde883311d4488b0624a4da71abba57cb523f038f66bedc27e6b6d70a882319bde8a77ff71c3bf76cdc1a8adef1c4563e630d02105223419defc012efba7d1b898ac611ec20696509fe7542ceee03d312f04d73dd5f2d47a777a63d3bd34881303c9b4769ecbc7a18f7756dda9d43882e1a385b063d14d8ba3c7d70f37e73c2d08226ea9d33972095413f6fbb5081a52e7440a4c9036e820c15e9324b730857fb92f109441189a95d8be9b66bba367318ed47ae4fc801f6a82cce20d063196570dc5cc5716c873099876a9fa9dcdebef424914ee1b0fba1d7de1bc6c2ecc776cfac7c9f76e0c5f84d6db5ed1f71aa30df8e541109962810746697ecd5eccf37057a09ee73dc7982e646a4ba3aaec7f10db7f9e4eee53f1657f7f702dfc7755812772c665a4316584faad6e85d1e64ab11a4d3367f737d3f15d12f81c5728d972eef0d1a68ad1c49c2872b646dfdebd963879eb2d07a692e4e94d8d79f2cff0c918ab695247cf3ca9e6ee62e4a934f8924f8f2c40b50c6f4facf16c5f90fbd77b5a0d95f1384491dbd438ac469c91566db20fa1c9ea691888a070f0334a0252eae920c84614b6da24153ac643f4610149950b3e8e1f509562d746646cc2e3f146b1b72b397af788863e8f09ee71bf6956561f127cea4321dfc1068bd5c4daaa296172469de91a3d6815354ebd2eb4daba8be63d26310764911b2fdbd21bd8d040c09dbddd78c2941daeac84e36317cb349d15a46020665694fe9e7ee0dffe57f379a5c2291d0e1ef900737ce89f0fa8d6f58b24d8ebb39865fb1028d6d16e6fc14ec1157f9be86abdb17ce5ef405d51115e904bbc09dc289d8bf10c96f2a82a1223ea6f9c51f85bf2e29b09a49f99c34868ae49b57cbcb533d7212b7f3fd915a26862cbaa0dbdd11cde5909e75854e55bb8949a838f3549b769c5572cd16c91c671aac90a723e5be44c8e4930a6b05105475e7d3b3efd096b51e425d1568a3e0680fd1d8988f894a3d2d66508b58387411b40341a29df5783a346f6abbab85ad5b9083fda2a25de3bbdf6e4014c5813e41901cd0a9c258e9573713694e4b438e12f40a45f88ec7caef6c6a7d42cc285ea5ae25d06a8bbe42ae42ce428ccd22f8add790604956a03f8f93e7eeed8f70be3b500b656790612646fd2e6a004f5a8cfc030c1e37299a6b161f1fdde86c11f63edde484890eb8fb850b59fae647b03e8a5d360f1694513f87d1235321a2fe5fd181ff908236a425796b19529eed9dd3d271bafe1be2e3ec212a8b9194e23950ad845cb9f81e525acfb16a73a2c289de4948cfc19a640ce1f3b7b7b34ae61896b9d6da126022fcbaf801f6b41993b6b61738be491b0f330797b8439ff373c37e6583a6fdca45b4b39c96cc87af1bd332aa1e7a4d81b428f100be56905466b1645546263a13d3acb0b172715c9ce0c751dbff20bd8b96a5751a1da55f54a2bd9300c97360c48715ed57a1ee96688a2830ed97ca0c69e1a7935751650a34a21dee23bfea4b38acc2dfad1b6a46ad59dac8db979c27a83217b869c26c2337ff5d5eba330a176951f25ded4186d96e314744d2acd7e69d5471582d9f78f6beaff149914e01bc3d9e51655c04a1387f2db43056e9f16eaf2bfc412ff39041d167326307fa6533d09f09d3a6c7ce50910327e263e1232f39c32bae4e3d11d8e1e0ab930ee723794bcc5952ca29e82a3cdc1c414c5b7899fce7532519ca80e1fd99e1d5712d202096538de726b5bb19658049c52f305cd1a7e555d891b51be01dfde700530df682b2effef0a9bfe22cd5b04f6c3de360533dba2cd51ecf688537cf4e9da70e16cc00b54a3eb756b9e92366c85f4bf993c5238bf4c2690c71eb8590a832238b03ee37592989157c3d39370b9b7fec22b96749a8e3ce325e7a111aaf8321e93331d5cb12e540632f2c201a374e3ca99e8d4b03dd723e7398dc63346dca42516ff149ca661ead56288079a6c4d804059b14f3f3ffa637b5848d0b1aff61a3759ce66c6cf139ff05bbf77e71ff15be5facce420a22b2c80dd97a34d0ac3e9d3e9540dea531fe904068f429ec14d410db944426f626d8891cebaba919f16fc94731a561d71a67ac478d7cd60f7a9d9b596cd7ec78ea6c400d9e50d2910c383ed40d401ea87977dbd87ce29f3059ea1694448e5a5cc5199e027f77fd8573bd0de9c1d3c6a82d3688cc9d3a281ec60a273c5ad98647a2222105f813cc3d687d923e5f066869a1b96db7e5a1a4cec1eb3d798aca26176d4423e4223cbe9d618ea08c5951c597614d4ee8a57049ab6920bf6c77d4b13ac38b3220eadef2c43718a444109f1df4eb654fe025b342d1b727b5eb73b82d44f332ba62768eb992944fe9bc44b799092a141bcaaad8ba9e6b59c7d96f7f8854f497dc9b8d35b3acf4fa7c7a97886ae51ac5f57d6ed3a60d6ca34815173adcc8d8291a857834838cbc104a4cdc133cd25f01529d3af515ad073d8f0d7ede0c03f6b554e9f5a1da038b13819e90b0f53068c53cc6f31f19a35105c4d75788ef3fe0965eb37df81204573725c5b1e523052cd24386c5b38f9ffa82dffdb659493f527640db24a2c7ceb43387d61e4c826441dd6307198d8991c5ab2601fe313f89681bde985f1eff7182e8bf6dc70607caf57243b685f3193dfdd507d46e07449fe2a8cb0261c8f30126a20799d08acab7e62871a26eaaaf0db99290addd513f1fbb4aea53da664fbe8b32f171e20376551df6cfb0341ee3598bda32a80ff8f3952eba2a11ddf6ffd777408152b498a1d96916e290e61b87059551af504ca9a0fbd0411fad23509b8eb17c509db0df8e08fe6385c8737bb32807f75d8ab545e6f0bc325b3dc505a200c04aabcf815c5f67e9db0dd75703d25d703b0c1e8fd28e4d108d150611d947c2fdddf9a6fabeb10cfcb24c830783906d54203c36b5e88348e12d06dbb6a351fe86a3210b6cc0aeb940a233a5808752473493b600abdc03f58c38b99086f46247722094ff392a7c11ca1bab2bc4403cd74a6b3051f4f1c495d6d128f13600e14586f4894f5a44478d6717cee5b94c59468b80d54ad7d1708d554a523b50845b10a5cf86236e889fea02484637669b6b64b673def3b5c98eda2054542b4ff036aca8a1d633847cec19bcd2241daad47855c62849fd1366f526e795776fed49be69e1390f64566081bd340f9d8e890430130855e021abe9e5e75e8bd01a0ae2cfbd3d6887cab8e97d10b183936fd61b6cea354e2925f6189c3ae0e1e5378b464b36b51e12dca6901cd92c274e6370822c88f5092906b858ae57f225857b545981e319fbe2ceed396da5243d2e296d43adf1ef2bfcf32aef15067404a0bd27e2c3b3c94a2955f5d9bfad18d921f439044f7f5195ecadd8a77f279d9520c6e8151b439b7a36e3671aa814530cd4818c2b9e4a0fc094f4c8f7bb71632b5ec7a402dddaee9ac309c627334b59223aabd56f3d81767426aa3c1245ff6dc9ec6fe27e8286f780e7e62e5e1ae51a29a03688e09a1fd0b1b8c159af775f0a062a8f10c5c30067172cc8bcf77145a5b6b511c20fe9755ec2532c8b6c337aa6d6bd78f3d8bd8fd4c9e75bc1348c2af982effc7656f2586b69ad3c75b2a17ff59e610f8d7a5f74609427a1559719f0d612e7b09a085ab39481f49a9dfa949920806dca6522cdf242ae3958d8eeb8f710cdb55a5f632e30144aba1e74998e42aecb28225d5ff46636d50f85f797a77b2ca3e5cdafc7beb850086de0cf45e80d1bf7bc620c7ed0b38aba59adac9ed3177a8291eae9f3b82f3367deef4d8acc3bd08323b14ffa58a4bc9ebd48af30f56fa0659375b866322b52da923988d09f6c590305f589f80a90eda644fc1faa39d40d921cb1e41fafb99e397912d6c196cd0e893167b1a6426e3157bdee377dfdd4b369322ba805e4c6f153d8b8f73ef6d05e980c08f47f6367c9d7581c8fe0af4c18a9cb5d3c804fcb61c8044882841dd4d452d7f839392c865cc8334acfc79ecec35dccb60eb476ade27a8947674ace87b5f57c1a6c9059dd781df736c624b85d88b589121c1a41470b54c03023a05435bae5796e7a622e7d2d86b69d519abc95515131a958978862c02f7f53b7844c1d619d9108ec2cb0f928695441bc95b49e4af5fbf8a5625268e4ef8fe60e46370afcc2c854d3099aa14b5ad016789a1c644c560d2130df0c609808939d62d36791a0f52e7d92db4ff62248a37725af61103419d50a26647529f4b9574128e876ebfddacc31361f87ab46bef2fdf980f0a54fc98ed23298af4cd9eb08cc7cddc46c8b8622d64f2fcf55cf1bbdcb91b39bd1d1ef8a65bc4530c926b59b6ab8be54c08988e4c57bc7bcb32df38ef119435fb99b889c3ea479cebd090d98f2e89e48196eccd1974f8705356315aa05dd2719693009836316c6381687ea3b97d89d3b66ca0cde8dc8545cf2025f5ef428983d9fb048a5c3af68bd2af0d0f29d2828fc124fa9b9454bbb52e86f8c5f349653f4ff5b587ad068f90b444feac4f9649b94f10511ec79f1b308efa6ae8935e3b48933438ae902721c8e3835f5efe34ddd0c5138f67f768a0c3bb6d6188754d0c9f37035b71a32f392e60b61649fa36c48248716220c95124dbb4b111d119c1dfba9915197ccf756f96a73a32e780e43a87e6c0fad768912357a2c00e627089d4998aabbc50ce10e3ee56a4321599c7c5592116981737fc2d50ef48ed0a14d3a9f41ae8abc39ce7a17f43d058641d2829a509bee797b01366cb6cdf2c039e583f0577ff5994579d5c62942d1b363afec15e3c619d8bcb490ca05c1460edf2297f122e2336e6076baec53d583f5c4e92c907f036419aad0a42b8e4bdf3e9cb729c963689403a8c129a354a23ca1b9ea21a012bc4cbfd36197a2ff32ca2fb5909a4d90c3150b9caf52aa068866b18e876ec86a1f73d6cbaf963e76eca83bdb7df26cd53860f8f0ecc6803ba4f4173c168a58142a94b7ba444e35a3e4c59926ba039264ab04416e076e19214284dec60daa109b6bce93e857a296bdfffa7a11f0f7a16697356168920d556be127607521a02a7f8f32d164ebc087fb23813381589f84d91eb828ba2368695ec39d7689f08d9f4cf460652283aafacf7438c753196e3b8a95c5bd3243c1f950bb122d1db90cb12f97e5267cbdb767cf9501f16d8fa64137260a893063280a0d283f04d957a6ec1bbdbc889d0516f10f0227f3ebf80ff2caa2e7777fb044b071f260af1c4d2825569aa029eaf0aa7073a200f1ebbf522553bbeae244bd60b9b51b6fd2a96fe0c0163e6159d36c88a086698c3350d2464abded44962fc70afd24de31f7c7c08ceca746d834c9eb3890dac1c57a445b71250128248bd47b722560b15f2150d8b840057d0dbba9a7a6b85efbfb0eda9814681aa47e17ffebfa0f7c7e9d7ca495699e4c1ef9e01c13e864937503c9b9297550bb504861a93105f0dee0db0cc408764a6353fef3cb1cf3788ad73358e8236e402f44d0ec69c81944ac7d941e48e840e1f97bad168a285117fe0a7094debc2fd4e1199399d8c22d016d5a862d47f7172f5fb546003462063eb4b2b44ab3c06c6d9e37b79def23ccc59169be8aab53bb3b359e48d156e145ae8dea11bf989f2b32876ef3b6aedd1b2e9fa30b312766f1cc912b5e0b4e3fb5f8f7bf173ff6cfc73946f4ee534835b520d6b5b8e8cc982e4f35f2aee129acc1dd9aaa3f7ae933832e33176a568706e01022d2b00cdc489d6921d7f9add5c8956c09e1dace94b1ad1e72d6bcf5f98066880cbf9d767e901f64a10212579b894a28ebf91d6284437fb6b0c58e8c0c44934f5f954c00b9c882db3ce6eb2d78fce91e3b05f36cec81d38edf0410e4f889ee3eb609a3bcbe72120d701825a54c9a727ced76333222d8d7639f64a2ee30680c77b15d19a9be918f8739234186e03997ad8a00c8854678d5cf1158b1d2720984aa45a9d952550466fb82f7c0ee8556f44dfd85d1f38a4f7e2f64b1dfe2cfa797ffcc0a71797a4fb5cfa9035626ce276e350cf80327c0b6f237d935f72527cd02d62d37369ecdc35e60ed36d09cf8f110b23c37cd3d757c50f572d5b0698b372d35be170051a8ef24ae130c5b5361bb507331fa823d8f9407d2e857e89792d61fbaee2eced144c6c79ce9cb1125b690cb13da2347e5441a1499789199a46cf187483224da0e03e88d1c4ca7f490f3079240754d516c751461fc719db1c6d1d48d3a6a74fbb24bb9b98eb7f2e4cda321b5ddada795976dc2a1eba23b282ea2e21162122bdb187acd41c119790d615501aabd307811183b67413f0b3f6c0994616cdb6413326b2a9f742d3204e8cd6ce83b30de4e7314510cc6bce6e181786c49fdd76c5f2dad2cd1b7cb7ece8db8bbc2c3947e5cac556d9931a57fe4555590f98f210bda72462e46f0805c15a6c7055445350c12f96e9c28556656b189d757bbc6b1c5eb88b3deb57fe184f89d1b7ba94b2ea0c24772f3065b83885311357441b80fbbb94a16b1b58ea52ef3fb57c5cb4d27d7b1be68e65314d902774b58fcae6486761e1d34d6850267818088e7a2bba0eee6b9d2b18cf52ac3b14dc443fcacaec796fa763dc5db28eb0ce8ef6138e346ac26d9e4741c21b5b68e34da00294078a42e10c23befd5713b6c4ed255e406f25491636e34cc50c4eda6be388ef6b8764605a07333c24a4436e6b8eb185a6b3eaf8648e9ec92a1bc843f064eb76751f31b4220fe2a197ae281a413b5ad4efd656d73715c79d150b46c55424aa9b59500c430d7d3e39a75148c57a2f982f3a7ac9ca6c873cb691ca907207b28f61af2a75ea4e4da2ac6f0133f3e02d5d6b98cfee63352c715224d291fec1df868db39c2b3f66b8328653ce68ffb368e3831cba06476a4727606a3d8b6d4478516a14c57c1333e8b0a9e31c07a4dfec51138625d23d3e91d10324602f280f8fd122776e26e67aac90df6a356520c2210a7c6f288b45e59a1b2d21af9f84ca5f2ece72924689661b62c2c004b44895c05aca3fd6517413b2f2daf4e32ca1cfed0b662b4afb5263c61a8593b1a2c16240cf8a02a68a861f1597ba5defa6bd997b12b590648538e4b5688d5fb590cb07eb48a1bd8036843affe3f57d07ce13098cde77fdd12f4faacbae84ca2f8c40cc803e31e2a3673258339748f1e1dd756886b5e2aa0bc65ebdf17c561e746939544d7b23f2951c11209e8da1a6a81240b9b7ae2262c5ad52bd1cacbefd98a62e6701d0c11609a917928d165d9352b63dc8f081ffd9a9bbb5ec7a8a08c63c880bb917aa103ca4c3def223c198c1282ec7e49a0eed393ea6a59cc5052b97576aab3b3733b44e70d86329e00e54f9d09d1e4d36730b173cdc62a5f908e45102ed86bf551c00df9ab1d356df1229f3002619a74465bd276f24b609696bf3dac399ce3ab83200fdfea1d04264ebe014fbc82593ebaa9f2e86431ac9a872aaf33318d2faed47bf12e35d6670c747f03ec63eb292de651dd5da1a17ad7476ca302aeeeadce466f39f5e9ac858cdc170b7152f3bc7c45de5f591f83c417d15d8c19f2096504eea3d0e95bb3fb16682ff2ed80bb582426a28deee9fd4485efd7c5d851514663929221224fa5ca201bd5232a8912fecc5947997c20a624e8d43e82898a608830a3b8f967bc2dfe8b29e233fcf87738d8503102e7278c8ca38ce9245beb397b05daa0d69124942616368728fbbb42ec09f4ebc5273373bf5f7170319a7b6f27ec89a882be734df4546cad8639ceebc9a0152c6e69be5870ea8eede15977028ba98aab5e6250e202bd9c13080186bd31aaa43f8be1960a6d9a9ea811cb0f364cb3f2e9d563d6f13dc5d46359bf2d1e6ca13d10b5cc3777efd1a8af4d2a66928cadac7b5eabc5f3a2b5b9a520864bd3e0b1454cfe7034d88e68d0060b62dacbdebb942d97215e5f68a94f2fa9afa609735511461a1d432ba467ae6d921eddc7df5bf88360b5696c9882c7feec3f56d6b9dd2cf7a1c8e7f74a13d1a669854ac9213e7ecd4b08853717cde3f6bd9f8ffa51fdb4e3ac45e3ee72fec886bce59cdf8d4ccb1f969f008aa04f759b5ce0b941897f2fbff1edddc35a632f673d2eab0b2682bef1b5e93e0821c4c025ee05bffd1b4356bdd30f4f6b4ee5d25af8baaa774d09985c0ac4b3076829edfca666276161300642a7368c341b3279df442e860d7ed22596c9f6bb50119fe458d52b29dfc6d18925206a44dd61e783eeee64203d5618d74232ad3d1b018b8f8d2f7f8ac9496adc195d9745763cdb07df4842e0492519467ac58d92ebabf58c0859c11c0786a7a545ff0e30e4bc7d1c5de0f228886959e2495c7be208e5a171d4e4b76ef3d7adabc7ef1473ae0af53c43402fe91b096cea55fee696f4180c70cb374bb269121e6cde633c07fe09295cf4c735628306b5aa2a09f86d310213a0c320581f879c3c8e62eded712e1c8d8a2c6ab38ecb590005a17e61551f40a10cfe54dac68727731e4aacd68b3a7a270fe776c0d37b1e968dfe13befe5ea95fd5308999098deed9fe3fcd4010d825a202754f1c7e29184ab28d2904d5750a66b3cfedd8e9fdbacff0d8b8ad04258adabe61183a388391c74e344d223f7e98a83fc1ca792915954085c747ffabf63162a3e012a2d45d774166bc438163e1d9c42fb21eb832bf8c49f6a1f228ecda15b51805508a768a5412ecc6dbc50ef14a79afb3d6270f7a5464b9b11e1bf3c34ddace5d403b2fff0beef737143704e312688c1e5cad8637e49ab42c4f1337c78737c73ae76fe324cacfb710a57ec9df65e2d6649be18b5ec0d19cea57a4a003a2f43c47f5fe42e88c8d6149b0334d18ead397ef2341c160bb36582977a786b5d5c0a914efa23124842e4176c59834bcaaaddbfe3e87f33c4305f53fbceb0a3de71342eb72c9db7acc1327bfdbfe65ac90f2f6612cbfdc6bb38874662b6ab647bf34348cf14b3df64b8fecd32e04db78a78358b377b0d23dac35d7c7f1ee638fe09a6e98e21b4befe76c3290354a527c90c4e22e8fd290b8756895060a541b8252fb137bd4e50c965acdc20cd4e11f682723109868e86fff005af3fea98369f06aa48c0483afd7f1c89a1019ac55aea4e2f00f550427376403c3181662a3bb6dc107364cecdb26298805b46e4719f42a09ca91d7b3e91344438c40a98f13573f76a2356e43d24bc872aeadb9b1254142f417f13cebe4ccd774e98ab516737741f2c32fff79814020e09df2ac1f352bae302a0c965bdb50a99a42746f005ca4e10a9346cc5b19d96cae472298d06008dbfd03edd8214aecbcf405ea539b3329791c28a5de79217e8242d5943d022a38a4a0077f3f7a541adfa8b7798473dae38566de3727f453d1bf029ca6326a2f8cdfd4700ee0c723ef7463d6472de7a7a06d501eecd20916f5e70c32075bda3a6945c0d837511a8330032730de9382a44a090a1276eda3331dcb8113c10d27964b1ce470e3ca17997d13234353bacde4e63244358a27b2a0793e6562e2af052199c5b8ca8b771d480a13cbca57c9bbbcb190cce4146544663d2c809f08200531ff457d2d8954d1517da18905105dbc5a93bd5e18e4148a0cdce0fc87906f95e7ad965dae0ed20b351565026a2970d7822c7dbebbfafc46c1a2cd5a3fc2e53c3ebfbad36578561a3e17d0d4019b42c9817a7c60d575c91f1576c34a923fc585d12620b51feafe5982138bb8be789b9d06f6ff9629af8465759305281f142e8062f86e389b55effb1206031a4970b78a77d5b8a3ef8dc61ea71270bd3290951a905b6d6dcfc554cfeb91bf12f7b46eda9cfaa8f86339e17e1985e979f85865f9e1a04ec9ccda7811cacb031f6936c6f6ef61536555ced81be3d78e900e0ef3c00eaf7772f1ccc0dd9f4928e99614d5228500a526363fca62c5291c921da25cf6efec64f6dffa8f3a733c60ae4681f38945c9bcf4879d7b09e26dd9b028ff4c9e52c3df4c2c991707fcac1bcd9c9f27038b29bfc8c65e3d0b47cdbea09cad0360056dc4888846342651cef61ed7c490afc4342a1e3837dba8c67d229c7056bc342ebfa6aa230b1d2608c3e49a8d5728171eec3adb872126b15e5f6ec99f5d1ad37116b8c75343491450835c782dc6990ffb2fc5662efd781ce3c373975e2128cbf11df8c9be206a7f4cecbca8ab28385bd248a97dcfcd15f5a318e8f79920df620484109331c88b7fc889950285c55311c393926500a99ba70cf24e55b4a450ced9e2afe62a8cb40badd6feaaa9e40688716bba78335582cf5a294de178e934c916ee53b592c0687997589777a8d870e8ac0d6991ec3781ec556757f2fc8b6bcdeee2b8bb224418a09f65ae59b16a75c0fba449a35e8c5d7f3e5f7a75ceefbfaf3242bdc3a55da97850b719e3c7e0f95ebd344329d66c73583ef13745bbfcb87c809288046e3b8b64fab8bfa862d91d5f7b052969a6461644a23cfedd94a8528b1958868cf5f0684e22b557d4a5278e0abbb27c88472fa1c7e227a92d125b093efe5c21c23a72efe7efb71ce4c910b1b4d53a3fa79b7ccaabf779b258b5cec4b45a41d222648d6a4467ef342072e2120aefac0d88bb9cd37c8a335b653e1a0762a4170360f1c96d9ad9ad20bd3d2712632e2ed00661ab784f32ccf07784fc579647bb70d95b515176ab8034fbb57a8a966857e5f26de953d24abb85ceb9a789a485684b428f920eb0955332b8dd7be6bf2e13fb4bce659a88bfc67774af666c8de5293a8bd4574d8fc5fcb64cd03ac478ffd83aa89ffaf1538c5398feb571f044c4508855d75d45b800c7cd034d9f6aedb7f6099439b6f434aed7f4fa3a6ee47c48d4421a98114c3c0ed1cf47d246575149b48c7d3e2e887cefc532f79a66655756515b8d8c6b90f0fad03e1cb0583e57d50423da8314280415a641456cd9d2bbc78dd79f44c81d05acdb73d2e7f073fe8560273e9e188853d534bc382353a2a5aa440d459673b4a007fb6556e0ed1d3b1e3fb081b34330b15a821ee738805190d0c1b42d5bde295ad5baa1cf4f96141c3f77910dd135add8e51b94e0171eb598fc73e98d03a77e4db0829af1c7d9c61dd33e16c033c4ad672e3d251135a0878da421197b537f36f17c9d20b02802388af4389c2cebf6fefce0187e7c754de12d9ac3e93a1486db6aef0dc289f59f0845c77da7b38898f81518b320060ef8c7b7247ff9d9463ac93f8d251b189cee12cb19a0043b311dad77a5cdb97865889e36fa289960e250b1ca21c656c18cffe983ac713866102cbdc042fa8dd3071879691c3d8faa8bf2e3f218a6a934f5ca8ea75c7091a350c0626af75a4038668a268eee1dc9ee91fef77872236bd4b2943424d277d3806de8bc167c06e1fefca0932308c43365c78a728d9c312dd66894b86901132b28f9f20f817f146a02e0a9d6affed3ac5396559cb13c43c4712cf82325770e74eb7eb44c0a8716ed1ada3eda6a75513f9dc24cf18d53a5c13998c136f28a1047817649356cf2fabb633a4eb1253c0823db3f05a201ed5cbab1660d1c3cb3124f835f01b07f34ce423b918241efa4a317bc3464a9a64a9cddbb55b010554815ce71a9dcf3abb38d65e91d4915de00c6b1b3c7b94333eb90a94effdeca1a7774ab1f61065585a0d11bc3d937e623bcdb5b879e5554770a20a027d577f7ce060b3c9aa9413ff205ff8c6a15d50d639b12be4fb67677d960f7bd103973ba4fa9171ef8c74d2a09e580e88d484b3fa844673dba2cccb4249c3e53451f0c997b7193b49924d9bffdf8aa764c90dc81c01eb4cfdb1e801fea528ebe638a4b3629c3139995918ad399ddb75be30a20bec321cf83c456c61de3a328ee0a6fa17800db32691e66a31b85c5eef72bafe29add3457524ea26c454047e0460a3ffe56e67dc3d94bff2c26ed2351a7d2a415bdedc1c01660933bff82ab381b0f4c78dd5150789aaca7b78a0e8c379605762930d6310580b869e90836e9c44476323acace062f24c5e83ad1b71ac7c21f9b6a6280a412402942c800cebc68903c53fdc5bf09aabf353fdf15e2809d8a90d2092f1dc2a62e96723177949f74befd9f3192eb155be6719122d11e05852d23c018afa0d683d2287656479024ed898c018780984ce0722e69a46b7f34eca6868c317710ae8f0ab5438d03f35c0f1eb9a72feaf0f64b8b2d4f25147b2633871e840fd156f75acca03f9845500c4e7e8f0547256fb5b2509ab57ac856bcc9c91ebd146605440882aff83d022ec8fab7a4f1162d3d29612d6d73cbd719c55832203fa78a751cfd8a8f07cff45deef53312c90dcf7dbdf93627043b57ed846190966236bda237bc767e541c2148616f340efb412f585d0d184e10357ead6c48f955445424d192c9940b01a0a2c4a11c0b6d5fb2fbb424f855c178be8ed6f622b3d53cfb04833d6e1788ab74e73c38c5e981901eb7336d40e140df77c5d9863b4a92e4557745c8bd318f96d1aa861b960d5d19f0b530d73b3f4dd43151fe3d4dce82a661b903ca9691c017d21c507d0bc904eb2d74eead2828715cae19865e680d2448f8e600d35b31f3d259ee84e712b7a602bef9c918ba6f1fdc0b6812f1efd76a8b1ffa1272ee2049bc0bf8d109dd3617512be57dd2e7d72a3f16ac38fdb5064ddcc8c82334981268eeed1b4b1f50806cc90a1e868f5ae1b91024e7ee49095abf0d09da83e9670e2682e3a1edef430918a6bd049dc09f05a2bd61ce31a1a0a46c1a044f6ac60b0ae3324ec3f92d48086c51969e950798b63b94174fd896d0622e7016fc721ccdd581f22bde8010d8bc4ca264fb35e1f9aa92f361e21a69728501c73d27874edb3ae77cbfc86ab89b4e8a6fb4637c81a99a64891340b2ec08caeb2ff7f7b20af68d29eaa90f01c0572c92574ca8a33ad6867f1602e244d8e9a83765d6818377df51a84679870dad0759006bb7030ac0290ecbcd4c0e5bd6f4a7104f9eea799f30cd44260b8e5f8e715d935dd36177c8b2c1d0809c176fbfac441c8c158fdd406f0a6dbfc7ae753571398f5e3b32dedfcf736dc9bfd3e08988f00161b45786ecb83b9e01bb18059f4f169b9145da35585dd80c1f0d3414323ce4357c311bd41bbffb6326bb170ff1002614dd283b80f3b9cdeb30bc51f40accee1c612a818b13d1e78a3375ae84c842c41a13f070efcf92e730f5d1338dc95fbda9444e92619af6af6e821cdf9ba0105b4f07b7ce41e444ae5353da1f1b42c06dfffb7d7c7c6493968b9cc60ccdf7059a3a0ede8fc90c437c8495f7c9a605560ba0d5f387a98125cade58ae2426c6ec37e380e124ca84cf1d5608b8a7a352bb46fa16eff8a1c01e116576030daabd0686c1331bce9cc3ed28fbdce695acee6d4e1f074ce61f5fb502347a8fce8c27a0e43e218fd10a3d67ff4234dd710ab38a511c7f60566a5a04aed7dd65c75bf3c2f01d73864efa07353269dd82d8991686796afe74f58e8ea593889bc6f6417ef6414f5da2fa716206dc324be91304dd22fbef7875d14502131f16b589a5783737fe7e60640b4f1c0010665545f81b4f6db31e20f808821bde34ece429700639882c5f0bb4512c3599fcef40bfa4a3df81ed7c5e3356fc2041cb8a2aab4086b712777938f26c8ce62d8d9893527449ab96207a772415dad225822c004e9dcc630229a5e99b761cf068bc977da46e14e9360669be9e573d2c738861240cbf3d0547b33b99f56c347fa6ee35156f4d27f6aac76ded0fcd8903629ee8d423698a0bcb1bea6667ce8f7c252ec4f563b0e86d5b1ff06245d436aff2b801868690209e5bd522f1a978600dc99e43d6e788b71632780468f792776c49d11def3bdea9198723743111a4da4b04311c5180adc0887f65b7d6d470cdfbbbf2227aa61b07c52951d5bea907c63eb979022597d34092c0520311981d69bd12408a44c33b1b0072f918d0de9fff684c70b28f176a3467316f93d7438732c6e67db45612d4f4973bfd9711b2f444f8c3b12fcd23522ea58d18efab91c3e12446e7169ef6aa2a47e8400d528a7dcc57c06d338c22acce4eb44881aed40e971a7b19b1006c9c791b96e1e4d45fc2f32e663dfca6b7df6a7237ff846a155812f9c6ef2bacb8d546a9dc581f38274c773874d4ea12300b4efe000e43f9e7cd9c157c9f0eda77975c6d789e5711b37ed4221d5a7b3b09d4cd307d94507e9eb3c40c9fb7a699912f702d68e0b4b55729985193ed4a6b3ab71cb5b9d88031a98790a5e564dc6bd41dee32e164ab647684da2cbc77b22b9272c6333d86b7dce5a9b7b52f7ab69081d51b31defdf027bec206e1b4fd660b1e350a74ed9396718256a1ff0535c6a35f18fdaac3ca1d51b1c326278866af4ff8297eac2738ba637cf14bfb99efdf54b7895f56bd44847fd77e7d8cdae1e2cf9d5f4abb0290d993ae6da136ee2f44e86412c486438f1e857fec294c3ad0fb54430e3098f6c742cb7c7a4bb4918c9fb288267cec081d7a7953fdc6bbd0e097c0fc3932bdaa841c884ddaf88662483cdb1346c82e8722c52b90113ca3a9299f609fb89fc7efc7d987cc44b2068fc62d484de02da1acd20054020698c2401804e24167d976bb9c0b673d5f223551ccd58b43635515abaf425aeb50225712442f7e1d77b687e44a282d6fadab93c335ac33b6a09f5dead920c7f26c377298c6ce12fb7013cbbefb7a219d0433ecf5c83c826c8866fcd79550da7a851d555c8c9c775c773c4c0861a12a6fb72988b800247c785d538a22e039f1c5226f751ce22fa7ab9022bf3eba3d5f8f76063e33c1df75878513bf5b3be356a7fd016e170dde336b079717d0602f76ada6e2cf4e9c64778a1af81bb74dd11ff19518ef3e60836be711dc35d82e5d692dd56eb64bebf9c4eff5c388eb63b0dccde3ac58eec2abd527b36d05470e1f0ccb8beb433fb6eff1188215697d112817bb87e053dc55318ddb71f917babafbcaccc46acf86c33a66e38d85dcca940fe30159dd6e56013508c693634005c5d0a1544862f745f324351185f37f7b13086337a411873026a968a89b392fd24d30d57911f38b9aa683ba3eb5847b9b2f18e05f358d3ed91cdb00a849a79c1a9e6af181097266b5c2add56583ce502c170708d66e4c4899cb595d134ab2fb26c05d0d23aeb12398ba1ccf68e0d02f78f45bede5793ed61ddec0a8f914f981bffdd3842ff70142cae969e8c0be7eb5b3850c769c3ac3051cf62aad65d8bbf379c21fa38feba325ee87a687217462510dced6a5de8b283979fd5f76b8dd537b9e344c0abc52c3114dad3ab57be7092afb72cfd14ba666ebb1bddede698c33805f70799121dbe08437a03bf519e5b0ed9da1d26ea344ec049389041068f8878119f1452bf72386e0f0e5bd2b59879a63ecc6c634dba8eb309d1bbe2162ff332e2d43b2d80195e5c9000b5116076cf6ac77f9debca23deab4546623fb288023ea67e22f4e507e0647a091828df7b60bcba47773cb20852a421b63ef27f8da68a44c7490ba3e175f63af178fe617f3c337cb47329a60e9c13a1454eef2875a2e64e058fabfe4fa216191a52c8df8115bb806473e13e1a777b9b9e16d7ec7e33b720c4e42da55f84f5665920b8d9946de141c9d54e44e5024571061b168f6f350a08fd20b31d584466eb1c59182e159e65bc91271c1542b22358ecbd4b80fd2fea1af769396393e719fa72f29decfcc610e8a0443fb5da43dbb0835b04fea347bd5a42b5d752837d953ac36b3b68c51b78779292bd5a74ff1f4765ed87a08a753f4c8ff2f86099ac4bb4ecd5621e72aa9bc9656c96fc173fccf3f48294bb007253c998cce1d4486c016934f2b590bd85ccb01d0772257f3d020d292157f82433b9eb9bd77f504e9c25c436f1160f1309f28f5748d3eddeeb33d505abeb361e1655e80818bfa8efe672e7a5ed4baf53759082083018a75493c09b2a469cf6ef42221a82a6dc367b319ecd82253c366b501a46b75ea8b1a21249a5ed34661aa046a6ff2eef8610483bbb0d967d38d16e6df87cdd1da638e3da2a03520c4cb164cd57539","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
