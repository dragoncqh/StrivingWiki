<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4eac1dd5f504e99d3d6ed21e8e54582623eb3ada4cfb3910cc6576f56cceca2f75d46351232588ae7af93cde0ac8784865381cfae35e0936482158647dc0a194839d5e5478197715c3dd1f27e9ff5b5ca4e486b804e05466c58679c996a87b08ab04594d19be63d31e147a293578608825ca6441b2d4d47b3e75a917188dceb7a2229f3962f588962fe9b0295d2acbc8181dd684bbbd550c4f54e4f6ad6d373031249d8d7813a665b92603933269944acc1b11c8d87bc5e896ba8c9960a0d0fad947571edccea38a147db634d8591b99314b9ed7ddf6071f757399865fc048ebb9de98ed6a87a4682fe89f431865560ba6c65ab5a704fe61a2225b18d57a4879c67ee8ffeca8e1a4909e88a334ef9b5fb06489c913fdc273ca508565edd72e67d6aef355a04ee2cced781f3d66a3be6a334e8ebd38f91b7de45af1e59dc1b587bc2c2268c120e7b45a644de5bb2dce7e49bbafa0b8a5319c75e964eef7d7a2e9cac87c202ea7b86d99345a5becebd14a9584af5df28205c7d17f6f120513c3d1ee6529c9135e1fd97da2ce4d22afb6187b55b7952addb6bdfffcdaa5b7de6aee179c45f733f44b55cb765df991c494ba2459dd014f8d4fb30831764e121cfc722d22d64527236156a734f91be1ae6f78f60907f07ad7a3f98eae0311834fadb62e1cc21f67259617ec8f89a5e78d2552e5199d2e59f498c5c6face7c9f3ccf5c5a53446d908c7aed48d4dc65063c81e62ea55b0883b4cc5bb5cf1b1e72754dff68178103843d3db544a5eaf62b8088dbaf3f729c5e0744054a6becce062c59936387d05d1903cfed146d9034f43dff2da28e20e17ec8b991bb2cf2af8e2904ae811c5242169cb816b9d5e40880b19d132c2ddda122eb2df09c9a064a48b67da3d22ceac504380f49a65e690f8fb01cbe92061504fb7d36332d1b7264708638e5673b4432f37c6f6a24621f382b8bd1310032dc021e77f3e0a33a78a5cd20ff24112f6af84707854d2ff7412bf7a385cc6b62193d9ba3dcf401c0abe8050855d3959428fc953c73dd0eae8435daa3990c646fc7dfd1719e8ae2eb86cb8ef038de4b60c8b4eced1f96554abc5a7b296e6261597c553a2c1741f5057e1eafeb81de5480a7b9c6d73ba86648c27c6e8297a767921d276cff6d033eb1e48d0736d612583e89b6601ac87e0ffc71f7541032ca46ce1de44efb19a2af2e9afb787c1bbcac8036ce998f4257835cc8c58845e1f8d32e08274202bb1aa8ecea3cf61072e405be63d899b6cde01a9b31b534e00fccb88d79dce91888bded8e5b9ec65208365838733064d83eb4e4fb2bcd5cceb9f85fe964696ecf4dd25d4d7c8c8a629fa3e0386900dace77c1cdd44d938cf0728fd62fceab76f4887259fbe7b013d4bafa1f10a8de12d3d912444817324c87b2918f28ce1160956301b42e5463e83ecc03f2368aee2013d3dbb803903fe148ca8de73fb3323abeb2f0d0953364d2a36856b6a612404c15cb7188f0c5bf572aef470d0007b0788c57685c96c0c6b5b45813a667d7f7b801ceb220baebad95dab4fa8f65d62f0fe2d1b00272419754e2ebebc325f50a45af43fc64c228ec870d9e54758c12a69b52942ddf487f4ab1b1d11a655ce949726f29f1463d66ea9e58128f2cfde8408c225997c4d08ee1adc2d466d1a0e3f5a202fc9ab6e323750587c115215cbec78656098b4015ad51152a650a2073b9af0a9d9379b1df1cf6efcfcd6d3e5c4f94b9f9aa21474961deb7b081dc7f9d492ed98520bd323cd8adf80b4effa837be251c29c9de1d76fbb1b203277d5090d270fc059b76ce2eee4fcefac8b15e9cb4a13399775069d23d30e71c04467365259840998ec3ead7acdbf1683847259c41dc53e3d4e604ab881d5e63f8f3abb1917d57fd977088c735e55cc6187a4fa6a0a571536a940dff6e82285cf6740863b6442be27316a33df721cef3fb954b9a131221e71626e29e3367cb241f2a91dfcb5dceb9f6325816337086c8eac2f2399a9620ce04efd6bf8949e6ec06bf03a1f80cce50c0081ea039206d7a9931a633bfafd20f3767ea2bcff2525522d8b4684af31d1d1a544356ec8fa9685197ba17023321752c96b35ed3c81dfaba3757e91123ac5d9b70a7ffdc43a6a7bbe01540367831a4b5d5e8b26d9a392bbe5f117f59ee795b2dd10f7cc827bbc90ca8529189a7320826d58863d63935acd0e60cc279e5f70fc77f7d0ddbf0d5ada66ebd25c76d6fcf435516f58dcb428b4a6e75b1246904a7451cb3566bc7fe3b14e43e375ded016097d8a7b68af1c83b884f59d24e3cd2921287401684c60b21444e5140649b7c0b94e3318a260cc99c890c5932f6e9c9b47eac77838ba68048ca0c0e0421aebf775ead571895e10018e2fc531b205085525d0e530db3c1e1cffcc3dfbf9c30ea7b9f5fdf680ef1dd026b494cd74477d9bb9f32d53f122aad4b45052c7226656c2caddb2c4d9b5c8b3a899b41992200d6a256bd1c784071202476bd528ae2fcde813b6b65b4e124a918c96c6af05aec22f03448a0038276eb2753a7bef0cd35b6ee54810edfd335d54c58291f5889c8a975df366a342ce9469888bf646d04f2507b1e8241659c4ba7af4443a3341902b99de70c260e4809a3b4daefac6ddc15491bf94cbb0507cb05fd290ea53df38cbea9ae68c4efed13df374d867a1edb66c44b5b77863024407e7debb2ad6a46196eec16e0c9644b6ffeb1ced17890a0f6339e22bedfd81d7bfa807a48743086e50b2d6a251349fd8724f88f21287cf2fd5521650da836e2823048bd318b2f4b1d509e995aeb1977bcec07677eefd9fa6fddae7c77e1cad93495d4f0d1b84fde3bbae04028366897878a0757b59aea32dd2553c633742106302fea786eba4120ad4b0f165f6161ba95219fbdefa4cea59265097a615e061ee9eabc366d8aa211519a016831a499c8b577db96873443793354d64f48015aa25259e2cbeb5980bf8ef965fdcfde3eee810b5194212488ce729cda549c1a7b4288eaf661b343e6a341fa6985410a194f26642c0df247b0f9cac07b5deb3bcaaa544ad6d2d582eecf9405a850872243a7d5bc1f514d1631663a948bb1bb89986acf00d4bddfc4c761292ff6552d6c6a3590c603f77d0e80d5a2fc91445d43e126ef65aa6b7fb160475f45efb15bc0a3af902be54ab6f205d00eaaed9d2c171dfc0f135d18c9dcff04fb3cf270b98dd521618d5d653b4bf7e2c19101f6477aaffdf6067998b6a3892e37f2adbbee737aba506d95d773a883ec5dae0891c212ed1c372ffefede24d837b454e09fa462ac3a5826e27a262818393e95bc70eb7ca0131cc08d15e667074c2501f7293da51f4ad5099b86514d822136750c4078d6618bd05479a964ebae2ce0b7af680af1765a236bd9bcccb50256f59f3fe2ace75cb1d5aef3146cd65598e8897b8b99dc90a5efeb58cb7562b1e5099ad314199ea19a9ec49bee8965f9295bfe7f88fe7c62d4c657dd8a7abb7af41f990f6a298fb4758aa4bc319369f5148e5629f224ad7786dde0516da57891d5ab4901784538f93144978c979c02cc23319c299820ec2b7ca988a04b874920dc3ebf21eec5b32404407f1900e0725918a604ae45ae924cd9b465a271a7542a7c1251a6f68df097493d2dc123c42f752454dc2d8dc2245f96b07d192dbd5dd0a03c6b9ebb7f0264883485dbd7c8bc8169990583a434a37503b506a2bb47d4bf3d7da63baf05fa75babf09d0cf241c520260372f2b96d0a5be700550d5b50ab64e432124f976081f54df636d91c9ea5ce75420ec3d49d323c54cfeae1297cba26b66abf0ed9191ff3bc23bb7aab8d00d650df9d1314c4dda6dc512fb59c453a798976e48cd88317340e6b8624605848b3d132cc7ec37db43e7846c2ec55757d4246a9da2ef5f7631c05ac00b54ef2d52caa8ea71c49296b5171288f4c60988c1afa3d4a580ec76523ffb8bfdb4de6658c2d9fa3437fa004063a2f8a379bfcc5ca375ced926b5782bc75bf64f0ef5eeb4f08f7b72fdfcef0bd34aa3e70d28f169b68d64b1937686f0e20be123d248525fa5029a2b25f6d5e71696f0cbc4594fdb8f63054e703656b10079dbba6149a9414fd389afcc07fe63cd13b42a8aa3a14896f4726a29777b9be6deadc5f80f790bf264d4e2b27bc9d18a289b3e084d7cd9cbf0ee5c90cac9a9898a31ad07b1998d6a9bc100f9efff2edd84c63ab180c7615e0729b213e397c8ab66ccb5481bd5c5a1fe7aa1f807a9ebc102d55ef2d3d26ddbefcf0e178771b40c080ecf1a3821248969d9a62f773984b2f846587f2df60e91df87844b3cf28b7917ad72d0569012ebdca1a7990ef9d362e5cbd356491f826d71fe935862da797b3ce4dfa1bc0a6a63e27569e3eb2eebc0e94049373c2acbd34cff7c028d56977c4da819818539b87df7c9bf3c367c273855edf575efa851a338eec61d1db062dc1905b863315dbb03fd078087d68901b79ad01f47f9171f4341f84e98a80927d7454e89d2368e95c894f2ca1bf7704da2dc0f2e7bb65629600d20db8c842408acce898b39b89ff1e80481667f8587399816ce56b5510036d527b079f69c26ea4485edcc8c6439222cfbcaef2ce989ec0eb041d08e81844c5bfb12d284c9f9c317aef209d5c602233e86b9a25bd623f7e1f371761055c2c5406bbe36f574a3bb1748845e02f1b2526167b22a038dde0023dc0aa2a141d7cf89bc0047747d5d2efadb3da8ac2e6ac570038e0fd92512222b2f39b4d03f412bd62f57441b5147371f94764d2370a9bac9e165af8f317eb93c034d258528c1f749d7fed43a7ccf1ba5abf60e61291f0d40e260f3e65ef881be568539cb98ecc68b2bea9c6ceb46324d35a7c2836cf8b0edfffb5561482e9eee7d6c3a74022e813087893f38e75d24b21efd61a16b46d65c01ee763b7a366afd86189cf3f029943856b54e6de8ea1453bd586e9e5580de760ff7b93a9ea28f6622bae3ce8a3a2975fc7ffe9b94d0af0ebc216d46617011cb7cf00d3a5c4a382cbc7afd049b4b031adc377ff4cf5db16b8013dc6d283e05b44d72ece15cdcfe2c6bfae5801f44df978aee5771473dd17f748479f59fc6f71179a48541f96930ea92001579b3ab8ef3cc44e1a6a980d4636b19dd3c49705d17d4bc9d0ff3f3d1f75f89ac3e401409c1112914749b71bbc08992ed41e3ed3cff85ec06aea57f441100d07f57f3a641dd00fbcd345c5991d543676c5604b73c2d10a3d1191d403870bd618d11710f15ef39dfe687e72d55c2d8e9a683739dd4513e4e45645d3d63f42a9471a1f221ac5292e0bcc4190214af30ce6f7387cc7c0869475f6cc2fd01a13d8f56d7cd0e11bb0ffc1995a7241bb4c29cfee6cb43aa2bfba10dba33f5f2d9a07cd40d499c5c902e92cd76c36b23046d6defc067a620f59253c495a598b097930fc5ba1957c01e95acced173b4248298134d23c9077ffb0322e9f20f75085d5dc8ece7f77571745a858fbf32f477e7f155cc423b1e9b6f18db444dd704c62ef71d4f3a9d2a8f1b3caabe9b19396e6b0015dc6020e2fc6bd1f9549e29498909221fbc0827fa679c3c9b83559df6fb6e4cd2e1ca7517298ce892727875fe67dfde638c1b51fee2ce7babdb1517304776d0ef5e7624134c45b3389b1ad631beaa41f1c2f51df24a942a69f5a89f752ab6497034ecdef341ea7c4bc91572c106423acda999819df1fc2113ff835ae55c918d692eaad4d1da3faa56b5e679ce64cbf7b621f51d1551424e1ff282f1e703f417ab3544527987e9b8bbbde9b0d8cf49f052a8e388e873dfb1dcaeb0272155823c9781b48732a42911b9f2d229395936961da60025e6f94987a059cdf40cd3ceae165ff0c1c6f3c6857c76536e5379e13b2860790264ee0ee9fbab7259635dc14d7663dbace89380f11ae338fa9c6ee993fdf45f434c0430eab211fb32befa1b780952409508085bd15692398e75394ed13e508b26f3bd93c56e8c56e492d71ffc4a67703f3faf891c04e995276bf2d8309b9b66dc61afa6e0311112b232b5ecf5c714641d12bd7f02e95affd03deb05143a88f805a0396593987f6a6c165e5d5b5967ee94720bc8d9675781ac0a1ac0ccf83f560b1b2518849ba48013be533087f94300e1b083c436668e148f5fecbb3ac3c11f2b83c307ef748a6cca2fd01622a27a913f634e9e66d48214dbec50e96516548eb0f0cd84b493fc6a56d8fa0b64234c1890d2847982fd63b875ff13276aa7be28b78cf6546e74e000060cc636bd855499a0dd239959227e96241b671f7d735ff3e3819a34cf03c6381546e4a5df800367c060f11ba8a3009eb3c25e0ae8803261bb34e9f64c0125a029fdfddce99aae8a3d0071f1fe19ab0b6dbc40c1a0cd44790d4fd364c4a02c49dce6062cb97c60acc24c88ba2d6b4461daf1f084ba5b72a7cd2ae90e5e28d4804de73c97dbc11283de38bc346b864f1214d5e5c23985563b64e5bcddbc79ab58e0fbc57ab0c89fc55b44c93913e1922c3d02f7f2a2d293ad77eb27908e286ac82132e9dcfc4ab497812985c12db6cb71cfbea636502b75d33e6b725aaebb7ccd9a860867a670d2e298ffa9dfffbe936cf12c8c2bda460ae51ab960b3153480b26fe1bb276b671ce3ccb9f82c078129185a2661cce7aae6a6d90f55c36bd915fc40e5ffef928d5ec72fbc2f179a514043f84141363b630d6ea716b6af7c424350ce765d5bab22faba77ebc03731eb782a34602022701e0a36ba78388388516a7c95a954d68ba9c4f8f34f9e0794568370979baf9800c996d19339dd0ac2e47699d08e8cbcb5f4cfd837e15b4159408f18ae1092e01ead31c74c219a9ed3ae59e187337514398bbe048da1345de423715c0a783bcbc8d2f3d3db6e072d013a22fa4bd11a95918d4d166ed35064b618023f4fbf047b85b05461391eec215a9281fa897a0983f3727dd04eea075338d23070b7e1c9b7eb73208270feac02c863ebe0ed7683d4b2bdbee46154ac00fa4f18ea1a0b3b32a747881854fa9a6b519e7c217b361c04ff88fc1410cf7797c80baa60ebb49b3ac72b06fcd9296a56279b54352ff65b7d3f829426fb4c8cebe8aefe17cc8d4a504acc70e57f53fe4292294a6aa729f22edfa25dbd3aa4c73cea752460e9740f7da74a4ab160714352ce4d1fc971cac02039482c28372cd24d2a710a3b6dd9a752b51693a990fb044b18617025dc16845ca05ab00aac8915f527f3048ddb4a7ebce407e18c7d01f99cf1500f1a815f3e8a75dc1ad257169f7f5966411a9730bbddc31706b3052bcc89b2fdf49562e0a337574dfe419e6b96e995b641dbdacaa0217cf94230ae4e64f226b6afdd221a1e0b97fbd5533475025f9449e8cb34ec59215ecf6fe0ea6830750dcacd14e3ce5e721fbd761d87839797d546cd4cc3870db237bc360a2ec71d0c2dcdc7d55b2a533b74ffa19eb5d116c233601ff1ccced3021d064c01610eca170ba0b53b8b81ffb6dce6c695353cc64b56d54a6be8c1df017b7110ab9a321705ef98ceecdbc82114409dc5533228a999e8d716d830852620ed30045e6c8039c1a5669a1c07ec2211e222cc6a8026f1e5d1cb30cd6760d6fa92b288d13fb8bfd2cfbf3c9651bb3451b55bfa8292afe8d279d39789a38439cd4534a1d8858e3768690f398e4717361312da33a3c70088bdca1d1c143cdc80c010047803bb937e9e9557b9ed1aae79aea75f38d6b4c681d7cc3649ce23b9856d8241baeea3bb88b5a81b6e81efacd01dcf4d3f97099a2d35889b8fafe08d8b0c70a0695b0a53b94966a397d102e42220e240e52e1d867bd049bfab45cf4ea955da2d5c39cc78681516dae655293b67dc5f6fa020f7cd13b5112869394156aab027d28e29a772bf97fe61f5279ca9318c76f380e511a32e3317d483194d4bb882a271c3b177aca2d821912c5152c1093c341f639041fe12f180e7874a88628d5f75e3f0094a8e9e8570e6106b0418cfd0debdbaba075e4d321626f06433224c9fe35de36144022650b3a8f05ce26603aa44291df31b6b07cc4ed408d88b98947edf511322bb623dba06a044b9020dc3a362152d71522dcf7f9ce777390b6938056ffe894296ddb8f3ed99680d7beb9f2e5023875e6c72f3fcdc3f3e6f108b4c9f331a41042880880a19a864302b984829958f9dd914118fd5f065fba2f9dd1544c486ddad3a6a75a11602c35bb87bff67f13cbf1f9430ec696b77b4e9cd1da6c77d2ed8b900a13c4ea3dd91f5803c9d37519b60b1db05ad1703d07aeb79ae39bdfba1ee5a20e236c0c6780056c583b27740b9b74ca7a90c04e38ba918a3c0852e821455d851753e9986cb3d18bfe969784f545fa60121380681c514be00307e43f349689a8c3e6b0509c1612c415fac78604e5e8859ad9b1272b70f397228340fdfa53eda453e65ec5e1aa3df6c31031bfa99a9a421815066f024bd172dce949ee1c22c0f146661da9427804e4c017c70ff13adfc99cb9e74e6ac91263ce38b8349947b256c9b82af20bc3241475ea77d9e9ba63e3f4f2434dafcc53fc4741de5dc22c4d6827f7f8f9d99e4e5e7711f6e105e18ff73b85bd9b74e5cde7cc488e020b456682ae5be512c2cff4ae2ce465e1b09488ddc07b59cbaeac1af95998e211b8211350071e8a34dbb533af0d3e18512e22142ee41d1bff18138540e667896b8772c30376bb43ec29c115ea49878a61e6f8cee39c319d0e34cad580539c4c9ac964dfa74b65e96833e6f223a9519c76378cd5e2a49c74257400833b11092be997ce1999264e13dee5d929723d9239646e82df71ebd5406a91f82bd4920217608dfc393c72fd7806cdc1d5879a48c94d8f9faa6cd13b46c74bc8d723c97005bba57b1d847a36fc8fbb11077b2f367c41825f0afce092921acee18c2c890bc3506514b11317440ecde7432e6feafc1b295f4a5108e540b82f826f6abaaa55f21eebaa493526dc3c43fae018421a57a4ff149de907ea0692af31e8ede7611f5c5e6f3cff16b6e180f2175e3c6e4a06e7aeb8826beb8e6d86afe70d9b9276991530b58316500739823a48554fd4a60aca2e94d14e362039e15a98f8510859dd83c295fe0f1097b5abcd53aa7bcd0da31608ddd6f692f4c122a3161b72a6e31f6530fd8ec7ab6ab101d4716a5ac7422d55e02bf96ae968a2ec678f54b4318f6f802d51e3d0e56536126217ee7e249a0e478953c3d796f3bf4eb232406ef684a3d79bcaa3045b5bb3bb716ffe2cd890485230f841a740e39b40cbbd0314142c71454ec200070721d901c31a740d27276148e4ef00da3afaaaddf151485501f66b7b50ac15c82d7312c7da5f41ee1081f20f179b2dded69236b4f5d6ec263fb43a86b4fb2e3d2a36135aa31f930b5cdcad1da2e79c7c82c788dd0270eb7f74cde3e9c08cf045f2a6f3b3fd9deb10c01c41a975349aea70f1bc09f5f8b67caa8681ea79d5f850135c6a81366bbf80188fcd3a540ac9da68b35fc43bb44104f877110b684a9a76328c284ce16d482d3dee97385aad7da88d39b6144fdc0281204d9252c17e70c2c2b10d9d1907c3d406b69e084aa83f0e51a26734ff96e9c3cb62f3d9b318ad6219860299686042e79db27d898284d32c07eb2c921edb8f5c846450769a3d7871ea8dd724ea8c0b47701ca8b3182e33c10fd773b83be1ded6098dc2031046ef79d98d28e77e3977bcdb0f26a64016527dcc1c5639e2c66a655caf11ec25cf6f5ba85c3386094179272a88a9712bfc76f2c097e00790a9732fba9b7d946928e001fb978963b1297f9f5b06fb00c55bbfda604c6bd52a04e70632155a2556496753af78046f2643f429da87fd2710e12c7b4c26529c37c864a1d5ebe21078b9aaf77faf9a542d1ea103e8fd99f06d238f8db52b7abe6a08fb231570363387336f1404e77e38f2d061a3a977751aafbe048a4edd3c9578fa0d4e31c7aa0d46b6ac4f56f55d67ba0daaed5815050a852884d5dc2cbe04d19446679d9f8a6d9f74b599a1d98428ff7d54546f96daa119b47e7edf45cb7637fcdcaee76e5d1d33557d6784d8db45bcfa413e2df0dfaa278c22b995b75961375fe801159d152aa07e9cb448818b2c5a91e3794aa258ea7b8641faf39dba41bbb9c2b3446d5e8fbc754abae3715e530a22337b812cf9ba63d15f3ca827f90aa12f61f9716cb0a95aad4b443e2386d46588bea5638abbb803ddfa2ef46597d36c37edfda5c1366d2f3d8319a88fa9c6fcfaba939fdd1f28d1b14d5918e49c550030b74322efa9429738b181647b0a814a6bb0108a458a6a3ccc5962eac5188b6b4b74eefcb979059efe1b99ad8d3524a48818d5e04ff3d952a5ae44ce19dba484b6f5adbedc15b50a383021facc6e4750ef57a24cc3bff528c010ecbda3bf0c39281afb02f62d0a14354607ab501ddfb1b27eafdbc5f5fa59fbe2837ab1c2a98743282fe709436b2cee6d7114b86856d3f11d7e0c399111778c1efa097d022bb57bc477108d513aa81cff337594a1e7a5809e9fa598e0bf8314457e8e74aa5209ee72ec2be762caedb844f0321c106c20b35f2e0b3a53ccf05a98ce24131cc7d9451ea4982e2557971aacc3916ff20830a0a3ff502e4a23e36104fc0295dfb379458adb97e23528bce84bfdd80168bee56040b2e24aef07f9019d6250a0b1e4660f5962cb8ab4ce3cd9110a514c3daa57ddd8f9ef0c8724cf06748b48366a6387bb5f907b55ed5c80ebe8c5517a65146063471ab53d55e9a26b1c1b2392ccf68d9ecc91d46ddb33f93a40745e799c832a46800ecf5e27e02127d930a948de5f445de42390fc1e27f5ecbc517112e155e8a1f4b00aada0a6e90ae4bb83626fba8b22836f41ed776d0b335e9bc347384297b4780cb86d17f0e101889cfe804649d2d59da2461417cf77783651bb29e2abb0643a87575e35c886afce76ac0c705e745b0fa61f5c2c0edd4895d9cfb9330d59d7d709e245edd2672c424a32fe5f26f51f9fa0a86f42c7f8250d7653684e7721f98be06ddb5067aa49d493b696b54bf429940092c36a31392aff154d63b1e8eb8a3341077f3599e02bc52bf1aaded0de9dbf313570f89e68b946cb0a79b311908fde50b2a58bdeabbf671b135a9454608de66cecb381da5db5bfc502c0414d1ffd47537f6e9a84bc9b41f78ede3112762db6a0400858bc1f11a76b05267d1782805aec93a788773bec5d95ab7931e8dae25084b31d4e51cd72298e5f15fa6b77ac4a064a0b4ec71346b46447acdaf45b6d630ebe7b991b46f2d0d11a0c0fc9dfae6a44b147ee1ee070b4a153101ea246cf614c8cdf2c055e72d7869a97e6f1da275e0d7f5cde20ef263bc4e4caf35c9def2b4c5c2223219e99d93cbdafa81b6ad6b873fb89cf56091d15f6e1bc833d3ff75afdf216722f56fd0d68d0c1f48fbce2ade445392d55314333b32bc3399642479fda5eed6d6bcc6f2fb2d4eb34f5b818edb378fac13b54975184564461975d236972010657d36db6fd256dda028c99b276aaecd78650ab9bfc0db1e7d56c1e8df0142c5e80e3250d75b8e6d6e10b9cd63b6fc85147e76ad6a4cfba5b40fb16e01e9b74c2d1b4d0dfeaafab611357f8e98586745d76d6e3c731c8dbdf7c3dd2f9e52c77296cc6533f58b9a960040b72dedbec568f2ca260bc0538ce7c173f135b50da9bf85cf02f447193fa9b9c9a9ca98f6c4b6979182be77bc2c7e123e51c19a6d9152bb5f32c078e10f35de9df3567527432643fe930a69035c96b1ceb63a33ef2db5931160dde75f39ee137128749dd6dd4ded38e0efc9f90b64904a614a7954acc7c13649d6f2420850720987f2ad4321f99797cec07ab75e98da6cfcbd7987383c96866f049cb7c593dfd2c3a3e6bd0a73d24304fb05ef8e84d8a3c8ad2ee635effeee70cfcac19b1f651c416f1430d8f12c9347dc908f59745f114bbd5cfa78a95df0600a7ab1d303b1be85625c3281295662a1faf71ce042793200c7ddc852a2a0c351abe294c4e9b9ef69de32000a49069e5edd174d6c9a76979bd72c8955ab1a233a7498e72e1697af04b136fb2be099d6ba6e25f3460a8607336e4a3377f9011e43fdeaec57d7b3aaeea3e455debe65c2f4129eb2ecb9b5d294a665c9b4b9ee90fd1f87cc18fb34c0041e865fc00caf514ac2f8b54a3ee3b8e5b73e1e15ba5efd3f36f6af040948e087bd18dac948f067353f5bcb00b7ad414162126fd3b058ce74ec1a3696b99dffed31e4d0818d5a91e76b915041b534d37e2acdb286b0a92dea2c03e0ef84a42b9cc2275194b019b9283a95fcf60bac48967925c7eb4d26996e46d5e9862b55899251c337c0d4d91c2c015d2f9b0dc5cff20a5ae1e8f272d40e69da58572528c7ebe5ec6962b1b433f944ccd197aaa8d40ac6f88409893f5630cc220073e232326d7c168b7bf128736934bbca217d120a8a6715e1848778721b14a9a7faf8588de9da759cbd343c9c071e2324f23fb4b3211e7364fc835d737e22b2dd8dda672222f186d4aa8dff223b840b1b75868c2116247fdf2575b8d4fa11d636df14dc96743f66cdf4f4758e76b3ae8c78817f9c259d409e12bffb11ee5f37c9fa3c276a18a5bcffc704bfb53e02c30b5eb398470e658bbbee9c3d76a208c02b42350131a717ed812c1efac3b54c281128d2521fc7173e69e99809f414eb56ea218c97d75b3bc565aa6263ccff41220edb0d6e5670069e1f7648c3c0f2c5bbc1f8add4ccb9b2ddabe49a3693a48f281e02bce3a4c39fc3b6021af685e8ea1bfd2e05f0611071a8da8ecb175c2073d56bb76fb7101f484e9859176b940cc1bfa6c81005410789657b5bcd80a1c38f58bd9da50cdb3393a92f6e850b86491cf4337429519453525d076cce6a7af0a2d50693ee7b82e7b8b00c86c525490989bf232ce182785f8693827130eabdb7b32d5ce7a843a85fb05a83dc1afaf64070e3165a9700469139c1b5a38a6828cc6c87f3aae83ac76f1409c393578b86a65ea0b297fc272bb02b6bfbdbc1daafd8432251d499d1d85b7aea19a53e23b579ff36a8f69ee80e263566798c92fe96117556d82a6a1544ab14c3d490b62b15e0885518d01ddd43d26cbed509d9bc1ef6b550da221c6e90bfa0d817f35ba551f6731baf4b0d134771df0c71b78734c1fba8081bfce118c87787ff7b0a6b54ab1c57cb4c60f6d594369bcab5e5ecbedc61c1e07c4604a2c2ebf7711336c7a2741e0434130dedfcd47305ab7b6c383bd97af76d8dae58eed8a0e496618b4ab83b765da455533bb1f45b308f5e81320582f4af06b546eb7a66ddd0514afb6d4d6f40fee111c9684b606a6077f70ef2cdae11625ca85bb01e679bc116086b43dd6e286a6d42eb03109899058c536b6abdf39cbe829447877deaab0c5c5d31e2f212b4ccb3a98d0162c498f1bed2c0f362da9f0bc649f9ed448f12d9a5ac5e8e3e678462d5fcd3ecfe17cfc34273e401d8b346cac7d8cfa9093786a6fc552ffe7a36903d8dbd2bb9e2f2cdd79b71044ad8746774fcc7329f918de35c06761efbb164cb9652170a1f227956f786b6a1aa5768190406a025b035da76315e64c51f83a2869e4f8e285598c7ccada47e2652c460a00d2f72e10d1e41fa0e18d09d2c2ba95909aae844b9cf10fdee27ae046750b263338c00611c4c8af3ad554d0718b2be2bc07328393082eac7d99791491dbfe22080ed3667730a2021ec4fc66b50256cc392a3fb77b9eaa467f285839c77a30deb44e3b987b9d2854c8d7cffd605b9656b36f669b7251c76a0d6c770b9a79b5a46d5053eb685e153689852ea6df1ccc5770b302c93f6f3676c83a79bfa2560f68c9f3b23a173a823fe5d977d3c25df595840ac997840050af2a0dd31cc928bccc9ae187f651ed5cdae5b3233eae34ff6a24b5e3029250ab2eaa287e22d519aab3769d4711a6c5518004d61924cd55c98fc3a8bdc4bbfa25063c94962d4a32257aff6a388c112ca1dd489a7887e6b2f54f39a944d47651b7594cd1ece987efb80cc53e21b86e56478ce4ac3982756b4b7ebbd53213444ce2edd18b951b95f2fece4a398e6a721c37f4832eb43d2e0d31a57b89931a9b1f7f8e303f3c63144d7d853eaa64bf1cec3c152658ef70970b24218a47924a2b9c938cbd6e1365bc27a37df9cceda21066740a0a68ef4ea4cb2222b6377e89a79719f17a1df642148f8353b9ea0771f2e9b6963ecb8e812a1e269aa93a35ecda2485cc3ffa2e9f5307bf619b2324c04e0a72239cbfcf2ace5c415d5f363de458691e1981428f149c131191e3c95b996eb47b6ce2f2e19f5ee478fbbd0ff7be9b4dd8cbb228e341f219f338c0f02b4c08b8b3c5ee7a64c1e6f682a7b85d211bba3418434b13b1d2a8ce23a26415cd07a5658c48ba0fbeaf18d78eb45f9c4e23fd91a7860f294dc24d3a7be167e463a534bc01fcb67c9da015155c2d9e4d4db92150e570cf5cf04842a2762d36af5bb24725b1689f161ee59a0ba917eabce4951baf4130c17a1868fd2ad5f303c4a5416df790813b7e680dcffb789c5f16d527cec152c07bd7f07e5ae097add7286cd07b2575ef644369d850d041e999d1d9d8025770cf843d5839a407de5a8536e75073bc5a521defbde51427380769b3753d6fef071993ae39bb62777af52308a78ebf88e1040f7831abc4806f9849e8398a1a246f5db5fe941182866d6186b4b3c6f206df3cc02c89993c9e553f12bc70d4bec5b2762d0d907dee2b31dbd982b0ba7d835f6cd8bcad9eaa00faf717e57ee9f5c220121c030cd27c4d090ad07fdf9a22ad0ca4cf69233afa16255bcb6435ffbd1dfdc680a4ae6ceeb91ac56412a2c7a8f779cecbb19ef7c13858e94c571a6c4d956c3f0bcd0aefaa6752a2ebee910585d025ce7222f3c518f8c8014f5ffa2c2b07985458f2c0c5d8c93e35d1ee2142ec76061758a0c59862a1c006a7387cedaadebf43e70c551c71413130ac7cbe4b72b9e68e7939df8a6133fe4994d4ec139f9e44748d52708c003782e5393303ce2391cc2c42dc587534aca2ca6b2d598047aa7958a0469cc10334bf49fd06d287852f3ef90e442d7eb559a9a57cca1f8fc976c394cdcae6d8b40bffac4a099dbf9a041588c0c12d0f7d83aa8663649eb6461a48ea2eda803b2dd390fae9f4d4d36fb15f0dab48c43c6f12a21affd4eeab06cb9a479a4e165cd0994569628bf63723673747e048d226acce827552bbc3fc5710a4a95bcc5aa796339462780b1aaa3e5f8e5e34577099bf5eed5ea6bede3a5a17f53ab967cb36c526e90d1c32b8c92b773adec216d6d8efe797b25ce60901431cf0407af76b38481d986f1b6f19323a03030fa5439c9a35ab2c24c5e6987399cd1beeb0bea72f864a14db6c19dcc76f27f4d16dc430745bcd8b9f74e7535b085c793881c244172008972914faa57f5e445c04721ce6bcfa05c0ba3dbe1d408dd081325cfbe410be57155319ece1ad55654f1d38176516f07a87f20d5c54bcccb857c26b1216b8795f46b929750547f4c92fd839fe05acc4cfb7013f5098879a1021ec6f31c2b5bdeab3f1eb6950205681b83f8adc3eae8d9cb702cc3a4626a4c16b72b1b5584fa666f8ad38a14b5d2ca9ba5252d9b5217eab6255f09fe945d43138de25517b12815db704bae3ede3803df35b704f7f6d48332355696ec22e68e0736e82d38559deeeaf59b2b5f663ba4a54dfeb3ccabbb77f3470f74f9ed57a1c32e6c28a5773bc8f316ccafdc2d8935c08e08fc999f84dca1ed25c7b726711c40078ceea52f63c81911e4bb603868cdfeb4181606a3fa420eef5fbcaf2d2315028c3d78105d00db3f0bf1aabfc19958db4baf7d89ce5aa0cc6177d22c0524b5280954a5fa4e442b6ce3a4e3bfbd0aed109e3c2886655053c1cbac8c49f5f2fa44e5bec868d335aaef900aec073a93f6a2817c366358043a1b0a2aca5fc48271075c92134e2a0f334dba55813a90d5695c76e92ab6f7d697b382e6b5f424f77d69d8a40524905452cd4e254c9b2b12acf63408813634228d834c55fa34e3de88028352211443477fb89f2486c52eb213838c5a7ef51fb3e67b837d932dd04a391a85c8f2241b19c5638de568fc3f94d040e933335a014b9c05743a42861aba5a1b338ff8aaf69941ea2375558d9383056106b1ba55a22350f886eea00db16dbcc620d255c7246d281648a4a883704acdc94d6e347b98ec86d843382f236bce3989b5c6696026a15af83fb1e2bfdc77f4c75493c0540dbda6adfb87b9f1b5876ade90407c6ee412199df85f55c901202c6093e81d7a1622a2566db3e956a9e9bb776e492556e723d4e11f3b3157c8ea2514f309ae026dd824730828cc97e0d8318550a50ff4759ee8acbde4ef5168590daefcca82dbe809f4efcbb6fe4c1cb4190875d6ca7a1c14188079119a610161b3c4340ee80bf43f75fbb5628398b8a4a5747acfd799dce4804a3f86a904b75a3a40dbb394e2898d76078ba8bfcf67a81cbc79c0ec993369ff35b6eba57f004109b7dec8358f03ea915dd93c078dc9b18d0971f1f9961350d972dec040600a9ac20e3f803357be6a114d50b40ddb02467005e7d4cec039e809986038dcebf022b2d37663df76aaec970f3f658b0e171a4d982d53c853e4eaa338ddfd5e4ac563b7cd64c4f29f4d6e280a0bc29f0b31e8a22e5fe5397e4c79193dd06053aef82be14d88e97df11b73ac885b94c149275360a365a99d30f8d38e3c396cdc3599b3ca5cf08a3fc25e47482461fd54d5f2ce53b6ced258f84ae80973b7561eb53974b8984b0d83fa9ec906e6fc5a77e6fef28d12b0384d54ccaeb21abe694c77482f316261b39bc3dc31d561d4a3e7bd635fb29675025527083b81fad3ceefd0927b7207cfec5207993b7e2e54152ab3d71df8114152bf6cb62fcfab335a9e1783f4697201ba350176a7d1250bc8afada19c71837f63283324215a22bc0bbe4ff42e68305755b6098ea9f617e499533cc7cc367ea038fa1c73464ecfac86131afdf96e2757b810219deae21fa691c5f9590b08f8d4d007bdc62c093289376bd3598f322fb99d124e9e112a13dc7152c3130e978ffc60091c90444c07ccdd5d4055aa175c16afbcaa43d2d257410997207be041ce17ed08ff58561432fe9c07234595583bcd6312454098171e2ed5fa78e2a4995aecf5da068db28efc13087a0d1e05816eaa6e6d62883101625de756917a9424f38e9d75e2bd2e465fdd626f96fc859f147fc27f782af59615c3b9e8d0eca70ea9801af478de1ad4e894a72c4795baf35b286c79a01efdb59b8462e0afce9c3b646f74cc349d11240335f66423e419b8828f97b67fea07aca5f077f85d3b2b05c139f12722d1f5888e04ec91720495c4779b8d56e8e3ada02d3d3dc1ef7d4ad2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
