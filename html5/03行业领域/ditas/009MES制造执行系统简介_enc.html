<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"14e0c81ee13b9d684b89fd5527ca87a84b4677253723d51f77e759120b9ddf83fdf767f2cba8cf3d3678a5565daaa3b5bb97964ad2298bbcb18de6d0e2cf020a1d24439454925ff7f94881bd92b3632f9f3eae037d87c746aac90a6e821d098e9233f59ac77ef80a675a04a33e7ea24c8bfcb14b13b9b906d5e53ab7a0b906af2c157d43c3c25d22005767c0b9bc7fd44f9e6059165ec3bba13ea164d6fd1fc9bef098cdee2ae576942791390c976c834e963b59f1325779683b771ac7c224d8b66a2740a05c56bd59ad7913f0dfefd00571d28816b9baf69f032c078f9e97454491a9ed0ab866ad79997180dac522c9b2a2397783d4497d508655ecc50298f3807bb7578ba7978cdb8b029ff13b809684a34f5390bd53297fb42aef9e3e985b4f44c217e4d301fcefdf2de3c09b23a57ace53112b8268aa472d0578aed6b00a69a37860238773bee2e32df5fb1fa21704d858f5187d054491b7b0fa5afa1b82aaa65647cd7abc0f72030e2d1645c437f02c2579184eb379bc598dabf7337f5084d6ac72b834c3b940cd0cbabf9875d8faa409fefff1c29cf8d080a21e943d3c4ca350b8a711fbe2918d1fa88c6b112e3b846b353a2ff91118a1fc4ec5c970e34b45618fec73d77e958f759d9d2b4816dcf4e94dd384d88e4e23634a66077a18ae2277af345cc9d10d41510d97d3ec2fb7af26ac6a45fec0a951732fc3ad9dec6ab6d86ab5195dbebe55f919483482649f3b2dc3b089041325048023204508fbf60ca16fb2df5613f900bf258f3b57d06e45b3663064729d754c9ce32ee9834ba5abac5552600b45cfb5db68f6325d6f4d3c5f948c9ab8e817bdeca95ca876ee64e342caf1acb133fc545b474f8893fd7f770d8a6dec35a5cf24c8193a04f4b3d0bf712ed28bf62aa8f92d9ca176372e8a6c6a20419fbd593ae277332a137565d57d7445c6a231e886f640bdee6300410f04a31cac748910d05b4fcc23351eb64fe1d260f93126ab712d1ca70f7276d32cd3944dc738feb735faac6e5bd61ef8e6250a58ec59f86b4137944a5db95da9aa707000491e9251faac5823c73e0a58448f2b71e9e8c4bf411d732c29103df2f73f003d33a0998c850009dc2e895bf92521ff0a284b9b1b758fd9975ca356fde2a3311cf8bc4ee636ba8f65914b6eac0ec50ef7f4d17354d3342659927c12185ee4d9ce2ad9f7270096e824e7db74c3affbb5cc11e82cfe20b0cfffca7a56dc553ed83b9f8a750f2cd7081dbf32733c76a191d9093aace2c7b7db2726e6e30409f7bc2842f700a67b4175dee5a9116edc6208b77d5d49d8470fb09aa2fbe430ad38799bfb7c4c92003ac492cf019696166880d16419ab2f9438969d52e87ab3c33bf9a40993e39e28764676b68b8eea67759bed30aece8b927e78d7d68be47deae77aac82bb33bbeeaaa3cdca0f341646afd5dfa0d0462cd64f8b60389eb2ed2f0bf5e61ba195ef06a1a9ade730c932884292b480eac834c2ec530905d3cce58b7a50b7e046c4d97d829e23f5fcf48a7d154bca646a2d10bd170bfb72c8e0204c9883b4a17eb2a03c7aa0e81c8608a2a4c237bee758a450f30cdd3ddee08e8de68e87afaa81c2ab3960de5705907526aa43e98c4014f5802b8d74ef00b7b6aea4067fef0781375df9373eca3162ddfb4fdc3d252ef87658c05e2923592eaa999e625fd3ba42c8d817b50f525f49438ca6dc9c87478c34b20371f0975b216cdd029302f754b34f576ee603cef4e982c56482de6c1e77cf26950c0a280b6de9e6d6e8fac13990bde59ba9904b7e5862c0cb478b84306a201ed86a01e17649db94c3b1cf112b733b0af61360a3d9f84a9c284ccb06205c932662cc4c5fded5b1531abc28bb88cd3f8d2708db77b3f4cfde8bba0c34bfb3cef4e3071c5730d4f05d2ca9cc0f63db8136f5912b0f489d93047b5e84254203d661512b65b5e8ef79066f2b47f455b9115d8593d82a412f8424f1261527d44e08af29b50042a5605613f73e110d98981ce1b70bfe0d1d7f38fc18ddc1827c6ae6782d62602f8b92ba1f139ee94c4bab72cfe5ff49c6127001adcca1768ec59c0b1288f2f57efbb4b4412886485e11db2bb55c810122ad1d21632e2d4d1ca79aab263fe5ddda2abd8aafce631b37d3a3952507bffa8096766047c60dd1a175f70e08e4cf09aed6f17e77b882ff603988dc5cfeb7ae57523cc80ba5653847cd19eeea6f7c207fdaef37b3f355ae141c5dffdf73606d721501949775ead413596538388774509e982057f2835a401b2ef5cef7e162cb6e254cf674688151b529f0e2e30d1f49f8f3b59772156376ae08e68e0ff66d91ddae8e4c8d6f17157da5f2aebfa9a1f0fdfe0cc1081c517647bd8421377760064395fd27f88fd5f080d41e4bbfd93beda489618f84644e6bbcfee1a04381b213a36a56bd910a32088ed1915fb2cfcb2035c984dc590a810b76ac55979c65b2026367db7abe4bf880c3d3183175cea97878b0a785dc77792b2a9ed8f01de43abb433d11e42de44716b7dd402137d52c74d7c868bc13ef9965c1d1ad7b20a53ce145d22ab68d00b0d733b8d83f830c05d43af2775ff5ecf89d0b9bece2e84f8a8c1bf95d092ca587de17a7c5331261ab21988e30f70a093d53051a8f86bbee4980c7bf15cde30642b0ad0164e0853542351941734d821e8cbd7fa045323060b5685f0bbd3117a514f91148e648f7cef0e9443fdc5d412c8ac472571d53975c117699cc4a4561919d3d32db6d4d876e854539815c6534f36ee7e3b094efb9e9d19972aff7ae3bef0adc5c6e99c50b07d9613eb5aaa2ba153b4d72275d6cfa600c1060b2c8fd64690b3b497372a97463e3f1b5e3791a036185d5f00cd4a21447522db42e812cbabc64d8200267a457304926edf27fe6a9f7cbd36323017157519d6ac30282eafee670d4b3556c712420fe0a12e4a960980cd05f41e72b19cbaa80952beeb46e91894dfe915a15a0758c4288753f7f2867c2aebf60c0d66a4a32672109901b1b3060dbfac170b0cd8649e6559211cbfc3a69deb7e27c5e71fee56ba0a0b0b750fff047745b1d78390a99598a798ed23c6537c59a9da341de474950b0c08d73cb5474f58748c7ab02cf7b0647f8b7c7b4eae4eb8b427af7f18fb59e5da335190a1452dc913fcf1527f1f3d27c6b631a6c1f0201d4ff27f102374b3fdcee5d1103132eb770306ff96ea3ee97b43ee14f252016916ae9c0dc9bf5913aa6c12749c5ccc9cda5707f2708baf2ecbffbdbcb940d8b507920102d32a6736c57a5686a7c5e27886c8a3a2cce476eb72ae80ab187edd939bf769b16e7d0a7b6e97593fb0a5c3d2eafb3ee112cc7cac92c2ce5f72734ed3b41ebf619b5c037ee550963475033e6de9c8ed0c13bb4191cb572c2e0f3a7896ee689a5645dd5cc6d93bbe3bdc03368c74c84ea619d79206d91dad798c09e9db530d39593b94ceac81c55c4a60ac32f6f990214cb73324d607bd4e464f2946001e6fc3d60af56496162b830a5f7124dbe2439f9e534faecbf5c7a4a85c340ff261ba3a63a6752363167fb2aa690e5956e54b64581a864c32de2cbde947457789240136d70d2e5d62c1a40eb0ba53db2871c07fa28f0c55bca7310ad232ddd5e837da90787cfaff604f49a64a4ff1e96f5c138438cc6325831b354049e924d2d1d87a08d3a0d796fe6470cde6c80cb814c671f9f5329436995ed32b518ced5a7cdcebaa9676fa7b5bd1591ad56e8491b2f30a075c37322fd22d61e933507dae1fde6e1a40ab23b9ef13e064120ef06aad9b4c901c85919e7bd647666b3ecf2e54e84717251d83a9116914d5301f102c47b593711f7e5f8677284c280a84819e05fb843a530ed3fd163eed82d54d99cf50dd0b8809f2f0ecd7f6ee26b88056e8b1aeb2811b25713f69c0d93089c4b342c7ac8b74ee0628c73bdb2ece1bdcc61d76244abeb39ee524cb3ed601c4b781a27ebb5383b532400cca7bf433f51adf7aa2e9098b8a36ea8fc7822534f26e8bb6f0cbc002d541ef8c2ef0390c0437727047034ddbe729ea7af4b8f680ed7e32ad455bfe57395507741260b457dc04ecdf020e89154d6122f7239df0d34730a381c74694e6a5a59e2f759c12230e8d005dc6ffcf95d56235efcac86e155633242298a51f22f083534b13d7f2d3f965589e7deedfd2489c443d5c36aea1a5a7d488e0cfa40f632e1c60657e79773a649972b006116e903a5ffde5af7b37a114258738d75348b24f87890aa5632643662fd7520fd34b2f7524ea42d6d614b30ca6d38cad5d7bfdcab643d5dfb69814f079a61fe8cc7b1e6bda6595754d01320c584c26ada2016fa1f16674151d78cb7778192020212c3600d5764e2ef9682bc5e4740e6e1688bd9425f67585ee5ea37a3c5a038c2488a55d5627c42267402182598132b831f8b6d26f202cd6136288b762690e698d62219017038c6bfe0f24cc392d603842d2c665d8254f2e7709282ee4d9606560f0ad2e364aec87ea26c114f0ae0a471b96152bde91fba10874c72f715e3e62106ed3c580dd43f40c9a58f92213c18795a5e92ad5942129284bc0895e571f5b6d9da8d5bcfbcdc254ccf84007853a514da327d3fdab70a8caaf48f386e029dade0f9c65f5f464f5a5752b3a991f932c85765d9690e55260ed1f5e615b08135540f4e948edb20cf33cc5465c8d00f6475e055f0f2a06a22ff5c67087fe4eadbe70e135a47ba72b752cfa89f8309a6876d0528e6e684e5771fff4407f3a4b6807b6701dbb6f5b478010b32768a2f43314ca61aafebd05feb0e916c240b5fe6a03313d0fa7a735bf0c12d04f4c0a6b7accce62ebdb3b761e32ebaa8160dde3d9b05404048577499f3a2b897271092073298b3017680677d2148c3faf70e5baebca201fc0f16d8fe31f42a62bae99c4e27c43931cc05518360230c408f8c89ed591491e66ec65a9c350e36088368e90ebf537bad7e3d13b872bd19c81ea97d2c79074f126138f3b22d7eaf15623f578bbafeeccc53ca07469f2925622b130277940cac626f31111b43f1564c60a81c9d38970101d59ec02b2365f355a15a511d453401437d813649705ae77650b8fa2848d0c5c94ae8a94af1249f0cf94a5d04a3848391a7331bb3f76109cc8293f3cb4445dad4187ac2e530c714c446e221d892df3ccc3d36954cc395eef01432c167e15b64b521bbb1a37909f7d275ea30f692c49a052257dcae84f444952bf6f1a4b6d7cf93a4537e17f1afe8a99d766fc8b637eb662d50a03dfe215f9e7d3a10e9d32e45aa9a4723f971d3be51146bd63d2ea96f593bc03adb25ff6e771ef0b5795c2ed4938f5b3bbeb709d1127b53e96e64fadfce868a337ca207ef03407b4a1fc7a62da38ec9f6c94273e310ce177b5998c1bbcf3e2bb1f031692b0137e3abe9b35a94e2fc1c3a161858e540908396a003754a2eab5f4836c20156b89971de3959e5cafd7b25f4283065a624e3ea77e68b5257c712dc4e4aeb3d7e6be5799b5b4e4c4a402eaf846b4a6dc75df4233c2f1e69322819c699a888dedf692ddc867311728af85be073a2bdecc767698d7db8d78546f7543da1f5521fd5a5ab09d0ccc3b09828ef1c50870be96ff7cf9e734546ead21591f4b172e988ca1788bef16122832c8afb331dc7ceb1791724f009f3be3cad9b07898174975c43858b21c66904ea7d1cbc89ad01e9b1dc7c68c2e16cc5b853ebd18a24803d651186b3b8fa55c72820221752752f110e3cfc3bbc0020e216845e2bd7ad0aaedf8102b9b4949fea859dccddcdad9a434b35ee62653f8592c79b70202c5eb6718d2feb00cbe0c60a06846e76c93bab569fc149bc825924f2e30ed139d9093608b7629f22902a0ac25dbed6d9795cd40aff59b80894511518a4aa39a91a00c3a0b1d24a43561c9edcd469e58dd943479e7cf881440b35f79cfb32fd01441c66c4ba933e91579975fafa4e7a22bbffccbcdd8dee4b63f73251ff6e32898bf2195a97f87ae83b5a04bd11404146ec99457e6bb1eea981123b600e25a2b05059aa718d0dd5717e4bd0bd50c55389d9cebc916d1739bb4f6407974c72f89205a92b4305ff7742843e3ad4325a181025a922494f2fbc24925585f91c57b018014dd5de831aab5750db26cecaa4c5abd87a509263d0f5b030f717d728716c27ad1e497584bbf1caca3b6d93827eea2065d4abe10b521cc8df9b346983099526fb07e854fe49cb5b835c282c6a08331068745502cf10d59553ca9c36671ea3f80bf71663c17ac1f7ecfbf6908502cfc522feadcacc170caea986cec55160054c7b96e88bc22aadae5a16134c2dadb18a1d85e0e83979cd1f62e192f43606e0e3e6b1620542a1f1b8a4a484d2fdce601d77f5147e9dbc854452aab28f6c5a5d7a0ff574e436914e88a31b8c75dda9b368bf9fe14ab9755e18dcec6dbfbe3368f0f66d79b466bd29f48d75fbb4c5f63cb4647fd0006b7281613ca535f51bfd5151cbdecd47a8f3ba944f4739d7b7f987c28136f278411bd0f122b2a8e1d5910794f4cb2c88d04edfe256b6f9823ae49c6ba4803b45cda1dd262fd3086c87d8ce5875c01f7ce4cc721cfb316b3e259ade90db2a186ca7b69bf05e96ee9d3630d27309a5780a237807c476b25702f0d64434752a04f90b0a2bdae33c53be7e1020f352696f7b3410da43d46366cce1c6485f00ee713d772c55720200f647b5b7e2e94fb5ed6cf9e4fb22400d6d2c0628181fd7f08a346bac1d02d5c6519036c5fb871b2b8f1cb5130de7559c678d13294009129f604b1729d9ddcbeaf097935d554dadbb2378b30079b4fb38022d162dcf3104bd2accbbba398e5ef3ca00da8cc830c85274f835fbcf59c8fad69659520cfc8e8e0e5d2c61f07afd4203d7be89a64705f7f96a2fa854b6d237fd28d82df0cda3321d79d29174d724413f45c5e52a3b99ba1450586cf7c4448a5f1ce544075a21abe1b41b574040bd4102a979016b80c2e3d5be194fea2966e8da85d9c9c61c597c021535eda9dc19cf66a7fa3da3bf09d813fac8d12d58e6265385fc978439f23c8aaf5a223419e848c3ebb346402360d33f0aa0fd97ceba2640fecbb23c93bcbec06393a6f3d3c59c9363eb38df8d87abd7930a4e4d4dec8daf7c6a718ec08281c51f094abad4e0b74d116abf184c6d3f1f30c8660dd19e93c5c997ad9c7ac66650885623371b51819308f13c520806cae88d07f94a51e1d9acf5e5a014e7e95610803e5950ba73915150862e05c83770af07d9d176e0314757d91364285feda4d27b5bdfd3468f892049771f512767de7a6af08a2962f538316074704dff57940366ed18aee50e2c7928207899538c2ae69c51f35037f983a4c2e11de9d83c5bbe5861bf4795eb0c555136844364cab4b63a63b83711797bc90a25cee525e4d28c471f68be8dff5d59bc4a72dee4fa2f35ac31e7b39ac65642c8dbb5a89331b00e814ee60e2beccf8c9bad657b31f8e33016d76ae4736fd06802a29e730c4933f647c7490e385255a1def884478c2ae3dc3eb03d975c5f9844afb38947bdea36f7bbffee47d6d4f597dcbbaf85b661562a9a8d040590cd31382e5940262b85052cf83140a648f42f9cfa24ed47dcefa77062a3b71efcbc37d31091b1b921307d56f8dc3e848ace5375e1ffacca09098cf178baedf4c27f56a97a2809abb0ad3a6bdc63447292b85953ad89b567b2bc348decac8af05c45e303091da804d87f238a3735edf0e5e182a948d4dbdace4dab7ae896aab4106b9410b184a14e5830dc9bccb4c43953523663f6300a5518cdcacc1d187abd4efac572ee6197dac1633b80e511b7c1f375f6321c3b2464ef49d8fb684edf42e674b92cbf1c6ea8d9001a98bffd3ab691adc17190dd60c46c323006398487238e77dc13eec2abd8222c3123da3c3a4c202ba59b5c69e54bd2964cb344590ed25fa435bccf593e09647e5c5075fec2e422578c21dce00db203542d0299027b6b26d490c3f4391a27888086a38f429cb6d1e5cc6695d059de8b8d0ddcfc33d6961229274ce0ced6c9494a971a60b8b28f67e2c15e89c2da8e4684f48357351dd3cd3d6843638b53eb62d52b29b298499dea9048e473ca14e625754e7b4562bae2b7684edcab11d2ec13de2d67d6d23dbf09b29ad1b6ef11bb25e4219e5e15aaea7834177b8535b01d4600fd676ee1f590f8aa0899532b973746d63845506dd9be34e2daf22e1bd25b78a913016219ccc21e10b153734d151e845be1b7c1482ef424ce052aa373ec5bb5082e0ade45a5eb013a264af722373023c88e5f85a8161c50d528c0df3e4102cf320889f78ee49b0fbf3159396a2abd1cb4d4e941ba5ceea3f87c17be3f2098b5da9c32abe13a8cc435c8de2bee9f75b49db09e5cd6fb70025bd6fe9e1ad18f0ff96cd0e3e71ec657d50bfbdce5e4b0bc52f78c47c94b22e70e8efa369906c718d554cd9c6bfa56a60663444a35e25a0c6da03fb6e581008ac2def66dbb43e05ea5cfe4a24464c027d47325be730c77a7751173e71eeecced9972a6835b30ebc34af2f9e04ff587069d8fa97083262be31e84d39dbd76fc7df790181865064ffe4971aa4c98bd46a13e101cdbe95e17d9001d6c011ecc89716588710283c987b8a010382b851e140b05e8ff01df43bbd429aadaca519ed037325b54665d3add96204766111b59559b3fff97bcc97e1ed06d79b789673ac0a5399c67bf032e7c82e700a68bb5e48aa48a90d4a9c72f34283ae5de7d48a272c309d24ede3d6df5fca9bcb1b623dd652f86f47727b92f9f7490a09797a81545ad2b61e18bd8973647f6cee0910423122ccb51da48701310e39ed47a088c6f29d17cb107e7cd0af191317ed9c0c36a868503795657457f7d6e76d3e345180685d4f8b72d44ad4a1787dfd58d89d14c2170739d4eade674c441d7b9a8d9cb27e64126d96f8413e015cef5fb7c106b46457d20dc138c7632c415faf2fab50d1df3c4ee5c4fe5de30584ce2106e09c8372a1456fac9c81c9cb09c27929297124ff7fafbbf20a4bae6008b943e9f2b0201f302818bc92e7cfb58d5671645a8fcee70e0b8c58e9afd1c60b05f13f82ddc2a203584b1e0ca88e72c03d2732c497cb3d006c11a0e78d9d1e2d9a5b84f39c252a937f841f12d032ba44da7ea8f2cabb21287b9943d3968026c15eed412e0170350afd9fcb45c4eb632271e51b48d184fc45825cab9773014d6c069815825ee6a29e7a2d35268be368b258704365bd9197e5155a9a2e87c7ffa18e74e10eb4bcfa24395071478c10a2b02ebedc72c504734a16d46c02319df092e76f6c1efad9cc673ed48607b0c14112f2a19ff529cd12c928048f9c363cb3414c2dd477f79e34e085a3b627f1c360881eb527f129f4e6641098da5690c5c531df3768253f134e1e6e2d16f841f904158511290b4794c216ebe6ba34ad85854a623949ab389a2244fd3a5d3f68e76090086855891f9483ca749707f297b479120237a9669f07c5438729da8ad88fd051101c3438aa8ed4d6f24e08bd2aa8cdfdfe5607ba37d502c0124f27b5ff83ffa6e096a2fb59b14d196713957699dfb1e27d2d5f017e64b2ea3a7f429a9aae8e6c06665007d096787cd677f441726fb25cc30e4124e2cb9769863b8d5dc8db9cc475059a2d40522728ef55afd1e4496f15a93ba5aa9377abc02f6d18e7bbc05601fa96d3cf42b86a700727022d44f729c5dc9d06d2d7044fafbb11c216ed5184b608245f399ee2dd52b449cc3288702a72b8a9fafb2e6115ead01f2da053bee8234dfbf45fd01d502c95fcf6010573101fd51f9537298b86cc3de692d3b511d00a996a5fecafa2b37fc2392e38978da5b2c1c8aff6a44e7c5e043c9427393b926f747f19514e28bc165b7a218fddc35de9584f8ea196becd64814951f5a107f5cfa14e258bdf437ea078ac2a7b7d927582c5cf637bae27463c413da31590d0e2bb53a659d5b331acfbf1434f3ead3f6c3361c6e1322bfe35775bbc22eb28fe9b26e509298cff8c5c9b1259db815021d67d28869584740da80da3f57e6dcf7ab7769dcdce162b0ba8a366472a99860debe663c5bc4626b3e30f27bf92af9734d872e0115de4f4f09073afcf818b98d77a68b6c6cee0d3ebf103eed89256e4f13025dd63baee5fb7f16faf475ded9fe9cd8fdc87dde208ac729aa0b3ee627a04ef29499da3e42458f41c1869013b0ec2229056c668f9ac8fefacf26f8739e66dea61a5fa82ebcafba0a6ca174527de75cd82a5629f5b4819fe5712f8a6bffeaff1fbd7c4fa462f0424328ab345bf7d7ce7c7ec7812aa2b67a65f9eb67703615f7b6118055d89f4824b0dc9ced137b2e38484f80ec357ea6b30593f93ba167f501f09e146844cb5865170f991499b9e33997413308209a3ded2c6b4ab931299c46c8b0e8cbe3518ca22097914cc23a0051606f52b42b1b77280c5c9e2c0b74301921957cad115cfcee1facc03b35ec6db3cdf724e16809afea6fbd1d6d5ba09f8bb179bdc6b4a340c310b8db93cc192592f7178985c39ed139f07857a1328dbb6ca9ef8bc4d3432f5dfad1f7fc718ea768026277bc4fbe68eaa4b8eb6d1fc5fefb7eba661d41ce196a828603130bac58740115591dbff75a53fb123be83dd3e5d9ff410286b1f67c9f2580ff82d362a4ec2bf1ecf28690c55ba2abea16326c8b017b481629d7a5b9519206561e740dac99cdf21c7ae89dc399f23ce83383aa07dd05f8794aa6402f0bb9cb850619b8eaca54592b49811aeabbef79776836d040be0a590bab6bcbf0ffa9dfe29bd195feb92b78e6ba20fb7f701defbad4fc62fb5c5a09cfcd08a369df2dea49945c6c8518b778c2f003f52d3fbcb638dd0b88ee4ca2feaf709275627d43b7128a2b506cb85836d40388621b20653e0a189b82637e39464ee6a8ab76e2b84a0cf49955efbc369582a2dc4f78b990c7bf1d346b985396aea70b27ad9662b076fb20591a977a6fe84b29ee0165815426ff7fe48328d11c304ebc1c13dfaf78d23ee441af6f2bd026c2e425b5af2eca35d03a72f095a87ff9a8c67607cc4b2eab7d1bd4b642f8397a947bfa64ba363b8949112722c80df30db072910c3407c6adf2871adb52cc6a3bda9c718a9799304b537eb3f931607e9c4892b77d95d1962765069d7bbd77ac1184b40c245eb1388b39c77da634054ee479d15a0cdb04861c5d0cee6926bce24927bfd145a7181bcb4c592876b3a9fe6e3ca0336f07b33f5286573c76bfd1ad33cfcd27a80271f859b38b262041dd07d8674b6826066e65222edf9204477f3f3eddf0640eb942cd8458f1171643acc363a7055377b090f2e51c0c4f88bf577677e676c36f42c14c7d5571f649355716b489855a928622cb86eab46269637745180bd419ed2428b2a179ac55af129de811864b8701a1089444e2d67f5aed9cf83c1d9616f18b45eaaf5112d79fe6f39f5c98e1dbdf1c6e4783d3da68a5c5e4d0a48313c81673a6ec0cb7bdce75495ee7fca37cb7cf05bedf4cc28b22c8cc28111d0a311dac8e7f4d2f920f3ee40c9ac0cbbcbbefee2f5b8746c42bbd8b60a353b290cc414beba76f4eba993464277fa4d7923121497803d3a7efc3ad4f0e72d71bd8631ff6009e16d317c3c977a6c168420c2b8e94d7f258079b164e986b91f9feb57b5941efae63cef05085e1c4138867fe9062c010915e1133c1b6eb595090524c3fb1edae6f5aacd44db9b097a1606e6c8b240250b0dd502c6e26756f4d6ec6465ddf107c2ab1bc5a856583aa3d8fac9fc13a498f7f69676a9c788d84d0fd7b558c93c3a6d9f50fd2526fd8a5b93c9fdd4bc6265b5713e98b2e05dd3dd3f578716a8dff126607814c62191c9e6ca3f106db5625406f8b5cf95f19e5ea09fd9787752f78766d6abbea90aec4cf752e79c007d78a40f83b050418ad3059c438a3d4a36fb8a60933e65a45aab4f1d8a37ef7f601343ef7360ce1f3b0d5fff283679077046b3f9de09053ba0aaad0e1eae1703a15ac79eebd6c9bc14e2b961ed3ded5f99891a2ef5bc3b906a12f148394a771c8472443ad8eca830fed8cacaac53a55069565c8a20297499e0f15382e18b115e31ee4773727e4804b31beb88625d624de782c14c592e97b4500071f1f3f9ff14d24989c72752dfb40ee2cf4b311c7c5825fd1352e2cf34adbe3f6556438501398ba6a3f7caad2da57eb43a54a7a8106160de10ea2783ad8e2cefce1c55ec07e5f3a733247262a18814f75a91d5222165e700d6c60b3e001b8840282140cb55764b573ff059f33dd181ba28e2ac3eac7cc1620a327cb1ee575d474b94b76ab63817b770f9846317c4ad5ea2c67c5ed5250b0e9182d8f472826be2066f41b980b3ff87f4bdab1d7f7cadc3df1db15ebe2933fe1304bfd008b767f0d9023103e3e45eba06b9d7b52d209a34bfa71d0b8ed3ae3c7883c761bbfcea6f653eea334c720a4670d27d25615e58b11979779fb0a001aa458784336c6ba20f678a4426f6fcb0d61bffabb540b6adb1decda633d0ff97c5901a7eb8b779a567baf8ca50f516363ac0a6645e8b06a017a817ae33cb6f6a25e3c1db405176b360a45903030fd22181fd19bbce0cf2fdd843e4af29461ea7c9dec3666cecd4440f5ad6f16edec6da2a556b6026308a667236160235a75cfa1dd1789f19c6fb9eb0312227c956e99b8d16bdf6e94be61c3d2c19c6e4015ea5298ca7e1f0ac1b0049f804d908e2d2852f65613b02094a6ab0925bbc4a6e7183d6c8af1dced66ba223bf2b9d6b242d4b4fc0a02de3b503aab82e65d3707e466d2303781380a95b32256adad69479b8ed26463071fd813de2b3ebb73a2df815ad1b60d733eaee94a21d20ca0cbd524f2ea7278be537bb62c730b50ca5274b4401dffc0bb4597d888333e65852137a177e0ab115c60f633b5eafbe32d53596ef950a1ae290e18565df23de6379bb6f8be83a19fb53ba6f82f230072aa8d757a7f3a89fb1f623e95c15994ec42d74178251aa2315f014f3daec686afb8e23c0786f661599f1c8fd2055130661e3bb2d7ca9627574901f3da11e985896d7ac28e2037b06fff4973b6c5dc7858ee16479d0e2ecb84e41b0d3ac467c4ef5010178f82a41fe528649d75f882ddf91c620f8d85233854d993543b5179cc7067a9bcba1d31b400b27021d1afbb4cdc5febee86d17454f671ee2069fa9455f882f5491725941f6288896e3f2467a4e7c4bd619e19b51f9ff761db6f0675c37dbcbd75854f36dfe879a3a679cdb5df6fef6cce71bfb03edd9179241429082016dfecfad5b3c91758dc76f739a54fe3b6458c61bb8acc2f82a0248d37f2fd0614b580a8c732eafad404ec22d5f3d3b44d5a169fd8c8127e5489e4a2b78e8277f32a309554e899e92bb4d728ff0130df2da011ee332f9a85d773f9fc234bcfc88c3c305e1026f953e5cc128fac8d20fec7fe92f9101298da9730ba56ae70e53a77d8dc50ef1b8c60e0e7e25e2356ae7eadb3dad8800863691f1550827078c0f1da5a07c65a4419bd31a81c422795ace0e63cbbbcbe89b505f83eae310e8e1a77b7fb00e66552f1e631b923a6d710edc1fb92828898d17f7ad752cd25e51f78218bc900885945b53e338c47a968de323df7d8fa3b6f600937857257e97f79702f349a7803a46bfbe6fb338a533a4e8d830c349bf3fa671f0f77db4d614ac327b2a9a3a142dcae372e4089a90bbaabf044e29fecadcded01b44871dadcbf2fd2a20d5588603c28aff8e0c0ba966737ce9d47b6d67baaa3ac9761da61b065848c128ec5f6ab50b549de4e44d71a25f9f00854225bf5c2db690aaeff7f546a973cdfbc93b60e62a7c25efda4ac19cb929ae070f54b187d8b5a9776cd088c46036de69a22ff194a329b62631fb267d25b87c7cfadbf90f453105805243380b8a654c092b18ac21ab89766aba3cd58e5d0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
