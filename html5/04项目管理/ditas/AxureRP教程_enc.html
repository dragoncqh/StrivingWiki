<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"864ba85ceb6ef05068821f9340faf88b1b27a5e2a458f6cd9bb408cce722782d6e6b7a9693ec095a3cdfda35b14f07e1515ecb61f985bb42267f6d52d6a6dece46a190c2636b62e9014499a04d9228a74237edec85fe3e1e42d4aad07127d8b2fc027c3547b972ec637b598edecfecf95170c24911719dade8103e1b196fa06bdf87d66a90fd0c8827e27df6a99566fa6296e356ca768b73bb357c48e73fbb271e9dff5f648af42aa571e7fe90ad6d9f10d3afa9b82764dd2e39379bb578c90609ae3c8d08efdc6aaaddcdd8926dfc77352692ee1b6cc8158f34a327e5c4edf6ab3c35977d41021ad070f03bab54be49c4227ae091f8154d342606ca2e54e02d0a42a885d5b63dbed76a7fd04bb67834dab3e493c6cf3ca97704c985ec1796147597528db20c927363b28c8c6c647098e13cf61ba2e3d0d723e0da61cc90c38cfecdd6a8d3597d75df30234059de55a77599592f3742b47e8f5d55ad44f49e7844af635ae2792823e7f89892d7871c1cfb4199169a9e1d1f823ba8dcf822b282b5957dd5593413d330e78954ba993235107eddd5237bc5ad872c52598c43464367dae0a51736edf7db8b170827f8b24aee8f05b34d212bfe3081f84f6111a5ceb000d1b75d80d22fcc055717e5a29667847df1efa5178433c64db1657b11997e03ade3a912ba87df1a6ae8faf39c3e90741ff1db8e23a2f7506a6a10de79c3d43222c22c5057b050ca4665b64aeaa6280ba39578941897ee55c5a1bbfa21d58b90c17927374d07db85832bb01ef751cc12e2dda2269d0824671b8507e5335461d0f06742a684b72682a59de84a218057884f02d4edc4daba891451124667875904b1993ff9ed229f6894a5180a548798122dd83c2deb80514df5105717b3341ca8441f4ac35270066904a5dafcb7c6d2af5e13ac54519c04282510b1d208ad85d1f11023053626421340484f7f553e37f95a2ff253660c2744974c1e1a0c33f543422256752d01de930612fe73af95be579e28274f6b8331f11c45ae6082d21061cb036db57fad4989deeeb801fae4ad92d2a08fdca7fafad6c2b52e186d20064970a6c8057383f55f0c0304eac70f3ece8afabade9d69093da43d0add024dfaf132c4d0ec0be36e6a6f1da0ab117575a04feeab376250d0df1d6fb19ff0f08b52c2e82acde44a07ac6222d3137a5d8fdc889ef577c3bec4924f4bdba41764893dee6d118d9d4f0ea271f79bf838b81b94884f801ad046cd136b59db47fefd685adcf6f50274a16bdf47032181d0e90152ab02503ec31bd60ae5b397468e34469f9c82434c0cab51f71fb80e6eeaa1f5b30c7e3c8ce88ac20473d1240d61bf1f56899e94aaeb3f160d2e9a3b7cbcf574308eed2bd6d95525a553b324c6911c4398bb6b805d987261d5eb80218dd7d79aa9b8ae4b673d9304c395543ccdd1b4ddc21145d5a76276e47293dfcb9f13d30bcbcb4557e51d0a63ec83b5528a9ee20e307d091980f493c118c08bcc41739e158aa75083ba844bc00d400a88757ce83ced936fcc241c2937efac96e424fbf9ff9c7e3156d9f74c5bf456cd55b698a00f2f81d33ce41cdecb0aea9fee3122407f19bb1ab0cb6dc4bf6885b57ea31f3a818cf6a93bf8d01b1b5ef4efc838c244272b0f0ebf261d704b88090be49e2a28893d0bec116391c63218d355485a4660ee6f4661268dc97a9307ca87b959d3243deb01de6466cd206042c3f9c28698a672d12ba972bba0bae38c45c8cae46bb8cfac41157e919f042b87c56d71b844652d2cb6ba80f4aa7710bbba9f2aec56bceafa5f83d99f26748d4005b9cf0672d129b26eaa69f8392aed77b40d68d1d749423e2666f0a517ac20867c7d65ee3f8993bee7018de287aaa3d7b5b1f8da0940df80ba2763c9d2e0b7aaa3db3106059a219e7705a1a9acb04d3992dc99ea7d324b4556e071c10a55f7d43b72e3a092bf66a6cf3b54c9c043d3a4f7de516759983dff2c461b7f9f7362f8a126d9a237937c212b68eeeed91f8a4d480353c18c0257d314630504500906bbf9105cb7939cc71bd002513a6d06ed2d3f6e2cf31756a41de186db9c79f329e025573e622ecd472ca907e024e80732878889d3a732322b8a3c9ffce04b2ba49c1a790fb79d5d7bc5fa0401ff78f8c36dfaf0141b4be7aa6a626a07747de7f2f621046b45018922f575ac128eb1c0a5fdc1d62ab5c785821583eec5896c93391ef5fc059e64ff4591d3418473306142d9b354af0d730abbed6b64b1c9e2a6a0cbe462f05d3e5941a3dee471274bec383880dc0ef8036434a4ca447f6b25e1016ac31b48ebc53f642235a862529791019e1a59e4124d0ea13d93291db71dba6746dbeacaa4a8274eddd84a9b906763518622fa16efcd0606f8a6acabd9bf7bc410c3f7fa46fdf73038df85d9822bcf8b6ed8af69cb1b902412d061626749d1280fce0cfaac85c6ee3d56c1436e63805687f7d45aac992062bede6a2dbe70fc0d953b902bb49506f4c5b88fcf6cbed4d94a79fce99d077d2db42a38f58960d5976720980de6788b5e5954734ad9746df4938abf5f9757f4917e1765d6c2b95831e7dfb3524cf02f2a11d36168e1bf7785592dd8418589c46146a596d2ecb9ed2a4b7ee1e913b6325a12993b578fc63db7e0a5a58ccbe8a1ba2fc9596b631dbf097a3988b1dcac2d5364699d321f832887f7ed9c137d9158a6b2e31ea9f00469e512e5a971d109b0791c292cd8f601f2dad15c8a70f3f14d6eed41948f7437caa3d8a4063ac43a68e7d2461ec8befa2bd79e9ebd70ce53ffc14ee08a049fcf660891f29020f37712f97a41f93246812d311b8c4b8028d28d7f4ea59dded799e6a7a91f56ad5a72f82e6f58329fb81075ee579e68de8146f03ea78641034721eb05d89403225b21438daee8bc065fb99263b655bebd2accbfcf0a8399f0e6535af6cd0bd827efed8c48b3984b4f4abe1be9df126cff6c1b7ab676975b62bce915c409652f685a9f812e7cec7dbe7cb6131b76d29f8cdd1d1e29c57580133590607fa0710ea02818625e2b9a31c48606c789f487fa63167fdc9289c4014a7a6f5c3328963e9e09bd15d89bf7cfa3af0e13c07bdc2261927a60638fc9ef65d55bd95ffcec690d743bb74690bc6eb5670f399ee7d4f1bec9e0c7c5442f308096ffae95659f166805dc57bc5d5c6f3cceb319152b1e2665aa60494cfad407390be56c4a2f7ada7784aaefcc43d3291724a339ed3bdbb612cce2338e5da2a60abb7abac72556be23acf8cddaaa3eac82c3264b6ad64c3331066b6c318d9afc4b3275d90f316432a03d7eb009cbefd6e0a8b5195f4373c6b6ef24261f02eb851ccd0ae896af41f7519e6a94422713711e1bc1d57713836d492c942d9fc43e7ad72cfd5b9dd67a872ddc2754866052e5341478bea449dfd4783b70e99311659098423c80b8effb3709d1509fcc6238eddcc4a4db4bdab1e35a2b53972bb6cf67cf9608f94d8a44972b60f83637d8689212067bd490322d2198a0abf0818d2f3a68c43b4f8de73bb9f9542f8a47f74c785de8d037506b4c73be6eb6bbc2c2722181120d6da48b37583f0c7af2ee067f3aaf0e2361898e52ef94bc4e0183eff7e17fcaf82bee8c42a464ed6dcf9d830be8335f24136403e0b0d0196e37e56e5e476fc922d72374135a81ba3a3ac55b7dc527b6e39eb9738dd27c72a8308ed9245cfc0f3bc35600d0c98b1e633aad85171c9970e68b293305f8f5ce10a1139c663e15d4bdf20dc57c272c16be66e297614edfa2ff0162753d07bacd394f41bcf2b84bddb736867da1d3b591f6850184a251ccbf7751d3721eb5582f14eca43d92076fc1750986ff5cd39b80d4e0f6aa49d305e701d8615d28b0c5e25f51c8628c92fbf54579392d70c9ce00f61372f9628266fc349d552222bc3e06694280d44f84cfbea5a58ba9c2ab945a148f2dd55ce58c1503fd7d4a6b6b2c25ac6047842a644835d813e3729c351307405d90722de1ede03f740626c12a3671d133239025636928b093b000bcb153ab73be5d2724a925ddc43c0274245e1395b0a6a1226b1e8895868edebcd381a45be603678ea9a0366349d8890d25c8ec66d0eb01fd4affc1e8c8f9f75a70d5c15d6cfadec99dbf0979ffc65cedb4994e8a56e8b2ef5ec1c7dc76cdd0eaee5bc47747734623e1e14e596fde33daa1afec06c7fc22b9444dba1b6acdf7c52abde8ee62ab82014ccd19be67b8c80d718f2dd4889489f18723c8eae8025d4169fe42f92816e8439686d24c11daff734da5d52f9db72752bea756c72ef90e9394b51ac80aaeda9dcbbee701ad69f1cc886855da4da646d15bedcbbfd2b512f213aaa9dd5b055c6170748b2e0b4c9fc354c815d12812be54f768d72ec0a11bd56978011f379eb798a457dd4c040a3c955de6780f4f78e9081e92d4044c738eeb3015b4f3f427553029ae322347bc4f709aaa10d78df3f4a9bc63dc4ce13f335a7eb9fb538ddfe086445940dcae4f4daf0b23e85bc073d3f74f471958f51e1a2a6b9f30b651036d938238a6f7e0bf0b9e718cc370db21ada1e42c6e8ea36c46c3b09e5bfdc00b32a56c5998b5712976842b859b59078e815785243d39a4ac732d4a9009bd10d07a9577f938e7cf53f6fa1c4c5224a710296d9b4001a763e190d7d5cd63d8e80d96482d0f7c921b3148256c69fa39fa98bddb4e1ecb9d76377be384b9d19c9f63dc8e10678cbc0daac7b90d3be74965560ff76771666ba58bad269638e49114afe7f660106eafa4923246c0306107fe62f0c607e7e688f9bb3b874207d9a4a97a72e9576e57e58e07eb034c2591f1f73b68e07cf40b280c701b84c061d5ae52f743643668a85b40d4e88beb8dce013cae9cb497fd80c5cb4cb4e6a96d2789441692d06d8255e76bd67dc5be1cc52b4b1f45007d4191968baf550e9ee8fee79afee8beea5300cdb8f5bb8fc024b9d9f283105518891b27610bdae8fd7212bd45bec1d247db9bb276fd2d1b56cb82b8ba44a293b41a4a3b107986bdeb73b1580834cb0ca6acbb844b4104a6badc37a5cfc6983abeb96bfb4061b1d0017632d65a64c3871ab8e4bbc83a4e2a2424bcdf266a8adbe8963683cbfe1065f14b7bf8f2c8db451c312bda59ec619d7f6221f8548d7978f5228d79eec4f191962fb2f04d9bc129678ef3ea79eee294d6071f654928c7de498a5a72f6b435a8093de4d5912b42b3e28d236ea990c1860d7198741b6d8680a0c29990e6a39e8d565284da0740e345ac4098a5791d614bf65590ba7b7aa0636df112a8cb08ab3459afdf2863524f6a013543326c57af41b258d3b6d6d246cb011006befeb8a32e0386c44f5842c3740c6a09fd37d752e5bfc863e5afa8c7191bb2d18eb86c681f2eb5ef38cb3ea40563dc695eacc48f2fa3f7a5af5c23bac8226c84a37c7803eb1332228c4dc2088ffd0716f11e0e4350d0ef37fb532b7cec56130a636a2d1b1341a6259550e11c0138a609f01ab0383dca9133cde48e43fd38065baef4b9e1d2305aebdeab250310f2170124ef92e4d5960da2011d87830aa84af95261adfe8c8bc4aba6b7413e5202d7aeb084137841665a88aabb97038326d16f0ceceee503fd316441398bddfdea7474caeabf1676d0990b0520dd64360b2f10cfebb2d48b0618d210c9e4a87e01de7a403507f7947d3a21794de3566759a3b6bb15649807cf56223f5d07c1b931c8051aa4189e94768394daa2b7ce52c419204b6495419c4af2af9e47f6773d6aed4a9dfe47498b29b0d998a2779f10f46822ac79ec9442e4d1bc0807ae9bee3e6acd72c5a06675b3131767c758dbd1b6639ed4cf52c02c6a4e7c55e8c684630a8b3bf4cc2765566c83fe40d17a286fc82f282e7cdcf990981059c5f7cd25ac309f2f38768e2e06182421a5515f44e968879943114a204cac944fb2ba476c6ca4ce30f3e3b2ca44ff6af2b0d1f35b378dbb32662423f76c14acb2cb6c4d757c03f2240d404b886329408383609cdd72f0fcaaaff1626a88ed5d971c8de27402ba742f65b9ad547d35dbfc3eda721a98c68ab620c0c47b13a692dd53e3132a71c93eba15a7d9d5a9f17e7c0abf4d029be187ee6ae1d97fb9a5092c6b23b069a1fa45da27170fa1f94d339ae36ba76a95d67ef25db588dba16cf8af4c428682afca2d0881d80918f9e9e3ad7bab4d33f63711157b000c99a41d1825df9116eb2c89e231804c5976d2d6c87df68d005de16dc76522057275c32f47c4365bb021ea6e35321ca933d8937a3e40c8896ac67ed87a6fa2ab553dae551937a6dcee5d0a3228835468ebd6abc7de7ce080b6dadef9bf747941f0a63a805cfc37343e1a525735a62980f114ffc6042740e48e82fadcea74b06db9afbe2d18a582348820b77b76bc3bd0271c1a939103507208acf8eeceb9f49110feac9489ee019d623842c09eee060dcfc0fa5eacd5d47fa4d3b1be0e68ccf4f8b244fa4bf922283290349f0736d1f46a0a177b544c64057faa78808bd14d20d94747b832880f23c1a2c0cb24a4a865d45b904c07e1ebe7d1b9f9dc669b91df8725cee5d0cdb31942763533eb05087205777fb0d45d01d3c015f1280ece01342aa2770d15f8dd344d6587c80bcc026fdeacf070abf3c0fdc393cae59ead4ccf5052aa4b23415ba19c041525c7bcf21d5a292e81be524405fd1a1197fb767b877dba6559e3167d712302eb5a8a4ed5d6d040c1ff81994d034d5003072c57e95655bfd0415533d6eac971d058a3c96b606c4885e147e0d17f3a709c8a670eb8f58190b170ddda14f047bf7b6c5944c5788be8491989d5a1d7d2110c30ab98a31d3199bc120f10140e4b0c09c85dfb88298a6acaa5b462b42a9be49612f35100a12b6966744bb799b6bf8e3e159324cc36b3f14e79d7becae884e962b0db29518cc4fb5489dc242bd0162b8d35c1fa551ecc41b901d2caeaf1a94e4bcc4f2383363e81b5a91fcc07636914608f8ab90ded0c52730597ea3126d18b9b7e3ca8e6deb3b946505b71414022662d2a14a54a7b9740144df5c4340808b3c5ae0a84688dbb12bb1fc3300c7ab1d32935c6634dd2ddc4264c6a0a14521d105d5e84317c4ee0fb917d7ba07486645826888aa30d866d32debbcd2e4b01a3e612c729db9883768e72b0bd4ad1a7334deafb515eaf9631d676d45f0f6cdbf4a3f45025c517860a7c2faf2f27964f0fb4637786ac431ed60aa6dc7848b1b45fb0bff6a7dc08a639b75f199259fdcff9dea0b5a96367802bc7b2c46b7cc6d7294be062f3363afb0868dd126f599f3795f70cc2279f41638ac5810902e4c1d16294a1a1590116a5fee407f6eb7b00638eeca0bd97cc597f64d8695f8a9cef180c126deff39b170c8ebe89bc1454f3694f0affecfad91c8da9cfe13a387b0ed7237a0c222eebc4ac1e61997ecc99fddcc4f91be06e2b6f168dd0915c0a8e7f862537871fdc0083c1c05406f1dd85b5f37b37c07d15b857940ede0667761dcdb60cc886341a1525904cfb3a80fb8c16c15b42eafc291ea39e1bca21cdee4c8fa5c3342cd91a4d1ac910e1e7a3586c474039f01382eb85aabddc13c56612c44ec7cf8f93b9df4fc6911ea707e838aa0e24e4bf57c1b9653fd63dafbfa8232f0ca7afd05537c0668a6197ede544b979af5a6aa5aa41e6dd99aafc2c155bb3655c73318d49f8bb425082a6ba767361cd82de6758238fb59ee933e360e00da976be36c5c45c2746bd3f7a53359d13a638c19fab18e5f170ea49b62326590ebebe073407ae97b339ec8d572245d19f451d78f897500498eaef224bd66235fe7273f2dd1b00840192c3387ef8d5ba102f962a7ab84f09dfcadc2136ef664be6e2b820df360c7a8adc5504a466c432a505d7a204f9e4dec77ba15b8b19f4ca22ef4e823a6161918d2eceb47adba3462ca0244fec9896baf4873acec7eea03b7c6c3d836eef316d3efbe8776fadd30dcdcefd89d825d319d0538fa787b48280ff3a585445b0aa762a5b272abeed8edfde376a481c0282f4422395d225a10b83cb62bb3d74bbc384414851b27dd47af10977cb37f6d942adefe7070a7e2c9fc8204b4e25d69a5eb9129e7ec0e8496f6a2323878f7b3227967243689f396baac58eb8568a6f53dd487d7c5536baed1415bbc70a96d5ab52abe0d148e0a8decf31887192716cdb2b6eede7130dda38d937d0fc1c1a0ddedfe7616be0969233d2c500865099fb9d5599adf8993323a9a980e6ab496fd3a3b4d520ad5a09f4b9139583619f2730209a0704d10ac849e03a3afdcd21e73bcd3997f53e305349feecc856cd4154d1d0ff98d2433ac1db55d35044715a1fcf1dd298f2d5fb3711f300b6c35e6bb37931601e1662ca5941b1b21ead7dbd37c0ef2af4998767ac2df8e1e26afa1e063040508243f24a6fe6913e4015cecf781173a48ab5a3073400a9fc123dabf1e32bd8f260853e0ac6f00374ba3da1f4bd912b2aadbf1779133cba36b7982fa664dccf0c48e368f77821b9e4553146890a8811f8eab4ccc3fa933a350750303c033d5167765d09964ea5cac067bbf6394954d57b93e4d02f16ec9e97a959dff6a4abc6fc874d53fd0745cb41712f3dc1da9aab08d7e6e0a8cf18c5f226e106fd7f1203b985b7bf51225a00b88ffe00fe4a9480e63a6b314966a4f7e71dee1ee995c5cf07091f6f64bfca6d4f207cf5b5bd4d7d429cd9d530b5fb164864db2225de99c13f872b92a449fcbae0b12705dbe4584ba1bda63a70ca645d2ca3a07023892931319102015ed3f984f033846df1518f2f4a56922da466da8b435b85a1d57f404a9cd6690db9a762f6c7847fa496827d1752c864dac79c4361b6947c082b5329abc7bdbb445dc497ab6e4bb34045fa09df0cf35f557ee188df58aac394c1fb45f9db568be1ebd900b8c9fba3861f5189ad40f114f281f1117fb37053f6085d2136261bdf125af8edc38d8a8dd56388aa76b949f05bb5423e7af93443a0dccad00a1086cc881b5a17c6de72ba00654b031ab1d8fad287d51a6c0f781a17951d82daf852e9e858005b126811d52b277ffdd708ea00783e16f1af3b37c85c11957d7605dd3673b0acebc69adfaa6048c0e8754d09f44a77894b3a623a140eb876f2303f7291d4db7b1b097b1ce7c63d243acc9df400448746514b9e842c16109d01199ca14378899c94ea34fe42c252a6e10f639af8e8b4453e7b87913791af8d1a82a14ff576457ebf479474aa83c6d5024194661a3e11ef0215a7170e9a850763b5d4f8de6c248602a4382c554ed54a15c31dcf7095b2e54ce6be34dabd0cae38447400bae18860467543074b0193b1906fea606ab9187e339a723c4587923d0c1e9da87fa64b78a60b123533105485a1864908c31ba3b31d2e7b7b638bf23c687c1e19fede949b718b0eb4ee655c978c40a9789e6cd2a5d16dfbe5acd25225b52b42e676c054c4acc5753f9985ad73c321e39e8de587e35ecf0068858d065ab48dbeaa94b0ed0cb31e4799826c145828e881d3882bb5e35d0e398d8da8e8af23830611da756c664b1af0607b2412cbdd6f233be40af8172e9c80c0fdc9dbc894dbf5428bc2b3ad0a69c07572b4416ea9d3b16f8af03eb0e2f5b0ecfc0372523f0af15daf5a99c51236e1dbfe41e28b52b7cbfa9ab864b546684e310a44dd6c58dcde84ea8354f3098647ce83b59d87ae893a491a45f4a7dfd0c07a9a0ab864b1092b84cb2ffb5083f77dfcb93adeb4e38d29aab9f80fbe460adef8ec83e91f46817d053d20213e15db84a46ef62d7e11153b439f7f8cd5748584e85fbb4a679496d024199cb0e236aa4000d598a3f392c92b8d63ebd430ca698c1d315d42a842753bf461693e998459cba88fb1cdf7ac83b7ee37c3b53d79141325737e5a3f7a9e777d577b41f5907539a381ec360cb69b863e26e6181c658b53728501609e50c5d946278d303efb816854c8492ebbdc98cfac5019d94ff141686eaeddd2298abe809fee7dc45e786022a9a7acc44f326c63dd4070a820857d52a114e19f1ee433c31706c0905332953d2f656e95ae9c4b99cc0bdfa51da6c6530f88e82527f60cb548f97a1378bd1056a3ffc0118012fdb44e5bc54e783a58ac9ed032aef79367093586a246d62942f4f1e7a19cbc7ef990ee3dd18d04f1a10c09a6a93a448ffed19735bcb6236ac16c1a9be55cc683b47d10ac73a581d572ad9c25283991d73d4a471668426ad21dd95fd26e6a2f38d9f5a12ebb934a3ccc083a37a4c91402d5713aa61bde72061f14cf3a22a0eec772cbeec8297eddadb15dcca76751171a2857a5497b1e0653cf7bdb949ba8df087ee8486233c19bb7aa7d72c1b59d4f16680d44f7dcecc4d51694f814e3fa0754b9554cebb1dc445bb0b1dd828a2c52b3f892353c5112d2bbfc4a55872305972577f742b38728c058fc75bf527bf46b87b13503bf06b35cb0797996f62519feb592f9f02b63d2378e02f67f1127e33be2a50d11ccd90b6680da71d45f492f1904e2cf7076abd74e0572cd8ba05f02c155014c6d38327f292c3f46ba805569bde5afe6213314a6d2349e3a90c2f14935431d228cd5a7f0ca7020c8ca500680d993d171117f3fe0be34344450f6c2680d1828ce8d4dd3faaf7cf8fb99f7f1eabb952890edb521787b8b07da2ce4b52f66c365c3ca5d55350c4bc4f4c3c97c3ac9e706f9580fd3cd973fda039b8320218b97f168d071ce5b5ccb0946f3ddfca99629ab9416f7fa013dbad26dc3785b98853c9896808b76e4a90a87351ac316a9db2b790691edd502d68730e5b3289de99d7eb86e59af4eb0a9a5974b5c8292516ceb094458ba7a624cd3c823b4af7facd7fa3911f0b2222ab53605b137accbda71e8fe84bf133dc9d06938774632ba9ed31bc3dc0f38d765092485fc0de5f7093b0f11fcbd026158c47858d3b3de8487eda4c6fce8407e8b2822e262bd383d6304566c09ee56f7211b4dea41c18e314589c7a6a86909dca157a0dd02c602b7b4cb4108a4b38fc78527c1c873a512e698caae1876beac5daf36a13a33cac35e5b282036d9b754d018795163e52598149c3db99535ef743f946a4d8f6015a1906bac3a74e169230f46bf8fd60b423f4e586e113a52209aeef3a7ee4bd1c8121a0ba9c57f2a72264e068e57392480994b1a3b191308d433dfc654c9f38fa69983a766ccde8eaf4beac9ccb16b646bfac91e3f987caf59888a8fa73df49576facba0d0f5ecd1d9d7ca0a6508badeb97fad06e9a192dd2fb123bdfd7b29b2f41de57b0c53ca0ff78bc2a1d25cf95cc1723ebf79914768646ee25d84c9c175e3d9564817e2563a0f3758aecfd184bc842fa15d7287ef5806202b6d1f7dfd56750110690d87e3118296727c94ec6cc474df0d0758d5481419c9e44e631f2dc083931f1edcc11b46b480a95dd19db2ead6b8952f0fa5cca94952f1fd392b05d069640058bbc9c44deff5acdad51c9e4e7681ab2908959844ca9c83529afdee6a2e51f2b4c85584b0311cc49158fdec4115ef5945f97607eb8081ad442db06bde0031b2e5d59c7a6da839bd97f2809cc749b294c0f8f94439b3cac2fe00aa492fc5eaf784d1d3e461c104787bf32568ac1ca370e45518df236f3cab222304af1a391dcb42491d56e65c394a8f2b7d68666b52b3168172156230788486712b62a2adc3a97f74553c8ab6ad99a2334102994ee4a86875a7bb7410e498c567b3154d0d500eeddc3ed42ffc7994ceab603445372402d46888f6e586c6e77f18ddc977fd04ccde1978e083616ede2d20676e6877e66e7971a7a6a442e57a26266cced0a9135cb8bca22d14a7aa0bced4719507cbea06563c74453cbcbad50aae9c4f4eccfede0d47022f5c34877aae8c20746ecc03828463fd62538a26d792cc496eeea92125838e06755dc913a7762c14d40a6c943c2ee6d21ff0960b41f17d677703192cf518cc010d2301f653be5bf1c6c05c483146f315203ed4784fb39baa63dab8a9a82264809e12e1976812538b8d347257cc2511f88eb7da529c59bf37f7599c0d7cf076a1a3eba66469f620a26d58276594e7cb3fcf0941b685320937340e1c757090b724851e3f6b137d4ad12fd8c4c3969ec123ac3bbf5d6a7a7b4050a2cdb17cf8326ba806ca84dc4770d2567a4032d2e8c408e182f08d9dc7a5088b0f0a3af4caa41aa2b546de639d93ad0879fb78ea6d6880e3cb5c308d506f176321dc453994e1e3b676f543091bf67407827e192b5e9f8eff59c91e2e3e6dd3f222c4d4cba2eb524f787ed177e2f611ae9c7b4033ae370970d1f9ddc90e0b0812715336cad75166e315057165c0908d2684b2f640fc8ae720cbd72b1c8b464bd138f525a1ca8e3cb3548ada9dfbff91cbc7f297734fcd05f673ba1b0730c432bde157d6388e2802f2a66ee25f07f0ca9267c95000089be41fa51b60420feabffc064e3dd54f7e876605f36bb1164fc31303e0735a64d4145a5049f09c9e0f25257fbf42b088cad87eda49a8f117aa265e793cfd9bfae24a61cbd63fbc76ac3e44082c06304b06755ead42864bc88bd742224b94201912188eb8c85aa99f9f007e7e26fc102f88a4441b8f5f1d9c36da505fc89178cfe08a3ff063bfc668e7c51b16a29bb88a2fbb4535036861e0a22e730b5c80e38899d123e2c763614d92a516fa358d32d423b4c5d7ad55ae9fc4c1df43bf8cac69a27b890dd4eea215fe6c3da2cf10ce9ce6dce9747c7fe8d019f79a847b223265f903883973ebd954027e478a08062c6504a962f4f7c659db3c69614a92157091259f85dd309df88da640fe56603574492ac4b8c19133e22bfca454793c28a71f997827f800edf5c68d814bcdbbb6c8c49613ce5e9176fa784f723eacf5939b583821d94863f1882353b25594c56c200daa0d2b0dbeb3e9d4e8f7f533ebf0280e76b51492eadbde53855fb7092a42211504c4262b33764f6fe144c338fcb7bb1f9ed58f67cfa4c76fbc11e6ffc4e2cbf6e728441cbe717f90d345d23351d0616f935be764ac51edc20bb21e579b15cb33d0d6abdac84d3386e70be6e16d6cc8698bd3600812dac593479a52fbd24d781f45ee852331f6bd22d432db3920d223a8901a4a230e09236462ae1f088496baaabebbe639339eb336388140cb0baeb153de6b7137a70278e9796784b07f117d16e74fe416a41da015c44224c0f82c14556893bc0bc010e9d05d25d72e0f233230997d3a4a1b8d001b4f63a6c5e480c34e60aa09939ac5a5b65ef8df3d34f220b4d56a2475af69ff3ba680f5fb248868d941354e13825be3127770ec6086b2f2870c44ed34e18d66275690b33ccc5119d31c7f67bbe9f3c98b8d008a84681955d3b3a268fed2a42f5aee4b48d739ac08d6e6273f7fb7ac88d9e02944d005785f8e2f546987ac4472c82f627d5305b219307d276846a8f4384cfa61f4870fcee2b5e14d812f3c92bf98ba0d13909bb72b8eb835696b539a7fe967310c9d3cc377affdd7b15a238fc7e4ee42710c9943a8294effee648ea947ffbec4229abc8fea8cc5621542bcf33280e22fbae56207486b988e371e7bc2522a812ddffdafc11ab5a391d09dfd87700f26536effcc832187a90ae03ca0e5b0f680ccc36d3cff4448b82da5ea5458816c491c9a581c3f73f7d2a860abb34b6479974793c0802275a234dc3328862a493b1b32cce58ae3eed5b359cd4da9e2cbb1fd5d8c70b340427d01b04e0c855803fb81bc192cb1c1b53791fefc6a23b0b066caed3b7d1367732fbbd79def10ad7434091bcb6dc509d1a6bd85a7cf8023dbcf53a2fdb910600cd6270d58c30985a6e733086713acf0a7de736660e3562661ea1de6996d83155685449d206c729b4069e6575fa59c8ccd8bce0527f209746fd2910d5f54da330b9bd12d8edd11737309dcd2279bce61af025baeaa399fa15f885d217c6c798a52354e738ced3be3bf77fd67968d1a3cc36054b81bc8223aff7550a957c7d603bbe4ff197a4f103f2f082e14fba609e8e7323651b20f69931cb59d3617b642ab8e3c545b8603b90e2a751003f8ba5c09c0b9af34e7fb8feee3c411eee4c9f11ab23e23438ada570e02fc34d2023139d5cb65fe15beeefd0118aae68b9c04c69ae6f88adfafbada611530ace4fe7a37814d4d361fbc72d50f13b0ecb597602b028402477f0d74cf83e53cedb6805bd5fcd199eb4956f2108407b2ddddc530324c3b00363d31261085829750c3909381f117a671fc2b7a7dcddbba6d7cea03afa2ff28c2fc9e07230eb8a476405e1f282647893b66c372627f616c8570141e8e17eb945621f76b8d883fb41ad46143185afcfbf971f2647504b0ece7b24f354d748680737cbfb4a4fbb1776a26bef0660ca5184934f28287108233051707f74ef668b0595aad460eaea53be4e1b567f50a5040c814e3ba9defb44dc8b0b8081c3277115ed36318cce1fcf47e6ad17820f7667974cbda699970672bbadb6b8cb378db674c7afe3bc1cac82ac4e6c94b3c1cd6ccec204bd622040d63ce266ba354bc952f630d7256ec09bd9c3d826206b89a4afa7e9dce2d4c4a9e795c0887f475f2fda68bb62ac3ed35a75a57949307152c7d04ecef420fc2e9e73599a5fb13776c5a2d75c2f4a376553bb2b16fdfc3db04428a31abeec167d6c4104e36cbf9d10806b18cbac1b56650a3819a9071b75626271f1fda52a763969ed398d6ce698b30f909ce6521e830796154f44477d0234a32e9f6fa7dedc363422fd207b0428685b45117364aa56705285398d2b6133d8576aab5eb22c9b5c464cd9dfcba58fa2a0096e1fee24a7892c9e5012113fcd615092b52c972583a73d29a4210f4049f4b8c39ad80a69a513ca58faf4b2a5f3fc09c27f4176feaf55e42a4b04a6fc9a9493a9a6d25b8178b58f27c2a71b6dd8607bfd0e776cfa2728b60d0da0605812e7949cb0a864025e4b941128221b3c3fa250ad3f317245dff87e8e668b6a403731c982f106cedb988c69374c5bbfac5c708660a803cf49591c6039a736d879cf7ebbe3d277f4f4c9dcf72aea06e1f3bfa601904b1ade1a930bcde6ef6c53f193246136bb1a6b2a7805382d8d1c5d645a9fcad67319228883f9eed2b1454c8b5c0b1a4c4698f661710b4d7121a9a8f4ba9351a1bfdc127677dd8f98d3e3190e4caf50cd41d8800557942b0be39af6e001028a1eb4190db2025d14aab77cace28e91adc44100430d69f8cd0549db62475f74926dcb23c8c7d7393b3d6875d7704c5698fd3f6c9cdb9cf844fcff820829504a4cd2ebfef4f730a83854353c0a4cc830740015644ab5bdf008e0451d9ea73ebc5764c535248c4f7986d14a35491b36f71bab5f02f6e8df6577f68bb572c2fe0471c057e61487cc99ce56891d017a6edbb71e79f7afeab02ee77e1f249ef4db59472b593af4fcc8767e6f3a70461345eee5060a10d9642688224948e2f439a2847cac75252325260f002e04bcf86e590024ef235609c257262e541502242701a1cd503fbcf143e70504985d2275217d5c39f50fad7480fd6b0c3139693520007b525f0f887b119b0c27ec5fb537ce9ffdb35a0714a7a48c64b7a25ae867ce6311fd1100a73a1eb82c4bcf5565a7f7448fc9f72fd26f0b1ca78fe745e5fd4507b6749f94c26ec4887a3307265509ce3f029d2d2bf1f61cbd8b8fe4eb58876b73ce69ca2bcf68e2641a538e54b84d587d269e680fc727d6fced56119e041928d0e7373a79d690afb0c42264906ac03ceec3ace930e30bd3c89d76f8ec1f7cd669edbe5d8cf07f09fa1d37d7260a774e86ede66a1254841f4a5a47f05137cacbd2493eda0e408a899ea46819b6faac52d7a0830ea5dceb0ae33edf578f31d492c8b548c9af711ea0bbbb5db870ff9b2348be54a76bab143060d17f77332e8d5c03e8d4283828172cefeecebff1472ee179a2439bdb6db9e38e335abdcfb70ba61b2cd1ba56ba0c5bf8def11b32dfa9afc3a34ec4b0b1b199cc3334ed142407356da6ce48b05b2dccb9e74b125f826df05f4226fc31c13b4fd8c65325d10235768ed7d7aa48758ae56c82dc047df5b4e4fac16f05847d8f4c65d86342a0bd7f6412176a0c2cd8bbcc2101afc35454add62d308fb58f315bc407ce61783fe1121e8579f12779f83bd2475c8354a7eb5a013f5d5accb3e544f2e59a5f78939cd7cc887200e3ec6bbc84e70713a2bd7caf887503a9f1761cefc5985eb995c260b7a8c941c73d83015bc68f97a1f79c4f33f9ce96cbb5d1db7ba9a9a101b330c0e2843d79dd798e7a7de5bddb041fe958db2af362a6483509ee20ee41f96d377e73b06e967f270d66ac03439f96cbb6f6e1d8ac322f1e929cf8d7c2808009c3e3cbf042f0db9f72fa30760da0586252e488d9945bdb5293f9ea3dd137c9b12a387be61c246808d647a4ce982f27e91fab6e33ec9405d4be892fe8f2ac58b0fd4975fdabbee28728a710b3834067addf75059df4ffa3ff7330ccb53b02558a5408e8bb964963c7b00aff4f71f4e0859ceff96c3e1c56df3455a5d8fa54a70af404f387d30150e7e590c503afdee886e36351a8b1767dc156258f3c1ce75d1c1c3e668f2220e2a6857320e3dbff1cc8031b7d1eebfbadb53fc13d4e38b48b9a8a389390fa59301c8a843fca55f52197c22e5870c93c2742fc54b3e8d26be31a625726e431f38979a527a79e4b6afae59ccae5940220c0538001e2a99ad04022126999db2a95c4433f0672409b4ad09859ee0ffcd6a4b5152ca3bc91020071502d6353ae174f2461624a5c48e0d94ffc6eedfcaea6069f814348cdda019634d0ce551523f4ace93b43f93f096c26307d82c7d90a4d6b539bcb9a12b1d52969bd34ffc1cff50e37e0675966d4ba63c3526e3c170c1d0075a3a51592ebe866a9df34d9e525817eb05cef13022db59bc1116215bd50d1991126e3625f1ff30d7c1959e6ef5af1179c7f35085a08817fb0c5f04646ceee1838fbc2c930a392895c26d2cbc06446a5311f91ebe36f044b414262ed351ab67ded09407efb2ee3feb1ee93bf356135e13f6f2844684a45f99d4c2810bc27e6bbbf07c41585c6db29539d33a389796c5deb148db9f28b564f69a7ed6d1b811cf57d122c4e5fcc372aa22c17d46e7f6446f642d7f228e701b0ad57687790418aa47b4f69435d8e06085270fe12a3ea60b220c7145e97dcb777840852ba0f87cff47147f4459fa520f94f7c6ec131c53ce931529ffec663832f0b4e15f39b6ece7ba5902d8bef5bb77d02220d1632e0c5a78e79b7e095afbc6c8026d0ec41c12cb94b00fea773fa72ae02c573158f6196d6a64da17009130824da07aaa6b4ded25edffacd9de452980b5aae8895893d5ff73a682906220a711d00f524e46f258480872abfd42dc7487676a48273c2765711312376829f8ce89a7489be24efea389896b8589e291de8bccfd7185885bd39ed0183351f3f06f3d2f5a5a50f44c089560c6830591bd5ee30bac0d74e2af8829e7249e2a72c77dbce8f00f923c372beaf60a1a7ba5ab530d1a0a2f5245e57e345c33ed0a3154ed6d51183669c005e5d0dc9b1f5eb89d0d463bb39c3ecc99f87f10951aa1d594d24bc7eef4f4d615dc8dbcc8a398a10ad5aeedbcd1fe4bf92aaea87911f71666a0fd00fe0f6a78377a5cf4311845ffde7c9b9ad69dcda16d64cc3e7f6362492d1b9c1e78805c2735b8efea484617d28bf7891f5bc6e60af73a9ad81a3c9ad7edbc4da09f2605687d1e4a48ce4a6082b23f2615f56702c901bfd2ca4a999a0460b054133d107150df0572dd560dfd22abb123e238caf59b0a154da24d6a1681f93331ec8b65c7a9c6bda737d18eedbe46ad9fc5fc30d08858e9793036bfd0aeabf2e9299df67a782833f2cd95b68b516153e4d4223004967b49a8fc140f5bab02bd930f0742dd7e0390dd753e7d9598e8186033807ceb75dadd6ff717d63ff62d6ffee83466af339978689ae80286e6976649e887f5805d171a46e153356782ed57a9692606668effe94bbbd8535701000859cb09633c0b0bedfaa1bc2cf0dec01234327cf6133243afbada34f19af40a3856e8923e3ac0b81bc5229b5f85725d1f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
