<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"53709e567ba91dae2b1837d9edb21ff7eb8769fedcbd5de18068bc67fe6138c03df246e306c9618e1ae439072b9201d2aef22a7a4b4e6058ca8726466dd9ede769ec821b1a06c849a23b4d15de5865c7d4378efb96ae83a8706fb9b46a258b18fb0fc4d13782edb4b80a0142e3ce85c2106cb1406264efd12597a7f074dbf6f141026d7600de89fed56ee7b4889782a4efe41ab21c392d032a79cae0b15acf1fc47485812db3c4824d6b54e19f1146ca20eee4a6955c3749ad7901090f7b7ae033ce01706bbaa2557bd3cb19ca64c6d6e2e8c60436febadb679c1efb7ab98f065110146a26de70c5b45c466f6d40062d90cbdd2ff5718ab789a2adf1adbd9bf67d7d2df36b2c0400363839b172023f4996cb413139139272e00c823733117267ca6c36ad91ecc164a699c792520810f46005dc56f86a1fdbe6970d6e832fb7036be093bf6e0d88d1b9ff0c1dd2f559b93a56ea02ff42a2b4ff9f5305dfef6bae476044df2528e37b805098f72d2b98cc9b1058e5ad676e1bec2b93cb6c54c916fbb6773ec00b36ccf0a885ade4480185929cd3ae6f997bc3b3f6bbc1d96306b01104cb467b8db85eb1fd569bb4dc8897aacb712f7f283fc5fdff7584e4bb8bac7f0fe9b75f60b1c4d339c76c371958ad7d297595d41b425ae5211e8974da21175bd86ed93d856b82fd9b5f4a821c1efb8308850ecde19ba2b718b1c0e2766f8f4b02acb2b348512e0fafd1dce5f4c2bde01b58ceb67829096156713d84381b9d21bc4eb6bdb48a5e27b9dea6120dab7c5e3bcc63ca0023451c2a4044764ce7f98e0ab7503d40c9f6f1743886c9452d502846624711929f0a3bde08a754d4d87efad8089335d57a3d8878004f7a4d7d7ce6a12b55962677aee06cd943ed6517fade1d0c709fabaa5f5598f96fb8dfa13cccd964ec5dbae23e0589b4113219a9769708f1dc95af43751937ed5b361f98293bd1db8ee6f1b56580c206b48d4e8063c7eef7d36916afa6c862ab0edd148f758ca09e9a1a2539b121beaaf63598a0fd50b859278b3d127b92f6495e91e2d9395b91503cad05459e5e54f4064011183e76c09762e8cf7f13e83728451bf3ec93ad47ba44a212a42d4649ab31153bf289538d1a7b0a3aacd7f10bee41a2e6233eede32840dc487838d4e4370e17f977d417266102a1e922fd85a3e93577653cd542c602cb555c2fc33b1eb4514d1afa4b27ef45fd4e90e51bab88cd983e19e7296968398beb3cd5b7e692d37d60bfd59b3a963b6d4adb368bb006dcfe2e4ff1171d516b215349d63ae8ae6cc786b44a5821bcd6f6d017f7a534b0648925173bbaef033cfe3bfa0143e15042ec26982bdafde7c8ebe1ff68c3b720fb9b85f49f34854d7ad8d1ceb556a0f8ce7d237c795eb5f78ef5d8c67ca2f8c3ec461d93bc796475d7683740f64c460a5d2be6b9ccce5f30ad2d7b8f4a2124f096925fd5738c303af757cd089edea794b88e9d01ee59a901d57eb334d4e3d7039c1ce2c3a1d3dd3eda2ef60e531b8bb81b8556c745666f33d811ef322b64a5b5976268ad03b892aac998a0b2251c95ba6c59f8a4dd26985a5d82f6d0686c4d98f792109398505877b0e31f574c558259e3b2b7d9169033e3baf50d799d2457b803fc61e32567da1ad5e726ce6dda4c755123dc635da67befd9b821927094a1ee06fa971b342525b2315cfa69a8587b34b007091dcc75fbef340a2724cdbe4da6b898d1f52dc51d1e1c5b273e49f75cc8d988e9186cb2d2ff4e361fb2cff73eb86574678717447c4a1b052734e825f842f88fe991a1b0ec4bca5943699992ea8079acbd216550a9b1b976fde3730a4a627782c24d84d49568cb74314eb79292543c2eda6718d4d8573f502a7a71ff052b75214b9ee3299a1d4b3ffd097a8a1d506674a66fc018dc1e5b67c838e2e13edbaa06563ddeacb66e1a0a3d1c4c93c2bf1e4d2f58f3be673244fc6c5bca9713ec7b9c46307de9722065bd3d570ec226bb7ffcbb8838f374788418218a20572748b37fe8f5946edd95852340bb87d41f387c7bd6f4b4b548d3f116a2291fb1a8814bf1951f455b1ffe0529a69c91027deb023334c730f0cef9b05fb2c10254b6c5865165b5525452dd21b10ab23f3948f306d88d5316b17ef5d6ab1b50abbc910c853593df58038b6db03a21f21a37f1589ee0de5c10fc6a0fa2cf1d51edd17bc36db461726035e1c422ff100515ca158125e81c39bf3dee1848f55b4cc15dce347834a23406deb39e8386ce365a84862b0a3abdeb95b4c489f49ea1bcd672b7adb89fefbdf7bf87e9e256f0f892df03b3917e8d460be1a5e9a5e36c1c71ab277284ad5c8f9ecd84f0cd8ef5626e85b8484e63df9c3ef0a9f9e1fca325ffdd007f6743eadc8db37934b459b6a1d65e962c1071f2477d382fc67e60233405685f5c880000aee33be98f777275a2e1b555b0d821a8c3a4c4439f70b597f453e61cc852fbcfb9460daa91067513b888c34d3b2a51c3275fa3515b3ff2f6e619e332df53f10d24620e4f561537fd43cecff31211019d5c0c05b6bf8b3480dd932eaea89da0fb605b91ac4e14eb655d467acbf21b5e1896a2f2c99ed273effde36ee06c39885a5883e452e95f9154d08b6b72e7150567f0082cacb9e0bc773efc2355ad4925a649182b83a220ccb45a164f5784c1f8e2b753f512e9779c34e411bacc813a0fb1041975de907580332864ad6795cf6aca67e0e76697277addabd14d0c1838b5d3d3d3c3347d5cfce4703aca28f6867d89b97e39a63535910216ea884e565188b0aa6ca7223554bc2b8d6193325e8962cb2213591fcb49202139843ecdb3897e7ec64b829be87d99d3c0ff92300b90ffee8d97293f2f0b436ac88a30b48eb734723ecde8e6a5b54236b5626531d25462bb5a42a1f0ce9048deea65212b6d3d691c9210728193863bfbab4442b08dc2acf0986d82c086e30e78c060b76c7a29d6e3d3d15bc6e369412530e3a98c42388dba4a9c45837410559ec7789bce9374109ff55d66ef8524cba8c80c148b2ff11ad8d0a25a326e609a8d3a28b5cb1d7bf546603aa7d0d3575b3428c64d5ac94ff7ff36bf78c1c65e3258148f053ef0ab295f2f041848b091f84fbe81e46b154863793e39a77ed6c08e40a16147012ebabcada4bf88653f982b0c1051885bd6fbdb513d9d774e7b62446240556105d4807553698fc6870fdb6f1818a91ffd4da804138cd715d6ddaaf1a98666e86e577a13432bdaa2d80ea130a6b7c9b40c6681fe6d9dd3c378025d4592315ecf84b6a3cca9a93052b63beb73c0435080a9d61def809fc6095204c8b315e60b422b5b4f2c584072ae040cd0dc27fffcae4e55025fcbc7dd5c15d2808981a24d95591b1a08b2d308a30cfd2bc82453e22cdcdbbcbaefbda7c6e85df1c436db0617ebb70e33b5734eea3b9d295b5b0e578f94732892c2f73f400af95e76078db04be84c8248373a92c7ceed191641295d60487b7cb9e7238257867f47834e14885e9db849376fe98e80f57de367174d8027beac3001dd03cf02c011dcfe1630cc8d35ac1a6be0b0f5bd5a3f4b6b5435212b5b166498a3d4ec12a364d03fd82087ed7130fdb4b81bb883f814f378d39bfb3dd4542f8c59f36f506b65bf5c277b0f31884b6414a0c017be4f97404f109115ab0d296ad5692eebf794c8d7633298b9cbfd22bce1ddb3e0e1ec244e1d236741aa170eeced7771e93e0ab3f2a7850221a77ac744c8e6a57564ab222923e32d729bf78dce84b39cb8290c606200a344621bca55cafdd982edf6b79e7da9528bc39b1652cf1b2ec3e0e4cd2d7024227fc2a10c1235fe1913d0d07e3128b726ba5b4f5d21b19130c6b854d4f03e9e4ce184bcf9d5adf7103ad6c9b73fcc71d007ee1e47b7bd9349546d9c8f64f0cffc049448da1b8c3d4fe3100dad3349302328ec14625cb8135d7f09a9e85b832d50ac275e0bc51926f9a8b0d67cff547a9ba6132bf0b25713f383eef99ecea057a7f12803b0e7e15d7f95a9fe9d84e9c5ca42cdb735ce7315df447c11e7ca96c162b3dd87d8918765515466a5ae30239c3a5820c2545a82a53520c5be2a7e16098eb775cda0c5f4c6ac25d100858ebffc0db38285906d99c1273398d5499d7b58e7b40ad89f74233c60de3171fd7c4f4b8b616976cff7940d2ba0f6e0f2ecdc6ae166b22a6519dc55d290c305bd360b0532a536d44a176b4b4af089fc78e8f4c94f3c4d780b4806a01905bc9ee1d3495a0fda37f5ecd250f007b6fd9349e028f1ec3dc8372f448a53c7819a0cc0d4cc8ee063c16e0708537cec63e95ccdb3f29a006a93f37215890c4fed4a1ecbfed9c0b866d2245b9146830145cc334f800d9941c4ea9a9f46cef55e3168626eebe949cc5e25d4bfeb08b40f595fc0136423152b7abff997323456ee94be8ae67157b341f920e6f75a93e735dbb03d178d71c5ccde76941a5abd0d0b22b8e4d7214b0ad68b33f6b874f276788b2cffed93407668abb9ccef6fd3b4ce9176e36068854ade4cddbf32ce82269f8ddaf295be494d8ca951ad78064c220836396c20770f93bfdd39fecd61f7ed43d906dda1928d83df24ce6b16ed064ca7e1eafa1fcca2bb8df8cc142362521829b9d22e07eff974445a0c9e6b44ad0c5a7ed4a5180dfbe4ca9c84c4286751f488bf50fee1aba28e37feb108ae8b5950221f546f4aeda7ac98cb0d17da37b1487098d13728fbd89a03984bb94190fb78d1293c1d411c63907904db2aae2c41d944cb044a41ceaec6e4ad668f69d12dd3f46d418b82411f23a5b357a0dbbacc09e4be6724ff0a3a73b8363f6349301748b864820168e6f64b5a28a9e38778c1ddca9f4943095a1fcfd86f07f56fe667b41cf8559785d1cd77325784b19cce5ac543bdcdce5e77ea88b395455a34d7207dc360324f360535a55193244d5fbc2c5d3af3a31910009a330b9f64a6a20a77fc0e06d8a2c16a4ec88d0d4bfe5d92d2d8ef607a5bb81b17819de1df6f5c32c348af770278519213f683ee417e0644c1e2c3c5649403388813e54731dc08e3bff5d083405783526ab4ddc386c0e7bc6f7d2746ce7059bdfec385eb99bd52b18b7fc11d2d51d3a042114b5ea1417db9d97c82d1301562a7418e384e947d3efa722ff008958382b38c14943439962fd8260bb260eb569f010ec8a88520e10cf721ac089b814b4ad0073702ff9bcd4955b8b0ccd2ecdf1909fc568b8f6dcbbbcbbf1bef43d457ba06c5f47986f963160beb76de48a0cfeb0ea8ef229c632b878206340864c8af15330e60fabefddea41f2aade9b504f2b9076d671a79a74d9a3fe67adb2de48b7831ef8940c35b7abf11e791a4a658c83e7a1601500fb0cfca78b45cbecc813382ffa7867f849fd99be9e8b6aa21638d9c409244d2bdf0ec4acfdfcd0ce27f2629305be24182989db1240ab3cdb86e19e6496ae90345655475b730787445f36351ae5c85fdd6e0015748034a58e1be7ee0cef0cbed71cee32b18335b3708fde86c21676fc40cc03121d04849345b8d60209f7338925897855be42ebd876f034c1b64dc598cbdeddfad586c25cb3e87d72e37a0df555ada5e73bad23215936b1b336df4242c97239b6f8998b3d84d412be5eba5165a95f1df787b4b5b242a0cfcd949595647d5261fa79f8c0056bfe0af167d589b40c2867ce4c44da86a6a8e9d68137409b364cca832b2d603599eee4a87dbca29ae3302602a4b97efda96f2e072f528bad55b83505bb7866480861833e7931ae484fd950351c0712ade724568b50503b4007d551c58c8a014d888eaa2cb258e0bd8b0b2e50b775656ba6d45bf01ff850e7d66c0d5661259d82ff9dfee381b3549e22f21bdb658abc7287688b03373c49cbc619b5abe28c08d0496132f811e296e733b1ae8da1edd82015ceaf6411ae2d363754e6e2117d9adc7dccd055e0971d297f661cef5a5726dee9f0de3aefa771699b2fe6c65cb8d9bdeae9c7d09a2475fa8e830d022e5124c602dcc4c68f10d7fe3db35d1c57feb9ff2a7b21603bd7807ab7dd4937de9dde98d5db7f2d12095f3924565e668cdd1ca39b53344b01b0d3d6462e9eaf28ea9585a994fad8d95aeb790220ba412e99fe480dd3a8f3fb5f1e19908b46bd8724ac3402c4d83f657d4291697c1ceacba47163da9bad1b485e19ea3998eeef1cf15e3b9f86b902b4a2fc6bc52749190ddf3d25924b8d776cd7ae7c92194fc5cdd73d718d69e371755fead833f356b43a4cfdcdfd8ce820aae832b9fbb1f4f572441c70d7877da9c41c5c7606409cea7ea8371196290cd7783ef28697832df83db0957411b9e3768f3bcfdf56a1750fbe68861fc867a671ea499a220ab42340c3b29c348683ea497d4cdf0929dae708b12d5b412374df1104afd0a564c92a62ed3f7536a3c8f156d6e510ca6dcbea4792f0fcbb0a883a7dc21063871f24f491f83eb84b88ab36f3e750031790eeaaedfbd4a2eb4737cc5adabc9e159cf942f1883357c76409eb0c98bd9b5de291f7e75c635a3efb908b5cb03960bb66fc338d9a0fb524658ef993524c28efd9971fd7d69a81b852dfb31ebb65fc705f5cc4e6fcc16d0f8db386657df8bf027f4aa3c6cf7e7f261459fec4542d76a00a7e5b042fd8cab3c0341ea94d086e406bcc0dca2bee2d500664313db495418d10ac92737914c9cefc943adfded223945b9357c4e63d7e533ef9fc7b87adf6e685532d2d0f9be4b39e14688e353fc19277dff1c07191e7b3e97991b35b757cfd21321cc6b3e9227d0184e8e23ccdbf96bc262b4893d88a4d859372c497c27742533d0b599569c63538ccda2cfc1e7db9eb9012de066dc388f04a74ffd0ce5d6d6b3e8a9e94b6034200ed5791983b436f9735ce10d74e2a9eb778b31f60300bde8f35a619118c1e7fd90010763856466f8f494e0c57e89609c5395c9dfbdfcd8ebb6139d5fcd3d19e7b145c3e2bd2659e3a64deb7e74b20a64a82ea39c74b2537beb70910b2573903647b8b10c09c940fb6b294baed16ab8641c377b0fc838777532a6d3cf430db7300a32c09c9340ecb723e5fcafe4ea929812107d54c2c928e21dd3bd80595e80167148afddf521fbfbaee78d70e9cb023fc1ad6861299f8635e8231991f9246c20f38030bcf6c5a7b63aba5e99776cbc2c7933e784d966bc2fc7a9f9681fdefb234e2faff1a5a313152600680f674b4e7a7501fa7cdc198a0b646aef676edb440189a744748f1828a3f20cdbad4f25cf6c9291b487db2b28dc721795ea629344711e2de9f062627c0b13a13deab8a9e82493099f1bb195804bee3e9c1098bb44939bf691510ee3d07f43e826727f80bcf0387c8e0384323f22b76c9f62db8c3a645eeff64f977f142a8872ba59b9cb517542e3bfab9e9128250f1d650dfca28871050ebf2ca634d0b714f87d9bb5e4cf110c3a80673a99754cb25a9ed3da75957c70232fb09ee691ed8f9676d1aa6c10fa98603ba6a527baa0be292499a043aec5ed2bda4f16c47a2d6f203d20cdfc9f17f1b813c0c7cfab22fe3283d7a08f0eb18500e03470a0e232500634fd99a0241675b227b1f7714a7a5cd97d5e257ad9ad78d44b2c74da01adb8c851710744da46b942977972d4d219df10132e3be441e13caf2a50b70b9f074eeaf51c5dd66fa3a38c10cb91d808a6fb525caa4e1cbb2bbdca611d49f0bef8ee5f7d1a3c5683510272285268e1e6891c946d7d849b8db34bd9c63192019d7ddaf9d74df246fd6a91a7b0f43cd0e93c7543dab761d948da7b753025c1c2d4af198ec3085d1be8123d02798f24c0155364ad27a872ea25b01a0aa6e8daf18070181d9ca66235ec7ef06a700e4dc6d2346c7f049dfffb1d7bf68fdcff33ba0c3d181a450d86d33bceec873f2e923a3335a6fc241a0a843435cc4a342bdc38da1d91f5f0f544a833171c83756bcf689ecb899b0660a40cdb786eacfc773ef0e7d803e3b8ad280aca0caba1601d9c6e80a506cd1f3308a021be3a2677f7f4810ae2ad63312cc114eb68b4cb28a9599181010e50038cd6bc89fd4bd891211d9339d4f47dd91b590fd316bda836e5618248b02b9e82dac18b83b2c3c6cc8dae669074fa09157a573b7b4552700076cf0a7f09e9be45e67e235cc935278cbebd97ec545b5f530038e50f7f03d3617ffa48ad69ce8904e8c4e2745c01193c7d48b8c487b32b5ee01f888bb051a2b940047551760f6e8d677f9d74cf309faa696d79c476535d940e79208ecf6f5d5275ec175679048aa7ec69c413278d591a0be80778faf99202c90e5f37f763461247c8dc8fb3fe12c4394aa1730cae8a987ea0255433a9a6e69d7df8b97ea284382dc0e6edb7788c485b593659551dd4c52a0a00ff560719813e50d4ef7c653093d96f7eb821ee30f9e1641a0db19660c0ec3edafb8c292facbad7eb7920520c664d0430bf66e88448bca5f7b64acf299c5c783dc5d18a923e3ae097152eba5c3388c3b9254a4cbe7b169d42156d364c522a38aec244a507d72324f2b9c2662d425eecf21385983747eb1fa16084315385b62eccf8fcda95424b668821f25d0b813eec5862d602c2cc56f4d36b4bf9658bc5dd3d2721bd2f55a2013a46b1a6b7f75dd95b1beb5f54d3a45454b29da346cd84d4abd68ad96c5416a30f24e320d658a89ff98c9cd0e860098d124170344e5056d8b60deb533768074af2c0ffbab2c4f016963169531a1c151efae5ce853b4d9452ef5de4e1e73e3efc1f4f77a4e513bdcb0985c06bbe55cea85015dbe1f116efd6a6f6b15aa812fe18f9398a0e75239c2ee81c4609337b40b13855ccd334c3b12431343b8ac32b5bc113388bd1d9af2f38b2a853b254bb5f7a5448556392032de472827b6b0fa41c9f9daf49af0e5837d1efb727eaedbc0dae897acf6417650d1fb9a6763d72f10fe290a88ce99bd1e41390016cc8c82deb094a60d42a4914ad55bcb164e5811b6ea7f5e4ea725139887f858a69a598466c402d3b4a7aac57a1bc4103c67b6838d1ab7e51a1004282d9dbf6618982ac34d78e55c3f784b5a5cc717eab1fa02d2ec6978a38973a5a93cd582880d09a86cd28c2de33e5dd8d2ed33b585fa115a0baab7ffdf547e6572ccb99cbdbaafdea9e4ffae2a75e941d2e55fb4eb5c037fd74b7a2679b836a11ea307537aea64b06854c204f961d2e52747aa7daa42c57d63f98148ee8253b99807ad73d4139fa190b97a26285af1da9ee7ebf30a2791c7d088d60e1ee2b65dd849b584e8b4c6f6f95c327700e61f2cae7452b328d3b5d9e42b126c7132f5a94b9a00188ca20529b9aa3ab5f81909b011c8d804f629b4ba2ba16ee122e2fd18d39ad82b38fde549533ce4571a3cd0365434d150da1c35dea63dac7556c4c16b1988737c271d8e9f24ad59f5235527bb66a5f19fba16119205aa0bf7a3648205c07ccb89301725b00dd8699152bad61b7e16ff242891c63286c2909a026fda0af87d1101e757ed7de70fe5e114fd1b850f53d147a78eda174d6b7cf954659d2aca3d8b1c4fb0d13c8af2e82ce1b4ec3b8c1ec7d4723618765b03e4fb799c878c3dfadc5fb1b92621d7077f3a1058acc1275e208bf78b7da301641cd298470a9565ded8541736e60d05f1d2057558836d30ce17bcb51a7c59da93a6c36321dfb74c853dd548fedc2078c16adcd2b9cfb2a01e98f0bbc604cb659e871fb2fe0dd5f6dbf2cf84a9c9b87725a71df106ee5b6a802c6fabb1c0c4358bd9fef4d18d245bdaa89bb0d4783688bc08b72cd593d7061d0132b6067d73eb379326fd27b5313420fff8c305abaf2501edd9d8ec09b4a9cfce26b9f48e02b4af1100aa740bdbdb3a34b739a499538d1c08d5657f0309c20ce8af65b46e68533904b83168974fe1a328241bd7c9c8ca7c9095d365502e8df86e0625053164e5ef2bfc1496d4348f17f60055aaa4414f0145205608555842c7558322b31dadc8b2c82fc1ba134528021e6d66341b8caf30ad43243434d58ef1a2c4b56dd426bc3420b3201f8f3c3e59a777b770dd492ec9dcd5e695c7ea3a3c9dad64f43c13a3adf8f6fc3b3a1eb75cdd0596a7fe0a8728685c6f62da89408cceed85c1e88e0ddcacc13987611a4ecc597f73c4019bf33d321354b5c1afd3ac991d24523f71541bfa80f6fcc347badd7121655ef78aade0e51da00dbfffe1ed2a50f5d620d06ee4a0268652d5c9b0971f568ed51fb87763b1c2ff462572b4264c4b812c73737342f701a7c851fd03d3fe7c8c3ea119d3a424fe485203acb2a448067df6e8138a4fbc1bbcbbc6da191de73cee388d726461ec7f0d77eebe1485fae7835de3fbf85e676ad883ef43edf0e7cdf17b0602fa97d9ea03b8de6c7310cf918d7975bb11a40257eb0defe057c1adc9c6887ecaee57680d5c32fd1ad968fb13eff345df4a5aba346560abb7b740c4d2382fc1b5a6916e9a1579681afb203c84acd8071976abdc8163e1315224c275bb773af0586b779f172eb850f8d019f5f15921f69b378252872248294119d64b70f30ebf71bb19286bd14ba3468308820317ced3b49dd0720efe6e450abe6ce3201a9c2e681a5ce3ecab4d600a974c71b701486a78e2ca55ef872c55cc879708d4cb27bee18e36eff93de83260ae633401f9c2d8d1de3a7f24f394f3192fca2ab8a6259b150e0f7fa1864eb46009704d2d6da5ef994e124a3fcd118f476c20b1dd301e466bb71d7835013667afbff1aa751143d439f17ac23bd1775048be4f9e085a71c7c0644572aa466c52d737eb3d92345c05a7105f6061f481a8a87d044ed89254e25481ee6a8ecbd3d1fdfbc9693864d4b86244a9e64645d6cc1992cc1a87d7d543b222908ab20514848db5d2e47faa5e0202756a95300425749f839222c255adfc47d41e302ff11db5a8d31d3da18c1ea7c70f0295454768287910ed1de8da20e4cdf694f7f719107b6c42b6f102b95c95ae05f0c949ee30c2f89a776d93097556553a261bcc369bc6e41ca63e2de86971f50762beac59df98bf88263c2fbe69e1fa5864e54570e5e697f30e3f707b94b40b7298dcd472751bab46e4f7b4aae7118b2c06fc97f19c96f65b2f00d44ec63d4fbbd0c9351538120ad5eb9423085d884a6e3a724faa684dc574a3be38f3e5f739656b1519a1ef9f9018e5828af395334fd7c8ec8392f4ae32d2240cc12db80c5d78464e7a6c39c3ec622fd9c07b528ec2efdd8896da5c3a7f1d6bc1c26e9f82d4ef3d286eb209af717131e2cb165d5476bd8e70d3eb42f9d15728240063815a682e1d817d7c092ee280b2fc3be3dd1423e5b37931d9aa3db54248e0b279aeea983945bebb74c75d6be7f4a43cbbf0e8494a990042289cc524ea419cb83978beb5fac964539518c58060ae9125007788f615e666dd7e20c86d9f5b3f9eea2637679df8864522275747ea9a2dc064bf7aca8859a0ba213aa32f598ae195f5202b2b4309cb64e97f959e0c75b338267a39b720bf0d71077819cfd801b7f5df9d8dbe4243f75fdbd5984ededd1cd3090e02a668c332aedd7d2ba8782e9740ca8287c288d9d07f82e11938daaa5115f8b380cd8097ef36cdc11a217d40747ffe60b11d4f0399f5f235e1db69323a2e5b214559ddf2edc91161ad33a9d8decc0c2b585a8678dbeb456641d4f48fa09a3f0f6350688a6b08d64b440b4c99395afeb2390de7ee7f741adfd78e9376fe50b3191b67f9d003788f6f0a49d0cdb7ed80eb82b7cbad134d8264a906781502a4144066509f112b8057d17bde21c051f53d8beacf89c0e013e976d181380f157ae0e9360e7994002078c0d12ab5830997f6092f74c99723e6ee7d5dbec88a9bd9292ad22505a39a1ef9ae004db1c84ccce0dd29aefba46a9ae7a645332887a9dc0a978ed82111ef3f9cb1effe147cd7c52fa48671f472ec5aef8cf121181a349b3b66b89846fcc33b553689397df1405fb1d0dcbe191ddb7aa3e280930c5ebf4d6a741ae8a74fa588ab2f5fc177b21dea7e20c53c70ac01d2d2b1dbb66c0309754fcf86f0aef576e6c5038bbc3cec5399a73b3dac71858e695ba588aba56afc0c0b73d34cd0de6700c882ed970f1c32eeec850a363c09b9814a62a475b7cfac5a784daee51c1dbe1ae1c98879ba2df73a32e3b88b45d7254aa2084f84c810f8620318030493196afd8bd7f1bb466ba8ba96c374dafcf13ad9da635e50221a897b4ec9d57addfe62076b5f90b5cf0f2a56c39cc367300c0a0dca98e0e00a6dd5783c96ae7cd8dbb1338f494c4739b6d5bc6576dbd9b47724cfd47b562f47f5da737695809fc6fdfcad92375ea71664ef73fc9a2ef071a159dc4682d5efa5c37a8a6663b3f8dadbdaa7d3bbf1767410988d96eb64c01526e797d1ddd94afcee41389c06732ef290b5c943651ddc3f9a981b0fdfb4f1d3bd8916b6b78172e49380df461d26a324c9a7a8b991011678ad7b24c8dfba9976235ec45c01a70ddb163a7ef2e9a9704be02f2c20b89aaebfa54d0c75d0451d43cd48fb591f120e4eca5cb11969cc3959805ce3a4f55d30db8433ee4a8eab5e4d495716c19147339e1dc6d16c54640e2b0c9fa699ab59e7f455755aae5573dfa55efce3d059830529018eebf3fb28402c6fd971d5cb1d40bb02db5bcce8efe9a5c076f04444d424ea4ae520b4636afebf3744d7f85b9182343bac4c2600a81d697108fb1dbf6bdc2a8dcc6b9ac6f8838e26ef4f6528b66504973809e90007c3d72a7aac51913a151fe17e4bf4862325b9f62609ed3cf01dfab2a05437b593a429f95612f8f6a092607bcddc75a4784dfebdb1146c0c5dbec0ebac37757471b00ffd3510dd2670b30fef01ea79a7ffee1a3cb7af80523c95b1ba14970c535412cdf70b5b6df70935044c49b4addd14ba89948795fdcc84f8d865bf3cac14790d30fe100491745434928698dcaee1832dbcd15b25057123c17f725056de0ada803c77276a24ad545adac447fb6932f393a2bd4426b667ed8d76d3802633fc07d79dfed278b6156fda9ab391a220436ac22fbfd0c148c4be53f64dd91fa7e0b63d07e4b1f38f90e1baf05c899b9cb2f9c46b129abb12eae6eaf1b36d3907107d37a3d216b5cdc16f3e3426fb55e476715cb01f713355d38d5a8795921dcda32cb31d766cf8c1b7a8fdb90def0b0cb059a87332031940fe8ebf3b7a3565fd5d448e2a3b9c23d3e2f0ddca319dd0cbecc635c20b6e62c63d3355d860b7e627f1e6f1e36ad61fc8907755e5b450b7ea3286e8655eecfec18b9436ce323f708df44209592dc85f9abd8caa494ffd445827130292963c7a909c8a9d261c8b2421f87d17593de07426f2bfdbb6d68321af69b6bc2af0bce8489b0882b0d3f36c33750892b50c7f2d665f1f66a861bfc8020668b3178dfb79764b9988d4b6549d463668295129b4c40dc689750fa3338e28686caff3788c910411ac432e6e1fec831d03db22fd6b5db7541bcaea08c3b7c26733a3d1aeddd2c7eab763b574cbddeb1728597c26f0c2215501d973d83e6a6b318aa6682ce9fbb39e3007c20b60922ba6f80364df25e61ee61f30668509362d17593b8c3cc63ffe7c3175b382e1759c1473e1b4c478845f1d72180e1d31f3436f55115f3872d9e538e301b71f178a152cc13a27572ec43b274959abf81686402f60c7d5ae8b69197d2c2702434b034093b9c18a064aaa0209f514c7499f76d7a9ac00645bf144e29fe9f87a39850a9f273d6c5fcec7f84281b117d32f2d6290d27c4ac6cba97247462a7f40cd68dc22e2c64ccb2b4690329ef8b89e9fb770de436f8300bc2d62a51fdcfd9a0ab57d942c83a49cb307eb5f991e8a8a7638d1cf14999339befcffeeaae8cdc45fde1f00e50e08b48482fb68a5b7ee6dde953c18767032688996156e0121e51c2a65d3156864958bbfc58a90b37d2c259e21468815c095fb88779abc8d594921767f4182e970fbc6e33918b29996945c8f515a1b8820547e4c089373f35d3c6f7f9e4a1aec2cff06d1fabf301d0fbe7252155b47624e504835f4861d5df1cc23051ab95af1e0621a6f304832ffee351f5aca7c3583534d934d888ec166bde89a1e620bd2c09004a1e631c5ffcb377a2ed91eebea1c369199774eaa926ddf740a0a8819a34a39b144ac5183340092c076c6fd1790592043d748cb673536991d7f7c59ca992c748b5552f873241b6f1618fc8c80de0453b05c6289806d4d27029338f682a53f41f3d64a84a5b5b5587989bff134f273349eefe4f055073a40bfc9ce6abf974f429112f9fc58ad464913b6a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
