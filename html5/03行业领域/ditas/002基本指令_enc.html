<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"41c9d022cb0a0dd39ba28153b480312b53a1b80faab86d052ba3e47fddd9202e4ba5a9a346a4a8994a22e7bb65d6fba2ee3d4056ca5f2a9b03a6cc036bde52b85f40ace03e831f2146abace354c0e13bece4d473d55c05848c97fffff2a175bd4fe449afd0735ffa3551df4e65e27f3222fffe8e2eaaa6c104132a026d19701dfa2a4decbf1c58a4177c594acc7a951bc6ca26f0c6356d23d5b2af50ed3cb6b8d58cdd9c11559486b021d93d6b5a7951b74593bb0766882c9d97a98fd4f1d5a8e6bffce9357440830f86ca162591c0fa3c0a6d0978e13a2a02039fc7c99d3dc8b012e337565c8a04f64505523fe658fa140c7f6271a5bd60df89a62d4cdd43c4af605ef475ea98a9712329585ff5ccaf2da92ca611323e91e574ce72222e32bf4ff289f9eb1859988b5f8b0ce9d3f2438740729151d7e3467b9939b1469ee15b29d8081dd12ff1ba82084e5104a4660f465c8ce19643117660373f97ab9c2f38d2ff2ed08fb8c7b3a24bb1f11e335e10892b1fd342b660d8f87b8aa4699b2662067df6240ded721d16d22e309349b1d43553f4d2e2d38e67e67ea4ff3db263ac7536af4c3cdd9cc8246d3ecad7eda06c181e32c4d1448177daa4df3d18f767128e76a106aec1a60f16ee81520ef6343b5bb959a3e905ffafa2fd133949a2799abca36dedeafb417880b66a7b0af784407fdf1e2a3d4a7b4a13bfd801d9941e3b91a3665ae3b1517fdbfee381e018f993663af296a0103d803060bbed501d0217d41b6208cdb851db3cce9a11c2e62371d096c5055da4a76a3458648b56e92ea8a507660e46397d4841797e475253b876ef80ea52d4354017ff334a052e25341a7ac4cafd029c290665a0d43102a4e52fa38979f0e0f782226a7df2aa24ee9add130a0c96cd00832fa30ea340789c54b86352876e254b03860801ce8aabfd2634f84d68b42dc76a59ea6fdfe0b2097d3947c18f0bd20e19acf627cc50a2399e2eaf52e971cbb3d33ae1130bf4235c2bb1b4df2b9952af5601261ee0317eff1d13d25f495ae5427b871545fbff70a2fd53b556f5604ef2f13c95f9555c9316b1fc51b7ec344a261feebf2683f2208edf2bf1f41235931fc55f202ff543923e6d8777f738a60d1e3e1e8c4f5f2f5ca58b0c1c0707c4b05828f950edc26bab37939e9f12acfeaf89261add15c7789ff7a589054e27277a840d598c5b05a11b2e662e27248fe54a30d9a8fdbe998721cec9e58b83d20faaf136ca0b28adb291f5026b901620feac214a9228f023925fa898368ead9f07f435367248acf5d1aa57a0ee0fe03102add9fda8f3d90ef3ee9a04cc2bf2ca1ff3edfaadfdc6982a21d7bfecd122aa1b0cbfc016839ad35f411a6d08141c6bfbf6fcafa204cffccd762966628c2b425602e4c85f3ac090d10c2378e1c1edbdbe908e35d3c7ac45b4b2cd4eceaa1b175f97e859246fa8bf7e5397a0be9e602ec9cb57f2390cb8f4e900aea183e0ded95ec0b62a42da788b2c562eb2d037579893e61c421bdb6104c0ac518dbf33e20d1ba12eee50d3bfb4616011148c130dc49361ac8dde24dacf52b97824338713231404b1830bb3c2df3ef618b4bc23881fa546f5d2d4409c04d500143ec0b72111d3d619b4314b116c3f6c5e15df160577af84837c6f437b06fbd3d08f5964cc18a23e9673386ae257610678b8da8fbc64393ead1ffb4e559addd55fd1a3b0c2b1af2aedd0e08468fd70c52591688546579b90cc8ba3a619eaff13db5c115669db41752fdb110806cdb32588dfa7d1c86539d1f6721db53537887053950091f0b667a507f5d74a26ede60be04432a2b583c103924a499e9216436e5af547f822a476efc76fc2a5a06d32fa6c1a778b8228e8a125f924ce9d7b47c4c574dd1b6bfb10153d146b3fd54ec2e0ec11b6197388141de7d12e26e3db403bd4c0fa1288306babcd10c19bd67ad7872f037b724068f5b996bd72dd369ba17ff61d014db078703d6f622b4d93ae40be300cfe3612fccb2768e0aae8f3fced7729cc4566fea369335989dfa602296e86cda06d1debb7df0702d6aeab59e228c7525a0634f06ab9d335bfc554cd7d68e63abc9bb7a372fd81dc04611f7d8f97b45dd9ec1c2763228f52d2d571dcf8b4798674296b3f6b5e06894ff0f4b0dc8b426d2841e23531fc475b199199c408c23d427ab5825da1c8b91776e1d3cef26c2600ca835117c920e509fc2b0a9a89a668e483e9be5f07b13d0c1ed7244bd6a952ac115a0c6f9da9f4d4db644481ed6cc9ad1ae2a0dce0ba8a0268150e77848c41f72c04e667fab0f6e626c4b1ca8bd40976734aaa2270c93b3dbed123c2bb498a18a7924e51f8731c5a77377485371ee4624341860170b06d176f8d16e79303eefad29e0929c6a923c437ad7aaa5ecdb0f5cfd8eca4869e9d2ce013e7390e762651c046ab254b45ba1f21e2d0b92bbf89e90e96472f4cb2857e584e1aba50db820814394130be9769e819fabd1a7d66b64d901028b5703c2f2fc4e19415a78b98695ef98c89223f9fd932508e12d56de45c8155111d551a9c81ebb978e68cbe70b6e0ae0cb3b152583d3a1866d7d16abcaef9d550b3cad9d06b6d87f0ac848fe3c7452725da40c97b3edd796dd8e96e1439c2a3d383c4e763b2a2e15996c0286f4d5a4e8b6d00bdb20151ba792f7bbc9712fcfa9c9b640565402a142c9f6ed34167818b1bf1ddf3346152e441f6099b797512f1573b3b94aefad86ea9196186af42f9590ad490f58fefe700ab13a0ebc983b925d917e1b985958c5015301b9e38be90363e593754f4aa7428dd7c01ff64a55b5e7b4cd6c269e2bf28328eef1c27eef30a24a44c051d2167d0a3563d80c2610607b1abac097651cc4b6b35af9b7b0e47370763b4379900c8735a41a06a6475a86cad6ee88ac41f841fef239bde3194af3b8a855911d4db7664f3aa0a4a61cf00bd5e9bc15a1f4bbf5de8aa93e8be71803bf9f2a62e554b5dc4e15d7eb5f12b407255fd731e4f9e8641fab82f4813c33992c53a6c91e5eca6ad4a44b961b3182d54ebf9813455931844de289a6aec2efd3add9a8ca236910f9c3575a37cfa794f7e7ab3c168d2eccfbc0b650806ee59f6bde1e0ee8a76a672b17edeb4c497e9ae11e6a5dcc116d692c26654785aff53315f994f94eb4c0e066ee550363f40ebe86b1a234adb0a4a51856281e760847c9dcdc8f387bd07341436b555953e45e26d44b056c09bfe4faec2f38d1e2180251625ad4749e244234cf72b93031cd83dae00c47e16e616ab280db1a31fbb8fd54a9326c56bc437047d49def913e3f54945c1fc44761c783baa9f94c97a7e7cbfe205d07d2e76111e557af30f35d1eefa6246305356ad8d1a9a73618b6c644c4d5fb8ffadb55fc4c76cd13e57c3d800f246a96e6b6368b5fff6e72bb3149d4b44175f04589ac1964e5b205032dcebb04dd86762a44260f0c604fffa02129e4179bf8af22e6d33a3ce9d373d70a3108704f500b2122232e42dbc92e49e53683cf60979710cc4dd6f290902d863847cd1221ee180fedec26d513e54ac3dba59e359aaad615ad570145712b5d5aef89ec3782fffee105616a6b8ed580b38e337a7f92b531dd18ad4c2c528c9aef3622c76c61bdd734b9558b567f4560ef93bdbcec6f21ad92ecb1bc28252b90d27dfca76afe0586b5fbbf02c80e2d6283afb4f9b03d132a3d42c330ca442df7db206eccb7fb964afa8ac2917af28fe6bea89aa9f9de49a9229319e93c21b1a7d5176d90c43ea2a9d76c74286759d8d9a0022a2db8cba77695383849bd802ff9d67a711fc728156ea6447193953a654cb1c89390eabaa0cf437f05480f5ace9f49213e32b7c164ae956841fce65d4336e76a3fac674fe2ad7f7efa1f06b4a3d9843b0bc57bb5ca64e784be2f72a9c5ce3a103faf2322b208a90d48d3b679c414412b9632c0fa6c79c4ae67beb5c3666afdf041ec5db5709ceb1054b25bde15f4c847ae731f4ca85f9f1ed80c96e19ef764578efe692d6ab5da53c9b2e917344aee6caba60d57ef876dc974090d0bc38c4e0726dbfc4f2bd734bcc187e6b60050dd46a076467dc6c8c97639114b4a0c93ce469aed40cf5a7643cf4d9cf1d24ef36bd8916c5c17f8b6119671d108a73e676de1bbbbbda17603487b1600a966fd7935a09a173c5894b4d1570df9c503257c8083e20a0fd1698445c54e41f60ebd9536139be6bb208b91d922f21115a00571ea8f4fff14ec28af83bce0d54897e6c1b03a156bbdbd3b42e3f9735baf8903e70ed5d8afcdd6893aa5a3cf2f252ddc43c17d167c4a86e299186c01c57b240a091b4ef9fc6c7b5ec70c765672eae9830820a066d4314f87cf5b092284c5e1b377d6033750c3060dc98d76c0d836bb318eb4b54d02ed8ac9e677b5687f1bbf46c3d478ac136dfef9048c8e7a5466ab1726bb141daa4bcb5ebe75a7c70b05d10c8c836ac949ff4d181c445f1bbe41af10893cafbd22c0914c8bb4f0c8ea5c90002e99706fbd2cc74bedb1124c04b4193509f363b4a290dc4ea02678906c1dd279567815b37b7871a2620b4b3dd8ea3ffa7fb72cb5cff507b82a748113afda39ffc95287243d2f6d1f96b92fd6bbe54eeebb84ffc1afb72dc7dc5152d28c53a5cf9c54f3c7d708e6e081085f82ed6ef8c75403735b9c1513a7752a07c2b6fd17fd07ce0584a7f635b4d0dac56bb953f8b75f9991ba9f2ac8976785e1f7135c5eef41ae2b4cc054775560a0e66e8fca248f6d86d9457f97d8fd11ff6d702e7f1a89fe2d9635b7bfa815e7201f916d88eac0de58de1cd3a640be20411e6b2186ee01a508cdbc4076b34cd9e6133e80b140355ac1e23f7e531575630a76faeeabc5d23d8fdca2a5c61f8c8a4a552d7f521d076b7af39ce07367f66b18a656d1883a6c772e83d3eec9fdf36e5234f23d06cb0bae49e542c3b2cb1e691a9543f68f60a95eea2858793ee953d37ce1e5b3eb566846083f4171fb6643360aa672a219d3a9e03c4b33ce027d507cda27bbe7c5bf7344a350841c5ba4c791ee4305ca3455032e2a08ff5fc9027d2a3f85ebf76990e9b9df2babc70ea996bfa7eaee8e376c140607f0c34388a365937619710328d799d1ba52b5ff3997398037dbe2c77fa44d8dade6704f82ea00986d850c7868ac9989e1849178e720fd1f93b7d95c0f8dc49801e2b12d255cc26c1543137fa89766751d199d1100f7f3be82f069ce08331d2f95712ab3230307463ace7b5834b4774275f27fdcff35e3b86a266041d09f0d45c08f4bdc82b8f1d449035b738fc13a244f4c2a00037042f5b7a71f9dcaec182befaac9e9257d0069a60752c706de943bafb3bbcf469d77bfed8396339862a87c393c079da16f59cf46147aba61156da313daa4735176193f15a02c284bfbadbe4b0493d16c1898d00641c48e09f0d90ea8254d47f026f16991b2d889fd4c9ef33160a4aa869099e86b7d345c8b0eae52244757911b2472624f839a379226eb6cfad0a454eaa659fd83bb70f4ef13c187826974111a9589015558274f2fc53c1d110b0710f784b8b85393c67f1df87782d22ad0940c3e119a1ac9efac222fa1afdb38a8eec7581aa9516f1d07e29d50ccc33223f2d84fa78db20afb18cea573f310af1c3d7c3c828433a5ead761e8d652e900474cca10a22377494c5e78f4020704504377913f68f6d7e43144f1550fa929d7ffb1df596f2deb3db377688822526f371c8e9ef0eeb0f1eca03e366ae0df58c59f748c8a9207f0c238598b9cbca510d19673da2ae712d5db945b975b0c7aac237fed1351ce857824701111eb46003f8ae83dbaa5d4b0a9bbc5191d3a44599a1ae6a1d670dc15cd3d243de6e0a2edd06d931e54fef2d511f88fa05c264c53b11db1f28629a8b1ac90b6f7ccdaa92b0401a81c15fbc07229dcf301e4c3631e51bd70db47d511bb5052a539b233513742700be4e146e62b1653d42be4b11ed0c111d7be8114d0c15774bc580f3e159dcd7b9a1cc546c19c7cbe590c78b2db2887f1a087b3d8e856b94953a7779a286702b7eea2fac50ccbc3fdab4a3c8ff051b9f39a4dd32842370665681ee828aa529a168ec6fda339b9cc5a7d964736c33fff26b1a3dacf7462cea23a1d32a9cec63e63928ccf014fa2dc3b31cb0d77db366be733526d8c75a76ca16742e667d379b7f988c2b176b9bc943f1247d2d70afccd9d23378574d56fc2ebdfc6c11420bb49539fed82a7b401e0798d003269e3a6aa51c3d76720667cbfa5b341605a339afb1345fc08d5358fae939b8b4da38267c89f62f3260e3342d12f828339e608c7e72eb01bb10a3762ae98062f93b942fff8443ab4c760f6efc4219c6bc7bdad193354b7041da29023e17ccc5f79d9c1cfc87475893f39ab5a7f23376cdb7abc8a86f54078fdddc7c337f3aed428a4136bd5752c27c9da7ba8d4d5aeda580e3d5ef159c5245d1561cf52cc4a6a0f855fde762cf2a047c9a4dee6f5c44bf46e4032bd90bb467fb06fbba8af0bf4bb511921c6935ce5c4ba8eff49d1d13301e5d6de77585f4cca109ad4f49a1fe8791d202dabf901277a43118a1fd9f9c34388e9d27afe7f89beff95c77284b9da9b5b2154e6c75d750093a14c8a0b6636bdcdf8f374cd064254878db1cfac74d6881c6d9e6344ffc4387f7cd5dd0e79939b7c076a352dc6524caa3561552b92f8aa94bdc6ee5cccb22e7f232eb60cf19271e916a5a58a25fc79f96db8aa6a4de9d343a1b4d15d138082690b228cea83a27be570037b14be0fb69940a4480b2cd987363627bdf439731a8f593863f8ad99ad277a1022bd351fa67265d470fb5e7eecf272194fec403e526903e2d93dab6fc1bb32ac15c64bc711033ddf245bfa1549c6a4c6cbc7c41d8daace00e262817c5532a3eb5b92d0f53b1fb98f3c93db0252b9225447a858b7a731fb603c411c0e5a6abbc6009128178d8e2a60160508de46c984fa7898e4b636fce9a468d7f8bdd9c98ad26bb1da787ffac03bdf0afc24a4dc655708b199ae26f6ecd6e4ca3192824aa35ca2dd268b3c267d3a5cf50cecff1b095279d1a1228ef6afc281988aa1d185728d838d216cdde9288a1792c9abf49c79d41ec8b66e9a39bec5fcb062837c5606c8bdd64d562e39a3e8c0d58712084f42e51b5ae742d3469a70cd4f502f04fbf0854e9f2ddefdb47bc5c84d7bb56828eeb0d9aa32ab78ab62249bb4e0ca4deee5d57ab18889cd3664d4477f2d72fb2636be8015d83c7f4d1c287147cca432e525b5be25293f9058fb3d08dcc2314d66a69c1c416ff9566ce4122c08c7d05b146070c7f1c71b4ad6178520db6fab194c3c2c8f37108c94acd5068725d348d986df42de61794b59c494ada4aba54634bcb7995378153791ccbbdbde1321bd58de4218b4061de4be184075a31d1528d830cfe95ac2282e14e33733eaf720686400ec9daeb5d941e5f85cb70d602d5df289ab5f28084027c7834136c799547f1308f956b7378538b3276cbc637ea5b2be3bfba79be8f801b3e6b6731da068a5b50b238c024c49f475f6df93559154fac462a7c7433c9811090e1daabe25443e7cd022f121780d92bbabd52caaf2d665c0afa2ea6b00012194206eab3478c49382b39489820254bc3d47185d7a440e9f948eb4e9466ac93871d5cea77a08af0fcfdc307ea65f5df4d6fe9f8247e227c45e57b9391672fe7925d24dcf26d260f8cd6f77d7dd822400019f3b3a6cea6516ce3e1ac1db4160dcc3a64699f3a8f83f6cf98192e8f37804e6ff126b5cce336da9ed19c013e283cb90c59614c91e26ac0f38805bfab0a041053a1c4ee069dee13ab9cacffe053fcea9f7f33147e76902af04a581ce319fe9b13e28afd35be400f4a2a6dcc9a52b73326b403a766729230343e97d2b1afb8b87b5670a902727b4e3d81234793a03ac118d6cea3a30d4166471b37208b67bbbc36b948adabc5db1c01a9ab1164e43ee5bde42d1e04a06bdae237c9967ce2c54e02c59b61c4d0c03dc6cde866cab468bb695005bef086a4608496859dff8232aeebbd2a1f2c2b8093460d8740e43c2b5c165c90b1ea4feef5e3811f3a4dcdb0fa615281e536c8863176073bff3315846e4ae6a4d5e78b82fd1701f86f9d154900970a8897a9b7a48a994d7fc9080c1d4007d492fa44929a8f1e96477ca9b8723f484beb370d20cf3e82ac74375da3ec1d9309b601d264fa228ffe399dbf3cef26c98eda44b6f9cb9858cc03f9e4d7c0affde753ecee83a705d73adf430a078ab362e4aa650869ea97f2c5bb9d9e8d20146e3d86a2b9b69d5b2f3c1d292d089bdbcec611f24cc2ddd68c6bab9dbb18da4a57ee8029886d466391457eaa7ca63154262a082229e52c8119610d90b69543bf775da18f9106ca80c8f9f1ffb4faea31102cbc78df5607dbf7b15c46be7cedf97827cdf29e020c5cf9c64152482f993019f143cbe8cb2cfb51d2bc3fdc6cc40f908bd5a743afcef3a529e93569ca58a697322cb01bfed8cd91c24aeb99b5fe170ae5766e73d0b9677e7530622dcd74b6509a10d72d187e90f6d3f9e37efe2a70deabd6f6ba29cc8d339bff372beb5a941cedd437df2b346136dba3ac2d3353bdf006c5cda3999d2f09626049857e2c50e3fe0c75a022da1d6c311fde87a2b3cb0c5c9eecf23137082c152e0841b8e717cac0809059661afe70352394828811db06771c5ff3242e4372e982e34fb953bade38887cc83b8fa507b2cc1842a89c0dca1b43192a1faa0a04b599cb83c344827215d0cb67e9279b887e2c38e7aa5d521a75901254011f7cb97b2fea24c8ce76ba7c8f7f2e4f607539a30e21f9a77ce4dcfa388135631ca9a09f6ddba77b59a0a53b7b02cf239d88882da2be75d46c17e7845dd680b10637f227e35b4faa8b67810d9c8cd92c7c0b60c577b662eac6bae8816621574cfffd295edfc55d9847cf4c1a7b2189359358e1692f789097057532965cdf18c1e747c3a9802c12ebf50721b477ce66725c320520d81dc5f0961323e1fdba5f27ac5d94bd27dde6ff7e69adce8b12f269dbc0194332c1fc0de2dffe211f02a34bac300129a3f05d66fd04f7ce944604b67476c0dcc3bb5b81c20c1045c44141cde5da59bce5d0dc7589e8dfac2f7d24b3d4624ffa7d9807494c9fd7eac95ab5050fdbcfa925c79b73259476af9da0f2e7b41280571c24f1abedd27b14eea637a346e94105004d64a3ece1bfaa75ef83d77ffb29dbee63b60c7a3637042312ce95c097c9c8b3653be19d0aae2a0a5baf2f2c23f941cefc21b7b8971c5b9ab0de8af9941583bcf772fa274da1c5f6d6b01174688f2eb3f6d1f69173b93d0b09bf4ad781626826ff82c06e404547086fd1803126296d9787f91c12a624486a985f2c0f25d648ee257109ed2b166c796102b553ead9f0861ef7a38821a8ccdb5f4ea3d40340adfbcde5cda65e8b3e62ef0ef41f3bf7fb2acc2454acabe81348e6c1374c54da1e12af97c8803fb56df23e8e3fc42c48dc346efb7c3b738c52d1518e9289ebf36de79a9db65ae479c177f49e23f7cd302675e0307a4be0e1af26ce24435c3a897731c64147b610cdc057d1973cdfb1ca8f0660556db8d518d865b741f1d5c11f9d40a2f98a26b7df5958aeb4be811dc847e16b4a5c9585ef67ac65e3c8897af0c897bcd5efb6ab43d918313c874b5460e4a2f55759cbfa8cec0dec402629c96aecb334de87044062477c06547f4c598b4c0df98191567fd645dcb909e2f9ad2b293903ef6ca523ff3a2963ceb417bcf716e8e6e64e6d10018d9b6025de019ed14c4f39d3b16938dadfd4edead27c8f7e1ad81e808e4fbf01bf4ed667da69ac7954518d9585d67bb02646fc5aee97a79fbf94f45968e6be165384fa4353fd3cc3e4d4cf075a6f557d13728b007f0732188826c6083331d6f6ad34b094a64158c3f121dfae1d285862f6af57d69f647a6661df615d0c7968132b2115831caceadd33d25bd6e7bfea9919e069d9fcb385c28743c8ee0ef8dcdc1b5fbed7448277efab88c53e6f1f0e9ea50826cc068e266c7a97eeec109cc208f7cae3d68e2bc6928ab6fe3557ad6e594ad787bf3d7a50f8c32c473be1295ceea949e5f4d59ca604c08110bfcf54b412c91b17af3eb4990af12e5f56c0dc0f1c84bb05304b3b42959640d15beef81abc43fc695755cc998bbf89b4ecc1ae50dd0554c7624e881c8a11e3775efa7b117c3f5c44c561018254fda99cea722af1f6fd1dbe0e2588bbb5fb97e1f688203bd0356f563cdf0a975f99addfbcba4f1e514f9c01ff6e03cb6c64c615c506d5a0fd01e1a5414b314a7da0a5b8499eb57cd56e7fe2d99d65c15b42715be445e169e445d2d37e1694ae6e9fd75bb2538388a69ab3f7cccd64f078ff9edac0867d1999ed3189def339de89b0e1d92c63e6458c50fe07fce313a63314f4bbd6a5aa1a3402365acc21b18d916e24d74f97df00ff6ee1f8a37f8825f0d99eb4c1489598b37d3072661eab59053906cc1e08b8c9c37d5d670e3b42df9e7056fd95b96fb81fdf48f372ae8ff1fb719bb5687a17a3c49d8df9afb3b5e1fd9ac16687bd6495ea3427355e31dfde58380c7cad6a27403b4b0effc4687990ff7fb912019c48804461df63debc5bf28947696aef36aa722b641e10f140add24132d01c153332834437901a322b15cd26455e48812d33d836b07349baf31a3f3fbe66d52c7ca210e87b0cb5978f755f4961ce2ce2888cfb5768378fdcd74b8e45f2d05caca5275d905ee4d1fedc0ce93806da11213104ab4a58255e2ffee4cff6f93d36b27634641fc0d99922fd9d717b6bf125046fbedc761299e64308f54e9687c2c42ba4a49547e2f8552cb51baf46b12ef3e09b626a9299d7a03504c6bf39933c48d030577d3c6aaf0e4a13329f0b743d261a02cb16e4e3f840f8fd6dec7c63d6ddb8453267c53d6a1866f91593154d38fbc82f600e6be5b38235bb1d862cef2f7c0ffb8e4919d1c737a9165bb67a79d88c6fef2cb890a8144180378131c6b3a1c194d4e073506d6624280e87ad6ac3215c722dd87e312fabed01a23930e0bae3dbe40a676e3bdbbbeb380c984724ad5db64eb91590a8f4394c1570fa9cd9efb4423957d716c24ab89443e73b2854e77cd5e4a18b8460fea82b0c664b5ad334c5c733ff0dfff7985dd5b3364f10f1c93d39c5b7bfe4d12202cc981af0a41421e08c352946c25558aafbfffa9f393a4e2b9c7ddce67b344083e69e0b934f115de79fb71a996915b28975bbdd64eb0dbc6916b0087f94b2f508963b59964cc23d06a8644b45a3f1b6be7d6f8ff9c848e420464d40dc50d40814aa792e64649bd29bfdb6ba79e773146e8300df65cbf379cb9c262f119c345f62d4f60759c3cdfb951713809559ce28fbb9c6f8ace407088e6c3145c709edfe3d24c14a1624d145d45d9dc61e8717aebddaa0b69ab2232ab9a6761eeee0fc4d4d4a96898ff3b49c27eeb2646dd82ca04c78dba2558a3543f0ffb162192e70a374def2115d741f53b9b1890e2cdfb226cb48a1d8979d8583c672f8c23de2c4d5b24042f80d017233f5af5e1170376397b1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
