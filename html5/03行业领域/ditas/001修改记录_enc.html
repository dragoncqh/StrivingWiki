<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"07d29adfdba36b196e48ef1c377bd34d84c1910ea652d12aa33b5ad69e30c849d0b32406330374a62ac1135c13ca0165df03b0003081a5557318fbadf8c0092877bdaddc3782cee9f7e8cd2744d3a17a197482595a2ca13e2c107bea7b1fa13e6fedbd397329b152d32edeea01ec9180a13fdfe53398ba7f66f1640ef51763d3cd0bce989615ade239887771ce986845640c84c2cd0e090f0e4f5b3ab51688be21612fd2db5647b4ab07649c9eb97fbec6013beda46db7e3a8293c757c657001a19b9ef05ad69486d702b331cc108ed712cc734e90d5e8a18c844d5a69f59dcba57b53900c917b04b613bb22cac2c6cd6a90e7af134326ba5bb5f9759516e62c69bd324598ae27e799b6d7d070c9d87976c8bb3123a243d5d743be472a0c1aa1c73a88e6f18e73fd9785e366b0a815bbf6c354e07123c4755709ce189a98f55df285b022fd53655837aeb13a3862b06c151dd90e31318feba0d59f669277a5d6c0ef438941bc15cf91fb661a889965de478137a1a265409122c7e087f224f8c8ccdfa678abb562dd61345d4130e5c49664d21fad643d8077c2631fa8ed98c42c57ec929b03ea30a72b72967b2c67dcfed6629cd611269836ca0e06713ed635617e90a14f752ef757e743c4e2dc43f9f724b95e77d431b90937b5421b6d626973e459c5aa736bd16be82bd0f3aef850fb479ce052e778d53e4c9905beed36f4bea45e01af7ff13760cf76c3582c0e9e5aa6a3b67c4849132a17894650263416151d666ab3f169a235f279b29bf6c4ee279f97bac5418ef9d19ca09bbb5df65ff86cfa6b044f0987d808422ee4448fcaebbe3faf2da5e0dc612faaa7bf520c7cf0d54d21d699ab0914ad8d234bc47ffc6690e7e08bfbed10d779c09ac1ecb4c87a153b2c94e642dd1f84825bde112667c9378eff7f7c2cbd2d5171c93417e6dfc4af4431c60d293d7d9f25636afb376a47f0d27439f16aaf6f0287270eb2971aa3f9e6b34ce952ade333835f05751e3a97f751964ae6911d96456d549c0bb81ea02f44e09a0c37e9652f93f6f83815f52616808fdea2e5b6e20eb26b62f93b80a41f73a22b4c5c4f842517e1aec75657ed6a995272cb12c58db3c233b629e0b39e6d664239ea52fe2533b8d15957f417f2565a11ce445311e9e833b42a9ee8810015fb1315a0166551a5dc5de10ead893e0cdc20e943df96ed673955fb76bfb7130c4c638d9f6df8cc68bcd2d5ea6cfd9a7e1d7222965e109c026824bd1526ae45ca3bb334a640ba656de6671612c5caae652765c8e1d334906f27083dd6ab4abf28b9d5ba8b652a7741bb597c9a5400699cb80d3bbb426b2cf4b26725a614eb999d527a3bb712b840a0a6b98183886c844a4ed852a36f3e045f8002aa490efd239e11b0e0d0dde410743980c0c389358dffc15a9e5611234b919c26c9cd0d3eaee1ded39b2b97de03c6cec0692678df916488ce36904e370b2fcbb9c119cc8b27b2d08ebd51bee9d6e9022764dba38f94c3a0dc334539d4595758214094644e03cc36635285ee3755b5cf005379c1d303aa47be5c0fbd12f407c8267b8094cbfb6bede8b5476de0e39deb2636447d320a20da178eb5cc570a56f44f1935ff61442ca89754ade829bbe5ee7fb61970ee1f25041cec30ac604ed98bb8e0c3d6cd9af7619965502b6b45025598d122bfd976bd18e7a03a145ca3c48d26bc4f1ea4669c2f1fe42a0e5d36ff58f69ad976f5c9608f79cb1b983cc52d46447f2be232ef46cd711a81df53e5c89a4893a9b6f8aba232bcc5d3d9aed3ac5acfeb8c025949786c1bbe351ebf26876168557a7cc6f27199c3252e574fa2aca95a4ba2012084a0283de4ec3379676906a13d61e1739ce3bc99aae65668eacdbd43b71743aa9221d949ac9f5177a1d3437e747264f74ff966a1de017402afd4ce5ef85e44676f1b1b4fa57af3174b03f70707c5dfe0f7ce5bfa4c7861321c22e841fe75baaa699baf1a991a75285ed709c0a94a504691ddc8d683505c8e4e392e1277b92ebc1de9fbe287060969851311803443144373b2ea63beb14060c7dcbdb60233af4bc3d37e0f4c607cff8ceed589b951263c7b69164dc1a5be039b1a43a9b36b513c318cf392e28e487129c875ecaf4b49a623999ff8041bf9b64af75d28835f88b21faa246e26fec17c93258dd30d151116b99943d0f47cadb0e32748c462f7bba4dc3c3db821cc3671903c54ebb8434946ad33337e907f0d5d6d4cbaa6bf3e4b0b3f4f8b5382828f50e3919c850bcea435dc100d64b8825a7596166fe88c4000b68842435b2a405384b24caa2f5916225dcdd610d7321a93d2764aed61bb0bf7d1427d9ea7294a979318bbabba0c08c949ae0021138acf303e1c348820f3b2c631ca6133ad22c340295e72ae3f191132d7d32a51a40b45c41227969259e105f25f7a6807549c129b392eee7f0ee64dc86cca2a69caaefb592e8a998ed8e7a9acdd9b1e218397f42562a08681350664b5fcbc35d3c5c4cbc30f10eade8759a613362ae5296a878a444bab6d413a43371d19cac026e8aa504db48b679978f09abb9d7dc04e884b6d3fbb09ab96aa87011ae99c5de5ca49b6cd9fb8771bec541925da285720665cb8ee5fc6002000946590bf4463c307b5952657e14f7427968eba4bff11d6f85b2b236595bd2abaaf34e5f4d39dbc2c822448a6a1e258f045c11c0f1a31d2dc294ec50bfde0de24720706c60d4a0c40e74b50e997c422b243de5cbc0fe925872d95a0b0ea48026319671928856c86b9ceb1cc47a8873e8e9fa39395e0f0f3d8d248938514b5e34a3e9a51ae308abb934380cf88cb52338ce319da1a233b2f9d7fe3ac3aa16b57209a1fdf207d9c1328027c4d323124b5f1ca450daeace1c2fff58beea501a1ddb6dbff2004f8f87e2db07fcacce29cb92d94f213c93b2f6f883db75e443c87f42f82072ae184e585940b7e691b11d31d6ae4a1cdfd8f38102112bef0d79eac6e9df1e8602a7d584e10cd3f82e5dd055b17b1c1ca642985d19686ba5c15705b75f5c60073bf5dc03137532753a8df7ac5db99dcdbf94dc18927618a571d18d0b71d6f5e50878ece835ac83312b22dd2cbfed691b9f6a8ef01316ed11cec38c3c30ac9189df881e69b0801a736656a3ebdcb975ec65930f955ac4c3ea560ec131b4da9f378052a4a5183763933c2de3852349681727f4c575f094c3f1a44b98c91c0ab46a8891a4a7a38798a9a8830aa2773a8746601d893a0405cd22949144765523ae171e85e36e620b2d549ca36f26732aaaff224f49e97d2d2078e377eae0f2703b02714a56aca3849b05830a3c54a2624966c7e89c6c724f6c332bc59db4a845dd1d9e85b7e7275705a28bf5fa32f45e250efc1b6f3bbf94e4bdbf35b8aa4eb6c9853e2295a48466d5e373cecfb7796b531ac727f0d408ed62a2947c2d50a1e8b5bcda0696e7b3412ae7e9096330680203028c8d2da3f186567c984ae75c9ab75abce1a45b037a8f63c4bf95ede4d6612a261917386914937498f00ff75e04c1e222e7541784db7c10ff0d62d8e45d1e5af7a6d83437b6b12e19c69f538718b5a7d22272fd02560118a17c9de4466d8cc0214cac27bc2e27efbb4a1db0af89844bc4b8753ae463ce3eb9e9c6d3fe1974d0c7a7e42327d5fcc2e4b8f82ca77551a0186a71c553a1dc4c6c5b83a9194b18aa661f16e096b8fca84229a6fd4fe220aaf2346714666952ce6ce653ab8b16a7282f8d8a8651e7eee762027f69c0e3790ec90c420968a50ef5f3fb3584d10e627dfb25603ee356ede3f1795b4e0f3a6b774773dace4bb00d725a26333e8de57fbd8487dd83764dcd094a4cd36f4e22ae1fc7df5011f4853fc007d8d9a922d1abfc16c7499736c2216053d8ab49863a20b7146bf95867adb699ce3f12641410d86cddbfaf4a8cc323b09b17b38efaa4de1001f1ee7cb0ac1c6c661fa02b35ffd6e066dcf55a8c98e727d7c72b33b28d2f825ba1f9cf9e909c8c8b2cddeebededfbf384616bee81bcfa15ca94415a6aad74c2a8eface8f1c58095fac55504c7c0ac2759397e567a9c6651230fe86e23883a3a541abb98d56a091b62c25d74bffabef4f8c8a47b5be0c27d17e89fd77b12753c02b26d59e46bab8adca0212a4b393d553751449fdf350dea45dbf4fc048eb84e0323c86fcb9199681580063d661f977c98454590bafe34b6634bffc7d4b060727388854b495b9a0d2ac32d366199334dd685e641b44afa22ec1632971f83b0cc545e5cc755671a8c6cd711ee746eeef984e28e36f5fe895c148e3d7f1b730c84b4032df94e83e53a24bb429aa8369399ec0ae4823d73e30fdd7945ced9ffd599d973e4a047c817273988e7344b8d46ec3bf7179e5afc1583336d0db55fc97f3d1cfd706d3fa51091971e3a8f698c60afc71ad9dd1f9e29632428252c98099da508b4b6b3ddbe4ef27310bb1f6710f095787bb248686dfbe1d567b5e63e5035b4cecad809a89e3b9c2e20a37d4af6447de5ea1be0f5e90bb53a17bd1826c8720a28c5e45cfb6836a4ce8971a564e508d2bf4ede16e62359ff596f08be40046b83bae034c30d1cc83889db5495a3ecb899dec184c7321e226802ab5fda115e387b1c0a060a809c7108a65e524a5cce3e415211fbef961acae84cbcd1bca883e2edc24734a604cd8b0dd5975b69dc6e3d64a01c7dec800aedd23f728909869ef88f291b3758d3f646b5c4b84c889c364046455a853372407faedeec0fb71793de2026864d9510fea48d587e12887c80e8df46ea6fa4239104081508a2f8125c43f67af2f8275d591e12599a0151e4adc8f16c9299b3af5d53835fcc0c57418ad0c3b78f485bfe5ccfefc7d6eb20f2c8d4baf3f5eabef301cd649d5167de7895524cfbced4601a8782ead030baf0862908ed4bf0e0aeb9baa0856fa3d1c473aa2ebfb108157643e02b3e94d7fcdde3e4ed8c70f3904a8bc17c9e6be2aad725b15ce507fa8addeb6947da55a3cdfe522a00f3473b0d3c07ca503115de0b9b590c72870b876a0c5984bb46dacdb55ba40e69232e2fc0ca7a84090f6485647e164143a5e2f88b39314121aa77bea7ca0aaaacc7d7c1b2ce0193d8849bfe4602d242a6d9404c3e1852a6fc17cb7164d369231160c047447d7ec517bf13e2caa43e7fa98c59c5a221e20609954825751fd019e1de026955c58cd96322fdff7b81e2389e4b92c1a15f819325b7df750c57f9debab71bbed41c244e2ba16ba48dd793a8d58e5db0d1a3aa559cbbfd7e73f11fde4309c87bf262ff7cdd83d6861e6e8652466ba0f649ca7b70ea434358147b002324e5a3fba051a576af863bf5671cc1b7e5d27e606f63ae98f032533e7119f5b10a651ccf619ca29239a1c62eaa9a265db10d397d063afdb9e4a9b1bcd929e57e1a54a943da785954c5312cd8763d5e379d67b9fef708331218172f40fa76925e9d55fe2d22932251ff64ca76e3979d2456930c29a1b93283f5f43a42fbf6a21d9bab7f045ab97db4d56ed7e50e1d58a1ba9c898caae250475847e07e67f799a7d38eba92dc41638ce546b14c29278990f35a065bda0433b8b02175f4bb358b2dd3fed5fe4705c68280a9c33b2f1f74cc374369181a2b757d82eee214931fd801af2fc9219b6adf5ffd7458f2725c3c197b985419f182718169f09cc1d7b660fb0cc4d24e500f858226e5f8f67521da3c2b67640bd25c34fa21f790ea6347c7bf4e8b6bf5aff5545af9a729df242938818d7546694b102db0e588742f99acb6ff4e6d256623d3fc4df7ac849c51a9949f6b48208cc6cfbd7444b25c8bba6f717b078f8f73d104b58d520a28fb9ea40d8e9648f1f8537293758fbf67106d9d36c756d5aa2c6cf636373161926dd65cf3585e5d11dde0612f039f4cd0b0a55ce9c5f13fbc083e3deb82628d61f496cc62f0bd7cd5d6670a8f2eca05757e4fc86d45c6de8329cc14de798ce4ce502544a8039410245745bdd8bb47f2c4e04468b88d2a4b3cf329bcdf9fbefc874707398968f4f6359b362e3e69e624d14eaa195c00d38830f30d06cca7a75216a4289854c161c25a436a661a704effb4b91688f8518ea8d29234e916c55bdbf11fea1e8548a2775d96ec175d80fedf0e6a873378c959e3d5f79519b0485a958be0c0dcfe5dbeb77b35990e145678fdc51ff0621668c0cfa8b4e492627364a49fdd377637a229284b46940b04085f425d8066805c77fbe0c6970ccf8d590011bee119dbaba37cfad65f6e76ffc695231562bf329e55b157a4597785910ffcd1eb072924647908da17bf0e70edaf9c6ec7538bf9ffcdf842aa7e63d62e0b3dc0fe200b140dc15a4280377e8998e018924c94ec314fe67af31382b629dd6c626a4015576152d71f1f572049177ca099e62b84100dde590a4d95169f37ad00f2e8f8cc3e1c53e5efa12ce1a620b975e86f8de1f2abb7db03d01ab3e034fd7a73a6e4991014eac1fd2de304c2b5703bf09c847421a6354c886a3bef96c20ea06c0f5f2893b73f99eb69b795ad7ee15561a79d18b8e5f7f53ff3f23c9f9b39387a8c34c2c3479acf663f442b6f04ef1b113ac6a52b3c2093f003e25a732eb4c95cb9c82c144340f516d11ffaa5e97098a996b03fbe3b6ec9db4fd3f848d42aced46b79b54485976b7304eb4dcdd113a8dcfd9ed971c4b7acc4d35ac08b585126145463458a698b69ea3bceae7db2be2b5ccc1779c24a5ef7c33b056d4111ee2211f50f2b08eb499d88412a02505179721e70be56025715e057c9af8143a319289cdfb198f5ac11ce3f967ac56903dea57d252f97f2cd265aca5c811d9685de5111218126eb1e891e3a05aa9222fcb5d313de69df39534cca1437f03d294c755b6ad59205407e1e854d8bfdd85d63908f55179a5560c35f59dbf3f8f952539ee3e679ed680ee77c4cc690b65a688f02a0bb97666208145fadd6ada3e07243bd10b5b751e8a2ea56dfbf5e393468","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
