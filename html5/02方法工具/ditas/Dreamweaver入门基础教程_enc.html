<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5485c66df45203aee7c797876beda053e64b37d0c72ed7da228ee9db50723a060c14695fad97e3fcce3f3c0dd8a34fbb144d43692d413a6f3541946cdef7537550a3b0cf3f7363d5efc368fe4d209b389f94f3a3cf516a3bc6c420ca97e36067a2cdf2a8e7319aaf06957a3a7dc057b13adf1bf9a0202309761343af39fe3f50955310089fb51ec3187be0b564341e3005440f132b583f4de4b8154b9345d5b2cd558a39a55feb41c4ea8861aba52f86b4f3f01de1c41d0151bcdd5b3c51e7a24a48afe11242fe987854f30dbf9a899838f3ec456a3f917f823c87b6a68f2c8c89cfc6a332e12ce3e30ded82863fd70c42c1407441e4af4f3a534f5c5ca522b9e01a7dc92ac6832a5f01babda1df47f295eba9e989f7daf52d9dd8c21e46bca74886d2793abe9c04df44578f5aed660def1cbc44bc5c3d3a1c5ea9d68d17922e249674a21ec165fe58e074cc30507d6a997d899a2704a87e193634bc2030da5d95c23f40a70943a5b422200c65601590c6799f62727543b20b8feeeaef00e311e928f375b3abd73206b042401752e2cbf6e75f2a7064554b267f6fc5ac23c1d65a9b9b02e28a8e13083f1fef093f9833ca1e6a2f33525a4937a3985f8be3635e5753654db6be602471f3d9f01384dea5373042bc06655fe0835dd85e845bfc35a037903bf405400c9e32fd692e4124e1d221725494ed3e613c29366aeed25e478fa1ab639ea89d287105b375fffad8adc4300948534831c6193dfe76e997962e502e92c358724a177aaec6f18b6aa47c2a8214923bd34e066ca0321c7247f631b4b27182eabba9217ae00c5802d12a2fd9c8559a5f38ed1a5feeee4fa88acc84efa549118a9bd478ced3074e468be10b67d2840d9613a912dc982a7aa8248a253610110204e4f448e9a78575be8c041150e7052f46828a850b712adf2d54b9ab70e6322af2f3ab5cfc873e2313aecf0e634ccb7fdca8f31a03cc0afcc28e5ed7daea3cb91adca1ccdafe8ff46961a798955c75a2eca75df5e83adfa5645fe80c44c3e5ccf53739607bac678e8c40915e5863ad0fce229da3d062842db1d529f9790f59acd50c1754e1e124a9e4cf28facd920cb6a5d540044d436dd89971af07763e9f43300a9ad3bc3a1b5a34fcd4f36c47b7a8fd74c3290e96b446e869219b260521413ad9ae99d5106ff094bfc4aab6e89eae713d6720386621086052a75ec6c23103b31e31d8e73ac611af12adc33e11b25fa271ceeab210a875c83dccf958b6e402370d6328145c4c6bcb51e58320cbece6f742433c3afd58a621ca7b55365a876c3ed80fe07a4980077bc7199452ab8fd878181a3d581d523bdd7310d98ea563be8218ecc6bb9660c39688567883a033233070b9a3f7c09bbf00e2c2cfce2b325a8b84894de1485f8fe90f835cded5f8d7f6c0bc4125e3dd3b7647eb9eba9363f27f0a34ad1b3ba7578988468e2014c60da9a33f7317456b3afaa31a25ed8704bb49ce0c6cf69a810679275616761e5d65009fbd7a519a8719d544512343e3a8297e1801547c0d59c80a087445cdb1e26eafa0399057211b66f07c0b0e52e21fab52275965a28cfa747eb13fdd3a4f2b3e2ed7308f601efc38f4b98ab1cc40f2c07fc2555e1ba6e5af20395c186c75157515e07e0550d7890d95c96eeb750499b10e5fc3714440c7efbabfb294c1a212459c962c3670b588fe084caba78f61bc20bf711b314070b5da1ad8a1dba858254601b097370a254a93e58540834bf7037a81d7b473aae6478f81f1d691e58959c6e46d82c6b2a515d2dc497bccbabdd93ee3cd8ec7134125252c96f9d363d79cf03a39184846e0c123fe9c3c39cf166a1e9517ed70d8a3daa13bf7b7bb81d4f59df42d2b121e2d1aa8ef9f07bee060185435181228ffd7edc5aa3694fc1794bb49928b393039a0d091f2dd246af5241bcf9b10e18b377695528333a97af6a9a43b67c2c22bb0729b224a3ef6a341f58402177b87bde6ea64370847e82c73f6512af6beb3d47ec45cb6ecaf36383c26d0de8cbe82106a1909a155f222fbc533b32ddb5fc87f2b7fb65a9e890a3fb60b744dbd1fb2f9091f6d10f5e19ebe7a62f005bd32c686cecb57d78b5aa938bd0cb15e17731804bffa5f36be6fecd506ca8a6b109c986f223798dad54fe7fd11b49e676be64001b5db2a443d71bfb950f74662c2f556064c358cf7ad378243b935f8bdc832f87e9782c8dc9130c91c223ed05a3b0229a8a91cb8bf1dd616ced18a48097c2f5b3e3feee8b81b3d4539e74a6ffafec95b67fc32902dbd2da335f77446d6fc030ea22e11e6cbc69daa34068e0e72b00ea39f2cd7138201720707a559bd1c8c4cb82e797d25b7be58646a603c21d2c78a52270d41b1083d0b516d7aa494dcfe3487195f8cd9ab7a525463016abd7a162bf0f74d23b90cc5c5d190e90fce4718bd2c6a3d5cc92f35489d8152780fd72032019da3981cad0e4dd6016f7e1d30ad83366a8de28ed42c00ac0e9ec830d7dd8dc17a4118de88d0c96f5abf4b1b8bc12540357f369c1d864c394a07e14c4f6b9f2926388e1078531692fff42dee685b1ebdde9f9483c9ca33bc4c445148c461d28a4947a696437e220a91ebbe9ba49ce86f8219f48b503b6a940755c18293f990b3440a6def75135fcfc2522b134cb3e4e7d1b1cc0c0e82cc1c74b1469e52878b06560c7d0c33b72af4ef4059167712db52c14facfd7c97e414c0e77582e37c944514e2ac1e49b6d00233bcf6a117f1d0be2b873925e07b38c6836188fb926075777adb4341bc018896ef1c6757b30ebdc171a72bdaf9b3fa3698ad0a4c0124278f2710d7f49641a7ad919478eed3ac177e6b1d32112bfa32b33f0be6e171e4183a1cdb9a14086965b8bcb371c9387b92c1d2345e80527816023c7dd0d4432f9ed1714f8072d487c28906fd357a2bf134d2009740664c967ac24a765edef51df765b00be7c6676b877b63cd907c7c71352f94b77f67182d08cef89538f0c0daf0df1725a135cfc25890b6bd7604c69e827f1b3eb26d8644241160d00e3c59a36f3d7ede7c9b351846c9f4999760a937d7534a7d792869101bb12650313cd482c025a2c6ef14be1ff4e82ad781cc69fbffbc39c5d3b110dc3d4d1ad597d19cacec5a49a8cadaf937a27304270bb16dba3eb3078082666f573ae35a66b56aedf14c59bb97bc3355765fd5b8970ee3876a089390662e2f305933c13bf20b40ea427892e5e8e534b384da9397cbf377d7ab967b6b9cadfcdbec212d0d124cec5595077cf125e5ca7e256e266c90e4bb709ee609cf043a7f9a6d5ba95e3bebfc34ef09d3d44d888a78da3e5bdda3d4deac12bc513d943d62c80825ed08b44a1ae0bc12d89e472c91a942268ccad01fec78052e17f8c00598b43d0c94d7805a394a735e03c2a871bb4fbe2f243cd1f781f154cc3ca6e22ae5a838be88ba946aa3e431ffcfb2b0e8b991a815be8e5d5ed5948c55123dc465574e78a5b73e42a96409195fb3733c4666d5079c5196fd30ee2f259e2aff6d4eb5b1e1733b8a982222d2df0941f295036ec73e01d5fc190e14d6bfd52e8713885449700fa8e8101fb902e072b9e06814c9de659dd3d9b32c0a1df59539c5463bf6466031eb52c896469bf79449e594a41d0c9209d3dee8865e3ea4b0e76251f1abe3e6b78adadec12f20622fd9e1fc60c854873878af46490364d0e10d58905768e50202c2255ea7f15cc5b3694e7dcc7807b9149e2a53bbe1b7009252af97198eb34e884668f9b96ded9ad67fb10e9c19fdecd6c74a2d260d367edd1b8976852a0a13d0f5f9d6d516a06a052f00aa2fcb3d3876ddb5be2dfa2634d4d0da7c35471bfde64bfe01347e82af543ce3ebd9816aac184cd33f36c4b97e7d0ce250567472283f5fd10f61e30d01138963332b0bd388ac8743bcb308f1788ce01caa75b97abfa754e560d5071fd2505cdf2e597dc9d6d6f0d19d48d92a87f471dfa9cd4fa5997987803ab62f59fc8e4df964af187ca9da9bad9d603ee86fbaf00687a842ca3c6b50fab9792d1e3bd22d29ece7c56b5c53762b0c274985a54bb093534a9cfa76d85b96f26f68d52565c228825bc675330171d2c66390646b2a09f601006259fd6c343e86c3ef271a7a3a08c5895a6abb8caa0ba86b450a0d6d9d27b469430faaee5b6ac1797ef57b4d917c4811c15260f42ee2b106b4c7c6f9d146a149f37a609586694f9539864ba6a9066b6729afa29d361ecd02a2d3eee04492a6486b07bd70d64698c7a1e1241d67d9abbeb3ae11a8ddf58b04bf43824958c92aa5aed3e50ebae89f24f8ff80c0586773fbd0b1c1ba3c0ed16a805ed39e8c8dbe1288cc17e626b7a6d44475269aee4c1b36e5e82a2c5f90a146813a328115a1c53a83a34bf4f38528e741dbad91d5ce097cf99fe09d6d7996b430210808fd880914e92432f1e370e93f0973c982fed85c58f6fca51e52dc11f3c038dc11fe1e96478d77ee93fe49beb0bff8a9e03ce06feae82156cbfaffe4b586c7261bb0f06ced4aa48b9207e3df4c9643e75a6dd720fffdb2db97796080ceb5a540428517d901567004e490d64439a10be09e0e1beac0bb08678f26381ee7638cf4b284ed1a94ffcfe348ad4847af730ac735425caa9c6317e8a881e6af840f694af23d9244fb077820d88f6c451a333c6d02ea6ef6d85665629de6f46baea810bc8614c9c1f7583840f67d275a12df4d37821f9a466d62c707b212b73982870591928cc2f72c142bfd17e96cfee4fe216e15657a72386579682afdbc3108633d24bd78692cd3aa315ba46619583a949ccf9442a0545ee7d1e47c633412c6efa4181b8ed4c4a9ae848b182d6d1de5e5c082dff348c5840d298424905d02d3a1f9c1458c4e067071f079d3d5d77960fa24c54e78019c1618200321b89eca1390f5b87223a73177a44ab4f597994071fa4ea28a40fbeb1470749c2a0bea08e4a2536cc2769b076dbf780dfc6fdeb4e9445fa7c60166eef23ab306fce94b7e7b2766b2a57fe4918cccf6c36da49d03fe743bc45df567d60b18de0ebea05d9a60900957cea1228cb106db0b4ae77d8a38fa3520f2c7c0f390e87ba0701d25475eb2bacd9a3829b5650af756f2068d3ced6a2e287adf8379029c32f36fff76cee454be0e90c3a1a96cfe40e6e10dc4f42ee82a07ff176d0b162ae88b9f9c7611f1527ff5820733bf455e367f7288c6d8af95fb79f8b6a16424f6b6932c19cda0d2c4388d07bc5a44d199c75a9e183775b9eb462f0e7291a5d76bee1915cf892b42538db56420483323253dc5c8e1d150b2daea89befe77f661b882b20946c3f4a4db3c984fc9179d8486f3a377e50fbcb7449d3d517fd5e7bbc5d29739d34359c26d092d40c4fd2fc836f196117020e16a3934ad312d9b00ffe8396fa9811f7cf52d75c6211680c13445645001df3de40288c0343fb7640da42e486335b1afb63063b172387eeca49f4eceff497dc06eb64dfac7c9edbb642d91fd1df70defb648157629a401c281da31cf27b60bb98893f7b69f1775679ea938f25af3b7b779ead225a602c9f4450caaba9117b9d604ce5afbc7d029cf9db32b11c9ae50b3fd705b0d44331c4f0d06e76ca68003b9bc718c5232f04bc30e94531c52f2cd06f422254c2aa469ed8514d2a03edbbbe755d30095f2bcd898ebae6b508a05146b4cb7f7723f79445e02c0391715c337a2f1558850d9213c5dbfe71bf467f171e8f5915345ae23180301cebe5e9dccb83b0b7f1243b1b5221a0b205a51db9be0c8887979c39c22e8465fd07aee99c2469c9b8e366b94b02e9568653e89a12477551b641452fb8cc4bc766f3605e9c46a4e03e83f61c981322369497656559d7c94939e7c0cffec5355fb1d686f87488c2f2c8b73cf7e4a060bf538ddae300a56f8d76c27980a992d9ced8e7ef3ca23d448d10cfe8c9be6d5649cd8e23013c435798aa706c826655622cc0e716f51e9d02d3a94f8910950d15bda9665a0526aa9f82dd21ef4ebfa1ac3b862dcc7afb0a757ea87d8f9dd35cd20235d23bd580e7959686460708c8aa3f2b831139980922b61662b12db6668f913d129bb4f66c63f10cd9b5f7cc1de32a6f96496b15527722ff2061ed07420137be0299b4e68f1aca7ffaf9d8673779d290c783fce65f6942da3bd6f3f42d7e16131db36ce39479ea399af53e52f6e9e55bc15dada9aca9c08656ba2a53e4e264045a258dad63d640f256a445cde917c49effb4e301436a551b181db7227733cfc09560fe64dd1f4c714e205cc01ef8911cdacbd58da5cf157a880ef525f1bbbe91ea715df48dda293df936b7a0443fc5401b1d91e0573655f9420e759c7339c29e40b3413ca2a654dd92ab543d7775726677397b3e1435355ad865b3bad0291ec8027756de6f84dc9b90cc26c268081a0afc251c3eee2f83fa87e82e3cdb3e11644322e0622c6a2654bfc35ccc03d974430b66b992031dafbce2a7508e8d8a566b5e48e9107814933c3d77ca5e04d2649b69cad02d973f0fab5ef8f54008de6b3c9949529a2f6234a5b2f34f913405e7cb08392c122cff2285aa7a0ce0e8303cbfd049eb2971710ae9b6d71f4f2774b2044bbebbcd59a5d48d22ad33e4f82df956164aa7bc71c3adc7d17beb5d5c31f230c51a3f2024647b6760ba7f466fd9dc67a2fbd2e7739c047b942204b9f324954d1e03538921a2d88ce266e36e09909d22762aba1c6e1e931e65038a139832044c4f9907d328ea472c49291845028511ebb3ff060dacdce8d20cd160b2dd4b226f237657f4a42194d2dafbefef1cdff55abd4c3d30d9a18bd981f2900064495e44351bc8c8ab4b4dee70e50f0fd3cdb5daea13f00fcad8751b8fa9679cebfc39a07dbd93dd3095937d63d5b44171d7b8063e6d52e94d93605b416be73a4af0ef661d9bb8bd0e70e6a2cdfedbd52e5671f06efcf3b3e248aff415b221eaae2219c17e94a9a0f81c62b4d8a0d378534c039164af14d63d94667bbee39e54610ccfe37b69930e3d7c63017698c1ac17560fae4ec599d1a0c70256402155e01e4e5fb3f0d4f1ebc97bdc85fa68c0616984116775af09847ba76a9c99040e6bbe636fdf93eb74facacbc5351474c078c5d875f3c3bcdce0c33fb99c69fd43b338b4708d13af123370fcb9f8d28206343d41f6b0e58223629316239467c8bb586bd852ef7a2700b9f109b5b2da6f8e145e7ea17d8fa9d1d09894b53f2e157b20d2e8483a8dec7a08d94f880fea4aabe8d02823d45d5e3a0549d80d1f22bdd085a49f0a4007ac831ac231b4ecf3bbeb60e60c8cc9f14aec2b92f3178240f02da2d97856269699d309fd98feefb6c9257969eec92d09eaf67eb2435e8d79f10c4ff5a4103452badc3963b5aa81fb2c44bf696697aaee2ef49eb589fcce32a6d517fb6f3d7985e70ef0fdf6e1dc4ca32ad23acd0496db193360a8d0da71257b7916fe5e05f1b52972c86c7e453cc520fa0aac8d5d1006c4407c2e5d34f33ebab21c828248548c351d6106455250d49301ead8b1a2ffff291109efd91628ab8003d66e235588d71ad31cf29241af864e1f4dc2f5863092541f1fa68de3c2744db623a2525acf4b946988b5c99eb693aa968a8ee3ddcfd89333c0d8aa7c5aaabe05f73e3fbb44b4b5bb8804762bd2f19176004689d8507336fb8aa6a4123b2006981112f8308cb92904092cdd439b7c989e928a189d15bcff6b654894f7858888fb107732c3209403c70f2eccc0ebcc4030d7e11a7340adbe84b0492b675c467ee37f7bf35914b6f38ba0cdf7eff55fa86ca9b52da64122eea8e9a3bb85a081f0497e16885bd1a9fddcb8c47a8f26c600dfb7950c35a0c0285cb20c0722366e350b2e39136da2949c8cfab75a03ce7a33aa3547434fe3526b40151b5238fb5c557cdb23256d93f94b34bda81f62cc3aea260ad9ef82c80970e3ed783905dba9f62816d73482db72503cacaea5aa9c1d369ac616a32f3f5622fe071216fd72953e65530f2b4678bda11e326fcf0f40bc00e407aba17b06a056f5f9a2ad2d91a675d1a2e5c1b57c63dfa1dd95f98eff43c48950f9eaef2763a956b8adeec327ab1da174288545f8ecb341146f0ad3512d94ea67ef7ff3be7bf0490137addca2eb696776de4911649b0847cb6265e4741c4a7aa8200df139ff62f9a4f18db637f519732c09487b1f589f211bf2f03bae17c34366ff5dae348cfe4d36422cf3b72856cb84a00265449175abd9dd9584a689c44031c191507fd8e0674f8345199e05e1dae7dad9a6f6e34c9a2342ef4a3190a2182702b6dc7fe7f90054662c87db9b3a543b58918ce97daad0dd9dd7786aad931d0a41e0ae10153df6791ccdb9c36cf014cb3b78ae521114a06fee5b1db150d9049637ac15498c638ee07cdea38827fb93c3598e723a71e6175a16d65bc70285b915e774224dca419f641017e87e6b36888bd567eb3eafdbbd8eaabe512c7a249dc202b34dee5bc745f0dfca0802782dfb307f0cdaf0be9632dcf83e3f809f6d27863ab7363d63d2cf0ef911400cc942a9148c65c361ca76c5a6d33f5d261dc933911c0504adfd5df9ae8f8b3c771254e813d71749495643b3e44e905a5c755a7cfabacdd54e46521130d432e5ebc432deb3b39ba58c0c7ef44a542f1beb6c9231d2bf88692a096d66a90ee343c36c67a26094f98c127d71c61fd4bd8032a198e238815e9f9c23e60bd399fc3f1387b43f0ba4d134390c222654fb1dffe7b9d1311cebfa7989998436c4d6cd1974fcc33aa2e76fc9cab1e051bf058cb2975cafbc792acd7fcf7f04b124c16613ea18ab90a868664fda6f86c5145caa05bc85dc69e63d6cb1d68727aa54f026ff42c58b27fbbbe4a150b1ffb91b9526f7ff8b025447e760c89180118e027f49f961ff5bb6cbd5d810fdf44934f0bad4fc75a431d7b4f661e39127651f832a2b4c08ef5999b30bc9b3d345fef32108c3eaf408265355b7fd9cf5439513948850312a10941406d971e2e5ae132291aa4f6ef28985785cc86c76c8bfd1333f9ed9be5740bc5a0031ab27cf99cf3e9bc5b4a93f0811f667c6278f0c4ab426e9fc3c57065040495519809454f8d0292fbeb20a13f6defa0380df623b1f0934c8f01833984a18025bfb083431c115737ed390cc33e92238e24587580e766f3ae993c91a3b4b0ba930afa1974d696c0e08ef721dbe4dabc518e336a0139c80f95bd233874b282bdbb289c18817f5885021ead2c87c830e1d942409304c6c6c71832ca78ae1d54304842d658f4c679c1d87010334404cd2cd7fccb9c0d61e78990251c766ff0f221a671f67fce8da275b67a0205080a80d52150c6b51f0010c845c3fc4b04de85fa21fa053d354fea9200536fc169d086a2db269e44d2d3e62f05cf3298a044eaa535995152855dc0708528a5caf73675d2006f145924ecac8008528f7b2c50842e332e45feebd096b68ee642430746fe9746529c1c57a92df683a2d65b05a45667d7c10524d36f0bf3dfa421a9212a3e334ab11a6225585d8804e78b83ba8c7fc232712712add087a0a3f1cee0e13a897ed03507c118d59e01d529f14a599bae45a923e82699e3557725e38ac394d53cb95423732ddb013c09fbc0a69e7a5a8d60df3a3d49aa9e8badcee3484b29c69d8ec07dc967315eaf235b23a4f8bd25c199840c8c0a6592e5b215ee23104e2f27bb502ce9eb5bced308cb0417239f1d87f5b53ab98eb92b6479b8650cb196943ebf5f8c10d35858865a6e8d2b0cdb2897dbb9a3f4e9f1d2ba406caf39895c46c48dddd939a5f730a597987c8e19b3cf78f73cbfc6dbc35661e706ffdae065b4208f416c633ff74c23b831c66ba37428979f653d58abc2b687a9955462cba722c1f85e08970140ca0f500414d6b90a1d7edecf8c06d4b3bf54c7e12de61cea49b412c0fe1bbd789fc5815282c2600e05c053a083b1409637329bb180ec8d32571e3874fab1fa72858373e774453bdf6dd93ebec1f4ba26212546ebb6e54bacfe1cd8dc3fda6397e41ae2b012fcac2129a3c5265ca9050126b70b345d045f3ce85de1a4a974a71eb7489cedc07b9e642e9bad9e132f0785f1c9bf9d1b24f601cc8a29441b5d1ead3574c9ca05883513fc4a496ef86ad636985f6a4dd58583453b7768e2d46ef80192d69d00e5aba718e8edf92a83b9970f9f1386fef65e393d97ffab9478f2bf7fe5137be28c18342f9796f7ee399f2f4717ee6fff72199139ca59bbabce57c02a11261b00b16a0733e202e9adf39e3e8dc6a2c76b236e6f2b5e5cbaa9c231d20b6d2bbe7c1d5921e068ead977fa059b67879ef2f82a17c81015049819b377c2baf62b434fea3be4dda33cc4241a979ae97890e2624074e34374ac15a06361e4fa8caa738591cc394432541360b0895d7f81e91c23332aa8c093dbafcd4382bf673a29e0865cf8a3a7217e003a9d23eee390e248fb1d8e75279527bb97bbc5113051cfe419f4d3870f26d4bd3b971b45eb8418ab8a0d5e9a3da9367dabb27d8313e810d8f94005920e80b45770c28273be652c54376c0a2bdccafda0d4573acc54297e32b96c243fdb3d85e8447756e41b817116e62aa8ea77dceaed4ec130c3ee259220994254450507e46abbeb9ecda012e3603f516aa61e5bcd5f2608015825c8c0da9ff751e4a6d62726374ad2df560f1d5b6a9e0245e98fee198d20537e2578bf56b434ab3755127bff4320c57ba8e01d218b98d175f8fcc57e8c63142dc9a78825477446d2b61a274b388eac4a0af746cc441a4addcdb65bb9f19a1c820c2d0e840e86927fbce61e7eae3ade6739bef736cf6d006c6aa848a4a2f35325a9f49e4ad9766835ce0c63461596148c5142306f23fc96626ccd464de5cc0c44ee68028f8b51ac87005be5ed8e12884bae0f22d6722a31417c16e50ad1b30f4eea2aa4e5ea1e0470680fbade0bd38df1baac9b585e0a3383a0a8ec71d80789c098ca02f8c0a8973a89689fe96e789f73e2c4d81863a12a38a90fcba9ba2959d0b10721412ab6839af05b48d0dcea4dfbc2bc82f74d66edd68014cc16a9c71cbfbef69dfc037abed7373fe02ba97e56f395989f4bd3594014831deaa6c2ae60cf33f2944e81b6943313ca4c29d9e05b8a44bd2eda0072e188f9361e0a12f5a719770517fbff900e0fd45b37da0aebb91f7439728a3a2f08b5ad94830e0b7cf648f8d87c5729e93bb9615a03e4d5955b23bb480aea2c02cee06d7d621f998122ae76f743420eb92d10a8fc4d748439a8c485d433b8a5f0c012bca6bc09385421fc8deb35d639b8465c0d33090ef16f4ef44c58dcaed6c97c7aef03f47c4a414add316d605c2fb8de1b356349e7d8ccf20c4480664e0257e97d2a1459214d16db9bf0e68e5bd26f4854350e2a1e76b97e73e28c4bb61fe5d24a77525220bcbc097eac5019f0c98e7872016013917ab643682d3cd35d8a1f2d18fb8a201965e25db55cdd1139ec6afeed0899eb60af351c016f0ce328fc1229ab689b7f5455934a3b7b50d41351ae8ddd3e8ab905aebeef3512fff34136509cd102040b78fcd9be416bb5e877c4f64a568f954336665698461dbdeb156d12422e0ac1945ee07307c5275c53986d2eb0b6bfba3b44b810fc5a9b081d14a67114e062805c037dc14fc534301f699ea2d3fb860ae820062f597a705feaa9b499fa12ad87434128c206e4a3b4e597c35312de23767f2d617ad3be702dbd575199d1042566f233b5bd7c46462e57bbbecb5659fdf0ffef4f7771f0b321af2426469890f4a8a665e3fb221ccf56f539234861d902369e3fc1f0d4cc744007ffaf6d677b8bc2df6aa3d381b6bd28239a53879179b878513cb714fd9bb974af213dff31242f56c8311ae5d0330361759b8c0c224d7e6f53246605b4533876ef568ed8bdb877a221e6c3ebe5262c90cb3a7bee600af48e27ef85ebdc8de5665797fa8664cfbef4af8231409a5bd62a65fe2c6787530a051a0b44068e01d589a99d09ec07067850aeb504b8ab95d7b7d61679b15bd331b3bf0cd7b4e79fbc96c8bd8c8f2ff8cde1e8497b295dfe11d3a0274b1530fee5d9a0fcd6c4bddcc3caa4795521b3cb5f0858d314d5639c979bee57664e68d1fe9379a8b409ff55786396fd8d45313b743c2e0d5b9e8e6aeabcc9edf09980c1f2cfc19b1582c89ee11c661c59dde87f39f8bc9f498012e0d44007094feafb03185e34cb018f96351632662c64b2b89af1f1eff8f3d3d94c0c6d927c74f50ca52ea021daac5b768307d263cb6f8c1af1d2924cf8e5726c72de68ea19948946d1f5a99791272da25be57864279ce70895439dc0ba446e7dff7809328ff7ca64a2d9140f643ddce2c6c20337110baf6ac347fc5608f631f40d9e811fb71fc2f28023e5a860a332c1a01a37a99182fadd024ba46677d9064015a91c50b1cda677a377fd5af77f436660984605140ebeab63e63a3d55e27f675d77bc26f669fe54a78148587b887cf3027419752f4a6d59c1be94d7c406ea5ed96a5c03fb09998acab990ee031d9db2f9b0c19fbcc3439b5d1d26368cf9d0a0bfa9e76e182ffd422c3a48c1a6c0e12adae75dda995b58bac3671b9ae61c7595c39209a171a5096a0acf98742e734d559c5fc155da88e6c215b96ab513b94f978f6c9f14784953bce24efa7b782ab72f14220edea6553e8ae765d62f32a0e1b091c199547a9ea297d16d11cb4cbf7d0d7ae28ccf97a446e070b5225bc6d90e34761cf8db777d876bb497abceaa4818ddcb7176613f7053ddb57b1891acf2a2ecfd374b1cb1e8d06d1ba32f0757f7f858ec0df54c6faee090e3ee96bdf71e625e8b609f27edc2cdc888968af31bfb9ecf9b22cc0429de263f4c34b0713f860e61e4ed751814f7d26db9c096c4e0f02f884b09963ccd43256d6b33ac75a665f1b0419a394d8a2d96e3a133ecd0ace95eddc7c88fa60dcad7268766b02b35d1978e66b45fd72d590130ac29c26ff4c6323cc6f42e04798a57c67300609550caeb1b126ab6fd9824979bb4b187116498ee22be95480c1f07a964dcea42f07df9e2246ce61e5fb0c3bf5e0e8e35bb3d0e470b82c8493357af31d5a21e25be25d68a271241a5655587056a88e8ba9f20fd198319732c63fb1b4fab69751679a612f223390104f09b8c046fa2acdd80d093b8ce191ac4a6d9980add1a93babfd6534b8b5c5127047ed3089fb72d67306ba33979b3121df372b99cc999cd0eae627524d8cbe26ee1003c07746e74220998ef8d32c65c64a60a16d7126c40bdcadf556597d2a339c6e0892c34dae95df7ac1c64c8b298ed0d8dca9364d9785afc8ca8c8b36469ad9f1b750eb120375dd99edbd220b89e2ca9aa1ab41544699535ea0f107c26449ad19d79b82d4d049528857642b7664df64cedc78d9cfe819dc82ae145d93b108408147fb066ebf11a06fbf5cc1690f8fc1daae825996e512e648cb2e2a2537173c6a16d6069583c13fc092d63f06ac93f1b61fe5facbd839dfe7bfd389dda2f380d1f11097e51be63f41ac1ee6d45df003fbff288f8570c61a08866292c8b3b16eda7075904981c702ca58bcfe07f479db370ddf2c394896f908e45db42aca8656e107898b382247dabc14a48bd2bdb1abdca63e0feb3ad","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
