<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"afe6234fba260a77b58a5ded28253feb2ff88fe67c079837539478e3afeef187a6dec91b4c6e795b7199274c517d448258bf757208218d875b601c89c09bee7e919d35ad985994d771974b9f7f6a90ae0cac57a8a24eb4747a84bd222b818939ce64e9869588502bb35a7cb66a1d95a38c3d5c3d4ddcd36e0a229d610c78d90636233492b5df5021ccb4d41275b546785b346571a5768f4ce10f223845a48cca03292bffbf0dda936fb328d349f0158d23e67157074557e88fb4aa1eefab71650f2f2d68385c95fec03bd62c5eefa37f161e7cb62eec199fc05ac786e4d341e0528e2c61df2bc9b4942d23b84b9cb3dee2e7ef119f0bdfb19faada04bf4e74ce9139b05fe481629148cb92ae5acd93efee1edde9a154f1a9e965a194d7a44d1c9794101e7cd6617d1d71845201d312b026edd349bb017afed2f3c9c88cc185dc4c15a050b09307c7fd8831a91530856762a33bd7e4e596ba0cf5d0a7951facd52736cb9e347922976a2b50f942f6fc0aa1c168898dc3b0d1b063cabb98b0d73eef93ffcdcfcccfa73101a5dac85fde70a3980630e360f121915a1285df33fd2ce7edce611296adcefb5324f12beb4c4e73aee887f6e8a323b311f32db6b99f6b6ece3541f1a8353fe777867f2bd1ec8cb4da9e84d1f51f43dc5ebb469c19cb79beef3d2809b7c250079ffc47f0ad15c357c24f85eb85768dcb3e15db12d46dc56e47192fb5f474f2ad2ad9ffbfeabe731a4c474a67ff7bf44567f1c08e942fed829b9ffab91ee497ea8ff8812a662df5f2be0c17829d994d0728c230bb7835b5016468396454e666825764ad9aa5e4c24bd6225494fc5592c594333d8452c3374cabdcd4ebdc60846d4607047eeb972ad0c0641c1279c42ab89e986b80430c61d7cbd4ad68ebfb959ba15c909b2cb46fb5db92435cada771cac11907436b9a32aa84c3992b4b61fa6783c5974f3cbf120be030e399268dc0ceb46ec9268d8ccad72ed9664bd1e581ce799fa8d9b694c1553a3cbda1758fba62ad18223d756d3c85d6f83939e289160f73c320e5dff5a7115e81e2cefd402d54adf127d43b04cf733996e826dc1afc488bd288201eea49a243618c9c02c0cf05a25ecc1087072b0ceab2cd5a20f8b786cf9c149dc8edb8ceb40e6061bbd9d56cb933a748047aa408941b10f86452703774743005362d5d355f866fc0585a6682856dfe15892cd4bd1932a35a29cc77cb00bc2ac0ed48172953233c80818c24a191ee085093624c389355252e189899f21e534ea6c2536296bde9050b62c89a756a3d68648309ecfd8830cd1fd3b66c09d1fbf942227a0d3abb44e6656481a09fe645d22d477d8ace3307b8cad279328cc7e746d2ca654326d1699eec589f253130978034eaee92e1775b05cf5d44cb3673ca3f573a27645b8c71d3cced30ff114d2bfd5e90b1aded4c5ae8b659b4a7bc708c11442beb07c4f3c602d9fe9ca7e186bb6589faa500540f073622f1831856c797fe500eac4eefca6e961623b7d94e38b23cb841badecf4ab00576d6baa497a4d7ba607f43d7747ca6daeaa6ebe14aa57c193ab036db86ec860236ec8015772f5d943925a62030b97d796d00bac79092abeafa2311a60bf96728f634d6640553a45d585fe26bbc390f53f32d3ab724424baf92e4fb482c61451f7e1936baee9df64697dcf6482a25a41672a3a4113c9ec4237b90d1aa30e2b116b7faf554c694c4e2c9f217f5fef90406f729cc6fe8847b6884306292f0b7cabbaf6ca526feb775ac468d0ad27111ddbb9c57275b2cca0aa67bc3fbb9ef55ba046664491beb23e4685d5b7ab63c04265908658afaeaedfe3220c4d689ca297540af12e2e33deed7547c15b27931bc99d4f324721ddfa8aef90cf0a9291e6f7c9f2fae95a94840762dc643289c819c50701a05afc798d9cb479c2043368c4b3b6416f559e944da064038648475b609629c7642eb1515bf9ca3765e2df52b01e630f06adb5542e27d2d954351d0dc17f4fc42a518d994664057cbec1c29900f826d747e99bb96d1ff4a45e7392b4d058684cb751463cda37af757a59913aefc0c17ef74123819c495bfee32029c55d7acc19fe8e7963c4916631745dd743f79b4aaff1bc576a3f14e7b20fdbedf7e2c0c867c3c8867e29c8cfdb1eab03f0bc19165fd2c4c6f99ab16b154d1123164931346054c23255e2fa2690f9039e297b77bee74cea0b669ee2b5279ad0aa6a0555ea25edc332f1a5a6351883379d0b0f6acd118535d79cee0501f6a2c6da25749a292415460105e4ab70091f28bea9a38d95179d5fd9917aba04ecc69addafcd437ca1201c65ac93b78d245c13d6bf7dcebd6e4f44b79f7286327a0161516ad57a08c298cc70b77bc1a71abcdccc958c9e7e99efd9e4534d8af31990b5de58541fbd8c3e3284e6ed3fda4b7ed37095d92e4a2bee6380fd0b9b6af9aa9a32251ecf2783bfc6cc1b09adc10faa41672ef332fedbfa38fb8f9799a2b0b80637db7beba640639d33a44dc57561ad7d2974ac6efc3454e4f5354f338c868d7c2efd22c6d2f2e42369f44ef39e9ae06ef7690dbefb023c214710c7e4b9725dcd841231b41a56134b802d545d499d552fb007d0cd401fe7458561b43867da36bbaa54e60d676fbb8e06d2fe50ea8b5a6622c790544d4deae823d4b030c0f29bb8bfa8a986fd14cabb87adb98a548d87deadcddc4fa727a26d4dcc43c26540bd4b1c3c6b725a7161c64c1436080f87798e865cfd776676e3923d8b15fe17ff9195d49dd411e6a2adbc24ae27f70aed90a64168d49cc135dc91e0702d6d0be6d7be5c11be010950955b21b3bee010fc395eacfa4af27136e50bc5e324093bcb2259180d4ee8289c4688df7609a3a1233785602e2337c5f34e1d18511bad506f9fca028e6c6547af3357eaed23d2167955a22941558d5642036aa99d492ed4e2dc12075afb4c3385055f3c72cc9cd5ccd3da880cd0fa54baf9896e750f15b88b7bb8fdb5d69fe68972716eb2489bf7252beea355b14456e299a46512c660d48daf147b2731e526138f523c61e0135f29db3f5593a95a52eb22c6baf198286319cee75658be1f52591675e14e598caf56269af5c75a7552f53e80e91e6cbda0caafed0199bf2612e942e7b591d9b48ec007e0a093aefa3c05f4326fc7f5eaaaea78798ba2989a4cca9c82c67e9fb4ff5e582bec1837702c3368e0bfe7d671da1299d9a80b4cf1462b5b4af39001bb9cd1193ca21e03cc77f7a3c1b30c97edf29675a0e66fb4a0cfa667d81b99d54fad7d15e3e3bbb2e200d6d54c221d69f1ac6d46406f947114ff29b3154d787a1628335cc358b7ab1cf0935bf820a86b73a9bbdd1764f4ec15d5ce46f5e7c5bb60fba9fd169b6655684ed439b3fe101c0435fd4bdbe837f312acf418cfc477face18efd9244a5b7b359b872b2b92ecf5308a9f9fa6e296d961181fe2c1b018692e866951ea7fa6b1c162324e10a543d93dd60a7315b310ed226ff77c1d03ea585738cfab43ecf16073d1d9c18fc9d95bed114c0e22e6d6e26b2be889553596e3c20f02bef8f2560bc7b37b633a725cb47a94db3e12030dd20c6b3dbab981918c808cd8eef1c5913345c7a07ab13d45535ac3d5a61f555af64f5e4a5f6ffabd2c8933db9a49e3e96735eac94fb1e03db01bcaa3edf03ad45177ab4049beb9c1e496b10d740c3e5874b38458e700fb918dca497431fb5410e65b270e66148a55101ac9379255fa8b37315b1fdc4b8ab599121883e0cfac448e6f0627fcf7e2984477f3283e2806f0f66cb0b3d7e7ff173b1d3d5dc5d8748d1e93a54fe8af30205dd8fa181f9c656fc22b6866ca338a0663b947dfec300243d54a94656bf37ce9bc8e8f1489ed1b89430b9cc912d9af7b73eef22aece729cc2fcd4a1f3244c0a05c18fdfb0ef9ccb642082f0702b14263b73e91706dfbd34b2e1f866cf0dd006e0c8619ca992d42ef587e7583bb112a38a24e9af3196330d37b581e4d61bc25dd6e77a974052e28b989fc45c0da051263624e06065aef6550afa1724cbdbaf987b88fe735c97e2c6cdf10fd56b33aa7b3dfa271ff9fc318720507bb26d5a59e996db651d7d59b3bea639e0989aa3fb305562158654f3cacfcb17b6a84a4ffb1795bdfe4ff3122c2b357b5c047cce9dfdc68899c7b5e1d8e9d65e29ff19b5a42e883ed6e0a8becfd8385b14d290e5055f8cf3faeecd54f73bd792e9a3453a48fa6ea35246b70bc32d1929c9869b9072cdb308ec1004d01423610b5f8790eeb8ec9b3353acff4ed1e9eb4d8144b5abda192bfaddf3404d5a68372110e7a9353bd107d7bd0249c55ec21c6958b04fa5c640ab873354b65d877555e99d1c22a3f0b7d6cdc6bfe54573f324066ed34bce22659c6544f4ed613c95d236d733128e833f6f149b1fdd3add720a8c3f89ac7ebfef414568c31d2ac5e81cd5acdf78227f18c36d5357b86d89502a222aed3b797f6d03bd3e4c0e648f39e185fb4fd2ca4b563cae8fabe4719ad0e94b72e5fa7a12243158907e5e38f5f9f9eca8cdd9084437bf4315cfd065a6ff57992cd212864cf751f45b146d9713381561b3a6598adb3b548b7317c94d8dea9304c8d335bc050199469050bc61f1dc4dc1e30972c7d68a73462ad8c86e914d3003eb038f3e26411e7d90213e813bf5b1b337154c1a51218c554faf802064aaf8d0353a08cd77df1e07424b8c3886fd3b20276fa8babc4bfa1ce909bace417a1d1a2a072805d106ac8121bbf7b9329f48d340fb28e61458d25b459055d124be0db55e065d6f2a85a72ca100333e2537bbe009a9e603eeb07668c73729bfcf4853927ce8bd99dfea51e0fc272199a8593fc61bdd85b656af36ac463353a993d13e6d1a28fe5f709293d15bd4e7f40ac57941a868eb7be06428e0208ada4a50c41092936b47150dbb31db0df4ea648b88a3e035e97e594680a43ccdd660be5db5f096619a54bffa32c31dbb38250120c5eef962d87dd015715e75548c5cf4e9e8ae0c4430bc48673fa8eb9187b0f92d26b2d4d55a685ac752e1f01ad6cb6dcc2dba71e1b7fc1f031213d3781c2a2ca9383bc2bcc579bcecbf7a6f0d4770bc5da8b683f1bcec7d8a8ba65761179b8529b77aed3a4a9f215febd75913ff4cf5563a859e84829fe5ddb8fe2b0249ad787a6020af977c28f25d519f9d63a38849576eee231ceb5aa8d4c41057fe01939b405d0d07233c82a262821b1aebb69f06dca22395c1efe86bdd00fb8b8f912c0003b6b4b9b00ee97952aa62974cbef9f0c16a74a409b9bc20018901bede2557ab51881d3c1a99d127366423ae69502eb93913bfd30545ff3c36acd548171974118486e2a55f3db57ef5d178d9a576164d488fdaa13deb8def8422837bf6793cbf7d3aaf1ee8e4034ec9584df1c8bc0a26e6f384e0f123b18c4b23dc3e2815fd73d516a0204d94a449881d3d190a92922b4e9ca0653a58f17b7cd526418cd6bdb48fcac3cc5f0ea008504db4ea01fc269ce77fb02d0ccf4348959fd9563c0ae32a8a12f3f21964e82aa80b1af13bbc17aed3728bef017a37a582a12a58cb862f29f2def6307ad65803865a0099de324b9d2b8b02f7397014575d318c8e050199d1a96bc90ef1ed1b18d250f99647b40695590bac738756ebcf78e9034a6a7987662487129a8d03fbf8091ce7fe39ff070217fe3232760d327f0ee16dc0ccb381ef8e1b8ee441ea42e16074d0b29a9b4ab94d7a725567538d6496e18c17cfd494d0b20d60ddbf2d41209a6e19f4cfe073f7b1137d9f5817e3c33b15069312c68032df5e31d4f2e0c07a6513bbb5d3e8aa8967951d8d8bb8559aa0fdf16869296127d3f1387f6a61c78aa16bec687d455683dd4e0d03f58bd9b8230300f499f5b7c749538be9ea9322bdfb301e3c7e9b58314799fe53fdc2cea34d70ca12b1ea07cfc3217309e4cf3d6eb51745f74217d0a6274e8c071d0eeb0db056af3c727dfb044027af0b29d4c09bbe9391f56e6c0c3e07a799cba099429a57fe180c18deb9ce0b13237e5e1c7331ba9de35d2b6f6db62b05342c6939b9b2a8bce8ba9dff14d2276f0f31f55f683e0ba378f30a357b71ac66658cd1aae57a4a5cd24ff1d5b0545711cda79a8e593022833f86efb68285134684de914ef62b2e75f6147a098e60e47131ce395b3f22a78cd1d3a9b49ee6f745a3d414c811cdcb19f12560d104b49e3ec29b0ced8de99e13408b0df3637f6132e8e3e44fe0f3327ee4b2ebdf82d47094ddb7f213f1335c1eb838d135060e0069e88ad8c83b28c5b50e37038eb6d900f1705327d7f7f55b0c2d206ef76783a79c7730c1f839171075476472bfe0be1fe68f1a05fb729a315ed1e5fe41db09e0b603321df5116e3cebf69e33e574dd1b8b42213f9a8ba48d3e5136ab5796c86b38b9a2eaa8be2b531acc3e7d041331d274447870d1bb5b115f4f2989b2764c1068b89d311d547376a83c7f48fb1b2b5fa654b2ea780262842781897c7b0a14ff47e2bb6013d486801aa53f91c3e0ee40071d0451f2d77a537f0ccffdb9a762a5e98f9cdd8be9747cbcfb1a049c5b75afdacf2fc835beec4c0b7db326915d700c2d3f2bf50d8baabad384ad568a8d62ab956d55a862f4994b3b81892301584d3bd93bc61e2c02bc77ba4723b1c92e6cb68318df28d9eb0236d06b8959de8ee6d52d9d9794ae97ae61b41e0fb855321acd9e7894a5c1eb7dc434b4f7cb0cde89d7589c81d1624e80ecd22e246513073012fc6841d9561826cda0ffc95010c94875a6e6c466223b2d1253b1e0f94f61a0345d737db349c88ef64a51932eef0386f9aa14614980dad76cb4c879c7c7ab1445474029554c9a98587077e44f86e92273270022147272d214434c9090f0e2173a54a4b044df3e27328ea3b72b08e942ea88f03ab322af454cf609b319be3348b9f674878e4370c1a0c145ed27481a8f76887bc10c7957e5e4565afed216ae58b291e987767e3c3c38ae7cf5a37436a952dc2a722d284947f6c40ad29badf15e53013f603c5b9f87aaf688383b61d2650129fcd4956511a3195d8f3c7a7e1bb83258505cfd40a734eb6a4c16f23286212d04d26535de1acfb900137fcfd7b6ce27538353eba8bd5b564afec32ec91aad4b64f8c1ea1f9586910a58471a849921c592a066f3d20a966d2fb53712916fd354cce957c49f2616889d8bde0992b74ec7a5924a3d6004a39b4b4ab0346223982bf303fe5dad91954e552c9037815e0d250d0fb7d859d894ba13d2c12784fdde0a41f3062894d5b2a5dc1a5bbf8a9cd71155b77a6a81f1397461bad750eb728a3b142a81b240095702390167925f90d69fb23ea3865982a925eddc09c427ef2d204b6418969f0e06f012174b527cc8311f6a67ab4af9d8824ca2b1eb804d1db7fb97574585f4b6ab0f802ae172cf75d6cfa80a60c2f883198aec6f1d6da556cd151a9537cba47d4c4c25ee0416fcc6a3d7189a7cf7852fb68428fca6e5fd5803d0bb9097f08c8a1a3d139f6480b15981d6b77b0061106c1165be79b9fff438abee1992c90a1bb8b95fc2801056fdd7f4f8da44c784a996bd729773430759471e2b306e308af71ac0149e71517880f9301391129acaf1e63db59ab33a2b4432386c2dd620cab3afeeedd3cc4e18fa98070cd5283906f3e2f0df1680b89b1643809722555e6e3be4368eb9a7a6d1ab94e5935bf6ef9145298f0e4862e229abb49e043c4e02c6faee9cb95d11b9e09de7f747e26df25a9f16a155dcc14e8f82986f9cdbb12b0beb60c3a5725969329edd69c2b83135d40f095bcfbfdb847b05643306c3e27b0395923d673266c24378994ca9cb5e9289e843a763ca3702cc22075d21d1b9ab099ee798240ac8e721805fc264453b874f21b7ccd2c2c01d0670487d82a057b2e087098a609d75aaad13c5fff574cc856260343e8895f351f996820a811dc1c0ceb2da8e8e5cfcbcc88848a7f0346cf32d01f517dff8286a0d95edbe15912aa078ceb0b5fa0587c03e42e7116a17a214c28cb4ee99b494a14ad1c40e317517270a31ee70741970e93f36f2e1470ca302feb3e211fc8a89ae18ab296b17bc446bfe2b286fc793fa8ff6cfdb5f7c6c0877463718dba6c37ab186b422c86665b81e84b1972516f6076ddd5f7b204eb9188b0ce1c55f86962d5430ebf3c6e6a6fbf4be4b1c070c0942dc6c4caf6a0da0d9fd5b8b9558e466c7dd395626822e465d22e713e06ec853f005cac9c9be0b03c1d3273c0a838f082cee2432c1a00063077258f779261f7d03c47e93029623691e671867676fbfbe590bfe59c6247a4220937042dbbd50f8bde460ba511b5b7bd31d97517d41070ef9864eecc90d641a59ce5dbb40368077e8fe168e689cdb3be4a444e74eeffc4248a6347630827fcff5e0e635657e941f6474440ced693ea41fe4bf55754da4e45d0c8f9214c4fb4e348584137f67f1e1ad0279062a7af1c0edfad2b5475d44f9608d2fa1c005639dc333a60d252414a9ae8980af151ed55ebdb3a294d822e1c4457e3ef0a92206f41b123c08d9a4e52d1015333e38706f9a77d7366eb782e6607e046cb93729a5852d44f3bac344ce4f3b16d43b0492bd553cd6fa9edb31e03faa7acca8b75b1ffe81718a66085d0282916e73a03cc5206525cb5846fcbb12abf77882a10bc541457843523ef9ee4927811cb32fd94902739ce1af4783ff6e03716c371aadcb959ff9c847c4228fdf691cf8a46ba3d3a1ec1453a78a59d0840e7f2d35a6a528e52c07a59f95e6dee8cf935886f11dd805277053cc861cbe78dd0b08515668633be650390a55ff19ee5aaf503967575f6db6c44293a98b5ec642d31f9bc99e313f5b0fa039b09b555bf231d40ed9410836eb3accb78aec71ac35a4e23800a55e476a6bc56901bd0b877438dc1e7e8d1145507a968e81b555fdf53a23a6f7826269f2b114dba0874a04f1171e6db0fef954dbb918f8aba572d4e8d57a97e0784705a89fd45c222bd0d1f2d41363435e74a8a84d56b74cee425b80719cbffc0b4baee19fd9bdb243186ef922490b9db98a4feefe3d6a8e6178253dad9906233fb30c2b9b5e166ee61956e59e2ffbc0e0922cf56f7e3306b1906292d76645fc71c1b95caa8d41b932642d795ef40481cd53ff28254ba998653813dc3aeea509ee645d057570e7486d332236b482220c3f55dd4f1e59656954d5daf6183d063f6ed80c0bcd19f25898990aafd104d483892973de5bf8a6e9a83e0beaca09ce1236b8e7696608719ce517bfe4dfec177ab7b417d502b032ede0ed5ae2da56e1d81cdc5a97b43552f72ef5f13fdbdff602e74352a014e67cb472b47beb08ce666186738b49a15efa9508fda0a62388ff99bbc87148fb80bd62fd6a3bca9d8218ea5cf4fcd249d528b6c91caa214407b24403ed4358cda9e3347eb3f1860961bb2cd017c4f32c3809400735d4b91909703838c7e00203999a89a5e6ebcba84a0b7e93555ef7fa068303c5ce23b4be3b3025fbba21609aa2ab59db16952d598e73b9c831a8d826de654e5bb214aef3d1f84997b6a6ffe0d686131280ca814c889e831dc9085a74bc17ccf1194c48b54b9a9a4f3949d106be3bd652a3186b35c1bae2354c3c51bc36b96cd21c101e81d5239ced9b68d676e93413f7f803a4dd739702365e7a8eb04ecd9ef2dcc8001db7fce67b4425f0baaa18d9a6c88e80fefaca7398d865e937a52a86cd2fd949745f6577d02e439149cf8c24e3014ba1c21c55fa875c48405764775f48b5ecfc488725daec4c2bb8a2fef1e44006063e54d2b59d86a4e9c2eccd9dcb071f87f938137d28d48dfa423d987a044edec3a89ca208017f8302b2b93d2b6ce691dc9090858d2bcf1e999cae76bdd5bee3c9638afdd117001582f59c8e5bc166250394af2d5125101d803fa43a00a140c43530227d83e6bf634d3d33d665c97954d90e2d1126a203df7f4d40db721ff406e881b871d199515b9b70b5e92b9e5ea272d2baff32419591e245c45437fc09cca73b7467096b2a98d70b8b1f19e4f73a2d5ac25f614a6ba3f82c87dafe9914d95a3e5f8001fc4c3c306153280e950899aa3f524a2181ed8ed908aa7203e494c48acee540bf4abeed67e02d3e00a899d76c011eca08e6e91adecfacf3496db71f782176e289866d09e8625021cc8ef615c30050d593619210b8ca202b0809c3f4979e1385c8c259628d1c8beb6dacbf9270c6b938dfecab7a3c9c10b436808397b18456e51e0443efb341d53246072b53db520268e29e1c5c7520ac9326ea92e08d0db261d36a47e91c2b77c72e851de9ac3be9108f89b7844353c21ccafd7f54f3585d2a65cccfc06cb71971b92e5de98330f75ac688fdf575b987c4cf453573bcf1149189b1bdfaf77fbd7b69139af77891e74ec180ffcce06a24497d9904732a2b1ace977ef6efd31cc342826f92b7b82dc1cd70b2fd42faa0c864c63abee6ff9334e5419d3cbc76aba6e01db784d3d180cca0e8328ca45798b474325f899dfa9fad8a34d1eda4df3870b99c9ba8a0b4f9d13acde378ac27669aee26e8c60c84964ecd46786fe4f0f79b4f4c00302a85525857497709a6449f812fa46527b570cf4dab4201f3867c3578a16f0f683a40f587dcf7cfddb7eed9b38da408022c0ce566cf4287a36ac8cde594700153f41c1843b11af5758fa5cd7cf73cf264ccb2a1fe8e5f13c6b98242f424fa4315789169b2d14517d59ffb9026b4f8ea0c91b9480a8c590dacc82927ce8877a79a96c5f1114827748da4fb00903eeb935ca89b4c6fa417c00716ec9fa176b0a5bd479fc72ee5e94c6997aa5741404b966405b742330c296860e213e8928e7c3aebf808c0f8b25477bdee5c1c8f48c461c1abdcec205e3bb4dff4b073e17929cf0e3dcec81f6ebf207f44f1008c18e7cff1422c6794e961964262bac398c054bcdd15e1a7c056a5d5f3283a25b9d4e3ab32b17412088b59b7da969f6cd7d6d17d1feb158af3d2063a969183b0ded79267f1046e95fadc784b921802b88faff53a6f2e6471e81563686935fca291455bcf139856f67cb76c9d20d82786aff6437c034f03a74e94806c8e791e3b1a8f68f00239e47b652fa399dcac289eace94eba0ffc5a970fe07be426e265070fe04df891f5ba66aae1bb4dbaf3b20f3b8d5cfdb0da4edd40010ef8bbb1a8d408cf712dce3199e0a8b036a42feade722dd06c3320f81e3ecd013a2cb6695a44cb00307d19f80bd7a6ca340a078ad2a8866d24382fdf7074df6945f09833ea8495430bb3c09989cfeb1af845aeee46974895d7d834c43728ebdef5e346a54130ff94c7c75ed8374ebbfb53a97d93f5c33af0cfa4b7256bb6f2b54adc09117291bc79dda25a87049df01704613b361c45c16ccae743bc5dcacb32d2754f29ad4c9697a4b1f427059833fa5c3c3aaf49ce830c5f3741ca70199ca1d678de05f219bfeb4da11ca64a911a964286e1a3119eb11bd75ffaee42452d044616656d275a6af968de911742db32a6de2068981d439cb518039f07a243185fcda2a94d04ef9222504008361dbb23242acd8b502ccf","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e51cb6d05ed027db058edc159e71b81e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
