<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d28d41b8a3728dbc0b90d0367dba14feb81f668cd2836c1f3fd90b21a1d6bef2d6ce1d5323edfb8ca797f0ec2e31388e28d84ee02994b3813e0a98aa48eef5fc083beafa60ff01ad0c88c8dd2d81a50f5afa655232bcb24a8d43e25ef055783ef26200cc04f660afde0c6d3077689618b8fc196ce968cedd930d99afb62a4232127d790f1a672aa28a487c6bcc66f2ab6713c65da6ed9f8c4daa94a322b692f9dee31fc12811f925ecef56cca204d029126b2d32456d56e15408df93b6baac49fc6e1eed88ef4fc0cc988a10c9b607df7e433c9dc78679cc6950bd9b9bcfac93d46712b7878d52b271b94b2e45c82caeb7705eee2e6d7b1789a7f04d4e7f1fc0cef2bacbb19f9a17604d05f23ea081a3624502bcf70bc769ff87678a75626c6bcbd4d094b8c240828d7b0d9f02d1dc45c5549b9c996a86121fec5dbe2c7ee1be9c9c68cdae282d349e203a8808bfc4cd83427f5072a18218585428ea7f050a2e27273993056af8c1da4104573e77237ef6d5e994723ad15219e5dc60ffd9add96456c731ec354204cac6ddd3eb543b8947d30d6fe09abcb029203b8fb0006617ad7e92e71abb70b69bf0face0c42c4dce123e3d3f5baa7e12de726549e0252102ff491900cd0bd89689398b8f4b1d25f3117e96c282e6ebc184b31c5114d7e666f2feaae9614effedb864fc8dd3ee334dbf916a205923614bbb3754f707ac7838008a022421d54c8d56c57f6c826f3481a70154d7895888187359d636d5d99752f916c36cec622174957be8163788df36391444066f788991728647a22ee260e1482dc1d920eb740b89458e902a5a3396b9ab965ceb5d9cad8f8c408f44ef5ad1db58746ba90f7d0bafeaf3a98eace75624d50356f8d7ea6fa71f46854576bae3dc882d228ea29a89f9dd962195f644ea69cda73793db8d0fd1d78382466173228c61ac3de27658c902e83fbef575628c480931f523a045355d16034b97441036a1f8dd6e31725f908dcc41fb6434d2a9ce5b4adc9f1b8f4b175864dcf9c0d074de80ebbabfa45e39f9d70a090c8286e2cb599e9686e0c5bf33f1312755386a5af8e9b8944799f333fe5e1389e1abaa4905bcdf60010674faea1418fe6434b1d33c97dc034bf3319a4db988c889fa476fcddc7025f37a7ade48322de213f9d3996afdfac436637e4a32ceb889596ac0a901312f438b02d79fb56937f3f7cd1df7a050092aa632ec20ea13a37c3a0b249a7721c26de12a90a7b5d971e688138fc0686277ed8271c0008f903c390714438894446dff1ae43db5f3e66daf3f305a3950539ce33f38461c8ec45509ad0a47a8a74f28750e769671a7ea043ac844c17c356d1fe66306ae7c6861336384f907f768010d6f298cd06702dca942aabd7936eb0167b2962700b5dbc2c348ba753c8fbf66ebc8ac4679e15d9913d8ebf6e57729a02f02aad0bf6ea56f39f149254f3d7ad5816e53bca3902803e1db6bdc881d2ab300249d71b86a07c29e5732e306d953895e9ce51eb9014edb0484d36b37e99e823934b11fe16941c44f40f0762d7c1e0305c0a2e535334df7abc090435af361ffccb58c5b90e6ff57371f0f4ea0fa9af90b1d232921c3d7dff7e09f0ef0805aac63d168e7ad17604c4e6fe5d5ce77a44c34488633af4fef09415207e17df80506bd09538624d653834cfc23562dcc24a141d1a364ca45dd4c329693862f4eb0e9c120382ff38bb17cf07ff32b2e202d0059e35d30b5bd3fb47194b7cc65c7d09f7f09cf3ebac9f991bb35b5c19ce7bbdb67f66cd276d1e81eeb2e7bd2ddf35db55cb8c95db36284192c2a8eb43797a3916aa64d0cb77640fae74271f29b306ce955a748eefdaaa99a328fc12dce740e1b3be98f8a13e6bbfc4ccdb9b6238a329a8ef421c06902622a130f61a3257094d7edc910020e49ded97a64e6791b7bc7530174b8c07f5295b39ffab76d01ed6e3476c0ca8e03cf1459f358784226fa1ebdb1f716cdac1f22368e75975ad4dcba8b4233da5b3f2b3c04a2c3eb7a45ce9b0d9190ff3f3a3853b66a23198c5424b4c7a74f7e9713fcd460b72c2c025d09c8b130671197567e35b21944f3e5695c7de4abf8c8ef386f7bf672c700c84d65ab9ddfc5b417242d78c505d2b98a5639c85ed4e34bb0b4a66e3b3255ad6e8e522f95894ba2c5d5f543ad5204efb4d29fea09638c3a24d02b91233873ffe692fce208891a12fe978ae1603ad2f2cf4ae442d9f35dfff2086294a43e82b1a12044d0dbb6f684f9a5b9fb5d9e0e044eccedc225add99e177a671c553db3e9d84ef52bd83fe6341cb0bda4612ce388d3a54d0581ee0b04044bab17afcee99aed2b2c5552981b13efc070b2cb3b07b46c3475af2408eb08fc481bcbe7400548e18985165130d08d54371c666339507b4ef8b5ce07dff0923264a9f3d1d101195dfcc948fe4c42b8c0f0792ec62a2a722f046ec8880883dd6423801165cf0801f0243f7110aef9027b4847d31b8a605e5717c07a0e89ab7ea718e9cb35add293411b96096a3f264e8e444e932d72af81ffe1c8681280c543ba7fe156f2285b3579c0756687ad8c721ba0ab68d4b356734d709c08955be4b2096caa79c9e4e4462e63f236432eff6c434cfa3a2bfa102bc2e91938311c9556f703094f93f4f26b389d93f5b4575d655f526ae8ba8c6495fda666d06f7d312934a0d8afcc79e00a4b870169dd8c3a7675b60cb78f99f55270ea2b1fbf3929ac0e5a287e6e67fe9567d3ae04fa2fd800b6be5c5460876140747a6df04c04a52543e85df9da10bf852bdc2070c018f719f4c4ab9b9547b2bfaab8bd44e4943b2e73ae9bfcbc1ffbbec115576be7ca62448e436ed963d97527077c5460d645d9e4c481cd76365a55114226c47da02f45623bd5be25984e649abcf61295f7162ef4c67ab4387040c54590227b7319274670d8c3864938264ec06f222c5a40c37653450a5c19ee8812bf4c97aa8286f2edf664a364568d7cde6bda4142d73c56ae3d69510820efb2f26c42d047fd79d0724415eb4999c6c836f1d9bd014d880714c5e145026af6343a2db8ccf7895e586ff7c8ad7fd537f7af7a017da0e00d6fe486b1e81b3ac3d73d681d9253e70b59ebb7ca49de161dd44c7df052ce9e4ce5c67ca6ebd04a5858c97b3cb2143e169838559405d1e1df945e8d21aa2f81ff289b91853cfc6cb754152075bff91ce11f1ed450d24c1636f5ffbc4a853a5129bc1525aeb61e8332d247cbfec042bbfd58db994f4d82d64bfd8aa01fedd387f482a89ef3ecbcdd3e8aa31a4ac576667684b8cc4de823aad39eb0b77c7ece3a72ecb928d38983420e55ecf0d434f3870b257b0a3d60bb4689d62d4d1cdc26918e1ec01078d681414021332db3c08e9f9391334014b7f54f5981df9c3df300060fca3b7a9acd4d64c0d7b6f5d1c40262cc6a5ef160e9f69fea06d775b20e0b8e6dfb57bd5525d62f8b99e8d85dbcd661e585a4e9eb20228d45ffd9e65c18eb936f12e9fc8f1ca7906483a35703e89a8aefd323e67e76ed91608d38c3a7967d311f246ec22f665787ba529853467a4c53879fc451a951ce3cfa1d54246d5b14fac65f32ac61075f477a149251eb9b61e0cdc6f977cf3611548f0eebea2410377665033c27311fc4d9678d878f97faf54fb01e906fc561597b8eaedc000130b3b7246eaa48a57a9ba6185d3a432be124a83c04f68960556cb096f97ff6d1e00ba6a51649651e6c12600d02e54d0e58aa0ff5eac9a0c0c95c408c11d3b94aa4922438dfd1c7e8918778471f9df799f0b3430175b674d4d266645136d64014b5da6b78af94a535350bd972e722be4780856cbb90f1b4f1cc6e113e80a70c8c1c591621c07917c1e816d229be0a4526284423192d626d4ee83ca5dd2971048164cd076f6b98d19c471b15b8b726462c75f2cde0348b6251e47c52303792e46a2cfa42a184ac7218cc01247ca89aa40f55fad6459278d98a76f84046ad03b272946b720ed6906d03a4e43f1937469ccba818b60a1cba1093f1dd4153a34ae9eefd72054a49a381aa72ae2b439bc897561908598fb2dfdfc4ab8eebcb8cbbef09b0ecf61acf59491237cb13c5fbfa84c027a73b7825acf5545a6b0bb79b6749e6f5e172bf5f215d57868fa634f7907617536632793cca2e77e1298c9432ba814dc2b5a97a3028d01325ec25053ea55e7a6e590e58ede62903f5ea65baba181c8567699298c823d8f06e3506e7c974841744cb647f7d7f51a751c28a7674b880d4960c0d03f87c0f68eb2d48c8c77ec6c4ffbfd12c18753f6d6afe8109264052e06b75d888557bcebfc1dcd9f5e618631b0b96e839ae01bb95712c73cd5c5f0454d0b42d1f544666c2200ef4df7913d5767277d14b526f8650d3bbe7b2d943f89def1993759b8673fb65ba587581d6fc4cf30b3ec9a5440dd3c3bdcf2d41aec835e902f1d51c4ed3165e76e56311da9416b96b3238eb9cac882622c4a8d809f87f0e33a88dee6c3919a8c2c1ef353b887dfca310aad5c737b7060001bca1455392304f9cfe53ad63a29f5ed15496a483252c1f1e0cd3232a4cf0fc4bfce8f0fe786d59fcd1c3e2fe5f5d6b54a11a75e576979542bc5e24b69f5b66319d8116c47ff22f667bda34f74b3116af3acfa169d9624d9c401619a3f7074cfaffdb8706842f3645140f09c243102040c425e39b21d955349ac79e31477bcf4bc500464a836f9bb393579d2fba2e7bc05fb978a92593bf496a8461878788bbe96df3b57fe6d9c220722a94634a99c8b3979ab768d6b327f3156e6eeafe84860e827910cb7fbc2c8fd01bef17ffc536ed1390590dee6f4ef81ea353fe9157d2732de1dae8acb91a9fbc945bf4674cd36b0d1661751b5c8f42e1c71e573797acea35ddf7f20a654702dc0d883b499b7052815cbe68ffbe335fc86259de08c933279c6b4103389cf4aa4e52d88495f469eaae9ac53ec7c20895c3e2399aa3a3f1d2b9529d9450a2ce4cd36f330d416735d9c33d273874438d265ae9ada456169dc41b7367fe5cb65dbf28236e396345c8cb577c9924d5b79b1366bb1618415633304be38bca22e584cf4ee1ea21baee6de5ad54c190ae8b59816078374a4b5c98f22b45a098d437d997253d45b4f2eaa9b2ae6eb283567f3cb160e69d0807e1b11ba5a003d0eb6fa4fa1216cbe6b9f48511b5f1266e5a9a733affad3634f828d18f89bc06ba1f44f5759cd390a1cd51b9580e8fdf99882693bc31cb80b1f482423906a6886a67f1fa80f24e847ad84ed91cb92851c4da6d3351e1123975926b88a63cf273b6b4bb4a4817f12ae377525a17337b52cb2520bf4d03f57d9da972c17a08a856db35694271117eea26e291009a80364ee322f12bc6aa5466b40ecbe98f79f195945115b1382bda347a8a288bffff1eb87520b2000e1ba8c89f2451af42288439eb6fb3797a5abb57f72b4a9f06565b4b48badc3dc16fb4535322caf8a07c46b1bda4a3c08891bea3d29a68c3b47e6c383b20c411bd93b6246f5f6273553cf913c485d02ad7f046cae03a5971dbb7c0883725b49f1686833671f9973a1cf4d3a1d0823fcd6f08c72c4dfc0df0a9e92003d9d45fd8a1d99e6556cdd10478ae551654a9e011429c278cb8053c7e62a684dd0e7255a4f0e862eb407091455c48312ac943ca804f5457a890448681026e1364a27c8232fab602b1219db67c993fa6c10b709bc29a8ba97bfa62b714d8d230c8f64ae9bc3ed840450f9ef4e0c7e3f4f4d0fdd930a23a0e40481e7512c505969c31b9f6ffeea10d7aad8181a51d458cb9edb06649c261f10688f7ae7a8fb7b19681d48d27d63687b0180afcb6f847c8729ff534976e6dd70d6f20800673de436b21e4c91bd78a07398ff98d9b4e4f8a7934b79756900eec4453090724303d7f982bd6667e7eb4f0add77eedf2bfac8ae6f19f288218f9cd560f0c8a7d890bf1521b7ff75688d06e5a12d075602314bcdab3538d185b5a9363094565f572d3745085e4f2f3bf6488bebcbba6e3e070fd06de26cbed0ddd1496978bb488de2f3d776cd825afb646b0a5c94913c04988b052c2f8ad6799a271313678fce13e9a41000e0aafeb68681b98019a0abf822eb804cd7fde259ef182d215b445c390140020a586455af30fc1532ab67dbc1dd59a39c691ee10379cf412315cb5c2f0ac44172e769d18bcf9deb7aed0a5b4d31fead6a5cd81abab44e9ead0347ee1f52815a2c2a25895d5982173d4fedf25f6724459020cfd8f6221cf66c2202648d081afca6cda64613329bad866399619d5676885e39e0da88abe7866972fe50b6ddbd2def12a69f9fc9dd23443748ec292567631218a291afeac40e1fc1ae8a5ac027ef775a4f66529699c91def4ba43eb70ee7c7ba3ac3cdf6fe687ca9c22e6529e790e28d266814283c05c8abb1ae6907c4600dfe12a4a1378e7f896bca4304fc0903488b5733588f2a7661032c4c15afb7ad01cd120b823facdc51d207ab3ff20b7053ec40e2b2efd610f0e038fd2109b83383fdf420a17e4e93426b04a70de9a96af6283e20c79ec7dd3a42a90f28c63cc2ce26b0afc36f4c55ac362c5eb9ff626dbbe62dec802de0d2888b761fc477bb7522aa5854dede972e26cf7ab25864b8666861fa1e88e05ef4d942c03f2bf4620c36c13a2d1cd3f48a080eab2e065b7f7e09713fa6995bc9b987c0a0089baa34071729ceb7a56c2e96895d5905b7fbe0527935e92eb615d62cbf825e92c991f04a54cd22fbb75de45ed4719f42052ff08e5e1d8213fe94dcdd98ba1e7af20000e9bb23036658c5c1ff35407f23c17d3e05aabbb98edf9e767ca3923d437007716e7820089ddc665fb3688fa6925865ce6eea0abe6cc9948c544e7c7634cd7388e5e35e88484a2ce0e36f3d949a2813918cf2fb0c2baa192a90f721805946a376e40662420584551f42640b50b3792c366f2f9149fb9f2cc0ae110142061a6f2f1f211b8560717f499fb4bdb5903800062680d51f0c730c431b68980f1d9161326e3c5689d4c9f7530dca8e74ea4048166dc83055a74a16b3c0fce985c9886b3af9be96f4e7056f9eebb7b8bac32a03bfe63527bc9f48c645d59f8132572b5b0e49a952a80a5f8f76f2bbbf0bb33e8f7f83e2de8ab51043dae2b075303bbf68849e3de139f2643b86bc95a448de717615513388063e5e4e8ced0c48548e2969acb06137e765cba2a8a5cfa570d25d2a93dfbac2e76e5b73a75459707e3cbc22dd76d11d9544b732739bcf9bb20624d3c5a7b0e1bbf0163e80b1be9e6778481a81209c10195e1c104d2a357e49c067f1f6da163ed16884cb1f58447bde39a97296ee23fb7e680e8d36db4afb4ca373df65e77573ec25b8855dcccba91bd4eb6771f060881a13d5ce6afd9b712ce6d9a3442573fdc839ca501776a59be6ad65b75392d443b6f87327c1d9f6d632346ddf8e15882a0c1e2ee69ba1b4756934b590594dcad3668dc8da1d24ab7d20b41f3dbff65844ec0f7dc102e00fc8d25eb779c9193716ecd65cdbff3018f6312e4b8a37566bc073cdcded4b77c8e8a9784eaa027080e1f7d8d51bafaa55d97fa9671ed609a9219bc10bdccaacbfe94050d517c1073cea181f1283856ab48fd6359f605a885e3639233139adeb94bcc0d3d7c285a162decee10171bd2babfc070bd791a1882bcc444232b6668ce8ebd65275247ef36c708f0a8998ea0489923706f48f214373be70fc527be5f825be5db04b88342cd77d9b1acfbe577c50ff1c8a542026ffd48aebd3e1b0b7b78bde364d28a4701e24cb04dc60a43b288149cd9e939f2f39dd042de8a0b4867cbb200a5cdd61f003243cf0e70a65d3d935dd01b376dabb1c688a03e1f772f7acbf31386ee85e080051e371ece7e6b1a01e562517be3a7105b5985fdda3c266f221e5beea5ce5bfefd104703c4c0d2b8c11c1a20d32e7a478f5fc52cd0fa4c79b5592ed61b3bf01553c0a7cb9bc99fe80424d03a29622a05a7aa3d31ed60bded8d9f030ad9bfb502349ed798d875c0dd916ddd7b12009032cb17768213ddca6fc137de8d54b26060d25012756799f9e9a41db4570fc61d61aed775db75d475a0efd4542209395d7b0375189c2eb1e4c13744eb35552fde6cdd30da56e6f4f0884a5051fad21ad9e245f3ccac14666b9a48388d8099574024ca4f2eb16f3806c9d42e70e7497295c50ee7e9fb7b9f26c00cdde5c6e99eb4e03d7ac072470e882028eb24255af350935080a285841d188d7ac977813388c582c89f18a00141fb370d394bf8b17d1b577950fcfbe1207cb6cda964c537f86002bef853cf38b84d49c7cd3913c2c98e3cc990854ab8f992a1c6a2dbb1e412c61faba38a99536b6f3ec5691eeec79675c084f72a9cc93982f62fce4dc265cc5edda548d47ff5957d87ea53d75d955fccf643fba458e66010372f1640d65ca99c2200d6addd6ec32a2569c4eee2e5adc5448afa7c9e248ab6066eb2178ffe65b43e92dec4462f8caea6df01515fd1c63bd47988b378c2869f2f7be1fdc0d79bca23abe0eef4dcae0e8948444056cd8f4250d3a580a31b5f35061469cb9bd3a438e7a2ec09feac9e171947f62c8296d8c92185d9fe0defa00df4d0829d256d089c75b8397abb22630c0ab4462e953475c95a2a521860bd3c35e327c47d0d0b0dedce6efc87da4e36cedf6d336194657ab4320c31b29e28b79e5e66b22b3dfdd91b1a4d550c8d25068a0a1ca31879bd683831842f4b60d6b97603f7898dc46949ed1375ffee855717f94d18854a3dd85bde15c2e77a475da2fef21593ef79da72a01f3b9408359f2e75485cf8169e80e995521b72244d6272625fd69db4b5d487d82fc45433d153260a661bb36e66c2e5b02ff92dfc1083a3ddee5d310a5720b5ec360d81895b9edd53e9c2a44d58dfc4d39d04347b58b0c6713690665f01dbfe215b18968dea7a125d9820b10a0f18b5a4710f1e337e32b449cd8f448846b6b6d3630fa165d92fffb639fb11f7f720305059c1e5befd8118996bd3c090952b1ebd497ecbc0bc6a9c4acd5605a0b2e6b3dbb45b136af803a9ea9539e7d7051b51d4f90f2bd3c1c829b2c0addc2a8a9184401187c3e54709a692c6c2f30b3f8751e3075de7feb0e08379b8aa869aa8a6ac1a05e16550e9d1a589425cf36c8ff4d9e09242fd82a7c4510e95e64f98fb6c8452237e94eba5cf78d0a891afbe70e357249263af895410fba882140816da2b76999bd168b507cb44f7000df239f474bc5731bcfc8909942117edc4896457a8e16aa9a8161cd803a6a075d885ab403f7078e7a3da65adf0c9486d6a6959c3fc3a74e5288c0cae09fe5c255303279f31697f3009a293c991d064a846967c3668bb80fff1b3ca7c7f918637847ec3cbff1a171257cbab0ebeadeb9f269d07a55e084fe24cd2b4c0b92d4dcf5157e8848641de4ea3214caafe2853bceb5b0055913da7a8e48a7ec9dfbe1789bc1206c8de6804bad1db217803948378b44b53f119725f3717f60a2d298f60da3ebf5c9d4c944e5ced94b11fb56572bdc6cd378d95994cdc19d95a906a3edca38d86b38736820aab1dad52cc9fcbbf3f5abddab07607f4ae1c50b69177032de2be6ada4fb78737087d5cd70c66da40873a753f71e868a5ba7303cab2ab4c055e44dba91b744e21d12583294a57965f45d2e48846a3bdff419f1adc52a053638ed0453afbf18469ba53a9cb8bb8d05829cf52a227d42556958b27211b0ef6e665a113f3a14e26cba7ba590e5198d610f7164cce6f26305400d3c091ed3a98582164b7febb4c9ab9ff0e3f43ce1ebd30f870ae67640750e2233dbdd0bbf2667b1685c27ec48006b3a42db5c53e515959ecdf02ed7da264f49b0be14ce98831cd96095d6414bde6a8ef1a538fced4650422004d571730bf2b30a4a44d56c156532f3c4e70c6f18d2a7e2207fc9f90e20ede8fa27d008afe83ad82fc99abed858e787fc368e046924f0a38adc894b7e300bf4b8ebb2e65a3fda7fdec0cf11090defec2e64f6f46eccc2b2904eec1f2404a1e296028a9e9637d962ec35b00df37b3af366c2032413cc001be31933eecb91d2a17a6c3d98eacdd00445aaa244d0cae63b8fb8d9832f2b8922e8a13e9f6570a994aa4afe989b91b5e3143e02ab9c69ae552a648223481ff4b840ce82920b952b00939250c1dc5e67d6c6a4a9b1cbedcc74f34ff9f4b07d3b0f3c4edfbee1a70f48c499d18de01530916ba490e23f301290f230ed5ec6fb36ca2d57eacd88c2c0bc8307d84fa116842b498f050ce5fd3d4153373bec27d6065aecb63dfcc1525288d433bac1b0b74801726ca0fea32cefd6672bc0a44bfc46a003bf628931ed3808c437d22ce706f591750fb415e29f814526d3bdd43c518826fb6e5c93d455ea7cf7f245180bd722cc65c45b3967e3d7a8e029e8018bed97569ab9cd28d9b8e935624b9f67f703b2be8ae160ef7f75b493ce06247fbbf26aed6e570e038c058f4cdb03d0c84eec24207f59180ef1895c9111ec84b03ca8eae097c6b9a30b0d2fa71694a0a4a91458000b6370a266a12729805d77cd0a9a23fb13192303b91e29d4e0aa0f9ad188fc0a96bd47685ffafebc2a5f207bd109be8eba94804b2fbc5347dceb232b8af7720a6e605bdf6c3996e1207b4968656cd648c9b51022055d3c3fc63825f012ae84fc903647f4d23b6fe9e1994abe80c59c6eaddbb7ca816a588be87ad6b1b63251e8c3a221ee01e25d7f8eedf3f16ab8f178ec0ad2126b305c889e29313617cadde023afde872f8d46f07d135b79ec35ad9dab69c11c1ab3b762e5746420c17cc7f34cc66a8c523fe2f69632838fbe98785f1746a097eb075c5a3ef1384b29e3126265f204473502de3cc0d6aff9035cc21161c0b66a75fc1e2a8c96a4f9a3ed4d87c6f39defa37a2e42a67d08c066e7e0833208c5c1eae002255155150ddc9b3d549d8283705965c31320af6dd214e27992c9d51100b468b8e9705c7a7fbfd5f2151a2d63d54b63e7e9b22821c05f63ef91637f79e15bfd30935619214a7d8afe6730d79bd09d59fdc0b11324ea8ce28cd8f731c4bd802a7ff80de65512bee8eb97c0b83f9355bf9789d40feb40b2cc16784365983e182adae92b334542a34f96966a1f7499db5590565323dd0009999db331e56a2e14887af987c19553fffb5617ae847ddfeb96c43e2fd0180172cf32f3176846eb3ddc750c151a90f16a9caa2b6d8d69fcf610fdf9751e7a9a4824c20dc6ae0c527af38ab32671c08056c9742faaa75d70e0b8fd4cc041b169dfd8de54fbc6bf2bbe5a50e9054afa43736ece8518c337f7a27f2db33962d752b715e1f454d02d4eae9ada3a3448df62bb26458cf4294a5d9954e62b4cdf4ff5799790463cd51f4ee7aec4effbda63fdba32390d0fc6a707d8ea01ae4c627e185b7cde95de24bfcad703d7ea7d716d97ce7a719e6b03257b94475456d784322e2cacdb5e5de3aacc0742bd6fb8fef849c4ae830e4f2f82e3f09d960bafa0116a9a098f679e5bb4b90d7f371793c20829f0359817fd2d48e9bdb3e2bd3ef47d7dc73d5f24c0b91f95a673b20105b28d37fed3433ad97c5e78a7fb8053cada026cf01a653c55d798f10f9574eae17a39262fd293fe22c90f177b2223be7417b237817fef8f06140747477b0fdad0bc9dad62f29dd0758b90d4a08d0a24ebe89f35c197b0cf25f3db84cc4927ecee8b0921ae48702ea5227becf2f9b72489159fa88c51a8ca71547308fe6ecf65193f0f3f741705c6ea469305ebf2539a100ca8cde9358ca5ed59753ae09971f9b0fb2886eb78da4cdcdda31f32d781af0872f5134d995d76835c43b09c3c5a54269047eb89fa4886e5c8ff8062ad8268ce7ef6399db31372ec6233e8c0b5adfaa6fc1971cbb665a8402a7f7c22b9f6ef55edc771a1512d734dc5fc774a32f42ca7a1533fb8b1eb8e07ee7a82c46390d776f4a9befcf02635f9255c4978e7c30fcf868c5cb41af03bad7747cbb88314f2ad782b70c64538bcc68108f2addf6223a097183ad0592dbc94c7f64b9afc63525bdc01c46f7586db7c409c191f9f55d5fceb8abdc1dba3afe7c5560bae5478798c873746483465108d881d7167ea778d7635a50a5d26014bf07f5a69bbf7056a727accd7eccc0f28dd225bd1d7d5f324ae57335eff5282fe2c81e469ab26b19cb0a56cc59ad97748f54de86d3646a80e7efe1ee558a459c5612e591ecb5de9808aca86250630198d1f5e54bab5af2e094b701cec2ffd0e4a77ce2c34a7ce4fb14ee610b4ed1450d785a944a2c5f0a4b6197787c44633dcb281e486607bc0d0a0741b2ec893cfe2b11c9a675485714bb60b20b1fc0849450abf33086e044fba85dadf9e91b1ae453e84c922ab088a271fa797f22be0c6ecef5541e5c1ae05b0a1c011fb1fa90ab47d9d282a4f58141c3b17629bd08d22f4b297bf1dc945c89266995fd51690bfe0c29720b33d345dc68b0474ac819dca2039f9635585cdf56314792675f5cc5aa09d78ad7d1f578afb510df54560adba090422aa65956cbe600998c2d62e7cf670735c4bb473cec469be3f04fee8446d23627fef7df0fc2ffbce83647fdbc32117c7794acf5f07d05bceb86350e1c85c9e84ae300ca2aecffaec73d4650dfbb1efd56fa9b858e9f385c6fad76d6d708cb2b45e181a55f4dbe7916af7ea6ce704c025e9f9f9eb41c79b929121418092114a28e0faf37ccebf6b1d538c895f13f3e124c295eb4c7e321ca3f88f9cb27849e17cc6263ed5e29c10f2a1face6b8327a2d5e6bc9b6f18e1e0304d4ec6a2b228379d95f978dd0048cf7aff9d82bfd5d7209c7f8fc4f6a7808ca6a4932e76461ffc9ae0025a225a4426d3d26be3f411ea2d5773ea61424fa3a7fca2907e02788a5a16255510ce406294e8c997e0e7f24591facaf1b14ffdc1ca44e414a5f6952a94e69ff8cafd9fca5f31f1447ebf0d78ff52905681b7420e8684b4dbe9361215e0accd8a7bf33ab0dc2c07ab1c088e3a4e3b42fb0990093e7df9802892d831d8dab0bbf00a33aeea9840f0133f4f92f0bef4cea3b84b5a68ffd9a701166756362180de6fa884479bbda8ec48d7b222fa44e93dbb7241e92e0edafaf47d355cd90df1dbdaacdc8ce4163d6e38b5d9c5c1ea74711808bef6421450cd57bd424f2cd4deb7ab5561ecc807826208a7f62121528b7e5fc4422b1fada7fdc30d524fcc0398fedd364f2e9cdd1cbccc1d5346bd9f26746356752360e60be8f8fccb5aeff7f437d25b49a7b133a510b0b3d57594a8b3119ec6f9d04ef174c371b011e3d040c97b4d9e715cc1ae3f85ecf97385a1735d88df6e4e3702a9ced6275cd36a40061dd180dd7d749e4daaa8ec6dd8373199191e45ab2f2ccec9350fc9ce3a624141f8d14a4a9f05fa1957b561e1c4dfca06bfba1c1cb2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
