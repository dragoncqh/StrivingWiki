<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"af13f6d6951afbc264a6b9d020de103c838d656cba9ff22b152cac57664a6d858952a5274847e08a593f00feff627b6fd2156da6f262ca8a16eebc123c681c94ca4bea844ec93db07fdd2e3a5b80377742a9a73d5238c144f626a26a6a7de7799727022c6cc92059c3ee1e4b7b323b78832288270fbe4ac1f4164ce0f76a659356a2bc37acbc994ae9135c0966b543ebf11f061f9df27452107ea1364f27201486b78ec077701c382babf24e29d7f188565424f0946a10653c45f127a768415c8b584e609dd0256250fd1da92a795d9e43ffbea19f51fd43aeae92524daabacff5439c851f972b96d3a61f2b49d6d8fb577f4a469ab8cd9fa53648ac4cb5975517065495af7b68a8b24f33ca5edc00683e7a1d7a4d52536ff67954bf520450d90c14658d6c051b1ab68b52509943535b8e95fcdc9708ec9811ea9aac52f00c77259111a0fecea4c83af263e426aaa229fce38044036fa8b5a61eab7bbb0326ba0d8382921b54e5a657974771e71c979e61d0bcfbf1f5271c23fd76c1e4edce86c43ea86d8a895801753d368c7c05e51db8629ef25f8eb16c7bd4eff9396dbd0ab5b5583b8c4bd949912b52a8b30ace3854200949e4c671d936e8a1b1b73d19e121ca5364d336c7bd14ceb3a1224a4db4760a94c2205ba827250a7f74583269747fba4a5bdc1ff3fdcd97476a702c44328b00a8d2bee0698c873faf4a36454afb03d2eb90bfb2e1bd7dbcf9bd86e13a69f19599926bd4261960c51a44d96ad9593690f68c9bfebb041e909d1de1d7f6c6c7c7f7fce1c031a616f901a42ab055cd2f5049c9bdfb46fb986dcecaaef1adc081acc66151e4237578e75ba1b013b7d62512402030e277e99aeb327e538a6074eb4664a001eee70a887315a3a1848b3f39a57b100bed2945b11dfa6eccab4f70e11d6e7bf5999e368971995c3c67b50f847b64a6ce559d7881d575b40a2e06d954e0a8c337681948a67604c9cf58133091bcdabf4104ec40c075c117a5b707349043f4235818d4ee0659a95262d00b34ccec1fff3d5a7d7da4dbb738d3a7ba94cdfc20cc74eee70b380f4d473ca7dcd9fd12aff0b40edc6785d66a67c8f5ac4f9b774287a5992c406845e9d6c7939a122ce846244272d975d1781cd123a1035d8c1966cb87bf7222faed63e697f7d2dbe046dbaa637480f39f02b9cee5ee3b958f638858fdf4a5170d01917c3b20bd96b3cc31c82999eb507d80534b86edfe79f779462881595ab93b883d8ed257969dd5d26bb811a7c2279404881e5bc2b2ba035ccbb65e3c28de817c8026ecfe1075eb8687f76f3f25aaf3c5f913f65e12b61c719f11ee632542b54968f754ca4cdf58763f60626dc89bf9e328b96fd8237b7d7821a99baefa016e7cb6dc091480db68493898a80f54bec8a58d36f6d3d05ed683c71071a7a096547c1427d54b9345f9f8dc9dfc5b9d1a6c4f618a908bef41c78b7990bf4b8bb08e0b48f86247c43cf1b79d9c0ab2270fceba363fcc36e764e1727bae689c91dc0e2d2e5896173cea42d8ecce4d6f14b15ad5b10ef1a748d1803b1467085162f513bd222fa13b32d8d86b6bccefe8a62587315f7813bf2dcfc0d7c910cb8a64bf2e9c39c4cb17a93c6888b26835045e7946dbea739a4e837e1d740e6fc042052a855851b1354388a75c1ac4e76071835fcef7915284b8145271609676b722e6493022c057c79d9a405185047df1df5c24085a78e8ed19584185f0128793e44b00fb7c7ef65a9d73dee9acbd47aa2080103cdd854e7d81e73ec3c2aca0e252f5b5ad2d30dc9e23a80065fa57135fede9ec69f203912e587a4d7b83ec6658e853ed08aaa6a0c1ec3894775302abd294ef5d6f097516c38162e08dd2227cf1f0f7509004776eba8f528e625ece88d4dc81db592e31c7ea3fc05b8a27cb1a5aad21c2d8aca5be477d60c369a695887eb4cd3145be5b984c790d716a9e6920655d67fdcc72643b2fe0e29dd549c8b62e1465311a57d793e7cd47e86ec1690683c1c4fc7c17de050430f84c027ab1344187f52fdffc02ab3860a88be3c59478b69d0157de28b105c76398fbc4f623b2e1cc177181d2d99e27b96a51fe77c2b7fe66e7dbc74986135c4cf6cdb535bd778d4c49bfd570b06c9ccc81d04892a375e5629369b4effaf8cf195c9e8a56dac8ea4163ba4c34ea8e86899692c24a388e89c9c4e8bef932e5e6adc1bf2be0ffd24ae9c77aa105347f7801ba06e5cbe06c51ebf19a047bc92f032a0120d3e0fd6b1281644e467ab693f1eaf61f14a2974442370bf65c0f86ce202fc66b01f8fad9c8850a16ffcd37bf502705e807060e6ac0940fa4aa06f8dd1bbe9eaa19e70626b28243b6aab4a521d59c299aafb302835a429d1bd203648643c83026ee0d3bd19c811037f0e8e1398d6991c8647318fa300ea92c2354640c4c2413a6df36a539f514835962de6bf86297e8be1ee461d124861e8ddeb866dd4215a2fd69ca6a69aa6a069454d629d5ae7c8afd080bd1a8922f36dd686aebb38e9e9640c7dc037c7ba0985cb73e3152fff353cf3e016e92bfc084c7880b6579f75c8305d5fbb235324779372a00aeeaa972c2ce3f63e33784b67c52a7772421a57ce07bf9b791bc4d3f1ebdf9bee773570a07b8cb2db2a82cb68ed073fb88a3774037174fcc11a34ef8d4df4ef2247595b1d6afe07b2504cbc6a6061230fbf0e9cbcefeeba86f6899ed275cc1589aff5bcbe1d96dbff361c2590cdb54fd854a9dd4090cb35ec5e773c2f5db89ea6ce00f29945e46b27485b075d7fc7223a18a94f6c66635c708001b915fee34db2a04e9ad6db256e17f6208d5f90448a7d53f3cacc12ff75d5c17bb18f0812104d36d1fca658fc769938ae21ba94e402f2f08f65baf0d11ff91c3fdfa86700bda0ae29bd11fcad8871efc265a710b0e2e7c3bc67ae932caca9b4ccb23df94f55be9a4dab1e903f67c382e78aceebed782cce7181221feba3043996da324d9b0c6efe19588b7aa91f8616315745bbf82bb4138ef6a7e6826faadb816559387520af78d3bffee7f596f6b1412e4230f0fce2eb579c1416a6245c1552ca93ed58969090a685245a6c37bab8b939c964e79b1a5baeed80b9abfde4c6a5efec0f08d1835834e601f4b255796679e1cdb84c8b57e60b1b52636925b9f56f8e42f3e65d88b2c129ab45987469cfb940d31afa5181de240f60f1cdfd5ee58df57c1a0c613a121a4be58bd851e063d516c099018fef7df70057d71c75fdfcb949c76e4c4b8c5fe7cb1dc88ee422c1988fb96638d6c0503c0e48030b17279ee88ac9f50c96591a315d7716fc26f1d06c9b56fb7a9555dccd736f1a72717ed287da6e55dadd9cb1179dac97befeb8d3a2183764413253a63767a115bb388c717549d340ae055a1539c4222158302f5a1542b3c789f4daab8ec8013f49d4ddc7ec8d6111bb82c32fdd79e74a2900b0cf2ce877fb5b31b7ed3efbc0ecddd63d82da17eeba47d183bb1850c47b72954e4be52f5272be1b9c51e718c2228dbc32dfd48ff085f588100074c998848837e1620a37ab1d51d9a7619f3705aa05184a9f1c47c8db7e6f12b0106b7c658c8fb4b9f06fce1442b5089644663ed034f9fd3c0fb4a3398eb71434452e48017a084ca0233f26c8d3a51765367380dfd596d4adbc068c040c69738c646d117331e5a04662d2ce4ee785bb42a1b248a8bef343925d993bdd9249348d1800750489568220668ca6c2c0cbb95cf1440d7bd49ba823da82f5e7210f5aeddb365195eb9423b4b13d60461f87574e24c50d6f9ec862a7da5cd5179e95e1726abf632a57404b5d124918d65e38ddd13678e017620dec214591f8c36328201ab7e5c7d7272f7dd40558f9edea6c382e142ef5e84d4bcbd7703924e9987d6b303a7ae9ff14175410ef8e5d573bca4fa406159ce313190c8a1d504c5c8ed1835e6cb73f6a944f7ff3c6ccd86e0b89d70a609af13d6f0fb5f26e4de03c37e82f56900174a224663bd4fadf996d49a3babb92fdb3911a2ef79aeed4da9585bccdbef91319ee511c4b97a9a5a424b70422a21a51213daa02e9e000441ea915d32bbd99f09794ea09dd862ff9be5b44b26ac10bdf4765a1794ebd0960bee8505c1766e20a0543749c1929a57e2af1cd8c66f2ca582a0a1b98505b44703066032edae30a4cde096a69b9e4b52b899aeb48a01564325f663127ffaf6da80ce3d8d42dd0f54f1643f7651eb072148a1ba9b4420f6090c63cf5f930069483cfff6e8ba73f7ffb7bd04c25462dc145fe5d4a4664c4a0fb4afcae3d7e85bfbb298a0cabf1007d80e2bb6407d88a114abb984a80ddc730cbef61e8cab45658ff882520e8ece72b26d2b369539011fef7d7fc8af1b9f1f52553568f3ec33903d55c91b8315da27331068b85afee33d779f9556069dc00f21697b7fe9998a7b9122ce15ae989f87e25ecb357d5239382895e78f8f03287cd53bb2d51e8f77d4af5a7cf2008cfaaaa3c40c8d8be2c00361925e01eda7e5cefe32e8a4eff4a3cfb67ec8e88d00426519aafddb4d00a3b6e357ccb6e1324fc6424e33c5186b54fe02fd37eca4445360b41c51c74e66c7f29638ec6dda3de442b651ebbb256b87c41988abf929b43938eb34c1cada98a1c63fb991f92124d54e45a7e08e17c80eb5e1b61848916e72d59f10df81118afba0ae9dc08b3e450e8923cc5d52e194abf99d5c548b6bc8a85289fbc1f0a4579e7fe53d6cddc186b499d9d3d0495ef57330c3d8ba3d8ef5279e1065e571a602f2043b100e6634e3d7ce5e5bae5251ac80347531c1fbefbf5d03fd08cf711af0e4f5557511fb34475419e6b872e32a5099603f5ef5bcc22b39c3737be0ed467342837c549d376cd02e1ae40b4940096380a1c279d88a0ac00430b8e59ab39f76f6f32ecdb8881b4715db54ed99dd872d0a12f6869f8868035d0fb2b47be242176369e822a539b69e3d03fb4abbe7f00e1d0d3b2ca3318e6d277989ddf3acc53e649b1398bcdd53e2aa172b509268d57657537c16323f963bb10ed1fa350f4c9c06c9029b4ca45e26790d365879c0f878ba4af5fcfba8b4e0fc331d1883aad7258cfbd5cef3797640cf5337bb14474f6b0ab61c68566795bb40fcfda26232ef177635799a37a13ed1794f126651272c450a860819dc8f0de857aa4b25f45ff3886f6ef6ce8bccf01651721cf8c12fea008e3ef15b7502aaca2e857bac0da228dbdc29ca67d81a97c0f71bbd6d5d9fe14fe88933d6aec19ff67692920d2aa48caba7563f0b85dac5907817c47169fbd34b8c05cfdac0eb19e0d454eb47a1f7835c0d98becd377c90891bc94059a3739688e82be0e4bf72f9b8c2c3d397883d9bf803bd5b5026dfd27a2627593357b78ffe4055960b54f45fcc1deb3a81d0a5f1c7d39bee55b5bf231e80fcbe71e597ac0be5c890ba1e0f383cf91ce98e550ad3f22e6cf5107cee4b4b4565f3d4d6970cf09320201cae925840382019fe665ba0f8b2eaf594e864549486c4bc28b942f2ba63f5f1880bcc5e7bd9565adb704026061a8eaf965cfa6101308e5316abbac376694f35c5084c171d16f8dca0e95af606b21fa9a1f3c4b71558dc05ecbee4ae5fa7f316414850a4aeef3a766c7c368ee53d32a039ea7853c3ac328e3fb75f699ccf9616efb6f6d918430fb33646296bb5073c4ceeef2f83872c2e976151b4e4dcd7ddd03b41b0e3bd567850188848a1fbef4b2951e140c23ff5728ca867717d0e494af485ce2f222bc786e8df194f743363496a83cb4b5d209cce0a28919aa9a063dacb2824d57501bb9ba1987ba537ddb13a345b3b16c6c0aa782149090505c457d8ad22a780e1b5cd6576f1badfd252f55caa4ef5b3bdd985f82a9c89ee6c6d08b72a65274118cfb273f0a10d74edec215a7fdca8d1352f4392dd6e1550d886f0dc608265eeb057605b1e9e5c4eabf6af4f299a0d75beab50e181b4fee6d7f7e83a23ddb91594dd94c0f2880df1e115ad396d43e96fe20cf07d578ed9167fb6bcfa017db1b9ada264284c9bf5a5321772723a7dc3de70f97735bf3608202d46aa9cbf8560da4b162f314fd278266497a781639173ac46c59cca9ecef00089d116e035e3d0f4e0b0b6244fd77098cbfe95bf8565919bccaa4836cc189bd91a8a32bf3b6e2a72c012b4ad5f71aa8c6959564f4c723feaf1bcd01a4ece10a93ff18e4313513339d70b599ecf5089b815a71645ead782953922830be6b0aca445dbb85035ddccdf3a1947f6210d1d79424b24bc6c5fdbfdc0444ac962d6352ab7517e1454489de441f94c91c82ce798baffd82d44bfe7957cd4c0012e1f77409ac002a610a7eaba08d19d687148759065a1b08b73c07b7b6a18255cad4575c92cbb4277b84176aadb59c671013e468b9bbed258c62f827942a410ace79527cfe7e8d38c6f98a8965a9772af01b02e1e2431d57fbc0d1d2c444302702dc7c0fa940767941f0eacaed88981fae2a0fe15fb961fd13e31ddd74c447524c2268d14262001cfae88314f3befd28968601438cd6ed287061f44de499e853f108394cb5548ba3715fb8c94478f9027117bb5ee35816a6c76249e8eec9d549527bda3ce707ecb2f382a9c4744605928d07e750a0e799defb7cee9228d3281ca9de6f0499b5cb633b2b4d43c3f70d1c9dc5c4a77b3a1a5ac08fdb188bcaf67501bfd824549af3d0d787f873c2eec8b6ddbaeba5351c1caee0772658e20f4030ae8819307dcafff9e0c84ce2687a203b49ac4fa856a4e12422d97af8c512651fb2316eb4a0194bce30b92232699978f9d974329ffd5fe64c551507cbb826447aa7f1b79505eb2c4394b160d4d4c5557acdfa6d5226ae425fb5f857718e9faadb7c9f13d4daddae78fa77a4b4978a6257d099c2725c28a695adc2c59525f582dc12d635be8b15a9fa24eb386ac26349ea29a0e0f121b43671fe4ed4dbf6d08bc4a858bc3b56b46296b9dd93b7defb7e8f93972adafc1bf34e8d1099f6c8db132605aab6563c9c4f6f956130cbcc58a008b6183926d936a99ac9924b0437f060b9522bed78f7fd396da73ba0321e4cdc7bab9903d01f12dbb12824c6ac42466be04c89195a84d5d9b74a97f78ade210ea9d225982e31566a31581c7c2109627cc8200f49bacadfca4e2256ca98fce3ec2cc01c3b806f00b2ab0a173617fd3fe551395961111bfa972ccdeeb8cab8cc54af3138da889f23200699dfb532d55ac5b09badaee7601e3b33df3aa5d96f529307c113b613ad2b7ac267552532824bd135bd1bd4c14d26591345ae107494c29ebd2560c0dc60386b77dae58397e0b8ea590d485140885496a647c0dbe8d371b712faef90b74c7be76702e64800a353c3461aea1a67080bbc0bec7df686ddccfaaea1f19ac88f146c73ce7cfce53c45fde7476c2d4e2dce74ef74f073ef780088f89c080418edc8e333d9ce59086252c06699f888cd67b70b3ea9fa74ef6017637a2b61be88bfdf995807a85810a7caceb0ad519543abe6dbb7f29ca68e36f35d24f4f3fd4fa2211b2485ed398c1d14a6896203cc54924b5af7d7524898eba9e96ed1b5074eafee1dc8047f91f6814f206d77f3c4a49bf5e8c465dd88e43917844e2074824c636014974b1c277488591b5ab9db21a678d7212b1b6cf3678db9b8276e235363fde0a606ffa1b795fd40533306200243dc3fb2e010d439faeeb81027fbec1d5a39a801322305f33e63a48f3c0bedd1ad884177639b5bb383376adca63867889dd53292167f19e4ad27b536b595b2579d0d6caad930bdee016cb4f824edc9a9cc5affad5dc331ce7e26ef61fe4583ca2ad15441d5602d31facb2ecf0f8a6932e0f3a102d5b9b57837e4081eafd8f7a9a4b6dc7799196b69a8da5092a6842ff6262334813c59082dbaea3e6d160718d151fc03dd52113be5890396c261773901154567b6c9121edab571114a6bcb7f7de307bd8f283f0b368de2578b19309350cb4d602fe74331db32c16b1ef5e597bc7c89a5ad1eb4d4bafa71fa9cf22526c87b079f0dc4a8c729280c13105e76eebd32942ac3f3da9c9bf7ce1e480a6af6496b989a9b06b85fdf73d994c026e7a0ec20100789b4ebb94057bf869a667363f41cd5ee80483c31a83313b9a455634029195e67ce31f47f9acabffd572781ecf6f3164a0fae6ad536efec376c90c48f6874634e2bf959be30a314920f3aa72ebec4d1360dd539baf294279b3dbde5050cb13190ba47058f71e5863dab71117bc34359f8ff601b193eabae10cc3c7d8242fdcf0c2f607171662d78c2f3a1a434ada14ef4f3f2ce1c57fa5b92f6211fd1411bf4d79cb8bbd02615ee7068f277eaeb24ababdaa8028df39f3e951784e139c7c6d5f3b88b18f58e7ae6eb4421a658ebd387da42fdfa375949827cb557f9b26e91f3c83616c77b5b41e12da78abbc89efd3230bc539339c6044d304aa92eb7019ca02df307757c631e3bf39294ac61489abb2a0ebeafe6bf764a5fe41c97dba2d296b0a646325080f0f6b22bf19e16beffe2e4d24675b14803bc1a4ab3f64adb43c971d166d4fe350c6919e7deeb1127564331bead8495893ee167997143d21be647f27fdbb74a94f61011bc4be08e9cb8b3114683d6d4ee8db2b97caa88f2cbc3f3d8c1668f29d9a10de531c89f2d27644a8b469edfbc1543aab200565b6b4d3ef4f6c7a11a27f6266277002f66f275457b89f8e697bef8ac493cb643a7515de26eff2e427050d7e50692a281415104642a5c1a45125fc0e68820f54a7956da3bf7e76c3808880347d1f5ee1734da35a71384c0e6bc30ee99e777c1acdf02f7f64e6510d860c77e502c2d43d1fa2a0f7ab6d2e08dd1db00e39a6dfad684b430338e874642502425f5da7ef9434b68a90ac949da885153fa46405c292c5950161ef90e6a8de37157e49ad610a690a1fc5a9faf2972a099aa038cca2feb3b98de8699b7e4d0cf1695de76a54667c359c5f267589a6d99972705cecf334d46ccdd014c31f38bc7e6e61900c9dc36cbb6d5898bb9d3bbeb696637842b3f55406f84cf304730683195306362ef50cc14914bf253c5e2d31e4a7482db254eb9678867b940d9e5acef8148d400a3139a0ac1f4e3d9d7911569a36afc6d42cec8debdbe717dce1b0c0766886095d1321d1817757a811ae278d32424aff563dc3e731a993bf9cb50ab9c4a900316b161a92432715ec6579c1c7e332d8d78a42ae69ba3b1ce7268f8e16db57ade12bc9263077f868970f3876d9eeec349e57eb2753a701565bfe4354929be57803692af1b81b1987076bf9c27183fab2683097d090cdef85b9eaeff14e02ca6e6e1f4d4ca32c913d7f10a2954761f543f2dfb6a5c49210906cd2fe46b72c156f3205e55496a423785a76f3d6bfe863171c39814eb36e82467d0092f52642b32b439b1a5a56605a1cba6a72e138bd22569390179561ea10cdc2b98de1ee45a79fa302b93308147954a586517e5a581963ed67cf93721579a79937128e6ddf35829202e0d5fe22b0092a9c3b28d68f68a9ead146e6eb44b2e0e49ddedff5aaa8cfe3785881e3984f2d077f9c4b56c32c7e108bf2714abecbcb91dc71f799c059a6fbe3effe682eec61d3426ae3268d76ec0f6d8ee3235e04d0e122a726fca13bd6ade3dfed72fc5891171337b5b82700f317e697cefaf2ae70580b396108f935455010bbdee3761715aec7a820940ad24db508d8e8da05c01d8f06249b4effbaf19c9fd7f9afd33fe328ce1220dbb42b831a577b630ff9d4665d35b97a68c63763108f3d9f57c662d4a8f794b5592a8dfde9db1f3b0935cba9f52ff006763d0cc9565e8bc5fc6c06d8446f026ac00a29a4d05ebabc7b60aad63f6fb8e7ab913d71065521debb73e4621d2099e7eaaae1c678986b28b9ffb9134838c09339df5d5bd15026188d6804726cf8a0effc5d1322509aea28b3fcf0e406963b1c18561a7d29bacd4804e7456cdfb42ae9f4a9aff830ce2f385a0d587db7937f6fb75b04ce31545d8da8494da9a77a0b731ee8129d951c22254481054d6e6817c156526d849876cc3ce6d6b3a9ff9f39b222590fa281fd80324c1d1bf1a1937c9c4fc5a6be11040ea34c114c98e5ac1c3b8e1bac7223f4897ac07c1f176d91a8ccd12894f93fa62c0f1adf9637467c6d00874f4644c900becdbde387c0faea555a33b6e315aa9b43a723639f230d370b4c80c29660d119bd5989c5a0fef5a0fa982b438cd70ef44db78bb2132185490388c946f1a827023db78ceef7cc6c08920116d9cc86fc77c18e5128acdbf1c84488932dcec4758ea593c253227ca5948fb4f879a7a742ca0925dbc88843d5b0699d650028ad8a9a2f508403e9bbf1598066f9fe2d556f6d4890418dcb2b1e980eb3fa44a76e7c179b237c1febdea8db4eae420476c1e2d8bd38e3cb5c69709514252acfbd2178570ccbb5d98097a3bb62248c8f3f0bff3431cd43365e27fb35dc51062cfc68d1b123f9a3310175f5916835a3966d7a8b76fad761834578f5bd5f194980cd0e424cc8e172bfd0bd153c420807c90e6c349749412bd735a924c63a5b22c543a7126d105d1fe6f28460ddff77044edc4641ea9861d3762c15dcd99044ce82f28f7b7e90d89b600debd525f6601e41657c20679c0f4abdeb6aac7294400245636d149985bed5ea4441c059038a1a676cf7c08e8772ebc1a7f956ceb6d95b386056f6033dce9358e5b68888931515e6399a33ced97ad8d01c8667ff4447f90a7d58a30ed3a39393f63701dbdabffed3e89d8e3a740df842edc76df5d4166456787f26351a1c56a2402a55f1165e42ed4fc606ebc7f02b3d3b54f9c29d17b4490280cd5ba5d3d04c1a12d794d5e635a77e0d0780601e1f9506b90344239063bf77ea62b1672a51ec87d60bd41dc9d1488bd2a0ad7090a4223f847078352635e488234f24a5275f110b0002496ed1874841df35d7ec323ef046deb880dc5a163f27ee227cc75dcf582796ec7a1017675d96a534bb01adb3d06ac5aad5386cbfc5019d10fd152de8484f174ebd3377d349ede73e2193018eaa1dacbfd26a233920aaf75c1a8d19f1944930aff2ba22540f2acc3a122e2d570ecbdc6c2c07e1bafc2cb34293da0333204ea5d509f96b216eb6151818c2e0bf91b99561329f8611c7b426a380ddc7f3c99e85857bf5d84f231f0a223ae7c84b2a379c742b9ce0afa9246e46f5180ddac1b421322d68f56e2c619e06b1153d9612bd9eb4754b7089827b56bfaa094fdf9df64295b3cbcb6da8b7c42cdffe4db0e6fb28ba0058471b9db8e87e83369c924083d1ddcf4faf566ed715fb5c8c9d82be662d13fc856ca8e234b695fc397b88c3d7b4a7a0d195fa2ac3a397c069b16f491fbe45ab8b219ec68ed8199cdd869c2f2213407c5ca1d4907b863a6fb1924c2b07db5e1d0e76b7d8da4387b2b1356bd4924b93d884c171bd09a376e5d47856eee18e5e441acf0dcd5cb6f0e6cbd80d577a830a6bb3a48c78712abe00c2397135ef101676470576b384ddc9dba5c9d1faa6c07e15e9c9b2fb147302f316dd07bf8b0513ca12b022b59b27b8862494d7cb14fd943751003738c799a7301b174e31fb22beb80dd7b2f98bf657e27bc068001b61baf7dddee1564bbd70c55af45e53826eb3b5807726a3c71e48f003135c40d3022bde8ec736ebedd433233334c0dbc7d56a3dfca2441f7ef5cfdc5517764aedafc64d5bd04f8c1963e9d88e6fc545b91e29de735442892d10f0436ee255aa129a5bbe3053d92bdc76536595a666328775cb0471b6a1cc2506067c75219ed59bfd4a5188009e3628f1423202d2e686ac5f6861a812237821bd4e8e3ce0747e6b6960ac282ae9caa2ef7bf5895dd89ea68cc9f0b43c36c975f20bd2855e38a4b1e7ad2d340aa68306a394e5cb9aada32d4ae2fbab7307bf59e29ac8dc20d649f56c2d093a2964d39a57918b61a2e3dd0ff5f9121ec18fcc99fdf2605d510edf7669983e2b1525469856a535e9da698c6002e89128c07fd588936ace1165bee18ae0bcba0756ce2d6cbb73e46ded1a8487530b84b8f5f099bf0567f714b584cca0997063cd97cf0931e22d15ce7fc36c77f54dcf51527acfd381bb911aa5af4e0e45aebc8e57e2e31090c25b1f20088df4552ace26cd8bea340e45c4a76adac11d27019f3e5dbd7d0774fc6d46662fda0ae498f3b512d950d975cac03a00fe80491f83ae4339daa90349aaa459e34787b45674fdc54cd3b26320bddfe3d6a7337496227908eb241ffa6cd5ebbb4ea85115f5bb0f975db5d3401fc60d3e73140f7df83af171be2bc5039b8e7cca2f66dae1707bfca58148286e56123840c7132535d42e321e4d26bd995d84f11a442f4fa5ffe0dab8a94c9affd826529458ef455cff5f31d72b91aded1db78ace0e69569cb0d0521da2f2658bd13c3e7be48903efb2f37d3c5fe7fe9d02b72622aca1a39d98434117f426e780632ad8272f761a8a7d01766b25aeae64234c87b274512965f57fe23c3bb296fc479c137cedb09d8e3d31936d6bac5820d3b4252f858da0c1d0ace4ca4ddf4febddbf960f4cf9d1c220a0d86ee50241f3af76c97f81d1ff268290988323e2daa93d1c0b182be0d43ffcbe91b5791b031036e85d978f1bb2c47624eb40680b86f40a8d8d88d8beec8f556ea0b912b3e8e222884c526d9814ae96191e5939e7b956ae9c61e13ce7e686e03f4e7e0703cd609aa10cf0185ef78471c7fbacb6bc69606cc38d98b47474bf31219fe62304b527fb6be0e517641683ecabf6e34a55c2de1e92a6d42a449375b1afe65dab57e1773570d7fe16b2a6a5e1af7f0309f35d0fddcb048b896e06e734b6f8e7b76ac774a9b6bd55571302e52caed977480704e40de516a8add2c5b4988fdf4b601107afb80bd30bb1aecc1a323ba0fb2b880acc6a88246378f10df188f71fbb9b842aed3822b819be1facaa549fd8123ea5515006b72d29e8e92e9b80c019ddece741b46ebf95d4eba830e752071a189944aafc170a377032e020c3ba215a88363cf1d8eec1063f13dd1b4493b227d12f20e13909cffed8a164a606c8d066d07759a7fdb3bc9184fdb0250619811f6904fae8a85a4b890efa4131b810116258642901a78d7b734e753bec23733933ee29dbf94b4da0316ee83c87e166e3cd908f6fd8a49e80ee8e2dd718beb6f017f56e86027d37043b26e23d00c02d855edb891b6bb991f0f44e32e1af78d8206729d0c5b6cc745596fb58b055c0b3bd4a340a649a95ebb0a08a376ea64d36291f6fca3f20a93aaed4cd9cbe984f296802438a0dea6995439f2823f06c5a164945c2d01baf7125adad54fdfcf9d99fab5b4ab41307087a242eaf6e7f0323cde57043f22b3cf66c14c42020b7d6ff07b98d590396e74280ef841cfb86acaf3247fa794dbf24b56894006effe978e5180bb0092df270dc37967fac867e500e8a7c356146336a4f34de523f75c753ef93c4a3fc40f348c1b77bbd38fff4c44df579108bce0823fdf1d7c4fa4bf0f23387cffce1c269c2994dc488120c27b82b59b5f999dcb97efe4ad125cdbb54af42a882e9f43dbb4ae6fcfa08fa2c45aa7b30043afdd8a07a6ca88bf4d0ec10c4cf63da5005e49d39fb97e5ad401bc090cc213ee275eca70e911a573be6d1c594e99e7715e404d72bde7378d3490b422f184fa782cb86dcf46f534d6dd96edda30b58b243f4196ea08e7c3de435295e1d8c92534f004d20c28de2f61dbf6c4485fac6cb21f2e157cd32d0dd896005cdcc0923dc01ed9aeee96d6914d011e0bad2ee741ddc0632b25a831d7f0538f2f64600877d5ae92fe61634713c7268b26a247f4318bb0ec13a1541cc4e58389fa779ec8042f5a1d56b483a6f91668f6b2c3d8b7951978efb21c7e4db69d3a076655185c0aa5614fc7c1b9518ad59d2c83c268fbb8b7f716076c767bf65186011b32e372362b5ad83abd39c4e656ae744d42021bdc316f2626b0adb96ec5635013aff2a1f80ded68d0a89e04cf3deaa891dc6a11c9ed9a0eebf96fd89b03779f253fc1272b8adb4ac0b860b62d0e8c4c6070975f0a15396b09aac58807c43713e2880623a49c6bb39f9aceab0bb53cee581ced46d2d0d7e80cf006e113ed835549e0d05ff37841a5f639073d852edaa6cb24c041b04e005dd92a9d922a78af41ceace3c49f0fad46fae328cbcbd84ada162a5ee183846264336ac75ec462f7c0717fb2cd18d74bbaf91fb903b5e19900b76891ec11fbf8e76816d818f0628aab2dfeccede22ebb237bd664be47f3826c8ccb640584b0ea6c9869bacb90dab325b00185c006cd128f66cab7baef32ecbc221185b1dba5456618420910f84070360022d1a2b3baea8e7504c038ce2eb4fd858f7c1bd8f1465f5312f81faaec4ea700196a8c65e9194f7217171aaeb9bef3a276485b3929cb78a28c5e4550213edabdf945efc1e9373f09f25b6de513364f02f772717e5304cb41d48c7deef0161455cb7a673a61081b3d85055003897ad60aea7b981593a0f4667df718570705ca57d725845ed967006f9d1e7c048bfc13c7df47cc8891c9048d22fb8bfb5c4d03490dc96b6612fff9ec640a4232d7ffba0bd613f0e2b83eeac2940b21290f4a2d1021a7b0976265842de80d0705416f35930cdc3e0e37b08881ffdded6b8f6f864ef98875e74f296d7ffbaeee5b64e8614e1849a216f58ede8f22851d1717f88b848c0c0ae8d88a7a966198c1c2297631a346bfb89961a14483a1e327f1de0cdefc27bf7562c9cc572f9fd694edc71e6cd48a83bbbd55a47901d00caa13ff668db100702ac9a3c1405c4ee5d9101be25b0f688ac6864ce9c9d7ad3c5227e391f3f1f7cac00eea69a80d940296b921d2fa4eb028d2fdc0288bf84d055dd782984b2e6fab39d6977a71f8964507ec16eecd181d3fadd01fd3f75c8464a0217ef01c274176342c34d0990aab717321ad50a84bd6dadc138fd4b1be8a21dfdd55435f80dff8fd2e23d00758461798effc68c08be43bc291cf2ac6cbd51da40679f74f83d88b19f58771c1e907656b85559a6575fa4992041c72a6318f37628af805cc511bc8a055c4243e4ed75afde6e8c8e5470c42b809620e0ea1b8c78089983fd18dcc58b0ec2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
