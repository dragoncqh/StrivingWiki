<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bbca900616edf2a939e36f5f98cdda77ba39ae50d4586493a7d218a6ad929d1bcab384d9f148d09d88dbf0cd7e51836f1aeca56e64bf9b349c80e555e8772fd65bc7988c8f1a0be7d5bbb3c28c19063abbbfebb22c43ff12f0e8a405f87aeed6422931740a98c64d846c369840c3c8632faabbdb22fa472f42fcba9305485256d9488c100f97afb4312079130e9b0f6fcfd24f379eaea4cc310313023e3a27d85d2a912cef64006d89048ac4278d72e3f5cef2058eb4bbddbfb832f4d356236c4e6981ce4fb6efc949a5f59a4555da0c0b8f6e7c6d25a7b38e8af53c50ad43cc3a8a132d5e1fa7aeee0d86337aba5e11ac2271f2ea9e9663c0fc39bf22500f2e06346ad9507d2158c77f67e1950efdff776aa309e3a4af4f87e8f204ef9ff837e8f39bcef7384cc44ec4ecd30661254b225ab8514608d97075a260ec83df0c887268a8184ecbcb5ac5a0391eb62a43a7ad04c757c8babb50549692ae413b3d6f00878e62d0b5050e921d1f30403ac9771e509cf29699fbbe1338e8f5ed5870473b19b75b1078c2c5744152f547aa93280282a9481a14ded3868435f088f1a3dcffbb0c0e99037e1e3814754d94961c8cd514f759bf5e20742147d2ae9df44dc725b28079194e6783154f00dbf16925c9f85e5bb305058142705036f53665f148d66b2f2f234dab34b5153facb5e6a8e96fe293e4c03e4eb01cd1f17285373b50ec251e11a09c19d6d0a1ceae708a110b5e9aeeb40dbbe30c5503453d216154388a13661072827076ffddbbd99e0cbb16941c699f4098035df4ec569e682acbb7c7d93aec36967212970aac2134feafdb2962402a9b3182d80c48a5755f6095904bb5dc5a23ad43d5d50b9cdbd33ca0dee88a0acadf378cc5fbd96fdbc11eb820393d7aa5bf528b62ca4ca9df65c97865447ca03267cae2668b301480cae3622cb56cc900ba2cd5faea1d89ee805b0024a7d42e330569146bf05b10c0e334a066da5f96ec9740d3bb0c716e8bdeda9db11dbecf848fecbd53bb72603107aa19d3bec1a42bdc64e52d51b6ea59cad649e68d4668bad2be10eb6d1934b6c3eaf54d7c6a7c32f9773b230b360b42384a45d9ecae6377e580263b60fb2e1a15083d257a3abb5560adecb3cdb079cedcfc380df293c1b1e1cfc932d248c4302118e5966b9f198176d4e0093e9f0482251880d02b717497d5be1bf892826af41a7829726282a9db0d4d9337bb669eff2b68c4e62335ddfdcf372607d6634fc1055a2f972f4d23b8cee8cad736c47bca8698f3d1f5d1ddc1de5166ef9d5933aa579ec2211946969fa9ba91f82fe6c0258afc69019abf2fccb1b0feb1ccf51788db9049a24f77c7e5632135fd32f1d9b3ddce3e716a9b013964828731eb783ec3610e629dcef47eda9a5fcf34dc53999b35c65994645fdaf2be16b163a06f46e3df461f5460f4988d022c478248e0eebed300ff66eb2b8ade6b8e8edf863302b1c6ddf66880f3461660ace51912aa653e95c38f0ad4e47a38dacbc43792f6aca0ab8af451c3acea59bd94a360b95c321f4676df8e67b0754e6e293bc4330afe2e392184ad691f319c0c0e9bf093291cb7824616a59329bd12b5e657d097ee258828b59c248e4a0bbf10eab9f40cc6201f6a64acdc43e84f302a528339f4e478991561fa6bfc24ac485813c9750718be3faefd3480d94f3cab6311a702ce8c02e626c8f7f087d24eb1d63b41fda6e6a0dd445a10447864370ab51b1b1c16324f6946069d7047f4732bb0c1296b3c67f7ff4db7d858caae3a5422e89b15d1ced27d5e299bc6f68a838f9fc49647fb24dda925e8bd1bf9f75fad513d6d9f4907388f9d4882287af0346a4f406afbe9c1356ee050f9d39d718061299ddab932d3904d0ca35a500f986852040b1d099512829fd152fcf54b2df2d5c975a782e720969190b37d329c484e62f1425e2ace2a9a4e3f34abba551206c0a1d94a15aa15f928565638a73585c0beb14aa9e654108cfb0f0c0fe58accc5bd169771a1b389161ada4810e5196599fd3b9402c36722f53588e07a4827b9705c7a5e3ed5be0964957ab90a5ac5e1ab620284f331d2b37090c39e6230afe94765624fddcc9aeaa09215dd7786c97a292dd75615ddcef0707736115f834c92b63106c5ca6f0a47eb941247dac3daff9e6a244119885bd6774f6f8fae35bdd9277037eb2af300f7f5a0382a0b4f014f83739bc12ffa14837285aeb3426a0a9ccf18f0df31ec914ae39d18551e1563af1199719c9cc2f97b5d7970c21ac17fc01372d5e63c9b2197b789692c8bd645e4560cc876bbcfbff97b9b1428fd0bc7572384fde107f71a80decfb0df4fe4b01158f814f42e63c0d5e727573836beab6b0ffcd4a65bce2b42e784fc97c63b315f87fec0b5c60637ec91074073a0256d6ac08b0dfe28a503aae64ab5cd57cab3c08a1d5bbad02dd3d84f71af0e1aa6e5c623e5fc4e003338cac45e31b0460b00f8bd337e733c4653c1dc0434fda769fe86921699b90155ed889b9e4263d6fe35bd10eb72b32523a995f3b094e872d8a34b08176bc4d54d3c4fffd2dbf6adb47d3239d469309c9d5a47282db5fd4c76fc8f8cccf3c2c17aed9eb8dc25bafcceca8b716cf261c7b6f33ecf7148c031f9c5d2157a31a2241ca3114e4a350e9134d0a01770d8be6ac77f5356bc9f4c61b5a0f7c3812095efeb591d625eb5331b9b71a4b6100200a929448639c626afb79515e13efdfe2ef487d90c906db8d2be394ed203e5fd5100596eb9f0e6457bc084fa06b0b9d564e98e71ba9a3b1f19f53c3fbcc95778c59ba03a10b96c3d83b418c3d512710c39c5ebb9afdffeab3e7d796c75b9aa54e7a4fc9dd44bde468a203d64feff11d4d3140198260d45b1e97a2f57137a856567f980ce3c2f6451c0f534aa0844651b60dc45fbd3feb6225e63aa125397a6603724ca0e63510f9e27070a39a79615457d842a2b8546fa6fea3fe5e86981ffa48955c49ef37b0314695577c8e0b69b8e328a3a7018c4e285fe1c82c7457b58101e6d00a3b26c143ca4ccf6608d58225f8b9ee0eb737274e3a9b4df61579720aef5f1cfa3bcd350d7a88770c2e6350c5d837754f5fdf433c308e403e56da5a0d2c3cd7f5810b37009a26f61f8f227bf490bf57c3e7ceaffcc0a96e0e5fec45b8f671046553215b50d716290745a40a6d8007569c647e2e2b8d8c733e6614c4121494757027adc15ba43dac7cda12f9f9c460ff9a5c72ae55bb00bd4dcae01f94d84f36e99065c646ed9c02d5c9e6ce9eaa0326d6afaea8e23e7667f743a3dda36d1c83c2c6b702db3f2312409ca8932c4ae35fbdf3c84fdeeb6cfa025e48d11ca815a7bd18bea2f883f92ff81291dd7ab9b8dda8ba45c483c40e5994f7173c88ad143f4be0151ec6346a7430aa28ca7516f09b68882c91c56c9257ff5a0843840c5ceb8d7adc70dc15fe3f8742fb2c9aa682871298caeed012294658148bfe6b692c20e27195a7af34e3465f4693120bb1c7619af6dfc999db81dfbd222efd2080706bdbb47f9c88ad60682db0dcce571e510ec8b58ab69e7045dd919cd589915ed37b33492df24baf6490243267a4465732d133d88cff76877220684b0035a3e531eb6b0688044cd1270e6dc04f463a1a917feb24f5dccced80efffa354131507d68297b294dfad27892f619ab3e3854b7ee9fccf08f38ae88a177a9654a817de85a7741d3e14e0ddd94ba5ed34e38583be1ddac17736a9f931e1cc154975db5affb187911027bc46c4684abf269ee29a21aa91424b0db9348e42f48f745500a8114571ead7dcbc62906b267a4088169b6673e1ad7e23d9fcff2be69980be691b2bfc202d69b67bf3972f00f7c71eda39ec22f6c678cf8f5728aefe0d78810ed848685f8f61666928e1defe8bc97011bbf1d15eb51843e853d87683906df958e6646378ea4764ff74dd82fc4475c19fe3c4588c101a7d6c6e0e44f7dae59042e9d975a55b7399fab65dbe4fa5060919772b9274e2a1ba6b25f63e5887dc7a97602352a99ed4c1dc467ec51ba7f86799f43708c3409b2815dc8597ce8694641f55a70c88c75057b52dc719d84622d9155557132e8e37a6b36ad7c9f325dff8753a4a592df14822f65b03e4900e891ee51abe350bbf2026a8392241527b7c1f5a4abc4537ed5c4d7f46cd91ea81ef89c433f9747fdf5ee9442f7ae476bf14bb271ff1fc1416366dac0f56ca7d4dce3c14a6819d33c0d5c0443dadfd189e27fa1947f5f1ea1ebb2ff356f22f1fc9cbd2f8a92dcf49681063a0b54edfa1e3e2b02c3e41e1812cfe921d92e0edd3539ad594050e2995d7325ac0fc8c0608d7b85b1e90dc83013faa2d8565316a8ee427c5d6a37e5b16e24fa0127d70d87f77589dd668cd87a1897c82a1df7126713bb58bf78ab7fd2938c9dd00ccbd703514a52c4353491b930cbe12601f1a69491197f824264e7cf9f2920672f93a63f54c6f1a29fc5d120b853ea0e6848c1a1a8bb3bcc11751c2739f4fef9f4fbbd97143397361a6703dfa15e7ea0f116246a1699058afe4c8e13432808397c53c241f848a6897bb6af3e41b4065852fae5f0628f43b56d164e1cc73c059447f4a9020513749d275d41cde420b4d37bec6d4c9d832538d67d2b0f7f6a0b99294b11e52bb3214ff0a7ab054ac163083ba4e0d0592cb87aa025568e6c59b547bbc389330e9294619ee0d5bb4d9b9ded9ea35100ee905fcee21a1b8d3b3d996be9874a2125e3971e72f29c2b5fe8378a13a0a63c4c8b6cc387037c3d4737ddad4b76f6b4111d50bc35eeebccf71bdd4e28c5366fd5c26080043b310d7a5189ddad8509f1d50e5ff6c2281f46037cb589bfe4001bcefc61ad1288c69e99c1b7fabcbc1e2a1221e360a689fe1e5fec233a2ad0b134fe1e9fe17ab0d68c94f99b6089877cdf77e2ac3edcd22d60af82019a06832cdbd29c358504e73e2fbc28c7fa5f042c116151d6ca824dc53b390df2ea163e8d1b54efeffb49555cd205b00dd2f7b5009a9dff774683c220934da261a2d134d19cbafed67b3c3ba0161342a5efcd081cc17d644a4f9345b95a0b186b69e8f815b6f68d166db77bb6ba874a46213d8eeda6bfb6088e7458503d83226bde682292ba355209b4f9e15e199e3a4e0e0352735475e8886278338b7807aaedd07738ce14e8d8ebf9897e0717cc23511db14df01d2a7aff9026651e3da35456f6be99a7ce3608a5ce4922b283313b995a0bfa9134cb087cd370eb27fca8898bbf28a4b13826e0a965ff26af5b877685c2ab9d42efdf5a87d42f9fdf9b00ee1f2167f5eba8d7aeff7c4f75b8b70fdb34926989cf645e7edf86cfa6bcde2deb8fee3ea232565e4df0ff1094d4c61ada7a870830f1575b3e45b6588f30212f594243ea8071982c5da9c9f6249c20e941f4ab9d29ff4aae62d852f356b813ffc3c456989b7bcb0cb1bd939e839b4d75066aa9ea45b13144fd4ebc1ad0960a1d83dbe4cf91215c95dd963e26ba3bc4abb80fd148988487243bc9ccf921ec816e639fb802fb5478858733a639e95a6c3b8a1cfa3bba2a1c435f01f011d40f05db88a91bd243ca657d606ff2ae8ab610a08b40e89782220da8457016be8bfbcfc320e2a8b5544e3cd3e759328a3fc6a988e9cb5036d6ba25454cc509d2f5f9205722ec03047173831cb9fd9a998bbbda112129bf115e82899185f41b50f4419c3ee54d0656e82ac6c21dff1aec1060d65a9713736875d006f5f70a73bb67a7b430e07b15d572b4b7746a02629e8799eba484bb6c4a6aea576108325ddf6b8c0a1716fe6b2b6a95a346f6a5c00d5a2d6123b0040d70aab4c8811931742316a4bd2797510a48811ee9150d72bee4f2f5dbde483e94cea67ec4f6b7c134d83e0d364db16e3bd814d4d2ab81117ea6fab4fd6441c39cb642d7ab91d335b1e078a20e86ec4d1c6cac541fe7e930494a68ce3a4461a233e912cd1307529c48f957e6fa9a4555f12cd231f2767c842074d11f2dcd81e4f3d1562d529dbf27f5379585e875490c4e21b3740876966a0edec60c95c53f07f90f950ef6bd51495581242dea61a95fa456d8eadc8dfe164a9e26b59d6a90f904af1bcc64d89470c4b1e70f758893e8236f082ceef341d71838e32ba12b34b9eb0b4f487e259d13c0aa00dd3241397e203ab64f3311a8ee597361239be0e8e4cecc0d0368f6ddf8728d4b4b559c957045f0ba5800abb8d1407bb891b2b2be584af6605136eb3dc45a3add75fcda951e3ed1f76d56678c830d209d0dff573ddb5e1989af5d8efc877000c2bae79650da21d7a5740316f01f8bd914dd44d4b6d1a1f37adffa8a09528527e04148bbe79c152304b994c29d064a10ac0516c48ffc0564634700d84538c03d7058d3f9f7568e1119ac79f1c6cf8dc33d2f996d37b2fb6f3b65f0b798b496ef26657dc5ae31fc218eae6cccbf518d87bc105ccdbc53729c4cecdf7f0a343f3737a393a04e9a3e2d0b8418ac0b0902589e2e84f13e6ffa1193b0b1fd3ab82563686be3664302e2f27be1a58211462927dbc9592e7aed9e18646e57eb02d4e3d6ef2e586894995e2866946d860406ca7e94bbbee018fe588fc8c3296c790bb3e495503a256b96ad5fcb8b4a30251e4a5a09e678f1b73c9bcff762e99562aceaccbc0495db10b7dad88bcd0f2f6d3fffaa6558761b456ae19b098a65d43ca89080b36ee3c1a1748714fc15d67ce5def822d82fe6caf72b6977e704e415c2a22b4ff14005f9142e1adb083e608a8e0a735387308774c0354b502f3ce7742f499c0696aad8e3427ef56b0c1f88b2838842fe2d9d6d59ad04b579928e5fd0ebb03a44d4d7767c7769013190c66605353c855bbd1749cf0e4d4da9f874e63ae6d185e12d40f2ad6e7e1c34b719fa050a4a567649024414aefdfdda9cd47faa54ed8ccd9ae29d145c0102df8869718ce6de128beee1e55c37fbe0baea44f3472f9133133be8654dd0474602f0d96a35dc0c2e97c063aba56ca3146c585429a6462386d8b56708b43bb1aee6fd16e7617bab80012d9e527b0a64e9f211699d6a28f97df1664d5616227c866880cdc081da49c5ee9fc967f17fb2ed3a307fd195c4d88cc70f9948b16a950975f86a4679aa41a8a2f339414d704ce290079701d45d4e8c158a4ec0e2a8f02232756483702fb2a1f0c3c3b00e789acf39110fd6cc9a022ad04a0445e537fda689f7a3ae8329aa23a58e2b5a004c7b3fd4f7de70f4d39201c73ef56e5041b0da2c603d459ea949b86694ac3ee805c37d1f86a8ae32a771fbf7e2552d39c4379277088b8af388e6ed0f90f6b010b363111d8931ebd716a0c902008c5bad3bfe7bbd05309046a3c23f905d35b5e22390c1299fed26bff03ef56b88e8f5923ff3e3ab15961f0490d7d2c6d4e6d6768cd1af3a0c1569c88c973c3f36e751bb59d05a53ed75fa6306e3f53fcd6c327df049a5c14a1c64923599c2130da044dbf140a76102f4d2a0725ae01dc1dcfc32acc22eb24f2d690092ae4f830963d6ae708a05328c24bace56373585b56d6a3ed4b68f9785c91df330e2748cda51a96c5a91efda56ed74608f560d4b7285a76c8b325582e307fad8e5a7e030cb4e39b01bf86e2110cd1d69fecbb0e815b433d9a677d913b683a7b8e7002e313a87987daba299592ff2bfede207b9803c98a65e89aca2799f3664d0d9fe648e199b7a151ae72c84d8dbb549456f0d0e4d633201891b3b10afd1e701acf8555471c084382cad18ec3e2d504d8207a711e46d8213d1af6c70d7c1e330a85edb4cec38a809080b9676705d7f9b76caff54c37a67a206a6fa6443ffd44375136c4b0efeeb2e56c71adb697d783860c863b51cd479d31d456acb9a258797796302d184373fa91b34f37c5cdea05b642286ee20b0898ecff2efa034f7595724f8a95f8ecda962569494341f5cfb695512a799d59ef2475ac5f8c5ae015cc06750f7708f7617c08f0a175a21ad0b557d5ed4d8986536d7becf6556694812b52435a52e53eb4950b73e3a14fd1a461d6fb53c3bb1f21bbfd678e3d1eeade2c653f776a654340328b3b55179be4459240ee76e340af5923796eacc480c49612e5a66de4ee642b622331d79d1e50e370e45596b4edc5939b994d81596fdc2b96050709d4d7ecc924be2be7749414f390306198a2f68f95fa9a0739c6908b6968d179c9c29cee398c7a126ec78072f29c35977dbdcb5e895db3535920c370b1d2e5bfa73068ae92f18ef70b11a08c22dbfe133fa14e3f4184ce207b4d77e73e036175e4e8b7ec1c63d16a6a2ad37eb22bb1bcca0ec975eff4ae768f34d397fc1a8427c1ecca3b141c0298dd91f899e7b6a40dc8b6964c86b671e2c74cb050b4a58a5b191cce6a2279629747d44bc64e0a9f1412b05ee29a04cf28d987ba526744070b5932375b7315c191cb5871fd86c2b21707d5d2815a26c330908f24077ff08bb57ef08dc99e3a261dbbdebd8f00cbdc7c2b6e2bfbe9657d897503159b0338ccc85fd0ed43c15446ab1a2c7dfcf129ceb063ab5967eee089150b8fc6d7d90a6d1acfd6ec0f8f500fb98eca7c8aabc5b00856d67d8cbdcf82a0872e30682a16cd3670c0b306a413b22a95d49992141717cfaae80838eebb845d24d187d09809f180500c5379a6bcb474370b03d4b0c43ba97d83d82a088a4754d019cb1aebc97e261041cb7b4d1a87d7789ad631ec0af0f612ccdc7a5f968a818404ce14128186fd72fb92b691b821bff7ca7eab1c3ea8bf92485e64243270af625f9d7fa95423e763e5ff67c4ee1b87b4691a89d64d3acc7128116d17039b4e0bcffbfa551724ccba4340d70c07654b95f39100d26e3a15183b2b51801ffa3c47f8a7dcaaa6fa002772a35ff5544a6eb42dfcbf04bf71e4f0b326b5e83a6bbba9fb582400511cf61410d19387ffc44029342bbd7fb9e06e0ee0255da1ff59c20eb00d8029615e20d69bed7c43756c0b92ccff8e537b8d5862b8f6a719179d9a08a7a1dcd7d2f21bb726d145aec701345828e6de92211ddb38f3634270be0e5cdd80404d7591e4e1993863072481d948f1f85d3d92f5655c0eac81a94343ac4a196fa4d26a1deb1ba2b2d6deacd1f26f132ea6f62f661bc89b714bcfb16c670d21dd750a3db3abad51e4d359ffac3a42d73c3403d11efb40d5c37ec8d220c00e663b5311f4e7b6eae5914ac8563b2715594046d4e6f686c6121d9710c097d1ecbd86244f34742e90472f5492ddee5f9fc6797b3774014459df4f0165fe7719fc457648c9da6962064f399f096b056f7eacf3c05befd050b0923f0949c0b42109c36db284ae80cd3e826f0c2082c74341d195e423e44b2ce0d47b82fc0ab6e71aefc39fccaf6f03a081ecd083cf1c4f7639edbba800814ec8198290f9443f7da927e85fe608b8d1fa23167b9def55dc661ea982a1d5f7b34aff8569e168c5a6a32797b74c1ff341c17b0b4186c770e25b68723a2a098fb4b6c3a005b133fa03448b499ef956253df407f9b26e0417658f1c32adfbf09ddd34d0496fc9d52579b50bd1c6d4522f3dbd32c7c1b51678eff80d4e28bdf70a236ece4c6f0bd84b129910d9bee0565f145f11eb4d0ced08a711c72df2e528aef57cd10d104488f6198e0f63bc24a0dfab1d5fb7a8169d693bd8dba3c48a5b7a3a5ebe791643b1042ac4689a762ce0a28fd1ea5e894b408cf174253ae73d42a1364cd8f4e1ca305acdd64d5e5493173ed489ef8d9d7be2f7fffb2d4a22ba5588adb61716e18b091dac6009b4530f2ebd39932318a0ef9438fea6d44b871c9dc0fe720fb38ae55ef8f2d6c1ce9211779c04c828402cfa5401c9d1736e560b391f2de1316646cf933b46d4eae89e2bcfb5e15c6cdf1b1e974019def89c0156cf277ea14e704b34b6333eff2a33a3ec46b2bb0608ecaf5f26617190e5b872857df33050bb1a50d8628342de26c93e02e61ad8123ba8baa195fd9c4318ac4abf39d63e7c606ff3990053326f832d9dfec686ea6a8cb44656babfde2677a03ffd59c6993921c7bad4a0f6b69aaf91a75cf8659bc2bca0b1bdf2c4068b90311c10c91e8a985dce608318bac8e587a6b51b07d0c6588966deded09eccc0d5e22a840fdae72431ccf2bff224f95d526502637d70e5aba6931d096b885b8fb02eb0d79433ac55f3ae55c3cbeb71d525795f91c730e9c31b69ece58668d34d9ba50f3020f6580293110967ff39bcd47e4282df0170d797077db0e71164312dd65b79ed1433d7757b9d11af4f3e0db2fde950231d7d626ec8f456a7975bfbc097d115e6270272c4dbf71c9ee3a4ea52669ea85a58d130b867984826012aed9e9eb2bb7742a178d91f022e3514df321f25f666986130f780612a17be30d14d129e8ace26a0ebf7bc7c3a930adfa702a458782b20b14","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
