<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2e2504c071ddc0fd414c423de30d7069581bc03e78a9c7c9d17b05bba8459c4ff4619d01f430a46d350e6e33386b91387071b22793a4e26cf4c55d81eb451b009493f2037f69c1969ac6aa4a7ae1738b98977e6d6bdbd17ec7d002147013d73f6452716f8a7059a8bf157d6483000036d0120ef707abe9a7694b32299be8eacfdfed8ac9fbd71b466a588fa1b57c070a23e1f19bcce50450b0d2d3a81d6c28778b75cac2820da2596b5cbd13bc6b98e93d4751c05f378e5b12aec7208063028081ed5ea15d0fd9d61e992193015027103f0116421f969bd0ddcc2bcc95c80e26894372fadf455a076d17f6d69a8c7de81a93d05c9d3ded105f6a88bf4a3d501fc09b79afb62c203b6af004952fe7dd332edaa9ad97e88db1b9d3eec162677d905dbf3538141b2bf60723a2078613c723843ea4c6fe764602ce2318498f745b2e873fc08216fdeff2dbcc71e8774fde0861b82a54b2044a352f37a19aa69a552b799ab89791e35c0809a90fe9af81e9cd90daefe46b15b858f386c1faca484245ecc090e361b4f16ee9f723a41e989dc71ff7454b923d964cc3de80a68bfd9e2550cb648cd230f8fdb819e3e2fe5269f91746f85b4ef86ce37dda27c613f74beb2927b017c4a4a637a950a5b0593b07db188f1fc94011b6a21f592022358c74c33536cba25cc305c7f223c8e1babc4b3dc3557fbc7939fdd2360256475b986821288135d9560dc9bb621d042ef36b6e12efc3a9f1e8c6a4429f8c5ad37ba9384aa7f11b1e30966ca7ffa45bab97db3dce210764475c3cb4b54de754000032dd00eefbe99d640e4955a743b528ed51206e4a5c3342f580fba699fbb7c1a1832aa906925a3a5062180d6d2677237008f1bac1827de3601121e446350268b943c95a7671a5d323fd342c132bf58962564005f8d7bcd36018104e82323c714aac76c40887f1122695d2fffb00dc7294a83bf16ef848684c547cdf3185c5d4a6c4fb1956f8963d3dc2a7da0cb5065557d53b863e64ae21b265e9269b25864db749ac2900c3ed32124142bdcdd102fd1915707e5cd1d93181211cfda83a796c178162195160045366b2a2c976b1a2948176bea54edeb9b6c42ec4f0fe1f74f9a68fda62eeb4e6e4a708ee7499ac8763760c413d3c437e9e161eec8779d4a90c1fa6de95d1aaf9b4247d8ffcea2b819d1dc3f03f8f95067be280c28976b641b24feb4875fb20c55eeab5283c1b447f2eb38268446316f87531139c85ab141a39e6d83b33b101515167f6b9484fc62d9564898d4d567d5a9d108b238ec5ddcb5df31746bfa3bd1ba4764c5f1f49ba95f02500b011a5252da50cb17b39ee4877c33f43c5942c9580f0cabc0f09d8809fab0949c98ef4168e8d68c0e12ff5107139d3f3bc9528c384439cefc47bf9bc4377cb53b821532717ef22045dc3a5861ed499f342a23b0481a050ea69737cb53bfbef129e684dc3f4df3548b07d1d8b82094ca066596c1665a2fd7a3f57cd570036ee46e276e1eff0361ca841f7995192a185b27931f0641bcb22e2aab36ecf510b4b812f3fd758a68fec400f799b4c0397b9cfae7aa458b3f771eeb7f5b0ac01aed2ec9c85cb506365be7a4dd3575492af7606d6219f466becf0143d0c37ec99f1246283de437871ab1f808a597303c25d63c374bf2f774e9c8d993057dd4b527f5f553efbebf3dd45d376e0867dddec12c39619ef73315e27ccd5dabead589e515b2e75886f00b7bb7b9e23fac8a4932fd2f5adddfc5a579f1a07212973953919cc29bb1468604d9bbfc324e92022c9371c51ab5c81810aad9e68ff006e766a18872c4192d280f785bc55079e2999a06e810bc4b7b133538915f708d5172f7ba5ee68a7b560fce79dc622a387315971955d4cbd634db7a2345f40cb34f21bc2c351936f896256d8daaef02821f147a2e59a081c7cb2150339d38f6dbf54ce444ff2882c3677745e648eda8b5bbd8582577ab1ad27696264174fcd4a010cc1c02d09b7582d80d31a312caad0eb7c0e1e8eca47ab6351a240af535ed09ae0f4b152d24209bbdd9e9014af503545217eac449af8d4166f663acdd52facc7e65a15edb9e2d7aa98b1a1197aa4e14528b314669d3ef1e8338ca041bf0d4c92b922fe67deaba666073288dd416e4804fe8718e31a409595f9479cef4ea90cabdafdc93bda10fafc7af9c1b91c9c7c539bdf26b3c2f6d845ee0c53953adbfd6174cd22773be013f410eb18321c5aba52155474f0ce11dc5bc27927039cf584edce8330526dbc71c6b280f43f33fe7f0c2a80f9519a59f3bdc4787910eb70e5cb84181adc5b6293d630bf403b73fae23971a611b5adc344a375c915b8b26d1d7784210261743690ae7be25125131703515c589d1af827dd7dc57d5dc37b2c9edac6b745bc9516097a59f48030c0adeb3ddae39e249c8a3d3655e03ca8334c10a6fc8c3842403199252386b457db8a7ae801606fc87b93711ba71698447fc3f21bb768a86f896d6803b660198cd8a93307eb3caf227e02655e33f94a35fe5bb47e5f900be81231809fe2627d1631bd53d8912907515a1f3430d0f1ded4e45b43d2533ef5b9b7a56429004ba283877cfdcce5e24aac3cd4c21139070e2224039b13c71ca0ff95dc52e3404eee92b783d459e3ad8b3c73ab8a78ae72d9cae2186a18683ab5dbebcf7e48540b129a8f5341493c2b605db486390e1bef4863910c18f3928e443137e3d8c1a7c2db3fcda32466947d378e5b1299167340961b98aa358b036fcfbc0652208bd40ae1ee0da37274657c14e0410e9fbed846484a65a1622ef3f4d20bba309328d87bbda382f79f7c510939eed28031f66fcc920e852eb5afabc7a0237e3e202c375ead0f1a4512aeee300aec61bc07f744fa159e8ebe13d9e5db928f9a9241a9e2378b8816a43930533a7aaa590956ca783e4765cb583430cb45e4f24bd930daefdd90c0b78b873451845abdb25c20ff842bb0cda1dd7bf7333c946d7daf6547cf02a2957277c6db5a0a640051dfe930088ba9f72618df83030747f72d36a53aba7761e8580900e8a58d754679d4739f96865de87d9da4451b1e1209d8bff349b0ecd9b1fe8fe346f4ddf213a2278bb3b10333a6cdddb5f08cf25f4964e07cd41c58582c7fe976f2728dd3cb6fd37b1b4ce3031784904b28386368c1f2ad516cc8cfc0424357b32edd628632964c0430f48941afc322c7e4007dae8e2d55d6b8cf91a46901950d3909c5034fa1b6b9f48dfbc9ca46bcfcec4a63b233f7bd275718b85f64f1641182b310fefa3829b453314d9c57bca9de3a4e655e86afcb8f49917e1ffe0e86fc5437aae58a18335a9bc1b4188ec0e8481d0681fd120520e758090ced2da919a280f3fe9f099d8a21c9251308b96d21f7032e37e90e72a8e18907f0910b3b475fd49b7db71aa891c2e463e3ec855f1f4fc53b3eb7718685c733247c61a66c8a05b09244dfa03f9e49a0866da0025310765c7fc3b6922168c21073040e5039b45dec9af2fdf718a8259fa002f44bd63ba03a1875d0e7fb61ddb88636dafd91cdce095fc80e651633d063b0c2f49a03657bcea910aaf581523caab1cfbedc3cd1d528966b0040e0f861032b215bcb97542f757ca9e7863dfa6b1f40564eabce92e99107a7460dd05efd24223aba293468a62ef037a495691f25922078d842740c3d6b5db001597d75de7addd86472b346f500426437a107ead8c91be53b6e4b8b0e816859f43d59bff3904d7f5a1fcaf20aa8b67d3f13500a8899eef99835aafd075fa65d58cdc09bfa8300b3ba3277468415f128431606aac41ef9e542d702d73ae2cea692c91ed71d65a731e0f5bc72edff259a9118ef7a9f6bd821c9ad5e69a4265e939e79ff915b464b2161599479358d499520e2799c9e1b63a058a11fd7ff13dc300c11851a7875c945adbd3618cd70ca978be3032e8526251c98cd7a5ad016d1a38ef3250e7897a51ce79005f38006921a7c004bc0b1c0f3f4ebab439c1ce9e524892f37c14cc6e6b1bf5e90fdab3e369ed0d1b96b980f1859b2b6eb939a3b85db8f3c3c9ce286322032b3e90d08be12489ca1b9b5227e5e6678c4f907b78aa6a06789023600f777dcd49767d0cd96413fd184f10bab4763a8e96e2d14c215ee4944b78e0ad3c8e0b588d92766a2b855d8950432d31c9a3b7b8ba86482db0fa65955b4fe8ab94bd6ec04f969171f96f2e7f805f074460734cab03fea6ed7147d671f7704b8d64f6e72b483c0374c62f4d61d3358ddf163df3d68cfa98f429c01709c4b1cfea7ae9f45816abc7d6585935df3fcad0478434a5eba79f744f5d1c3b80320a5ca2a3e64bb81c65a3b0bbca19f615595b5b1ea05c5bac6511381605c9efe6e242bba27edd6e70e2c11525c5128786bb0941ce773e6189e676accb535412ec1f104512e77dc81d864a0e10b5e38dd28ea767712fbcce62a24f6d53af29a96e5cd9e2d288b19c8c473acf925e524489ee9e66b6e944c16ea96db984324a1f29c07d720f301ffd48ede7215f7cdfb19f2562782d73f939f68a37ac46e391385263a156c902e767c1b03af9d892a46ab9e1ff7cd3d7f24f683405b984c35a980a6144a35751ed043fe10f007eddad27609cf95a50f0104eb88d9d8e1b7a1c4869b7ec918b95085883e288b9e62117458bbf6fa62947f30895c2c091b6a5aae10d2a0e617668eae642b320903233331d188043ba2f764de289646168f2931a092808d60787bb6c594d2e65fa605fb514fea0a894487a87a006c4e2868ca85e58e7e6766356b047d6146e90913303e19568ed98af77440d66c44f4efb20cd75c7f3929ac15b33bcb38631f89e0f6e9f12c090010976f885b0601fffe7ef1e8ee71fee095dcb8fdb079a7becfd5259ee00f1b5d2048e3efc8fdbeefdef9ba8314f242adae98a74974f90ffc2a3afc5234af0a3d81bbaa418b52fff107496f52bcea1b7e76a75d2e63cefa8ce03f029cdffff016e1f4befb655a7b936cf9238279060a5e70b4627502351156fb410636d91247fb5ee0cf36890b939a6dc3bf12bfbd7d9b1fcb703f1b5a94a9ea4066c72d489b8a8518105900b4bd64f88d65828a1e32543bc6702eb08ca8d8b7ac5e802b028aba596a3ee6f7e70f595cab35b658c31df59cd7220e8dfae3a6240066e5fb7cde928d080a3d1e70b11c000edfa6c65948411aac979394b6ecda85b396daff5d927a81c8728232f1734275e8b047751a167c96db72c223a953c7f76fd145a8dc41761fdc4ee999f1f1d7f8d5c74aecffa227fe606a46c0ce1ba9c2accddfdbefa1ab05ae185b28781f96f0a514e6952203b36666ffad7f5aaaeaced8c9dccb8b1adb8449e83aa2914da77a2c7735f719e47556eda7897accce11225c2bc5a1f2bfc88653be101f66ba0b3e772a85d46c35979fec405651f25b00663e0438316204f80689856ff69ef0ed6d119060b8f8ee2fc7539804ca95720273b30c25d97378335ede257f11523b797cee1df09e17daa790e0d7428e4195bc0459ec112410b119390f1a6993e15ca0982939f102cd8fa2fa78b683a47aedb5fd1aeff9b2391a6966270efc297f0fa804b3e3a4ab71f618f7f61027795ea9e292852565a9044a2f0c9516ac90e76c280925864b588e71f96c9a9e93c5ffbf40beec50569d0b938220dcf882417e46c02d389a2dbd3136984e429c2a0d5a1410e243785fa3d50d6b9826fdc3a0635d4120979e3e4f3dda9bd313fceec4f9c15209a05541b93f5d44d3fb7ecd47fca04291cbf070a4052e8a9e2c08fe50c28e28209d91664406cb913338eef524fcb83803bcecb5501f14dbd889616821b5e963e7a43050fe0b4d2d2de6db3e79faa341ed7fb7b7cc71564b2411c41092d4dc498e41d10a3a46596ac67b472d9cdf764497e82686a3ebc7efd6bd1d918a1ed85baec7443c957b2ef944c0ac15502bad7860eeb2bf138386e6f18584593ec55142fd567639ef1f43ee5a1813c61864ecadbed47e43ae11185ce6ef3a9ab134b9541034716317df87a54f14290163e2960bede0dfe59964390b2e157a40d0eeac17460c6529bbc71f488745683b398d39b59e67bd10c9672f57e3e99c1e600f4ae6f8a15ccfd8d697025072619b8b17ccab3ef4e2fb45e7e455d39e188ff8f1d36cdfd975fd71ea5ec092a70a20b1ecf02692c0283c49f1ffdb1830164dbdc08f23ae15733e23fee90f596c9041abaa260beaabe6389e52f2d55b435c7a0644cb1e64cb4f9c2701db90723d0d442921aa62b12e54cd5c43a08e2b0f318713c8b671655638b5af889c5ea29242caedb8e74d6b58a985296dc9a3a23271467c396764c32d9be68b33269559004091563aa0cf00f73af891dda21b8753fd396a5487f75c85da2007901b02c727dc8b46303a4033d76c2efcedb3b5467c422405ce1732f14f11ee4619657ba562a7329d36e5ab354360629062e3fca5fc70809105aaff4156125ed5ecf0d5ab6c6028d4551d52f0998533d5e5105b04a43b07d8b0730f243355c456802ce664b44fa3c90838345a4e492983eecdf77da6ec588fd42da4c3c36cb35159cb096080a52b89189b71eaba54ddcd60659b02a6509b356be5d45625f8ef38cff71ab54c6d6ab47ed62e43f33fdc71d1efa2370e42a27790293fab47af2b2929db1f0cadc17f9588a8dea6a2323d3f8300fc12c0c172e660dd74e4a411e463c992e7e5310ed28b96601e9949038738b9ff41b198fcc9410f24f3b6996d4377f89e646a5a8c0de6a16712513350e69cd509ce7a2526229612930435092f911ed043af968baf1273684c18a3fe9d46fe2efc1431dd4c6c8f24bffdb8a0571d54f7dc488b8d32808e0531ae967fe78dac04bcfe85aa0f06d4810c3e721620e8d47e4712e838fa82db174ccf070e04fc60bc23303a3103151e09892a9754f28800f67ffb79d85e595f975beb4c574406980af8008b23bfd9c9657cdf118f38d50466fda81953bd220057f1c5e444bc1e65b89610a90607f5b80808e4a1f4c349ee761c55c1b57451e244b7e8444dab3272b6608c92a4e7ea129a8522bb80a88b104a69e3c7c5fb9559e8637fe910b93f3ad7681f6476a0ae82929946c27b2405e5e52de002f3d6b93c6d5e290cdccde6efc4c718129a569189196fcd7cfbe6c2ed9481396e41fe663ea9ff6aefe05238d6dbf6628339647f0e7773e896b2c0b6d086756de57255be7eaf14286a2a528f30f60230c5581604696742ad6147947a3f7ddaf59f06230db33d2308ccc630c098165761fd7e8573a0de3c750155f5ce905f2292f9f15b959b62a8c7a1a30848d1e619dae06c133fb804584b8a88bdf501ad99356262155f59314c5c25878e4f5fd7ea3f15b88b62c05261c6c8cab953545c28a3bfee05985dba23f7ead659f9a6b52e8c97a7419bd97665278050918181c2f5b66183de742e8b6713493670471c0e156c5bd0c4dc113a14e51ce14d782b0e1ca6396acb52c5719c4f4edfb7d5ff0e50a47fe384fb0c1d7c69343a1673821d12fefd08002c5a83ccfd191a053c654c206c2b8a03800ddb10343997a1f7b14ff6c1b3ea2e504b31f3e420956082b6206172c22e2fa6e98862d8f5229dfa275e021f13b858f1f7acad2f1253307fc0630ee941a96733350064749531394c60c5da2475e6ebe086d6fcb11d40b78dd43d51c683879bbfccf364fe33d88db0429f6141cacf6abe223ca65c10c5b0916e6d8b327bfdb122881f3a8749a4bf05f8ec47d151a7d2cde979ba7e970fec8699a46f2e6c2f4dc3b143d24877d87247d482115b823a6bde88f621944132a5f85a838635530d6026510e2de8ea8dff44596900f3d6a41c575f447d7264fbe908968420a32061e357f4e82d0d98fabbd90e29e1a99b477b7aaf009c4a9f375e7a7c0c8597e73e911550238127f534ae89edd3c1458b710571c7ee1411b3854ef02816fa5300f40d129d70a4bfede083b50588f44fdbb4660399e708da3dcf07f7fdaa17ef2fb4cb1a1ec4f4ffa9bd3ebd5c751fbabd5a2e5089e1607a780ca5a7aac10b82538fa967406f9d7ffd8d1a1269a20d7975bceab66913e2c0dbb6e983bbd620784d2f9277bd5852959305e09913c530441eecdc01be6eb9a147ec3868d3a06204a9586d9f971cec3a75317484401a7521d00be8cf8b08b167e847a122450288228a90248b3c01a4d63e1d94fb6dabb054206dea9a2a61263d526a5a498e25aaf51004e50303cb1e4f79b92bbcdcff24e16300860ca9ac52399de8edbe380ac0a99ef11c980c5a9cbd086d7b96e5bedf2e6c19730f07ccb2b1ef7e38676ddc7c101459b5bbda3fa16cfef52f9d981d44efb44ee18f309fb4558c9d745595932c23e15d9c3e2d93c1c85dd078acc7292495aa3dfba7775cc265ea0aed4debd5314bc209cc1676e7cbfaf3940a7971e5176ce0255b01d36a3bf05258c3ac140edf75d584837250cafa87d7b84b61452edccd1fb6bc2436adfe9adb925222802e4f3c09e6899f032e0a1c080ba5bd0e54be58594ece86bde7ba891bb0e9d9aa96fe77e4016418580dfafa7df676fe7e2d25fc5852e6657362e8f1ace133f3d56dcd2d6ca3d1e9b7e582badd542979922e8cfb03985ea641023599f6b6611315d40c54b0966d84c8d868a7c431802f80e97050c443234b1bcd33e21f1fa703087b96645798b173ca22e6dd7d16434e5960f3fe456dec1410d9f6d4e59778f6d5e6203aab1f3f4334d1b367d122c79aefa95b50b2e952df27e408940ff692092e538096d16f63eaa65b82d4ff8edf2ff548f5b36335bac85442bb21ef16095bf2e8b681be3adcb765f82339743a8f8613b546313895a436563e75e5813a7dacd5295c5dc2b08e32dfc3376378ba56e1d85a2650734c5c307f5f6b8237c2e45fd65daa74b8c74627a049876aba94ed10aaccaeb1459de4d96f0a78d64761b9417b7b1cee490a36a1896f22b43e5d5b59b9308c1d72e9df9c6999dd7936c4684dc8e042c5ff9d70fec1b1f9447767fea2bb846c5217077dfe24000456ef5124f35677373dc766b5881d8a962fd0ce4ac38df482cd20dfdd7b1be4363f1d8bbe8d514ae8b65b0671617d071866f5af0d83f47831655320a986cddbb48ab0efb6d563eca461b2d21525f069dd395d125ec530794bc718b802f24c52bbfe17218c823ad253213d0915eb9bda73158f39f8e87a0706c6732f7c5649f1ad9e9e5e3a677e0a11e86ea152004f8c157ccb868e5c12d8e3e4610f8f6dc4ba1c4afbb360e0dae3b1d9f0b4405dd85366a9bc733bc82da4c512580950fec2a265f6e4754a49572d35f9b14d18ce9c39facbd387e39da98611f56e38a2ed3e065d3746038ba67b6229a1e97893a70fab8c5dba37a635e74c2d4e25e506f758817e876e8dfcba54c539d42c3b7262bd2a22e8bb1e1a41518d87ba706ca8fe5490997928aef0f752afc023e1dc08dcf3eb9fde9f0731cd43c49ec7d7f6136733ac22e1741b8dab617ab0501fdfdc381f5e72f0576309bbaae758628850559d1f70d56938f2bdd3a84145091cefdd0839dc745210c3b8bafb9de1efb1de04f71ac9a76dec5ef590c921dd60d5d7ff8f4f1a9a9fe9bfdbb9e1bba01be9c55ed9a3877364e9c33529377762ede1d6eb39d5f3de9d6435a5e51338fc4cea176f7229e7aa006e89869f4b42c2da233b4c544d140efcbb99581809a9e2caf9775f01cecdb1de3405fe11ed774ce8d8245ecf6d996869bd552698c209d501503d41f2beeaae7fd98beb48b370f30596e60bb3337161e2a2e4139685da3b9bc7b31c9b227b4e6435385b41527afc8ee18b2be82a7de480e157114a5fd2ac65790fb3c67b5ef8e49ff7bfbdec6d007a1af7b565a658683054ae6608fad0b1106b262f424871fe66acfa9ab9dc783be1ae97b1dbd662de062bcc4910c21659a8473a89d1fff9cd16d41022eb240fa05f0cd009b2117f62f69ef91130cf265d840c358b0e73af406ac7564c8995e3044573d17200eea7ec4606bc17a86a827b419a6fb8d2bc2b31995f6c2500fc0ad4c57153c0ecf7fc6ceae6928d46ee8e2b7acc2560a8ceabc29a16f6c9dd8c3df2a44f36fde7d0d19a5ee633f753734dc2267f50edacb260b584a19f245a08fc381e29d870153a1e9643b87772f86163a97b0a2f04164e3f008045a31f4d8d956853af9dac0dd56e193423cebe6bd12bcecb12751a280e5a6ac35d05f4e558c05b8886640822ba28d89921b48f7ec30d162b89352bd30d80616683146512cc5ea1637eb200273613d8823a5fca905c0614b7b97bd261b00dd47f6544517b59f95fbff216345435ec44658a27a3577bba8054857ac6a636be18e702d629bb8983593b02c15410f3d0ad44efa4443fce71ebe685f70db053f4405ba6169f72ba6fd702dafb1795f5590938b1c822daa9fe9ed42001d7fdf23b4f52ca232d1d115268c20f3719ea8ffe005ada905d82aa9756dc18f33d6e0aaf00d5df0cdfc55e40c0501b231eb9f102f904972fd7099ce4d488cf2f38e4f397e51cb2ef2372613c9038da83c72b27d0764dc648dc5d04dfd29f3a99245ea2f5e7454321d60fcb5f467fe84c2e98f5f00e7f78a7aaa8fe389b4c4a7d1293446506495877f1a7fe7ceeb3f78c0d0aa3fe61d7eac885e000231a14168f604211ceba94e613763df2299734525e15a6f33840ddcaa8f8982820da8ed18e4448450a9ee54d49c7b6d40a2aedaca7cf6296685b8526ef7b5fe2432020f9974a1627c293b236fe4d79b6d6096f144b2d20f4e4dc0e1422a4a906e3b25a89935522cdee38bbc553cfffd9573cf7488a7f83e77ecc8be8dfb782a0e576c816905e6c781d48a7597730da28a4b3f928a653843ab92209199173e66d5390b73f4d238688ec40e9e56fa1c114ef6e81d0c62e9033f09185701c90de48018288a4a012ee1953adb17a3214f224ee4bafef5c05010b314f7f45325a71bc65a5b9fb2fd94846f92b49b9b05d385ab05f36e00fb0ec25cff1c1ab5ecd99f668cf6aaae2baf54752f56adc656063c42167a568874d3305fe13df6fbd7e33965dcc270f9010b8dd4d64a15a0de8f46d14e60a437984c41a5211c2b18be7102c2c06443932b319008d75a7c16a878631702c14d256565e8fbfec74115a93d628c65423974ac7baa5d7efac22449b51f400e450505dc19d382fe15b2cba263f4d283937ba225963e439053e9fe1337ce6c2c5ae940202754bc95662707deb3e936b85c36e53052aee0cbadb9a2a0a14211059244c7862db7af24f2221acf77f35cfc48abbbee91ce4e800b429ee4c8d21fb76d3dd913300589d35dd8a8a772dca0a0f8a86983ad9cb58d2fc715c902dd49b4b777d0978452c0457a280cda724a59f1801b680af626a13996487f8fd8bf057531698fc0e05b737b9531c66ef84cf77c3a6958457f49c0f7bc7b9237a4e5588a65b40e763b9d59640a7d1b937609dc7b25cff89431ff92ee2b8d8cc4a863ea4770a94697e9dec31ebf83976dbc800883f3a898b933404484574ea8ba109aa1f556fb6b9343f4e5e68bb4882aa0e17f3ac717c58770a2f65d24b05fc4cd4d3fb766ee95d0eebe887b9640ad6dc2d88387e5ef1266f9334a5032ec8d607259ad8be1f881206d486af361c3a496d1f96d471531860dd27520f14ca28bbc40b6c590a0f7b0beb2de27b25fe99cc6e7f0b9c31f8bec06e30fe857c34c7fad79f985bd3918ec3ef8708842f19580ddd315fc6542ce31e67780b3389c4088bb7487ac6ac79321c8b455635996630640931d83e83343e8b9f0bb9ce6e4df2cb91ae48996da4e1fbacaa6a29e4aa3399e0bedafb01528902ebbfedbc5e255c81fa5f5e874e8bf3a06adf5bd917a82db23d1748b939f682c4e7715829566e35eb63500008e92efd1c5a577ac42dee471e06f78a6b06765dfe644f4c66c13db7fc5a65e106e3008b59c1610dd17a0cf939fca408a9e628d5094451f27f12ae1148572478ecadb9fc5da46da74c586c18bf4aad290d00908dc920cff27d9eb67c8e38632f201b4e98b999cdae6ca2c770774704f201e0880c21b37d89a96f1460e8bca1ee258424cf718a4320b386b302f2e23b45753a2a90d3ac695859473ff0a8a1c54889caaee137f5a4173ae871bd4c4a1bfdf23aeec07e101f886f71f99898c4a22c2a031a3a95959a535a43c2daf1c62290a7065e55b7c51bd356c88c5f2114487f3129acc54cd8948df5ae77a17313ad64040dc61110de224a3371968297c9b3524ee65ce68396f9c466b43d8e416493b42220c97ea4bb3376add631a91993de879b7cd435c0f4eb83f17ee66f203034e27946f7c9801a812b8de07787b716def5eb6894111250a9978aff35b266cc6d4ad7c7f2175359862955517c7a4b922576baec500bc8133a5a38c8ecdec83230cb0be9c3db3458d32304bc3dfcf347e1328baf7e72df4eb50569e86b5c9e7b7750d054fa6ebb1045ef6da1171d70cca75bc5b7a9175d9480b358bf8f8cb8c8b25472e07a4b5a0820664de2ac10461bf2799a5a5af30d6058a5c02f942a6bc9d32816d6a6cefde0a8db32225148e3d5bb9753d86d3d30f7ecbdfa29b613d73265c1e8333cd4ea18f4a8a0f04ad10a1d232d2b0319cb2f594648203a12810a386418ce7daeefa73490c8af9de5d42b0839d53e90ae576f5b6d28f19a68e5fbcba23a2293d48044348185e34a1196290a753a76b071c6aab25456d40ed2b768839bca5ec9c4318b165956a1db51dd78c9056dfcd5affcec7b3b6546ae0a262caf8ca02a01ca84ceb43e4f661193284ee5affdcb6ee3803011b56c33a3003294f772374b341c540cb9c90996dbf02d16f8153aaeedf70e5d191485ae1930f48034447571385cb3d9b9c8a46616d6990e596c2a20dac2cb679d82daed8c473e4d8476431afb636db358bb8c76080a6f972f681a779a1edeb1b19f9dd257b357d342c6a8171005695ab37dd97e4bff1b1c777b9c8da161699d21ac350888a628c5e00c54640de702349cb623547cdabd3bdd4e75ff208d4a8377cc19137cb69669552f5ae331a748721188920ebe69f14a159d0dd58a383d268ccc1c996bd1bb874118ddd923377ffe2a7301ee94bf89ebb41cc1c7d881b57ac48c86956f2b9ab3487464dfc2d56d98d77a63920b3ac8325bc1bf6d6d314ca72921e39cc2fedb18316cfa01b583e43d18480921b7a02e222c2988bf7bd1033087025dfff4815fe4c171d6c2e2990621cf39fdf8f3027500153c2c29cb49b874fa205b1dafe23c01bb731ea268d2a3daa2997f412f6098fce35884ff754dc4708a25b855a382e87ca73bf875f5819927679e32f2c8f7c9b70db134fb85b13c1155e87e7c24465ca30ef6240581ba682a07fbfd387bf3f0c08e996c2bab2cefb17d91459c80bee5c0e870b4c0cc48116f9994266bab8922e4eac20c6450c15347819159f1d3065cb43777fa598ecca1a175870d9477a58d3fd2875cb263a7b9c635ec115f366b417e282f2884aa9741b644c89c60f25b6e4faeb1bf476adc97fc0a41fd88e73a12867218a7d7dfa0a841a2821f170d27770d1bc8515578f5b49449fed18d9ef3cbf11136a1f78162ea1a0e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
