<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4772042e03c1cf977adaeda9cb3a351901d33de98700a79b4276d1f486b6a1220abc31ce6ff5cf7ffe19d1c4352011442df5c3178f9dfe175a77f6e8e175330a48a6e14d41f7caf5e0b1459fb48051c970bdc20a18a3df67d2c240e29cf5c165302c5fc56e3e31ae0886da699cdf4a2af0b861814f16f4bdfc0cc4bbe24a759d04d6ff53c1d03775b680f65833773d99b2b3436d4ba8d57e95c867f9116542cb994719946d2cd444a866222352c79719f7af2c79f93cd1812b81e3e8203a14200b22a48057c15faf28d377a6656a22a77bdc53fce036f1f554f6629259220bef82e951e9eedede3d269d69b3998b9548ecdbb503463aeef7819abd30249617303fbc33def998e80a3637fc4dc2b6fe73c1663edccbc069cac3832b0a86da4aeac78fd45f1ab49c7bb8749694d858586643644c3bc2fd0fb76027bd997b1d24472263cd6faba8aeb2b7953bccf10354389778191cba3d770881ddac302902d99463cc0c11cc44330e3df43bb5b73182da0f300bd1fe14632170d391099b18082e99c38a0957d5e86174b85e6adaec6d6a32d64e997ffbcb4c8bf5e9b8d523b6484906e5287a594c21a9d4cc9c1a334ff0e14f9425c54ebb1f7de328f6546319f6fcde3232e4a163e391f74d6df858ab6018aef7dca33a4c595eed8b0993d3fbf009dfae71034f20b7cfb471d5b94b3f36dde048859f52a5fbaeeee9a6f462ea3e96c16ccf5e4386a9d1129ce8ee0b0f54df5a4f6363c84379747c8e56840c4731d9e72261a9b1d9a5a2cd3df3fb6489a3d8f2f6c9da406cc853586f4803e547e9da33a54642e2374398f8327285130dfb78b779975f3c5a6b537f3baef42bf0367c4831722ff3ba3852f1be67e92f5c602427f60c6fe70491aca1370193f28ca1edd7ef1dafa9a1383202ccb85e967d4de8b259041b7973c68112299a184bd4aa2b77396eb0e5285507b8c4b5f57ddab0a52ba099cde2c932ddea4b5bdeb8e0a7eef737cb9fb4aeacb0481a218817cbe66554cc565437c8ba416abc5430d8640a31fb7bfc8aeaf9d5b27f6f8eff0420db23612d095f34528754e1dd181731d21d1ccfbcc9745fc0ebb5cb9d22d4a1d2859ff0a9eb9d774e21af39fa7dc7c23eeccb66e788841ace49946cc90d8b13f697f4b799987fb5d03a98502705101546fbc17efb576bfdea8576cbd95962f0ae0fbf72a82131d3bc7cb18c778c43152da3c929b6f3065b04eb60baaae680cf9aa1f2108f03585fa55a25c19ef09c15b53ab0c90b43808888021c571392c542291bc2b422803ae56be34da8f35be1c488c8e0d511f771c3b234cd591d0462df91db50a172daf1607e6be6d92311f73b70f15e2300b9d91bf09bbb7b3139aad84c39c785be5a73fc678900d671e082965eb6190c33d1af5899179b5dd27df48a7f402e100a79f0f01375732a41d883c4908b209153119b9374e2b86fbb1146c3f61d64b4c16fa4b2f18ac5e8faa06ca0e6e37fae9ad34d162027c28518398be1f246a9baba8a25870186fa3cfd122d5ae41505b392ceddd17b10533920c64478863e01ce1d7e1cc7e5e85d0ee5b8e81cd120e2f20cc0f433d815a28a21df453410b966914402834b26173bfdb2b57c6b69eef93730841f306bd123694bc9812f47012266b270d7e3d629687a67046336a1135606d6a8d5f929a049dcd0674552466fbcab458c4ea31ba9f0e125752b5db935081f8acd0e4aeb10594ef16b6f1ada9c21391ae9e784cc6248eeb9d1ef2f54917ba33f561e1cd8c970a8a9a1ea2a7d53a65293f703dce2672735a7df65020cc76071479cc83b4cede303434ee170c21d01909570ae746541cc0f4e3f88eea1fe51ac5daa6a78f50b943409639830822c8105ea3611e181844f8ca961419540a2c793fa23113f85314509f863c10cd5553c4b3b5c14e236c8d58326efb04b814def3a785fdb45f31228f238719e273611205ec590d8387d3cae7097bbee0cfe2d8f853f0ffd2d947195b4f0366a6eb5708731fb76aa09ecf8b41a64c965be04b5c6a035cd409672b8f667836a4af6385ca807e0e446d05ba9397a15abca4397e4f4e7c25ba28ec666d62ac5fa84eae7022551fde392aefabdfee28780689b140fc2172677080d32b8008c03ed3a717a6ac386c9dabed98eb2c8da81af795d764ebfdc1149c9e8b0ad4f4c81c3541e109a59095a24f8e688a3fe80f19f493ea6daf8e49cbf797a88db044719a96a1b4c479d4bfdd3a139504bfaa509d5e929011de8936d297b71675aa75627752764a3f7303dbf247049810de81c0eb0b0e562611e0226a83c934f197925cf9a22602113f4c9be3a8ad10215a43a42d8e6cc76e9f7c6e0763d21e46f4f32c120a0cf96449890e9aa3ae3beaa417506891b742747bd4dabbd9ca91c492f0954874874ef7ca13865f99a36ee5ab276db445a8bbe04dc70f25b6595aec856636a6be7cde3e9f070939ba408aa032aef144c0a2b9691138ee266bb52138598f27bc5839ef02ff1edef9ce298fa15c3c4a3edc4f8a058ea389d882a5d33ecedfe8b5c429f7531558f75b089b436fbc84c7a9abd39ed0944910f0e7b32908f8698a321ae3a3aff86d8712ceb0ec56824c9931494b707d167282f41c5a2a0a98a64da57380757d008cf094804832372eb26a77ca1e0508ccbccfeb3a19c7404b0afeb8c50fbd803cdc0751f364ad9bbb4e3e04285fcd122c9f432d2e8a230cc6b3e94ecb72931e697462e4a951427643a8058ca7e05fcb20507467ff7f6abbf668fb0d63a8d418934ca2e6b6986c754870f72830838e0c9a97fb386370ef32aa395c07c7cc7a42f0a87a0d6fc4796aa43c90a453b722bc4a3826e48dc71e1c183e547be6f0d8c8aaec1c17d2a9d3d67abdf9ba43b688121ea4da2743de927b9c6a52bf7687ca8e415333416796f68ac7790e81d7e8b063d92d48887ffb331168d5f59bde86de07d9aaf552c231427b2ded174f1b9251bf968883fd384148be5773f1f4c446140889fcbe29cf11191701e9631c21fb894bec7fe11b7f4f8d2b7a7bc83d81f2c620d1264a9fc9561b8a5c6bac85f25b3dcac70ad26c57a72ebe4b298272884fc34f2c4561327ecba09a90e0c07f52f3cb612e6772d2ffe15360d6b011b8c0efcce14d0e2fbcfa9e438c8ac08a95c532cfbe3674342cb813a3b9085a90aee1b79b2520c633b274f60172f41a4347839bf4e71267f6e79403c23f2cbfc36d43896fc5ae7f7e72f66a7dbd8bc588c69c21b5f00a7aeb1288ccdbb384fc6fb083480eeed342bf377169316788eb321ec9223e50fd63bd997695068d16cc8882bdcc0dc67386b4678b2d51390960c95ca193d5783c33eb1d8884347682f7b119d726de503773a66ee0764f39ab52dd13e279a50a57e9eb22f5769e3317487e1d785e015968c2ebb091b107fe0a9780861afe87b885e2e126654c4583c5a847ce302995f1542e9600a64a94f51c075419515edf985b3eaa3b2fdef2cd4da61c73f2437ee4ef5a3befc97381f128257597f34929e527304a6dc6d3bed54e8035c3f30679b764f844465456f7f89d410317e8696a9d134908ba0276e1e92c9b2554b4a7893d034e371c292d8edf5a1f535485730a9525d366b681a1c008272ffa16154743a85443d424e9b7a51f72461622e9029f4cb511406be93a92f47bc303b3f499ddad53887bdbd3290f50b749529c2aa5e1dc47a05f7fd9b23c43a91afb59e5e92577f2cf0c57b64a35201bcf48061a847934e17a5c1008e63473aa740d0b9e4a7d0928a405a8ec00a7074984405343c81a9b668186f27b4d7888f245815b55c3809cac513ce9de0c91c29e44076de1e35a4af6b34f5ea979e9edab83d837e534bccde21f3fe20886c66e98fed129de7ff6194f59322aca2efb82fb549c0ba2f674f2ba507265486102f6bebdf5103fa7eaa47c0bef092c1af0738e50254297d304cdc8cc10ac85a3b503f28c66b8b9f01178b9d33d44c8ca393c7e970124fdbaca6287a4fef9e9fdf3e309158a39830bb636c17cc5d3b6c1644e7179f5bb0545989c7928650d1f31546d7657c31dca65f051e4b0da6be5d5edbf1e079323cd4cc788dcdc01ff43fda1bb86a4c20fea0a1dccb621aaacf9a461d5f26ff547c1d0a67f16e89148d1aec29b3bd8feff2bfa7e1c29792c8b7bcc0ed985bfc00353f357dc6d3c7416bb93e38911b47b34a9ca60a3b589f73a490664e0f1d9f2b99245a7cb4b62a7fff0756465e4029ce32963b1e26686d5cc00e446ea64b6516978d0164e68aa1a59469a3f5a7e3a8a3f5186c519510cadba9e02a59847ca8c4ba44e9d620b06685daea65c972ee3f1a28991f4c26d9736146a7bf7e0126422b7ba4d1fc238540c7b3e24c3501ccfa4045f6ff0a100e75a51eaaeb2b5e3aeeeefb2928c6ff4eebed4f63adc2ff7d275e0b5546d83642a994f2cbf33a0b977fc8f43f924797249c304a1ce985986fdfd459ce44e0e3776fe45ea1313304fe791c778fe06fb724479ab367d76b297aa1421133b9f90cf0c25ac6485f8d2f6214fcd8519662d67ccab68fc4b7e5a5d15089d267abb9a8f54ef51026b3cb362c0a1dc24126a88424c0328157fa1ef5d3e49a85a99c2bda389a170db03343fe7f7a0ea56d8213f6dd5f679ca52aab0c9df0b6b39ca97318f5c803571b556fbff57d04ada086bae1a41e54380bad39a10b43c14436d51c58756c4795ac27c80c91524ba7aa5756254e9670b4680760e07d02eff403f45e0ac479940e150747ae3b3065c7b3043e9f8719b1fa32031096c8b1058adfc277143d73d42e456e6caba839834f43b124a7a717f1da41450c37ecd7ab46664bea672baa0662672977e7c5cc8cfb19d2a5f2f9b8012b191f0ff3a7b7eaa20b66b6a22ad6760dcb87a348a0727eda1bafa0ff15ef7133432e938987afde640d0c93fc159c08f091e1cae68594bd05b6d372f392587812d3750fe27f143e3d8a4e5a913eb3576fa6624d12bd459a448e797674eb1db8503ee5313925ba07e2d3fb0f1a18ee9c99ea684f956bef7bd1b31519564b1c82a6ae898d82a5baf977374f7c3dc8f0c84ed2b8e948ecfe464d7c817ae57845986b33b89d025e0f64c2368f9bd7498dfd4570af9a1a4aa81d1a1e205e94d275c0b567978a501c231f04b1918796c46341702846dca7d108fdef84b3350776aa43946080b07f45c34681477b06e5a85d1787a91b964afc560ee4fba5596c608b2c851679a7b418b4547ae44aeb3a9c6e2dee949405edd95fbd97f390640b2e6f5a4fd45b0626855d237f36be20e76d10135657fbdc23c2e551341acf9f341434c3a2ffac32f215af216ecdf37a2fe736607bf3f89082ebd96a018cd9a1476e76a1ca95529a70fcf555da51a1cee8efe56ffdb5eb528f762a977864d9c0b3e7ef0ce726a80308bb3106f86372b11e0e30955129ec105d0927ace16d300d260fb4fa97369cfbecca21599db7c796cffd98cd09ed0efe01b13970186847a98ed1a6234a2a717edc277684140cdef855a9dc65e1926134779380a8d5eead926d3243c88e8e2818f0a5fa775188f73262920a3480e83ea127073796a9ed1e63c39d6823acb0dc8316df49a0ed934dd98e7967d81d99630da24f80249a4e561c149540b0dc894c895fd04056bfe8b252b35127eb07078a6f225d65b00a11b56068bcc66f983ea4ece38456a5ac39d0c1f159d0cb34d1e7c75b7fca7f5bfc21dc90a077a48b183ddab32f455604b647857da8b6491a543f17a4be13c2f0fec8300ef46e5084a551517f2d7af643de3b7b1949b9fd0305ca441222f654e52a45673ef5b49ff5fb55368a520786d25710e67560cbd754c935cd178acead270123e541506e462ed198e5907285d7746695542c6d2073bc5ea684326ac847dc7eaf18df942eef41b512c199b25165729d0e7e7c986987b3757662fec9d4e80011466254e030c0a1b6a17b5cd7b8fd4dc948454465b6927e1a66e239e1b483b1e93ae5bb8ecd665770e1c6232e935e745af547f8afc879ed8d2430f2956288bcb62055020639eba2b833bc7cdc3cdf206e8cf0f4f245ebbc344287295d0c23595cb49577a239507af1319c5d9c2d6b89849ba289554950d7b8b8d6b5415a4938fae0739dc19a94f5ddfd7b0d4f5aedb1798d9e0e6d60d49b38962d97591f9bd38f89e9f110e71049b61db1c73af4b54bd09a062de81c3ec9fa30f821956ec986a2926f66cd5fb090f0cf59ee79faaa42c5a6a79cf5a833d0b66f62a2ed01a6f18cc6a4d4242f43be08e89c3902a3a761739f2dd5ceb8ad8d9d3f99bbc4f2743e7f4ae1f1f6f3f7a24550b7ebe746717b360571cb80d1a6e564bb0794d56efe069a4853fd4d322ca0d904206b6d9cc778b3b4e67ec4a1e77043869b515dd46eae54d8e53f6ad115d80a62520edf13364aab10f3f11535780275be9b161fc589c16598f06076e4761ae9dbde1b5377750cb084a0295c7f6550cc4311be60afb5bf7cf9c8d552631908b8a36151980f3c8d3e13a2654cfde1322c0cd9bf920a28dad87f628a1c707946ea2395108a0cbd1e5b93fa48c4cd42cf5ee3acab02f6f0abbb3fd39e6dcbf9a886e7732a2f08cc921003fb7b62b52c28bdb1fd80072a096018ae3a61a9e0c26f8ee9e8a11a94d479ec28a8f391b734a0eb58da87bab6bbba63dfffe349b9437447550bf4a3f541c07cc6f82b8b0fca8e79a31d00f9f6aabbe21fdbed174851cc224d2d24756ce5e82f89cfd89a81a67330a109a2e4d631f8ed30f9ccd82707dfc27f7859337c9625afaae0e72ea65ed704241a960cb6f5f15c7bffec07778c56777675c13d9f3497bf7f9c55669896fa6b7c6bed52b3d308f09d862c60ce55eac8063a20ec0ce3c79bbe2a1dab77f4d11d534c344949268d5bddf86d6c5f87cca15124047a2a9a42688de05a5eb70f24199cbf446b4df01de75f0b1dec1eb4155603f3cc37b03ca505e1f8b296bc680e4e41dcba5a1257ad94042dab19146c51cac65e650b23d903d24f2753efec1ce40504f7ac075461b54d48a23a42a90cf3ed9436b868fd1260e121f9d301bfe89ecddfb3376a939901ad17b64c6202d96d569db126f8291f2b71a5781915e08129d824c63d2a57341d84da3b5f1936a59efa2f1bdc8754f749f9722db1401c5b0d4f38bb216fac2ecf59aa4223cd8621f12af74e621b350a54c28fae690a00f9be61f7d510ec9fa54b6819ea8c53233a5efa3df58d81b1df459a975f7427b26e5639a40db065163741eb87ad87a5ba640256886f561e9760a8ce037c1a2844fab1e3432670a728470da7b955124da779ba5b46fc15b58317534739f0e677b2cc4b351e2e9afc8f69ba8c9b49ef39f42f7d107042d7c84f1214a1746b42de20e5595aabe5d66c395471136b73c1c15481a3d244a95660e6846cc3295f40612d3b5590588ab6a9cdf54e788f8d66520cb1c9c1161b2f54f25f25f7e40fbf5473189b06a2cdf45776b3e1aa8b518b8dc9dc2c53f15ad04cd13a70edf7773c739c879f837204f6524ba50755e896a0d6f9e37cc493eb49cd297c8ee0486fb2a22eae5887e42fc38e371571d6dec2988f8714630c14cdaf830da80fa46b7b195388c77f4a1ad3714ead27312a76e1eb41af3b7b34abca3311718a311c30c1386ebef31974f63612056b1ada2c1399bcbf9948a9df94fa4b433aca4d35dce38ddde07339174d66c5e4e879dd3488966168647e01453782492262bd3353c4d78274c8cc063f0ae58a35e84ebff12908df3f394685962f2deedb21953e225eb0346a7f0202a4d7847bed54f8eafeac82f77c6178425ca7aaf72b931a007e6fdfcbfe8a43f3838a8b4ab6c7e55545c42fa4c24530435ca5912d2a7a747494d219b8d346eb3b9ecdcb484083452e2c9b314ea1c5bf8fb49122809f56f609e10729d69707eefdaaefd3f0ef1e050f60f5359aab1e2a8b4abe92827a697ea12dbdf1a08abeac015fe87fc147b81661f675845bd1690555fa159b221ae411033c8cd9b48bde32eddd9c48057661721bc3ca151f13721aba7deda269452461970bf01a0a5305b4880c33d5bc9d1c713395815d0b646b1f891ea45a917e83349052de1292a0b465cecd0fa0818214ace209bdf7be8e4b7b527e0bd57fd1a36c161ed57676d35c6eb0a012d98fc688fecd708760f43f5ab4d501fb700ede3768e8a7afdf57a5bde307a23604959683bc66c3699a98baf96fec63a06d29ae14511781d38a54e7b4b241912c81c42f1d4539ab51ea3bcc9f9a0fc49d104f5e9c621079da90888de2b4f59fa79c0e3f4e1069bdd7826c699e7fad5c2c6d626d8533f0581cf74e204946d17afb8e773d04cb33cb82fe6f5e213b9a19d66494a0d7c169f1782ac6cda3b9c7b3c893da0854e7618577cca883d597af414c559f03e311550795c3124e589076918081d95b81f10b3b66e2145270bca746a42a846757d6030b3992dbd010543e92667bbf0da1294e909d2d5e844831af176c5c64766b546db28e664cba1351adc5950e67dbf0b14426ef2838bcf23cf45b7f9421d0fc52e40fa609a5c897e11ad7de162b5d6ef135c24feeecd014bea3b9054adffdfef25328b0c5d08cafa4521d441d79556342bafdf17b068fb5d3432fcb8aad29ea9d03cc43a60a24aaead25420e0b95d8dddb5a0f6bf9426a04f9a101780715beb998175319caf55f4b91013eb50ab0e272d0a60af7d4c503528155903451a0c565442be6570aee5cb9a2b953601abcf561dac8dd9e6cd659cc5da347fe39e579e4f6649d3e9f07c512a27041bbfce734d7157335f217f1fd067f4e721cf68d2474d20a1093d27b36b18edc422aa746a71d9b798681140f9fc8195af5e7dc846c405d1cd2a816be0199c43c42d6f37fe2234051e78a9a318ac6ae2b40c1d2c0a10c0fb94b731a6eb1c1ce7f7dfd1b1af47b1246376155d4b5df5d8bd7d9597fc27e2f96db89020a25c2d7b1fccae367464ce2b31d355b2996d44e449d658e724dda0082947209cd3f22bbc92106acc1952bdf5f85fd7ccfd17684bc57f1f567d9fd82f2b90952a46d860b5cf788b7dce5f7b0bd6360e5f7c513792539c963402deb53c615e8b5bacb8e1df154b558adc6f61ddbffd487e084fd669300706d385e0b449ca3c8459f2b94f0794ec4637410cf8da9b1775d19bdc014c74b4d88e923d39c0ce6a43a3ca5e9fb3e2a27142b3a1393795e73d3b2aef9180a5d47a1c35bac748ad7d14127e53b238a032bd001db996b26ee805f5f39227277e1fd73b2ab0be488469ffb75d7ccf8dfbc6a88c57432d1e8cd2862a2ca40ad9209685674c1d6dc39579b0453cfdc3496f723c7e19cc88173051ea1a3d0411123ba14d2b25c638f801fb7ac0841d80f54e326ab674f2005c7faf0cc7208d19f3f0a6649d943e3abdc58db132298b59c708b14cc1e33b0464fba4c728647a47cfb4bb1f1a023bfbc8c14ef3840cff37aa3817770676c7fcc47b061167703dbab1f48e68fae5e063a61425471e4e008e5cc77eeb05dc83ad141d0e427819d5dbbcc30b0abca58681f099fd06c926201082e61e3aafc352defca9cc30d2713cc20c1264104ef2061e7be2b2b449a33c8e22384fb2501b6e2a3274492490432b2e86c06bed57690ef77820ab520df27eac3efeb8c18be3ce8ebbd10a739b8fb89ea58a62b3053111706bcdf8498af405831e5f4f0798a71369fc0224e63cac9afba13f305748e04ae768e8d9a213afdc890f544aa9fdb4f2b5a3646a8c9ce3ae5ac69f23b35c41516182bbb3d14ba0b00b5418f7cb4e8ff2b776e78e432e08c79ae78b5d9aec2a1d931e2bdd6d1171a6961ad98bf63f4566d3638ea5987aae8409e1592d417e65800ca98d2c04c94ce5a0772308b991f7581b7942b9bd305f89d0dc6c6abbad6a9adc1c4f391aadf73abb2ace8adef12a5448db11b8601fb9acbf337f630da26c5ee4d64f870646764a8691f64ddff4f4e582294aeb66e470435d06f02cf5523b5bfe302e9c67d6991e9dd50795eae4c33a66618d645ddbd30fc46114767b4bd2c28c11a4a821665c0e6d07f79d9b1bb865ff62b33bfcdace4bba7d68d14e3ed382009de2c248928b8f2ed8faef79633dc17541ff0d394f72bbc0efaf5e6aa6920d3a25a1adc7beb76210a832d7b6f7a7cef2282235785216ea0ff209f2a9f9803d339e98b704ef5352daf8c08c0a4644a0b9dc030af0e3b3fef666bedfd0d1817c3136f87adb02573d14dfbfacadfb9ca64517d0ea7e5deab30710fc17a4162675bdf8331fdb1a5475a44bf1b7756bde37da5c1c89f397fc521df0015e5c5d99e9efff7839469426c45723a450fdbe3add3cd2863995b1c2152453bdae73b3fd348e105283bee9263260d13127a94aaa287645726675093d97b98da12e78cd4493b7f8a78efa2e6401727f3ea659ba03b1dfacef879f7f10b2d4d28690867153f8de79bd590f1175a375fbd8d847ebe395097b41b90325a5f96b342f9df41b72a4210bf0b8759c0dc670b9f836dcbaec5fa9e8eef73f6c3ef35411880ba4e9cc1ae01a2b689c045ca39446991f22beef60d28d3fea94f91a582b37422f7fe1326066b6f6adec5ad5c6cbe560264d445f27e42734469fb28d07bdb82148c03e3616d106ae9a68283c99fbdc89a7750ad0c9ab49a2f578dfa3130336c9aeb65d9b73b46f5695124648ab4675a4373c973a2f05e108e20c88c2a29ccb5018dfd36a01d610de05fa4d837344408b2ca4f8c87f7058f6dc989b0d9d3be18d8a52ba11cca498267768797468d593cee9a13f46275b3d42d5bcc4514fa0c8e9e2ee19ed7a43f7205ba7c0d8305231a10758a5c2ddf41d8ff6611062c26041f296636a543e027aea7a39436fddfcc6302bbc07e8327c286399b2b41470d402cc20279472e005271277d8f8c845cdd0e3d95495437445531070f5e41b7fd7176d788eb9796d7a37e1b4a6ac62a4f20472d14f08abaad305df57048e97bee82e27b3452f5c4224e7be8b616b89507903e54122c7f136613b19d0cfab56682d7d2c5c07214ebee5d343f3ef07a22ce26274a038ee69323f2e603371591b82a09a0e1cbcdaf229affe1afda75e08fcb5cf74b77c9d7fb650140518f47552ce0b778105d4de51834f54475a54010cd459c84dd56f0061af4a33a5a2078a772ea72364d6736a328670e409d63deb043f42f9c9d75f14361957cbb69b4d4bf2e88a85832008fc27bca0f5595cdded9fc311643acda44c7eac8eda6a91d419820e1786f400143cd597262f330c5fc0f7ff5aba9034fee634c89484ab58a82be6d6b080a2b6b0f6bfacd9808d505b87e5292c521efafad0a481ccc1aa7f630a283dbd48d30cfe665faef22e60337f8358d7cd65224b8797a4b70671e252da850dd004943b546fac1ef11d036236a2cbd81f49c6d0f37dee677a703b5ad47c95674e4063e0478a0092865037927a6769e1923c22b0fd9ce78a018189ca04a17c49bbb5196e26b44851b24339cfeb5c75c17e08a4ce162f71d440be33714148ec85d4eede7c8c0364dc943e9be0c61c0ec467d88716535fba472d8100716b3c8d3436b01c64d99ad08d21ff97870c341985c7ec07a0fd7f45b6febde40725102c12e39219edc0bf9e894bd1d1ed779e4226135376b844fd20c6ee0284f13832f4933351c1b6168fe785a485823cd61e8de68df66d5df6e16f15c021ead472549561b6d0baf44213ce88fa0184c043045db4e6d2a1c5cad7a069b1c0b135777a7d9b263e0b4265ae5187dad8656c219697d332498db10dcfc315a5dc6989e6a9ca341b2c2accae0e92fdee620821b867cd10e32e01c75adb131beabdfcef08fbc7e9f93800d2e11753a6be0648e6152a706383548df6b81bff8d0d9fc4b2a889f7650f2afef45ddc049dcde7d24ff33ec6da0141b4dbe9c4d675a986dcf2f67148f69abe6e47b7a2d08efe390acbc8f94223e9904258ed14cb2fbbef7e5f268eb9e942061360391f81ecb231b3ffaedb2d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
