<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cd20756b4d85da4e9c48999f321e724a58bc1a57d3d84806e1ece9bfdf960bba19171f54bbb17abcc5922794c9d60e7f0f00272836f2bed2dfb9e180091c530a68b76cdbfe029daea64de0608feb5e40da8f24e42018ab9e12839330341dfac9d1c964e8c30521902972ce55003ef9150e4df0032a8c095beff5198c0608e8ab9c568fbb87195d122d818725852c775f2bb538f047f696b61cf05cb7975da3848c0a56708e23e78098c0dd6f39eb7d70e31cbc1677ce0222ce6f26c60bf6ee0bda03b0631d8f31dff4cb544dc6f3b7f41e4860d1d54ddd9d85f41664450dc3be9739a9d7bd2b2e63477cfa1ceb44f2497bd616c2de6479af6de040631b5ae8a206e72db381c22997584ec8d84cfc96ca0fa7930f293c269b67bddfc7db80bcadf3b2ea8de42e0bb47098dff4d5355644cbd0f4527cffa5a7918170793242182c1aaa5d0c3107ea88092e8e7d48eeefcfe3eadf37b10b0ea23e4617933cbb40b5f782ba16e01bb220280e178c88b83d473c311262f4f3ee2c307c6e8a89793ba224a1b0aca6ef73b3235c1542544f6336ba46e8069241a5ce844351b5ffd3f2674608560ca32ee70172364c38c576319de76e497c52980de1e5fedb8be24550f4f1e29733291b0563bbe46056f74eaf2bb850a9a5ac828e57571d86c1b041843462bfad0ced2a404e30796a1d047c62176ee7894de6eb72ab352920cbf4651c8e34e5da447d1930e708e9b036f014414c235618d7473aaf4ec0e42174697fad135c23da184f7e3bd5d90f00a7acb979e4ee15c9ce2c56a765137659e1a42fba4f2c32837997d8b9e5f0fa91c843d8b63850550856e51acce93b45c0fd10f4cde2a9cedf452e8c8b14962f2087ec3f192c247f028b4529c7e2fa133d81076e3ba31bdf98d3cd04eab8862ddf86767552839a4a7c7995a851f6be59c8193d5ad67833b4fad2aa8e6fbd34e22fe0019d35d9fd55467556095addc9a1aa49d0cc81a4d9ef8681c3ea1463d3de4ad327f897945c42a6158466cd30672ac1af3798dd6faf269ec6876fdf107a7054d8514d13da614dc9bba812adb3c74d7d675103b8748fba7ef11a8b3a90dab710961b12263bc31c6c4658d14705f50a2a39e88cb9031230d57d0177ac6db34d8ab2bb48b7a0a7fe72f4175a525db09a55312ff44a82f418d7bfc1d72221ff04df157e61aa9c24b89b126666ea07b28fc7ce2489772ffb9572acf6e34c2d858f0eca67273e733f34b1ed7b2655c606b66e7b677edd2ddf9a0558c0a1f2be8e312735948cea41ac9f7b3247a45a7c1f092cd29b9951963e134d9a107d23ac410b1d88900387134ff5fffb8abdeedbb324745414b26f6287b610893f0e25622c81d0cfc076b2f2ffce4fb7deef6cff77fbdbd143f844b2605e6374d1e1491e4ae5ae33aae55a8a4a82abadee752cafa0009216ea881c6948907b8cffe775c7c97186f2c8d46b1393b0514d636ede06ad5e0ae4145fe2780f174a0aa9c2ec4e5d49c26a1c273b7eaffd17cd832c14f79e96b23ab2b901dc0a31c69c1c9fb3d544a12fd9e38a8ddb5bbcaac46bce4455ccb4091bb3886b6abc1ba21ae936a980b807078e43a233d325aa6171e1f32769a8e474aee248bc5811d928cc75c745f728118734696ce1eda0a7a24f14a7a48b23724f95e0dbf18a6eb8085623187a5bb2b610bb1604deb4db23efebad191a208255e90c6e986aaec384fec6281ad70aec88e98bd4a9805d2c7290f051ce0530a0cd94e6f15ccae8f4f90bdc5aa141f80b12e5b0672fecc6870b73846dcc947aa417cbd077346edd53102a6a6434e79f2e6049b547a54e8d1971407bc3d0628a89b8c9df5a0594a1c4c0058d0b45969faa307240fcd8d67b05bf4c2f1246648c56c9c3d61b2acddd154fe3700c520b4720507dbcd3bd6cceedd95b28b0630852e8051d28c5901bb304d7a22ddba0d1722737667d3b400cc4e6b40247701bd8ce38eba84f140d31d458fbbd27071f12c7d381daf0b9edfbae40c6c16920a15fccc2070735a4b22b1d9df446f0ee40b75a624caa54986fdf360ea8a2a482fe455c78a81b8e83525ec4a05b65c6a8814f1b71133e0c47216e6c76fe6a4b6541ae353a051184affd5c04c9fca71d4068af4139d9289883b918dcc58349c1e14c3bf4c552d6341b590c1858b00083574cac49c371521f591d9e99f123ec4f86daa5e9f24f6a5b5b1a0512d47a6b861962b6d5aa4402b1b819acd49f4120b0225538e2b11632b7843bf63fe743fb4208486940cdd374a913b6fdd1d084ee9e616c0839a5ca121907e025b181303f2ff1fb1e76e6e764da94d86e6f9377db4925cf4eb4ed05c11e5ce8ceff34f056e247293989780e9d924f0ecfd21053f368f5604819214597e4115caf10054cd300339771b762be78c19f393ec772c39d3e2a273f2498800ac554eca1b921f7d0014b8b29069a6d00e8600be3066b479e34fa833fd18a5177ae73276ecb19e0ae354af76ecc69b2e6de0b350911c949180da3e600702791e78b3e28ac804555e4bbf2f4529fe3ccfdf23e893f98151d44d7fd57819cefff1dae3657dc73814d5a52e004a11a080928cd4d2207914c0b19ecf10df05cea17d2a3e80a29b7005d7049d2ccb321b8f90463d6a1e66aa683703151adce917792f471019cb686313ebe8c4e5094e06edf8ed534ad793c37206f1f9a19f5c5fbee261b909af5bfe0bc29101d2efd3d56a7b273f66fa3fb9167c63445da91a270110ff67de6aab108f02321ba218dfe94f9613d5b0f0196ee35ae15163d708b743a3c68ec9ec9eb54b19c5c710e582ba87382c49fcd6b89bbbd0607d18168e3bbcb9c6787a46315d8399c31e7cb85f6c2cd660585814590e83cdf8620b765c7f75b55389e1c62d6d369fb07f93a5d2732ba59fcecd8b42592a411be678d72dc820c1fbf1fa17476e42f075d8d957062a27cce2255db0326d2aa08a6463913c06b6a0cc39928311a25113e819fe6eb592e32d784474f8f51dfa499dac60e62a6b3f4be6cd967853200394654b6e870a20845ba033b63d74b186bd5ac504aab3a71a324e7b5cfecd094cb8231484d96b17397df31c73b74d3102454777b3e887ff718348b22745025ff2ffe4fda01b09fdd179ccac33787e64822fe630f7139f0bafc3a8111ca52c9fac59a32df5cb35b8f57a84290f2eb34acf1255a0b1bf4cef4add5c7541e6166decaafb6cf336a17a4f51dec552f515bb227ed2beb02e0159246fe8b6ac9bc30caf8645493dfae7c02fc181b1fab935d8edcf5a5f35a741b212f4b371cf99e6b250f8816b137bacd7e7b9e82cab2488da2504c9bde78aef600ab547a430f85ce8bca1e0aa7b913ecc4c10eb853929cc58f7b85cee3770f57a22c27eead0b2bdb888886f4371a471be235c780fb7ed47c971f6c8e0d8c039b3653f048f31bb222330521d7d2e0f2d9d2096c956b46ccac4b8ef04996a21280845f2842e64c108f6070b9215130148d5ca55917567e57d9982b42636554faba7f632e2153b092af3937ac8fac7cf1468b9c612eb32db8e7d996d64266f3b5da545eb80193aebffb988502d074b53ea950a4982d141ccf3d1323be28711db0d14a28297a06c51e0feb8e2aa2aa1471b151ee9617f5c6971992bba83efd94a1edf0d7bc78fa33d1154521e24a349c66e3aa8f30cf28e0385a5e736a009d2f4d50737b31ce51424c95aceb38a39ae088178f62430383deb6f49c94a7717454a752e8e5dfd8e1e68e4883465c638433b0f536483d2bc6ca8f9793cff5c98282cc8d6140652da6036a0068d59a05969b40481b9d4827eb85a7029e1dbfd1083c94b12371c0dadf8dc603bf8d15b1575d83623708959bf1abb2e9f99b51166ebfc2bf4f77f06fdcfa9fc4e1a452404510e711dd63fd3eb32e53e9baff04ed4b5cc3d865e2f3ec454f96d7c554cace12b9d87b917d02a235601defcc37b276b96552f45394e421d663c3b599906ef087f37042b5f6358eee80f015e3666c15c5fb6977574f1192428c38b4f8276575ed4d130db1f98bb19474a2c888cc155f129d5b3dbc8cf80abf7e5d5dfc91f4c055ecb462cfbc87a3b1a744696224f4c7a68498a93ae08668df493d7296323b8b7dce338c74d4c83be546b0971410359664e383596ad94e523dd73ea884809c2cede4f50ec0bf41f45fdc3b8e34fcec1554bbf3a8b3a74ba6d4b62e73fc2cc2f029728af5da36e273611b09bb48463b59d7b57f913b441ea506ba9a6c21311a375a6979896560f3801f105ec06d2e8d693680aaa9900b19cd9e08d9365af1c5948bb3734738337635b1d25672f971221d4d9d4c79580f9c0af42245d7816139662d8bde876c048c33cbded5e1345535ab32cb666b1cf53d6af36e8a792bc173ed1be9846dbc64c804f90935ffb23b8b3aaa8caba1672b6e5b3619ce544beabd7e87dbc8e8616d81e412ab7af4c51988506f2667970ce730c874731406f58f32fb6b709f2a3bc9077b3a0d033b723c0063a9872114efdc571af77304b044903dd0e045989a8116505246f608ad3bb8edf994dabad069d6586703cfc6371c6b036e98e00cbac24fa803502118249db8f7a859e5e1ab9ddd63afaabfdf07a9c1ee933ae99c50090c315764f4a60ae2c9630a31fb0273a8a56f25e572e327ffd63098fe16c350a4313000dcb1ef561972c1f7be927b312132cea9d948c377b956900fef61d396260f5f0557e1ef2dcbd2c2e2b06c040418356b40a25d4f7c5b230bd24467baa47ca53d5d1785bb26379dff4b168b6d638f50ff266551c3f73014266a9951ef1a3c637efe9141e16677786a4ccad9a3c8f88e7816ff86f9be4bfb198259a7356c7a5683d44446a866d6df1c8e60a0a256da26d18ee6b8b25df5c71c2216a0243148de08683da0d9db0aafaf88fad13e1b68616734f9935d3d4474dcefda1306b3ecabdba1fefada2d13bc796fea1445124c05a48f9ad10fb5325a27148f0a7f2ef4a998939ccf175e6698cd64315812d46d16a4ba99dd2b9b2762591352a9d7c7e2e3b03e1f7d5c748ef445b69b03104c16373cd442824722ebe009ca890ad5c1e06e6e866ca20c002bcb394b18e5a06b0564acbe5b98ee009a298ce4665244bfd731917083f63387e7c33e7bbd0312a25d181dd47a6f570c20bde64276ce776c44c32b8dc3f4c46b1e7ba554f265710a04539844bd59e06f81380fb2bb6b021ade3a0274bc745608efeff25228194e71231f935547955ce2cbf224e4851d12d7dfa6ce6562f25e2c72a455fbce64feeca5b2ac7c662e541616e98210010ec22f630f12b4f65946b75a8a640016f08a0297bb19f79282bd6874e732a799acb77653546ca0f5ce96c9be79b55fcb19a079ab86190f81688490da82a02cdd67df99733f776433be552f18efa0c6a9a765596514a9aabf22a9c8c3655103bdcf0276cd7ffa41319c6a32f02f6e53236b866d50c98d1b3d24f2bfcf86421abae7d6969b104659bea5f8bc9166664d9b7a34ea116b38e4131c6f79fbf8571f876d9c7f9387bbe0331ab4fdf4a519ff708ae812dbac3f0e7586f63a8bd251dc605b346043fe5f0ab8a423c7a9c1ca73b230bb0173e169e4b0c1069e7e69af47bf717db64f0fda4b43d18177a48f277d1f277682e72b5b029d4a1d785f1175ccba4dc30c6b2e29d7dc7145faa42e3c3089d2b644a4c46f2687894f8909a16d0781a4f698e960774bd991a7cd34afa2d399ca6341ceb044e129aa7d4d759233e1f412f6809613d6665b51b0677a32a3ebec040c86d052f2669d47dd8c8668b1886a149e780f437eb903892b54b48d926d14020e9fb6aa6492d71667a6da87463cfce3790e6092e056b690651a1f493b1c445a294fde6962c811ce8e7af1950307d334c9e70886d81dcc9f040042b1e29014c300bdb4333df19493186a16aa602d35b6f66c260ece7e18107fafa33336de2adcede1ef918d197d32548dbf1d007e2c4de7fa0fd94bd9b1065deabd798d18e85c1711f69e47b0fab53e59c0e011b10159a8db1e1726d323733e56aa633429d233e47e3a0256acfd36ae0ee1a473b2675756797e2d3928b598f61eab251a0a8da8a498cb12d8e579f3f755590cdc65b24aedf38da390665dfe9a7f53b1adbcfe1bfc6f2d3e062bfa1d993634a26060238d3d9cafed3ddb83ce0cb43746e105ecf8f1e687b670a3129c429f36e4292f3972f75011d7c70d24fd95160ec999d7d71e7bedca724bf64368b68036f001150a7d36c4d0c24c4b7de1353074b666ddd6dcd962f9ac76e505e0a95f75c5860dd05f1b5b86f32a5ceb5b6a7c363368866680f88c5466e9e7f8423bf8f790e3e56b6b23405914039d61734e37ecd775d1a612d1b331e1feb3e415b1291dac02b63c2c3ab4bb0869404f843410e0cf9402d7bd923cb09f1df0b7eee8629a4f198d0a0bc95f969c0b6a76011a2376c96596855e726a3a224e263499bac1347c43305df019a56428af8fa6aa57af0ca1721c512a95ffbeb1e0150786946bccbbb5ff11f691e94facc21998ba31a95b8f681f9cf1c70316a7d61aaf58615ee1fb649a8a2bfba9dce52c1e0350a54ac608f4fa564d5d1943aab47a723abc5673dcb88d6aaed0344195bd16f48ab1cf81c4e5946e60808ff2c5a68046781f725a9d68c3cc531f598e12f8eae6637993f1c685b4a559b1b3b8974daf91c727f6ea9722fe8897c90eeff9fa4610885ce0c9a26ba22baf9078c154c2ab6ea0a4270228bf01d487b617819e67c9b260418d04f4d253d72c871ed88b2c11b31c0cdc71062bd3154ca66951f92500c0f4adb0dbf97e333681b6d6079c9f9f32cf82d2cd98497452c9d0ea9c58c15dde5b15a1c7a95eeb95b4ce661ce11fe8761d962203e809452875d15df0e2c2553c1fabb449b165078e86f0f1f258150efd567711d4cc11010765fee0fdb2c43526c99abe446bc9266073ab0d7da839fc6c44e1a7f5970ccb23719dbb144ea553767c83083c60ac885001d4f8a339ace4eaf71d63afdf574dd95b92e254d63bf5facf8d8a118e89ad0daec2551439b1657b58f70c0671011b332a4074180fc3c0077df72c17db001b60d1f57df751ad0f2cf406c7d23395ec7f72bda4d84d05ed3e9520b48bc2f38d86b00b597daf69f04c03b21e6fc2758319fa45f9f447e5476214fc1fe8176d2bfd4e6f6f0d1c41a0e12023f8aad55775f6615d3d3e05f481fcfa7b6192a18c28be2eb7b4ae90d2fab082955609f4d3c3c1cd6ae29e65abce3127a752d7c00f5a318c25740ad600f556d6b2b9f7390f436fa529d9980d6bd333dd9fe8ee45403ea036f001e4caf9656d0cfe685b1a824240f186a6c56529646ec5bbb7ca7bc1ff1346d5f5667e8e1af00cf070a050ffa325ec925da28d89de221b00583cc61c5e6f1c62428e7b3a3513a5779aa5429d7e6d92a4b17a244c688d8ab7a7153b979a3d63bfdd391c45ddf61b007834cc1676407245d61c038b6c172516e36e462271a30867f4417af83ad5ec3e1b240ae814d87e5e35653241b97af927a986d5c517084acdfdf8319efb86721882a0f657d01072fdffb364a46bd1a3e8d8ea17e1c2255666a3d2134682a14dc47acda82d4b478327bc64a754866f372c8b0a219e64ad7a3bfbfb7f1b77222328204af1e505bef82c915ca6786ab8e7d09f305005dbd2c2883b164eb91f3f0defbdf7a885fe7095b7f8aa920a2615f8528814a1532f335b83af5b5ff37734708acfb2e21e287c807a1051539a09ecb1fbed559f47236c5c9dd5f96c1d61e8dc37120609588f292ecb6222a9668da6a084a903798dec6621e8f8ee4009e0ab5383a7dbb319ae71f7d3f8c31ee4b58ee1e8e0ef6dd1223bf0747658ed7108b5a2db9196124bf454cebdeea570f0de701ef46c786d167e6d182a5530f1bc66f8e2918c0153c2f9d76e1514097bafde6b5380a7287e1cae8406bf3776b42df3164bed707e404a2deb312bc7f7273a4c5eb31d21ade959fee9f55614a21d5e994ae69600a833e974e9c8ee29bd8085456d6298232ba4ccddd2ab329661ede644631bb688a851da220c80dd4de4b78363e4d7e1c871caa1bf28f2cdeac81b358ad0a784a8758212ef56c646742f21c3ee6030cafeb82f8275e9d925e844636b1fc8d19c969728fb77781d48cfedd25ca52c397826b1df674c9956e2660d457d5b82cdaf7391781d072568d42edc3c429eefa6dbfec67952d62a6c9b9ed11808fd49b15ff0970f45de31797dc984fbfd1882b48e10bbd41e6913c254f60ca5224cd2df43c56b8fcc047c5e098f54d61cc2478d1025af5596cec3b89b6d6873e3ddd96f0daacae53b4db4743b7e8bf36558755bfb0f5bdf99ec72f27c91fc6938e8299960dd15b5793ae62648b925433ae95d2dc139f5ddc4ba98186be7cfdc0ee52f8b41fcf16b43bd755ff9c7f8a597d0bb851338c37641bb5b95c4333fed9a440452d66073f096402f5c7134efa6eee54540d84b147b5e0d75badfbe7471d077dd5c557d642e0fe85d32830bd4f8acb95645a59fc8ad23baa520a374b23a947437356089f96b7168d97a76b1878ed8be5d77168582b08386980984645b63e23118f8d7343c820f75c09bc952634be2cdc0956f41b14b8c421364e64f88a5c5e807b281ccb3301cd10a1c8f6c15bd098533a4dd06c81f193753a0887a291b7585d200a259aaa5089d1d8395ee47c5a88222f9c6fb150a3c0891429bdeb6ab7d971dd2648e95cdfbdfee2b506ce20a96946676438821a659883f00da0d85ee63f8841175445b7d807f3aeeedcdbb87f095bceb0704537f8a7023b265578ab6503ab0bfeaea3f0410afa3b841fb991058d21fc1776ae1dd92f7a536d8857cda0b5561c7a1610892531df1a63e84fbca869549c4779f39f0182e6da549118cd6bd13746c7f1b4b06d149050ad32cb2877d005f54fdbb0861c0bbf277e4ececec35494906cdd409967ab249d49728367a409c8759497ef53c6926fd6b282a9adc65497bde62c58b8b26e968a6f507f6efce16672b84f6959d0391a000a0c9d26981fceb1f93b578d8915e6b72a6a72e9f896ea3d1aecedc44d017655220658889c7fc6325a1a97ed0f77d4810f6d9a6415fac34937fc7caad91eae5025d44f644e149657328bd39e3896935198608cfa042b02d525e3bc341ca43c9859ff88c606d34c57f8142c752a4e283d620778fb02aafa5d4ed9893c2686f6307b17d715fa59492201f231256c76bb7b30cecb89cf9c368e781bd0c8357d4003ace74f2be71ea1be15623e53b1500ae730a274877aa0ce587f15d7c21046dad043fbe440bd79d744b58bd6d4b013742fdae59d9ca428c9816bcdd54d59ce8a03d99c50e54433a8e132d0f798499581d587335d45e8389174cbb33bc4609c700ad3de6cf97fc1cf64bd7ca169d4a65aa6e80010ac0c487f475213523c5cda669567c4e664accda330120c93aecb052a063de45254cbafa0f66db3fe10f56b788d83a01a1fbf79e194570c605b12226f0f7c415637049526af3742ff05436130e32fe29f14e973b12c6fa255fc0d84b15247559a675477395c546a3fe2cdec68108e537e9b80d1d7728f782","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
