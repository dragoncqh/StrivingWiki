<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"deb929a493488fc3b2fb9ec24da7362081dd2e4797bc27994e68f0f02b558dc4fb8071330c58dfca796e8cc3c1ac116fee8340cb5ce7b8cbc35045f7ecbbc549525a79da2255b24d16f9cf5d21e872ad729c19957f27b67787f959d0ffb017e9f9c1083e4ec5853cb3afb17b4ce1be7bb889068857f94b9ac199066c9faac3a06e07be2c2e1b2f749c7577eb4f39b2a9cf2c7a9c21c308f758e2761c5bd4d947a74a27dea09a7af3013754afde31021c997049f8b81aa1b91738feb5b4956e0a5976beb69585962b2470eb86de404d4d1eefc0bfedf62cdcba123fe55462b370fdca87cf35884ded719ddfb89e2103748da73fb24f2cb902b6b11e39411bfc484018283324a0f54665386d865133a3c4ca4ae6465970fcafb136b701dfe8b2a86a92ba57c407c2d15df3d98e918f4aa851ab293effc9a1cbd3dd0c4af70a87d08cc34fba45251552668031c176aa04b86628447c79d3e9cc2d7bc12c17650fa868c8d42599b3c7f6c8804ebbdcee7e9eba4a78e87acaeeb2d6b53e568a0bf7d5b032b6158fa0b428a41edddeebc465342d732a52afed0587f1f59a4f6a62eeda44a071ce76b30775b7d2954811a48be52083331e4dc4c07d7775333f17b83a35a24eab8a4bdea4b5671dffd72987dece848ad774276cb22c0477a2bdc7b31e6fe050421604b2cdc5efceedb98d6940418255dee300060d67060b8c3beef7ad57a898af8728b0f34f872ebbbea1fe211e66c183ced97ed39dddf7fd67b122afaa331254fb678365dbb1a5759f7467cc48001ab71210d6ce84261fc9b8924905f062985292ebdd5ded41e4ee3dbac75c8f6cb883cc51da9d9e40f4efaed95c48aec7574165b62bd6134c6a2add115f961c6e135e5caa16128be9f0b3cef58c5148e83b3f3d10d26556314a47aea0889a0b95fc2bf858df5efd9a7e63b64b1de944ebc3db1722573b55113822b646831b91cfedeeeb83d7a3df536dcaf6696656c0c17966001f44016837d8f6733013f75f2c4b3fe81103dfa9f939d217a887c4df3ab13e7734b64a36bc3c40f49efbe0e096c8fe44887b9c2b47351f546d827b4d0a34c07f2187e7a6deb7471ecbcf399c6ec21d8b5962dde7db8cd458d54480b65f0466a5b43833dbd5cda10d71c059b07f8a5e37348ecbf438c6e3d4bd9ff7cfe91b68eb9ff13b866d4b91c2b1461056cf5d6c076a56e6c3fceb7ee5fe956a261f9209974c3806ddd02e02862e23fd8141e12ffd93f700517db89df81f66b5586b705d2dcae8c96b5939a50628135b2609e45b4fbd293b7c339b24a9cae507fc649ddf9d0218f279bd1c662eed96532996161e46a060dac1722f32b4a6ad103f956e2c08ebc96aa48300f6fc47d045cbbf3ea882e9f7e1d023c66e649805e90a8cfd2ae7f6eb9609861653f352a1a329392f78aefcbf63c1624315850988012eee4817a4e8ca41a13a953364a2d015fbd262547c8dc3f0e64104b25791f0ec20d8c947368773743acfb83e799efdce296ecbef95325cbd9b639fda98838392b424b52f79828b682d5965760db1c1781d16568c980e557938b99515a27cf6e457b9f17924dfd441d27b25b221687dfeb9352777682b81e0d45a0821f48bd077cb9891c49d8bc38e062089e5ae6b6fb44045c6fdf2cd51734ddf70cf884c89d8269c466965e49089e280b2e67b6defe2bf7ae22db56e880500dfb8a7f961bda8bedb2d34f2767ee43c67c227441c36ee6ec29c5f059265d95e7daf2048f39ab7087f2c18611f83a608335bcc566f0fdeae08fbb445e7c633cec39aa2c9b459851f569febc45f86f3a5fd76cc9e73a6cab59b8c4084c09549536c3889562f3a54ad3080707ef5e2aa6d30d304332b9f68c1a3a94511ad65ed9c8bf6f546fe1f5f2a802f17f77fb833f947fe2061f68e3835d885a72cc53b65bf78c71b368b43db5213b7651361515930492184bf11038bb7555c045e17adc9b4998fd8d1c8346e55c94617e97d31eff62a3602fcc51a97ad9246cdf9da802f0f5c0c2ae21efab399c506b0408c1fb6f5c79927925cdcbba824570f6474e7c1d3db532624ca6a86c1ce40d413b707f94b9a213a92e1e6ea9348e287183c80a020d8411d2408c2a3de420ee29a95659daa6d38c668d466da1ec304a38744efa683c762a987d46333980a504f8e9edc1570b505d1c1388b5fa7bcd9a54f38997480bb8ead671f707287220b92fc64b970ed156909b2a6787eb36cd7967ac0524b977d1ef84b5d45be165e4af0479048efc177c80b19435454a87716ebd2b2b592ee24061075a5532f177453b9093211570ec2a2dfa36176d4626e134dba732f2a186f361fac9a4ee4023ef72d87b68bf80ffc662c2c2e56142817a011952943be378317ca3349aa9c80da232f07ca97aa50556e06f86c5d8df7f68fa6b042bee76d204318269bfecfb307dd931f989df8edb97bd77e09e0924db012016e8f2ae41c9b7bb04775e2857c2d5b6ab5e8e4f24655984dc40d19ce7c39acc2d81076c530c292b74837e45166fcb829af9c25fd045d58e9272edb3faf1f74cfe41d5cc047d0af9d7b1566e43e37d5ee8c2098ab5251ed03ac25df527de2abdd86a05079e63de15a667d5bca0f236c7db49caf1cd72ca7cb3aeb39b26a2c9347a318724ae1cb6b3dcab61e1837ee520a9f5009a79bcafafae5faba1d77b966fba4755ebaca2f91209b1b3cf040b464a353a606bc0712c61a60bd279a3c852e2e53a73e4c77f891166c7be9ed4951309c011415023de72275ea8958c804f3b38d3be9cdef88e02bc6f539d678dca7c3e96f69b97998f6f695b4ce68ed0e507a7405511352aa1bb7e1736b2aac9e8fa21362de179cfe108bdbd8e9a18ead6acd749b419a3525fa26543ebf4f949d79769d338715964347927757cefa9e8dfd744f26881ab30c995577f78df74f67d43dc688bd6bec67aa30dceffb742b1923bcdd29e3d0ad15cfff253b0a610e6946f9da03e73bebaa66fa546fe250e7ef6c1371606bbf707200027330a6a233758ce2f1d514da260b53dec976ab1aaac26e3c47073d55c7778adc9cf2d9954eaaf11e66783a96ab5ab036c69344d0d38b3d277249c412b421a8a8b44e1e945a9aa5c557273299c21e2d74a0b4d6ecb541aa6455860ae76c43eafc0cb7109cb2eed0cd2f4327110fbaf493823ef447b9448b9da5da346a388c295d95ab8ac4773af98bc4e040b5d210d1858dc020353a79a53c2ad78125014ebac7a4b5ce213fb2e0f41ebda4b5a2e55b2d2be710d77552c995cef2517d11475e6772ef0b0607846e30a0b7ce9542c0ad458c5aeb66f77d14d1e3b49231f6d2d9a498a224557aa2aa1ffe5793e3ef955ec0fd80e3b399b25baf8f588171b4911f7e2d1ad260cf4c3090a367b9c892a8f2bb4d745b6e9b5df57884b0fa82039337d89a414d5f14c323a9f07547ddbc702a8529acfb034af543592d1ad9ee5ff0dcafab7225ccdbb530dc32a7bb9f4125fe4c54eca7c79a0affd3150ff1857b7351c1b734045060b7836d65cfdd33affa4559b5d571588f7984030c630fbe19c0e9637d03d8b15450f811ebf419b5571d3825a567b9b1749ad8186ab0f4c1adcfda99eb570c14ce996b4edf8db65ca3cffb8b61ce628c867767edfcdc5eadc7d55684f8ec380bef87777c3f460eb5fba62bade5a41e56a2f02e5d9cdbf9170ef312a6ce8f17aeb4f6e2ac24381df4069708cfd640d10a99d94d1adb3431e9938944a06937140061adfe9acca8f55f1b8830269c815c3f04a67695801ed42c43953a8099d0e3b168a4f675d2b2e38845547e7779cddaeab68bdf14dd76dc22253d2d27b37a090e75726925727dafff2c6db9c2bd2dbda26dd5b90bf4116e0aa65cca67e57f4fd29344398906baf8a4dffe7b3c4734ef4fb2b35f30f1cb38c8af0246ea9547617d88d6673186336c77a614e6a119c21e9b699de10f234a29098130feac59f555b18de777e0e1cc4353ecd6a0abeeef8c4ac8cf4719eb1d65b129ca9a947b3be4c6e52400e4de5b2098892696ec37dfc15bafc3478f007160bf6a3bbf2a8710754cdfc8375e36f80cec22b30f4a7133c38c8ff864e8a0b2b3ec1b39b46615ef95140042ddad869a213c437d4386a445b2aee3db11cbae48b25f2badd7888324f7ceb6700b7a04096b5ee0ed6dbe2b966365ed463d9d32f97f70a2dcb352794431088f0d19b435d3a7e273c14897a681b2047e595180e0d1acd93421568e9a77a2d04cd612d52e8765e99a95ddc84790b7a40a8e11dffa1209c5f422bbbdec370d248c4b0785092d43aede7a11b00396a2db243c94c553f3c14d51719f47fd5f9de0a608222e4429422d2eec51c56144aa8e695a65a2c1bba76403a05af82c15e9f7a439b08842f83070decc331fd297dbb5f7454f68083dab4b73c418e60771916a13eee82a1e0c7ca4c89f8be28576c091ee0adc985a713dcdca5c1fcfcfddfaf154ec089490433b3fe93d557781bc57657d4507ac0e536ec44614839c352fcfb7f65e789893f6da720dc40d44a5446faead32657cd6f95d43e12580b1928b55fd37bd98526e360ac9ef0f92395e9b772b5eb5eb4e36cbee91c51a266ec825ad87bb8fb896c7b2d117e0fbf6955d4155619847c643ec28aea9a7400ebea3a2dad2ade549eeaa67f09f89dbd85f6d9b6f093e1384b7866565b476fac6535b4842b9e65ae655653c1c7d2226644389a2f99ab8a72c0c2758f0c697c835d35244cdc3c01720d6574b4b72175fe5c5c5eab649291980541e4193573a3584c65a76385fb669860a682e8b8c1194777f793cfc3facc9f9a4719617ddf2223e95499be43f470c18d85687a2d38cd5541df2f3a6e06b97caa43fc3db6280e22704bd1bca50a55f544ed07cd5f172dcb7ef0e943c41fc31fa14afe8c2d968e621b95a575ff8c4b7c31e2d96c6f1ce1f738a2b7c64ab5f69898d955ef811e1fa474efd31d2f5f9579edfa5b6c4a0502437f32291d648b828c1d1dfadb1f8eb3bc76936ccbfd3a97e0fd071f53b4c804e0aa14e90953f6275251d431deabb37b5012d0326e9952b6fed8f4ddd81f56a2faf3de0b47cde027f89d638af6290687e38211a52426a969ced4327d34acfae814fa22caac5edf8a6be1b6d71a8d4e2693201ee5de28b76dcb2e968000394bd3673a591f37b34c078c9d6ff072bf2d2019f2adc3c403c8e64f66c926c12aaef52376521b18351b941ae0f780aa2729989319f5976191643f746f53d6e75cc631baa4e91246c342a2af03400f78bab47bd48646ecfdbd2648a9a09bacfa9217a1d88320f338b12db315e25ddffa27f2875b561008ab1c61102fdfe01eb66b98a0f059d22726c9caaea3a9dc97e97f0a865c0d562b7f27a63d54692382358552215bb114de3c68643ea1e2a1afe58865aa9e7314dfc9ff9d7ae8a7a188b2b4470c45ac7df3d5d9b95d53afa1129d1cb4f6d334d268edff8c2ff40f4336d071e6408df89b9f04c4124d75408b9bccb8133458f127476b0218cc7cca07c03093c83867731eba859c2ffc034b9671fd2adfca14eb88885ad621d0721dc5524426189eef0f8917103cb09afbaa664cf5cc7fff313235e2193bf5a9ea0e0f8ae534a0bf2c5282e2477c3000ed1f8ee46421b6c7e89c184a9fd4759faa289c9f5f5b1c26d43b0f54cde30f4170b5860c95ec21400399e947a280c66be4d136f4a7b2d63b5c12b121ecb5f3ca83dfe3d9913be0fab976047a18bf5a81bbd76402e79ce42ab9bb519c79d3b1c5ad3c07ae87bda3800c802f7a81e210adb09a340399c9783b99268fdd87e908d0aaffe25c8233edf9b50c9754361546b7fcf4cb28e2cc9a5d8cc96e571e806f58a8626d942becf42ceb38fecf06156795eb04b666feba581ffca89c286f7889a17ba0587a0a5066d8bd3dfc8d29d89e475a59050eaed63b1acb66d48aca58fa27a908b69ab89650cf68cef5d36549551e4938c4038abaa2347b42a268f9b23b1f2002c1b2a1c66c1361f0ce683fa2ef9d8c09bb3d413d6164b6f0a5b86bfe35f9e4c047b1bdda43895319e16261ce9a02138ddcd3068c8f5128361e4a2991bc066ae4c67a9a85b948584bc0e601c164c697e46e46eeaa6508de154a00342bfbe6bb3acc5c3ec8c60865d92123bae0ca95448f987a2524690d317dda60a3c0033b07050cb22f0a20c40fb067f05fa52904b1d7875c6b055b223ba9241054452dab4cce0660fb70811908d87d6366623c4c20ecabc0cc587497c90cb06bb236c7c4e264a7dbbcdcecb84a66f6537e18bdef3caed9bc7b01bd8c0748cd1bd45303f76d0b6d6c9f89fdc2617e65e0be44bae2a6521acc4a2552a958224d9c1c50d35c2602f16a9899945346d359b28ec6d502ff5d8b91476fa10bd98274d50e3d36c118c0bb816716f8b652a01c2038ea16a85a05e7ee9f01a31f191dc731c5175fbdf16d0ff2e3659ff792e49163ac8bfc15d595307cd9be2296f20a61dc311968cf07479b1b31ab03b10c6c101ebedb7656a460560996339a94d403ce371853a5fb8b510ffb873d3afb918a23d53f11c57f6f0f220c29830023a44a255d8257af1e2687f3cdca21a810f5a1a06f25f048b4468b451031f698d0c86784061f4bb1dd50cec0775efd0c4d1f9efb0e21055eb1e64c44fea6c6e2562cb50a94b41dc34a748a4424712aace354e7a968f8fdd5f59ab2a07e871f100026ae84ab16c12240c2174aa38d06658102ef2ca8902332e94fca6a8136706d472eb73126cfb135d3cd37cae2af6a66a4d89aa7653ed9d5966b4fa07a39f61d7b9527c468f7af77faa8c4fee490baf2916fab3eb3084acdc91f09d0ba6b896353d0a6d39bb60a482b532b4105c601e978536717610fbc7db611d937730adbe548946605702c0fb95fe32b3fa920fad8e0502cac161991b326305ab7f7829d9363124322eab48993d370d46e152b4f0ddcf5eee16b13321fa704e183977164fb48854a6f5847c4e00a7662ce3d3bd6027e4cfc5c518030ce06e182376e6e53cfb4ed27c877f193b00f3a284c8dfbe665ecb1d9cf19806f63a35670505e227a38ffc7209b1c365dc0e71d0fce0bf9cc01f82f6343bd3a3dd292f8181c774c96ca66afa0a19287c249b2e513da65072248bca4ef5825e4b1f899e76b17b86524c2d6337becf1e0c6caa0c6001f751183f33e8c02834ec872e1171adee5d6d04a74097fdeefcf716c144fdbdeb7676a67c85b8805476b470e7f055c9795d72ea7aa1e352540c508a41a76ed9857f804fb4d01fbd0297a441e9c516da2dc40e64bc6ccbd075074a6d78330a06a70834a1cd91a92d414f1097fc3c7220d77ceaba36602f9ed808365f0ddf1179372490c8a1c1e61e0773403d2abbbadd17a16c209c2ff13bb8bb3ab85305970556b12bb9ab519acb055558b59cbd74e901056000a45fd794a399643c2dd9d740cbcdeb19c7fb8b2d109efb9930beb27d856bef339232a9f86d51cf552898a03f5c78e617c2f46bfd0ff2dcd0ee5810c63c5b2426ce1cf7b05831a6e900b63ed04be4ccf8716153d5201a4e52ad67715d095c85517650bcd99bff48c45e1fa3bc05690393972d59f95656369586c8bd32758f162e116adfb1a69483e7744b9ef29e29bcf2ad6e31e938c56d7fde2a0ea9bcb0895bcdf7a36c16213bf677a4a2536ce3fa2b8d51379d577666d20ce69aaeeaf23484f977450ed359c3f7fdd686c288218a3e909c33c72d85f5b64c09fea00b95cdfd51fe9a4a5a7ba778d2c376d745240755ece1bc2f302d076a304ef73a4bb45677cb2323001e1eded3c3fdd44df23cc384def50e42e62ab4fc47816b4398b889d741bd5a8693def73fe235b39dc37ee32936e5c689f4dde87adbc105876c42cec1753fb6cfd94658b2865eb239cf6c696c3359286ef17bb045cd8dd61a2f8a7356258feddd0e2354490c20d4cb951ee07875a5c224eebca4605892c1f5ae1fd6b8d14480d7ec99b1faef377bb04025d56b7647cb70f42e68c66485b891996a1259578f4802d7ae9b5acf1e61cd2a20cbd7e2c10c9ab6bede4bd1d0dcb9ee253c36b673c173433a096a26bc72a0cba6322de381921c0661579ae3c9765733c0f6d78401b699644ac13054ee3a3c09b63fb30297c8e5c934f3ad17e3cee7d374a4bb539fe4b9de09b444e0ee5fea46215b7f70fbae37a4704af78014d2fab40c7d0eadbe8e29b0b7440c9c7f0c2a79c8b0303df6d50246bee5548e67e075794dfce559760856d0cd9553f77c1b6dcc5854310989a0a96523b77a09c22b2385567281fcde70c3552ce3e554a3a8139344fa7ac119336d5e4586bd2b1ffa15ad75d43c9c83410adaf03cc6cef587567a823d9f29f667119711b011785190aa73ea42c9981629f93655e4721ba1f96cdab6c48efb06b2cc7509a3d370bf4053677f2b08adf9a380ee906cb4ac1023c9490ee4fdf3f62f4ee1fe034cfe4706a03753881540980f95bf6eec532cb07507c0a9f3b89913b20cd53742b20e300e6a47fe86170d8e0d7288f13bd5bd09b8685f7d1456d9a80e8c79b37cc948ac6a6e75a4aaabd05ffd99c9e8c95d2ee16aec85d82c5c60539cc08fa60cb436d32cef27936f9bfbd6e8223a797f82d5fff3e68704e099036f9e82777df013a64b7260f418ed9f6d2315e4df16bd42b5834002919283e84f87973ed524ba51c3d8c894d0514f939191419d3fd76a985439c78e18ac10042ef739ba5c14a76a48eb2e2b17111964a88844b92ec1d98743c9cfa34e844c0e9259f199bbc527fda4d21ed1364d971d87b21df5ab599ec70aa68c182fb64ef3861db23af2c5afdd602bdfa46743bac5d0a5561a738bcd7416667539b13a845a469e4cdde9bfaaf427720b91c5c798f62cf3be33ddc7516c2c0bcf57b91bc2e05eb3a3fa59a4e0e152a0e1c7c7030b3b9b1d171cdcb1cda6245aeb96be24e6b0b0e9feb1a08d6449dd75e46fb753c0bd07ac3dfa7566f121b41c1b8c8a0def505c52823398e3454875a4cc2f2b4b6f684b02c76f1d8177d71f722c8ec58651dc0345aa8895611c86747c3c9c8b124ecd40abf0df7cf685d8eed334a6debfb5de59e82ae0f3abd6ebdd130199d76da1051651a010a4643dd57a4ecff116fc134531fff89617b20e64a0f7b9b79500405d6b8528d793e6f87d35f6536c46efc2f08a0b5f3badc7b85571e0765ba317e7e9ee34ec52970164cca657730853bae5649c0e206dfe048883404feb3e732031e88835b1937924dda3bd2306b9f872116a4e8b26d418a4fc5ed355c394936c9ccbc9818e6e8a066acd47baf0b30584c4fb5aeea2de02078d99686ad180e45284b576a1e06a66419d4d803f3248331a4fad2219a7da60877fbefc04eb3634928b03e3f60d1d6b7c1b33dcf10ee1e881e0d0a8cdd34242ef3f6d1164701919cf12bbfc4368a36d698673759318bf73faa5f096c35f60b769819f828ea5f499fc54f9d44d88286976140189b3237d607655e7f759dc81964f3af4d5e51cd0dae9019d6f93a50c5f9684ff0d3d04bfe410a2bdf17b89a3bdddf6e4e811650fb3702ae0d8e69dd2948f638ab0eed17498c61664d78de6e919e61d4903386e06e9fad715a8ac0597136138f20677e601f9517bcf873139e96279b6d2f64e38f37c4ade8e8a7410d2858fcbe1c817cc98e61d36271d84dcd62d9572ad1ba6e064bf41f6b74e9297058be134656460c4fd6872d18adbc28685fb51dcfa1ef35b5915ce530e25be3bddfa420102c746179c6f97ea77240cc35590aacadd5cd21be645229c23e59c57ebf1f46e1d81b789e7042eeeddff40c3b4fc01c3aaf58a0bc81e3905df6c7c519aae342ab3c8ec8132c98dedd78df4646951e2d5fc091bc77dc822cd393f51a2e705f3a803f645b5c6f0723d3b3722f574d502514e24987cd416863fde9bdc435e56306a1d72cf9a7de9df897fe04276e7ce80203b8f99542a32e5399c72fd8a6e11b3d265da898e5d84024cabd341a3334d4f5d6dd2b0113cecd4b5ec708cc7dd0fa81c5db6c37b3c184e8ed488ef5903b4c61d2078e8510b6af043d39ec4298938ec66759bf2080dccba570c719e02a9f9643b12aeb3f6a00eaa24c4ae3a9fcee91598f9326c618c337b73e4dda36b12b811a1dd7c24c24cf5593bc1d9e7797b41600695405a36f8cbd09a396ae72be32b5420cf337be38cf017681aff6f1700da2c8f04f426edc9402c03472d68aeb0b9dc772e373e92c83c7355c38a21d2c7c952d82bae586552ce9047fad8ee418318c17a64e157b401eb77874791a498288e2ad7468df8579e3013439b149376ebd613eaa6d82d078574a468602dc85d6f212a6028300299e1cefa54e477ac94d426e71a26b2cdd8c46f76627d0dc938a0fe24c8f8ec491beb29f5c05a298f80ddd995bee4735e680810e62d18d29b484e943eaeecb0fbdeb073e434cb078410dd3e5560cf7d60568082877c7812338370e1fd99b21147e2d6b7c97778358cf1db1531741a4b024570bd07495be2c93ed046fa9a699051ecfb8a05a3b2411816aa4efeb7761a0b7d741f9110629de1d4818b7e3f7d54962333d645f5c4ff9a14837d0c3ed3ff086c8765c9138397fa543386481b2ccff18443c824e7d4edd9db2825e2ce48f3a56929d8b254395ce6347d6cd1c1cbaf1c0d312aff56feb8571134435f365dd502bcf23ecb596bd43392f5f8c8a61874083121f1fda3e6da16cfdd1d82abc41b752e032b4d216c7dac30306a97fa1686b3ce0c6f5dd0b42373819c055f719f598bf9bfe4c9f9cee4a63d012c1e7cf77058d2c1b57360065bfc1f68feb9ed79bc06d4c919dace7417f63c778dd0a9e69007f8ae13fcdc548ae1c2359fda3cf79a888e71aa747a1e90904686b37ae1888bc5ee6a0304098ec40a31af9e174cfdd37d2bfb803cfd1ec60b733d54f563e26d77828d5fdc3ca41158b3653fd1f33fcda890e7eb72f31a59596784463bd39b929ab1e9db5dde9040c03277a07efa04429aa2028e1c2c093781c91045a69fbcaf35e76060a06085df7da54d5dcc4856d4a81e0296adde147aa66fa68d6f62a32cab8f106ea305a2660e87fca0bf264bebdc593df2e3609cc31691593a51b88fe6a56a26dfd0d987e499e9477211660c1d75b8cf040fb14474946fbbfac2799c59ec3f1e402832d0e965429f59e6b87596429675b199fcac26e64e285a3f42613332a33cff65f6f1a43d2216c85316444d246d8177f5b2f958cdbf5e4e62aa992c1b0ec7863df2b78dce631f094a5dc6bc342cd74fad73e55be3f1d903047cbbe860bf8e4350533ff4acc7968a4d284079048e5eec4f8d761f9a0a0c7ea540680dbe70c441680e317c4ebafb2988bea7a409dea18675233aeef7749e102f29229470c07297d5a5180654613fa639bcb7d38779ab4f48ccf1689e6119937768783d27f397729a29da578bf5dd1bcaf80039cce81edf95f23707f0e830dcdf54e6b625f1cb64436884e41c79c9001dcd6ea315d257d92e4b7df441f1803d732f2c759324a4c4992675f413be198702da0bef624ad3f1f2466e325a667d846f2eb0ea0766","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b65e88fb4aad2a4dfb95b4861d2091a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
