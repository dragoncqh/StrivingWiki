<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"08799e219346d2d0c2af911e4c3e65099158d15ef0f1230f846432da1ffb0782374cf8c0d998a23c1555904591080b667e1a969260bda5ed8423659ebd51659a35949b7a4abe3cd921641010e41a6e37a364f9c1a667002afa7377a73d24e7e9d1d7334e88959dbcc3b6090002c54178fcabb7295ffb0dd320e69f2a4c735be494245aa6f7412a1bb20228919c93dbe5d75a1c109a418086228e01fae3322219ac7e66ed20e9748672be7f33a5cfa280c040316651dd71e51788c8e541e3f3ba0058bc058fb8b93edd7c8021f4e38c786c389a641e7f5d19bff2ab6e33c676638ec9cf423b02aed9177d2cd035a2161691f0f09c86befb4cc92f2575553ac3be50bd4ade64e81cf1b478edbffc0c827dbdf34addccf514cca22dd38df2a6642a0328bb96b5f1f7a73004adac79955f6203c7f0f261fe2050a9c4d479c974c03d9ff87fbfe684806880333c0bd8afdae78e733ee14732fe065bd3c7e81c5611826a167c81b712570f3cb742d86448eccb69c231f2d5cb0d250770c25420a4271a5897e20508ea99b1c489535c014dd55ed67503dd20847fd95d8e19f15f6bc68006d2436a87ebba871333bab833570611296e2a71d3ef4a45c2374fd727188ba33bf766d0c61f35b4f9f44997846637d1f20c5accf13f93f19cfeb5a700fe3aa8cadacc1298ff2c57bcdcac78d3b9c51ebd72244a9600a2a524b67c4573024ff3617ca524044353ebe6d05614721f194ab35cccb763e247533fac7112fbbfb5c54db8c5b71e411e9353d67dce4d1a037ea42a87658d23e22bdd01a4a4070999747c76c0c9d07d636c3e43592d3d0fc7d56e4d9a9ef29e9bac4beaa65f44a1f980198ade29345b6285c59b54eff19745df3a6eeefd523ba7a4778fd86fac12282c6c16b3bd0606c52e81b2e0705daaa2e56b6e89ddc843f658154c2997e1cddc40863dc952afb729d7549baed9ae9fa7d4a96341b0e7b44827f84eb2002e797f4b8a75edfff626b8d9b97acefa2cf30e16bcdbad7f77bfcda66ccb8835207fb72d35d7ab37d1de086a79816fb7ec74ffbef353ec49cd9631c6f6ef70a065d46d69f14cf9784eeaf31c5845bed9c07c7f156935f9861cf16df600de8cec5f7a241d84a46239de4b30491969c7800e9f844dadacc4cc9ea1bb8f5bdcba9e034b745606b7e6b02e482de60417b6286536cb253e091551325d570cae09f537d2bccddf336ad5a6795d0982062edbf8c956876a0b29f70b14cb606fa780c071938f86a05441513616f56471143c2c39860fde8e585b17ea44aae3fe1f23eeb5336c0f5b5d91659dc85f0c7378940969bdf5ec412afc41c876474e1de58fd52e3bd15728d03ff9896b2485e1ef1a2458bcf512e6e2ec6de2275c4bacb1646363470a15ad6d1741461728ad56bc2fd5a7f65871ca8575eb574f119b71cb0437ade50e9d71af99f04b4e8c570917c9e65219ea3ca184e045f30b8c097b922e255e2c84f6580eedfc1b8705e8b01d0544fe7598d341704c342fd581c8c5fbc1ce3d8cb067866acf7230ba35ebd80d0d003fc9c96156c95be18872d257ee08b073b6c925e222f98399400cc648651da0b1c310886231ff2ea9a9d33652c054854278a4a13ab715bd24342ca879e796d35ffda5e4fbce0607f646ff915e72046dc9ec5b19e3e61970d1972e35b0ac7e04553e248f7597395306a0fda8b7235a8388a710a67b795d5ee54045eccd985d47fb196a85ea40748d8622878673041f88515e72fb7c8cf3345be9e5b32f554c371b32d29e6f0b77d150a5e232b23e15ce0755fe85d8aae386f54e0d203271d2a48874ae933c31874bc4f98b78384d12e322978700ed5c48aa5020eb6be08b73c1c55382de91157e0395ec0858e8ab9bca23af118b883b6d4a055ca2bb3d2eecd00d3702d83550c9bfbabbe4090131cdc00c436f2e4ee2d89b64414bf7340e5286f2b4bdd937f48c515edc68bd843e169c694e099fddc8a8fbb6f17a62018018ec81e7ef596f03e23b8c395ae92c1086ffff8d7ca07e5633e7bfac67b5916dacc0190c7f94314d8948b5125888261735eb5199abbbf0dc4ea5d54cf3bbdddb4f10e572964a5364ebf391f7550661448b0deca68fc7e499b85f4410404ebd2c91a1a151adc8be51dce1d08cd63173ba561a0212b59bbbfde62dc2dcd2472020ec661a7902b4447815794bd98ee005d15947ec9069bcb50626f8fc41cbd802f6c5e6998de96aef05a90b072fca2c06b84e81b11e97fa0d2c21f87c8fbdf0f08d3e7149a0330f94208c25b7af82b289f6f158d5560cdf56cc995fe438fa326871bc92da0caf18df69b1828c09697f3de17d2f8174b51c172cefac908a9ad57edd36c020efcf773a2ed08577bb83ad55e00a55361254f3579455b106e175b17e4b12dcdee906c027f022c67f19758d027e9411909820a2dd161f3d010e0a027b56fdfeb8772fce0a1af51237cdbfca85b67d29cf1f00f7ee928cca20c17dfd1072e0fb3ab59e028b782d4b3d93d0cb05677e956da631ccb81497a980861d117ebf696bda46821171d0215362d9135895ca4a7fbf2395c0d885c7430466efea57d30f137a5ca05fb66beb1af47a907ef71dae20abf7aa14a4314b28ceef9ce883cf3974ffdb40c494dfe9a8f7d795fd551bbdb2b9c52fcd054dbe997d51f3ffe3063db6c9841659891a8ac2610d849422b0df6f1277e95b8b52659b58978e78f06c7397ad872e72a79c7c9b42c8f4b363349ea9edac5998c86fbc4497a4b1861f90012be755ed9d2279ecba927ec0a02a18f893d136de4f21e08a9f9a86faf20798621e8c29007afe768bfa36c2e602c68a83331f0f0ad163899b4b9729a70e52999691e874fa35268ef0737f76f1abe603e557d7387bfee0363fd6e30086fa78162ca81d0c80b509707fa0728e6acca8ac75fd217f4fa97fd1632e26ac16856abcce70c7111d6835418c11f949761a9b714809b6bb43d67c1e4d827969dc01cc7923035b72434e9bc41c0c33d5dc95b2deb34a5398a17d8bb8b8c76c6fb7fdf46c43e3c01f98352af0650f8cdee78e0ea2551b14fc6857a74edd76b94fc518f1e20349f64e4668edb6a0a998b05d856aa7eda9de0a6f8c89e59dbc6cbf30a2da26a249780b16851a8b80dd9e897307982e06cf3b3ed55ffce83b5de110b5829f9556bbdcf2b7a104f6652426bfa4883491b8c0cf78ea3c562fbb5376f9c1d3d4dd185e00d724eb9752539fd85db0bcc479932e210f11b73ded3ebf89eefff659d6f06e320e60806aef474e5dcae7f0f43d7647865053df690bda8cb0dd29375bc4fa47031b9a253812da53955d26caaf1a7ac3048a3a36d5629c28bad5725a08ffd16752c1f9336dff3ec9d475e5ecee5707a153d2a536c34a7fd3d27ea5e4d7c3a540745ae9fb25cd1f02ddf97b2629a780f039700381b3fc1be120c6a6de816e4a5836f0a504027d6b420cb1515d86f65c654c4125904646f1e49125be5de738991491df7cfc339eac3c9beca92f55aae88b18a1ccb02e9f9ed34acdba36bd1bc91c0309f7998b14c5bc330dc6d49ae244252854af429de38b31d107a662e7bc61577ed7051b8ebcac46e920a63b8f5d86724c4f700078f58bc3f5330fc12054854a43b123674b588d04f48dc5a86b879017e54e829023815b84055386c77178a8c9ce7ea8507e3d3931fdd3556724755d5e61f104dfeabec91aa532cf5b4acc3304355e7d0e812bfbd78c4c3f48267739d424e2f4351c139f8abd57eeb9216fb6928733464f5835cf35220e52a831ce6925a307b08b5646e0ba398c40802e5b6289db550513bce1c85f1fb5ec36c18cbdf2dd825142c8c2471b96350a36e627255f8b3c6eb8c5d8fb9d924a37852f924f276639cd2608f11709748ec6924b39b643c196181531d100414c406d1ee12c9c399aabe830eef9998ab3477302973b293633b6af442c72037492ac908e138c7fc4be540622e5e39b8d6a85d70bd542d98eb56add2ee9c6fcd9e2691f8b7b4bbab7c48b85c0a6a238639dea4d3fdb9a5f5b70c0219940d6d323e66a8756a6d983cad11de1a66a1bcb8bcf41aa0acbdef2963631f77aeadb6d11a930d151ed2cf036e745796b58a1e638b11f2f18bd45027c45d7915f72e3dfd0c73520d8c24af8cce3e05d58b5bd77bc670e919fa3cc31d728e1f9beff5eba94bb48cddd538ea880774af2e656307978cbc6229fbc44f7843913ff12a78dfbdfae3e57afd44ff8ae80552645289d71c7fc29c9e56d163df23d20eef33114671970ba9ed53585b17ff1a4ebf6bc323b2c8cb76b7c3879023a1bcb0992c8faeeafc18f7f311b01e1c784810f6a23e8b60df3efa58ada09eca7b72482020e1c391e6329bf213062df59ba766c751980b65a26dfd7c7a8b71ac04c2b5ff27073620129d2af60ee917863fc754cbd940568209f763df3a89b972d08ae8c363d0d58d091f855ac1ab481edefcc3e63e116f2e2bada98812f18f95f3e2d5f8420ac85e2e60a525b18047ad4bcf508802de2bbd425afb187b9f9d06ec63e1d4f76535333bc6d4749ad53daabeb60e27995382cf080d37a0f2f107b36ac5137198af1fe5f90c29fbef51e90bdf9f4140fd33c13d5a8f1ebeeaaee0d3ff5c6fd62213f57db66d131ec1efe5fa2f25feb7334d36f168865d13e31c149a1101f8ea9234081aa3d0b2846f6edec97e17e7c9ef95f79666206e6fb7c1be51a23885864a013ba576c4bf5d395c328775df98eddb9c5933b92d424ead6f95c81567b3f174357e664e8575e38ba7715f59f836cae11303fb7946f3b9cc3daae02831b1c06d259b70f21538f1f1ded7bf034ef5a05a41cb1d31688b03af2fdb4f7e104479ff4455b0ca234e1131975ab6d8b9fd4cce4b75e6be42928e842c990a5b53b5d92ca3bc0f0bf22d369851d1ea187ee590f014c2aca5ee787630ac083ff0fc4763d4e6d6a744225c4b96ae963cbc84f1bd62adfc4284ea4ef28b64f4c98e6f125441d09411c9ac7ab5cd1e1bc383bd4f4d94587de96043bb4def31aaeba08ec8010f2de372444c1c4a21b3b2cf59ce4141d9a61c7c904e38b5e2d022d36f6a056ff0fbf32e8a4e79d16614eaaa5ecd064d24465a12ffa2b4439cf8836b2e292fda1066972c423f11c33f2b02122fe688b4cc5b9a57c1486401499e84440e7ee7983ce14bf3daa01aa2b80c99f4f528954b304cd71a6395955cea17994bebe7c4405c917979ce6a1fcd87669cde43a76c823498c62c9e120069b10f4dc630677d13a6baca0f10690ba9e9998251c5d0df4cddfab335ff9a68e8a6954362604fdf4bd3d8dc8ed404f93c615f7cb80ec8cbe668b7188e8c0d10c8e67d5bda448df9ff520366b38b0a8d439b0c17d143b271be77cd4a19d5764c13c5f2826c8452217e85c3be0a71673df33b8ed0931b94f5b825e3a44c9a21996ea887a75c2558d6c921e008f22ab53984414ec944191cdc4f4f914f4485fef489af9063366307e38723ee60d56a4c5a9dba18ce87e656821c1bb9e80b4c7fd5fe13179882ebadf220afdb7c58ab020e8dc0b50d890d39aa70dc2e6fedba569861eed92b51f0af94e0199fe0489ab95352078212c69cb84537a14dea9cbf05cb4596d9611cf4fa82d487684679f7a8dbf305c33a5266ed20eaebbe5b97fd9edab6b233b63778dad5fdbf878da26b40c6cb768dc8b1638ad641839d3c860e6c69adb52565ada7203a4855c6bfe80ab41b79526843772115ff1b1b8544bd4ff64761d848880179e19966e152d618aac8fceeb0c8528ce9e8bb61e46699f00e956922a295e8ee96baa9aae338b32b3fb0039b0d6be4b4bec301ae1fe357699463d25c406e3fa9ccadc89b8bb095b820c2aed78346580fcc6d3c137fc39c8fe4b7bc31e858eb28d029e9732041ba598c89372d561335477c51dfcf20f6d393f7d789eb4370e5326b7e46f8a635dc20ada91923af224aa62c58328927dc773086256d3020d87ffb9acfd991481777d49caba5becabf3ac336a12574871efc217a5b513222bfc0b37930eed179dd7a982de8804bf479ea2545cc3664476914355fe27f49c6669f0ab04495aaded4bfcb60c0694c0bc0f393584be7e8f9defbcde84661f7dfe1986ab178ee0190c9c50eeec4548724dec59fe2a41b796c9a71d76f4bfa751cca1b9b8156616235b7b7fdc938418a486ab69549f2dd0c63e4e39ecfa4960124075f7a42395f87c3e36004d84b65140ba6f146103294fa1acb71ca168befb957ebf8438641c40ab3d64dd7084c64271a7b244d874ae437aa0f2c1e6e8a246baa5563ec2deb04b22427a07f0baf2dce9593efe1946810e4ae67a769d9c1cfc75228d3591900d321166987901eeaeeef7fb4e1183b8ac8b3859d84e524dc9cf81c063ace5a637ca0e03824fa204000896f809a13399b0e46d7b4c45beabb169bf0fc80c262d1cc4e3393d77cdafc31916587fe7d88674f2e9424a329dbfae2426b9fb9a560baadaf7b95d5b3b288d3f122778e205230e644d21c9452c8d8c8d3ebbac3997798fa82706e067f4e5dfb91bbcfb5bc70297816710b46aacc72a59955cad5948e652252d000fe90614766aa036f550f7018e2093b4e1b40be643b264f4a457c37f1f9820052c34b6107c1bab5a252b498d711b26ce571092560022de40ab66240491d73b9e21921eafddad2610967061da243f4e3afd12f60f75ac3a1229ef6856b4350533427014f7cefa48626f78bc11246853639506bfcaf4d8c607160b6d627162aeeffc1bbf00055d34bec5426b95ad32bbc36c92fbefa6bf1fd7c2444c69c09820c03c3603e84bef950e56320a4b6f39f0fd374eba31b22ba5cc60015f459bdded2f84b401cbec509e092d5522481628aaba39ff950a7a2f52d7bdc3b5809bf88e7f8a25918664a23bffc237be567fb4bb0037ee057d456b2d8cfb902b201c773b01306c04a68787637582b1d28d7db8d186aaf451ac25c6c31fb42fd88de6aaa39ba5a138429c590293302d06b01ebe5118b4c206cd8f74e5ca2910219f3f89b1dc5eb592b34ead5c29f670e771a983862cef1475a7ca65a9d7d3c6b67cff74deca97048cda8810dc3f187157701fe63f790d8fc695d60bfa04cccdb94468592c387b6e769844b5bd3ad817a3ee65fddb626c0c8d5065c6141707012ed389541be4baee19c43e3579e0e081fa11220efd528686f92939e2d44725d8baedc06d0070b4202575d1ce2fff690eba1d3998cc1ce808b7a2c003c54e816b987e9676f99433b485507d38d9a323b31d7639aa9dc0d4dc1ff13b21e86b2d34365d064d08b45ba2cfe43895065cd9fcd0a63e886b2678d93969d17534d782ce6b621ad5f479a1c583dc093a9e1816f135b7fbc0970255d0943b699074839ebb755333ec8e8376194c9713008ceb5e8bf9493fb38b8ac28115a382f695efb4672d18e643fb2005e5f50fa5ef14f8e78970942307ce626d5106b0789219310146796077461f844d66bfc275fdc393da17a791a31205b81d665e6f808545388b333f5a7fd4455f05e41e882e5137c988d7062c9f988ec99a423e1877dcb7fcb928ded1e6414aeeb3565d9b7a0643870735ee66173d9eb16d4dfd1f5da9085dd783a367acdb2e2b5da880f151c9ea44719e407aee2207d048ce36bf0db1610b12aa0d8b7567f20e1d7a708852130ecdfc6927b7766a2af95f410d664918422c94cbc034af5056bd55dff887326c8947cfcc73a9893942cd8dbfb0d26400d6c12e2e3754abb92715e94fd5d2abb21159d6d706ba576064dbd3ab026ed2e04e5dea2691dbafdf70a39800c7aa2a4b34ef606e48b46a22dc1ee3abab204362b3ec612f569cd6c74f1fbef73e927249332f408ca46358269103a6ab93dac2cdaa5719b8ef8e7526cbd5213da5eb67f8bff03373d9869bf9723afbaddcb5cc705d2a867b0b91e905c52974533b424fbbe14265a5baf32f3991a1e3f43e5d31c6fa1367007baf57df05d0ee222bae7b3d20a59bf8579a792162c6fecb0e6083606540fa265b1977bc8d2bccdb94a6a9133c76b28eb6c1943553d22bcf217786fc41e89564499c7a1cb20e0bc52ff308d59041853f67e87feab13dd9237babe3820da8d9787e7c5cedd9d72b56b87ec2b5679c13e102219891fbfcc5ad27df919fed389b857dea9e6cd43b1bcac38ffb8da031f95d650258c5c8f688f6c8a24236e369f67882628b2514190306b3d20ae30c7dffcb3c55ffb9b1838052366b07064d2c694646cf8279ed6a1a90041973bd27307c0e9f7bae0d611321888c9218574a4a9813d8ee2079d40c6f41f6cb8861bbfccc20fe5b15e0d966a69fc88a31c57e9710ff3058abda8ea2a10ba14f9f8f5690c416c87dd69460d7f294c464f789f3dbde9513e33647f6814278f9a554a90a9735c6333c09660b7ee886b89cf281744af60d0325d6cb17b1bcbc77ae749fefb195b352fbbf8cf159af36ec59ce6515f3b03fb75331df275f0c10602c58b84b8cc8b16c09baf44ef2697ab1848270b1954ecef7a7691e3c831edb6006a255a82bb31ed28d72a7617db5d2cf782bce32edda59b3f61a52c9bbf2ce220fda6b6a07389ce3921cef2f1e3ecc33af2d4b798031ef477089f6d9189a59ae3cd055b5f87d34fa1391bbd043079b455db539cac23a83ecb88928395ab21785fe64309b8d343791b64cb4a921311a150501a14d7e273f411125beccab40b268f4f38ce54ff7ef16c13efb9c385d77204c50986afdbc5c681f3c401837714a8285e6301b09046ab5ba680b2babbdcda8cad8c4f2394f0df8c59609e9369612004da42ff7775c934589abc3fa3ba8db30f31c2ac619d897a7da95ca8b4da9c9a494ea1e4642b704446b94a2dc9f4b9bf435c7236f4e410364debdc2acf873bc0a7c6ba33d9a11357c264bae34a24c739cf21e0a60d9a9fcd9469212cc666b68bf4dedbe1b7122c8dd536c7555d535fbb76cbb202ac71a9628173b175cf4e3331849b83d1bd55decd3f041a2e42cbd95cd95a72d5baa83cf6e66acbfbb6902c50c96736d44cd50ab5c2eee233b8ce1f86d46c1f9a99f2f117ae711254e00aae8a7239822cfaa3b4410209a120fc35aa11981f08f007e97bbe74c780233f1f1ea3c395786e2682025d81cd8cb6e7f047d5e885ddcbd91b99ee797dc1962e22b484f2a8d3e0b2008e602b05edf56e58b14e00a2e70204145a7445539b1ecd680e80392bb8a720ab08462a38fed263e40f672097f413e3989004a28376f520bcebd78af457a89e7cb306bb7e86ae83b67da2cce1c3783c6adf059c6cfb0bbb1b577dcb37f4c180afd264056ee6f963e5c2d36a811be8f1248a53d019fb4f5f14b51b9b92a6e028a6ee29100c067293fd1af8e2330a3321384fffba20ace03fb60b0ecc7ae7cb2d98a9997e8573e7bdf1ef64855202a567ad5da1b52f73d083c862133b7c2b3657ad42966908f0bd14462718ad969e981f5e12ed38413a0db4924579420e46358faffdaf00191ee216d331d0cf20ac386f42ee99f1c57b93c977e8bd8c041fb730d0e21654c6aaab9681f12979ddee723cf25c30f544d09592fd84d5c2cf9179912d10958ba579199bdeffc15eaaeea4e129566cc903c9ab809037ce234a81c02889696f2ae32ce309300bf9370d7fee1bb61dd03e4f538ea68ababeabe9135d5d0dca6d498b270d97057a3b534e1c508f48695bbe539d5d27e8ab609eadd94d2df5dad628ebc867a8d10185b21b758196c1655a7dd7adf23917f4495bc1045d4d5f6b39651f32d95bf44c018226d9bd6e9c3f942c5ce3a285aa8d5c3d7db5220f70cf8af787ca306c43f78e59d9e51c1c26b9e6308c82811fb6dea7758bc1e9a591272cf6b85d0061f6a57ac0a5796afe71653652f7a1dafe4c01afc70f7940c06b7f66a0f89952ebee3a3f57b543ccd07ea17ff5cc54ca51a73d6cb37df1b1ac5a61beffab1082359426abd7c6c39c717566007ba10036394699a8464e7acabf86db343f747160e9c6523f918fcd6f77b5c015f96638a4bb2d513e056819f8b338f23d83191e8108f56b95db6a7a6341a4db1b2dc24b3118100361b36623022401b52d39bcd050a5a6a7ded90ad6b6acc4e690051d50f35c6e078c45fd059606928286d9f5ca3c8906d2c566adc960bd55f9f217db3c08274a6bca33e962b17c875f09c17e7bfa364e1ba00130f03462e6bc340a3caa4770ea0f58466712a2867cdba75676fb8ce99096ea298a9aedb298510bc3ea955a123d1b347ad03afe370d0dd97ebc22babfde8145e6702b60051ffc47c2e538fc28834ca375607e8d4e727a93c0e25ab89ec95ebf0507e93da757e0c13cf74c04447370dc665e31a55cfede8731bd58b33c6c5c402079609bee3ac4d8bd4ac5bb0ab9251ea83f0336e4dfb27041edfd1dcd22081efef951139323c2df06f3427c48d9bd1451df1ad2cb01f53ce89f2d0d59b1afa907c5bbdb601f1683af4afa03e589335fddf4bcf65e0e6d7ebc10732210bb6183a5727b06a90497b3b51ea38cc3fe220603045cd22a499473f77f82941d965b98d70782e22b9da3666181d6aa13e70ac01dc2944cd4491e666c9c36b62f9c1d2c6199f9618ea6f9b43e8879b3d3c1f4862d4a3c1450a3d215513b8dd51aa19ad58b37931c7365f9a395cfe8020a8563e614249a140a366d179cfa17148a9d76902b37d32d224142d8e632125f55137f2a6b54ab8d78c5320ad339efe87cfe3b3e7263833a32e5480d7557514650d684a9175cb6333504e89f0d35bc1e15035c91c5002a98b2aa8a6e1faee174b690f7d59105113b296e3f469a2bba6934898c65c9536f6747d503746792e83a36820da0a934b2be127f223e8f679c36a7592c9a68ef41f4766203a0dc71ffc62e9e9d672cdbbe202e2b45538aad006070f3006f318fc862d6a576176ede2f719bf7b4b171e364ac12b7f784b7ee9a9afc9a4e261d23de7d8823512f708d2013134eaa9f1c6585c247b7346f5240b56a84d69c99b7b37c2377cf583d06c1471dd16450283db33b7af4b0e0dedd29617df18dc4405f50c367f556f0102f118b5db17f28810c43b15b57c83ad54719e0088b3ef6ff6c61e714e0c329bd19b24f8ad4c0f1fbb1117d97a46d7c5a1992429662db3a69d4fe6e25ecc9811d03b974753912d8061317cf2a1101e085ab8978fd49c9801b518342886f350ad56848b100423d2806b6dd1168540278b9af75a90482f6e367f20b779359e82607dbc4719a4007d9fff14b750752f2ce8e75c324cf3eeed7136d7d4d8d4c4d4e43c63d11c32f59913d1bb5f45c0f8a83bfe8d6b6d1c4be90d40e6addd0d914bd29c32b7219915f24faf26ee9e216e7578656c5746afd8a4400d45f1165c54a82037f8ae34102869827058f9e84fa93d233a1169914710194aa46e450abdf6cdadae145d0f6e5f13451b9f1521a0b92f8249d56278d94b56e3f08c1322c33bdb0a9ddb40302a72d4e83aad282208e827ae1c63efac21adad280b08e400b18eb35a539146339f52c52253fbdee25f60ab17b537eee3ca7e1db1df44be3a98fc3c443dc3154407e44175ce0e41977c95bbe1bae1c6fcacb1104231f22f9b318efae7478a7e3fede3ad6ae69e1aa0267bb4768b06d568f18ecaa02479af73f2b7b555a39889b55ac3f5f7e9acc7338f2e0a579c350829189124dea94637ce617ee03bac2745f112d875df1faa9550b661a869e922dd991bf75ceb0d73cdb0d4dceccb1d52bc2a137cd7668bbbb696174b93fd12eea34a51f29d752ca82c65285fdae79e3803b8767bb8c6f47fbff1d4caaa90e506f00f3c80733f667e15a45ecd1dd75c5625a0e21cf2464ec67dca33ce686fdff0a4994c621a55fc92426a85c87d1f450c1579b7d7b4739f80ff0ac23faa95c9fcb421e42686fa7bec7aca0238c021259c1dd2740468939a5199fdf51b566266a823723780527aca70f2b150e54ff845da7b95a6d3bbff41484773622be99c180b9e17eaadbf49ac337d1d7b3469c4f8d112deaf7a8272f9da53361acdd4372402fac8639880b17395f32a543c8dc37bbea0bd8789c5b1c5587134b844dbd8a3c3827bd0842841e21d478b4bd1b77adba02f9405c368fa366e96a4d645547a2009c34b57f7fd575b67a3a90616643f5f55e269d378620b2017de2e9dc61c4f6aab68445dfdf36d85a14e1f6b2bfeb2ad0bf35597f61ea74848ad0667db4eb02fc09b8efee063f8a27b73f17e3083e5c081649055befb6b24f09507622a368b2be41a107c0a7916e7df64232da3d6f6c96ec12f62189e740e6925a9647494aeb2014b6502831273d2efaecd4b6e1f25f74fa48829df4c93d1bb37bd6ba3525fd2e795619ac79507d4c3d5ced2a637a979858c29dcd7a114f59841f77d793b1b2f2fd09a7b2d1b48e84d7ec573804c4d869604d2cb4b754e84e0b898eec456522c035f5aa220fdfcfb69fdd8f1089e3908ce6484ecd1b94c9ae6286abadcc9796c49272e7fb7bb3f8097b97ffde08e6389c77bc646636e098354df3b93d86532ad40d508568889284d7a64dc924561ef24e119038ff7ef6dacd840611f445e58f0fc0510bc068189a65a69681725f5426c20d475a9d871ab1be0858711622348d159db9ce9cf33ac43950d5e2a9875bb634238c544a68b2282d5052ce440d571e709fd93533fdd452fe6cca4b1de4b8e536be5bf6ad5629aabaccc71d8c33387bfbacef9c6f7b759305163cf0894734e2da9412a5322c1e2b2eceac6b492a64cdbe6c0685541d7750bceddfcf855f9d2e8c9c14753a91299503923b062b5776bde8cf2dbe13906ee1391cf16976983449b76d7ea68bd3611ad85d04b274dec0431dc65820235196dbcd2dd448400e881787d1f34dc828ebc70074bcbea108549010d8539b4f30d7d6bfc222ab90c19bcbdbbbc42f2cc3a85cec58cefcc1203e88b1afc514dc21f270f8162214235ae213c312b09dce8999d723e42a72610d2c0ec95372dad8791cb94c6ae7626c037837993fe51183d895256797e91989d00607c0cdc3e57e3acd7e52a8e4a9e667bb1f7eab969f1ba8e10d89b12716460e0772d282520e38dbf8d16e6c9e3580def5b5dff136438f30ac3f23a15dff43a66adb5ec3a00d27bd33ffc4398f96b0450cd4a99c6e46e3bbe8a3b9faf555b30c59c03e1ef46daf5b9b4b8c046b441f91d00b4e2346311a6b8e49770edd037522a117619ec8a50dfdf088ac6e08755af53f7491346e0b08a8fbd7c8d76675a29a2a8e5542e059209c23cf05648e6fdcad04af566c2cdbb17c08e1750423dccebbf819ee9b0c05b9c91707bfb12f14b8a33cedbb7722d4af67ecb04b36e9ba8e766f3f8b3c02c6d5c71890e346679d6150c0763fd637b92fa9568febc34bfada657af6b67d1d1588a85ce959e5d1951cbad81a3fb9525c36e517db146b7cb8abaf90351e78a5f681b630dd1c1d8e0ae2560bdde4dcb553a90e8ce3978f039b747eadb3218629c9a9b31e5f33a6104d8d086afac937aeeeb1207815f56dccd440358649f04e1334dfd963cf14e58ef5c0568d6f395471745b16b6f40e2d62477d1bde7920a6e2ae85d3a744d17dd763520cdadd6708fc3dce4aa202ce40e085ee29388608a81fc369b14ed0ee333417f95df151f3acfdbffd7271c59139886fb7c0ee5f965e2ae0c4372a8688a6c96c88f25d1f2b24719aee2e3f5cc776cf74ecf061ade50378a16698b833f0040a8ff11159acb5577e2095aacddbb565773ad5c64a4b0ebd76d60799a6f128e7686f1fe15dfa80fd8ef169fb092fa4a08a9a69b8d9beab1d367446130e83bb34e8853456bef4e4c6cb501b8dc2b0043057d3d9a06084de92d9f57f7e5b3bf9a96453cb0f9549882cde9694de462891313a785e3163fff56c9296c3095f5a4a80a73e91b20deead4295b7360148c8dbb649b50394c9e0f19f57c5f3ce96c6fabd6b2f2fa1040734094a4b19770cdca27e49003d36dbd138f3d08b2075558f2786f9ab784c2cdac1f1bd95e3083e68b1c50410f32b9539d1f44e732379d4f818b8a80941610b74b64f9fecdf80b1453162adef643f3b315e460474471fbb1e5a5664d028c223122ed5b1b888b5decf9576738636a0e332de4a9e0737bf007b847c000d758098d569e1603b0c7dff207507f4a61ce8c845f2511ef62473e8f62ef0d1b039679d4720c85a4c6dbf6e494507db630a4c12827629ee73d3100b8c3150ace2d3d68e7dd1b90bab4b9e151fd78d7b89f448a1641d3817f69499d300ea3e0224c95fdf48b7b60957ba57f87646e84727b18521b1589856d57b2c28395da3755a0b89f010657bc051b2a5750cc028c6a0a01f31fa619171e3c33fbba8ae25617c308df78fd7760cb009aa5dbb58c4ab22e2079a76491ef610d600ffc2d62e84ce0f617e2a4102a2b1ed23654b04ed35b56ee15d53009021186d75d3ec69cbcc3f1ebcdc463f0697fb1984e7f16e42231d1c6d0efffda5e996a6752691c9c52451c24114d138edfe6a900fa9d651b6688c4276cb3a8c9a711d9deb18cfdce21fc1b713569457d67e1965dd7b9a8634e9c4c112c519a49d25d3e15680739503bf59fbe80fee0fa8a1f067e247607ab89c3606b92d62a47508e555a2c3ba6f00676d07c97912756909ac8ea6f77591e5beeddd00f0a6cbb3b410e1562073b35eb4b739f63abdfffb0056b0a762da05e1cd8301de38cb98681764c6638ce2fddfddb01eb0b508a64ba30752581b05c505c1b41449990909177d7c6ad0cdaf706839dac41114103396c6f043b3447bf0810127ca364bcc9927abaf4780b0fedf06e6b70a2c48e277867ffcff835e4bf160bbd00279c88890b586064046107d9f1adf707a585a3abd89a6f7a752a35afe3376e85d82e4cc1b5157fa69634e8def55284ef298899bde60f9ecb107cc9044dbcf94ebf3345db4697fe6c6d4f2ffaf8f1f164b0ab460025086e5c1c93aeadbff41be530e063dea4ef5cdf49e4e7c0ba9f0b789feb1b7f9254abe9df4e7c56d89bc996b26af849230bf01d1b7508199c5469cedb8a5fbf45d1aadaad0e3dc5a3e158e8be7013870d6bc4e41eaf50458fdf48fb7c08f0b4ab7f274e0b57396ba4496fb407cc7835f4308c516a492621ee31388988129cf52f4e3200c0c54b8d7487f70886bc80b128474bc3625302361f89f46fd76349f4083779ff99fbf84605edefc9ae0aaffe317f1fafda8e32c4481a6914df0e0faa51039632c7a92c4b83e1d0afb302242a8df47175adb29bd7592fa82a2a4440626791315bef66dc8612b4bea877012de1b63ab738e4c72caa19af7139e6acf1060eaf2d5edd3a8c1a8aa4588cfa3f4d526fdc6772468398ed5b96c8e5c29e409a90553a7697aae0120462311ee95ccd2b647ec49554dbdb4d4a6728abac542af4f1688db4ec0b1520582354eaa021f5fd44839b09b3d63153307b9acaeba83763a8ccb19c1a08fc5816261d5786d695a4121649231be198dbf792c5fb84cbfaa12fe8d5bc30703be83a30ecb9429cec3cd62cd15e196901967ec51fa7480f2255a09bd7e5fd138d4c13bf5c3dc90472e9edb09e8de37f2284eaf2290385e5671a11b472486d08bf41ecafad264ea6ce4ce88bd551d2df91b8c0592b8f9942f88b6b8d7de1568f8eda79f56063b7cf2cbd593a3c4a56f8b818567f2ef0c67e55142426fe5cbca82b8fca5e09df7ceb3750d01d35ff20c1227943cdde23002bbe38f5916d6799964acc3bce7a1fe8a7f899ed6fdf8e25a58e271a9629112e31bd499ba84ea765c37c14da1f468e25fe8d8881172e9aad0bb42abd9b22cacc68a9994f64ebf5e685d063137c6c83639954d584309e02132d350fca7e4d0b1d036117e01ce53efc5d9458e55f3dd6808c537cc5e18d73d3adfd9e69b7ace5198794f34000e7c4504234adedc00e4f979b8f17b408888b6cc2cdbb08dc3b6fb1ee5d7097befa4ed90924836d0f65128a483948b26d9818f6db1dcf9c07782c70af9ff9bcd54f2eb218e1b6821123cc1e4c9d3b1a0faa11a53f6c6c3c0450a1c60d46fee7a174fbde6af103e1200fc65976b66dcdea020eaea0390a23064cbe34c6644a3579c28bedc338a95009ff6ebe8a9f3a15e5596609e38683b34c44bf978b125db4c7c2f1e2019f7edc8e1eb4dd47c389c422eb612e8b77d1a5da4030f4e43b881a74506bc0048730ba3a41aa7e9e94a2ace920c1be73bfc776008c06b83b906a9aa2313610c80fff9e2a4aaa5c8a4003329cae897425f8547e991f0a6bbb1592906642b475152f35cf508f24e29415aef59baa6e312583806e6d3ec647d6b7b2944c3e62182873af0a9cf5c9902eaf70617ece733bbceabe3a16777cbfb6e26a10dc199edc159eb32acd863584484e38f89efaa748edf7840ec7eb50598c3788fc5b99e65090fc0b2982bb8e45dc0fa7902399480b2345d29ee828b18304831bae6765b155e31e621be3a37cc8d8ce169b7c059646e2cdf3d1e8bcf016cd3f0fda7efe93f01ded84ec543548cd22a7873e1df08f5286d01ecbe0e60e8b8fc2750fa756183acb249b484ed0a453f880e1fc3c20b9df2fedc2df2435445e9d6b4a197d93c8362b1d2b4d76af5ebd7721357e99e66c37a6b6c591b6e544168b7ab33e91874cecd414c42b62565a6bfd395f008ba9b7eff091cd9772cc0b9678b7283a0bb85ba66fdd6e5d7c9c910a39946eebd1eb1d18ff345826f588169a32f2d9d79e5c604cf648df473ee71ff863bf0af13b4d953b90548f39566bcd66e97e1b87c3bf86bb46d57d317edb0abbd9ce42b27a8e2085fa6cabe97c832e5feb6637dbfe420e139fe6516697ca7d4b04ba969890d9440f984c70c030033651e630ace7386cb048eda716d858e1d5a2276cc1ffe8c2d4506212b3536a74595f92b2d157717f2d42befdb750e31c167ae7dea50ec99459ed2ae6657ac3a00cd0c35370253ccc8ada87a6ddd69bfa114919cd6bd370cfc1391c285a8bce92361b770578118bc252f04d0463e442f77d5455a99d3694e9063998efec612a83cfa44684ec03c99eddc1db2358b9f93b5ecba53e7debf7aa4b326a1091feb4e17b4885310005550b23d35e011e5145c03becad1a868693b6065fb23e78162e4c10f7276a98ff65e6c84b46b4cbf40394e77a192a093ab3cd3c9122162e443c6d149f12f503c9426ce728d9ca473c8fe960acc412afa2d95ac5834ac5dcc3e56046009036aa909bbe4c081ee79e8bf8b8089c298d82d5eb05576841961a7ba3c26e4293c75e1229541e5eb84e335a049792f41903e9c9d0fb3921647617437f2ac79f8da86999ec8deb2eabc399087d6b98fd83840607afb61ea35c12e50d35202e892a0994dc4146647a1334b1c26a15983a1c749a35fc5e5bcb9ea192f3c2e5a7fbcb1016c93866a707059b1bb0a5d3dca0976426f9b199fbf0562f87a0dd62323fe79bc564f585c122ff13264a72b2f56f1f91a1a95c911de4f4a009f4685b644b6aa899b58a72b5b11e8c230b6fb1dd655d550022a8a2baf4b87f955c8081f2fdcf640420dde9b3b38eb456bfaeff6de736bd7c49d1ad54a91f0ade0456d97c0c35d78c5c15561ae41d20253ad62dd603811080b56008d6e707a9bb57e49a567b7638064526a66ae86ae2da89985004e482ddb11c82c005484688b1f19122dba6229a23c7ffb864600c616857ddebe73950c49c418557dc5decd0d470f886f7445e2d12e02f6cb7baaa1868a953d1bfeeae24b86422ee23ce2af1dff73b98ca96e6e088e9ea6e8c6a432afd4a36bbf158660e9fa50a97e25e9aa291fa03f3f1cf587ccc3e9cec7e1ecfca884971284fd1185a38742d37330d389a753cb787772e4890c702cd9f52565d671cfd8549deed672ff651010eeff1d4983a1eeaaac49086faff5e6b607f3a85ed370b53a83e6f72dd0169715973bd4e32791dbf487979b2ff8dcde121b4fec989a7abb1bd2216fd1ec4452258ffdc9b869d0cd94803966f4c418284bac06909aff1b3198492ce1d761d53f60778d1f0dae59ce8c6a399eed336b894dabe5aa90242d5297c03d85d6bcf33978eda7cd9f75b2f3e7af507a4726b1c69f13aedc403b093b1e343c84c1b8ef78187f97857c153a015d09272855698cd997ad85ac3efc98461c2d97186551815c0aa0e41f62e1ce83bd9433ab0f51537e58efa59f178e9c023044290cbe75dab413259d76866a8098fbe7d053fafff9e438cef2dcacda131a731c48226c528b5e25850b4909583b0d8b9a680e26fffe0f64d897ac251fdb1724a0e6050e7e3406815dab86114cd67740b7e307cb441d1dcf9945b0e0678d8f087811741240ba952bb589703cd6f37e579ae13361b1ef20c0284664f27ffd9bdba8786b4020faa2126116d922280ddf1a079cf228905681de37eb26a08dfd0ff1132ebc95cfc0ad78623621021cc19abe7e9d92462991e6d24bebc2746626a67a430fa6ed2caf9859e1eb5f490559ddafcb7f8fdd4c7276f1b5fcaae9dda6394ad266cac166363381ce0af0fe6943661784ed4f449616ff630c46d8d42a78e8d46d4d199d4bb79ecb0ff059b0f7a2849bd516fe5c73541ac4b0d84e99ca5538e254b395d3c57bbe705e813c399fa0b891edcc3dcb5bff9e5d57b3bc501de75c6d4f1260ca617233d3e7d2151a7e2d690bb80d1a19913af0edad5f4830b64ea466bb35e7687de905b3d3b9077e0f6742beedadfa2cd61db3bb6da602ae61df3f805e48f425e4630fa390bb4a41140101ac371b62b7beb19a29f5f2944ab38fcb8d9da3c64c0a19fa7cee838914afcca40ec71c7a03f13c5bd7de2b590fc7d63f570fd2cb3802767cdd16e398213b379e75f6c766666516b63b359829b916bae6addde3466083523edecddbd91a3693fc20f12e6658e292e33be85d904e4ebe64b3c838cfc6b68ea53db3422730dff45f774f7d24a58e349b9a860e9067076cdeaa993ba288df6b176fe64192e553ca6ea17400def11ff34486fb94282b2a35141c05600bebf2e5e1328eab3ff8cb7e01ce1007b18206e00fa41f142519cc87e3af19f732931a58a2304f6c2ab5fd40f80e765993f18828d7330531e8d04405ff95fa18232d1243e38b6716b9c532c6294c1ac5d7ba7f46c73dd02fcd3d0926b99fe7afbceaf819cb22d9a23f52e3d1e875a0b65d809e006f5519442c5fe2f58ad63d9efd49ba5c68981cdb8e1bd57f8a5ec791e490bcad392985c74ce5c1ff9076d6a97bf06dea3203b9a1e249724e09f3562d9a394b3f5c8cc73616758571b2cf43173e538c13b789945303dc1724025f16a3b10df204927cc3a729d9c58e9556640722fc159bd32b40c819c6ad6b054cdefc7984791d380eef7d9c8b8667d8059f63a8259251d7c7470b314a3ae662e92e00921c29974a09b512b252fe64f78a1b5e96b9b68fcef909cfe0a0d74eb625525118f71b3fd7063d2eec6b702a3d44b73272197e2b38c56ccc081877e547f692de4efc8e9f88110cf8684de2444e65a862072d59c6610bd9f70e8256a59cc7ac1b3acc0425c181cdf818646920769c52ef5ae3648ffb827d23d05fcd8294de2cf9e557b96f45a75c54e4e87238d1a9d114760ff53873433566f5e582fe1a8b0bc755426863082b4796edc182d8afa6d91a3de7e456fda066fb33f5d24b07726287ba139c63068c5b88589913a7fbcd6cd8be411349b4d57068e937236fac244bdcab4b8a3dc4f18802715847761053321ce1dbada3b239fcae4edd7f9044bf95d334556af9c5cece0e66ee5832e19b5ee6b399e79e72c2f0545e139911dec0d64fdb4f3e3460073c6ea5ce56be10c2f73186500e4c97ddb927abdf8d17ef73c0abcce7a2c488472a6bc5834807a40077f19b69bae8db1b9323ec44c69a78c1a2a1de39b8f6c458fbf5f5862b55048aa26568feface3178b731f502b830685c0f5c4d7af89362b22bf8b8aa17605fc5d05635f2bc2d043ca8af211af64609a800d8863ab0ee278be6853119420b3c1faaa7bf7aecb3adbe67fedfa3d4c4dce9213361970eeb271f2071c26bcacf8fe459f99c108280ebdd2c7c052d23915b86da2a38b6fcb7c97ba06f7e17e2dec7d5616708d9a1727c6c85752d9f03124e972e1fea7bd11c281241dc60d703ec0ad61f966fc6699a60205a4902e8c3768d92a4a35200fa319df837eafcd","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"af6e4505fa5fc7ba203e95495ee903c2"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
