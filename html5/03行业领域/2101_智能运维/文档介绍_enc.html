<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c682b630aebbde6701fe7e3351e34f16da6c021780c5653835bab2551f442771709b2f4238776e1401519a36978ca774b0d4a0e112d279bd68351655513c2becac3afc31cdbb1f0ca34a8590c42690ad65597c346a7c5271670b7054e1f8dde5e97cf69a1eb70452742f1bf4415f990a9ff4400ef61828dbabac1cdb3d405a9e06a418ccc53bab343ace03c39ee77d9e4b1b71d8bcdc8d75c386bab225d910d657dd2648a8df3f320db179304628fe12236916b72f650a327dee4713544a54e85ce2ce0e2a1a4ed7435916fe62076d0f85caf84fa4697a2fb4e0fb372bc975ab069761f76b9f5b7487f2c475015388eab1fbdc185fa2b381e87fae14b446783b4b8de53ec9e3ad8590023249f87841a4bbf45475df8cd4fe90423d67cf0b2c5d0e774384141d10ccfdd5f2d606d0855576e3d74b632241e621fafcdf043c3db70447de77ecb51867515d35ae99c40a1ee0e3557a2b96463435578c6303ea399e9bb23e5daf5fb4c8349d4e6490472769b9ca6935d75539af85a045124f7553662c52ac84a1df4ef914b75d08f5f7a5e46b997261992a00f47f0d91b8f39bdf0edf9f8d025123a46533ad0f001ccca0e40310095650d804cc58cb290e89cc8683071866bebfd6756c707b808b3e749ab9f07103f65521cce53e5589143f2f98b11e2c8d17d230e96f2501e00248b37f459adca021c983b282c04ad7a3adb9e1ef1a4a4836206529958f9cf10ac7c334ca7d0487e7314b2716ce0884bbe931632dc8e9f389e931f8263e3f63fd7565b420e97609403d9f61fd6ad545d69b88548bc1948fd4bd665233cc7642bf457f3e057946b3ef003a72367442785b0545c2d1966e4844476808461f02286db96df590ac9107cfb0cde9093376831f114fe998391866a68b98aa76f23dd0134ab0afd8f5d779d1f924be5afed6f941066b4e25e3203a2810207dfe9dce07adfb01d6264e17d001c436e4429f60ec22a774f14512b831e740171ea17955a085f08d0b0306fdfa45032f421acebc64042bd5347408e9b3d9d2c1f92d7dbd377279f906c01724e3362f050174a59339e56f683ecec8a8e795557be935bb471c464569c85cd2ff5308c90abd29ec282953e84fafdb1473783b2982a6ffca811f0f681012189ede6bf912f707debaabfa6d1a6deaff0e32c68989eb64cb0fd5f01f63e116fdf179bacef13f7a9b0d5c615a3a235913d57c6c1b2f8b2094a895339a3ea2e9ae687b173f971d5366825bf566637ab66de1f3dd3f0e4b983875f9f6916f6dada1460ea4f9077faf33ff183e62c523b1c37a1778c55ae7c37f5ca67ec3b18ecb62822aef9e5507bb5d5b77a2de3481b6f88c575af61d8ce4c2d6ea806fd6c9ee69c441f79502a76cb6b1c91667a3d963895d26d66b2f768942fe08c8e8396548acebf428e4070ff1b6c0de06f084769da3931979a859b23bb6b359b3ddeddf6b8216c31aeea394a187adae3c3d29229050b335c79067ab98cb9b55de8145fb958523d35ad623dc239923c39029e34facc259e6dcf8e636e6cf38c6678422ca3a8736a3f84afe6f1a9682bbaecef8d6ca4f7492ccf2cf9b9ea708b75e0318218d98119e6fecc183c2ff856cd1433bd5ebfbb2fa51a59370de0f9de4e3c0912f32c9a65db5b88f2363c7c729a7b7411f8b6f11ed70e2953be6261a5fc639fd858d3ca9c01dd971940201215958a3b2e29b883af9ceeb1e3f05a03e0493c8bb8ac6b1366794ca1d68574f29a427930776c1051f0ba93d93bb1c38554fc1f44fc752696fb2b872a38ca440cde12160549c20ae9624b57489b6c8877969eb96aedcff7248590a2ce880d16c7015b2f46e4e9bab47cb01c04466fc10cf9fa9e75177c23a16e87d1a26642dda9c7cf6bd47ae16cc3e9c7bd644f4b7e7b54273e80870858c037f512c075cc60a9d35cf13c6dd94519f6d04c7856aec1e9ea70b65625382c60412193bf8f77535047b70a73f8b2fbbf5033fdd65ebc7cafc3f57092615910a9d52b45a96fbe54317ea1ff005689a922ee2957ffca2471b5f97858b881e1934ddfc50640031c7e9427a2acb13550b0ebb95781b5783d5965a041f094e0163201b0fcefe14c0157206307a3d51d9e466472e63034f67341c5d71c63e20257b7d8e2976b5c054e38dfa7494832521921c16b49732050019fb69b484e0938826ea068e5254358e666097ef65f5a75b48bb30c85e1f338a696a8b00e2e499f2f0ee6c52da88c0c28b1bbe4a18e83672dcd49d8b11be01fc93d3239649aa8980919eb898a3b3eba0a2047e45a2821045bd07648f13c346047fea20c2d9a03e9fa1f10dd21b15d55a06f5a093527c289735f62e921af4e69a5f8104886c919a1c6ccae0aa4a8d0709975a86b351b929b84418fc5775ae0291c2420b6c5c953112b95be1e75f41589ffe2e300eb5808b0b8442ea55049536c77f7f7bc1e06c5085ed35fec6e00a5912acf00a86b050c5a434c2f0d8505d12d57e63116c20103082eedf6a0dcd6eefc9700ba4c88cba2704a53291c928288d4b7424547d75263081ac2dde5bb07fce482d1bd5389a2a31455d9f3173fcef505832b847de80ea74569e50a271658471bf0f190346699d73a3de720a112e19813f29192444b536c4ad24b4921b61c857e33456392bc798283cc473c12cb193044a17d7f7a7a9acadd060eedf3d277ed96a7fb99b31d53d9fce703a4ddafbaf4e7a7032ab1ae5eef408d433c6af9f3af0d0a23f9366672eb6c4575b6ec1b657223b742d46e966da513b40e4cad5c6fb40ba682e8d568d3b1cb6c2163f1fae9941a3c2507ba771fb06771458648cc1b6317c147ff08a80b12003a7e72b153330fc3ba5e543e41d81ea12a6b75355faf362ca47d7feaa81e6698699e2931f1ff686ff2136e086ed43c3c1445bf02a9e0b0b0dc5e5a7ea6c44f5c71a17804831915ac1df32dd2da537b301334b97248a149f6b4e4dc2874fb68a1bce0c5586b3dcc32ef85b1ea3532f5826ce9d42d48e2638508bc1781210f85f1989eb9403eab99469fb3add306dc064abac4e9e7697f3c1138802932c62c7d2e5a14d3e06b924be4644537858db4f2961efa194f181e9c7548e746e78671fd48fce7d9765aef9ca70aec577f4123c803212b3bf13621f6f25ab9b9f9372ecd6f818e439aca441a756bb64e8751279b13bf7c94546b34973a03347080f924c46d6efde13409630ed43b8a8cee87f6362e92dc53b6cc4677cd569e29ae36156fb7fa7fa50f84def28126c6e48e4271f6c68ee6dec767f902e6b86e6cb2bec23dbde70dede0f38130656cf30c7118ed1133adbd1003cadc927b06815923f462f83321761bc77caad5f6a3da3c9b47a17074c2b34e72785fcba22706bddec4a6d1a09aed658bb471326b75eb288d79019176c69a4f1d99d83421a640c35de098c62752af21a123dd45afd352614fa4bbdc44ff3a5bcbc6f770093c9008a92bc5ac1eea9c10df1f560b32cd258097366aa5dfa3a8be6291b0897d36e361ed715dce3efcfdc61f10618b8cbf6609a54269241aba49fb265fa0c1653bcb27a3e69c30abfcc8dea18fbb7da26ac7395315162f6664bdfd91215d6e0c2a82ad6960bb221204b3fd6369d04da74905c1a6e9b27771a9db429a6e4b1c811149c3fe39b47be528a82992071079bce1d97c4b4235e544dcf32acd4ee6485dce4371c25de2e241959950c5bc336bf4198ccb19915b655da75bede05683d2282dd19603dfa67c545364aa0375bfe1b2acab81667b2e5cc243032da920748925dea66cc1f34d8690b023995840b4c2ef843780029b61e5f15f8f696f67826e42f961ad177309fbcb5f859d4c2447c3f2c5785f592ba1b2ebe90e7461cc755ac38f02b686bccd730a4426871f36b5e1074697331880db84adcb0bfd21fbe68a7e88fe4b590d0587b41c3dd24ec5e6b1a6edc50dd9aa0228a2fc8c75d9588ab10399f7f37d3ce238895f08d40db4e0fcd6e1c8dd28cf7fe81623c593ecbe65a6000ae41da6c55594e163c7ca28bcc5ec90eacc7733377d4f748b1b3209bc972c3ee0c7d3d70b89a80915bf65668838506f71d62c04597fe714839fa7af2bf1f6df2fc2781eae11852a78303d69cd0624a5f58acc9488ffed83f494b41e6c38c9b824fb6e0ece10c476bf05664e8910a087ddd0cf51283e5e55d1f3b119c4818cb759b99de22e259348c4a055f58294ca4e6e7bd516dc208714f7b594f4fe0e98de753975ae8ee9580112e5e36b19a00e8ccfe9c9f34ca22895e3c2f78beef2f52b8c567aecbbef3f737d91509f68e183f1612d389452469bc7d3ee912b448f6fb03ca184113a05caecfb1a00615efea94a0b654aabb9e1d8ad0216d56b0778a38a0c21e932eae8a9e62b09838c56799324df08e8ea947b837c6a1b2d0ef7b5ae33961075058a77e1dea1a808687ee9ebe9fe1a37313e721f4496497bc131c7f0d9cc65e9db11c68909e7d22871543dfce200a8966534311cca1852a8fd9a7c17552f7bbbd8a9bf6c66f7b8ecc8e7e632ffd56c419cca4a54958ba6716899d9e91158c72fc6b5777ad7fd69774e25aba739b0b3399f4fd8411bf4d3ff8a36f7e823e8013cfcacd98a53d7517711e1e2d68caac040d9b7907c4d9f4ace2f1d18b4bbce277fa4c1825bb526b5404fac7dcf5beeca6018f6c9e6797dd94da0edadbaa43be77b691b7c2cf449219bcf145845c882aa7cbd9d5dadc1c96d5bdf3d0fa37ceb4fbea70fae52ff957c8274bbade9b37c95d8284a11ebabc3f1bb75409f47e5132c791cebfe971756faa198986f55767fbc663de23915c2683a812f8ea228ba74355fa6a79e402492ee1ccd8a973f2d5d5e2256da597c5839828a33d44ee85faf5cec096b2eab22eeacb643c605c60965d78c25389df06a49ad478eecc1b59087ebd844a7be416c0c6a62b2fda90a54f1bf56c726bd1c0f6cc6aaa343bfe68a10dd65c5564295ed9e050e53f22c43ae7aac4e7ac38ae316241045149e1b350a15a2e96b96b5c3c6b4079095d6262899400ae46553b0e580a8c49de41fbb0dee86c189aa784a1fbf2c810926c4bb7f441c8915ec6a349ed2a5afae0a6559569807a88b37fa8ada9d9271ae41e15dc286d4d5cb8a6847a4f9d3e478bd9e47ba1685bf9bbb510077822f87648ae349bf52782fd53d3459dfeb68278726837508ed1bd2cbe31cb728f8cb1ffc973e1049a8150e8771e3b57fc45a26c70d2e72b299acc114c933a94cb0954d9aad40604d75672eb9e52931071aca26638f853f36cb6506e182d344024eb4a4f3f7eaa1eb9739a21d017c8a6a6c0160a7fedcea8c7a20bb8feb6cf6053134d113712839f5027097c6519a3d7d02ad33dc64bd57bc2caebf0257456f8841f3023630d2328e2dd4cd9cca6d80d9e70449dbe2ecdab90268d16b596536bcdad032dc761f975bf77aecef4ad5ee3b7785e510b67c4b37b349263e8fc383d2910ff2bec46c42e63868818ab6120a324190db4bb4dc9da21b1ed72ead7333f439bd1293a8737dbd77dfc055f201debe342ea74c991bdf3a514027ee8208aab799539de2ba01ce1fa1ee9bd5b04cfdb995fbb7daa012e8ab54f758a7f3d23178cb424548ef4c8313ae56152c96367ed548ca604730d7d981bf420290a15e5cefa4b4f5e2121dcd21fefeb6b384596843723262dfac36ef41ccd5f93181bb805716a7eba091c248909e26dc8c49e1ac8472a3fbab7d89e8bab4198e24d9f15a37f3fa521f3359f5eccc9c27a165e0af8b09bba54ea5dd4ae0b53bc4947b57f584844720ac217d3fb112bca0a5ef5c532c1b87e5b9770caeea71f9486e95d5c6931e9053719042319a86f244837c624445e7ee20b128cb689696a21354d15e177b758cfb0d2da8dd5aee45b70928913a8c54cfa33bfc95fe7101d8e564c16a89ea1a253fd5e89ca3f2a45def836ced23e1a21048be86ab7cc7276ef7391154e79a65bf021ab3382e5cd9dfcbb44006eab41ef9ccb3da7c2c8527027937da150185a91c40a6b16e6fbe3ad62a6d4bb9fd91b03db77f506ef386d662a428a83da432f707265df391d7864659bab6728da45c052111d57adc09eb5b0816e2dfc0725973ad7397dbcdb40acf78db27dce43619b2749b7af73cfc16aa8e5a48908d7e1b1afeb2ae6f4077a39d104b729b273222040b356a2f2e6a1429546588fbd5e182000ce89df75477a193dca4acbdfb521182107a12ca04c5683707c93cc4868b3edafe546744ff10bf1e6edf485dce0730a3bd2e4714b563e9646e51f854e3549dd2a6bbdfbd41890a38711e76624798828cab5c07570b5e82e3c979ce81861c87608c93ee2832f28e59c7c30c9b2d5a4edd52df39a3d6226f1fb05396c38356fef3348cc27b47c54dc2efabea052ba68f3bc22edbe86c6c1c631b98d883278d17c284e009ceb9bffe2d398cd96d1731c58f6c24511112b773d8e1b35ed72bcff893b09a9d4739b53bf9e745a96ba3dc0e9e8dfce377a8d30108fc9989c7f20d8b90a7fe2c790a8a24ebb16163d632ac636f21eaa656b40d7e335e31ed7321544e99457880e4236539a5bedc25bebe2b44c61f6459cd06eb50352f52d48a30bdbe4f76c6ec5fb2a0877ff7c0651024b3e0bbd12618fc9f1a0816b574a5a413dcfa550ec68bc8ed5b058e4fb77298cd79fa0e3869ec9fc6a36be4f6ece40a1800912718d6832eef3b9373fd7552a4c17feb32a2754b793215a94f3f0ce5eccdde4d030643ff14b73dcc4858dc03d0ca33f2df4c090d2d888caabd7913f9a93c03d73ffc3cce72ee98fa028536668561042560d4f337d737f73c2498fc0018da5c2ad8e64850418222050e1f59bf5959ff618550e6c81255c1a1fa140f95789011dffe396418d60a9d0269e00249d9889ba8e9a20a2464fbd18c6bb3575fdef6f68c5c2cfbd51fd908d80c8edfed76b726f296aa114a61335fe0fedbca81be5cf220c51057190f6fa1f9c26f001614fbb898ef4fff4659c6f7e39cf2e9d600ee8ecb6e2b1b38a8c5674717c6aae845578dab8d70118cf3f0774156fd9cdd5d4b75cf3fb432e8400abb6add7952790426686d9f1ba17e3b3114a85cb56ea868b061fa3123432c446a33072687c4c48294410e3e992b6ea2a91e2eb135d192eebf57751d3a2ecb6f11cea0eb62e2db5e01a2b1588402da70234ad740e41e390f42fae4f0d6ce4b385561744d1fb160dcba5d1f360acedc1da8fe42c855512263f9c2773a20786141422c20095bb084001680a8895b5db10b390a346a9067bc176237f2b72cba686b5430e01a801e0d0db1c90e392b352c0edb00b5e8dae7650e0c9a2b7a22f4bc6cb9028a9747ccf36c81d84b52820c427e9eb319da9dc3c4a2467238befa7d0ee36c1a6aedb28796a0eb888959d01cb7835eb3383000e265bdf91a6eb5078900da3b7f3a3cbba9e21cce0286e56b45bcaa2ed4f1861ea13f9eccec6170bd318d7793de78caa8fab0914f76762e29c33e50abf74a8fa6e5f987123844128f268562eab2cf2cc6711c4c543e54f234de869520e4e95dc137a5ccd53ea88b9e2845e2efc67f074efa90f4239cdb26f0b67de2892b8612e488535730b381994bc1a2d4ee3764f7fa16d2b412af05a99ab1250e170ae9ac6efa0992f36022a3cc7e7755abf3df4b151ddde2aadd87be073c5e5cb81d15301d320e57ab9fd5bcfb1b824cf2774e565fd044f4843829f2dfd50dd2ff7959d8d819eb1c8d98cdf6d7491a962316a6db269ebfc1cf8da4ac761e5ac4cec847c86641760300a10b0a4455c7fb15354a8cc9f679cf3ae5bd6e4f5c7647a5796646e8b4164f5aae9ce96902d25ba21e857a6ada2a05f9a9340d29e8e952d648f0d5270b5b12f8d2f01e3fb9774a5e0cd928b7980bc1b5baeab9d93c513de8e822d74d83b32f158689afb156f4f299f2bd7bdacc970b77f2f0308341444d60d2c494efe566aa9d3f20b0cc6c09dd1f05bac56b276834e0121ec1dde9dc6ea7b9c969e819b3acd47277c29a732ec9760622beafb146f82e0d29543337c72e4bfb6137e34283b447c62e792a7365d16658b42ab97798e1ad72c70f60be3a501702e388535d1f6db4986cf54ff8f8e11be20b9f1e807a1f77ae11b4f5be5","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
