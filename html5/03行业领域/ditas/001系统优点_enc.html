<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6626899b054b530a6b841c68472bf026555baee51f7e9c0789a69cf3a165df2aedf929697ecaedea0bd3b3e1487a4c20547c41b59c2453c9578363424a2c3cc851bca8fbf7658d8086cc981e2d462dd310bc15bd10d410af406509a5e939819b6f05eb9022529cb225c7601fc21ba4be5b0eb96fb030d5c2953bd21d49677db07da62920f1b3eaf436182ca1a4b3f4f774ebe7064a068dedcbb1d9f1a280a1097dd290944d9c6650d0d31c9f17d2557666375348a45a4c5b8e31e8da5c8c53573eb8543a3392edb36546d56b6a47d75778bd53ddb998328f8f759062c1c87207c6a0688b2f89c3763fb0b33a66a3dffa5b2a9e721f7852c928249007a8519918808609228c63753c572e83c034e630b32fa55303b6e535bd0e6f3165adacc9ba0e1c65021c6e40e9eb552d55fde0d86cbac9d20d506a9cc09979fed6ec6560c90a9af0546b8c94a430ffd8eea9f45590dea40efb40300167be0bef7e4faa97f83ebe8c93d439f83b308a4139b844e2805ffa19f541e5a662d68d6b4a27edcb295f8d051c6775e0b45fa1a59fe19e40122ddae8aaab3bd4483bbdb4a9d088e480cd2887bdea9935e81867d5771cc08b86724fee03b289588d5ceadcf4f47a14ff717fd0dc2667b63851fe12411ec0df9879df9c68a75d51d372dd84600ea938817793b7cf6ad8711728153b5670dc4295209b9398c42714bc1d0037bcab3a465402d18d2ca6d794e999482c9cbcf9bd1ec6909f125480af0d5d0d6008ea207f8d1397efb2415bcc67482393c4b7f0b143b142dfbd11a64ee8c9c652ce992ae3224fb5f4db07b2607975862021c41a2791bc8810a1ddad380c9ed0d04aeb3b8a7eb52c251a2b52b7ca4ed5c4359ac0539c9a584c67f7a0cf799e936f76fcaed75cb075266e41ecae4c1ff423f5cc0ed49c6ce5115de3604135b7a70c117a2db8381654e0bb52afcdd5d359624fce65e130dda7387d2b84df107d03141ff03a95e0e206635bd273c8efb6d4a02f2887729dd45f6a17fc981e4c74568a0354f5155eb911b4dbb64495a4841fad154d941f2eda487c0938cf50bd1975c4d73eddb95c3a0423814aabbeb34f7a691030a63a77c6b42dd416577471a3e845537b9f5b2b09e2e535974916811cd5f6e269997bb7c0ef1be245292688e9b0077bb3ad3cb8cea49e176fa8e1dd9b7f2b183ceaace5118618e9c0bf52b617ef21830158fdd8fd433f352e8da7494970b60bcc541357569576f421416c65789d903a126a75678d44f0cd88566b3cb1059c270975e8f15f907c9d9a0bc941b3cec77d2de91c8ce41d7ef42969a9751c9d37dd0af827a472015e96aa2d82b6d19b83cf310580a39f89064a1ac7e3558ce716458dd24a15972bdd203e02b5523fe51c93d956ddb0c2c6a82faff640ac758482f59d0a088e6d359cd3108c91a4548e6e75bfcd5471663c15fc0088032816db4c0d3d974b9559565a7d6519e93389b909128f85ac8db6759e1aaba178bc12ab068aac86350cdfe0d9af1ff3b128f461576df63f6d10c58d9af6bbe3183c9e61fcdf153562fd074a0cd005c897023969aaddd4b7c80a48b4127c6dd0561a30ec4c19699e6657007c6f8e32651b8660dffd10060d8157ec7e10e08a190b80adcfbae9b31372e13388159d5c773f42eb6b4433416dbc1d3018cb6ec875472566b83590c3c027bc3d05e3e77e6ff843cf01b39553f7a5ee9eeb5e0459b8e8e6d6a274c5e06ad65dd728ffba1488fc362d7cdc9d4e49fbc2302176e8f4ced718ac042b3e4a24a457933f012f3f2629baddfb8e67757fbafb556781fee38f6289ce85895fca85fee437295507c32422f54e61d71991146ea5ba2d74d8667db07647b4dee27d699e1539329f44bab3d245f78b77dcddbad72ddde07d9860f40a5c3f753c2184c33c78b2b98b2419fc75e9d959253f6e0a5dd9cfcaa46e19f4fd5379b48e3065082238ed022a97af58d4f58acbae131f3d15f2bb13107cdfcfdc8f523480a45ba5b563bc3f7e8bc91627e02edac38f8147ba887d5226f8c8d7b7a2c712c865a5ac8be4a993d5f7bd320052f3ee1c97b5857c888d8f692686d1f133b8fb15296797d945cb60976f1c719c68fc7eb0631be5c1f2926e89a1ffc2c9f704e2e5897e5ec214b68ca18923de457f5f498ba0b94d3a54af9c13619ecbb50925906a9d32ea611c21d62e4b6ec130ffa07387c233b4ab9455564990448d1d24a875bd29d10bb5f2067784adfcfc837babdf7c9ad32ea95e4b07cf5c435450fb732ce5f0b0676ed431060b300652777d1750297b6415463268d0c44798b7862da4c6e1b81f674741e68feec8431a3e68dca24f084157c7c8c606be6d762d36bd3979a560c02448ce8ae434704be4282c33f983163a8ad0e555c731394ca92e967e0c505bdac8f0dd836571d15dee6260726941d3bfc67a6163f18534442d5d80ba0f6b695c09de5e68374f959cfc6958e3f0fb8709a7988e52f0ab8a8120a123f7400df6b9901816ad40778a2fc91ebb02d08d82242b5e973f5883eb6b34fb966add7d6d55540d1b2c16d073acb06be22cde8a347cc2df7792e28c46cd6093cc923f03c452a0297461cd7d662d2e37ae60a78ae4664c64e8239d80d64f74aba16159c0966e48711da94ec2aeae619f20cf3f3e7bc4e4cf11e447223f2f0c4e14ceb284de34b44b1620995b749fc77b9dddda91adac03740c220e45a7815e8d873f18c77dea35786784815f4e082fc083f7cfca135b420474129631c278fe8330d7441754c96886e45e57992dc3084ea8548681d22837cdbc2fafd7caeaabf4d074aa20fb5e3f6e57c2f43bbfec8f0e397930b690a1c7adee49dca423b219b035389ead68cd45de6cfe108f1bf1a51d138781c56a2cb3de04badd146018ef637b90813891e47729c40058bd68de35fb00b399e16219117b6dcc350c2a7c8b1e687588ec8d893708bec1210abd251156b7a43a9f374b60f9e27227a829c6b6a079aca2ecb29155ce214a0ee4a2a7c37ffb1243ef52fc460dfc6f6d4cd55ad59ffc67cd72d5b044592de3a792c128ac9c1d07db07799a68a35c13061a6054db615a7f0c2ca0c478f36d1d73516b6771a83b0bb6fad4a84b51dcca60efdd684aa35fb23019bb7d21754970e09fba03d4cd79182b1bc65bc11ec7d8cf526faed22d67f395c3befb8ac92486c4ffd6e55da07e03fc0fe12808ea5f3e55f68af8633aa1a1dcf7789dffe0d823afc1e110fbc2bc13e3db535af1d34ca1588482bbd97245a57f3ad2cb85eb187c3b6ca3e826d3b4200adf15556303a425bce3973803ef14abfec5bec5333ea33f89ea93bd13103735e45b9a1e1502eb5724bce0a58db2feb7224d66dd846d67ee33e7bc12fc9d694d3177e6ff50dd4106fd27f0667b577d4fc3590fbf77f8e5240975d25dd66a70e4a4773a814e67be6b04140bbb28216c7c187bc81bdafda539fc4214965ea4691af8c7abdfc58c4e7348de4abdae0b41d2678238353de5b59131fd6c09bd48ce77654aa75be1b378743ef00c3298d5f9195866f1cf873fde6d69d9bbbe9313335b39aae126b0f7ac2d7166db705f2f960718b19e33e5975d3754a9fb0b65e2d43f33cc692803d6d6ce42eae9d15e4e037a76016ed01f76c72b1d69d580e83d1b532cd38ae79b54930982247adc28aea930af782a7ea3619e3c9b9c726d5cb519bd1f00e6b4264c46835d9229d1674257eb32303a99d741ada521931d944f3f5fe5ca53a41f5ef0ed6c8119b777751f2bef4485c422bf2393b4a33191699db5589f21d38ff7cdeb2fb5a5cc1f7751206acf74f1798f45c0831c534479f57b9e098bf71af3d9ea06afb176d726f05d21fba844f772ce4ed36759c9591fca7321b1add9b15a87adc1bad47c6bbf5ecb1cc50248e90b1cd104c28b214f520e96f75c18508154105297a7d8230cf0843332b84a09e3a7cd85610c0dbff4d472d379012d246f92a61c113dc5bf1b639e043f9645ff2949432e8ddc702bb3e40f81988aa4c13b81e3695d65ec36a2dc4c67785cf862e90f847ecc0122833bdb748c6f1358963a141adc46d5d5f661307f10c640344436ab9b5e8dda16ec7d65848223ea71e39b99cb15400ab6494f19d00499e0e059ae5fcf025fa3aa6b10c621c49d503ad49ea483ed920eaf1eafbaec19e686569eb3ae8b9f39d5e5da866155b4053b81859bc58f87b74ad3829f40daac1c554e7dc75435e6a0195e9b64623ab29701f953c9be20b4103dc0039dc92e7bc457e5d8ba6554cab51b318bdbd1809bdc4cb9157d6cbb9b5d4531afbc973a083ac55fe475e2f2259ec12a9ff1f756dfa5734cab52a0372a92be96f2cdeb5fcc8b7e2444f83f53bd1cb425ef6e91ef8cba02640d617c45f02171f53c6fe0abc46d655b6a4ecfc3505d136be0d149ff7edeed30092dd3f67d31f90cdad928cb2d796f784f16d2fa2c7319e5db0844b800d642f2047abd126711ba1799de07366f2a597a917ea3083a91076581ee66612e92de70698592ae1bae67788638cd13e3b50ff6e631102358d1f5c045f2162dcf7784779e5b41d2d648d5c235e900c03841abe3b0cfd568741a47256ba5b3e075a47e6ea47a42c688cadf7ae1e91bdce8fe5238f9e5419803d358afada90997f8c9c2e59811e6d16f46c2a8b16b282094ec98fd188f9ba17c782e9be771d7d476d079ad0aebe0b1724e4a0e51cf6b66876ca6a6da63dce5c5f2f192d7bf57c07721388c155fc04ad7db98b6127584ab3eb720ef6a85d68c7d23cb030eb7e1c28e41a9721a001933e962c4e6942f79711db25412486121d7cdaadff6af802493439404066ad67df57122dec7efed01050830421b1a597cb2dcf1ce88daa42737e0f520238020f8e2429a92bec8f83311ce44df6de39a90a72f3f7a1c31736506b3b0495f25e8c1738f950de6405f5186ac408750dba500e769f30cc91ae5bba4ebcbbe696c20cdc915c4a5cec33e4ca75d62b83b7bfa52870cc63128879fc9288198bed36166d245fa3957d96780123ab4fa3054094c5c1563d32a1d4803ec34cb785590f37a51c93bd8c90edd9c2803ead314704b808132bd5830a4447e12cdc0f07e45e9e1163749fe9bec0833829b537d3b371e6e11b0c5a0698a96a078095ef3379a729bcdfa3557f5e45a004ce5b9b1e6abbc5b93ea0759aedf73883baee31046765bb0685fb3de75322548091cc23f9c3658007309a699234e468187107cc8ee4f9cc85a5d2a12c8da6c3dd330208d216f7709945c121aad43469f724ad4f1fc26efe9b58d79dfc98d6344de6e69000a001353a83f7296488ea402d661778a665299fc8f947515b0e1c70e93c0e0331a51d0fea6629e4f86bfdcd049caf67c4653e954c8583764f4b9fb1e27d6346e4229c84bf03ee1bf95c15b3ad0be8bc2997c9950c42e016b5a1775e47ca9824e0e81af25ccead21272da3161221d67f558ea2675f6aa16561deab42711040db9b1f6703528f8986b10224a63d548c6b1ae8a43668c698fe90b435bf696165f3e32906cdf428a602235c79ba5674a8254c665e14ae0d5be20aed1a4ced70f18ca8ffd3413e3fd52ed84f12de27094947cffa853830f7570c383f28cbf02bcdcb8b4f623d4d7e4705de451031aab7fd027b002c3ed1eb1ec5a6d17fa4cb016b064b946cf55821a354aaf0aea9175d228c0437d04c2080f1df7426f0e9a8a95165df91be1be7115c83c071170d20455bdc9cd2f74926bb1459d208f3f7f693b9e24ab00f334335a641a00cbc3018cc67769baecaecdd317ceeef94f9e7f0e215677f7f14be545e911b18889b7605f171a57c64fb253d7bfecee8c875229b14d7c09ccfa17e07f685602e0786e51521d1e7ac5d6e6630c992409087bc798bab76a4f5768039db5601da05b1a6a78b6a264a332ab412ea14f3e0d06bfbbbc70eda55326db6c259aa65b1635f48d1407d7e20355daa6a610ffb729ccfd539aa7208414e965c2a22b7debeaadcfe698510152beb2fc3e4088458dc7dabed787606b45e314187f315e9fc0512b2af36b5f511750ea2733cb69c9d4a067ef2529feb76a03c2952823f9d199b5116a5db0c118bdd174ef3f74d1772e4a75eaeaf6ceafd32c4bb222fb328c3a2d65d31be7b3d8668c52e76f7628a0154dd4b443072924c17f008e848f75cdc28c7eb74251428024953ac3fb8a823cab43fbbe34d424b71bcff316345e0019ac41f0ee3f18ac47059305e64fd7c52a64ff1045041d7dda7d426922bc0b5677fdce765f5349fb0bd5498afa3d3fd056f3f9e5831eb8305c474b13ebca0f36b300ce670037c9a9413884bae7c3ba97900916ac6c47943a743620219c99678552d4fc2f548a3f560f352a93431351144ab3c948193d8a05278a8d384e9861ceb23cfde1926f7d5942220300c69dc1e62c4f79bc9994eed59f2e46ec20baaae0caadfe183fdf6d17db3340dc4e1e3b5c4e03d7b2deeefadd072ade286b67406bae4b53d6d874ab88befc55be0938c1d0633d9087bcf7b64c6c3c487712c0782046f8965fa6941ddcc1ca030dd0aff8458120761544638fbbcb48bcf299b2cc878d7fc7f2c824472d1c61b8ea2c1d7d5683fc47deb087a5dd8fd7f82f0a17071db2bae5536669d39c6a72f6dbb81fbd66f0400a26b20e79e61657705107358021903e0cffc4a9968c4ddc4f0f217f724dead7416cae8279bf51f02bbdde0730b06994a86fc538a016d7c55d78a21c614f4f5a81a9ee62436f969222a1971825cd3e388cae7dcdbf34e7e6b8aef1b77db31bca34d3f2bdc66a9776b63fdcdeb797cba1b02935f4e443a69ddede3dfc4fc54dd94f2cc38ce6299a1fe05c226f8348e1e30a964bff69991bfacfb07237aadb13139582f26f507e148cfe2a2e96165d324988b515f63ac3e70ff30a08f7ab9258ba543695529cf35444fbfd654d70e602df0b9ffece2a5986ba7405832a652458bbafcf13807b85e84d3ec6b397926e4e7ef3584560bed49c5fe8de81d069f08339aa35b2679024b6d10b4a11845cfe3125a01d948c9b682293a44d8f58388335d6415bebdd9dd790de3ffdfaa3e05279f75ef501005b6b017d240ae1f7b33d1278a69a4ee66504d1c27b2fc8ad5ab8c0cca30c4972e7f7a2a7d1915ce39dedc1af393e0b5715ba31edeb0510b843ff630f03ce5a046d8083416f91bd17c14602f4f0c125834aa296cd6166db67fa28d3488077e99d62ee0459163407d8bcba5f87d1b6b29950dabc3b09a777c39643247cfe1e614c65f9bc7d33a1c3137e7b8833659fb9da15cb7be6a90ac8ecef41abea438d8e09b82a57e960dd94e0cf95279f7a67d04dd325f1150a4148ef0e51d7d252b15c57a90174f78eed5898eb3a16af0a64324a8d0b44d265a9b9bdf709ce58d8aa52c1f57ce6db2a45e805e2df97c59de3b14c200648cbe25f42f5abc83288ca9e31ae83e36de3473369ffd4e6b07559ed43343f203a6dbce23876bd7a4c5a99235cf71eade5e605f0fe0689dc10534a56e870f77769601bf5748daca9c652cfffde8ef58c2946b58c8a1730d77e28eebec4e8c2b6602cfe8401cfa67d084408ad0562faf28189c6b039d19df9f717f2a0b37e4499bdbff099bd29f8fd771f0ff51a6f11025873709ac0e6d8d1435af343fdb2921e827573982ed5098387572ae9cf23b47393e368797c1caf1bc8e0cf493d2be8b44984f76433cdcf21061c78a0f8f0a3e797b25c687e3de63da92decc676825068ca0f304b0e3c49d1effa2e35ba43e24b6a38de3bf1e64428480db01f891e0fbfe0c49646cecce67c8103f2b14e3d44ece77b2a01e44a1526f464a99d56c62d02506892980cf78747e052078c182b19a85e933967531bc025216b0847b817a88941fa0038a001ebf3c8651b5f28bce984bfad9229cbea09c178687be4b2123b59eafba5d50defd182fdb65c80fa90c299ee1b5e6480646ff2708023fbeb35d8e5104f8641d342e57d02dd948351bb722e16c6625100940eb14b72b5b14692fc55d9a0f45080b63ac4e0515cf35d22903191d3bec624c46591dee064cc0772efc4c41d90e15cb823b9e19338ef24450e51f0fc3ca12c423c1f2578aafdd10139091d968d4a44112900e52a1d170c032773204045d4048760bab90dbf849976c38e9d3a18af95a079b1d4eab3256812207a26961690f8323e711522908ebb5d6eee0f4af325d5a145d84b68fc6bf27c69e78622ee3852ff2fcd423eb4d5882a270703f73d7233f567c7b695875ea8f701b47cb08013c9ae11200b0761108020b10f13571364b5c7ecbcd962c8422291b1a378ebac2a45450174b726b7fbe8f0c37063b790b421151f78be07ef72464ea994becad071217c1b09b0e5252ae87c22f889ff83da9e3516f01c22d7b5ccc53ddd5fae6f85fc8897a349f177cac21d0e07e88e750d17f27cfbb054ab5d519530f83f93261cdcfc3c6d4af7a66952f3d5420cd6ab6d2e542b4ea0e11c10c62901dc9e2540e1df0970c23272c92584b35777b36a51ed7c3a8823f342a734c45f11eaeecb4966b4001378f32aef61deb4dd9a291cff6b4f7d26d7dcfe4aec555d930c95bc417d1885b6b3d348dd70bd185f00f63ad7bcae1c4ce0e84f832bf7241f4147a0033ecd178b7ec60ee65da47dd6f5054e394707f88772daf4aecd57fa4c166d5f00bac6d3ed6a923bab672ac5bfc0209328241eca7050abc7a626cd3c9c75b53dae47ea14a7248155b7e0ec1c138e7e997008a2f74a0404a1df1a9e5e803caf1cb996863d9d254c6aa747d969de6e32f1a57f7b8bf59f941d34125be4609a1f06dd6c4c8067821442d978e60ac462931aad321f4641e45d126c26c4d9a52d3889b3cf549f8b4718adb8ffdb0535e86c837456bbd6fc685a4efd553ee7e76aefed21d7a031ec3037d961a398da33016746a1f9035c4c3b184042d6a214a8aa7424105c84b989fe9079ce116f9fdea02f8506d4e0ab9fef7c4a92adfa1d9dc99f151f308635fa72040a546e7e4d18db8677f121cbdd6a0ff0bd29175d26013d0fef92835cc223f1f79873f4eff6adf2ed4edb32cfe6020190dc0ac8e04c49e490044a713fa85b089c1fd2c18867481ea08662a2e4198c631e87883f103c246897d26ca6af889bbab029641d7297c376b92825853ce5e20b1fe7d2665f668260fd7064f779dc6bbcf558a707be6e5e7fa513d5efd98d21b1b809a5a0911c8bb5a18ced37d90cde3aa5f3892366f76c3eb50594e491382bdfe812d5e52b9e9074ba9ad12f413420967cf3eb8e3a1e3d845b6917a95f8c2492c458c0b177f92e0906167691ee5e93082dd17eef8d3818394571939841050758e3480a1265c09792e7794e7ae941f5abce4df10ed8200819ef038b7352c316494d64ad189eb6199c448666585ae5bc77bb8efbbfb47ce4d5f4ac3c6e5ba86afab2f4f6e3ce65855e51d9e8b271fbcc893d7ae2fef51b69f61373ad104afccfa1eb535eca13e0ece5d275ec72d0b48a2572ad7fa16796d6ca5fb4cbd8df597c4e9aa2091866f4860047fcae74c1244da222ab03fa8ec1b2033f29f54820d29f4e5e41a37eed7ca85db4b3ba5be5b27e90888f5c12a06d8e8c9368b8dd1bc5a4fea78a78c3cb3c2181e024fab3795fc65153262439ed64a4f8dbebdcd2df84c74ff34c23a34868130887160799db36a6b4597f36729776b4956ff12c253046829a419bc91d8314d37e5e5750b7d70d4ae33f56e626053a5a343e9262d98d341d0d1459ed06b2eb7b217705ef4fd4ebf5b1ccbbbf38d0abcdb701511cd01d47e8457ce12e00fc40b7573e0b2c1825017c9970f2b5d95d435de8f1498561698b50d1bfe4750be782d81dec5dd85516b53a83a8ac81d7b345d78e7dede233017adc56714afd51cc56eff23c0a5480091b4805a4c8614230849be17cc2b6d06106b4656d84335e870f1b7c162a66aae30518a2c62c6feaac34790cb44d4af68646530d555e3436763e0e80f02fa086ae8c46fd0b3cf8c2592eb42ceda9f265f58dad40d2778424c77320c12be35c495c1d9faf0df0726f6e455635f3f2c906b22271c09e324e71333f47be264e0f34a96ea13bec983b7a0a669e0171f9a002e19598f39a626e2b19381e3cecda75d47951e8bea0a4843ffdf6a08b754a79e6c671694b7fd05d26cf4b0717f4bb1e443c9746a8c9c0b00afe15fa7356c13c0fb5e613213529c73f24732ccd6e5c1bdf4573e2ed4fc363f7284c1d4356ef9e6f0d9ce1f8354036c5850b34bb6bcf9fa9e261e453ec480f26474a26d222199763b5f9b29483c961684de45fbea3d50953f64c96cd7f33dabb83a736c2f9e2ff2c0bfc4968edfbd318a6d2587ae76c42c7fe496e18d1fb3312231387acb620f2b75ad59323711a968098c4237bf7f44b7f0516acff5e70489dbfb24b929010095522fa2d981d73c32436639c36c477a3b5bbd086537018b7146e2685861aba895c919c680e15c30e940ec8f5a928d798f4df80726fed5f323b926acc5846211202b1aba03a536d26f09fb63223f93088dd263eda45d56b3113833cb89237bcac0476b66d7acf40db882b7bcba71836d2332a4e5ffb30f1fc38dc36ad41bcd1ac9885b8e81f1ca74d7d8f7b5c37524054d38beab77906e4409269065436819fc4065b389f93d954b705bed52bda9810d19ebb38f65865a64373b5b4ea73c2bb54002a715d432c0fb19415dee8dd1123f358703996d7d151f5114a12ce69fba05258c557fd34114e824c4640f3e76fff512027de19973e9d3ae0d5def23ed0882d2fb1985e35fc92c3808c5a3b82f54eaf4beaa790eb4971a92c2b0e6c99daff42bb45d3803689bb5264d6c896c1e089eb31250b46a5d499260a819abdee8e11eeb049ab1a89d1bd393a3fb80bd77e029bb95a0259e61820ca59c191c53152ebf9fca578c4a5041a6eb619c593d996082758173ae3ff5eee05dfab7c5c9b4041b6549101318da727a0e7bac9fd53a9c083b0442057964a2163fee58c1e17753fb0bc2b72de9bf0591123a3cc04545a526a2d35dfc242d2227f20ed2f4ddf5cc9ab2a2cb05576db20595d38ee05adec7185081c43047f496e473f18040d85cd5d478493d81e7a26c422b1583281b04a0bd86b2b798e45b057c34505c7925114bb8f258b6cd9d80a7199026b4b7e5d86913b5d284fc48bd0c01371ded9aaf423a64c5344d1c2bb6288eda7c902be109aac1768054f464dacbdcff4978bdea852dd07959cbf74f10c8b260e97ba9aa826860a13a823ab61d82cc72bfed01da36a7fc35f1a959ec21c85112f527ee4d599c10dae1ce7f2ba6f1d83dc389b92e57dbea3b8139a911237ee6d68bc507fcd5f0ed733553d22c9694ef138b9fe55bc12b0debe1d5b16f4ee68e609e057f9178c5a2c422112b5ea667a97e6f60b57e94e924a87117175045c92ac5db3b501ae5d9c4e1014d35be844421fa70087a874668e07f5c3a01cf2115042773367d2b8a3e9196122b868c7b98245310b2671580fe5bfb34719f1845d8f6abac7cf3de72da5f4c0ffa79c91e5c2c00b56bdd98ff39ec5e45dd67ba1c341990f517f6d0e9da64e5eeeb675985625e8fb4e152d650617d815a164cf368da26c5bf12f695b90bcbb5a87ae6d6004b1f7d445ac5e8eee6f55c4b0bfd4658c559144b0df420b2868f14618d2c40ac4289783e8026ce58a4da4fd1b01b824474986e8a5b5707bea1778980f57b7bbd4525a62489f2407e527b166c5c954d5a78de356c98ccfdb68c67741c774459130af5adf92b20908b96915d03cd221a8f2fcfcca6eff630d80af96f4be9acfb80da1faf6849eb34edb545d987d1a35028b7a7c0f15986b8707cd7f381a51b44b442da94bfbbf257de293bd7f739973be5c3681960fff0f8756d94ecd6232b59704750a9d586461c954657c6133352803e67e6b953f51b33e6f7e62a8546be799f58f221816fcffae336ebdec13caae222217bd2dd1401753189d35c996508466eddb7b5c7ef6f2cae817c683261257396306a79e113629f7d24cd59b59194c99edd8aa5db6fe0bf26b8ebfe832710ede02cae77bf8c37ddbe9b3fe25fb341143d26cd9ecc0f0e630cb90804f940711c197168297b21056a68e7e4a201d85d36f5eec29e6f462d13428ad8974096bd5e865f0284034f87946bead5241fac65bafeaef94f9d07f230149118abb03c3678af7a122bf26713cc0f23fbc861007f76a8b8df6ea7a2c4f04afa2a5ef395833fb52c16b6d6261cab78d0c1eba9f4a93cbe4c63fec4f87f7243503d42f33b86f374126b7f709459bd18db53af5ecd4ded7f6921f189eab793a88dcd6e15f8dbc38de64615ef8e2642f966d95cfa7de460f0d2f7160051859f9309f3411b95284f11c9f07b652ec99eaadfccb65608f91252261cb12060a4609c120e810ccf89b2f7fb00c49d211e84f71f155a8e4f828860580252cee7787b370e9759c8bf6bc1520521e40caf210f11884fd5404e1117bbe9404612771ef7205bd0e523f577481956b16b206c5a7813c7b0c09ee920258062b7663d685f7833b20d8172a1c0900cb36b4867f918ad26f9ab23b1e650546aed6ba456f9de437817ab7464a17c22d9f5a7924862cc3bd563af3774dcd240d534e095ec8b9463d5aa17e775db53e326d83e6ca07252ea147e94b26abd72b1c256c558bf2332613fc492b7919c964b4db3d6e316d7aac53297114caff9c449238fb3190f87ca2af9691448274d5641405c7f6e4a0d2f190048529df365131232b919d58ab555b075d35cc7e6ae763857fbf8ac8c46a203a8c8e466538e5c36386b981bdc14d212e021659c1ad191c74303a7677d3a45812e0398af8b95ee31e233957be15f1000924c98a0f0f6e154b2ad28a420316b71f42758176fea9c5c12910976771f91c083e1f46bff712848f9519efa3eab599de3e01e9cfa4cc1c3f836374f3e2c1ae5a8248c1375bfb944d95029c12f8c402efa63b7edbe7e88fbc23137e912ebe4ae3212750f64ff9316a7d4556fb2ec48eb867409f5f802dc4bacd15c0911803c188b84c4cfd7ec87bc7dd86653795a7bd15ec9cdd8c4703cbce9942d35c7a928397c0932334cc47049679c47c497c609ad80e90184b130e2639ac7088e59239540ac60924b20dbe5c7c1a0e998644ae45fe1f23d4d3363062d38e388e377a602fcedfd534538ac37735a4a3ac78a92cb60664fe25361a5dc798cb9e86e49fd022dc0a19a1e333694f032dd80960ce7605336e00bddbda5450c3d8460db920284e70ddff00e3c26aa7bef4715fc4c973da550532fed3e5728c401bbfc50103969710434d33d71d5f873faeb7a8725d1b1e7bfaaf30c087a380ae124d8dc04c137276547aee2fd19be8ec82d76b25d8cf617b314a6fd042a50d50765ea02bac59ca59d631584b7f04b0a9397d8df31cf57fe6201608980093cf0ef116457cc84d8eaa95d762586eed1743ca4d5a49d33bb3eb17e1f0054ebbd7a9c225a939ea13a61e233c81f208b70b00eb6151e97fbf2e7402816bd69810cf4001080fee975f0968666a0d3185a63c894870a50f9a665632237b9a9b348dfd68d4d52dc81e1fb6995178d433a95fe89273155d6cc4277bae4795dd154d7ee974509dcf7697f942e8f67e67f39ab4e582cd494a64ef7bcfa2d8dc5703eb11c3a40f0cf540048f01c72df484e13ca4f40d31992388ea7af41de296ce19f7d62f029945f3e57b5b37ff197029c97755df875ee13bee019e1cbd8ae1ff21503797c096c102bd782fc887b8063494ee1ea32ae8f9d9bb3e0f3e41b40451ceda55c88787f6332ac2cccdf862994708128cfbe21aae43b03ecb0ab453e305653144dc6d2b9b15ec815f05af7620e5f7555756ddc921fa72c48d76673eacce678d1179801423a33c64a81e5a190bf0bd1cab89b280842137","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
