<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bd2611204539f361ad4890628cda69a7814963fb67ba69b67c7716e5b562cf3c504538d6c9d7afb465c75e3afe556d21740565cdadc6d5a418791bd104f834a6825dbba7799181e43b7bb783f79af1656dc88d4d4185748cf2d18c1191da462de566451eee169387ee43596575edfedf7430b5247faafe3f8f6b0fd347f2dca2feba7856105775c19e7c28ec457dbfec42a87ee71e05334bee200f22389dd3aa9b3dc86b013135944e652a5344c1b2f6426f6db466d69a5620bcfd435fc3b549dfde9e65732fcf902d181adb927ee0c13feca28d7460fb9d2c55b7395d2cf0054785fbd1b6b0e5412604b566ceb9ea507788d98b68e7e94855181008e20cb723a74f9be126aaf55c9a49836321dd437cf603c06983b61bb97761eb703e3594c2097f86eac149a18a4e0b65c8aad551b452347fa3eee7587c421d0e257afba83f54dbb3e7df8640b8af5009ead452bda8c3569f375f321f34ab966960d4006ffcfc12e051b5ebf1721901bd722bc29cde91a865b9700788d565c59d57144bd74c458a7fe8195c366f42893030250cc14d1d1208eb73888044e33f4ab6263ce7083af646ceabce52b74ebb1ad84c1e04a8ac2d0ad0c7751dfd5c4d8757f57148e2f4b41d46bd6366b5e527af2f895beb0795907c2f5ff57405c21cafc0cb606df8ba0cfe7a84b184ade58f0463f5801e51fe61cbf0ce24597d509ac5ef626ab70b4145f9a64ad9dd225929dc685c22b173dcc53793075faabcd084908d991d153c771f522b823faf20f7986a675f710f4ea9fde33e6772d758011e9a61a5e4937550ea6cdddff13cf9eab894a6ef95154290a5147ee6bc18e27302949dacc706f4957d4c7432b6bb926a3827d3e96ceea0d733e43339d1f5325aa393f7df7cce54fdb2907ea1d9e6ec7d0d69df714807c847a6266b7a72df45762c7f3aa6c2761c7495bf55c67fd28405d9f15ae0f9d70ab9df64ad94604c2a54e141906699108cf52297ae1a80b8214a3f92ca358bf6bfe6a096788d411ae5b45df01e08a77868c159807ac1bf59d468a6f4faef7569311eaf4ead13c95650826c22bd2fa49de2e582ee9fc79b322034950a613827199bb8ac035e8f221f1a6d2e6ec6570497eecd1b6bc89fc0f1deb48a3ba1c813921619cb6a03be4aaeeecab44cb8ba7c58879b1ccbc2340355b6a7a760d2fbdf050521db2484f3d92fe65e2f411ebbeaa22e841a1ec493c13d31bb7c519180a4a97e36486d3e2751128a9f314b36a9510683a445b074814cd2e143acec67f7bfffab150192cdaf3753561eebdcd265b68192fa94591048f9bab2dc3deaa76d8aea6fef5d17e98b5ab927faa556017fb5c0beb5e4bc07f308f21e6440f4f7b2f99f11bbc0e8ce3fd6d6301ef1d047e8d579b0e2b582c43484115ca871163c2c58a9ae41bfc714f0343e456fadda3a54bc97f17c2e93d9e7b92c276aa584966b5bb0362cbd7387b6dc04b9124ee28d2083e5ad8730c7a036967365696a4b24b3dbec88632d49d783fbc1ed58e8a4a9a4a515267f1b1e9041b6acc1c17bbbe99793c5f7833a0dd12d67b7e102572b39a969154d133b80eec96a68e7c8863ed564987a18c456705802f18591eb740ef954340b3d90afe563696dd6bf8a850c3a951f6f5c19051ac39e7651b8d48342ae716401680ae3f583fa2d016f2eb24ac7e73c3e7729c548cb69e96dec1d7d37fdbca7a16b017fc03aeef75842c445b8e422ba1038c5fe81233e0bc9a17783b7eb1c0e82ab4df560e79e65984519d34f699c25e6e72b62a4cee4c4f57b94682bf6b5c2c6a70c9d9d272ffa5a338fe9f986e6679fb55fe255cce427a133c3915e4ad1ebdcc4f9d8be62271a13a234f64cce154e28402dee0035bf62da582a45eb3f3b5081e19b0aa9cb193773a867941531349b14873a885a2a1ae82b8b55cbf6d85a2bcef19bd5fb455a8d31c78230bd6b8f5cbeb9d073dafc8517051fb708823f9baffe9af7c44d404978b392f9ca311aa3e46498c373d64ccfc8bf229fbe435a68c5381c500e363a16f847af4dd5858961195191336ebad6651ce8ef03735d851d30ee69b6b2a84e3b4c90582e17ecfcc9a1cd81444eb68d69bcef26fe83e83002862e4e4b126b82f27f39335fa514ecd7c2e476abd73dfae2e112939df546d054ce89fbc38734d21614421b1ce08e77e424aa29f8a747f8684d78ae57c2ae9cc6ca5bf400582ccecd4693ce764c6530e60e22b847b428ca2b93f76de69cab6dc778ba275bdfe9db7492bc35ca23d92316ebf5ab10f571b0df5b1d179ec34ab1088255d4a5485126bd6ef54a483567e3474a57a12111f96422d56b703f4571e6ead248c37abf6682c0c8a7fc401b74566bf93317fb638809c3c60a6c79e508f2e2403391d155bb802a96133b3c9e60fa2a4cff2a718cbb5f8492ab9c004f8f1f4ccff3b15a20b9847c430f08ab2e03e3016ec6cddd53ecc14fc3700f2dc53b01c889b0e196e90a34b9e1f193b33d3d7006ab14ebf612224c9cb8f3b730e9eba6af4cff867b44fed5dfc996fd687c58047d5b7fcd0ebdb6dae948e24cb31aea7206d45963d41e82e62769a5c19709fbf2dd4bf49646ec52c34749291f176921e0086f90471d646e1f9b7a41c8446dd70aa6c2a42279ab1817b7905d3dfa8f8ecd86a1ab5fa928b8d3d753aa864cc4cde776c0be4f8642ee642f39fff93b21495442a08378efba072dd8017b2df9dfdb3ce878cf8b9e6e1c688f8fe5ecea96d15c016ebe8bf729a1a422387c27774d95243d0a549b8544a237201b133870b8a9d40b6d02928981997dd00cb4b56cc949e780cf238fbdead94fd9f98aaf3c71cb325089abf183097d3543ab2835e470a08bbded49e8003a14f00410c86eb2db08293df1f9d2a3b154144826db538fa4133f777e5f9aba41590faf365ec2544c2007da3ce50bc6b29954e86b0aad6e6a6c989c3af9a2ec821458d927615217b243912dbe8902fe5712dc25518d3471d6bc656f82a47e52eddb4f5f9bd2de760f3d93cbaa4827860a351a110c489a70028858d95763c478a7dfb3d2a62e1577277681c48a55e7e3394fe5fbad2db0fd12b04c49fdfa8a405ad2bd26a6f4f3b5d429f3ef0a361a191952eeed0071b24cf1f84d73923efc965ddd291e6eb960ad62c2cac7e9e2169c4a3dd80fb35569ba0f29fa37be2e1fb581c2337352afc26e78845ef81c293d11ebde83e8f0f16ccc9f988d5d4ce2f27dbeaecfae260dd98da8f84713876c123ebeca8a06944429e7229c0c95f757be665c7a9121d4a76dfa962f2d0a067688b65694c2d0dc884da4326cd121e1c8e34fadc75974779947ec3a4570a5562d7c232547dbb261960115cedf36a3ffe6d481c96243881dd686572f89b5278434f75fc304c1857ef10ac7a0fac5b3c9832d58ce1b72b946e530a4f332dd871be05cca788953d2b4a8e504afc61a2c0dcb1b15428822ed500cc78ffeb36db267d783c96ffa066ddc0fe074c3471ee821389eed86cb98c27db0a8cfa58ec910776be38df66addcaad8ad34f4d4e7c6eec2b701f6c94bde07f5d94a505722536035f7bc1545f8d0792cfb32199e7d3d63794df9a91ffcd867089e6f52244826b4ac73484e4b808c2b5cdc09ad0f05ad7f34852ac5498ed051c818be373e2250632b6dae90ae6824570244283c11188b117c14aacc3a8e2b8f1a3ae1ce574439024523b4b520b1bb52bed7644cc9594d8006b3ebc2398d999221c51af16f78f7492413ceddd423acdf34e1a6275ffedd5f19e2c33c097893e14dccd69b4f135e3bb9850ab5607f24b8f129a28368deb7e37f13a50f86d54cea68294f9cd9f202019a9efdc0c26aee1ca7ad0642ff3ac16a143ec91008a16d676c010f240a0f2d63bc6519b4afcdeaee539cf9fc2f688fd218d825957c2c9f3b6e5c49988e6befb407bc4a46d4b3d670ca11235d4144f6f3a07afff0b6c63406ea75bc0926407c84c2fa9d391cf29450cdd4ab8140596629de530e6b794cdfc0216441980948907bb597960e7ff50a176941563625430848175ea04502a8c05229dd9d9a026b493038aba0de5d0c0239e938b327d77e8d038633871ae76224f4172f66c74cd12f6bc5f13e7355fe162df122782cfdcad83b1640e4c7e76b521aee12947616007b672bc0f98d467704a7729deadf3bdeca39cd9561ed83bfccdbeac28659a7753b06eee206a95235aa06753f42c1ab44fde14f1c41ea1ff9177f1b63e1ce2d8844a19c04896c93ec40ccaab31e7a897a354b6a7516a487c2da10409283f467c88426c4dccc729fa30d5e7f6f6cfbd8094522cd58b1d97d75cc897ad4424690b21ab9f54cb64c735c8626042fd6ef9eff17ade8bbc9cbf8974eaa1a2a254039c55ca5557a9f67f6da3436af15807b63fef7057f2f991bf21272d0c1069a0ee819cc964c9da1821b94f97388c437edc246a541d4eea990de4411be18342f2a752376c1daaac3b45c4a54ecb9eed4c783c3294c38e4ac4d39283c47ebe2932a9bd0091c0934a9d78e9eec16dc53baac50bd202e04f38c646cb12e942594e4379196229269765ec6b81eec588929fafea452c7a3f36a2fbbf46a797b9d65caec3aaa02421a515eb4e624a9167fa3375ffdeddc64c31b80ee68d4426a8b6a85268a61b39d32d6ed6c02c61d56868f6319163a8a3d70522420f96bbe4942edc24f6434382c5f84161952602a455518f8224ed7b204c0800daab2f4902ae296427ea5519b92636c5fcf5dfbc3ecf6f39c2edd7444b7edca6279bdaaa52d0c2f3f8b1d1238c25f6842e391b304dc46aaba4d99b24014bdab9ec3c922d9c98819db207568bd14f50ae9fd036863199d3606e55a78fb3538cbd7793160c83145b62ae78e7905f116a8ad7e4eb687ecd1fdf5763b6d65e2822391c39041ee45cd6dd129c953a03bcf99c405983390ca24961d2f3b8f26b133e76abd711ffe566fca7a99785511f398f9a148a7e1278ec4af3dfdb787deee231e9374b7c28f64e917d5ddeb5d5b0d3a6bdc977a482c6a7da2b0403989a06c7dd597d4a4426d13117226ead0e0768fa3b5d454f9a0646b936e6c4fa3ba7a920ef3e838c5637cbd9e42812944a5b3b599a7013329842f801ce90b9518757c6ffb8e5964c42f8ae9100cc80a6f431ffba2c6b23a1ff452c33a1c63627f8173169f667776e57edfca14fb41f33be3ea797431f161a872b7a23b8ee724da277966a22562569cf6bdee88103152c08a738d286e8f1c79dbd9d08ea8c4d05dd7092c923b893da871bb6caf4f807e54ae452aa15cf788eb69f34b283b99f8a3334572ea20542aec2e7055e1e2558b421060d929c249cc33bd7482f7fc1297346e545ffe414a000c77ae9ea286925b3570802995096546cf0ed3c359120a354d8e8572e3729","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
