<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9de8ce073ec597b2f7a557e1fb9f16e752ed9aa9c118b77cac0b9a2503198554932368ba9e27434102f4150ba6a7d057b9286015340e9f7b20dd1b4352fd233924c48547cc5f2e2d1245d985ef8748cebe974107ab381f006c39befff34efcafa175f500474158afaa00790374cbc39bd9cc0f65f2ac13355a6248c4af655b5dbf499bec11f6c9b966c14c00040b1c30938fda5ca4a3c2f7bfadddc1c354fa8fcdd9cd7c8f443394461ce9f418d261745b62556dfed5d8133362c9dc25cd6f78025a082e606076df8cd64de096756126998c9c82244d79f0e512838f61076335433683c04dd34c905f092a9987b19c98735c0b839f2749c7c2027dc858531cd517ecc22c491feb70227cdf3a40c256f159b6890b530966f6f2882cac4ba02c279ebd501177ccf0879b2c68e140c6550adde5acd18c62fe2d52b9675d87bce652a5218651b0cd0968edeae8c69dfee03a75d4ad34f3c32087dfa0a5b9d41fc63aa436a86a6e218a19f2df4e1e15d0428e9cd15d93fb42b034e232767e33f32d73e124062fd59844188cfe3f4ed426d51ccd143a579ee385d031dd968aaf7e38726b004c85d55541b2f9b954517a4e3457fa68181b4e4515d6a9c9af998d684f74106b55be95caaa8717e721dc0ecceed8fdc0c14d746c031686af1d7324c2e8189be56419bfd72a3c1bc63c1dd72392398d8200fe1143239261249eb3015ff37b18fe6b47273986551a5500c4a8c50f48ebc23fe0a68bcf928dbe2d483c796622eada7baf33abf4194d29aee6acb6f68801ddba700d7b7db757c97d578873dc03decf01a2d6e620ed8887e9595a309a577d2e02d09baf7a06f2ec886f6690b937b0373d781284cc1c36c2cdca349108b6d3d38beb52088fe4bc44ced0adedd5fd155bb107801e4b3870cd51557041638068094caee5ac57c4f8be6e7040d50f3e8a2d906232271b0a77faa8390ef4525480619e1a0fe25d74813f5be4a4bb0d8a17778d631877b0e2f0e879737374fc728192bbc780f7e865448163c72eba6a5d3ed4feae2684d04936125f66d2c10a002a2a3868bc9dd16784d1372b145c8f1b339561bbb9ca726d3ca1b70a319d92da934f6c099aab105bd30df8e4182ea38e4819b3d35ca2d9703dcec4c087590360297269d1042b7ac33fc4bb2d5fe565054daea30e86e1f14918491b945cf094a3bd7f220bd8f17ff7ef12e301ff8c9d4f165c524a1bdfcde1a0391d86473af309fdff33ddb054b854a88bea6b9c3c3aebee3296c3560f8c7781bb886713663404126321446069e6d4f13a073c85ed36e22a0517c53195126d4d1e29126e0c6f7138325616fa3e7412c4f61862cee8137dd09987ece4421df608a5fdaf3759397f5777e3edc48dbd29ed4bd23cfdd0651d85ccfb0ffe5eb24cfd4e8ed66be0f1e243069f6c6470fa87cb6c6009ebe525536a738274f74b984cebe28f5d9e8c879555859fb0ef90501d390b657d35d319a90c586a10bad28da9aa0c985f717fc4352e5b18d918d6172aa41c6f43fdab3975b601a1728c285f6e6f4e2097b574d58aae8dfc7d42af3e049a657366f363fc46028a2a1ed61b878211344fcb96471f53aaea77abf29e94769d4cb3520c9b17fd9084bd116db6788fedd52cc3c905e92de67df747f858b4f1e74472c601fa493daeee742cccdd027ef5383f8c66ff2980f993a72bfc74416ac2fe504ee2f699ee658ef50b0229403bb58bfb4fccf02afc9b3d47307fc9182d52b13d849c9f675d8557d351ea62082fc75e4222dd90bc041f596ab1a23cd7debbcd5dd23f94a2969645ed7fc856d11f1e1a44440876ce4ef83ae9500bad7602e1ed232f4ba1faf2d3a296c5a7a6da6c9515f3bf6ac331a3f809a549e772a23d55751b2a624b8bd5c43abe35c53e2f7eb4d17a4734244adae82aad38cb75e94b60fe4b6d87de9064690ba6e4e253646deb49b06613cea9ccc11ce36c129eeefbf7129b0d83ee3b4dedb06eee88cb482814d745a72ac982f041205b536e1a527f98bc4f7202a09cf80bfd4153b9361ca7a7b98f9337882546899dc65ff4bbb5ef000e73aedc7721ab3ca74101817ce2e343ad1257e485fff59ac01dfa0cab7c6fcf9e09f3cb1f4cb87a8acc9e8fe28b3c247d0cfe8f9413f5177e2728c88b0b76ebcb7c631f649f8bcfdd490f2df1e02a22c616742adad910ae91c59067a791f673fa0087b24e1be5d1f016f5a8517213689d7c2779cbd824d377c2a862bedd04f919217c59497c09358d2489fb941f4f7d77e97d53e529222d610f17ed44270b2828d9ee84b8e33ca556106cfb4e4badcec3422c2a9310f47f58c68a4ce8b29880115b7a0555bc47a08aa24e282980bc3f77bcd8776643dce2d51e100c13f5f904a8e336592f297f05b24bd6d53f182c186afd16301ebae2617b732fea19f18e9346f24379d6539bfad543511598510f245b7da7c41118aafeeb7286148edcf52a307ea523b070c0d1c90306d098e649bf865a1e20f49268dbf22c5ba69fe56f981ec4982b5ac2e561bb8ed68ef954412bf7bc33a92f5a1466210667d10794c4b0b332d7ebcda982bb2e9a0101867c65814b04410c3a1e98c48561a2067738441d73e39bd40816ba9e87faf30e2dfc642e8bf87e7b531f7295593623b03e4a51b96e205a277de2ff8f7d77cb7101ed9f316752fd92cd582b61ddb73aee912c8bc0a17105e5adb1e048e24cefd6db2bd0ee9401f31d2b644412b3c33bd0c55ed8f0744764aa1f3a5df0306dc7dcaa89f275bd540027833e617c7a1318d3975219cfebe5c2877889fe3b092c5bdcf16feeedb1c9b91bb87e42e511a01343d1512b1f4f16fc8126529145ebe59492fac4ac5011563ffe43e7d34ebd240c4a77e0e0a581c3822e60da96bbbba2007632acdc4f57cf1cdf04f6659e65c60ec34bc29e0e1642199e53bb485e9e5e92ce3dd72202377170131d0437ec9b968bfe77dedf2bb6bf27ca49c189e11b9a86c8df6cfa72e5cc549c7d773093ed837967da4da0f237c6182d4cd28197e942d70609ba244d741d71d3f78252eb83704b0e72b12220a6444165678ce51e9f3ba0a04d2f3f0e936044ca0da818654f3f9fe51831a18c4b93cc044683c93e89729a244d553c99c79194dae887a10ae3578f75d99078895823c94120b3b2bebd6a23b1a2be0895f2261d2506b052242b4e702e8d743857653ac6355c71cec61a95d1a80bdd2e14c300b9f215710e7369ae33d22715fb3a101db3ce3a20850be5b538ff158addc07dd94a62394750295b37d4273fe20961d4c949fabcbc88743ededf9e6674afb79c908055f30b911b56587da9d4b2ce9fae26abd39621b4b65f5cba3e0c6d3c0444b9769941ebcf0b8fb63a214b60c4831a5156b111ab13f26d97508e5e3eec81f79ac9a0d924636caa605b5fb73262ee3d21ad13c860b93ee1ba91e4292ac07056663da8acc36137f2e2b3d43ee65638dea69fd926c04c5334c35986a9cef2c0182c532cc62662d3e66b789920f05becdda6734b2a6ef093510ce30c989c4071393ac281f5bb21f6aeca21ecfd7456f1e4222879f1a4a190ae8c0ff19c68dc124e0ad8f96495a43e53123eec7f2d35a47616942cb0bd41839f2723788b5c772a272f715b958c4bfcc1b68d6dd43a23f1ead612aff90ccd2e3c29a3f5ae7100cd40dff34f11511dc887fbd95764cb1e5979a3615aff75e47074160894314a1416bb25259d2911289791763c1c9b7e5a5c9d0b0a471532393713c3f221638d0965f963e1d59b70f4446e8d71671afc431532e5c16349aff64a52cb17d93783e7174465e2a7bdf2da691228b93a21c7ceb7e7e96375d2a86da73daf883a750ab15eb97738d37e8451f3524ea35bb633a4519e677e9e7a3613c20298e3cfa3e465492f72438c2fd247ab8e42d1d05eb54bebc95322f1cb8fe23623503e02353798daa4898fb7ae134bff684b36c47ccff4845def678332bdc361ea273f4053c2cdd9b93816e12a83ea594118b15bb94c4a0b14bd800629dd10300841dbc5ab084cc08bc8447b692a848ce6b28ffacf720cf2f31d1c5e6c6e95e9671cbe056887dd92cf1b5b24348611acb4d4e5465488cb75e107f0c19a8449927dd622402f02dc2e9d0f9380241494825fbf27e8f192316ae69cfaeb68203f89b0af89ab052e2550c06e59a97571df952c7c59fdee4c3bffba3c2e34af6462e2a61403283c49c36f5548ef4be68b6ff6ff06b4ae35df2661a00407903045c76e97c0c554f135de168214e391e39d0ce7c8569921066e97b4f57b340b6ae301a1f4038ee0896a45e4dd8ffc1e57b6cefe7dd1281faf46c227dabef36afba550f15d641c6fe9ea59a327d9f6f6425de043e117b146a9a0021c33f24e26b7c21a93a25aa9fd56580af7b42a033baafafa511343b1f9f1160b71d686ea72b0d68685f6a0f4f5c2e6065ce2623c5ea9c7eb09a59a1ee4a725bdc9347fcddfce8ac7b1e49a634d881c884f37c8dc6b7faa8ccf81cbb083f753fd035d8c9ae5d7fb7eb4a27b9f0420e6cb2854d30d813415f2ce7516d1bde82c9892b96a3472e76bde66c19c56359f638309d58ff8ca560616083dc7eb3229bd9b5df1f32217bcf13035727ac26ff3b1044866fba2b6a85c00fcf5dccca7e552c080a5d36c1055652c77ac15bade317132e76d888c9ea3617ec1dddaf56c4bf08e48f77075529be8bc5ca8298b9f0e45667d4727c50daa18d29edd323802d8f10dfcd771abe57f6311bb0a6f40b324b6068c1a305235c1879030b655b1e887d4c5f4fcb7a7f03ee7b87c75e3f9a36e64d2aebd8e92096cdaa6c6a748f3d678d5856072ef4a102229af836bd6678a217f662a39fd506c746871ecddb8647ce84d142ee14b7f79ec9fc47754cbee7eaf608009eb011f391fe1fa80161db34f4f465a2f1ebd2aeb0154a71dbc9004a2b5bc63c36ce25b151d1c41a388c8b10abc3d9dce627c046552518b50b971899a8a2a58a424ad62a2e65c15d29a89d4ebb09d58ce2c36d6ea3c5a8ac3a8cb085a404f3558a3673c80a75873d799c564fb6ebf1552750385944f1e18ebafdffceeb1f9146ae64dd43e1b6f8288fcab207d1f262cd0f6deb8e7a95f6f26838473f99c7439133012e57b3300da5107e1a66278c2ca48830ecdf0f4437c5b3f1ad1a85b93f8d9afc86aada34fb91360146fb752bf414ed197c73527f4d8095c29e89cb63dd28f8b5d9b8ae96a6c1f42ca398b7a139a576870dfb564038bdb8fb1c2da0bf0e4357530e9a1e68e132ff8f94f78c9a046d32f66b2cc6a324146c9a0f59b8d1fba8e0161ad73a2a9afda8adc3130efb9fda5c6871a99aad01a50e595e29fb5608adde155b100927655d1c9bc4f1db927b8682f78c0d2a4063097550578d8e877aad52431594dd8a8fdeb39a5c7db0031ae9aa77e82b650e6d8e5d31520787ade1bc96bda87bf9e0aa9f772f90b2768647d4924fcf52d03ca30df6ebb4ecb6a10d7b05f3be95bc138dcc6ebac42ac97dae91e94ae442e73364a2915329a0492e94449581d12b784ef22364eb801f7f5d441fdce8460e5b0943619d051483d979b9c37478d82d5bb01adb0de2ede7e29a8aae2747bc6304f8eee7862b0826b3774abb2a6757a3492bfbec5a5e7f9062ee7a69b23fe139ff89260834724f39896061796bcd66ad2ee13bdb20a40f98ff3d3656a26abe66432c8bfe7bf0d4aa9b545d5b73393d89d1b53b9e978a95cc54254fd0407bee4a9cf6a6ff656a93c124785e3546c9985e069a4d57d25ccce4c4cececf86a1abb5c3032e24e46b55aaa292d6332e16a56673725ac8813f1fad44cfb483a792b7997fcfb0e13234bf64464b71dadfeb6341b2137ebbe46177ba18b5427258b971d8461c4a7ee96145801c8c2b36aabca6ef7a1f40d10347169b53e80066e4c421b9a2f104934e16c246671433897a6853555717cab9b32f399f06e972181c1e001847e947ab365dc3c23d2335321e1dd5ba63235a691b49706bddf4a73bdd1b64b4e38cf795790ef7defde9b184b087606d24cf15f79c7b0a45a382ded8df307c513a35e14fca09b7bd3d378d6c9aebb9350cca6f7598340ce82d6771abd5e884e1870aaed62bc70056fb53ada0b3c63c193faacfbd5d3075e9a1bfb13dd52f1606fb1fd5982b184dfda8043929428bb83489094e736d3850b2ae6d5f33fef5a4cded3e36c2e437e3179e250d2c008ae7a0c3e921340aa7a04c4f61cd9251197dabae903215900f214cd16caa21052c7e8fc9d1656bd0822007c0340e9b6ffc3d2eb09b8f4de4da576df8cc26289a87eda30c7273173cffd9108fae69345c9d721239f7be92e1cd1d2ab49a436a90770532e8980e849014c34e5cc9119164a6d37776c3a668bd19157bf8c30798a3ccf90c1bccd04ed417abe7dfba46738ac4c6bfd3535dee69c40f09f818a3a4e17ddb6203172a0a838d533d41303966a17006a427160dc8cbf38854cc36f8e86ac48f4482e9b5d59d3205428e24e3624c72b4fb86d7ca0342d0d44a656b5324eeb8a88eda249db63b128a54bc9de03dfccccaf481381a381c875ee097cc07bcabfd21bca11c8e3d534af93ce3f8fac70735a0b804979a03c97f81f9a9ceb4af92bcb27425756f475bbbbf51e7b80041747e23d4da8afc31bf89717d20d20d3fe3fce6b50c8849e6ed77fbbd0640497e15638b28b398be76dc5e7caeb79bbece1df02e5b1f78b256ac9fcbd36771d69bb2a27f9ad4d88063b3bcb3f3b952cff6fe3a63b75485a5fc276af2c7722285d8ebddd85efb0afdf88f498d7d26e6c1a49c0e1925354f628a04a013931ead9d5a648f15783392a86d742e38fa97a0fa977f7d36cd29c6638a604f2ca0c9d47527e15357f8432beb6219fe06154d69cb6dfab54a16cb38558c42d9ac5ba72b82ec3d51887239beb52a1a88cafaa389a0fb826b738effcd461ea8d968c7b44c8f8a8892974585c0911","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
