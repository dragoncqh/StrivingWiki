<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b43304efce2035dd794d0161094d369eef07e0daffbae05f809723ba3989cb6f61782b595597c31096a796ce36fb53bdcdca0f7bc85a9e0dda1090f99de091764f2c32a91e9770f8c24b6bfc51f1485c25ddf22078900fb78925b399d4f1bf80919542427771431367b91ed1b9a56339aea15bbd06fc6ee40f99679947b76feb82e9c05c46e835fb13a9f8914d425d225622bd95934dc33381bd84d5bd97de192e76a18cfcf530746357b189f3c8f4455abf586e9067bfd497de06050537d72d9b37f70a1ded7ffa8640e810a35bc4c345c6ffa218ff43898da895e679cb78d36df9c1929964bfa80594884336f7a5106dc2f0dcbe7768d49f85d203f9c5092d24e074b387a9d4420351dbd93f740bcb0500f87a3aa21328808faf24754506ab6f899e6dca5b4e272711ed58e26227c92fdd49e2ed747d60fc164fc1b5258de9a1e1666d7382251d00fd8c4e9d85f08c00952f91746734a2b54619d219fffe4f202df18621fdd4ed0c03b2af6c4e86fa87d4d48ffceb795c4bf0e30e6d6a86a75241e6aafb04b583b15fa0584843681724cde1366541c05b6bf0fe9d53d9f1c0cabd9f612128741aee4029635fb94620cf80696a837b6c3122189ebdac39e2c9264d0bff4c74d004a77f34b9ec7be31e5ce8cfb504e24454bb64303975743e0807aa3f0308b1984b8de58efd87097f181a48939631889eae070577513208fbfecf256930b97b7f5e5ea360de20a5841f99d8584de1c03af71c9d3ee0c5172d6d6d64005021f0cd93cb944385975c00aaac5aae339bc2dfce8b99c9ab33ae58bb0dad4bbccd1a7b9cbfbfdd21a443923d93442bf77abccd36eaae5d0a57c352d0feb91a23edd51858aed966519852ab7f8fb4183d92c70b0be6b336de4f8b6d6e161118af1a1bf14990a8b31b9a08f5f28701bf23a7a6c0823fb1ed27951755c42748571a4dec6ebd7f8fb671e3ac9d0417ea24be2ab6be8ca8b54554cdd82d05f50483b663d41090af79f42f90681b93652bd842aa6b46be544b0a3b7e32023ac23635ff8cd3bca16e2efe6b55d179ef383808b2073468a9a2a8761461fe826e69070cae1be6a7ef1802efa954c6c8cbbb086831a373dce277716fa2d04d59b46537a9fc802c27be56538f34cabca728dc02f77af829b0756d633b1d18011b4567cbaffb26bf298a6ff4ea201358a1dc972bf15153e6bb697b003cc3f78f489b6dd32b3c5bb4ea1d6768e59bcf3d6760affe6206432880d37d19a539120beaa57ee9afc09c947a57bc783645a5c21a6693f7c3d69633914cdfab723e7144cd5c84fcbe715909115465842c87d62afcb2c2f2fd412e3227c1a02b987ecf9e32eb8348295cba9c3b174c02bdc7a49af8b6546292adc45921014a901a9280871bc9fb5a5ada7d746e31647ddb9d590f2c7827a636d93b871777484324e18b3ee018008e3e0778faad24df07d3066c444b3f46207f08570d1048ca23e63e02a987b5bbad332383953b4ce7a669f6fda00a4673ab5620f13a6d575ac6f99c57d79cbf233e5e47be0f00c1f4d766006d6182e0294d387c74029b0d38b0121091690b459782f530476f0dd0cc92b0eec555fcf8eab3c56b458cfb3180d6505d6b349dd1c0ebd5de0ea3dec8c647ea58fd9e2817749a888070909c7af9a58cd52ce0a44bf4ef3c17e5ba46e8a79f7a2dbf6bcc024c1a6f76a2c2ee1aa5aa188d16f2436407f8e60aaece5b8f48b7001f71b7600adf72106306ccce39175bfdbd697be87b63d6566fce54e174f9238c16f92dbc581766175eff6732ecbac61d0c97dfd487b9b0f296d23cf05bf9b46647912c2e6767eb3e44cc75aced6c3143a230d86fc1df2ecb8b24b3676d6cd8ac3615c04946c70437c0253ffdc29471585477029c051f56784ff6d29efd7381af1f9a4ab0a2e7b3ae9631d1ad05036d803aaf878130ee635cb63b40c74acd959b61ef71b6085b1c8fecb7a83675e3f82fb5e67ddc1605b4831aad0392ccfe1879d0c913ed484703552a2e54b5fa70b6b6c8a985d00485518ef36607f2a3adc7df5ec16213ffd3f3ffe2492f418913c65823bf36606b28459503dd314f00b2738c4cc270f6f560530fc13717b98a03730413a1b80ad09f98c1d4174bb8e006d447e7b4cb143ba408eee73ed56698526742bf37b024ec71945400b09ad354b7b73006207fca00c8dc31099e0f30e239efcd0568e43065f46bcd718de48ecc6546da07d039605e3664bee28d75c0af1dd9fff1171938235be4830b410a7fb3a0a828de150b7caa6859e2257107690e63e6c8d75355b1019ff109f29d8e490db577a047f8e0f471e67b4bfafd11a6d9223b2a3e713fa63aff7cb64e35a90d02f5582b58c087fc454c36c10d66753b223c276f11815c7b00b31501aaca7982c6dc11a6e86ae5d6342ab38560573eed12410ca30e8126f10b9d4ba51d0cbbf596725b7efcfe87f6eacb074e9f4916ccfe932106cc7866ba95f0611fc6eb9f0f4d31cbe7d9521920d3d8a08fcb9bc9c984f21db11ff33c02d1f1b081848e8bfd2cdece72cb52e4f42498bcde7e3db3d07460fd116ae2e79c0513f141158561e00171ca97f4b7854d9bf6b6c8c809eb17cc8fd2a5294e9f9e54656a283b496f8ecc5bf3a75685050432127927255a28424a92950c45107e845957af3df8e343eb8b05b2b18592fd408b4e67360224f95ce51d1c223273a422736b8e70405a049e0d3f180fa71579e943322d6b46215184705a1949764da39a66feba3a391c1cc0afdc8e2901c5e1671b44622e08c82b05376418dcc879ed3e31fdf19bc66b6f463db5f7231d643d686c78781a1fa413e6af99422cc153f47ee0ff3ee517684a139212f3dfb555e85d6f39ffe13e29fdabb18634d404a09a10e00f0bc57f7d50b08cfa6b4b16ad06839819e71a581d200e4e9d0059c68227eba1c0ab265b017af910bc7348806206a25b90047a9ce8a0d678d8d995b3feba6950e4e682c0bd3effe5d65436066e5ffcd0a2c0dd40c8eb53aaaf38347558150fc78695423ac4d32bb1ab136cdcbd917056066c737a4e450f2dffb905f6b70526e63e49220772194e214c38d432f17203c5881c92e41b25fa812bdff653efb79258b953c95c688af909d5b2939072e0a932c8c03466701c97c370787d897a360ec253077014fe94783241852a136dd355ee9f8b797c83a8893aad477675c5dedb9292376394aa2ec8b31a77b1dad8286f873e5ca248b688dbc32c5e3d32aec5ec8e363c517ad0b6da87b7924eff448aec64c3adbbcb84b2b5d54c2d3e67aa525f8bd1021e21a77c3227926703effc022736472b28e171b23797526a9968d0120597a929b6abe4de67cf168feb7809db899ac71ed5db7a8790e434301a9f1b7334a1504e5c805e5887cb5d0877d9494ff767f60bfee45e91e2e7ce5762546ec928d6254c9a182310c1d02b45ede480926c0b8d1d92d896f0c9ae80bd4a5ca330e9ec0b86e04f51ba3329f9de4bc0d9163d7c5aee5a2fdecff95337599c95b7a97f2831fb70a8c56e5e80d980a479536ecc3fff3e392d44fd13832ba56245d73dfe3ee2876bb6f81cfd595fa8562049199ab8829dd7e5fd99e28a0a5f2a9237ffda533ae2541c7768aae9df28def700eea24ddf62c1f05425753636dbc6be569f244768fd19e1c936d377e61d4c01f0ae59fd18f5d8b246951ba1693c6ea805069a5e791ed005aa63ae9613ea61c35718b6ada45794e925259b47ea8aab91f38b4107775e2291b6ca8be05c21374c5b5b1f59b301026f2840037139198d102e88e8dd2a925cef94db00783e4333c3161e50fb53b49d315aa07f4ebfabf9e880d11ce697917a2dda1c9dbae91258723ae39d5dfe46de43113f1f829b48a0872cb35e0bc289d0b84ba35950cd5f75345044d66e8faf7cd36dbaaa74d73a0f3a49645ee16c84765be84eb491dc592f745666a698b52e96317e2a533f9661a74734d766082d9b89908ec7d6e3cfb46b0ac6f1a614862c1f130f432078da820e14a08a99e8d5a373c9ddf2b04cbf02b23751251c169818160e6e8f03ff973ed3182a8846273ee1657407e7f19f4bbb643f90c304eab2e589ca074346c4d9d58b3fabdab74894d9c6223b1354f87b48f2008bceca767e539b1b1492ea227858c2b14a998f389203c1bbbe16c5d9f9958de3368fa98efed84c58819377cd06ee2d908e957d3175da14613a57dfe218d1ddff29ed1bbecfc8bc26de08e174133211a13f631eac28aff39f9a8871c89f5f3b4e4cac1e68643adb35b61cec1fa799c051f72bae06ba84677e22e4e89e6014f6189d77cfb466cc08e82875cfa50abd3f5b5af98f2cfdc2a9a1255311b5f417be2c5a04a352e4356dd5ed4af63dbebf1472d223391d9e085460b27c5fb32d15fdbc3ace33d411333b7739aab320a499aedeaa7da9c432b7b9dc0eddfd99425a98c627bf867eb74c2fb6f9e8bfb968c713ea897791e4ca55aa2b414420ad4ac9653ed2c159191be1858a7f2f28ef06e44352f557d3d788cec614b9434638866477c47b09b65cf56862ecb00c997ee52ec0b93b8b2fb3d1e084b7c80d9bd4ef5fd7b5709aaab28d2aeec051d28ff11ed35f5ec9aafba2da157f3287f647ad0ff100bc6b791857ec6834497bb75be22da811c0d78b3b47efceb266f4713a973e8c6fe9fa57429ec5eb607a0f0a97f20248be4b3269ff9290377c9ddbc0207d8324b5352e5f9dd62583422c10f1c116aac4f6dc94c8e7ee95b60f526522108b846b60594a0fb003c03a27fcad544bcc9d4904ba0b553d7be1304ae1a5ef61c788bedb7820d4a4cdd308915312220fa46c070df37c84d5c491db541dffcd30bac3ef65ae2dcd8c284434792d0b0434791999ecd636be60f1272a2a46f12a55de2d6cc804df92f0ee02bd9b14a924f02a335e622d3a541eec1daf689ce0d9d5a2a111a0124b40aa81225eb9ad4905d87eebefa1700ca76318a029c08322dbe7df3510e7c10787f02412435193946cff4de8c3a1922fb391440ef7bf73c47687d8d77ce6b4878e88a5804edcca12126404929bffb443b6608d1a8c0b39b63ebdd9e71d2621fca5ad88f2d748b1efe52db3ac93ffc643e416c5dd338ee26208ef8cbb7dbbc2f57ed27c7f3faec24c3edbbebd599d27bb24d19d3d49ac38a3ebaf6da2bbf4bc595c68438aa342b1860f204d08563603268e464e665f6125195ffd8edfc9377ddebe775d1fa49c93c8335b140710434e70a82d342560e55c76e6dc6b7aecc87ef40469b4113053a13c51297ee11872589a4a62fed0a81ad858458e9d461870e3f04d356ffc39db819d26d3c7e5fe88b749ea366579ff40c067eb56ab28e9ee068c02588cf5bde903b9dada629a9d4596b1f4f65c94ce594e17b950ecfdecc107259c2e22e61dcdeb4e3c6a3d2199b189d1610a83d766bb7593a5c7b309e0212b85c9ca39fc8bee248a944b2f15307705a293034001b67c07766f1cc443d25da702770bc1d8edc2fb6bdf85d982318234c94a5d2189af1fd5e348650c71b2f79c5a9f9c551db50f7c71ce8fbf4e40106db9efe03d117d3df31b80331ccf4064f00bb8d45fb50149ac3879fd3b64107a608b1e953ac0c4b734157097a57310dc21de4b4844d28c056cfec966f9bdbe5e1f36a4c450fad53e7a28b53c32ee070cba415865d5cb9ce5996b726a613ae24a857641d141fa9faa346e947cf1118cee9ebd21f45943269a801c44f432684cfc9241fa3705f6bae16a0c59852ddadc34664f6f51d3b6afc242417f4efccdef052a6b3bb7148c213e4df7b6385028b1c8b8aa6d5ae130c8d537df9b41570faa20d1df599f10adcdbe9064834819bf9a814a7f0f901d79e194c7fc6093efe76eed10a4d752af5c2e96ca18e31081624e3cb202895138edbc1fa65f77a09059f747f020cf47add62aec92290955bb3a5f7239280f70273a963d3dd0280b3b2f38fbf33cc7ae9efc0a9c447946d852b173bf30f2b85e1cc822d37d399266be1cfb1e27820c752bc08244fb4e3d7498828d1ad6962dd15708bc1ea82e8addc6dd69a54322060fa1ffec1c363e1ee463bbd134d08409d7c0d4a598339a98b97cdf7364038e5ca5d0b3a06cdfe8a64d4568f2a626225d6aaa0308f8a322d131d1ae79b7dd26de1c50bbcbd70e8bf6dbdb799f2831758ae69d810b2680ca8fed32e7a191b5a53e4f9b9fc809b3e66b6b6cbcfe4530e47b50811fdffcf62d1c9aca451f67052aa9a4f99418aab561884539dc152650c9193b971692b11ce62a4dc7abe97e14db9ff9b0d342a2d5deb424f4e54b56689333cc645de0b813422d7c1ce713d1fa264ff748d3e2752b377b079f8d50f73a5409d49bca5e53536406d62a87ad727e8a3564a21aca218c328372e9eab0b768b419777d66e6360a1267b34e549cae0f6d42eff9a16368f8b3eeaa4d20799139c4f4f9160fea48a42d7ad4c119acee7a78483af820ce66fa084c5617e5ceb67fc8e909c9e9ec16a8a8633bb0ac9b819cd7241fe0a02a3539f0126927e394ba37035585061f03fa2fff32e3c3d859e3bf60f2d499d189ef64026dfc9bd30a9ad247966fb30206c07a86f81964c47605dcafe140f2e0c798d60517c719ef42a5a1692174300e62c5bd4d92dd4c314ac5d69fd5835e9ad19b2dfe44819ec8341d17e4793cf8cbac2b1edabd22cc6d71f0671c034006f828690e62c02c59bae4304f5039807a0cd38310e7ce7b8e334c0ebcd00c0fccb24b1ba1d186359e539635eb38adafd9a24d9358743f1cc10f935a48da800971536da93f9a21dccf65f5eccbf5a1b479bb494743d1d467c99b752c5a4f10f23c5c521ed2fa9f9822127a59e258139f3105da6a648c7fc96970ccafdfb59762473e0266408275e4beed62c907628977952822ca135f593b0f383947ccc0538715374e369d65d185e47ca2b0cb4b89cbf71a0c3980390767a9d16dd5d59090c5c397b46335182b8870f608e954653f8a57eb2160fbf60718e294ae83722e9ec5ce321c1145b7403d3331a334e89b4572e903775d5d10d74a4f63f4b753222f5abbdb733c95f02da2ce554348c2ec5a83d86a7e72dbfd1af7314c145635a596f9d572cfefa2c7ad9537b71454ceaffc471426bf404f4516d4f2582b2c66c67d1386796acb733d02afc8ffac9e3488b18bab1464ba020e8bb961c927f219b1d4406aa3a070af7ec54579087f5968a64de4a8cbf46c87fa882b3a56939ddf2793ded0fbb29464f6d70d335288e38b13bb025d3ed9c49bfe9f91823e6d13ad42fbfcfbc499c54e7fb826b0bd5454f73cb91b38dd69cfd8a09080dc025882f69a41f07b7d2f7a40c7b755770237fb5e1bceb0ddcd3c642664464fc7f27dcd7b95f9c11cc97b88aeac9532aacc7caf79d70e33152527579588a8a2c48f6f4f26b5a84a91d7dd6dfa6c9a0af8e861507100dbc7c24d4a959893243bb3a76ffa3e2ca6e30a8b53c9d0e5573e96be460fdc9a9477b2bad71a974d2fcc8cc923f48ded7941f4abd9ff12bc28886ed6318a588b76c89db70ff7dd6b0f9697463ca1cc57ddad80e7a8b0135c688a6d71c9bd2a2cdacce17374939a795e772505bef777151ff17351323f29d7744bb50129e32a3814dc4bd1399d9d19203a47a9c02b64d5c8395a12691979cc7b4b05099b4390504a1b88bf6d7a3051dbc287f3c2d08031a1beee3b72d95bbdefa80ab87746f0012e562575565c46bb04180f2537c18fa9ac6f2cb44550c7de025988899258a5c38f1b934774163999d20302af40161232a9c944fc7052ee9d1fceaa74cd98c7a43ff96cafefaf07fdf648ffec39c144af6e0f39f9429f357e5d21d14f905c129980e46d9fef59bcb7be40b60fa3c358ffa8015245ae70dfb7eb9b678e175b90143ef76d4f3e4bc488390cd92d413f22e8aed2eac0d523153c109bc8be045ed3ba171487844f011affcf11296a0ff25feb56a10f67d63d61254c706e45f7851b5843761fbe649e14d1a2c69f68e9afa2759bcb7b6166dfb0ead5a52683e5916c2de48fa92d4685689122af4c7b34b16f5e16367b4a0c9f5cf2c698904e754809008725e3a7fb1cd0350a76607d29446cf603d61cecd4b8c9b8458b08769be43d1764d24d60ea9ef0444d956cebd03ca2e64b2a8ecaa592fdde8b2c761ea6973ff56e02539f405b8e942166efe53ddea975dc31766fa5933dc49448370dfe7a14ba982b7c217ee96e3da0d9cb88bc325e4a99839d3e97970b9bc44a34246068e2e4f36a3927ff5781eeb570f0554f4603737db280578b7156b31e629794581e5556de7bee3213df79558801576ef74d07205e52475927bde40a1d31812befd95d10ae34199557774fb293144a98e4a7587d2ea38119727df2adc1c8b107c1f6c91f0f46fce09b386fd90a41bcaa1a7c1f556f91e979512ff3e6c5eba2daef629d6158b30b8fd9ca904ca65ba235668c43422e08e2c52ea072e1cd549d8b0cffac2e9ca1a9458cbbc3b16414c24afb82d4687ee3e78b5b67a5d1d9855f49fcad3176e12f5a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
