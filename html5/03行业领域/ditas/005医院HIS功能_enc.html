<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"988abd8e257d78cf163e8b09c87c7915f903835b790d596629cfd6ce1a189688658764c392d3ad3ac88ceaffbfefd1180be88e9552cedcf7a69d90058debd7b1d4033ee7c736e09d4dc727b49fa0359944088915d8cdbd7f020e0711487bc4df2315564af8001ad1c324fc889ac2b533c3f2f4f981efcdd50abde0f633f6ece7a1541c6caf91b2b84e2e52eeff516e453132df88b5e0fc68926e5728c41b8657ac0105b6eef60b44fa706b7b1f8e47c26e9c990cd467a91b0890fda628415d6e20c5ab9fb95feec7edb02c67cb87b8a0082139ff25c39916a4e67ace33f14cf75fd2744032fd9e5794ad1aeb1a7e2acce44c912d319f196fe54297c86ec85a3752f6b69c0c33ac7b17814c1d768a526156ab0bf1f3c253294d8c43473d0a17563a2a835b863ae1564dd57f82828642b6ceb5ae70ffe737071b84d10d043888ac4a306ff49ade7ec11d2f57eea4f1ac3bc0b9dce7dcf57d9a8b26b947dad43c583c687581e892b7e9fd5266651e0b8c3299accde0351d3180e6004465ef084b03ea57c8ee94874bfb6b2ae60e5dc1723c1fca5210943c7539d46f3b955926833c409adec5c2976e554886a3060d26dfe1a05532cdae28ba3fcc1a5e6350dcf794ed305b07b163f3ec4142517f050dabb4c2dbc19c9a86dc068f7ea1bdbbea78e983086df8e87b47f5ecf826e2c1839ca30f42939e5d67e4b420f7d10c309ceef011c35d7a456b79cd8f94a6b6a5c5ea8f69cc4bb902ca7be578b37c796410844e4f7f96711308191ad2e7f9f918ae23b3082459452f7795ccda44679c5db79a0cfe4cb7c72619bec3b380fd862e0805536e6993551c3ae173c75bd787d2326786a435e5ff438ef9c0a66141d2f8348fc5eb86c7cbc92d830f5b9287147dadc1a68cda0de4f299c30bb5cd9785463ec53e3cc66bda5d4764ec2e69e24132485b38c9dfe7d66a8ed3eea0ce30177b0785699478db3b8e1db0c0fced7789102de73de6448fa7d8d3b1b4857ea0d751e047cb32ffdb5595163883f3b8d8b6b464c95db27f02451453f37938d6235921d331cb03190f1cb5c0e5151f1866762bb44f5952f71103b48d6b270d505c72b912624b589dd115ff40c171cfe5f4ffac19a21196bd96d0cbc8faaf562c7ad548760df5f332cf7ca7d186f48f335f0ea28d1d940c77df2a2d9ca1b31056b488329599856fdde6922d256e5bbd2d169b1acb0f01f4c6b35e91d2680f9789be91a08723915d1fd4dc7057ecc50e3bfb483febae3aea95e176ffa0aff23f3b0a7375258bf8016d99e0b96b0ed7b305aed4018272d2fc78d06cfda5b8c93a65339d243dc53fb4f24d6d092555fb3d26303be2237289647e13cbca459f6d75d4926dea90efcfc1ec368bb8b9268b87eadf182766ff74b5d69623537495101205699cb9a158cdbe531329526c4398b518ef33697ff012f0461c19408765f8570743d7baa702a01a6cafb8be24bfb7893647e205bae0d97dd27577afd006304a1e7240b7d9186a42d19414248846fdca04db2ff5b909632873ff8f526eadc455fe732cd8b8683c942c42f92d95e5345a25ed406222839f3f4b30b90d76c816f36446596c8d303d132628a76bc0ba5412353dd7f8e11f495a199ad926215cb2ddc9ad0ce1eeb83c80a200557b1c9598c79a74cba4b608fa0ee2b612356bc7b3e0af6039c0c3c5132185c808a0cf00aa0a3674e4c4cf5031295b1bc799d71e4526cf32263897b401e1eadfee43411e6896bb33af51ac1f04926ffbe7802b8615905525f12bb8e8f1be6359980d8eb509400223f8841e903a5b5169544d9f3919fb46465b599d192ed3045dcf1d3af9e9d400837cedccd39b044fb310b3d5ae9f1c6c10ecd7d86c568e5896a843a762f037de8781115eaefbaaf399a0793fa93eca64c0253a283ff6e2d362f1f3487092bd4374f616b26946e41dd94b0fa631560b7475446721f43aedf53f8526712d22987096a704e2a065128ad9db8a868f1402fc402db6339821fae4714dd2a302bed650024324339d223e78b6bc711e595629e868e0d65ff6a5f7c86a3710175d8059eb41a62dbe95225b9f5e869392830124a1d198b189a4df17e3d15823f099d4c52bc286640e1a8dd92f20bd6f7e747f8858d5e25e9d2d570bfaf4df3efc84da2bc5b7a23d81039d910b983c74e6384e921209377864f0c4f4554663bf6d775b662d1ef53ef12ef26371c4a6246824964fb3857a41cbd086d91b11d1d330e2e0773bb0f4a636a32f16482500497b9711337aaad94b1f40337cabede42403d5501c0b7c81f1ad14f583b354a2dc4caa33a248ef8fdc279abb43956c58e79cd064bf801eab361a52003aae1a7aab18ba7213e8fdf8f31a3446157cb20d54ad373d7142417c0f253c4662fe7c032b0e7d04031ae96f6452dac4b882d237717817e7b4c1519da980a6fe02a33d2d11ae5f2bdfb4f8c9012a9bc8ebde59d6492359204fdce7f28c476de26e79fbbdabe16bbb6a2a1707342633d232329f0083a6f076c18eeb15a7700f9d457ab675afa9bbc8f34e91eb6040b5fa45e1a2f6445dd4eda1f954d74e345ffd35662bb804b59e6e26794c8364c66fed9329c8eef55c93350d5c9de8dbda809822dd12e6134d351cf04a55aa8ed9428849d3cdf376bc9cf6125d8f6b575a2e4cd335120b07810b614a5dc21d740ec387a7432f2a184992747a68029fedfaa46eb0a6e29a9d1c38c334ac90baa7797315c0cb803ac635478a318ecdf50f690db807f4e96a1a8ef8518604faf5dad9e640d86a764991303313371c9f36d99da37d32827ef14ded2efad2b610d0156a2ea5f30e0868b58498c214a23c47a21581a20937abc03168989d6c57eb9db3e19acbe8b5b9d66160cf0972639da9b0ab725a6ea88765b1ca173b9b25d56aba5ba83614cf03f0bca9f5e66cf5e2713e670e6d146b94e00550c15ca974bf18e8c56f3e49518df4c5409fc696b22e865937481c4ec869706fd8b4fa71f36443f7ca65cf33690dc687dde8ad6eef0d4f01940dc83fa55fad8dd879e912364c9d9de1aeef71e2ad4b43091a6767e9ef9b54404ff41db7f9f242a29b42cedacfd3d5729267f589a7b69cfa47b5bf1f9a948b8fbdc8cd8f055bc3e82e6efd5ec5df73654a06d74433d00ff54a70fc62bfa385a84015323ea06a46e4273b6a978ac0ff7138132109928dd1bac07a3376efbbc81c9a886787af15f6526d0085cf1914315e944f48f13f1358fe929675f65f388a216a16010cd0258bbf32a13e96c28591776f06c5efb3a84f4aea6a65ab3fced364ef63a17f9c5928d1572fb859cfd061b1dba4b92897bbc6dd658d6ef9cbfb9c54e010a5d1158a9519eb71a6f77236fb71719a7d763214142b5b0710b1a502df60aa3c9be4eeae906d7ac3f1f3a3115f306ae8de6fbd32a3183f50b1ffefc6caf9c9c478176bc85fdf0a7297523323378edf11d0ac853df279f137099b9dcd55d90148ed09b0e3a8ce3d18f4a6ad0ba08443ceca7f96a473ae659abf9bf94b57c1735761ec7598d1d93e6b4bc1b728a5a337e02054bccf04f9fe076d80e6ad7c07f7cc35acfebce97b987cb6e98b507cd7a9479483537e39324ce31de95ce4532cbe00a40206c0d8363f0477e2058c68e586980a4cf2e294527c0dfb54c01fd0562e3618bc227c81a847dc5e9e37dff4a3bf933d6dddd14910c0bf43e411268d6330e941c6537a393b534f34cb24376b437b939e050f0f5f5984ce7ea5ce205fe5799f521c936bc6c2ef53dba2478eb18fbed7db0028d7a75ef8df102d5aea9718de0b8694230c9a5db12692c96fbac5765bcb28f3e1df6ae586080ef67843f45013115d2ab77108efab18d8aed915fb7121fe9c37cc80af682b553e8aee81b7c9ee8beef3fd9be312ef99d42cd367e6a0a18d1643f28723c4bc6b987ffe784298ca3700e5a2d8b0a5eb5a075b4b9be79ed19cb9daa765acc3b426ff80ad064b258ef7936140ee1935b032fd97fb82536f49781f0be9fa7d977e8c450a89dac09c7dc7e4f24c5a34570f91ce6c5d61daca4fcd42edb54bd41b34c91ede1ff3743e40c49a51691dac4a165547ff83a1e4bf6de322cf53757ac9fe5c088583303caa3e7958214fdc3de681736e8f8423fc6f4722b5a124b9dc6b2df8e54bde63c464f5beff44f8bf7bf57c478bb54066b24974a34ffadaf1445f00107b5ba59078138a1026dbfcaa079dfac69a402447e7e4804db7007c3647ee440d8d1129f30813060a01e9af2ee39923757c7ac9cc2d9977fcacfdecbfb9594ba84ee7b8bd2125cb57a6ebd4a20f8e70280a70cf975faa08a7a06f3e9594b0924a7ade7f3a9474be43179c25f59567c27cc67551aadd043b528907b102449d2fb0b4670c8b0a068c5f7d27ad832fa164f878ee0a48a3f8bd84ccb62ccb8af51ac25d29a76dfde30abbb64c495f21c47dc612034a50bfda87e73553c533bc3bd355ac1a2269f9af0891174d83697b56d33bc34d21fb222b1eebdd6ec763c69d5d971ce602c4e8f79e6d62f72f9740cafd540bfcf24d92cea7ebf9a10465501af9cb40e23abba12b45fc0f70d05804e922be73dd7ed8e991b9e26d02296a983a717ccb901ebc8be52df2fd0b12764c19a5d9163f2958c849b6c28584a9c5adc36d6f643a81445269fa7827a4a48f19bf89ae8d83a9271bd231c3204035c8f8c0ad098f53a3e86574b6697add4eeb9530de063b853b5e4e9e9dc0d1d56d8931f42c057e17711aa4ef59340dcf90fc4405a8253ce4c562f8402e7688256de8d66f713d54b9b46b53c76022cd16028bd741882ce7ffae8e7848641d7d2de4a9af565b57bc8ae041075388d40dd097933ac61bbfdece39594e870d22e0e4c30acdcee151025e366ede450d92c31dd1a9e211e2f4f2486a667eb7357fd2394ad9c3805ca1942d037e03145dbfb4ac589c452f9461c3e3c2266c4eda6b3b0103ccc09859559dc5a0f125ab4f2ade76f2a88756a0c29b36c4d8adecc00525b3bf6b33e7b42359bf1bc7e91a4a188c7d1279eca9cc1c9c76851b66da5556e1b888eb8f505657a651cc7b24a304bf6456adb3d6984fd79c59718280671144c9a0aeffafc201e6964031b00594ea6196033bf53703c7c8f097cf474f1fb0b40434c35ced93d7962d5634eb0dd8a8543e7b5142284c009567a0e8a0ef12c9d954393e773d2424b916c9c288fc347cad2e0d348b76cc521874b39d9ed0c2cf80c8bcdce1bdfc5c57c90c66ae0283d515032f295fbf57a02ad1c6d2697c1cb78108976dccf869dce96ddcd666b4cd2c2c5cfa280bfb75a81e6a374f2722c4ae33fcfd98bf2ae2418e59d5112902c41358df52104db5fbd0bbf7d6671f575481f84570cf14cbd7c3d3da4b5d2731a2e62d11523cdce89400cce100f679ecad9407181b29f71fe0d873063ee967f5b31b7724ce5794b0250bdba80cae053613585b105cebe59bba38e3c3bc853a610d20a67cdcd2eaabcf68080f1625a2ac0e470fff4def102b48913fc6ae401b0df4dd7197e7c61a0b963a074308d9129dac39cc45010c3f6ce7eee47d703e107c9c1ca2bf6ccfb8f7f8e8f3cb8678d6c942f69548e1d37945b19d47fc258414d921525aa0125c678a093268a95b5c5c3754fe972c9845ef8fb23df484422a57a713b80221c01cee5c505b81ab89c218db33ae05cc72b13059b01772d45dc390d9b5caa383ef0da9419238d67f5da85340b4849aa79725299fb1f126c3c8e03b3899eb7b331d17d5740237409be51786e1c7e31b7a9df8542ab8bb22f8ac84a303ef2b9c947d53d8a41397e3768f7bd5f37a3e2045a3c322653dd89e9d88604ee1ef606146c2ab50ad1e75b833ffef0d7bf24d02a2e778ab0e8eee8d5eed8a202eb7fa63336a7b5cec5e7347ca557362377d1a832281082382fe235672a16f24fc85e2749684b25fdd318b77c463dd1f87380c83df52735c82c50e56d5a47a3bb75e0c3ec2925f7f264bf5b8a9122dedfcf59a7d5ee43c109de388c71f132953b6aff3651f31d26c083d33d4f7b3eaa2658a8124df063eb01af28fc8909cad269ab47937f9ae61c190fa2c56e61abbcf6ee03b9e7e05b171856802c7b1fcf5da7b1475848f88f9775a2de8f34ed2f48e6f0984788192daba23cf01178e8df236d99ffab3b2b95ccd604292eae74f9478561932ae728f425f4f44aa792856e77061cfa63082bfef9803c9a6313f2520022f121eca90bbfe96c3fee24a1e0950a7a7df69bc888752685550f810cfea6fc6e5e3aa50a8a8e9dea0a413599276c420fcc7a832f6f348bf3870f855fbb82a0270aeeac1306c4181b35466762d948d10983901336a8996f0c3c56f00d4b441f8faea4bd3b27941b2d57c8fb82d1f76dc6f6f5b4fcc68336632fe320cdf3fc20bc1a7f312a270f006949efc5a8b2aff985146b1724eb0ab827336dc67df8b1fea020eff12a5490e83844048dd93f1834bc53b58f788e3248ab51ccc7b477f41faf5aecfe26777c0200e513030ef354c5d6ba1600c54a6baf2bd971654ae08bad9596b55f5554121df89c74dd82f8447eab1c5080d0cd069f728bc2cbc8a56160860a14fa54c897d11dc0bb910feee245d18a576e678e0801c324109b3a6ef4f32c0c0d0f70c47911eee325fae3713893ded0965795b68aed7317dc5e5c9b467c7bf5c49125344a0cc7afc66963e3b44cc510a70251c1963ae535115f0f1aeb453a577a5fe0c6a8f0bbca9744fd722ba48ef354cafca9cdd45b8fd8f0d1f77dbd1359b4f2d3ce0f65e28c3f253db4c356e3157753dbedbbea17c1cd9dd3d452403b8f73c5a07b9e95bf307cd507a739681002dbe839fc410390507868c10bd5b968105daaeb78229ca44263248a2302c026f1ba9d7a3c2b17c4fc467855c6fa75ca92549b4b8187848afd189412233af69c219d8ae8d22ec6cb9bda5fa15c5de1fdcf8b66a9e4c7eebf9d9726b8eba42536fe85e68234f0b2682c1df305f923beb93e629a130ba3fdff902564eb03cdf4383468d07c98bfccf14d244159ecd18cb0b60cf88680047f09197c14ccb9ceb08078f901d29210f6045418b6afd1bf478907175d8c81c88a5d0f77c9963f0ba5b3df7a57fc74fcb162a9b84f11f5e1511794ca7e6ed3adaf19aa17c0a7adf6b010f396c3ae049f875490e77e24694aedac59bd5099805765f10817089ece02351ec1660ae592ecf031d3086ea5ba788b23ebc02dda9ae25a3a72d3d69b81b8318fa9783b2e70402951d87141f2a1236d4521b2c88fbe52e733322c47417d3562bb3acb8a9f3523a9758c8806c3967993d466a7228e5f9480545b22c67b99fc035259393e45559093ce7ce785dd2bae06d8b7349f65a5791a69ebc96d034959c6d8df0637ed935502840585e8c2330900dc076ec21b1f09fc97f32a06ae57811382516ae927e80ebffd966118e2b2710aa860c3a53918b18e68994951753d9b950351a355fec74a8f8db5430554ed3157ab6936c849e5013804cf404333da26b60664fbf400668e8d04270f41381ac65e0a4cbf415fcbcee088bcba0b1057b074317605ad1969963c223de37acbfdf8f07581a7ae93bb2f04a04ed0b035daf4db02f2988f1531a22a5e90fe77e5efa42ff76191d9ab5925dc2b443c40b9bde721b6a2478a4e795f90f62908e1efb277dd40c8b5ce55a48f65bab0dba71675b3bcb81598fb16d8aba333246b4b907d1ddbe487c408deb6f05fe13aaefa2c9347db917ded56b4258ac88d66b0e078ea564d2b293342565e2ae1bb5475333b7062a14eea4400b188a2491a97597fdb82fa97c0b20cfa92fc53349b0cac3837e06cd4af285d85f285c05f2a104f2b834deb8dd1f1c292d99bd3932bd210c341ef420c090ecbafd7cfa583f204ddf0c81e51d054c56a54c7376b2a5f22efead1cccaf6db6423dd51ec49724ac6df16b39c6f6db972a45a8af1b45443be91d3568e49d6f1b605e53418ef35f0478aebb248b600bc004ea1701ce40fe0d6fe247625bd4d33f528f4766ea2c84182421334efb85f42d01990e6757a0ecb55b7bd5163302a31e9c5a378a589a4e6bb9773b6e4128fac76dcdd5ea74a6e3f08ed2cf341a6627cfdb827bd162c30102f0286bfdc189874361933f6ab59875e955881b0d108872779364db523fa070afa561494abc95474f8227e406c511c3dd344d48e95f42dfde350f2a3796513cb6f386d52ce5a18835c7f536b73b7384af853b36f2d754c6549e4017c72a7cb26944c2dcf872a7e62d4e27defc5bc452a522f56dbb6ae24b3227c60ca49347b421ef2cb8e1515c61e30f1a4ad9222d3d5dd185e6304ad9beb7d35c07715e2553b36829f29bc73fad75ef1f658e9263e26bc8ab3015962ab1acde3013ee8e9d2d88cc16910c0d165b5b05d76c0ef57c385ebb85018fe50634077ce2ea284e84067643f6d10364909f46e6f039d4aab757d424b14ef86c7dda2c085a0a8d19839a59685de7e7dade175b86f8319bcf25743b9fa53ed1ce716c904bc317246b0493a3669cb5d5a8ba835c15866e3fd421ff2f23577ad7390f0d0607c421c4d872cdfb4fd0478a71a86f511aada1ccab2e07aa987d45faee2d49c6286a93af8e3664e065e9b0282a02015b03674e34b193dcf92965428cac7bd29b30104f6f253e2f6fccda88195637c8cfd98ac4a07c365d0061dedb0c5832e5dff531f1406546d9e93f97f0882e3f6926e624f0e104bce4f111b7f6bcb1a0b4ff58cb8adf1ec891a2d09f10735f2202894a0390c4c1af649722dea0f1cd0d4e4a8177adbdf0adb3a92870fe378b92efd8c821f89c3251a861567d56d4156f159a621dc35edb2393fbf3df8f9c8d20b8c1fa40621843f0637df43cbce9918a2c015854e7af87769513b7037db26b689e75c984ce7050ce4777cc9bb61a7af79148482cef2a89b9ed58be272694731af9f5aabf9a5ce072e23ba85f22a8d35061088315a26e25b5a764b26b02be24a7a03a9b2281428d12f509383791bd01a266606651a9994c9470564823cd53576c101e6e598c63216c779a20d44e7f028f064ef8ec9d84f4a6f861a4522fa77bbd4b6d5e525819697ce8ac02733a1357baac0c691edb24fbf5ba2137ebca64a46ea25c1a7302637e83f920d22467694569561c621f02e99430be6694520bc8eaa07db64a55164f4f595612151654b75c637b4026c56b954032f9202757276fa21c26a2ac094a35296211e574b2b025297c66de665b10","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
