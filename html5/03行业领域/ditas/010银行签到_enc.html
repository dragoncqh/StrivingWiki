<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d402684435d78a41d444437b44cb44e1257eed084432709bb383395560af6faa76b28fa6fd413e33ff171f4c743639a2916d8f0dd245333e5a01fba7a5d799b6d354be087bacee2908c841224c82a879486a018ecb3e01501bfd684cfe6fe6e44c8cde6771e11555c8d1e0fa4f0b95312cd10ee99a28c283aeb901e0250643c2281b56d79389a52cee812f8693a46fe971968ac6586e277fe456ffabad0de9ee6c1ce3349c4bdddfb77b437786c5a5184e8c6a0cc270af2dd6161d42553b100e1a163a82968df7bbd6f1eaa33195b71f0bafa1feff9bab7174047c6c3ffaa827ed027d40497a3b120aecc9b4a067533b72c7047d1651f2a9bde22aed30369c111c73b4786eec22de2687f629b3f9f80845ec30399e69ef6fed4e44f81fa25e830109adbcf679326efbe36e7b2a4c40bc60ede5be5602cbde2bddbf3a67ede60dce370efb55cf5f58f81aae33cf1aec1210f948980682b737a50a9aee36285016ec9209755732e4bac93e5dfd895a59a764667f662eb851046e1815197e20e1f1b6bc0e657598f2087a7c979946acca22cd8b98f85b8cbb4ca353f3f30242ac85577cc9c877f83074aa1d2e8899859a584bf2e79b469e2f96b9dfc1ea9c7e3f97a24403ebab725e6d3ce6540cd0597f377ea0edef7122576fa1d1214d37b157fa4bacbeb50457695718169d77c1910d5dc8644277b525109919a8ef295f600fe0a5e4f67810fb8e43875999afcceaada1059ff0b0c6f3acd6cc214bea95581219239ccab366f59fd062adad14b05031ee201173de144f8293180d1faf3060de624cbb3e093564e4d11b291f088b6f1e56a5e1bf440cc5a5321d77ba9d3a6e50ac60126266093ce41873d93ea78e4f7220d1dff55191d2e031c03bc17c5589287502b517c98953fce80b502ca5b0189dcd0031886f58b2af7ee53f12620d49d286c2ab54f1f9a6320fba92883839407c5eb8f266b6cf229afbf620cd7bd789496f809168999d0d72979dac40632b3acc801ea08245a2cf69376678107a2ecf60584da69df0621c2f81e7d003a719ce395d1457159970512406774a6a523236d7ec5bf121b909743b4030045b8f69bc83de9ff2a90f9e51fdf8c2c6784d348c805cf383c7ab9f0e5d2dcd27b5dccd0df6f64f1f31a41d064af98cf2cc433d6def1f2126711f896a3288f060af380bd8cf53e974e474a73a08874b4050e808d8089cfac55cdeea66df466c29c89e4a12c244254db630103f13cc266a4a6c316be5f3488ee7290d32b4a8b69105030edfd5137eb9255414d0dbf393a7b03737d0605910ee9e70f5f790df77a98dfc6c272d3aaf7c90595a8d327c4d6ca0cb36ed374543adf2dfb3505be339a2b9d0ceef8c760b276e3dc1b5dca186394d9ed6f3346e0ffc85d866620a19ebf7516c28e923b5f650f7533c921df22e7ef2520fcfbea46b68e894a2059c453b597d35c8d071ee81d0bc3eb4f659519cbcbda041eb66d0ffab6da83b0a647f0cead9480cd181ba2478609c7ecdfbe47c3a7ba0c80ee88796087a80355cfbc504795e0d9cf07a8e212abc46af75336e1a3ac03d1bcd9dd26b490a8d78f59cdec8a5977ffae84cafd20295ea9693eadcff28b866acbb0237f178a3e0b20b6f3f9522716119f11b0ae8afcf79c0d3d680817af3531d2c7effc92f630b407251e1a179b18ac17381cd7d857b59ef39d3678c24f1abeb1ec51dbdd7921f3d432a1ddf5e06eadbfb59c7b39b4432463704384b2794efb6a4ccbbe33449fb471e064c807df12d08a807bf96322b47e6eac5b69c65f113c5841968a5d457efe4c00a141fa23c9997b0cfd62afa868f3f1b3443fa3f80830f7d99d8d2babf4c2905d73709d89b9e6f51ea930acf40cd4b5eb68fcb0d49581724dfd061819ea22c7ff14fa9356f79e75c4b6577539b81bc274ff847858edf6d223273d8526a0ff01c231a919b243476d0d3147b28bdf8a628355cfd374d75850021d58fd43ad993381b91dcfc10f97c4dc831d46d297c3179556d1185ae69c2ee31347ff2c3189c6a54759f6b89a1984f9fc6cad50b3ba25b709cd654f0425a74f7fe3f86a4d9042e5a25bc357ea7e2d1d3997835f26407f9d5f508a241147b5722b5bfc8210fb57283e964a0f971f6564095d1e638c6544fe8cb8d33d3f3e44b950faec483d560e252f2390bb54f6c4f46e17b29f2a526688e5f6bd529bde9f1cdcd98333702789ca807b4a199863cd062a3285f4b1148fb1d44b0abdf7367986f8e028fc39524b7932de9e00cfc74caadf30ede16fcc1eeb7f988ea961011420ea8e7376c1c309725c2fb7df5f6b23df127e86d354ad7e7001d3bc5af6dfc121ee1e202eccd04d1b36e05fe256fdbdfd0bf916fba431bb43c74837bbfe232b5443bb29e891233d8dea407ebae7a3402493fb4dde5eebc1caf1a121120e9f5300b4541e1d998a2456519a0470d24621016b7ae995ecfe60da055907d5b1e8a909cf9227c6ec4b133d471e971da5a0b61aec4dfacbdafbb056c94ae3e03781d2f1a6dcd4cad47244f63f280b72674b8e17dccd5faac6a6105b47d5e3e818f8db43228678b900056c303fef9b16e4c11fc9f9143651ad4455eae15d055b43ea7e1f5da955b814417fe3dc4b426d9141eadf65ade3efef3a7327bf0397a9e8fc414ac9c7c2b612631ce615ccbf918e46b1492074c44f90d16d6ec2509131a6598275b120a3b8750e5c16386895ee4851d26f34283846e597296a3a1a55244ed96913887df82b179d52cb0667de4f73402d90e6df56aff3ae2841d716a19c536cb7363af9f3b2b2cca2513e93ec8fb6d740807971bef7e98c1135d105285ab07547e64409c473b64fba528b6d421a65f0ba0edf0c4a2eee63e11dbbcb30cb3410d839777ae494e13bcc9a4d5a6fff480b9678a3367232c62d4b92aa7843173b82916c2a9568c8dc634ebff9cf042aaec9581d7afb69fa6d13ef4e7b178e7e5f148927821654a5ff81d26c3ce6d7c36f5fba4137304cd6be1af1ed1b4ee98cbfe28a87dd56b634cb77b5ad1d7e4f791b0b16f810c15775555ac8a4fca8f812e9483f45853f99a8ec12f664b4b1cd251763de7bca7fb87c2492835809727ae8aa6228cf456fdbafe859b53059305038fe813b229deb4240c7e5395983445c2084f73343d8cb5879aae9e6259f996181f07d1d0de58eb90a885a325c049d11371048039381285c85b60784d956a42d36634a75edb1a98768fd99d2af589cc3342c4b5f0ab59a014df36146f960a9d217d5fd563420c3340f0e1a2112358c01aab44fce78509a6437eed595b3c1d745012431d9a599fc076389c83af60464db220d01f15a8a3974af73432256e8712c4c1efa46475963202bbbb815432cf3731af94a7f948f82ad8bce9909e3463a31048b72518f9f46d7918060613251ff1983a8385fec9c3170ebf9f792fcb36ae6bfa37b1947414e243d713116b31139314714e646b7ca4773acb0f70aea7a13e428456dbf4f0e230cdf71cb39e2bc19e748a4b78fb5cad97daab80984eb08c1a8afdb83672d25a0e5535127a93865c8b29aa129d7413a79230dd0655af06a1e1aa9a188b67a7f4559ce7453c6f2d04fc11af268b9d14a8f621ea918a9cabeab8aebbc74fac41bc54dc1f409147c1175d798e9f4b22bf3be4beff42f8dd0094b80923879e835f0060d09a88e085bec2003337503350bbe7ed56c2944b3451e9d2b1752454456d71849b97cd1a90ac94d81cabee0610bf4bba152d7282f5ce0fa6e18c1530c545596f4920247af32c243449dfe630aab977aba00e1ceb44c54f350bb4cff9d3271e29519875c048c4c0e17460f0a005a6e3a207c82ad0d33bb71cd4a33634c0965ece4e36592271fb13af6efaa9ec9e87017d9ef0d83d8391e03a4c99745dfeee9ac7cfca453397c073022b074b22438b0c4aa52eda8799d3a8a5872a551aaf53c7d580213dc8ba970a80918f2a5caaff19f1c80a8595f1733fce82f27e05ad8c156862f56286c209ff20fc01eedd97e991b170576522dcd40c80f23f72a56fcb16f91aec6928f1edb0392b3bb2d036cd73dc28f2942d9759daa49053c7af1966a0adb80d3da339c5831b4b7caa81ca6368c6203dc1b9f75843c53bf54a268ba3a184f31e1713e1532490303adc278def81d0faefc8d3defb64fffbf53bcae60c4c6352cc2cd7dcec0638caf90a0f03a475ff7c9d301156cdbfcb8cdd194cf2b27dfb14a222e4b978d18e920fcf4c5b4abb722540b63ffa7553cbddda68eecc41986945aa3a16e906bcfc5c5e593586c43fd8706dab3d217f5c5329407fbf92480d2e49f896e6f86cf7fad574c6857ec85cef9f1b4d80f3bada3c07cd9c44fc066227fa7435eda40e70398c2a651634d9508ca01b73250f91bf82d043cd08648ddd18d359ce4c6e261240abf5cba419d975f3ce88cab36b78d989acf38b42a090afd9743bcf7046418206f4ae551365cc513ab96303094427ebf6f160444cc725eae8549e7d2a20b554e4b414df783c8665d685840ebcbf762b841e4cdb59df3e0ae076510b530be7d87e4ca7aec2ebb6669c58c7597b58d9bf1f0d31a4fddbb2e9ac69771c220b52a0de5cf5037a07d8ea924e691ee2b6dcc327177648bf02e8128fe6f9980e4f9f46c3b9d0a55d6c0f9577b525f750bd51f530d7d1135b1880401eee776690006f17547a16e2c9e767d80d5d76347350a0d1e350a4184bf23a9feec46b1f88f0d89ec1bff992f21e46232808a004289dfd48475f59a37d984999ccc44e7a5b83c9f77ca11f939f7d53c55a27cb384859b0ebabcfb783e28668c01c01a3a3b846dbd240ec258329e8d20bd6742860bfb6baad74d34269d4a031a39719911402e3b75b187b80e46a5deb421242bc80f90ba61732b9a9db244a9f4400c58765338840d789c46515e628c1d98886699f15d4042d236773f06d64a78717a503bbfc5aa9cf0da3e0de3c79bcfa82672ec7386069a4fbef37fdd83a86827533df087b2402e16929424098a977cb4412ebc1840e2e6c09583c022cbd6f2382922832bd9ba413e8ae34faebe1852d13941edeab3e23d135f669e2331b06b79b6132dcac7a0a5db8f9326708c68024dc7d0c1dcef33cb4349d19b73e8545b06d2392a2b7147258318fffecc9a0994465bd626fc30784bd3edc76eb0f4f28853d7fa1a92da7960c8d410bf9d7f57800d7e291fbea75641e68e7a856950c3418e7bb3be3ea4d3da4df92128382d6c4ea25763563850877e8f672e0c49a6034b9e51c04a5315030a4982011ffa7fc71be041737022cec1a94280906c6bc8c3b841fac83cce5a8a84b5a2c82cddc7e91c83d4ad3ae0d4b3fcec6f73e2326670aa72d0b2c5f2ee9bbf60061f44ff0818796386f382768305609c6bd99b6d811d25873a9040185a5dffaa1f2731fe49854021da46831c0f3bc93bb70a71b9f8de20ecc87b73bda8fd971d710d21beccd723b43013d5cd7c06affecf561cbc82e6416d79e1493ec6298f8c334886d087e1d996c3b7570ffefcea9ae30c66af5b0cac9ec3a101ca59c0f2e33cc82de3600a368d7e389f63ea3799ecf2b8105cf8909a1457823205da1862eda9193ec27ec4a2fb1417490eb092d222502acdfec6f99aa6e225e04210675ad35a99582eb3255786f11920261d3057506cc2b9d7da47b75a7bbc32df6e721846cf75a9d9b54a30107668ab6084a7f6258795ebb9d18513e508ac3b0be23854d64497c7090c3bf43754154dda10544086c163a6546fc60bbb57d6084b124dbf64d3b148ac9b87bb55519cf99b8d2345f1449bdb18fc359cb0f30ed8d8097290b850f5f977633c419da255180c85b634db16527fde3029bad411063a11a1d8501f450c36de8d6eeef70ad32885ada1e9267e6743dc7d65b090fe3a21f330a0a41405dabfc884b3d3b5341818645d116ca5d3f9b2f90f202a34de3f4b72564355f4fd6347f77e61464e5e9dbf49f40136dcfbf5b89046cf0f305a1089e03186338c5539c4586d6ef5f14bf5e29b1ba6c3a6996db590e37a8f03fb75933a4f8ee08318f7e3522a41b264003e831bd2fabbecb448515871e6995e9bf67c161d2c5ef8ca90392daaa3a999471a0b10389fd51a2b54cb40db16177d02f6fdaad36a21a08c69c6f3cc4c93c2fc18d0cfa32c485879b33e52adbc3c87f045602a3042155fb54fc339f96c07a56f68c3ab63378be87c29463aa2b0e1e58c7f8fc99d2aec221ca24cf1162d35670a6fd99c6efabbb4dc97dd8589d5c82196869b11669b1fc1be70ccbdcfc95f5e43b0df0255baddce3b36cdf625847110c68c7db8e3b31f22fbe2952813e2223af97c1be5ccc6dde9c4710691498fea107e8468c84cfca12ef34e72a98b2066ad6fff128d837ac9f05cb7e414f64dc05a39f549b43b811fbcf9f7aa968f3d8d2ba508495d1e9a75f97a35f4d564df3c132b251b2635e20a5cd98ef8708f05b51d6595d9944722aa46c6918596390089f2e8e6fab5a7be62bf1aa86f44afc3429832afa246f867fb8aa64cdecd97040d74fafd57103596dd310643f82f03638cad01afece71f3820105d4f5376e6448f8ec2325db4fbaa277c269ae29b4a253a380bd8830207837be1ba20b081e515e3da2c9d15a96556445613a2e588c139840bac83d2cb29218eafb64a53ec0befe266fcfc2ae9324222b1db646324fd32d221ddce5913eb4f5984c0a76abbca621333054e06cacaa8a9797f7ab506e94aa538440a7297d981e3485857396edd767a0","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
