<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"31bb5a8347eadccc25f36a44bf0be1ceaa497aaca87604bac95df127a7e2ae976c5b7c26054648fb14e13cbf95969e596e5dde92202c3b74b3b41fdeedd4483d311dd17fde51013c5014ca039fedd1bceecfdb0b8c3c75346faf560d019c5f7a9ee3b99da842837fe70ceb9033bc4ae7607c48e88415439a8a0b3a592da2f1012282968b3f1c66d423e1ea009cffe5f97482513c82aac6e86294970a4360d63d4fcfbf17286a99909d1be82b3d9686b4d5347b6b1be845684a19306bb48eca0ecc2d6c148257e52af4693caf431abef59666b18643058e12c790a1d121417bb5d9eab42c5701dbecd92c30dd1df7ae14e54496b99ec05a7e8810199d78adcf2363aee03e323fe892852d88ccc81e54ff15d2e368c0538e7708f282899089eac079192f1351cc79868e57e5600b0da48bbdcfea50c034790fb766eab674a61adcd2bfbe024c9ed5d89d6817ddcf23a6c5557aa36483749398cba2cb72e8faa2d885c0280a4c82341c006cabcbe98650a3cad3b18a84affcc89287015fa53ceb3683cc18dbc41a6cd300a6c1ce82ac784c9caf75fa66338b601693eca52aca6105af431efebfcadca33aa5beed9d7215403ee134ddfa61aa2eb8ff5183eb2336abcc3967f1a39bddb7b7e33057e2a608c764fe9b6af34145dbce3c43d3982a9793bd3121e39044e68be441003309e48480d18f7c1aff2d5b7698f8529369e3dceba9f79712d17db8f063f33f7fac6213bbb6c3ef5fb875f5d6842ce2d1be05b721ef237ed829f56a2c84bf05054b6d9be36cf6481eaa04859a102696363c0f74e46dae74344471f66eebe1d72f7c7339c3734c4cb399dca272e1bc40ba2e2e6e9257fb5a94e41f84e4fa590fd1c49b0855072c451ad33713a6f05e58304ba54338597985babb233a065c6eacf97b9ddea348244ba4f11fce02f579d06be6a9f4cf0d856a7cd687d17fb833a0501815224b69811c56e2d3783a613cde0b91c49163e678e9f2018b582d2a9f75311b019d425bfbb8f9c99116a0b710079bfb84555e23c3ea1224149fa30e4b3a3ce73beeaabba7c856ea4834f85b06b8a5bfecf0c4628c2ea87fe7d865df3b01154ffd0f0e4ff6987e3c0c0cd384512a4c454bda539b43ca875c015ecc7cc25d5b4c631a0592c4f522bf6261cad39bed19190daf59ff313428ea12cfd0837f1e68d5a4f90ada1e237a13119b241e3567757bed296a8df48c8e7473b2eab2cd28c86459aa51de2f8c007c086aa88672f8600857f1580f4b606864722689549f01e7dd704cb587728ff600fba08a5597592bd6a308c6b72bbc3ce147930c699a53715393f3b5b00b96a7857fd9c15016c62d9746242f81fd0247784b439ce1f817da28824beedd1d7df705c74853405caa814504b1e22a09660c8459ff0d2dd5e3d49beb9510f27f38918dff96af18250147bd715b5121a8076f0389d7ecc3b1a14a5137b45717aa294ca971d64017f07fb9bbf3dfe1e43dd072e373872728c297373ff26fbc116a6cb21654ea2c6d0f8ca284a7630e2197ab83c99a01b5c6853a2bc27c3ec6716e33d9550a452480aa404c899c371c3d4b9353d7970202de72049bb3d7c688102bb6674b53004fe4b940797a0b06b3fe8be628c0edce53bd7e2b0d048abe3071b0f1a4dc8bbdde82a3df04f690d7a7d741a9bdf007c70d57ef81a3b85a16a700fde3acabb40c72664da80ee5b1bb7906e009f5773fb0ad4c37f4086d0ad053cd7adf34c57f44d259de27257e0b422ec63511c7a3df8edbfde9b184b3fdf58c4b4ffca95840ff859040c89c45d568a21a4771877e4e32ae3c812b35bfa7e218c8b7fd7b0920a903e6bc5be014123203be3e3124ee8d0cdcc1911722cb4beaf1c094a62237a797721aabac5031e19b6ffd8a2f974e8eba0ac0bdb8ca4c16274c12879a7db02173c82d0f16edad90ced49a0dea062565adf749f8d2b43cf891e4e05f43b2b9c3f65fd7db18991f265bf7c998365caa8167ac2f6fb2aa0544bd61d001faecd51ea449ab36cb9aa598a0329afa44674f7e7865ffe6f8ca5919c31c91fc44b724c8dee6b91477f634c668a30ff89a9c615bf3cab31b0fdc4b55b499dea302f0b91093335ea1ea67604a0a3e76d09504bf1ddda280bdf831ecd0c9c1461131890a7aad78a9435229415c2bbd6387e49cf82f7aea428196f02f1376766dc71c1b6ff35cc6efc25483442caa08ebfe1460a2e62ba0d3036bcfa212cea01c6cbf554a51d65777eec5567eb3a6682e42e901e252c44d88755287c268dcc80c31cc0b0ee353d98271adfc759a486340b4d694d26dfe2ece38868dd9416fdb4bd1cf86511745f4ba395a9d8572c9c3f198046e830f64dd1c47573ead3e1c43c63f20e73c9a1bab65cc8d0c12d2aa9531137149d668c2cc25c78543988ddcb575fc78c9f276446cf58ee5c5017f26ed7f35e2150b45f0e6b846b6c41a5840fe51d776d7b0aadee1ad66df5e520e8ca42e4d7725966a1932c489103fcabb200d2ec25514819fdf66df12a35ab6c4a20a2145047173227f4820923c2bfcc10606b1f1b1479cbb9794e3b0667d7ee21054e9e76ed5c4095765db95eb6c65d1b3783e8abb6386e5616c82b36ab5ab7bccee2bc5a0e4ed87d7f8182b49594f26744a05a66eeb05fef6cf2c29a47fa90fd8c88c5fb5cb1bd07e2453e6ffe329452ca6f55daf49c95885aebbf44a95940970633fca557e205629834b2e0b3129b3b8c86f40319aae82792dded4c1114212d52480a2401958227e9bb7ad50424206a852f8fe3153b912976691b77027afd5e1cc15b8bcae6d66c07bcd22980e8af2ec2ddd24abf2c74323993170d20219d2af1298bd5959b92eea3434470dfd4f5df0f12cb13ce1f6428a9cbdce8a0b6f6634a211e9626501ae419c6dfaa0d85945a9dd54e589513159a74d3a317128fb0586c6f1da22b30981baa07ccb816bb40d38b4c5d616b5b4f610aeaca922d2736369d13636ff7b7d6371c75ef73cdd62058446bfddb81c6699efbc3eaddefc2974e0f5bc07eff07d324abe610e7ab6fc987e9c520466078c50205d264dcf874337a8da57e6c358966a94ec615cf7e2a89f5172d9380f328fdb36661761720520c6133a3b30ce9af7962e6cded99cef4f4a58e4657c812a3255b6ac4889afdf2748b39894ebe72e34a9d1f6be0a0726ef4665f1fe4be725aa048159f9c7abad0cd207103fc5dfe4adb67cc40ce87b21be24a9d34538db8c29486100146f77e95fb0fae5a7ed4d7c7301634945d531c6b7703d6e0dbf2fe95080fb5a815307af6b58d4d0099f7153d279b4c0fc99c3775242d9e943eceb9720113bb7021d74bd77a0f97593fc35ca207dfe3f59647e9250dfe642bcd9b79755f72c0b3f4c926c0f874280bd7e10a4aadbf60de3413887f76a55dc8cb1cdd57c6c96cfbabc3733dc74bda31027106403b716c7ae9ec9671aa1fe47d0b8e0fdeaa7ffc63a3d4a0fe809ebcf9a85794a3dbed447586ebc9360501bb552f6814378c2a7020f55c372465970e70a3279cdbd887cb757c4b4069adc1b478d4d6cbb645f4b24cea396f86195cfa4521b3d041c7103b1c6abbe310223786de86b8b74d50c376ed74d134fe30f7fb1eb79639c29e10810475390b7c2100e1a8f34579dfd1cd209cb4d8ceef2d1f39c49f336d20a392fd98c55521038dc50249239134b79a7b01423f644f346331a57b1da506b1c3cefca6758ee14334e4a8d5278b1861b00638b42b4d5dce664bbd7c02d08f2c132cb7fc0e28abeafef5763ccb1f08bf819320547e043604020c49bb53f455dae4066d339330382495c8f3776da9998565f01e6524a852c96df887d355ad1c96de489b7c335d1d61e67d8cc5db6d6e4649332fd03be4708d5ebb922f7697777fc46341c70315af47e7bded15cc70f60b340825b3102a0d5a2dd0224f8f9121a92185430863753abe7eaf5a74f2335f04f181228fc0939fb13901c49599c3302be9b998fd07cc5a4f321e1f37b2742cd3e4fb44562989a51c28237cacd8abd5cd8d4dd7d9ed4902271eb41a62e1c32a756614e20f8d3052951288284954c61ce11575d60de5addb01b921a2d2dd4bc7d0bbe7f1be12792cdb6da3d1fb3e7c4d7d411febcd7409125fa1379477570d98085fb189b7fd5a9b78ff8dff64199348e4510e6d5a7b158aa3d9dd256ba8c51a37921c8daa8db5580fba150a73c7b744c90a80b21f41c92551c945973a1ebae6adc84c3c2ef76bbab47bcd45e1cf44494923b81b30e47e3f8ee3101d0403f36d8dbb0d315b0c84392b2743f355556daa7110ddb17d9c545b753b6b3446dbe0f5133d4049c0b04bf3630f98e2bc8fda63e2f3c33db75e7684c438644856b3ca256f22dc37ddbd1156570facd8c382fc131a240435317e410f4357233d1a18a327a62d63c5297cebebb9839996d8af967b61a700ded7699657fef4dad6d5d947774fdc566078eac2cbda2009916d0d0272a816731a6db782119b13b2f556db79a37e53d800a86e30b0cb2711afe24e96a4f3607bd62775613e4150da573a03bbd22b9e14b2cc9af6282c4803e13bbd1e809df88aa038948c954dd8cfab59d406bb7b719c7fa8d0b5a82fe35c982e9525a00003febf3c97f5e337f6b8aa0acb84129e5e5a9ea12a50be8d1c4edab54d9ebc5948e5b81983fcaa8788d7e0b9df387723631832621f4fe86cd1fb15b5c19f66080a0649129d50be44141240f048ff5efdd87deb6bafcc6d41c743f8b0d0db44ec4a4b615622d20a8e054e43567171c345f67d995ec1d7e6a970149d4f8e8c584d66459881ed42653759d60fc868bc9bb33841a47ce50ecf11902a4a9ef712a66a360b777433d369e2129495376c21eb773a757a2051189ba0f2f3af69596b5433fb956adb00473e83560086ab2502d0950b19a404bffd4fbbdb701c55401959636f9a1705a33020edb4c89f0bf5fda954431ae199058258ee337b51ec8baa301d74894fae46b2e8d49f7d9862d1109dc6361564a767a0d928c939e7a93f139808db711f03b23dc2ce971b9c257bfc38b3b7f32442a518d05b43c9538173154e73c12c21fbe0ac16ffd0839f74b62ed994f7754efca7991c425376c131c5969e30e34cff4f16c2c21c657b5c53617671e736e1257da61d454368499176d0498a61a342ddb4f9b182fe3c19b32615818a2a18c183014355b1db986bd7c82f86e0fe7e1b7c56042d375ecd4137ab63d3d996866c24a0203506cea787d0393730b5b9e4e07082e00937583e8d0bada154527c5938f2ba030f7c79c17752b1882b42628f4769c347f4aebf7767223f8fccb57bc8c2284078785841db19709cb1b59be38956eb07f609f748d9e834f3b724cf618848c9b0c2f58608ccdf550a01e409a77a5124e3e1c2f75e2151ebb8db00d1058bb028a065ead7918c44dff2e3216abc73b2869e66e7929a2dd43117ce8dce5687c51ac36a5f66a53dd383a83a6a03cd818a3c1bd1496af1db25c71d2da603aaeea766e12cf2efcae456de39851af4a75c311545c2644f6270796774474f0a3af7affbdb21223149ed487014deb7b58a763f06ac458e29b0b983f69f6d71a9059a17e9019c6be204fd64afbf54841952a1ea08e041a94d4c8aa2d2723c625f1187b8c116b3eed6edfe68a983083707e5a3d6a0a4212fde5ce033c6f063cbde90172bc58fc08a62957e69c8ec657c13b4e9b097d37940557112087c9945dc0aeec32b8d818aa682ae792e2384cd92cb1d879e4032101092a3425610630e5297fb449e87e0bde346a0d2233c74cbb28c06a8f0d9a947448a6a7b4c821d0eded367ce7fc79d6d6748accfd60935999ff3d4e2d028f25e193bf043f9000dce55c29a22f48bb7d3e03f5a386a059455ffc743c6e892efc9d33cd3a9149165b124bf84a55bc22588458210c48afdd3dc4e7e427b0edcbade95188ee5cf8130936502ec0b7b3e63617cbac8e44acf302eb760e30bde1918c830bdd999b0ee1de25438cc5d9c287d70267555d0590fde74cfd8242ec3a6acd002786d5811bfa65efb9473e7fa34e26d49e14a3ec1d5b850c057dc0f228d8013fbca3d6db058ff7670036773486e59ae2f150cc503135e1bed0b8275ae9a2fb5f84941c88fee8550e26133254f124bd138428acbd3b60ac63ae23d062e53c08c1bff16f5df2cadf436b475aadee5f49b70830e0c3ff6666514424e20392134a64309f431f78c3876e364b8821716faeea0ea9a556043f6b9592c2be6a73ee2ad5c9d35650b4693865e60075238ae81d5e54b72e27884176c70375f5fb867750fa26cbe52ccbdd20f7f395405dee3507f18d9e5f62a375d907ea8554571876c8258f988d250b02d42c2c8833d50a3f10a80d280672375295ccb15dc2ab9d4bac529e2f0700e7415eb2041272a9f01556ce78ecdb4185b2cec006187916c7520b854eb300aedfe435c98238e9522c258b4c5b78a9b7561f0204136ec9324cbe7d111bd3e1218a5deaa155f2ef755df5a94a3be3cc5d8e7a65630dbe81f435f08d5f16691d23114e53d27b9e3243dc8e1b1a10a81930aeb35b700bace55450e4b1b54472f48ae07b957fae07ce9c512e4129e590557f010210b2bceb4311d5bbd541d161ebf681268341ed3236044b0db255b6999dae0c49d89571364d080e174f72777666b16f7e6e4a849b6c234f9c63749838de3fda3f60b3cb50843f69836ce4dc93e3015156263a4b20b82b6e838accfddaab8d794555e7f7aa6c5953c578a335633deaba118b59729f4b14e6a8a91053baa7af7855f9aeae11a18a9ee47e6727744742432471dd7036e6f3ef4a8990693376175d1ca2283a4eec2a484998e8fc5f97e0c2c76ac62c895bcec1d532ddee2902f0f9f74e51ab3adb8d989717985cfb8b7b28878fb383eac0a60088d9dcdd5d65556b43b6277613c9a044b619052c1dd6b23734ae5cd01764bc0b07ffb15a4d48dcd0eed5f8a2064479a242a03429300d97957b4a7397be52f6b497103a999648d3fed5175cd3521ae10f025ef1f2de623ffab691f7f7da1da50a514ab90c84c9b32c9ae5b718b5e6cd2c3694ba7f9da835d1938ca246294d8b11e6eb063fe621eca9adcc9eabcafc3bf597acd9cb162f0f350d1bff8b99d713039a673394d11d1c4a79df113e4932aa0a07ad40d68e1633a2cfda54ea393af6cc0a44ccf85810f8797dffd30d1067ec041ad10d6af5629aa0fb0c8ff13f64a651acb3f27f9f31b0f14736ac822755d362a6ec868714225e335950a925c5b76a7ab829ea0d610ecff85f374cc44b283adad245a52a12198d8974f04176bc8fd116e4647d92563c91ff38fa92a72f85e58d0e38c4730600fe2e1044086c780db36c0fd5df7a891233b1e853b932ce5f5c18fa128015de580a574e19228886576702b68e1c9dee8ea072e47782024b3499b9b328a56ab5c9cec0c5569467c132ea3bffaff7137c9bb0db4be21b7faf18d72e638d31b4c5817e5bd66b25a6c75ac2053410f6fe2b0dc92940fe1b5fa067466da742ebb4525b27109ddf933e354cb66986ffb035b3b3946c73767aea3481b594885be30093f62735172dd68b0b4671ffcc4563743222d6efd01eb543a199e75ee5732959dd943780a3b025d62d4cd7af8618b3ece6d390a27a27139d202245bba753cd55c536d71a1d1fe62372f129ca9be361ff9c34e3068a34b9b574216a6f174b33416b6e67d909bc6a3bcab92b4281074d738f8fd003f85fbd7df3aeb0a2b01147ca6d5824381ef0ad1ca03a8494d7c7e99f8c49d0e90da1859f847724496e76641ec0acc89f40ad2dcd449afddbac1f10e546f6162e9ba5b40e8dbc72c2ab95013e24ff75afaf8f5ff1e8f131bba33ceb4679991d93be161d71ee3a7047f3e9e02ef9904c7b9b033a5de7faef3a94e9143b9e92f099a16ad984c29a12da5b5324f159fa8aabd089813fba1f5c2b640d27930db5104558559c1e8199555e0d44d25add3df78f2c916fdff0e818e5c944bb17f18ae9ac82905b152e256b8350c1ac2f83ef76e12b851125ea5b6923d7489dafa617c0e4aa24770a5d2bb2bcb5ec874875725acc37d4164b75c20c3cf787b9e4f4df507b001264dc50e40e99ae0c815b3979536b1e4cdb4e7050fd065c0822e2e9699eabf77b953b98dbbaf0c71ec4c7b552db3c8bad1ed385ba58ad3875f8611a0f1dc99467aff328431d391b1fc572f9d1317b2dca46ea4ae137de6493b4a4e13bc7427fcce6c37fd9a8331181a5d4e4e16efd365b96654e6bf2d7ff29badb70e6ac0d3b0116e405014cbb4e1283b308c4753037a5f730c22783e8bec6f5401763b3d4b30a90d1b0e30483fd21d21dcf15a218e19e663a0c9b77c7cf2fe74da23306e3df4778b62278bcf32036f37852abecf242caeaa56481a8c135e902537cee2206932a9fe2a4087c05fca2c40f6a3f7886c2d8a6c9cca20ddbe10c68b795667dbeed2b323a5e685374825f3d817ff61492280978e2d54b74c14c6daf96dfd1a708623921c0af9241713fbc225c53da9127662edd354633f329472cfb5e8f9169db3734602d54fb9a4646e45ce56298fc05ae12b35512d44ec9a7a239a54826f17bd97ed2dbb70e00eca1ca1f48e4264139a22c150c43ce4da8ad06cd64ca3a2575e77ab693fe8ab78e305245d207d779a332da4c1d70888e60eaf3068fed7837ab48ee3e70df3fbf9bf6eaee8b3a22be03d2f72982020b7f79390f1c882b29e0001d5c589a7e7835b24b89df73b52770cde88122fe7b3720b00587d5c1f06bd6395bfc2adbc38908d335544c846c96a34382d9db892954c9ad7a4a650f781af2849801999f754d4c45764c5b44714364734139ac2bcebea15b7edcde08396ccb7aad9c9716902ef490f1a493deeadd040647379a6b6c8fd5ab781efd0f3f331c832119991df7483210ca47d1357a97f21cec74741acb4e4e7f6345e8de80146934c896917e76672a1eb01a72c4d204384c638b95d722a374898ca68afd0b539f8861e4684a65c2e63a58a390f257e239b806ddaceb2f697313b6801afd5b78f3d383452bb13c318c8d057e2fd9802a25cfaf8102b205a8d8c35a5b7d92679feb78d61e8304e6dc2f205c1ae84f6325c5407c16e15546b04bc1ac1647f21edbd6c3ffbdcaaeb3d1493d7bc7473c98c5fb485c85f1d0aa8a98e3def1f325defd86a6e22b020e40581ae836f2bb94b483b1c8a52af9025ca928658c5512abb41c31e674633de678c30810807671ebc36feace3d388b380d3f8be0ff581d3729558be1db2540b9661fccb3ceba44fd57fdf92a47957eddffc67be1ccc6f3e630fd589e7df824564f7da7a83267fb92c758a7ced86319722b20cc17d50e8ebe6257483133dd064e34e1e86698bd9ed50625e3d7ef2dad677b03e5992829512f33454ec6a40d870ed9468e9a40eae8cf8eac3ecf3376acd97823281b58104de1cbb2991f7993bc5b5996de80c4fc909362c2118dd5c2c9008e26d544d5720dd1894035fe4a04d29da4766991ff56ebbaac94a8746a905b56033b36ae8e1184cac796aa1ba21f745c57fe24bbf274a1a2b68bf29920f6604b7c0bfc471d770766abd0f03ae710abec970e4fc9787ce63c1c335eb02f387a8674313653f30fb2cad355a8ad2ab4eed1d00280b80531c1a8ff03bccbca7eed7264029047ce48b32fedbe661496e3ffc32df443ec837b8f3e69abbcc789036294c6dd5b2e29f1ceaba0fce61d4b4605f1374415a79c7e8172fee80abda686102ed269d777e6981ff9c34e8cba9ea05c91fa7f29fbb12da60bc233dfc40ae69aa4314fd9dd306f54d3052e6312a1071e95dec4092cbe8eb6e57528fbf6f353a1280cd9852868a46e0be70d36c016a7794d9f638858ab9ad5e51a30aaf369ad48177a926b9f0a4291d6ad2999e3aa6d760942d6e8ae0f058528b4858c528e43658e3830b805329d8831b427c74d441f089103c275da00aea870d171c5639a90b233c166c6b40f0da18ccc764a464adf522263248372d186dd6523d63d8aec59e3b1f62467ef80299f0f3f226938e8223d0f73b76a930f939a78235cc4c31708e9517a7bfb6fbfa4016bd52210a8bc7582550e5b9a38fc520aa89c9d7b25158661044e9f925a9bfbd93e9fa80092bc703f5f7e772f29f342fd5af90ae28f5c2080c1e4584401cb7ab49bce6312cb4af01394325abac5cab8fd45a95666516f16a235f8a29a37014fd5de8b0f89b5877d0557af622d6a0f3fae57b5ef1da1730f1ebdd79e2da156b4db06070f50318f1298796593223cb4ff544c77375e20b78cf4f746b4021eec2c19df4557ec1c9c7a1b9bea787f81c3f024173aec1ea3bd83a01257df681f158ec1da995b0e0a3ed3e63c3936e27a769a876bdd691f37d37a065af82efd06d9e7ad4932fe522ae51a2322c3440511fe8f0309eb31d5ae92e39524ebc7b2e4e65560bea90f35a6c1437113a39a4849d4db6ac002311d4952f5181ea9523051c3e3456eb35942eefe613f9e2e2b83ebf36599ece94878f5faeab4d89b100f2609f38dbb398372a62e8b22cb1d97e73bcf31d345c627f9f5929d4263d22000355a5735b857637bc5b05179ab7fa9ca1ff4c057eb193998ce41bcf30c12f3b7fa68d3ea2728cda8b10c59726b4201674a7fb03bc4097315004f75e29d3f0ec31fcb947bfabf9af0b8b01e665bc6b1689d4c080c2398947c55a06970288b552acb55a1e08a1e48e3889faab1af1f46d7c47641b9d48ada558b4072cee4b85f7f5fc8a64e9fe0a414a07fade09fe809c065f689381da74efe0170313e906aa8f6151bbe483609ea5a590c149f74b5d9a68b766223605b57583fb543d8c8ad06d0c62bbb9d64d9acbc388a063dc599a36f288a20be80c324c99825beed9c6edcba98a6ce0ed672f7f587a5c7bc9fe96d857f9cb19c1aeb06bb6b19b07ee1800be8dfb22e7c1e9ee42d100a67ce60cc28fda275deb41bf7d31f9a5ebd17762bd4ac07d06125ce770ca896479706f03431f8abaf77638f6729a90d9a2f5f357f3ae6b70bacbb3712d99bb81574a45595d0c3cc37cbedbe6a72b401ae3bf1c2b3fe1793739ea45b8f506472f16581e6133024b18dcfb6169fd5a3f3a95e9d681c46df79d1662be79640c54d7c17939ddb924a862377469a4584ca0a0d6954e67cfabfa0b6a5f15db56915d87aca0b101397a4d765175c614b2a3f3c563ce27a13c5f179b535612755184f207a8b9e4d538cac69568a0d18adcc7823f4418718e8914cf7c5b1f5db24f3cddbb31fb796a66e2318ed6a870c455c179b7155f778a7e331577b8a28e39a7c1c05c49e839295d2821557ee5040945d7d78dd1ac54f759ee998c403b9eca20da8e97d8bbfeeaa5825a13f811f433d85956f6c427ca6d888de6bf3d922fcd395bbe1873d1cfb5b37a618d7546ad70ba4b1b950a3f23147f4d5a79b7f451599c2ce9c7948002cb0700ce818d962f70602d0b68d218bd9a66fbe33c9ad48f01e8fa17bf52cb447a1131228e5c366c82d711935844ea8e712dae99da6ded8fd31c4fa53002ea1e85a6789f60ae4693ff520f18a70afaa4a17316232e2d0b730c55e05333bb6b04c8fae4664539c7429e8fc803426b61777a54ebd6acef3eb6b8ea7d77b2beb586baeef469c62a4caf25998925ea64324ed3a3db0583a9c82683b882f7b4393952d41bfe6ff891cc4e08bf909c493ad7102bfe6faeb53075dd9923037f70afc4c08c2493c3c766ab9182d98593f97af2284b135474105b5e1ff176bb2261dc13da8aaec738626b9f45fcbe11c5906d0a2ff815cd4d3d974aca0d84c10914fd9ce9d3328b5eee3f36d606b8cb32182cb59857195faf01bf90a1a52ef05938c7ec6bb1fe4e8cc6ca28216b0604c38c1f2a374f773a0307f1aef33f1ef7de9174e61de122847612c5a90af3050e7b46ed074ab23b3801417e30d6d8ebad8e671612f54cbe1ce40b582676287da0564346af001c7ed5d81fbc2d2f1d7b2e9d36988871ec373730b03bea9fd13459b26f13dcfb83be9df3c79aa79499e80ec9ad3b31ae706680ff9d002131695748e7db9a0325c3a9a8ea0a8dc64032415b2672b773a5e02aefb6071eb00bc45ccffbdc3036620f4ac8a96271ae108ebfd4d352e2a1c178a2c9d40d1efbbf48ca25276e3cf55d9e8d76b49de19698e90c32a2d014ddcba558a06a83d304ee08aee4839e06a43157405a9b65fd3188adc0f5be19fbcdbf1f61b813b69b6f8d5fb099d32531c996eca725d17fc39cf55cb66a4ab35a858e4d49e2346d3b24cde849e99b3e65a54dc6475e3304e4ec0fb0693241a94b7f46e3f3f19eff7f42bd8988363391d0b284cb738db7d684b19ad50d99b6ca326dfe4d686ce4419dd35c967e8bcc043c08e02cdf1d695d96fcf5c6860c26f7c1d8f701b08cf4b1f69412da87491708755663a9b6bcfc3aeac3d014d9927aad9209fa6be882d73d07423df57343b736b3a70aa00812b22af8ff325c6e2a5faeedb45d875d871585c8b553889b0c7241082ac08ee7f8b87e2f4419a232a6cddfd53730e8659dadca438baa69ef62ce0c1999bd0a503bb60f1c920b2d9be3ad2a8419a651bf6f8ecf18f861e095f43cbe5d67f3cd0ab97d3a865190dd43e9f555d9b20d2af05e61ab3860d8b5e56fe6a15f47e5f31de8f301b3728cd94be9a4036638d49f60551869d1ca1214fda96306c1084f99aaf59121fdb1a32759c53da042d29b590c78fb4da44962e593eacfd87aa097fdab4b8e17267ca0ee0a3b3ea429451c8dfeb9d2e76f95355f573598159f57ff82311eb88bfd2eeefd012c8dd7145c5130fe202918454d5f4802449afe9f835cb3cfd3eedbeecc05c8abfe6d36c8c968bfeecfd9d4ec3477b82cb12dcd04f7a3fafe3989e9074337d54c89b5380711aecef42db633cd7672cf4c533ef92f0533feed8d4567c188c748d989eb72fa76a02df74f37bb40a18186df6d6f149f73103a020ea0ba93adbffd92e41e35b98f7ec6f9bf831ba1f72289f6b6f8674b149f93d4a7c2b0e6cc8270de9d180b15a107fe76ef3bb6c27edaa0e0acdc9fa50a76b643f12e23c14b9b734fe227a0d8e9ee51e954c7c73d2221beb46c77e0e38eefecb1c7fa0447d12f8958d5c9039d1072f77d047ef13fd3fa34c07175f805a21dc1464283aacd6c12ffa9e6a22c181fa7948764ddea3e6e15ee83f4da6de5d527de6fa5b249f833529f93521b226ce2efe155947166051de2c33c382b31d72a31791b4affa57c802e5b2ee44da27ea2dcd983bbac13cecfa746ed9c087c364236458fe215552ee1a8374049273ca4935e510851f1f71cc09a455a02de425bb76ee4fdc7786cb8de9561c37db07fb3d4cf7794f181e3ecb827564c0580db082e2e811c1ed61207b8698a98588d2af4045b0d7a2adc4a3366d4be359c704ebe32d8f8e45ee7bbe5ad570e2191ff908592d925a4d1d755e005b25fc7a25bf785834fb4ae0b86c281fbb48416589ac330ff29c7c8af942e3b13a61c71f7cee775edc566a3aebe2e68b0334fb7d3ef51b1437e4bd347099109b0958f0abdbc411f62334c323f1bcc9e13667aef519ed1975bccfd56deace9baf83f3af36145865db8ce12786d0e219b64f479bb24e714bd2f17c358c849309184d015fec3f8d30dad8eba61801fb7c3901a885771b6d6f4787a5f65a57f9a2ff5fb9286f58998b0c4ac0694ae6ed5306bd2af39861628cd5dac04bbb465dd997ef76f474449b914e5393aee46812979309713b19fd4109a54b7b29c47b933844931299aa68aa1481505dbd7f655ea458dfd27817a878cce61121c4fe88fc47eaab046aa3efb3037850cc6c9924d018d83c6ebbc2c462e997fe1e864d624db87e7149719023a92e2d6532d03504797cf690fde928f6138674229f77179ed7d4c0d2bba058b9939fad8ea4137b6aed92776db5c331c927c1761bffe67ba9a730c1ff9aed39716fb069571701c944dc48eb41be41902096d5b6d78cac0234efb1b34066d5e7e36c4ecacb81b432a4a0cfc6406a3bc134cb2a57bac623a0e46734edeae83725f332cf621a145ef078eeb1cc925ac0265777be5989d82e39ec42524e4d984385e91e4f9a84aaf475bcf2b31f81cd616976fb73dd244787df5f94dccbce1fe189f5e1922514fd4b37944812f3e2a5971733623a079b7d81b029986bf9ca31c8270425d036269e81cf2b8898b32dd69ca52fdfb9c5047d929df9201298ee37d81dbba708ee7ecf3a2c61bf5d72805d38c3099237a202148ee5fd58d77582d597ddb4a4ff","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"a04e2aebb4f065114c065b7fbf49759e"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
