<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3aebae8cf616097a6d68b1546b97b37edb6109b3f71fe88a2b2763a54a7b782fd14b79a01c1df9e1d2e47013a06b4284d8156c4912e6088c8c05b9a5b0f85c575342efa299ddf58f90ce217d59bbfcc88478c67f33eb0d90845d897b08db2780d43c100df0456491b8681464859a9d943fa304158530d045cd84919a81d23047551f100d837f953e7d9a861b8c265938def8b3fffd4820ede01294f42c4fc500e0e093d398feb28e28e06f4d11b54a806258016aad89da204591294a7f359b9297747ed36c5f17a60fb30bf0bf5ee14982a0f93c124fda79fb295341bab1d9704b6d1e027ec11fcd8205d76f7db213dc752e3fdea840a5339b9b1637e63ea0527490b032e004539bdc3af5ede0600eb64554d63b5cccae978d7f04e8ba1181ceded2597e0709957292d2cf02faf8aef7d030ed7e32bb03da5adc6ef84118674ec10272a10df6b4823f6e82cc9fcba4de0d2e3c80d045f537f24e1c02b9aee7f25cf8140755e22607af8f3def3f12a8c1bd573e2a6aa2fa20f3fadf93fe8f18cdc20d874b0053acabfc92aec274c8cfc6fc9a7d11258b4b03ec62d776dcd65557489d0dab81b2e6fa2b40e88ae93f8508ed09042ab50e49b76b6b3a153fee716b3eb3cf79d7496a472698e1324c99d7abf2f44076f8ac783f4f04d8dd52f1b6af2cc1d1984773a3167e2f7f39b04a18d9cdb05b3ef075d9f3c7e8c58680eef46e70603344c997f58d0061ebd941e91431ae79f34d86eb9e353b34d604f77d14df5a3e3696cf57f43a292aa1fafe3d140ae0ddc82073d321e41bd637f6921ed0a42ff7647f8643ff7ed20def0895054f2a2af5858d7f63da3c53efdca262c2f8fab7c9ad61510c0a5c4b7f6d38a4f85e15c6fef01ba33ef31ddcf05ff6ff5d46d9a262481d35ab1232e726c4a03b2aeb2a796856a2855cb92c9adb7d2bb9adfe2c4ca7a024bc18181572e9aee7a8a0f6c2fdd59e6a1d6616fe79e4e29b498970658fba2eada177cca473ce4df965d95ee811928108ed7fc5b7e3b571ccaf82f755e432e5e58e059f6bfb4aa95167523d372c0e256e8c2cf7c3d6e22b4cd8b967428b700a302ad37997be03b0d2be9ac1c192e52260a0b07f640ccd14a78241c996396b12801be2bbda01b28bdc06577ffa91f9e15acb0fd9408a581f691aa8009128a6aea43abd9708841009f4ccb35d40b729e240857d9baa81b93e22964da9a83bbcf6e082d188c249e3d1c9d69198f9e67ea02a6109a6049b4488e1f9aee1ad3528246f7daba9838bf926a9bb8ba884f012a5f0abb3d21ea607bdae1ea4e868b2c45a53fabf055d2fd847d3e2df1ac6c46310756ccccb7dbf4ff18adab6ea346ed03841416629bcf4e71c778f07fc0fd021b9197c7202473870f2e6140d2998d902ae333aaf5f3d99f807712a132e01c9385d3ef0c3e5d1ceb8765aea62a51388041583d6947b0d4afa7e9b259f4a1bb0764b3eb9380152cdb08a116b4fcaee40630ac7e6d0be995abb7a8b2119bea282794f28f94412ac4e2807119be7ebc64749e66509b2905da8cfdd7954b6e92a2fa80745176c8878cc742fdfa86aa6106d241aa1e8af86f00d6c9afcd37349a604e410e2c7f2e90754a5bdc73e452714941ab18f6d05d6909b652a8de7a2beadf58f9fd79f89a29c95ba0e635e09884fb12155c426450440ed76ced050daaac9fe93cc4aca4ebb0b5f58918731a9579a3ed0b373759e09d332ca9abaa04c1a25aee1d6bd1110ffa0b4d340e91ac82e59902f3f1e54cb8c67ce96dbc6b23bdabfb9e5951c0cc3bb7d7baccd1e79f4a2ae700f6d61a473d2ba3c26c24795b3cf006c8654cb7d6b44ff579e252a151cd36cba33a07c5ca3060f00bea1412d8e44576b3543a6e1f24f798e54a554769fb8fd0e183f35b8720db374fb749a80e35c0a29f7ca477d2c61bb0728b4abc7cb8af6ed156a734746277a4fae4ea4b79257e2f3e7cf4faacca21580e8a6a118f987604657128e0968d6060a051ed581b590e188df93b0bda62d78aa780fd0f4c9fbbba342ab3b06f08a7316fce6aa6c4d1517093aeabdc81e8eba771c9736c1d3eda85bf8d3314ec7d35a0d38caa19c11a4b9541969a0f40828b1b218cbacff6be837bce1c9a0dca1e42753aaac5a0631a6dc511eb17a4649d5f143aef24a326012911c7d20e9537a99d32ff27d3fb564915e3ab2da7569f026389b7aa091384fb0fbaeb13bf787495541f737fa9e50e1e03eedb053761baae7696949cc3ebde6fa445e45aa605fcdd414607935b9c8283317063f52b98a1408f4ff2798dab1a294a4eec5cbb6a71e9ad9bcd58608ef542a8005c210410b089805516f43e82cdd0a325088bc730e0bc66430b678082f2ee2b5f4472fd5479f19befc56e5bc96165a460e210ef9843992d3e67c8344743a3464c4b71b4d1b52909a83131d8d814caae818cc1f3a4779b572d274c208e20c3f39536abe5f701c2406256caf1dfc4c41831aa51077cf822c044ade83c64876d51a98c4031b26642a282ab0af6fd0f968e3fa5e2d3461a2ca4f0100da6d4278645d83939dffca193dbb53211fcdf853783ba563a818b8d0004c2208996f0cb858783ed7cb80ab410ccfce5fcce99b56c611328cb494bac596b0679c875036ee1fd4f5815982a3a9d8b4e01079891df5b4b4486e4b8897957773066a5419715f2d16fad9c8ffb2f02826bd17a60b2bd5fe05f464c2a86b449d83ea89cf4e74b5e11c004f8228dcf65034d2bbee4166459a6f3d70a9e6766cc9796ce33b119f90663ebcb2c14c327d5c788b511aa16cd3248282070b177c6c5300feee9114f54a8476728a0166aa6a56b96367d50fee243cb75630abed6f34c628bf42e730cca010418d23f8bd25b148dfdcdd9f2c269078b0e810bf078eec409362fb9540725571be329a91d3a184155c4b89250397fb305ffa18f7c4ffe8df79003e881b2b10188385db200f7eb8cccf75f2fe7e74c44037e1f503101964c329001892b6a7dab9fb8f8a638e127ae7194c0bd0c86443ed8ad7ff2d844974fc6bd88f2202a03d367568fe076f8f443f3c61a12dd1cf3612431a0d3013501ffe986ec97a31ec3a19966d12861628cd06abbef28819867990eca98eaa519fe1b6bc33f8590244c4cf5e1dc3932aa8f9578280b0a4e6b6f8955c46a8783690b7fb3ef28cb164f0812691d0e29e48a983543c45022860e8f0c90faf57a74c4da9cba9aa8b7c96e8479aab38a185a60559d17913c0e1216b5acb75829b5ef830614541779ebf555008c827efc8870163676a7a11731777e14a509faf3460b0ff48875f1a925bc9116dcb629e664b8f715540087a9d8566e4cb52e2bf49e45c404af1e96c141b14f2d6d249da56312d6379627590d6f1562a1dc3f80af3919a8140d1655e45d95d18d525992220f61a649ceaf6e7ad94a18e6541b986ed0443ac7b246af4a9a562f2905a0feb6f6697985c9da8d4f4d45c774cc96b9f9eeaee6dae5c34c2e2a0c1fb37e1de666b41ca2dc46b6146fec72e0be53f34f658660bc879664820af7fd7ba39a34326a835ffb915e216ed605d68fb1816d604aaae096de1481a0969c840b942f59f2067f5e1a0a224c19ad6a313768bb20aff0b376d3b5e0558b2078086a78507304babf9a2192666d7f147d356b2facfc3f813d419c0c58a2ecc6074678066dde74532ee7f1469d85f561ebbc73b3bcb7030370d94faf94ce92870d2ef36aa38761dbddfca0acfaf3b408bd404b847cc7a150d1896c72c7582e02537a720b95564984e2d0394fec0c1296920e15a0622c0ace259559c78df9a80902e4d378c043a39d7b4628ed074daab04096eac8aa91a1ebbf0ed2d63d75425b74e38f90e59d3b0b4b5d04f2e1f21c7152b681771ca832851dd86bcd1b76ede76b599012482cf1755400648fcc98fadbbcf62fcae7685db0a50106658fa8d13cbb29613b9b4413f75b091e58b56717cda288571b471a5a73720a2dbeab3eda5243ecb4ce80c0ba217d298db9a948f070dfec8ae247d4e9cd7b2cca57efba805f8b40fd8f293a21601b9751fa4c4a9d8686eabba725bd59e2cbec60fce6341d9b44e0f7dde0258ac656c621ccfcde9def24adadc7cfbab8b1ec0c63345cc2ffec65b90b8ae9b7995a716373695a63eae5cdca2b7be68e74415fad1759a8ea607d1365d1e44318bfaee1bd594884e917279303280f229db02d71aafd69c1dcb660a5399329864e0b0d5be8a1cc1eefd80f56227be5a2715c3194464e20118c6da27c9cf7a0b587f79d329b4c620784bbb8f4526450d831657a005b986510aa9ec2facc19f3b6e4270960b4a6072bd6957d9cbc2cf00f7787ac2f1b9f24f9846239b782b3db438a8eb786487852b7d7065acaedc416d974c3e5259f05fddab40e6457372fbac702262ba3a624df13cf0973a1e19790cea0a8a128841626124fa825055c15f1842cfd939157ea346365351845865fb83c9a1d9c912b90b71dcf4dcb066ec30be83b2860142bba310523285de99cae02bd7996a15a8fcc7cf1e016703cf5bc6f51b679366d8fa03e08c09517b829d929f9ebd4e89ccba7c371af8ed99b3d24fa409ac537a3fc8cd4464f6b747f6bcb7fd7f3ed4f9210d1a0453fc000ba0c4b6479db30b684d0359ee46c4063e60b679f3cbabb33316266c0ddddc57e7240d6199c6dce8752f5e1e799965864d63de823fa2312a24c72e328e576611148e50c18a7b63d04c1cb9cb1062f369b2d22d1987dc77eff794cedcdee26f64d4f93d6a7ca6b01741acffc38699ccee361a45e636f1236285b5b167d94f8cf167d03602cd6283eeae4bebbe9e8127ab65cd7d05dcb51151414804e00c1cd720bde78b42eb4825ed62610bf2da81fca594360c973821b859432bd39519a2c3b1217d5ea187dcb0e8797641897aaebc0a2a4a7b372baa95754371c670eb0ee2adca45ef839e57405d067e503f11ff751c3cbefe1d74ca3e4cb9ae51a18b4cf68da46f8359af1f8ed7d02bbba3d99b81a8de5f5adc4a8b0ec04021c81b52ead1b11bb7ec110cb6654b863d82f3691ffd52cf092ee26ce9f240f26d294b6aa6f7988ee97d74fccc6e0dd0d10eae6a35497a968aa1b535ec5dd41894896fd89aa6191cd73213ec2c35f49578412684330c12385919b2af1e7530963bf97ed3b61b9bfc39f4dda32be4ac8420a4bc8b850c75d9de503b9bf79fb420ab439e8fb841d4e04739cdac9ebe3db2d63a73b79a280ff1061cc5654ea35beeefbdcd7f87131a0e032e195bd65e771c7e2df2daa936617687accb5c305060ca5f34c097cf3c66daa728f315ad936c2a19c397a36d13d632d895168bdf10778f80c85ef61f15476fdb9a3e2e613040d8cbaad966be1575077234a11ed3878d5490571d7bc7e1fcea698d0a1988870cc45b90b94ab4438d3b9163aa8b6c9012000ca045240fafc80e51069f380f1578942038c73516801a9797e41e9c141b2d70dd05cbd5ea082a5f3a90029c728d4afbfa6a4402e81c9ec3bd5294009dbb2f77b59f5213b4319b03df9b9a2e1732039e67786354b0e2b48efac4615c987ea7c0acdb2a8a780b0f66791deba53e654eb9269e90c387e47be5e0f9d9999fa04e42f1b5e4dcfd0820b060955a428cb7ff4d0fbc59a266b5c402dd17decd38299c8ca47f1c3fc06125b1c023f1512fd2352e2e18c5f7dda84ec160cc4f842650e533e9d33f0664aa3a1d26735a9aef72d1dcd681605e4e46738a1f131dbf5eb84bd54ddf4c7ce88a01b21146960ce98f16efc395ea326aa89421060b1d71dc162a74ab2b4762f690988038192039524daea46e578a9f7ce408308900253f27ee59788a3559358c84dc215dfd657f8392e9afea8b294236ba74d002226a84e6a8e3197523f1f13d3c9423fbe6d11cd62a5579521788c0c9dac3b38b0b8bde4273eab407e84b0783eddabb4b531fd3962a38f983c7d9b264286380149fbba576a519cfae7892e2b170173ce0fbe62c6c3a4c26395e02c882fca274c1d81934af1a908bfb4318ea7772fad6f3ff64b0d4939e5d0630154c2f0d8547f650913b7683e985bade7376911b9431c1b242dfd9fcba5489b3b33f992763866801125fa2c9668558b26240f4392d969ec603775619825223effd8cd27de6eebd5f5e7582e7e2770f778c60ef1fd68055333016dae51c80d9b35d255f9c3c73555ebaa1457a19b15dc572027d65210ca4854739cb4791e1267e411bdb74631c73a84cc4fac32d72269e75135fcf37ecfcad18e9541b650e29249d17b9d2d8139bb0f39cc08f740e3b09197451b8468bc05601cdeda8980ecf46b42feb74dbc2cebbc6f584dedd12c5737c4a7cd1d9a76b8ff0bd5d0f85ecb52abf37b7890bc11d1ee4bf3f71cd25ca1f2be2264bf4596e866b68fb5651aa97037476e23294d288b5cf89519b37db01d348874ec07ddc1abba3e8b7c498be3e97af63c9ee70c7b268494a4e5a4286523ed0e1553013d23a0aac669c8b930c37ac269885c4dca2d23a890d91cf1c6bdebac3b9e9b5cd22949af3e847485d4a24818f86fd7bed8eb036a1355e09a071b6615bb7ffcd6817355b112afc91d5626cf31061828044e144b4b932b82d6927fd6a6936c7294dc098ef425ca9914058cde70c65b9ece022c0b750bbe7edf72df93aba62ed12622f701fd0b5d1dd5f9542332e135c5a0c0268766ed421e1afcb761520eb6aec4e185efb987293d70cbcbc6560e4b7090031e32b5c8c8af805c2db54e9a449b14ee42f2cfb0f95942bb59d56bd24e2121ad38450a77481ad25a8a0767968f21be1565e38696726f2b8301069c1949c031f3c5f9cdc967a059906829dd9b2ee867df727419545416cac34aecc08315e0536decf5f17ce009af2cd16c89ef4dc1c1eb3d7a8545cae9ce1804a1fe311b4cd2d1a478a65ee2d92deefe6c3f535e96a229f0bb4ec13892bfedc80330b10fee6567a7a3a753f5c2b669b4310de76b0840753956b1694e2c4ad08ed5874c8d70ca55a6b9437fca996589263b6fe6a870958b3746194df38afcb50c6b2b4abe7a15375eae160b8da519bd344b099a3166a05f62bd06266601b0464436eb24e0286345b7fedef9f66b13d6475a7339cea5ad1e3b01c9775e1478eaf312090e9bf93b453c458b5f3b6edb7143dc1ba42eddd1b96648e13397c216c312b77b72a358780135c9f93b062a3eab44c8eb61e2ab1efb86efb2ac31e60d823cc1f4ceccdebaac7eda9a4034f2f996507f6342203d0da185a707745219ddec64c32ca8191da8ca0ba167d01d8962e14c2b42a3b3f0eb0dbe8c14fb97ac868d3716f185f13dd50b6a3a789b6b1201fabcce4abee457652323a0598f02ad2d5f1a53097c2b914e8aa2413367412d8595ae758beeb65d4c6818d9963a60a957466a4696dba565eca1efbb0008c12e64906301503dbeab32355013c1637af53c870b63a9d36fc94dbacc8aec150ac30af207307882108f54fedf64e2dbfe097465607fd0e8ca8f23e28d4591ea5d0045290326b285ab9275795409becd6512a93a279ff5ffa35008aa9445e4624a0d92c3d554ae65a76b7358e69cfdb54eb02c47ed9832d40474ed4cca572183f292f356cec38fbdd136120a1602d2ee841fa83d69609a4ff4ab243fff8692441c175b1eb9ec075e72738c8202a9df740708af4989edf6c7540bb88a21a98189d6c0dd4d8346349037af8bf22f375db9078a3a34358e17bc81e042f8eec454510ea9d677c991310cc6f1afd3425956b2f6e5ec2f285ff93f557d4b9f6a7573fd9b71adac32a453552bafce7318d1c1d60f07007e4ba0348c99b7561e6961f7fdd365289e5f101da95658fa2183956ef856f850b1f497bd40441bd7facab16ac4a63657e70c8e6805b912554f190ab82f1a6b88580255190d919ccf8126ff252533f268befe75edfe13063eacd95af57f35c5a396f44e5b9f8053ba66c58d2c94e24bd18a156c6d2f48070d6129123fd9a919c86e67f011880b6e30d25fd2ddfa84aa079c17e91116884519daf4b62aa37c5466947b000e63007757a8f40a4185c8c8722a3f7ff370d18d11ac9867d8ed77f0f4bcf9996c57d9befcceca37c46dce0b74d59d600be484d8d505b77083139797bb5cb645b9eb3d83fc51e5167ba7910ce8662018fad9da2fe0a53039e8bcb27e544cd723d14e70c9f6e7f0cd33434ad5285fbf4edf9b71a31258a5c88584fa120ce2af9a44e2eb448cf7560c1a541ed0c3c4a27f780d9c6de57202ac6ce912a8bfa61ff96c7693af8a68258e6ca6762471704f7762caa7535a59612c5cce7c992202bb5b5c00b1289a44eb9126ef547ee3d5b24ebfe1eba748cd410772a1f44440990e4499de70959e425780ebc46d00cf39395be8ae4357b5344c671e09b0a183be4636b2ec09b0f5b7d317dbe536e6ebbe2ae7cc5922479ccbdbe22d527c805c9ba96241524efc201fb02f9a28ac95e94fd8912ba28003a74e59177ae830df592f9f0f4747a30cd4dc31d684885b5d4d01628984f5db4f9c62c6ffec795ec4e2429b883e54ff594362b33e36fff285b1c5b876a2816a1ee42910a3ed669c793dd09b6fa6cf38c1da9dfb8963a318cede383386a94842481ff27b8ef01e2ad633b80783aa23664c159c1590b511885e54e78f8972e2e1860fb7ac09a97dc169d1957372542c720597b5fc0f3f9c42a998b2aa47060012bcb226ecf03cbfa215879028494c6c8d08b5f21af3eb5795e7474cc4a6dc0596219c232bf2054df715188c0b14b7efb71c1eac2e2e0c5e495aeda2b34109d37707652178909148a5c55b06db1322848ed430e3dcbb2a5160f1317c8017a4c9957f3b435ca86a4450d9de65b27ffe773a6b9fd5d24f026ab3bff0b29fbe3195391213838df7c862735a773fc6860ee0b207913bc6fe49940df5c561004e653b0dd6fbb10944c09eecf6c41adb271c509875fdd7bdd01457a4a0224f7001a31279faad315e52ef4c072779953116c9cc96ce2c71902c84efb175079318faa310537f7f8d060d515aab8baba9c4a7dd9434b4df5d4dc2d65be9cc470fc0263861f56fdfc6b771c1740886203352a7f563209a410ae5ec4bd03ccc6c52c17020cd99902bd5e2cc40ecd80309335b26d58e13de140bacd0505d06ad7b1e9eed857a07db755ea18053f4c966773ca36c33bc3adbd086e964e809cb84b931f83dd3f6f8ffdfc616f41c2646a183bb0c94de9f947a07d080ddb6f4ff7b37a1d3efc74f781adc708f9fd00821a335e3a0b54b1c40ccf4588f7e541bda01c80beb98daaa43cee8a58e44fb8db2356b972f7116e14291eb9e73b70acd7905fe89ddd730ddd7c1795822def9ee543467d30a5855b9a1bd8d89bc29f386e71fa51a64767effcc0b362fc92b9f48be37e89758cee4bf26d49ceeaa3830b290b22c6742a27a44483a21ce246522ebe2a6c9b14aada6c04ab3f35ccbfaa3f7c075fce4d7000f43ebb1b5e1e9826d6edfc431da83d2d1750bc96f08b9d274af0f5b33e5c24720e5e017acf034adcdea3b308a1c63b0df21a5a316e61e6ba4633e80f2444d2d4a710478f89e81c79fb19b94b7b8488d90b9f33ed3a126322a5e7dba0d6c6fc8f0a338319cfb252c876e70ae59614efb5981f3a6411b84d65550baaaa863669d5292456d18d75a8437a2378de6ad6b3b7a00509b48391eeff232c6ae6feb7c38a9d3c4fd23affb25b82c98604d60e6d4ea8ac510f0327717c22ca06348297e53ec146ae22fb0ddf04ba6af0fab68f6c3a1dbd3d05558568123b87ac613dbefe4a2a8cff942c4442021ac7156d5a34a7f9dc7a9ede5f9fe05ee4938799043031776f0dbcc9db524c89cbee10fcb1e90ab660edd84402811df2eaccf91f8c6bf0abf737f2d8aafd8d1d9eed1222489719090f060598170196d0b6c41115134a95e2824d7e02ee3656f6d52a4bf753a4199a58be0f1cb9c70883f6b9680cc2b9023bb6495b2e6ebb7de0c1aabb89ddd882d3941bef8aa4b4381e71f00408821b10968ddd3eaecdd588d522c641bd09c0fb0de069542cb828514cbcc16b48baf312928c5d9e0c03baf951692939e8ca0c99851de76ed5fbdf18b5a7756a23651cf3915a3f34a1a438216adaf5d8160fca32694d1bbff42cbeacb5bf473c2938bd042daa7a0baafa158c625dc6caaf54480d7243b1327f0d450f11fd633760e39185e417610f35a9d42cc78a4265dc0f03b6fb6827567d848569cde59c858a4cb6ac5de3bbdaad06c5c0d94a92d02ea3ded52b06c1cfc59242ccbb431b809b62285e60f34b7cb045f52c2117b29dc4b28a79042bc0cc2ec938dc95defc364cca316331445354efd1603c89bf01b74af58e3db469e239595db048305686bab61823df22539a486a6fca4f4c8d61f6053c88696e2c496e79c12641c001222d6645cdac51f5b4ff1d7d9df8fb69f2e7369d9b13adc78b0ca24cae87c65703b6ec931b548799c024a4795b9d690951e7371595885ce7b1b80bafd308755d98800748dc211eca6e036531a77d78ab8213e95d36f5d98c83f26fe50bcf38a84d6046d8c0fe23a923db5919eaf1a40ea91b0e28679db9cebf533f784d1bdcd0e82e859907b23e95166d4b0adba9c02e6e476ee656937605815843bfe2c6c98ee161d06f1f26c25eeae127e7d31c0a3f04736d8108120f0bee97f483bb217f2e7e0d204fa2b19445d754fbdf6d74a123c665117f4d4e212d3b011f9e90b44c270e7e7d278490a2dfc1512a2099a3c812a49ad260de84cb489be80660bd56c37ad33152e4ba58ff3ba3f1d7a71ec4826572762603f5b956c0ddfeb1b912a0fb89b391a5e0c3733ec9f4612d09108cdaa5f0df59220ca68fd9fce1c388332367d4d0c01ec03c1ff31ed48c190f76f1a1acb79398a10ff5c39fd513076ac42082f626e5f3a3ba9f90cede717294fd8a82f91b86338539e828b726be90e72271a9aae1ba0343d183e01bb91ecf27325014f30f0daa850996e5490280915481ded4dc53c627c7b20d47d7ea6d59d2c4e4fff4a1e61ee80a81dbb9557ada769833a1182b67c5846a1805b150ee1e866ae634a43768f561d21d85fd8d4c816590b6a7e8189982b17ff70c1f6f36719034012f37cdc3f9d2be2637d85799f1140b960446cc7b8c3969af02c870c3e272c91e64d061e09f18a12cff9cd55dfafd9ad43c18f1443e8be4994fa12b003dbabb6b4684b643e38fd97984f27a92a406df2eef36d18603364e7d93612d907a3c00cc41a1871f91ff695f871eab47f7f983a78614956a1e22248bac8fc879ddbd2cc752ece7950f9cb9b1d4583efabb0fde2b24be64355e8f13edfb6940cdc509d0e241169cda8eee5edbdf50bb2f6f0386d3b342d1d0d7a7d9c2dd33d82312e04628e33c6138d1f88db469671385156d1131f03eb46a92a6647f375a965e7a4389489fe800dd7971099af710f107082e7bc1cfba20f28b069823ee34926daec27ed2930513509e9980b4677525981dadffb930a06e5e0d2fa639dc9d59803789aba1400323e5b7bbf10890e5cb0582750e8f351b26298520719b00fcd4ed2b87994e95b01390007487e24b46a3879c91c1f327200304e708fb0524e9922cb995f6f1a30819626c85d5ce63e4ad5fcd972d6af9a74bedb45af9bc51c4d7762501b5f92165782f9516edd1f070beb633a2fba4c2a6b2c7858a2745d3408a51fb57290f5db85dfac1ef18de3c23a5fca15a59170742b83b849765cb5a6d8a056eedc9ec1e4fb4cafb0017d8f9ad52cad117151a572daf3b59f7af417adbc868e74848be45a7d27b54587ff4d8f0a951b6507259b48318c7bde422f876818f59ae1ea107ac6eb60c8f9000c67a241203f0fbefa9bbe49751637f0795937cb3b1cc7790d1fbf7ffb69dc5c429efedd32621f521c4cd5f3f1e5ca37cf32b5436c916a2128618effbb91713f355f9fc36639910966a01a7bebf47b0cabbaac4bb283f0494b32dc01892cc5f5a481c3e722401d0812132402d0b78483faed0ce1f2a793b0af674e5c5d3f072f4c583e5a4035af7e3475d13f6abb71c48bd5b405fa043e93703b4167ffc2bbfba42fb4e951d0f1fa66682d1870344cd0fcb0a4c4c0397cfeda9f3e114657ed89ac5a4e5599b48e8a9ce9178ea73350c3a64ae327703455019323a8a18497de5328d5b37aa81c24bcda6f610eacf570b884a920204bd245e3c7b40c56ab69794af491322a48318810e25378ea23efe726bcedb0090215e13c764550693945c951d2c77aa28655cb7125d06effe617a8ef7e56042aeda10acad21858d87166b85c77dc62f6b186dc6fb373e42b3155624ee100ae3c575754da0d49c8a8ee98bc6639d6b0cb0a6eea43ebfc9885d51b9a9eeede3fb2102a3c6b4276ee2bfade3788822f5adba86d83831bf94a83c38f46e5f4aa285a437d940701a633624312348f53576eab2f0221998fac3099a04b60a4e48ea46ae202e1fb2a64e2c278a6e78af9fddf7a79baac783d97885300ab473b93051302fb0bace6f0ab4d929ec41d25a2c3906bf9a571130f0be6986bea1f591dd717f100ddc8e4c18eb0edd16f1d6b12d557180014c0f49530e7faf5cb3478bcc2fa86d6eb27b79cff3a0d71200de1c4f5e3a6887ccf10a7faf05464d5b793cd075e5fc40feb034fdd81e45383328c7c8ec728532e07cdfcb1dca5836d9ca09731cc33bfb1d1de7da06c6b341bb33043826d763186bc831369fb8bc9cb6ece48cb026b7618bb2631fa48cdf9e7eb31314a5a6d7af2f4c23f2cd274058d8331445e9308b89bef2d0b1380bb86d7fbaa20746cd0e3e45f010d3a28a491605e8d2002458f5ad9cf0646d627c1195201266eeb83ea0c8b16a8798bc8f4e8549e64130d2642ac8a33676fe23e7befdc5cac4a3675974a15ba5d5985198689cbca0054e6a657080d2c94d9614da847675c68f7674ea26b08603747580c18cd9cc053b149dd687d1241086e43c8db85cbfd4cdfab4bb800b7e523a9a04c94819b40893cc5d4eeaed9f576912f0b20596ee8b0462e57a546dd5d40d4c7d1323292eea066e3407c8c84ac27bf27bf2ad52eab0cadcf2cdd55c66ff6f7e591b421f9aaf3558f5f220eedd31c1cb9c4a05ad83748ee417e9a484b1df613ea337de2c9f5467c1d040826ca71740f9a56db7886d840787e0a7eb7159a0a7ffe8c29ade9fc5693de0510841137558d19de8c32ded6ca842bcc2b541b5dc326612b88bb7c17db85758bf25a296df74be90e6fae15b2609ecceb82a7f1712bdd050275bf20456f590d0b780279323678f552798e627f8aa8109918fe6222ba992e33b9a458e41919313e2bc561663682ec1c619f0b27e1eaedcc516cf10886bc37ba31346e938257afc3bfee9c58a8babadceb0475ce1cb88cac5691d737b2177cabc35411fc8fbea1ea6347416c1488b9148d6e6601898a9bbc17f01fc401626ceffcecf7d436a11888c5b0d01bdd02545cc7a3385ad09c42d34329061ff248b7d220d1901749d296b5acbab231df389bd07f3f4fbe1658311cf44ec0a60f35a5ac32b693dc7905e6c1d06c2d3908b567f7ae38e743dcae41ddbb3166ffc7bbd66a3625e1522ab20addf640a4ce1863d2f802fcc2504bb0e2c11e4ee61d2e5d54582b3eeee2d9e61dd37f95daaa9b029b810660580eb1fec3078b0cad8d56c5905ac8f470ffc3e98b9e9dcf740fd890cb001eca94781a5a66aac4ca02f7ca34039df3f56e7efa201341512a6aa91da50b7da66d08970b36f4dcda58484b90d397666b128f917972d41147ff3f6eae093b8dcf962003de4d02f2ff9678d5f8b167d929746266d869b9011ec1d947e57794c6238c2542ece89a48b4c099a8c76f2a5994d372e653aee9cd3ceffe19016eb81a47f5d2c195cafe80990b567c89b5f490097b7b54b775dc3b985a3b6a10817e3e49f356c3fc594ae1f91af2c39141c485733ca9b2c48a26427d73d8c2e61e34a3bdc0411c09bde63cc87b0d183032bf88957857c67137650849e5d3731f3a9f1a0a6be28e5878129d7cad9593730072540f8869799faf2f8694d73f0cd8a2eaee5ee58a0fdcf52c9b1aac01d72a77788c6a946963186e0f7859dbdbc1aa6742b16e94aac1c917bc181b0e298b40772a98f0991d73eaffdddff8ecab01a9cc526ce8aba497c5231b12ac52dd84d690c33a009c08692a4e600442ccdf907b20a4433785ab2355e83dd43566fc2189ae544b9bb95a12ee36d285137361285f75602b05fc0705fc046440d5e8649c7475170ec673d6357bac7114dd71f2b8fd309545992301f2f5040b38391506d1ebbdb2c1659e3ce53519ef9b8e82ce6a2dae4f6caa3bdae2b602d5f6f7d15049238e593f4890316b9e5b4008b7d223b5eabb58d94b1ef87c997e298c9b8961f02619c874ae0c9e975ed5601b9804ce7b7cb58d9e605a0972588f468f877552187cf15f5b906916fe276cd14b48663d975e6b4f2969b4b81a81519894f5cb40af04ef352be0d241ccd6d2adf8d5e17ab4c18484f8a950539f96d5f4c17d7d7b82f75fb8b46d66c7525867863a27e481bc3b3381a9ad12ad48bd35626c4d0f5b41aace34a80b36fc8433f6771279541d830da75f59bde8837110fdb80607997f163749994caede32e7009f4f7d9c2d635415dbb4dc2700442ea80e0a8d9834e61be06d746842fda5687b5a9e37c5551822122e3acbe104331dbcb4489b54786caecb6998734d71cdf33e2c5f808830942e42fbd222a4f6a161ed29e7f5afbc70fdf20f58325e472de7c9e6ecf39c0bab1243c83ce57138037d7560d44e2d188e7b81b35a8543ea2db7a5413005217aa2517f13d57bc2c781cd4d86314fb42bfaa7f4292dcff9e7c060006d492ad2bf0a5ff89422b9ab0c316d00e8821f5c8fd6ff93f832fc9bd57ebf2c197079649299e15f0acb5237ccb25aa547b22dffa4a1f24040564a5cf6bc3923ae9f8a35b6d772a30e07df9c57952081fd0b21ab55202e0e9d063711f9a4ad3fc73585d48dd8cb9815a1a1b17c0dd842fd3e430398a6fed52161e127ccd11446e826807e8c9fbba00803e692a380169a3b9590d41b77d0f4e127d5e0da6a2c10404c8d22472a439cb3daf2d93a4467bcbdae7f9f019fc3da152513954a603900ba1a41bf894f5a64403a25e8af4c8566d31e6966a176d0b3e4595be7cd36ffaa8479278303521f1b0d823d514b6c99a5a78b2c015bc20d1e7d45fb59faa4350aecbb29949c6959e528fdc575836fefd94503fe4ce0441d970a25ef2ac2dd79634b1d6f3b4b24756c466d4dbf578a187a7c625d359a664a3ac29fb6b6f97e1fed4a8eae9ca314f419fc6a3284b83ffff7f7cb2fc0d9e00b195f5b10587a0fd521dc78cc313cbf6b474dd3ef31708b811efd88f40994d982936fec101ec26341da73a89b8052ad1a23209c05b042e8a1f3ccd1f6d4ef67e76a9f831751b39f00c57c63b6ecf0b0575a54565560aea34897a9cc7df99cef63243899764c07943b83e397c0529ba849fc32c40f75a3d97bdd8bfeee4f2147967b3c04a9139d64cae19a5a2b5540d72b70f4be920b4bd339dba54fbe19a4730cb4d13c2821cffbbf77d72e673878fdc8f27bedd269925340cc2270afd590bff73021ff5c2a922888447c1d43b207a42e04dc54e0804101718601c5d2c51ea475a7ee8aba325a6ec57b85725a490cfe4c6e98680df5016390f8d9f2eb7a4d280a34464193721707857f39180c18a339a3b0be638b1fa182f3862d3d711b7abee2194730eeee86d9d27263766ce412c5ff098a25c8e6b5bb48a20c95c10567190a7405333ed605d02304a6b61396cee212a07f20362207f521974b62e552712f351157e02d0b6e1e46e8ff0fcb230d7bdbb7986fb062f8713d72eba8251d25c1aa13ae04100cc29b99b2e342dc17ae1ce73e03bc511f1613cc9a67dc27e2eb2e8779cf7c20bf00c76243f4b12312a57b02d6c8341d44fb743984d18db82aab862008a368ec440c8dd97b8ddf4839093a14dfd092e85063f18d1873a244761542cf5cd8ca671d42a705a77f00622b694df6f789d1d96e1f62602c87eae206bce66cb2e683b30068fad24c1c6aff157631301240d90728e739604e1a09c9e695de08c08346e2ce3b97e4a74cfd5960fca823fb900b5fad7f8e4c9fc4fe64a1d76ae5d0d4c444a39a8e75e5acc71b2b71d816085c1670a589d58a825d608c47a2b56d33d47b3bcbbaf16b806e360066970bb9d0159e028c49210a78d003699f378c7b9651a5fcb7f2c89c0810aac57c8e0646081e761df039c4b74025ef52ed283acc740d2b1a4edfc7e5b36225fb191c721e8084bcc7aa387433a02be50f1254849830d35fe7003c082b556554a2b88ad5fe7fb84b112a0e16c8d57b91e432b3a76a95d21eddff0e6002353aa33bcb3338e259463a95e6a529332d684df13cf2d1673be7f7e74bdf4be8296d43b761ecae07fd23aa8f0a447534e11dec1c880a556478902fc8006bd5d6877b4da00c4f1027108880f4168d0ae013fda0cea7070e74ab0aa2bc7f5ba2eac84f6c2e22a22735e52f79c394abdaca20c07d1d4f45446fbe234f6f628c93c7e808c5e8717f1515b56998fc936438cba7ec8149e0c135c9d7b642de34be2d498feb2c96fcd37c253db77aaabbaf1e0e4fa6e5de0f53a4d094e3da4da0b7ba57dab05dd908a754d422ba1ad9a953f3aaef5b719aa47ce9cca2c6e2acdd2409793ec43da38e69a03ab463c81c155c8aa3d8f847442038b93c593497f4a8ef526574df178ba017fd97381181a2de7ac9866928f9aa0260931f222ec80c906f3d360b29052a806c79930cf0bf10570f43dcf3343902715a36181669dfccad9ff851c25abe62b6992f464eecc751cae3d1dfc92f806c5dfcdb67f61e347aa767d4e2b343d71316bf3023baab0c331e76039c01930016af09c06d0ba0053e8bb73b65baf9cc89b19ea4786cf94df39c229fa5ddb37fecd868237181640ac80f4d24cd1d94b837c35b81d3217df2fa84c6acce0481fe5ae4058198c54a2f80f89ac1c7af6f847104ede9d49e44ce66ca5ea4ca6c83529b9410586f9ae546bc36a88ead3972b00a7ee4a63198c5d61f2be6033501d24ce5908b8fd354d8e33f1b4da9fb02b877941a5398d8bfe17788efdeb2a534e7b8fc5298096daba088079f5d5a3693064c63684fc9abbfb0a848966ce7c0ed455e0fdf24cb5def021af7d0a73c914995b6b6b53b62854d8c1f883610053d0f8029b1aa8928741aa747852dc985f1d55031e15e4e69121a7ec86df451eaed25fdeeafa3bdf6f5b4c1c939da9f0dbab65cff14bbcdbe1125436c2f851c97cb53c48b30512f2c0ccda59b3fbe93394754aa8277d1f783822aaac7ec698d8d83a680783eec22a7bb5ceb04228f5f826f893a174cafd73dcdbd3a6a9a23314bfbb3d5254454c7e62338c148c2e4ef4f259c89370318552d54adc4694ef33b01b5b4637a3678e70ef29a620c7fc8535bf3f35e5fd33e28ac61c323735852c06879f8d361e89408d6af938ce19f9131c645fb13710d6ee93416e6d669a82527ae49d5b0b254f2be42a30b5bcbe796d2bbead4c5c31e6055ea1c100c326593383845a08382d11d0ab1df5efd01994ab95c9538fa182066b88846efb8c14cd3a64dfdefd0d47c86e4e02edad2e24606360a008c9c1293b018ac3f59c646c89b210db07b7365f0c11228914b4b54b07fa1cba9b70ee50cc0cec88efb953df5ad92ec6b4d38e50c6c6588a2f977c868126212f4c70e59e3d10c37f595329c06caef8a256715187f013bbb577f1c913b09a037748b1bb2f07102e919bec0ba2d94a63be5670de5c707f901c62225103e13158c07177e2a0cad9ef49c05c272a83bf6cded14ccf3b963a7565d33e77281a6bfe3f358d3def128ebeb606d4ffd493410c169999bdfce934bef962a9f67fa5c07eb8431cf607bd0cae4abc8a3f98f7e21ef3c24544c903d55a9cae04f2d70330d98d467ddaacdb780e4323f840a1e6fe0afe693c27e1b54b58cf0cc09e8a7d001ee6d2a47d3104c3ff37aa3bd0546d8c3b658749332fd49ab338d4b05c555fbfbd3b0e1caa2a78e957eff6dfdac5dc543b55a746d375119f395ace4de89d5ec265e1aca7c3141b6b64675939f03ee1ea401eafd6275f97b72a3dc2cd6f5d074c32a9ac929be85d52f225d23df7deb9de3f203fe833be9c0df3b55b08cfe980979b7425867a88af28de58d2278c6f87f6e189731c9d8b0d235c3b875c56332667c28bb309c6e420b43a0e7a567226c95a517997955a872a283e5193ef574326f5ea4b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
