<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2256a2b49f4b73e1358e7d06ff49cbdd9bbd8a104f980158046203a474059013d30aea8f35235d8e1c63540a75c080339cfb2bfd6226f9c39a96b77d8d3401a3f399b039a3d1bfa10a15fb362cadc171570d853743544235e802073e64f6beb8a26787afb8ba1642448914045c65ca5e455fae593ccbd99088ed773c7c6d7c653157cc70875748c15636fb672941e6c722932f8ebd6c2aaf6792c67ff6c2c36c28240ff4b83401f6fc8b532355a9c5a0140108b65bbf83154d1121b64f34f4a624d70cdf5419628c1c018fae95684995bc0b94f63207d9fb2d14b3834bea6133e8107b801f73f39c8143c9165fac8066b0bcfe9bd6f93aff8b3037e6c438aaf5869a9276722ab03e74f327da89c3862a1797ecdd9e4bee5ed88d7d7fe0910f56f582beca1aca83c6bc378b2d84deff8ed7e6d60c23ba17a4c5e0333b47818ef8a6e78a3de54b719521a32566a112589baad99b9fa64a6704c6c6086e28b08e5b8d9c66cebfdaf997384aeff634da38bcff7bf282854b82b14dd2df04742dd2d375e8c77ff710e6773f2d6a71160cbe22976e62390c5ab49cf8504bd28a6f1b907642cfa031e3f302591a4f02fb1c4a3e9bdc0ac888cb3faa1f4011f6697dcf6cfe315b9cf99efbf98ccbd208078ca91f2452a0928d96ea2eafa1e88bd149cfe0114bd92d0235c95edb56a7bbd2fd14645549eed9e79aae0f19eaa4e23438fec1691e2cdb24baa920f3672ed39b1de21fac3d18dbe0a152f7a8e5ae8791562dbb3ed8605b9de20eda9c49b35285fc2c0790437ade316ef21ff3cbc083d27cdd617e39165d8d6f48eb9f69f50bcd0ff6496ed3ac29023571f2ddafa1a0b4b4914cee91ff04c4064110ae2be4a8196dc8cc14cc7585bb0de3333e51e0775b31d30e64bf0219d375245580976fd34e9e65b24d75e537b6c43dfd9ba93001087992c277a41e11e325eb7fb55e06be0c3c8b793544ffd49e2af429377e76ee42d15b4785ae9321c62c64a9f40d803957714742bdf30dc7a767e5bf5c4d4a61c252d46f984297ee6e5181dfd7aead177afd8a8ce17caf35f44349d1896118f4475bfe5c4a144791a94e82d562feb6d0da1930a280f3834d657ff8de84a32405ad285b600d43e4fdb0c11859fcde07477669e82bff278026d7ae6f1a59c18d6242181db8e7bf647a0f27c61a78eab6934280fcbca0711223d27d7e836a9c2172bc71eac34bf100094c45117c82dd0cc38892e08de31ec25e59f926a1eaba5377bef8c3819e4279aba2875bf7a9670844d419dafb6f9f0ed09328bc3b80de0d67bc3dde5615a18ecc425b4eefe64b13460c3654c2e052136582d0f8fe92c4cb8752b3372c10cfeb5946f1e328f5d5ee5806f2b548435a875bb34a78f7b9d5ab667734ba679aef674977674744596f5f46d01e54bcf808e1617f957d37129b3c61584bb59e1cc25227db2bd7763daf57c2155eca1f754eecbe068b750b51b34f79fccbb527e759bb6bd287493177c292d99a9fc8b4d584ce6b8011d813b3f3b6d1c66eadfbb0a46e9578c4952492f1b1cc8e74c27dd9bbbc1658e38e323191b826a3ceb5809fa21519f5635352abdfbd60ae3a4dfe1e8f58e40a0003377a5ec63695884a5d218c9bf5d5da367d9ef5dd0a6a3b7f339667ce5a418d5460c604c803cd1b80fc88ecd8a268aead98681587670bc920fed0daccdd4a9c15e730d3bb817f53d13f252a888c9a5ad2797c0df923582fb420506b1dcb55ca6eaafa01ffa6812bad26ee28a06a959ccb7dad239413b08674b23d0e73eda07cd6e793c5d0bd9ce2cc5767e43a8bee247e1d6dbeac20858e0da48ec56beb1e66414b9a743a7eaff888da81b19064239d23bb5a1cf056a2436b6b9f51e2fc9ce4c5caeb90eab0abbf0ee222bb6035c4fb7afac2c809ce5606528526ca91a36c91262f9335aad21223359e23e5b6a644a52bdc6619dba4163e9e752ffe98cc7de89daafe1da2e1d5492d43a9fc47a3eeae2b1f1bf1b80a1b1d9b68d34bb301f450781aba9713589a945315b8f8e307292b1592500e89722bb4fb7c7327f5dc2441b8ca6fa926c9d2b87dd7d1651684c3af1263beb664ef14081420eeeac065caea3bda2affa6d0adfacb6eface37e209c98b52689c6b8a7960c637e712e5d1a2e24555cda6940f87279e14ce41a1ab77b0cfab8f865dbb4f2f12ca1f8417e440d4dea46f7fb9404883c6a1b21607a88af5caa3e9fb4d0dcee0274c1465934cf1ba8549798a7a039f0a6b25fb1ad5c3312166f65b4c2a157ff756a5dec36f3e9edd7f343d107d6afdcf428c91ab01f0d287500b4352e4f8f4fffc072d83ddb68e877aa2991558ab22c6f0c256996a646f8ed1390dc922750bc1282ee182e411dd3f17a0b28577671a47512d72f3c1f8e2c1aeb434d8eaaf979025d14de4a921a45181c6d22af8e74fb3b89ecef224561d50a5ea49199dbd4e75b47e36a5ffa8e081f0caa12e519e48eb9ec775c526dc33af36da6b94a01d8892e798b61e9f32c0339a514eb9ebd84374f1fda1896a94bc55654c259093c8302e26d4056936b8549c55bacd63862f42120dd37058681eb9f4b2d8885f084df5da8bbbc18f909951c9f68e78fc316be4a4441aa2f100f4a03e95bdee1735cdfa27fd6cca9689e56b2e38e3c028b48d9f254ca503fb8b3f752296de7cda82472c71fe19603fa4f22e355ec173abb00bd75f53ae4504aea239bc40eb151191bca5db7259609b9f5a0277d678db196226b9d0a5bc2032dc9a22f516be695c46731971795a7d314af740b115e4c5206a2cdf72dddf90017bf4d05aa04ba508297b5a1ab496afc52b448cdf0e8eef2b902924408d6d5718d56a33dde28e16c58fa50ed892effc5ac552a45f2be4974ec80c4a246e88adb4de8f144a39147d726e63873380b81cad14f7d31211d367ba381f0e5f566ee26265d1da3a2b969a513600772d5e2bb25a7e26f6cb9cf40d13c864429b8ddef94df95bd2e52a63ddf5c7c86d3811070b2e321b616b70bf237a7d2ee15242fe7b6ae95a8f5327617ef541b41d6f09c2760a5d6a41e89aa6d57be7a6df2ff958b691e6f0066d765e1d2254e936d0714fae98dbdd21dd9e3966f2eb8451914634705d5f5d477c9a2c834ce39de63f3826b4a81da9adfb80e8a4b6269486ce18bf08a9f82bb49d9d64e666e200b3f233f040d910c52f88fbd35d1291aa479020c9aa35a5f836764f69b0f87a7141156bc4fde4683a1329b66f0046097c605b9c56c330cffb43d43369d8cee14f16901731326976ed743f627b3affc476c82ab17e265f8b44659f5b254bd0eb6b4ba40c9c283688817083cbc532460e1d299a305afd34804151e1bcb1b56df42272488abf43bf2413533736b88116c3b80c01fa412090fe3b0484295dd1aee3c1e3d09e832df8386bf1bfe3af6a01063df372b104ce71f9a3ed6d605df3d840f0ac4d1f2837ab36c0aa44220d774abcb8835521017ba9dea6e732098e81e516b02038cb4e98c0b504291b6ab55875b175c6b9498eddfa8da5536f013090bd12d6d43dcfb3a15fe2ac79fab5885a3030fa45e3a34ecd250f18c9b81e0e9972760f7205c4a78b06824ac97c40d253c01b06cb7188c9ffbcaf4e567b4d69362c29682c1c7696e20690f0785f23b971ea54ff6905a1c9c76da8b55e8634750f1b32d1d24f03979dbe6143e2956b7f723ffe535f880bfe8b49509522589a6ff464eb6a8decbcc2f35d4772faea857858730d34136e8299d38b1bf42ca2794d9406811630482a0d5923f98b6d0fffc1470313a50113644ebd0c1df564f5f6dcfa173b14649c520ff77b11fb6e2a8c244d73d7023c3a9c41e30c59767a2738516960707ec7f4119ceff08847d0c32c73c43a4b07aeaa43957aaf41747ec67d1e093000fa25826df6182e9fb1f6341710e033406508decb18e6276983c70aa5bdc962d8a99ead0fdb64c76455d8c70b4ce2ca0f2aaa3a47e0b6f23229d65aedd6acefbf66b284ce2ea59214fcbefa87cd19b6b7396cd1f784e68313007d387ec3ee25af08a68c00fb40e4b379dbb732118eec8877213dae8a81c2c5081e3f3f523bbed69f867af783f4474c400767f5125e839831860790dbaf50d3ed06492dd742e8d8f6e1bf4ff800495af6f6d4a74413997d9ac868fce555b5aa51b430b0719476074e9b88e997d05bc01c6ab626b7d3937878816d8a49c7c9823ad5de60c1b451e52b9bb607b99e02f2b9033abb06cfadd76c873448cc98e2a1b820b43cd3588499a72efc61585e4a0c349a17598d83ba20e05a3270dbed8336c312ea27ebac464deeae7dd196229a2f25e2308bef897ac6ef764359bcc9c5cdad1ffb94c0127b8c9196299587d0380f0fc20bede040e490439ceb05085a2ce8445d10407dba3560a5f1b84ee88ed18e09c9db1d265d7207fdc24eed5ae1dec62f3028cf7ed425936736dccd794dd874c16cdea675bb3273a1a78521506039172be96fd5e8fdf006221202ecf45a5bea41168f54005aacf94ab532ae2dfcf2fc981357aa313de043a9c1ef816049154a86656c5095ff3e195f7b3d9f44e9385395c39490ba56b10bdc8dc5033a9c3170ec4ee0c47726ea58ad63236c5b79e857cebf62dc0dabf044fdcb050e4ad49e537faa0be9c5d12ea97eff95faba684fa6d22d08bfa6d6c74fe6904c2f5af58393f1781c95e0af1afe0bcc20afa8f380987c5dd8385bbb67a9aaff88c81d2680ea57bf2644a200d3f4cb2884753c743e2fde82af6725878b37ea3293bbd27276a5769116ec9daf01490762124fa1d5760547731a20d869c4a0d959bee1fe164adca5c43f584cf909275d01abc7fb4099d9075cb8e88d318d26bf561783f175f971c06e0d9123675446aac9aec9326c7e6f3918a973a750bcf8b649e493d1ae516425d85984390a82d9870c08c082751d744e5be11bfcfc979e927fab1a1d76c0827ec1747da431a2082023a4e4d7bfc90bbd90a5ba53669090de4a9133bf72408d7f08043d5a1bad81c8d788d7523a00e9fca74d7b94666a943330630d9afe2cb94dac0cd7948cb359513ecce9e6227ccffae85de24163d62974d5a1ebd4879b85c6eee2300c778bcc421141f43f4c921f855aac909b47fc56d713bfd3ba550c406fbfc53eead4226714117d6f12cca3b1288b7ccd4a6d6fc52018a9831daef1ab0b3d4418f982f447bf56236bb8a78d762d494a3c4875037377dfc5be17d247d89d824e96525e217ec4dfa1c2fb493bb271ec2e02fce39ddb9a5988ed95c885204fbca7c400033b84e1c97313faf46b7c3648e6169699fa1971124cfc392a1d445d3455a5bac8752878e311b06d1c661383be03cb245bba55f5b5434b98ba518a4ced16c5390a6ea35dbc10fa6d3fec6c01afb48bc8266b30b4a4b7d8d20b3e8c975f00255674fb3d4bef9b210ef78688344ba0fb5aa6bbab0b4982632a3a649b1e4d2cf32d94df5707d30f168f34ad0c0640214e823392d941c8c97dd3deed8f74637b5799a46a0a125bd597cf684b10d65aa7bdc6eebe9673c374f13c93677c4a7b867cbcedfc644ee992067bd5023017dff1dd1c76ff8684fae8f74af45a32872a36da4eef43d7e17b6cccbea08d7efd0708c754ca7e9f7c19e4a912d9cffac08c7418a51ea1beb65e48c4c0ea4fa53c275faedbc5d0c20d22d13e0dec1995f831f6f0f371a7ed924d393dbd9194ccd3883aeb9d55bf310471c7c24ccd318bb4b55951e3942ed7152031dbfad3e096362fa0f003ddf71419dd99a2a6600b7c4a29a23f325e3cbbf5a6107253a0af2ff5ad0ed40d97cb78b42de23d5d120ced211144165e742c8e1484f27ff6ae796e435d82f89049f0453ddcf6674f0fb122615fa538f1a3d700fb833294274229c66348342f8b29b12a7953451323b417d56e5cee8b982dbf7e10b7949476394b071d8c55c3347e3f7264b2aaaac8ad9384224d7d213c1e0f3143fa38fde9326ea06219479f7c99ebb5bb0000c41719bae8ce6d341a2e047d6843a7a7270549e170041689ff3e3c75f1e67a784fefc12febdfbd860be3d89f249526d5782702e35b8b73035e64ce40f206205c3a28a8e98a47c6adced3d1e81fadb381a40d26b3509398a6cfb17b331319f7891b3bfa8f4cd7d1146df95b9486786d2c03df9ebdb51682ab9be5e831207fb6d59c5cf9db9b3dba2c4d16bdec33eece9e964a37a2a3d5037d4935894ca8dc3cb14da8ee65dad4ecc46958b93d67b62747779ffc05b63762181f9554831f4a19a93f97816feb3b064afa9759d6a86ef24690e88cc58bfac20f1ff4d1f7141813429244fa0f25443b3fe736715da0e860442b953af1b3ed6dded3d95bf6cd02418f295421515abd87450150280f7fda4a37f0ad128fe87e9488652617cc9b2fa5c72fbac8a0aed320d60972efc37a137abc70a7beedc562d8bd10eeec2b3adc7ae7fc90fe816f78061b8d9c0dfd9b401a20a9399e4abf7aaadd7f29c084e8f40dea5e380470180e12f14686ca1d40f712e1d5d9fefa339394f69a526863d603275a2bc298c51a8ae69219d6b4b9896ff5d5e5d2273d879e1950565dd140f0a51324de54e7ed0b7c36116a792723cc6f667f75fc41ce51c10ee17f7cb59fb66f38bc317d4b76f75f9d57cc883caa12788161749db7f33a270bd106a1c8ca37d88317d84dd0a219850806890448238410e36b7089b16be9829afd6a019fe4a6c9d946a4d9dea7c67c64891a4473f638dac287710eba7094f7fc5921058db96bab531c796b96e99e7cd80bd70aa352016c6a298197fa69f511edfd95405ede76ceaf24097efe9f73e9970c27068ad57900506bfdb951f722a1bee67e2d034cb19c6fe7c082b5faae0dd9f3674a5a1de71c82fc101bc20668e2a1898883ea8f5dbcecab167936a16f5ed253ad7cabc05f24fb8b86f51520cf69b666941ae7246820d1ca238b4aecbe48da1967e19c8d140d149b945f9c1fe0a9b315d652899eafe5b924da143c8d95e4523247b423ff20813a82d2b69bb67d000ab91c46a5e38a91ad41be8245eebc510cada183434a2f9f67a19723aa3a9d1a30c6e2a57951ca7689ebeddbe14ea50776743b8910f2281c8295a7c9ad650ccac61c070b28eafb7fedef257decbc36a7b8085ffb61b42974cc3664ceb40ec5b597195e7e23f47cb37f7efece12d6ccfe4b1499194809ec7e6e8346982ebddda71ef7502f42a694a9d175eb168ef9360ff540d0d2ac4103a97b5df4ecfdc7f5014ac650bd9c1a1208531c6bbd931abddbf3eeb97714660351d503367fe2633d7203ddffe3e281997bba146226428a547d0866a4b6d24b7030222f9cf6b2f8d66999a58ee05444c545c3ce08298ccf41a0d4223cd4d195056f7325a02ce9993c831bd21ab93d698c22ad34def79c85e4884e301bd013a86cb57b0659cefd9827958ce126169e93ec3c0341f07ce98dd6182836414d5f1de9ca05d8e0ed357e679d3657169eb35f27064d899aca1173033b67eefa84a6a786eaebb67cde45b575e2cdf8360c7d788eab2985bef235ffed6fb2089cefb65982e69a11788ddbb38d7d4a6aa6a0a8f59394e9bd9d2a30d0938406fd114a67a944f9ef9378c65bd3cb1c224745cd5e0ada43f4b3a4b511e03cbb1f5168d41cbe21a0c4bbb56d2bed6a3a9d31377a4fe1dfbeb3b9b1ca1e01b132bffaecef2e417039a6f3e5a6408589ae9ccab0623a242bc27f88a9082cd6621cf3ff8151b6c7f94ceb9e7ca11b14174fc9ebd4fa884d36bcfc038cd74e0517e0f64fc8d2511e93d2b2acbb9d935d4ba03dca421e65c80a01ce76c8371f1de0960e5ad57566017461050f418408e6e8358f37479ea8749246f6b242386ebd2de9f66a53b0847bac991acf53809fd0904237ce682a6ddf9c84885ec4a5a94217c84768c6f7c61e40ab092c358af20d3ec17d75d0a91c103df7170d95c59cc143ee291c348bcac05983458e26d1e79f5cfff81f8ec3106bd76f8e2df99d3995567f2778f2b54cda7adddbac17542357855e35bd58675340d08f4772e299b398f5b457ac1e060512b97250c07e674437f85785a17968e2d855fde4cff6cfe293dfea313930ba885959121d6cf647058c7a63b1af0bc78429f034a5c3baf0267353c4a08132427a0d41124e814f315d9d3f5cb2c70d8985e513ce4bed46ef5959bd90d788ba08dd3bbd84fbf03c17458a0668cc61507558f1b3232e80c8bdfec216888e4c0812cc9a9ed76950e55f610b5524c8b3a3ed54070422f47d13a0c72f3e5d91f530e50a28253ed66e2755b3c6c5b7b96e17dd60ba476f1ee91e4dfdbef9142390fa0744dbbc223949e47d6cb3fb0393e684d236e961bfdbb2ffda1aee17620b4329584f3b46364e94af0caca1af217cd74a3254592e106ca6b4705f782291c570a7c4aa037607b365cac07f7c28c91c484081b3e6b21f82f318b20b9d1b42a1dc85d108343c6576fc3759d10b09df9c45c024bafb3ef3ff95fb81c5d1bdd0fdbfd1ae257530bd56603b569a6eb1d81b52c1c4fb3368385bdd1c4ebe1ed5d465aaca7dc865344d1c007663c812538a56ecba884490d78a0545419d2ef1d0e9f73f1a02c3bbb4af966781217fdb12b498b968a145e39300b8635015cde365d5cd937a209d614dc9e34997d90855915bbc98c8558a661f2ec672e781dfe771129faf309c7509b3e9c152b96b1051770b36af03c1c85c05995590555ddf242c4dbd8a477cc513def6ac85796a8afee59bf43ece46b8f96b4e37bc90f17d5159573a1c9799390aac53bcf828cfce842b435f9aa55ceef9dd7eb9e607e16589ea9995e9828fe1b5dc80146c38ea850b695a2c2cbdc18d3d65d5787a0131dfb52bb582fbe35bc6bfb67068b1e5bee799db5fb1aa69f47e03bc9cc0d38808b83fad4ce8743a235da8b49e4e2951e535e66865206ab9c8f7aa682369cf31389c57c27b03118a89b2c66abc8745128ad127a3fad90bb847149a10a44dccf28df7c5f662380f0b33ed2c4415be0b439f60301440f64d41bdd7194c2a751fdc1e3cb13c9d060c4a64755813c70ec69047fe14471e6e34f750949753394aefa678607e8d4922da24e8f1538acc1df926e1b7608b5fcdc7e089efd22741dd151ea838f7acd4a2cf185a183dc15f09fe57464c7578373e2360343967cea341f1ae45031606d281449cc3113c457f377cfea5dd37eb25ba03b6f03b93294b82a7deb9a7664d54dfd26ac1ec1966333e0d18e78ef10205d2d6cf0e5bea1b35108390a0cb98194ffdc491676572e569d496f576a3d0007ad15d6917aed333209c93cdf957d8b6fb2565bb25013d3cce09370819bd7705e05927da8b79206d32aad03dd307aa8bddf293f25d2e69ff88e2576792040d9debd282038ac6928fe9283b0d0b2d721a1523809d1ac534c6ba922f77273bb6851dac85bb7cc0f3e3d15e2009f686228f8dc00f00497b659f5a38ee6f575645504e881dc6919384702293c192c7e86a6e0f2c260154a4551cf1be12b85eb5e7833dcde40b585b61dc7a19d450dbc42038e4bdd8ef787b5279a7728e33c01ad59fc0f06456dacc40804a2c6f9689a4f87ec29997c5ca8280b5ca66e27d155a019bd6ee665e6c5202a45425540cf06ad6d3e247c61598e132d925425840d53ef278888c04fa6369f01c9c8d3b9d1db7db7551022eec0f30814b8d23ee175d32801b8ab6663f1b96fe170301a1fd98e92999c4e0ca729cb41eaaa61ab9d5b9a2ecd76beba0e57f6b0a0845bdb53d043afa588ae6b8547fce39f5177d2ff52ec4fbbee07748c77d651dcfa23153be36841ed29f2d0e395fa6ac03bce7d1ffc1afbf55facaff237eadb43f5ffbb128a6472f8e33bc38709705277baf07a35c1ef24c6068bb816d3a4bc467162f0514d237cd8c12b97406351d02413611f8cf01cd0d94a306a7d5436c8d7d7390048ad6f4d07ae781de442fe2ca07d742d6166cbae577d2b1adff0321cc1da83831de7a66abf03bc655976718c51dc1c92d274d6393fa85f10dfa9136f1fd50348e91a87aae1576b4c779260a0080fd88ffdc4fcbbc9e4d931cf5a066c49d00319cdc64b17dd31df086f89bb45da5049a1235295a5673857386325de26243f9b87660fe3a380871971f78966bfc68f1a17cb91d50ade8956ea36d91b0791c2f9873df073fda25bc87e81ed2d0230a92d47cfeb8dcfc077823b9d4834f62d1b75d672beb4e6439fd3ea2d56c336e8d2a72a9d6d5717246d37efea5323e89d9c54d4cf66cc4f4ccfa7a94fa1b3bab18c6b955dd66ebbf6dfac8540f23e87f4c8d47d2cbf26baf44c1fa4c6a92f2fddaf1fe39719279697b18d4ff8b350a72a4ec1aa462762b3b28322b595e181dfd8ab2abdc4b82afec6c154becac7efcd8bcc2ee72ce992e2a1e91d15ed27c502661c8fbdfb7d6a3a90ed728c456b2d1201789658aada03f37fb04d0a4e5a8bdbe067b41efb99a3a9bdf85257e31d922d99f6a2bc03fdb5456ecf117a5e0c9b7efaf6fe8eba13482f830ba5f2899440bbcc669558b85c4dc63a4cb4895c9df365337ff38ad763e6664864ff983e6a175799e3454964c324bb1acbf64882fa7a33c4b3740e65028f997901ba97bfb3b5e49d63f1cf2b0ab5f5b627549bba92f53a5273b2b6049b27fc24a44031b53b417c60f6c95c06c9c5b995223097d4026fda6fbe4085c53f3bde3c29d539b38c1eaa2cb85e65d6f825c3ba486506e6a8a0538e843b489dd5217139317f070e88f93fbd3211f82686b9e5ea4be1a32d0d0b7cb5b13f9cbd76192cffe96413fabbf20e20f64b08f3724e5a1b0733bde26a6e2e4c891a2b627612e1a5b65ad2f7fe5f4e4fec4295e161170a803e528b1880886b5143ccf569660bc69c693b27d7acc402ae169d9fca16f9bbf37353f9ea595735d1c11c843abc7c55222987b0f27b7c3b637843cf92fa6fe64e22f6d40ccfe4bd34f9b5084c134681d83e5dd23fc62ca57a1782d045379b678e6a802e1415e9dac05ef2d9e4714fc2ac2794d196efb6b25d72bb3a6c20c6bf6f3ab38c01e41d77d3dc342caea811a9cf2ad71fc328d0d7f8ff6949618166462685d8110bf340e4a03743a5d1cf8f05c45f9ec594eb44eb5c7f303969d40f0de82473a0094fc7742df402599eede5cf8a758465f6d56197279ef0e365bbba33cf5344e1f7bb42d958160b12fe859972b234ad178f3f2ee32629b61eadfc91034f9123da3a998ebd849fb750268d61fb1c1189425920e3af2d93514cf8bb817faf5308004947c4a37b5a81231dc1cb0d6f2fd878546886d57477f1022e53b336b8dd224f45168745d239ff956cce7a36a2d0ca416b9b3bf8e2835147e8249fe3836257a5894ff25b0496561d1ce9adb62a38ac37b14c2eb6cdd3f734920c569b6abf18e4d03ba22d04fdee27446e855b53006b2386a9750a7f0f750bfe1e8962e41f2ce03f3a748ae9f9933fe756916dde526bbfb0ae372a54725f836f9dffdb040984fff7344f8e71460ba1dcc563680a8273041a1f294af8635805e12e6ebb0b721151acbdded563f21e602ca161fc18875906239410a0ec6fcd20bafeb03a0afc72cd6c48640de5d1c10318362eea03dbb20533287e61581745a137842e859cea393817008f0513f3e9b444fd5dad20bc7e5c51a41040ba3fd29022588167a166c1b026157546b46dc005b863024a80d37187a713ffd5f0580d92f786dd1a0362c964037f267e3b0eaa7dba57542036c77465fdfe6c810b2f7f1f1dcd4cbe0f9266f1af36085e2a7faa6ff6225cd70311f4cabde1ac8b8b67f1384f149a7b9a3325796637bdcc8000815b4e94e8ed746271a7a0f51628a7382a9b7374d8e02fe537575e87063dd79f6644ee2c9ff36a205afa29c44678b51e25b0583e698755ecf903fe3a20a9db6bd3ecca77fa0dbc0575c06bd54f3fedc44f6d2e1089550a56ea88ddf36d5d69e916bd0303f71eb2b3d51c822c0d2af66fc9daafc4f3c69f064706ca72bb278af11e9986a3dc48c63a4d5c4ffddebc7d9de33bc6af180c32974d46c10154093c86a5b95b373338d97e15a75bdf8594464f1b193225027294b574df562c88d62083aea61d11bd7e568890659d738c653e2c63e4df9bec0c118665747893527a04a4c0f402e81a6a10b55208e612ed6e73f3691bd87aeb70d61bfb1036835d7a8ee696ec68e6fe83aa7336efcce403230f7e554289e8e2e1cba0840b702b18c0514c843f4101c45a9bc51d2d16935f73d6e705c455796857a521f9352bb657e81707ab229f1bfbef91ed4f38204c1019adacfcdbb2a5fba8984e63afd4792762c8445728af0200cc955d53202b7ee71a513f6eba70f1a1904f5b1bfc3f552930dc7f7a915b80f505088a91832c99648ed1cdc0ec014cc99a2244f912da2f57fa2521432e20c125048cfe7238bc05025b95b78fa2c5a181bbab5242cea5cf4c07cd9df1e5b8cd0ae627ffa99ec4cd8a3177d46c5bf19eb8132692c118e94c0388e378a978fd8c949aa527bbefb2470f5b08a87e20727c3df654b120886224c1ceb886de582dc4cf9ae70e70b8830a03acf46d402379fcde3045183805f32ad65c92ba92e72d3995d48d2dbaa441faf6ccf06f093e996abe78a3dc769491dc1176e95f9a8405beba298b3623c0c4abfdc127ef84d8839f5a2dea0026d97a1e460671306bbb4abc1df67bb252f9691b9989f85c0eaaa953ae33fcd609c25c3c4832002fcd9c3b434b9824716597c0ad3ff29b036fbdb0158111ed7fe4d3e6a9e80c80bb6be2349c7c114de5ffd3b7da071939ad07e2366e3945c239ffff42128a6097775b1ef289b2523f7512fa53b5d8e07c08376c7b95b952336493836750c43706e11c10ecab4f7d77e047076f63db66f2e23f18d5637996f0ac4efe2caf59c77945c006465b4c734baa35f7f85d77e811160670697996d791c9c2cb94cec8d572250e53459d9c8199079a2d7af775405e461ab1897f153523fdacbdbb142822b0252b5927b6aa785a05bfc6e562649da1dd6a9e03de0ccc4e1d7865dc8842c512d37a73a6b1f797093c8accda13f2007eb72209fdf74faa279f4a23bc46de0e055f3e3ccf7097d140313bbd77a4077d4a5e69e93ab58aaaaa3565b5ad1f97c472246f7627a82e5f2f7f039bb602e3b2c69a984f9f7e81f9d4c4b0f71ecafe4be32c4e84f33e3a54f6332926e90d86f829fcb097e54a01bb705a045d63e5fa49c8a6a7e34b6dd20f0f63d99ff02d2c04db9600e81e27032eac8f739565dbbe7e72bf014ba6ae477d64a910c0b85ca726802d4326b62ca8b324c29ead0f54c70ed683ec4930142684ff86b4665bf6ca470f57b304e8c2aac454022d1fde448681b9e3657b7585b70f2d968e969513f027a4563b004077fa9f2dbe1db1acc770e1e4dbb45e6c64ea8503ad9818204cbd8179ada12618e6ecb41ce0ef3d6796b7e1524c38a904947558f1c5e0a6d5fb2c30128c6152ac41b13d9c1561a87e1cd95f6f542da5a8756d38d4ab819d8ab992230867997a2e862b0d9711022cec84a2fd119a082f61e53388e8f0dd2651a72a1afcf2b62f5aed83ace728a34e992a023799b3e912238767f9745ccb7d7a71abab61a8902d0fad36245f55e69d1b25ea08bcb4dc356c22e8606e886cea5c08da1c6d07c01fc6a4456d9c9b15f644a6879d6f9a4d99eebac60066b3e2d15fff583cc080d17aed3162e01d7d3fc2958005ba404cfbef789c8b553789ef207b16e2b4e1fd41367f338019ad5b67ab5b3fdebd40f2cfb547c236af11b0b2696903566c2d0daef29eea85266b33e931d3f4b3216229ec43c7ddacc6e5016fa4a9c7eb3ca95efafa836a2fae9a39228fb2030d28222575a3f39653a59819fb3bc449617823a02d8bf43e24b0a00bd3bc86ac9a1b30a640a6c1f78e655f823330e3a31b72dd26558553e5120d30209863a3dc4cc82a03de054006f07e04c121bda134987e9b856143a9393647842ef08fff8f915598f50e59d1062452965d6cce6b8dae1ce092aa0de69f7371d981a8e3124ace6ee6884bacc542336cadf26bb9f9f42484cc1971e08d95f5902816c1b54f3a11933713327c3fe305a88f812637411d3fc6c7d0e6de524ebe1b66e87b48f571ced3ddcc9f065891d16e93ca7d0b15a1a1dd316b464b4351210b99fe35a68c43039907c2cbbc6efe86b4c7806373413d1857c18eee964f0b743054c3d1480ff5305229476237c7e41d7cecb3bc17030f94d7d4cf451949554030dd546cbbe33344e873bd257b30e3727c365ea0252ec7d3f4245ec639b28167752b1e50b0cd4f4e625fcdccd8148cea2a9136fc4af1ffd103e8352866ce86933217c653916743fa0439fab950b9200df86166c2c8419c4de87e61e77fb9b4e0324c272f4752923e1f40231feac0e391bc8b83c08b3def26f19b9fa0cb5e61c9157df9300ee6fb88213dc113a0357575e25ac09957e8454ee71cfa24db4f41884b057996fdafe4ff12a589a55af01b54fc6c75c4bd2efb5bfd54e7a1ce839dd169feeb8225c38511cf290a2a7d3e028e573ddcf3d9fc9c99bdcb59a65420e0255121a65629e3a415fcfacb9cd966f1d99f32a9b67db0c2107f634955cd4939c393e1d09580879684abe16696e087205ae14d1bf9c1385fe3f90578ca65b5fc0726ee66f29ae1b7482bb6c78f304a4d2979084520860d710ec4847a816884c9b5963579ad7e46c0a3a96fb7aad3cbd64014e7c68ec33f5215d4f175b067eac05062fc20c77ede630850e810d734e7fc90635d970c1bb9d84f50b57ab181cb0feb80d683c4c8b2486d8bc3b4e9f70d9e38879eba03f64a5201eec2f253ac9f26a2c062d77061f0a510232335946dcae16bda6666011ca2ae1fb822e20fb40024198e3b745e89ec91e0d950d6cdb5df9f677cb1cd6028b2af863a59b24c8de0f26151ef2ad5d888f59a2416655c99ecffe1eea9133a4caefd28b4402534d02ed9fa48179141dcf1f9348a51d241fd3296924690484c92ff748c5d62bffb7e60548cf61be37744dfee7ff995d3aa5290583ac2244ffdd0274ce97192fb439678a457c39d18a3a5c8fbca3a9439dc186c02b0839a81dbe618acd6b6590513fda9123b8f081132f6e025f1c1293289e5ba5c830a8fdc261a1c7824ac2dac9ee7d59731977befc85ed31a0b6f3d8545fb9f52039fc62d35a4de4a9beb0fc39708f5d79510858ba95f613fb7e508b1bc561233df01cc5e64b31a43f838cf8b542966c2156b516cf7eeef0bcb39b2aba775f407a7a63ebda4aae037fa6cf1b5080739592f9285d56e06b12f2c5bddb5b974a00d5f2626fd3884af30eee6ea2f5b7cac337e959fea25ecee037a56138f312edbc2cfca554cf568968d3898b6fc8bcfeee6c95fdb272003e8f69cecf8ecd4afb05654e1b89c86947913348d6664430cda3d19d5881a64a2d5417ed344a1585104cf0d729a6758edce5e4ad386fd1a7c8513f9f80a4b6c313f3d18082d8366734881e4626445d091b9c77d604e17d590b8afa97ffafdcb4ecaaa946d9b8d1ab5f64e26b161f52f7bbd674577a4eb05b39e80029318b264f9ee0df3f71f485b966e2bce8f6e8bdfd054e63b11e1a499ea1e6d20454a34d3d9f77d51ddb3911a9796d840eed792ac4f287af759626b4eddd4f95852f5ced148be50c4f3f485fc583299aed6865ff1940a585619d01b171b7178576424c01e362d14c017441d02fea624230fb45e37de6a28b7aef0a12cf408d9dc486716f37c25d6148b9d583ca6c2c09f81bb34a7f7c24e6f1c32f366e3ff5f2bf435424b9edda981473067756a5aeea8facd86071a5e7e299309f602a7703de85069283dfc5c8979d5966069c19a8276bc10d5a6ef31f5fc546a20637eef610a9897a38a21473f1a5a023262b3f6e3df8ca407265fc53d47d5efb61a5ac6bad6a40a0b11e5a3755572538f3a360b100ac95518d5b07265a384e0d4efc4d398384606ae41c1a2b37bbaa64dd1fcfa4b6d99274860cbc1cc8bc0619ef2a3fa7317b1bedd42b8c6228e937536ae96c793fa6e1d593b2a3faea9c13318618bc789253cd6c8f85e1ac027bcf278aac512741ebe3777e4468fe62950572c4f11a85a6bec6bf5624e7dc465fa53f11a354f8e980a1ac8e5d8a251522b5837bdd8b10fa5fe2194d64a9d79e1186cd9b2fcb96d5b10d2083aad587d8e8b614d04116cee30bf69c923f80a3f98272dcab55ca957df891d4373ddf50c343b3eda005332c4c2747a41818f8a4ca66f72cbe8a938e1524634e9c92a57b407cfcbe358d546f08f0ea59ea4186056a999384a718ccea6babe6db330ca24a20fa0f732a4706651bf2d5aff68b34d7be8cea5cb53514522ebb0b123d4d0968568f3be2465d37bef2c01f575309b51b7e6dc5f59abca7bcc6e7663f10de7101b9050837e3781684d0f25c16bb5ac34c010985bda552a29f5a528ef81a7295df899a47d8719522cd7887c2722204cb6a32a446aa57da686f41921a908c3f2e0a988bd99451418b3d79ec9567551db8bf97216ed7ea6f37ea0c50c3c3ccaa4ff07f8c234fc6bfc7d78ba3a7955113f3adce1934903fa79103b484c2f8173a51294d0d5689c4f09d36751e7857a084652b1f3ec6c4bc6d4090a20fd91ac0bef1cfcfcc50a656f52aaa14d4128285abda653eaa33584a76c6e6539a0aabdce9a167cc0c1de28489a054f0e4c2f390e2f84bbd9e8bcedb4dcd552ff271c12534233ed5ba8408a9afdd6aec777cc54bda6e8dd4458aed2aae693c820be0098f9aa794ee35e46df9290016ad8409aba7d956eb6559818984bb90f09b2da2c58c22fe669546fdae59e20171350bcc41d7101aab3c793158acb93b1571cf629b281e03b3ff07227a5ea1bf24226e859da604975c83d391ebd457a26fae7299fcf372aa14fcd6af9c2bf3e3b4fcff8cfc3d5a9355dce0c09ab6c0f122888fa288edc7419b4f011b630afb8d4a7bce0ce5facd7528155c7708f7c9d2c316ea7f368d7530df84b048e0e416ec514662b8aab8f177e7d1de511a16c37dbd040a52cb296b4c3063e3c107539665eeb69381b4db8bc4d548e4dbd4cf623bcabfacbcc7013e7c7e8f9b62b39ed86c80814b59af61965392506dea319501078ac87eb5466f1c2efc77a74c77cff4d8b0e882ddbfacb32643a2962b13aa9de7668fa6aeb777660946f6eea79479f5358c1aa7ef48ea9ca3a0cc7540df2a058056bb4bbef3775fcab466baf6dc9ebd2c194faf6b1e25b9fb4ba8339fad41f0b35c76309e51c86fd2c2e07d4fec1d660b7308cdfa7202a869bf24ee03c5f445080accf0cd3d708969287748fe41228e2c129db87800c92b80c5844e64c3a2058387b6d1f2bf4ea418057202b403e1b986fe3d6bfc23d0081c4391177dcc4780ba9c3182b1d86b764d9d526ad9062fdb1c0b1611c33eacb65f6fdef5e7b85aeb7c14824b51f8d44b2563f5cd67cd73b94c1c8c853621c2ab7d43edf729f9ace9eaf3ea7bbc0d24397db20c0bb3c021bfb001caeb6ad830b4636461488d83bedd3b9161dddf197acca35211a32c5da06be3da18a2f7af7d561511ddc8fb18a4e0a42054cb36e93c4d050cda98d0274733e39c7184aa96b2e52d8206242111c7704a0c68a62c00b2669386bb516139a90e7f26b04c789b94341862ae09efca2b56a08cd3f06c7cb469dd3bb56c7fd8650b4aa83831ba813c87a59af425c43038a62c01227e5c4e78a10d060c18bd19f4a42e42e0a5648eb303c79b8d0bb41ff78cea26b5cae263dd01c3d361ee9d02f179c4375befcee8f004466801fa057bd190fd6854d172ba3884f8d088d7020f493b9369edf470613c7e849add127dd5acceb45b8dd6eafc4aab6d0ad3b22b65d4a9267f2237aa205fb93704f93668cce501656b5183b96edfc89820a56a44e11f8b7c073c55ebcf5e54a1b3f49d67bc925bd892ba9cbe9a0154aa70a4eead8903d9fad21dcc79353b6909c37597a940229dc75844b965b3ee95ef7818578bd7dd8594bf91df4cd8abd9b16ae352ec9a5186cb9fab1d4cfc8fe1bd59197e879e24815d8a2ae70c3f8b45ae4d85848cb318a0c16c0d9df58670ee513d93b3b3dc57c0728999db5e3793c7a512d80bd3a33369233afa78e76cc739c7b0f5ffed585e1b23e513732e2a12d960ebcfe18540414b0d3f5da2828bec4123d4d33a91f0eebb9ffe552102945b379715304db6389526558c475dc01f0305ffd01bf5f8b5a4ec8c709f39d7c4857b9d46084ec8c8ba05ab57915219da1aa9317bc7661cae18a58dec4957d2bf0c9fe3af84e882d72c397e5d7c62aed908cbc6dd2e8a5da5ecbb0d54b7985436038a598020fd7139e8defb54bcc6a535e2ee83f3eb7a8e6aa576f786799c4399450e7d18811b3c1cbbc4ee445e3dd0b2f68cbd56d579bba69c25ca1c3bf497396960ffb6fdf598bc462463c80b5c7a480c5a05b40891f3796e550a2a724d48324db810e12327c0f6ff5dd917425be4c05d53805236f1816fefc04c01e2f9d017a2cd40ae1f707b159c34d250cae0a19690af7dbfbf81e9877a3a747ad0c0699c57fc4a9d5d0d4e03a1f19a0d07051516d14d7b42010ca16e78eb9d3e8d9270aea98ba467036560ac8f88bf59fa2d78708e93ff673531759d8333940b3d563376bb07eb406bb879b4c73a07806c1172855a3702c60a15347183a207d58ab225f0dcaedcea4ca46dab735796e1b465b2de70fb5eeb0ae96ae1ec625e64145e2699a0334ee8f4780653bb3c99ed8dd321278eff0055010de64c2a478aced3d7d3624c0b6939b6c1f094ac2e27f9a719ba8965c04d8ad3b0ac65b5dc0f16f335e77d2baf4b37ab846f3893b9eeb843ceffc318bf67b11220a79884eee31c5187a2d068e67132d3bd620d0d26c9f9cfd27f83f77f3d59d6a2e0cbda7842f90198e9440029ef38fe19645344cfbdc9d72db98a459c75722cf6bc29d2b262531d242adc61998f06858d0d351c60bdd251541143d22f552f25971ee663cc0f66ec1e660c65f2dbc997227bb35cab505b6d2aa270bcb046cfd400fcafa25e9c788951db98f1c8d28491f643cb73061c2b841499224fa53bf0d5c4063e40083cd341cbfa959a131dbb233584b24381b1b923e31db1a263750790c7a2a0a0216b493dec2d52aee74118713597e821ef427a41800468fba5516973fdc9d1bd6f06d4c802f1b3bbb5400f45890ad6efab9772ccf566a3d220cf0320cdb278624d7af36554a5c224c961287a539d235e46afbaf8c7774a72dcc6df4bd80870a0c6b22bb1dca06a660fb2b8cd4a55ef0584966d021a244adb0ee2f64eba19b908a243c345fc5835e6a23c339a1640882bad8bfa87dc0a59e5b729c6a2c3885864d77b790ed1b7f5896e0a7021af4ed75f00de2edd215dbb54d3b4393c6721f45cce75294a6635a80cd0befd30660ce87fc35b1ab1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
