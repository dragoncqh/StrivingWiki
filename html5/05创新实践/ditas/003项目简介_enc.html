<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bba8dfc0c0babeed41cf412d7af15ece5db09e34f0758cbad89f05df89eb218b12a48f3cd39087211119e3363cf7d88d6e059bd506d38ceec709b0475123da13cb5d2ebbf0e121fa3d6dd8e38f1637a634b129228966ea3ad9da281c608c515b9c37a36c546e21fdbf2ed87a082ff7c3185bfe5fbc62e4080eb824c82fe560d90bc85495abb7710e207e0dde3de336ec1e08166db9479bc41d6fd32cc487e6d1374e0ea750f0d76c01f4bda390607af82b837ed7590747533e6962f2c401c6121e42ca7b9b403e14d2db18ce93095fdd070a2f57ebea3a85bdcc866e56af489afa315d1048f94bd187162616fadd304a9d92482907cea3ebfed33172746263f6b86cf6558e0fce6d7a9357c8a1f2dfde317221c6327c1b9e3c98255620b2dc1fbf2a3b6ccd0fad39b489e196b8607ca2fe42401e8c8f364e82aacaf10100da232785b6a71543fabf2a8b52aca35a4b0ae9c28ba83aecba17877985f7be4f49f4872bf537751be7eb49eb264fc63c7fccb535728848371575d5bc77bad7ce541fc9999d87d172d4d05cdcf45430cbd50ffd2ee24abce6685297b85beefc73ffc91b8069752168f12013e1b68a1b903136bb5c292516dca3b44e35f883b65cbcb6e22a112a7755fabaf71d4e7be223100d55ab81d5b9d742d630e827ecce36019a795fc075d6019f9641c15feecaf4610e58a3a4f3162b974a1dfc6a4e2acf5231db46dbdc1844118fc15fa797d80d789d5b9147cbb2235d6ff8f2535b9b688c7637c8399569c3ed2db83bf5d21e4c28385578845562bbd6096031f58fd835b94a26669f317282865311fac9ef0ffe5ba7769910d118787c7377ac0760d65735d85a64dab81b92981951999e07aa598433258f17bde4f572615c3b5dbaa9bb17f32933c7247a6457e23012d49a73eabc064fe3909143ebd7d263ab04674cb3cafaaf5b97909e577d2385ed73586e2aa9e7412f68eb53034ca8169349c7a6121dedcb46d4720e90aa2e66905805403f08f3d253ae45b931228c8c4c81b5f3ad3e1fb25c0642369844a4c634bb20ca8cb5ec5147a5238ea2783b9e5c058c0a0965b950e2f6b33198274b2322b9417446d4e38c1cb93456761c7f531d13ac99d609404f7133d8d0efcec66b2662d475bb742d82eab1a86f94a04f6f6f7ac189226af00cbc8ee4c0676dfedfff7c5456156ce0a12a905aaa7a530df6eda260c2699053f95d7403d62c2e06ee602d3d9e7165c18126da197d34f50d652e9c3f3428f0268ec1f7b9da4143faa2928e96d199a6e02f8bd825a33dbc7fd96669e06e2b22db644e1538239598d573814bc9c2faaddfd80ed4733f34446ef5bc08b7e98f986bdc2e94f88066b3847242127567826fe17decbfc6f7f4f2dcd10e1bef6086f222f6a8963e5cc9ebf9486c7ca942db9964e312d93384ef705b4e5f284c38332d8e0e58c3719417bc22daefdfe643ad1a06b2eb72d32960e69bdd4b6751a7831bcca79ba0fa403e3cc97bc613761bcff4a406bff18766f045ac803b34e79f06267dea090d3ec578e3fdaa96fdf81e85b34f4acf375e6a970a0d817640b0a6a494516c7ba2eb64ead2cbb7618aeda2fc5fa1005d35cd5edfa04bbee2f59a63ed164a23593ca1c9757cab92162b7f2d43d29d21099ef0090ab00cdc27dae06eec4ae591c02e24e0904b3fbeac5a86ba8d6bba2155d2f84a9c87da5f3c5168bdbb18beaed5177b7536f4bf58e504dc8a253bcaf4b8aebdeb3141dfcb54b64c3db3577161148f7c4f91bcae4c3cb29f8922803c11bf4cbd6d4b3e102c05d8d66ae54414021a2ad1e833a8fed893c611fd14425600f63c10aaf6f618550c26ebe9a7c419d1cf37d50eb73c1395db42157217bbbeadaf8ddfbe04e742db4cd8e5619b78ec89bbf1e7e2f28f5b62f57cf318d88459d61eae63693cc78da502a25f32b6f68686b5aa94483c2d4d1dc7af3af348c35b42f16a17718077273ec1b5e3aaa14b0737233dd525fa7c42c3d0b0e294f80f9bb793b1cb147f915bafde86cbe9c1bc9f475949b6ddd0fdf796fb6cc5c6eb6507280761de3d27cbf0ec1d3ad53e0264ba3c2fe2363fc7edb68b16594a6e87e20fc0a884c65dc8246fcf477aebda26d125491be78e2f8217a62dcea46dee5eceb7ad68463d822b1b31408ad7feb0d20bdf0bd58e14011383d678d51f4663c53251bf3dcdad9d9162053757684b9903448afbb3ef089ada1b4f24e4461a5f6b9b610806bab8a48a110c0e8accf2a1e2c27b7045f67cbd8e193ceba5c01b51adfdadeda93bed5c421f53036aebdef81407fd02a4a20cc0ac342ed10d848a09fcecda0e05fd9c5d69cb0a7c0b12134e54b58301fd584484c5fad267f88ff9ef2b2eb94c4dde38612279a851f97c6de5af4bef465c024ee55ab401f04d753b14a663dd4398a543d034f6165e91ef722a0001366e87a3d24be344e3b13a189910e2fcd73e6d43e2098b7497069051666ad38f9a6203ff8b7a4502cdf54baf2a2426712119b84f502196083eb7726f8daf47595f11007dee33193bbdbc6076d8f90909a5c404abf1d859f6862dd0b4abfb73b62885b3b8e8e5473446dd5e765288bcea7d2f13716b56c08f761c70be42b9bf329d520d7e57dab43c08fb76077a14a227feb5d6701df2e9f052cce51a42bbc083ffe9a6219968e2feff6dfb534e68f087b678db00079c1cf1215aea770ef9fa2e37c1d92dde24924d6e6b3e4baaa90733e84194387b1607cc11a3497888213a7d3cfc4fae141a53ee9b6b97c411e2c6b65cd8c3f5bc29fc844b743f5088c0cf50a4102589ba5e3bb5946ec19f696f7af71ea054aef5fc027c110cf22936a7e8643b72b520a4d62084accea30dc8d1b30ba50cfd9edffa210a90d7c3f3be85fd8b3f10e3a0715377d67ca13b1a86fc28b223fcb53b62166c671b77152315de1f9940434d6b316c72b38d634681195a08f282390fa96779619f85b77f501ed123f0d028f79238bd8a154ea60fe7580de5ea233509a5a9be00bb15746afee8e470af299cbf13b90db851cf77fdddb9f74dbe5bd68f70b9df1fb599e287484d98542441da83d8bdc79dea8324423d17f135eec6c19e9b231f3d90f8ad978d09a4ab7a21c1eb84137d8364d89cc4d449f372a0eda3783ed503c9d0a0300c4ef58cc0cef9a9bf54a69064e70ac2cf60000c34167d489663f05756747ac2be82dacc34f97d1ebd8484b8e1b686654b4a6055a31d4ccbd21652d5a4466718970d4df28338b66dc787e35b4fdb38cf43e4e726ef69bfcb735fcc5bd285c0b337cb884f71cb977367d900b22c65e421927af68358fca60a722aadabf2240f9b5e6e6669f77c7b63fc1f3b1b2b2d57924b77f33a65e68dc04eb514a7b8dd685740b755d4024be530490526e23f1742d4f0507edc8d26ad9c0837c1a3ec863602f99d6b190f4e57e4bf685656ae7c9dd6c757e81fdaa86f173a1112ba617afebe23308cdcab582b1d2aa24ab6cbe466e9c48ae4b810f4bfa75f404388ca7d6eb006bafd130eb35020870bf04ca89c0864ac0eaa9dda4482c7f1a5df93ffa731c00bb59108a0904ca0dd7fa16c4742d752a073aae1b274a675460e708c333ce33a9d6f53a08bc3e6a70cb60a5a5bc5859284bc29600d9f2fa63ad1ba91db6785969b0f8c9b03945b12d652a8b158ab4945a80f4ccf7b52203a4f186edb9bc209e4a0995c844fb9f594bdcd065921eed85b858abcd0c108139a5c677a38df01737e146c4b360a3f327dc772e46e9aea9f0a76d996dc839257170018bf3ef624b1c42fef57b71729621cb7341d1e8973c47e7d8ef19c01635afab1f0704097d6bbf8c23cfaf751dfcde14dd39c4e30689323996bee0dd68851a0abe2e7d8d7ff15b024b06e070e6f1a0c36a23579b8774213971e10877855eb1f58861a3ea74e3ef5b68191ac853830121657ac5d1d2b9ec2853ab02298d5442dffb257711e1d66ae284ad995af4dbaab9eb8014d8779fa90de0c2de72ea0546d97a579bd9e83aafe94facfc7914c5940c698e1f6270f94475bb85a2600db8dd4a8cd8b043f4507308c3a01ffb55b62de65c126735f3f33b4dc769e543c71c17bedbaa39b75b4930987b46cd0bbc38dfb2ca3e7ab1766d0881da28443c236d3b27cd3e5fb4821e050848595ea1fa94e6abaa5b13c075a778d399a89ce66afb4af1ceeb2f5a9087a199e98f2c88ceeee289779bfc682202fcc1bfbb7943c712180e6e3dfd270038372c341acaf5f61cbe4b4934dd465fa6a9db2902c4d6800d825dec34f3ed183bc4f7ce5046164e632ac0ee695182665636632c60a7ce21b28f9ccb8041160b405669d771bc5c58aa279be10dfe97fe19f04f61db67c22e1c49251ead0da24bfe0464985d176eecdd7ae8e5dc356281dbbe127ed3339d9f95a601e8b1f035064ef71605da6a8e04006e85b8dfa6ad3895f09225a48f95da7a42aa1404eaac6d4c3e1bb8f56b74cac34b291bfbe22b35f69e903e0e8c8804f3f1fd32343b2d3a9f24d6f57c0a685646bfc27056434cc1e46bca1a180fc92ab7db65154d59df6e4c69d13d529dec1bcbacd10e26acc8ca8209d99057a898b4450161974aea3f827d6da218b0460bd5753e4fee3c666770e100d79007e542468635c317d5ed8ac4972a301992de1a6ad4c5479e3266372401779d68a77fdc85a83d5ba8a4d6af3582715c5f98457d53d0f5c015090bab644ae6d1cf05c8ee2931e66897f5c27486bac8f80ef9b55523653f4423981cde2a3d06e266573f131b144101495697b3e1e9981b91f1ed40f50c53f858fbcd01f2743e67995e32de026e9c1fc03015d09c31a2e822aba3c60309f9ba3e37c16204f9e965e69c60e45970248491a2e8b64393494d33ba265b343844c239a5d40f3a5d7eec1c66d5163fc5cf39f89b2c21e5df8005a4d302a3edc73bd69da0cf2f433a94d4d2dccc5bd9356e396c60b398df2386b210c0e3f3a182e403e3a774992022f16420a6a79a60afae455aa24bfbf77ded8121e0e597537e35376b1ffec22a2abd589fd2db71e64eea1ad3459e0330f15baa74d35231f292c0e042becab2ceacb141faaeefc8c0646a71248e99ae9330ad0a93edaf926675976f6a6eaf2fa70187d19d99e656c4a5e24cc9b0f41cfabd2e558b70665d30db264b3e149bbc9d5db0514810e3fc0100952a017e19f259c987f057222b21ced4ebb682aba3195b9401321e4e7fb2168004a0b89501a3ef72c5caa31f6bc2617cc82360d16cdea6ea4e73b19fae4ad5f9fc555b1e2f1ee36000208202ef369a0fae2a76413d759e8eac2bd135ec57417b5507c639e2b8c1ad4f116f9a02dd85716a12380521a3eed4466bcb3ed46b8fb5e26889bbd180a4cb082f17a2758d1cf036f1f1a24263f09d6da2f8d52bc7cb75368b817ac45358c3025b6f04ca1550f674fe8ed102522565a1a557b6a56e92cb707cc65025d43c36cb17a14dbf3e45c18b55be633f7c8509b87f6a972f7b779e97e9b08acb9073b09e708f61d592808511124bbc08e9fbe6421036cf24bfe0ab70a35df5b7662a5df2da4e991eb8b91cb08ac746c6bd74a8223dddaabc2dd144b7c91dcc088fe01bac3c21a1cca833604483f7f498e807cec3fa7e8f8581ce3163d4883d3fcca8f293d3c0420bb4f21c060531b55d317f2ee76fc07607206806b12f072b0c0222777418e89403490b6379ecc5b90383671b9478ff99764b20e0f2be60c0901fa81e47c93cf13a1e044700d32d84051411fbcf4bc55f3ae3aba22d62020a19e173dc4fd1500ef78db822c9d57db18928572175ecd2e2a68d839f740aafdd9f671ec6430a4afa5a1fcf080e20647d82fa4467c773136588c2a5f6d0702656c11dce5c985c707837ccc21f9789e99f59eaa52618ebaa584433d316d58f3632560953eb9ac3cfe4cc8bc16b33933f36ff063c324886edbdcaac720e2bb74d4856119dd6bbabc6ac497ac89a77e154f15d8a3829880e23d7eb74e9926cbd5411bbbac394856758c36b9bbc164bfe0b7d420cfb5dda292b2efe974fd833e74f0055f1db2f4234d4df231db608ddbfc0d419bb088d1ef7eee5807d5497a36910b02559d46ea6e96285f91cd89c23cca9b8cf3bc8ca94db8b213f7fe8c6d94e95d52070e4ab6a9287bcc941b6c5151d3562f6749754074dd1102dfff1d2ac0559672ce4a7fea2a932a0a602a28e4b0f3f9dc78566d015599029500cc8d7e3963fd9012676253d253c630641bac0656cc7fe381b74d8af63bbc1a0ec8f253603a2e3971aaebc557a5b76b518232a8fc82b105735cb74844da1974664032bd800e654af3d9c61495dd853ff9048694f7cda56e6a74487155e9cc0820c8b40a3879c565c3a90cbf983477850aacd722474cb6e0946077757e61cb080395ad97aad1ffb6b7293a6094a58b3a2656b8902af8f136abc2b996038d78dd38111fc57b439a0f0cb8ea2009d048c07a9bf6277622645122d31b07f13902a8e42f828c923613c670bce414056d47527271e6594d6a5ee623926761ce310dec41c324fd321f24e5002663834c3543cad07df46a0127356401a46ca910def25ac34d29fb59aef39671c66e96dec8f81b7841f06c18191abc56952f9c9366b945da46670d685b6bcc7b24737610500f9f27f2cd108b20685ac8d69655832ac4c9b2ed4857528b5b41208ea40e1936222421a7be2b72d7a982eff8fbf9cf96951c1cfafcb52edf1fa2b364356aa25f5ff4c9f3c0d9acb1b49556c280a424d4326c59ec038f4f1f264ca13775da6bee3621fe187865e7df5f5a89a9beca392b7fae2ed50855cb24a2c7910b9055250d92f23ed68b93ab196d098bfcee964631cfdf5d14297ae636695c41549bc6450103f8937437a247281006f82e78f2f371365ba031706b462e7a4f3e23f03677113f96063c06eb381ec156eecad91f7a936e6937d520be1a0489f177e440a953c9ddad016b5f38e7fef6366dc79f9a8e1dd570fcc7ff34dd5d15922c7454fa34c6aac5094fe0099c82032ff8d8ea923c085a5e28f4eb25626741a3137ace865f695f7d1ef511cb5ad3a9e0a5de262d759a67dc23ec08f3d3310968f4737e8052c311eaf37e760572f6e995efe7248ca960518864095ef2f0e54997050a49b031d93e6424c8f5c064c7fd737f0d6e1683c4d0e7c8b6bd57aa7ee7b03bdd3969ebf603835ba4ed4eb224f0362026b7e4b5feb3f8c65572d9bdca6c661a5baed3b6b9f4b138cf8e30f1626e9a70792bc3962b4afc4ea10e5647ea42373fbe9b7615072b91bc0704a781bcbb73712c799c1ca3e5ed9dfd78f4661b5fea9cd4e5586313f9d595f69a8867612057cdfe838f9c4c1805a99ed3b1201abb0444af83d42460c054e2e6c4812f4a24b55bb09ee720b0d81bbc2687e98811e52e93a3a240d0d971435c531d29610fe71f17906229ea8e75252db2174cf8b419c450c679721f37a6b9f061a33172f8806dc1db11a944828627e42a92b975205d25e31acc6f507c13c16deba90ebf5f3ca83f256850e861559475d7c7c93afcb1b33da2d215945a9b28c109a19490f00ca1bdc51e6bc8298878d69a8f9012edc465ac98f63ea313cd0757d45791a8c944a545a8d6ec89e329cbcc8f0327a40dd2a49b0adbcfa93aaa991ed202bbb3258bd0d4d8d51363777809e173e2d14caf67d2cb7d0556ab6428b5d1a5c0db9a191cefbb90c03491eb3aef4126b2182f4ec736e2e5f7bc035432f35f36da52fa8f7d85271da6fdd0439e2625a1ea07b264ec3599290c07ad40d3763aeef61d74d52fed3e3d385d7856b243f20ef660e69b742b320d1c8aa08d620a235e40cc8560a4955369c9bd25e61a8822e25537ca2b790f89f072a5bb1498eff398e6a75ed40fde5998127c72c40a002dc717859a870915cc58f2b7d64deca1b75a91ad19705e56b4494dd8b451efd900803fe6c955d179aac6e7260b4a8bf71a10d6d3832e2f095a046eb6df5ccdb427c066159e9f3b544ba05b4eb50ee3bb237546bf6b8057ce3131578871c9f6f0f083db9de49379115d5cd114685a9723144487e71e92a7379d134ec232ce8f4abf467cae7414a50f3979f45bf0b40bfc840b8a3a4a22f9e4019db526f5ae6ebfd33c14deef8c8fb714f356f38d1d18d3af182bc8cb0f6c7a552382ee2aa2a63fc8c2f5d5d9165230e70245a1fe0a5b1885c31e03a1fc7cb51e2e3a3c048e0a260f6773bd54d65c5f6ef00b9ab10e5b369fb4ee0cd1695098e692cfed7d5a5cb0f2e0d448f4bf994a2f43279b4edcbb5792039fc850f5d480689123815fce1f8d142600701dfa774d80a42e76bd246211a44caa444ff7f6a8417dbab5b63a60d8f419e13c12021d83fb328ba4c6ae89ac684698049799310735d97a672356b45284fb78912c7792e7a1f4a7f9ca021d87b60f5fb8767cd077a5da8f0fd441cb05e8008d336aa24fafa2b30976a2ba3a9e509e59c6a9b1165f04eab231f44087e1ce6606b81b4811ffda774624fe52c304527db6dc11749d1195800a50bf14f39338d0c77bd422f36563b376633adb1d66aecece82b662152997de747820c45586590b2e02b0ec5cc90883a4acf175f5121a81c059c1683d78e3ea354aec9264fc44f8ca4c684c03ef5419336faf20ffd8185e31cda4634c7e628ddfa221b126da6e796d98457c14d408c0b4b5d8db61218fd95b7a033a5f04de16083b8fc9eac9fffc6e06086bfbac7a36e3a17d90a126a984a4cc555769fcf4bb6d51cb0950ca9fbf10902342f52da62a436a144761f036fe2b792a8d319f91f89cc74d259f7b81dfb7f6cd70ea8022423e311dcd8f6518027e7ea261873beb6a9cd273029e817d60f2b9fe39e0de2a1021cd55dfe0c81f80f25d5c384b8124b51b3bf1aae2a8e1429a2df3c75465497e1a296fa550ec49621191f45aa98ee32806f453b72e7d21b6dfc8a97791506c145b111ebd44c5afc69a2678b2967894342e72ecab7c9bbcdd8641d815ca3e8b4db20e88371d3e231ac3a73188f79921f2d26b801887bcb65bc7c07266901606d90c17f1d69226f4e7aca21d8650edcfd555d01583ee56a271601049fe112044477ebf6fbb2de2346d90cea04dde41b1a23b46344f6eef0ae2b5ad49680e117990cc1f7483fae2a68d12cee035801b961c1c66f063ac6c877d9290b75308a148974f461bada6cdbc64008d6255f3eaad9597f13e055008134a4dcfe8449943d1ba4c94fced885e3fa7f17c58a227047eef258a9842d881484ad535afe4d5713edaba92b5e065f5794a941d63c1b5301a2972d3bac5292c9f4418fa","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
