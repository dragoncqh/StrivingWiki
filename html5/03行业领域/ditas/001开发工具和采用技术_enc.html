<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"584e0ef7bd0997b87f6f7c398adec33008309813f9d0f78b605f52cd53a2edb11242499d1015cd8b02c3bb3eb2fdb4a764b92bc5e823bed527284f1ba6dc5b8c64932a66ad838744c30fb3aed0905d00fdb45e0df3366881484984787dca3883e674ec10b4649b49d1425f4bda7b370ac7f5b253cdd0c51543301c187231e58e76f396ed668764f371cf1cd590b8eded97e7b4755c4e792a234e9139211479975065ef0cf3eb85495d7b3eec3516aa11b58febc237296923112bcc82d00bc1ffe90a9f62e4957fb64bb11b72d11f41861dd635476b2cc7952cb62342819306fff1dac9f9db0920b21d495f204ba2a9260cd5282b5b62646ae2810155cc84f9dac4fe15e9fb370adb6c55fb47356ec7af47cbd0819da8928dce076053e4d1b1fb589e96988acc6e4923a83f6f679183a7893eb408fee9434a9fc606151df141999c06c9eac5486fc5ffbadf18798f6460ed72927e14b5c7fdac24366ab8133831afe096ce0e208b5ec3ad1cdc05d9a7895fff07715b5449c6b4b036d20dc572bf6f95db49c7cabe542b00b4bcf45c5029c3878c28f8510a3191a0bde06146045ca77aa74650591c636c9b0656163de2e39f10b4ee6f647114caa304ba0f7a6c992a26ef2bbeee9bc42a1e5c65c4684f36f78697aa1f43eafd04f239cce7dc8e1bed80860a156179c2c0358fa31b7d9ab982de126f24043af9c75d9d1d8c7f7404dc19767e05cafabedee6c78d4c51118b939816c38c2530df0b65006fb3aad270145b0d24766fd2b71a8a7a518f9442e9565e20a674f04e72f86c87499d7912d59c71f67fb63c78151fbde067e95e6b5008a0aaef35cc0473c9970f970850e74d343452bb68de46fa5216a40b15b138045a724858683b560f0a46031315df34195107dc8ec0f99e4054e898cb51ce8e3403502a10da84a059d03d450960d0246a79e0afcb305154e416673dddaec03c59020d09bdf45da8d3e3391d614f32108c352e359b667f5f7d7ba85cb07c268d6c93c7e25bde77f857ab0026c9af28e025f0c2dfe4099991c71e2c61b2fd7e326b9aa102516b9670f51819deb62e8c76b5c1652a88988196c7974e9c9c20e1abcfbb2210b9942d1df727abd54c5c065bd501a62f3394dd9b9b075b0d9e8e86da1b73295c10c1506fa01eb2e29a64688756f840f8f05a59ff52a9d3a3a13bd3f6472d99f4a17aca0dee5c9576691d2f0c4d46519d8009b9f2ca1c946c56429a8c215c937d69e805533e5ff298ae43c84946bbfc98343dde16ac51ada9baa8355254f1820f4a4d9a969edba98656dcd305c548e979aa2bdfb5b646781042b8e956dc3fbf2355c7daafe901f9097bed1a595ad7f353a6a40e573bb0ff5a6c1a27a275ec5ebdc4bdcd62c3936e9d0f6cdaaaf5246d80fec0833891952665fe9724177ada1c06bbec2b69b5132dfeeee4268584fe77c29dc35550998cdac8786500c8f442bc26285cc73312ae92a9e970d40328b553f5ab8240fa8df033680d336c23ea9749b1805107ddad6d597dda728ef66b871cafe8575b6c85c3430e706ee772e53f894aff104e68e659c02ea61c42a9ac1a98dcfb51913d7ab9696b9222c7e3b174db360de6892c8a586651ac84389f383b8d16c36294117604fb75b173b5532c3aad67178fad814523ea2c3ce113fc82758cb37812ab6be9a55d34b671190db60119ab6e1be8eead8ded906b91ec7b65f0ce20c738fe9df988ae9aaa879e3ff8e80729cc6286396953a20c30008313c11f85d9d79cc22822870679e9aaa4af0ed4e6f8c0329151d6b71f6cce9e5f4d3edc280574267f4fd4ada361d3981aa9d1afc02c40ab6689c629a811ef891e5b1307df1eaed02f0a04f6232377fb3d2018692cb67064636ab9c4742ebcbb698191a3b94f2257fdbb3a33d1e47b6e567e87ddc0551b20661536b5adbd3cfd680256693c3bb841681ff5ad9b87af321c8aa9a782face0001f6f2f43c880df90ff24197c851515a3b242b265f8af41d64ba3194227629ce441c8e527484a179ae660b3a52770a790288212d1bb2b2a32835e36f59783cb27799daa39ab9ff633f9c7f98c34643774a1c6a082a15034f31b4b285a814432539223c90d659b11e5b709219f6665a1dfc3918dc0b1048a81227ea6e9c38054fd9a5e339563a6ab88aa28fdadb738ee20d11bf3e47c081b5251cb2c6deeaf1c23444b581ac38e2675f1d44c9aca90296a8e367c458ba6cadb6b84f25c31f84a931975bc0e9b133373d41b6c131e169c5aee14ac794bae5417943e6b855635b8f67c538aeb159bf24956fad7e67fcb78b060d4608cba91b66b6ee21349e8f8ccb660c19a020a3ff60c6899e358bd9ac02144a841d214db31512bd29415d51964c992342c2bfe26f019465c3b8dd00ad0f374ad8934253229e148d36c781c7c8b4cf22754be356c0aa572d31e0b63b8d2ec84a9e966d27b81f0ba16e3d1baef73bdf6d7abb132285b4ca6f437989756f5725398d33a811b32a135609a1709399845e48c58ca62e6e7fdb2e6c8948b21b307ab96ec29218d93d72605885bce2a4bac2c7f34c4c9da27719cde98976cdec4d7bcde3460d5dd7a75e4def09e94971292141b89327ff152ce306711a5d4bed5a247575de2caba14bade7ba124d9399aa70d7feb6e04ce5f0323140f4186437693a0c665f73bc1db75391b0b5ece3fbc6e771db7cf5d17299efce850a4f7c620bc4db4f85250c4e8b3dd355ad05eb435e3f525442b0a6fdfc6ed20afc7fd719c92628070bc5cc12ffb8c6285706e06b3b5586c10e5de1ba61e2f356b4785154a238ad34080bb340e6b7f56ede8341131eb09a59a50c35cd623f55e5e4a681c2028672359301895ed2aeb7ed5164f540a33b2b6eb9d6f218715f765d4a941447300945ce953678d40fa983b4ce6de4b5740b01c44176591711da91ab34c0c40eb7ea4b0d702fb48cd6895cc5e561e0f7286561f1e9c0072be83e89a2f5520d6ba8ed6469a91c5390a4bf007543c043a137e31a04b65f515900b4a241ad76f7483d89fedd6fa44f7f3257af191408de4d2ecb3fd8114380ff1c46c55dfb787389c49b11e560afceee4b1c35d316f04bd60ceeec5c4b4279b321a291abec90e2ff670eb4d2f9336e5c6378736a2612383fc930be2cabfe9ad1db1cf93754067e61d3120e194d2aa043f464551a02f2f7f95dcba8030322b57d14b9223e4264886e0c27fd2895ec68a00f2310a70bd26daf4ec78c1fb022e3b147c27fc279e061cb5fe734ed45c6938aeeda02f482b0462b8acb8946a32ca0e6102d6a29c2bbe6b4d45f3b58b0989fddb13a387c80e5e5528c02be2b132b85e2f65b4ab53f07112b0f8d905b034d7ccd57e300592697e9994fbd7b05f6d5774b602dc84bf05a163604c5b64d6087952d5d31dc688160f695f84d20939a7398e594a79b8a355cdff5fb3f307f33019b7942fd24d75c98b97fa99397e84f3e30d7ba304b235b751c7dead075f64403c55ad55bc4c51ea9c3b93ab2831e8745b6d2ed82b1f7e53a59de03ac8733b38c2bc0dd1d39ebf747d8105d783159150f5e0b47016b578da966ad618607e50d9c24eb1c8d314a3cecf5b157069f8cfbf48258ecd551f521d63fb3114ff3730a1b030a1881af78590951ac781809ffbcb8052055d927833b57a16e4e19e3a8d08c70b858f82323b3878e9a38b705f0e33287c45af820c482649cdaf8230a4a717ab23ec34b26baffeae6c07d5f9ec4e3aa8c0dbb18703ff30243f920b79aaa74c46297e8aa7ad77638034fdc4f697ed05a5254b4fe558edba4a4800648cb2a45e750c4bf07d520aca25ee70aa58492ffb683f6f77dc9c3bf62be92aa9c9c220be63328f2d890209806d078b341d0c9293e27225ef23f46bb45644a5d566c358bd5c15412aa3d38a9850703dc38a613856dc0441b575f08c8bde9fcb3f850ddf5a8a088ee6105640177392c731c1edbc0170559e1da3bef79c5bfb175a9ce7728f441b1b08067634346d5706c85113af687c0b3ee4ea5386e6f33c36d1b18163873f53b2116a29d993af20df05f6c75a19eb6057006e94d336600b3ca11fd47533e13141084f491fb77fe54f9095293cc594a4126d95e9a5ceb80b4950c6e13764c32564bed9622383dba15ca9da74423a0a07418df39095bb6f1f01b66165058b70c76c4c832def57fbb68b0bbb82aa0b8a1610fa04f1229fe10b5d34189138a1fab0b7c3db67de298a468d74666e145d9cb53fa8a3a2b29191b8e2345a8e4e2ed6844cb6fefe14da4484429fa1ea2683f0ad2215c7608e74430553b53458d435f3f2046a1bbfce913c94a0529d49d32e920030e3c1546203e7c495e5436658e68a4078b02ac6d8bd41c26400cc6ac11c64ee602592e95263222c91839a8c831ced23e76e9e5cdcedad6ab8fb79294abaef69021744cd987658eecef62359c42a3e52304c99492ab95097c34ea924f21deea70f220ac950b9b36cd3e4821b3e4622b42a8528ea90e9d21ccd0f5551ee9c7dc6aa59bca5f6e030f459b6ec03fa882a4513ef5065f791b3d72a10661d636ed2750997ba08aa371f398c05d57999b2b49607fd937ffb37c7c51ce7a43855150f8eb75ddb7365c61235dfcf19a46240c1737bdee5a7075314b8e4116f83f03a02f61410b2cb3ae288f8e652488868b8f438afd551c872ee12609090c36c35d6af883eb45471fd6fc1907807ccfab3daa3b4993b9d4bdb331f38ecc5b2ad99abb4d2441d5d03ec092cdd100f8a277c49e5223aa008d4af4267b5671cbb65f251d0cf121ebe2f1d9f2e317ca77739942f36c6861445d6802aef0f940d7ced70c8bd3d136c73a384c8f6089f61c6550435a6c64a4783675b1bcfd9bbbed0cd9bb072fe158084d70779a3df28324b97a3e2b6620a08bc1edb79e248a31813e1e9b31037260dcddab72c9d2c34e38fe0c333b762e4bc1141e7b97acfe13c3cec7b8364d6c515ef31d9aee620f9fc05258b139a347a0dcf95596b4b7e7a18dc0725455ef4a8268a82d681f80aa84349f07eb5949428fc69e0b6255b2f0e70c3fc3f5d215a1dcd0a65231862a34b944ee14b8869ac744e682b3b2df730e610db4c9313c5fd3ae151aec9750313e440fc979e2aa8405d9605069e2416cd855e21d7b77fdc8900e601178d5cae77064ab99d730c55f5adf3ea8e1697458c014e55a1afb970c28d5daf0cf02c6c478812f4fe6cecd2b9c2ddcf38ffa62924892fa08ecce4fd18f36ce57cceda0e1c0acea8271cb8e0b7455eae5084d3ae331613efb0fd03c659148ad945d456cb5ea01c70c977bfefd3511d587e92f8e7f064529c626bfbd653ec0ea989adcb3dba2727a2eef6f362262c9c175444c55eb850026861c9b8c59998dea365b9cad9feef07b2aa2481e881cb55e7ce8af9eb210dc148ea8c18cf000d0265702ef1a3778e6be0ed985d9ddc2377fd5de05103c3017874e357537e52f3ae81465c616b0ac654ef940c7d785d0f90040a78a3ca5750f61d68f7393562d2df6a9154814d13cd62a4053a44f745703ba9231af9a3e7873b8407771b8a2ebe0148d4ca4462109593436d97b27c9ed6f56cf9deb95d1e7a7f8ce74d0be7812c824b64a1ce0985a26e9fded7f52b73796f5f751ba643eeaceb79aeb7b29fc69f77a69ea7b13ad691fee5a961eefa670357874853bdbc540248969bedc1e7ebf6f4c37cc1730f4730db624a1e8bcc9befb9e1b62f937aff04a07b6ddfa01d11d97b6a342b3f73c9a54962aeee7e02ba80a6e8f200ea5d5c0e19ecb40704df10ef197476084d4d9ef8700d4614cd1473806fac8393c4a7dcb52fdbe4a91fd5b34f1109b6b8a3d4d1fb24a4e5c706096dcb61706f1d3b83fec20c178108d0d7040e200f52b08ec08d869aa6df07f32d470e9e58d2849fbcb722e464b1f0091780f25184ffe528e78faba5a134daac61e7ad6b059d6f5cc68ec900db27883ee996203f819bcaa22095ae4bec8efccd3f2c070021cfbdbc4721310e8c259284fc78de0a0472e48d04f592e46c59d991093ec7d49a8a141822563bcf070971766e01ca183ef8d33e501c4182998235408b8f6392a92b800cf466a9e2dc22acebe0c247858f00d4f2e3b54461f9770ff0e44e902fe1b6a0faad82e733e74e0f589daa25f520ea0eb84a394888873438beb8405efd9c1672a00bce3c5cc519686a5143365cb6ee766724cbad396cc063826a496b33a2841935897d018c59a71a26f40617cc9224e66ffa68d988ef00095a3adb5a187531e22fcd20521ec387bdd37476b7318df58f77a1375500728f0c26251cc64b57c5a257a771ba9f67917be1ad81952b8c401e00aeacae3f38352c0f85d049aad323602a590cd61db4babd629f7da227fb36b4164279e78fdaad908176750e26e65bea3272093777fc5a4fadaa308e481fbb4d5209a26be6bc205958a82735d72c65147e6acf03bf97e920c6c4d899da7087d02c918055530553ee41f3189d07f376d826e860e6434cf06d646f23c086fad70cf22040c1e8cf629cfc2d0ad6124a30580236dfa409a69a9d9a0646eccd52bd1fdcc362b53ac82bc4e585c0b89d276fdef50bde78fc3ca09a21af4932ecd2a30da2542b71f0c900558b99cef9ef8528ea53922f91b5141397941553df44b6c9dee06da59e2e0b35cd0ad8ca36a25ae2846c95383fe7dbd6cebabd80650bc26d5f89b5952159d3f387948a32a5b33a22e1b6106c778500b868460aa7c974d97965982e0c75ee18e8ed76d574fe716ed8fcd4b9f6649f088e634f45d1eecca5ade4cfa80e933c4823b1fdb6632bbe5005272714cbf1c8777791c9e7b0094d4915513205234fe8baa8cfc76959a78e07252495c7e5f6c62483405c827d0c9f05726db4f698b3b42dada6dba2e82bc849d640c775fad746eb5d17be2f965a8c9b09efbe70d792bea5aaa4e71b30a2baff7145aa402811a65e45d7d965f45d8a4c9cfeb011a6d570f486be1192cac1015805f8e28ea5e4c21a9f6bc34e1484aa07e4911f9a3d6b5c2f54eec8575454383384726096027f2e1f6a8ace242f7b33ceb8461afa63f5ce46d1c632b2150b4126004e2d00b75d6845a85cffedd3cdc62af85744af2c798c6c70dcefa1fcebda87fecb0a7fc21d67091a8a034e7f138114f697e11faa49b4d6b80a88b87a1e95489229d354b50cd459c193c9dc36470b6bdc2d3fc701025dab3681b9dbada0244484dc3a2cb2b733ad22e19d2923d376789be2dac40e5bdc8986906efab02fb5426939def98ad43938f8e2b24b17e92c27af0bd96d8e1b422bb801988a092dc91c237cda112242c9da51398f9a6fcc8c493f622ab9c26207b1a03b06d8082d65d7e82ee8144500bfac875a7934ff19670f1e60b374c747372979126e5bcc927679843a16a9d35ec270d32d94694801dd2fcc89d041fcbbf1be313da824d91dc4b4fe654c87f2b6fa7e58c73351e039b2dcea71836becce2c85c8af6b2da29b5fd892e1ac08031708ca9dc97290616ce6f3b167a0918da75f4ed702cfa8399126818d57a96e4cad1a6185d1e6546ca7537a88d965cf31f67cfc66a50fc12750ce34f81be6b619c3f035e123196d489c333ad75b75b7c9c14a43537c619ffa9a9459312305fafae2dce64d8daab5a16d7454e3a430d0854cac89027abef19fe914294ba5a56ddcfc40a3eb41690edd95fe4dd94e83840523e383aad3cfb2cf701a0e2ebc8941705a22f613af1271a79bb93a891383c9131ae6f709133a351886dd72027be36438e23aa46eced34c0faddf0006fa3d6ee423ce2c1bebb1e5b13d8a3fbe3c792bda587eaa92ef7a5b97ad8689b4f0f496fa2da8ac75dcb0ea27eeb66302b29ddd41ac0672400a10ef39883cae77f3830e393a271be895099442f1bed8912905cd1f0a36215bae4a2472b15333d7d081b9849eea3540605a5a0d4011e8783a6cbb637ff44eb21855a10d17bc3aa8bc59efe241a842e999e4c2ac67d381a82500e18a1a1657555eb3a961716c9792695e94f08d9b31eb95dc7cfc72ce56523c9d57c233fb148581b5f7af3c001237c564b8e7b22c43f18dc06de909c78b40a6f62ef3a520703474816c6e034aae86afdd82ac13f769f11f5ef0149c6ef7f65cbcde1881e590029e598ae934a578d8b39def1935be62c9b4e83208cc44aba0a985389b0114531fceec71976d236b6797c89409a24d2054c6c21ef46c3e1c7537287dc0eefcd26995074f8e556bb5302aea1f935f5cffdd3c18f9b4357ff40eb33e944cadde7f1e1d21ea789c19ff4da85f9a1031601d0b032b00404ee9e77e5c393c6efc8ddea34b6d96707479a9ee3abb387031b9834acd7692b6a11affaf9ade36f399eaffc0a530b80bbf480a5e9b364c8beabb0ac83be5e9b93c30387accfae092b8e8f8c2fc31285e1f100d880682cbe1c458607d9bc67ce51515b35de1bc1660100f69bc53c821ddd9e49298683e6a3a72a05d134ded34605106619f405461b3b68094061fef92b7df32b4132e20220ed8bd890dc1cb780a43a0b49dc01210a5693b94424360e57f96a065c609c80d7a865306db1b4917849219c9e6232b49aee618a8cd6e118c3c4baf079be990cac02ffcc558dfa9bb7ac4cf46cfa3e9b78a7e91585eb514daf3d28877ad4789928f481a4b2d24f1dcdcd6f9009e964e6345e5d953c0c6a32896dba44da24e6ec75d42f9bc6e9bba7fcdc0525e869aa0c8fa04e6e193afcc050a0172cf7ac3f827d6b7f6dc6f9acb69fb9575e71caea6945c870fe278943d4e531c804b58728217c8c6f4e6f2b81794d9a1e4213b2d599debd719d8c823d0cb910396b3aeb21e23e73a70beb50006c4423f1d77cfddb126144e1a5c68006e5dd9825c72b95a7724b066b9bfa5d1d5ee29518f41174776938ff5296b08e4bfcf23b856ac1169a374175a08001abf9e1f8c389a44c186aced7b016de2c1c364b0312cccd44f78586503b79b629c49fe2a225a5139b5e9c7cb467d50f2869e65dc44b469373b4c5bb53b1b95e1f03d131f0ecd43d8b0b0837272935bd01cf63e1f2d9c6c365a0b991b551ac9511a4c6b24d48c216bde18aca3d938dfc4034ad894efd8809219802aa48b90f6ca58e9f2bf683d7703d057aa976e1e3e0f2b35d41dcc7b99239a05c73db8149989da855b32361828970065851b0520a8367ac66d525f6b6d957bfa6427678c435d1b1cb9ee6516321ded140df405faef8e6b701842a6847789414902b6a142e678e5becd967cc10399f660b711e84c2bbcbd75101453b65c3cac4c0cd52041d158aa5150ec0b334e1c2f5046f7af8077cb8bdbf258df1c5cc47395ea1627267fb3d288b2320220504daf29c16aa341ec4e55109013cb38fea51212db807c2171f40f8eee9aec3e265aa43404d6d4307dfaf689262af3c53e208c6fe73ed49c394a947fa7208c1e531464273b3e4ab282e0eadd9013308a99351064697c612b9db5da7a5775bbe02a139140c50bbbf1d0411e2cd2d754bdcaf8e5e9f087d3160506a3f6b8c62ad1bce2352a3a05351c5450c69045efedb0d8d9d39cea07ea09f089256ebd72c3730a9e113b97d98f80791d8744551040b73b353caa819f3108886bbb5233ba17e9c1d0dae0c781c1ea9b6aa079b727100d6038890c1eff83d4d67483ffaf80628af917b931f9b1446d72da2eb302c79da25c875b3de1fde6480ae03d9ae49c7506fdbb589ca8da49b4b2bd8df96e56aa91e36313b71719ae8788071a4d54d350cc6cd5dd9c1c51ed82e85d79126e33fb40dd42c04902c546e60b1ba827c0cb9d187e31fe2064ac8b4b81a03e0ec5ff30aa6a8eb98a21061803dd412bd3976d05db043341bfde3be61f40cb455103eedff92187657c72e31d45a0a047cc64a7515444a157017c7b34c752c86b895abb23668dee1312d6cc7f88c9e774141d9130a95bf7d9705db386a2b51012925ba3a7ef2a6bba4f176871c349b3ef4affee56a14cf0ef12fc9ab65984d667266e5172d94b79d60e7bc4acb2c75468835ad4f549554dcddca1e768d8b65939da9ef1f24ba79b91c7cac2ebcac37c34334946ca20e92b8925ff984c6d752ab989843443b42dd204827726b9ed79d25dc7bd3f0557296d6f6f9afaa4f2416883227e401c629a6e0b64b63446d4405eee87a98ac21ac52844cccc44e18f08c6267b606391fdb26fee8d66550719d4d7b8a3b5de929d9eb21e7e3ee9ab99caf191158c34507550fd0abd8f9e6eb1ca9f6447342eef1d50805c44e93da0b3689d4d8b3365c3d4cda2e75cb0f6f4e45de025dd0829bd7b300b1566e06fce48faab03120e441abb6e782fa006e104aa67b7d107499ea95a658c7e3a3127bda2739f5d1f784cc16b687eb798879375a61fc0b921d233cff1391916d30c7f7255f39df0744bc5002fa50fb19774cd1c5f0449a2e4a5b0a49ef90a153672bc1f6c0583f71ad623309d0a0c404968db2542b1458c6e67e7c6ee76bda8495a50711337153178c4a6e79e942662d340828fc430316847de3e14a75252096116e9ba88531dfccd20cd9151992d84de02fcc94bc7566d1e837bb0c59daaf1dcef8174ece1c91256a02324b2e8b20f62b64d7e4c094efe31b033beefff7fea94fab14e06bf280dfd30fdfe68c20b6249350a7e02a2c2569facbe1cef0b73e4e474965fa5b4ba89ecab232e6b0bcf07eadf97de5ea471f8330d87f5d929e612609dfe421d4042b2dede3857cdbdcf00df1e17eae9096d879bd7f2faa1e576e7f5f2bb9cb994b1ab8482967b1484dd12c8fdcd54d1d652cda2edf1b33b9d86d18b0b4cd952759a7fa481ac30465ca8e52da01477128c9be0185447e160212b6dc6274512b2e5591857a69db6d13e42c6f7c2e9c8f614e15f705f2d1e06b61ff125e04fde907f9ae5db60acc3526ee9ac818526c88633915eb71130cadead283b96c80a79e50d56d52d6691d613c3ca8c6de34a95e11ca30aeb0131fd28f1e66fd419269b78fcf47fc9092b4a23c6db94fdfb58ecd219da8ed078351f681d008ebf3fad30aaf38cb508131b7b59010911029ded9b01036ff91761cac1f807d5bc791b1162d4998c4af1a01051f4c165de2c54be51b4aac9039335b09d2cfc91171dc821763d17193b702a3c35c7e086ede39527e33b05bc26e20379a8419655cab683e00cefe460bf6e41e60f20360472e41a0440e98cce8cb722fe91fe072bd88f4f3884a2b8949fae59df1cdc9605bd572b51d7f648e0133057a1af8115b4ad9d654144da048d71caa89a0244e27b186bdd263a8dd8608cf76812e3c97ea0b1533d7978826116aee1aa4a207a318f772a341511dd3cd9a2c0a89233c8911cd22798dd904b56df2d964fe28336cec2b64045c0365e0e6a8d8374b85a50a379213805137021f7ed78a619af4097dc0e84ab4590db992d9d9e0ba7591e5cfa899a39eeecbac423817ba834753efbcdbbe516920947a4635c96f5fa65cd9e4f86bb69bd5ea3de9148c2fb716f0077875ddbb3674dd35be4c9b0ac81cf19e166562aecdedce812da4cf31ffa0e580d3ff4ead9d812a75ac701e448ed297f2a162b204547639af418cbb7144c048caf0702972ed033351c87fa2a8f82b97b2108e69f9e6aeaa6b3549d64f921680176b37fdbeb97b9d08edbb3f0bf87021eb625af73a230745fb0fddec3f37b98a29a95f2fc7c3d9a167530ef1002c0799172a03740c4a180fbb31a7ab9a3f1825ad6ee0070c862b9a9c3c495f715574d44c4caa3016a13d085116f376fcf77bdd148431c67b13f77ef7b1fb59fd75a973a8674c1c56867e0409f8a7fcd39f7b3a17a9f71867","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fe727b3ec2446f3e9140a7a09442f679"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
