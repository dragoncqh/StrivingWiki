<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1b2b88aa9345b0d2ad5e8b5d260b349425ace0fdfcc2024580d35bca37dc781e773acedade660466bbac9caeaf151bb4777bea3336df6f07850593886209904b1e104e0bf1a0cd95807f32eb94647e1c1ab8d282080bb603ccc4955df296ac4933389b0b443ff47ec1acbdb900cfb5cd94c86fe504e1d1b2a4a31e617cf482fbd1a113d33b1741739f4b50ecaff5458f33b6e2c4188dee69e066bdcfaf0cf2660d23cb18d4deaa50d9c329a6c24131160fda207d5e488334d13cabf2553f4fad381d273c963d6d951973bc7f9dc6368a44236a0252a658f406694e5b3dcf16b59c27d9284022b44e8912298e933dcf089998380d76210d05a6621d8baed863758783aa95d0e1dd32c129ffcf0fc51ab2202c9ffd09405294256f8e21285125d0ddc86082f2bf404606bda2ccda1bad83e227d47b4231e6c82656976e2ca361240f74541ab4f72bc4f9a961826e774cbe90292c2aa1ef6cfcbf1d5b9147c5fb1def2f9e6395e310fa6e80499d95887ee533cecc4815af5a93c539ddd7ab8ac82ad2f08bda58f5c50d8fa0313badfc1f8b8774accc0d805cbe5746d8a3384277e1e5f5d4a16da6d025617d09c1fa260db23787195a65084d00e3fd3bd7f66942a27ee50a492abf7c10ca932563e8baa6d7195d8fbf338cc1ec8415d4bbd6c7572a9e0b3e6d65ccb6117edb45d2f360deacbc2859bd7cbf0c080a7641436e5b12f388f48322d2c6802d0928f7d4376c652f8af7c6f94091f0cc90de3fb895c9a72bae2d4a46b5d8f1a1df94fdb510446e030eca57e4989dcf13a5aa65b83ae42ec2db604c63efb346cf00619aec434af4344298452f1ce2f30e00af5797e7b59061f12ebbb3bff64d80138148aa982ea71aefee89e17050e48a1a9da8de8f0c7742ec4aeb86ec81b69beabe430f0043211d79503f91bc8ec81d93075684c4ac9c78978958709c535b806053f1e29a265e0f84f690f6e2d49188375655f61d6d50d9c02440f0846a2eabb58436e72c0817ff7ab492f34b475053de34aada76a98cc5434691d4d9e329b322704b317083f588fc1e699656459dfc13a43b7abff7ada9cb3d960ed63da21a7e6e3b2873cf4ea5396f174a54f08e7b442378246941c8f19cf64e6e4f025002761124bcc681155ecd53fceadaf8e949e443573548f003ca71cd583be998b9a474d66d37afc1afe547333fe4da43200efaefd38d7e1d901651d3570489301cadaa58e38429ceb9a4d8c50633a88297221386703c6d3ac9dd3457e3feab1fd931d9d78789cb2c161ea6d47347f9169a565e0a1a5efc03232e16c40a3e8e096c49095ac0569e55646c49053916152c2632adc6e4b8dd1f6847fbf03678bdeb4633d99e96d93a1a8d2e03be0b28f56847a0bd46c6040a50d7616ad5f874d762485896490fe1184a69ca89ff0d3fcf626ff5c50f1fbf72e1e0c7913cdc31d7ab20736e9342ef909de4383340492d8d7dc2f7c4d2aa40d6b2c40bf95a5ccc78358f480fbe20f67f2d5532b3a88383ab2c66ab31fea1c1b8de84e17d3cfc6f747d5e1bac8ad998e08b48919c10a76a1dcee266f066020d28d5ac89ac0a07f38485e0b0efdeaf456e5ab304d970e11a8c4354687c533953888804caffff46a5f5a78ee822cfeb0ea8cd1e6c784e734480dc6d72caf7813c8f111cb7f6c3168b53e0188c64843b3c4b892a87f7b148b6ff9b0adf03c3540abc587a5d6e463874379c41e4eea0a0cef8b7d9520c729b4443bad36079467b4a164cff221cf0699491014f6d474b8e5b74fbeafcde5685a50cf47f5c42819e54334b606e34b670a36b95f6b9e1962d9dd77443ff6619983c48cdc552be5db3469a530761da47b961abefd2c3e3e3e37d446540ae88cfcd0da12564aac53c905a45c065aadde6bb1d3a1c0cd1f985c53533476df5786cd0b1b0c9ead1982bdf3650bd59e117606498e2bbf7c5fbe311c49a48064a7f84f66c10640532fa2cd436bf04d600050864c5b3a5fa75cffdd856186976edecdd450d2e83712c6bb14234a0bb1caa00364cef954bf58ccfebc0dde722d4c4c6caa8b41daf96000b5c58d864ef6b683d32d6e3c606839e7b62fab469b84e87bc7f3c62a405b53763bdd7823aece57b5e289aa6cf83405882a20944f4bdcb0a3f1d188261fc0798b90bd4faee9f88a76f6fa9f5cf5f71e49e34de536f7e06e10b1e53892f99250d1200b26533c1150a2a0df62928e7667cc96125274cf9ad3c90e3d0840821e8b1f867ac7f69281f89cb28819e8c8ba5ca2a8060f7522de20cb2c68dd24a5c379e469d26037adee53d0abee632dae8ba27cd3c9aa4c2cbe6b97650d1e8ab4314a2772d0064f3b3a91d104febb88a3705a516e64c54080fb38c5d2e5919a7ef8ee51227cca123bc0cc93d170afc00c902fb8fdf779df01aaedeca13119fd4c83bc95caecc5b3599159bc956c8ad441bf2bc057f65103bbcc3df8f8acb4d4e02a95e37c8a23f264f96a0b1791029645838a58d1c78971ae1e9b88737358be58590ae28e10e2c3678e8771c75e37db3572f049fdfb11409424401349529556c725eae025c82378299ad0b59eaaded2bc60d87db6689e093b70cc66b6808116d06227db2150e39b9a6b959c28cc07ab67d25d3fd2f265c90fcb31fc3928e110429e547b20943a94bcb45c187e25acfe06d71244767f1e8ff36b32d594b688761792442545a66c47406bfa2deebba5fad5b2740daf32fa7a3151487c3512c6300a762a269b39f158df17837422109b0d7024d301f766b09ce0c9d1380a441f4ca2249ed0938f4059ef0fad85020aac6c67f51e6657683cb78a29f675a66097e81635a798640630d98dde17398d4df94c934d239416f9ede2af32a7cd6e8ac1f357c70e3818ed72ca63e5823db15c19873f3d88cef1c879726aa010a4e58ddf543249a384ae4ea3233401a23e236239209aaa0d8f843c353babdd9bc7e4b7c36c0e7f722658b326ce9172cc7d7344234110e82d23099cfa973331bd4a9193d4c5714562b0a3b707582b4791b099876dd353f6d6dd0cbfa4f7832095b3f6c3d8cc2ef0463a17c01aebb4e16a49b3db8ab5a46ab7d9737e593d911d4dabf9692a30c50a7aa1b06789130e1933aba61dadbb3d656b86f4419ae0c90658e16f8b509ab01651b08de08cbdf465a961ce1024117d39e926c1bd6d30bb403168c5f8100a3da2877e4223e89473556bc3fc3fe8d2709fb206386a0183dae99f427930ea96930d6a69ef63e6180cbb5493a3471271010004949eeb8c96fde91b604faa705314e2cc38fb91c406da00f0bf3b41dbe3fd78462bfbeabbaf3635ff84a95505d4d3ff07aee135947a5a28a1e4d3c6019e9d37f71d5171037367064ba467e273909934828a8034e733a85cce96c8415ee9e4dc8ef32404e10b1f41601d7461ce9b2ab16fbfea85bd1e44c5b229b9c5171e59874afa92f4ab8559f147747bd25141811b83d0be0fe5e3fd21b48390a932cc43820c9d824b288f142873c27f8cd55b857c6b6ed9aae47a4c834ca5c3374fec6354348a205004b9de651d5c58b5973cdec1069791ffc38ca8cfaa1528cde1831fe470d2fa1dd1de77a2b4c8780283250400dddeacf07f15a1ef04990c01255107fbd88f4c6861261a97ea328e8687cf5f577f9b8f7387238a6e5f5fbf15cbbf330983ca6865a7cc6b50fe73077bec7f0e89a1db96ce89beb9adb3763bc3cfbc171bab74e153a56257db3be444c40ffbbb485d8fc6834db2185538accae036633633da0aa98147ba516d1922dec493fc4077697ca160cc40e5854fe7d658b5f1eebe0426aa072694080eea2153864dbf7f798648cc08fa68dc5a733ae2a515a619f420534955cc2276b63533aa0d5942594ef34103c86788dce87ec903e85c8159926f0bcbabc4da60ce98342aabb2201a3c068fbd1dc6cc6bee464575b8020bcaa4d562306b4dbeb859785479e572244a623fc155826f44f3cc48e5cb41136bf45345dc486ecc0761c5a9a3a3020392b1cb27e882d0216fea4ecd6beca0033782d644a5c10d993a0d4d7e48f3e995c8ac1397a859abcbb28262b566b5677d0b2f7342cf0213ee38ff440d6583e2a7147e9300cf8320d1b37583f95d4a28d9c40d959b9bc4d328702cb00adc575c32e01d6aabee99255d4f91fc07c2741f98e8fbad111e58c640a4347d594c2ccb1ff0f6867c46e9ef0e8f64087c6b7e63356b3e119c058879b7f88a8259fd6baf2f695d94b9aa131137c70d969222ac90a26b0ccf73a6948e2a549e5367cd0b17eac20e9617d70c654fd9c2d437bf0307b5da086a957fa514d87d06fee1ea39f0b6f710b62d362937c4f3f13784ad5e3f3ad7c47a7de8c8ab78fec94c940656d167c856c4a8447402f39306ecbd12ac06f6fcd6b95f6efcb474aac2b36a61bf146409d55ddf3920907c73a56d593262836ee6d5cb7dacadc684949a91199d0f7c9d2a80f99bcb77145f89d7a50c39f285e9eabce370f569fbc4deb9881ded01478660fd4830d49558d40f739c343f09ebffcd93b19ccf23d966882ff82734ed36fb3390ff1dd12dd4f38cb216cfe0d85cd4aa0a63e95f348698d18a8b7dad7a41069f013b4f91b42d053f91ce60345c4d3a3ffe8c2af5033d9c5905b954bdbdf95453a04d8451b70e51fcd2d3ea9f1377d437b09cf8778ded70461a21b591466da33974d2e58a126bc14dac9bb82291b860098285886b7019bc46646c7109304d6be9dbc327c753b72809ccb22aab046d8479ae3742ae120e801897091334b6e632526ef06c8ae404fad668f5fe3654aa30acb55d855527bdee59a015b6c2d2af49e8d56b5e56d1576a27de47289f96be774a85cc8191ab96ad929ff94ca28ecd4f8db09be244ce78dc539a77a092bd9c088aa4b41ed28af7db5adb7d123df025e279c388d2a7243107cd30ba1a5b3b115732a002ac73a8b58de17c1afb9d21d0f23dd05de6f6d80b82e98c0ac4b8c67c14b072361078e9dfcc241e948dd9a093c551820400283620b1f889c65bff4cd0762a5fa90a7e900d1248d25815c35780f29b8fd84d7b0819ff059acb28a3cc5722bc26c313c47438dc015a029c807c72654c1f9b96086d0d8a0614be7372a0b530a3341fca003f90b15be4eb6ba9c491bd039fa3be72e208dda670bd6321d478550a12e3bde5c75ed21aaa3790368775d291257b228d17e65ae26991a956aa24b14f89d36df050a129033a6c696a1eefe4a37ed3c4930ebe4d1a7f6096c80c3bd4d10ae4f4ed328aca570e7bda5e87022eb9a8352b5d8a0d36cf21f0b55955ef67723b0b7045d02b9a463f2c12af1dfee0f4686e62f42160113be2c2f0ab013637915166891febff0486d78d08cafe8be992964a60309fd673aa86f06292777b2ef56d1d29d7aafe11ca830a73a083780a6e88248323bbcc3099b315f50538d8538429d1c83a5a672682f3a732c445f12395c47b96505c76594a60153a463c5b32cad09697de5ef1a4133a46b79e1528dd3f46f9598974cf8cc00ea6440cffc71cac82481a737304f2e6af91aa4df977ef7f0ff1d48ec05bbc7301c4e619ad0c306bfd9dfd4ba9a0a1900248e1754949c1659c90cfafa825b37fa6af05dd16d4643cd23de4115d64b541c944c82b6d9d07892089243261de64bc43db055efd9031079df28a6548b8ae090e142f56b1ff561a112dae803a69e78d8f6f7c805aa487221283f46c4601fb4d5aa2409ef85069f20e773bd7ecb2ed349304c45b535d13b84dfe88f11777586a5ae1512555a59334ff0caaf15ade429a949f36d68be523d00304d6b40c16d4ae5adc043df4256195b2a02e2b83fa7ab4591785cfcec917a60ee7b9412cd0519fdd27d4a4d0ef6e12f927455713fc5cd21d18925db5bb5da208d806f454b121552c0b761666efb43066fd03b2ea1fa190238f4527d725fdc28f807107a2ed7fd3d8ecf1ad204f489f0732321dbd62703af8341d122daacb6a6e85e6e6f486249f12af0fbaee35c21587f37cb90dca6ade669915bfb7599555853b92bcefb84f53d68a7e7b810b62710f64a80c1a2182937faefb9c33bd1d3f5578beb3d356bbf06d3613471ef5b311d1b2d3522fc14bf987dcae5fa687a2157b2f5a842a8bddeafa220e3c5c479ed28877727ea16f7adb2f30a3a74e616366a69aef9bab62d4ec1fcba9c8c9f8bc2bad194055f75837a785dca7f1cc5094172793f09fb5e05b7d3fb3cafe7705b86620325df45c18ebf93cf0179d615831247ffbd6b92943578a1841930a5093d41c100fc9b5c783609650aae4da53e8531e399ee32246dfe320a042ee9c1ec28aa8d33c47019547ec2f0f8c0203cdb66eac1ba04dd82110ce905897e07d2fb8f815e05ba06565e2d110293a91afa2f23c06880e47b259626ce69a0ae9e0c5f01a69761a1922ca7d8398f89bdeab3fc88e3f00f519f1bc7ed1d19552a14cf23e9d8b59274d45fba2074f1d7478746860f6040e57a5d0ce41e85a8e33ba9d7c700e5f4416c012f07aa859616390c1bd0db3033fb3dbc3619f9394add90f375a6bc12975f3853b080793708d11b7ba027dfa96eafbc18e92098a709f74a6be6bc4da3e47ea299acd675e0f30642141e631b058982b5e6caef6663ee990710b7d7dc820623791d6bc79806ca9f1dbcb1eae1c78d48362d0b7b2801014b355bc692c22717dd42c385949fb097c1844733907a3471dc6765d3375d003cd401103c509f16e249e985949e58e2442c852d7b06f6934fd0d75558beb01ba19165a18816d207777b245c8ac465d6e33890d740f79da49226b4a82fa0e33f907553cd3b4c664bee622c36db03e09c04881a1f95817b905ae441d79bb169975fbc03b98ced1d1ba479ef90b26371d1147807c0c9222e3008b696863b5624c99fa676076104833df65347e1f21d5e839d805f4aab5237b03dde09de11e368103cfbc8e9e7b438492cb3aa011f4fb6e2b1df7b2075ae59b98fe6357ceeac7522cd574cd659801080e24a4c60a533993bf8a615393c6ca7e201eef94dca6913baf3bf18ff36b1b74028603850b8f858a43692b094e35b40266dc449ab4adcc682368beb18dffdea8bdac5670411579881e7e00c5ef9787a7643a1e2cd80ac48513378f6cd1a865323d6e2551aaf22b9cf61c9be38170b72e9c597596e02e1d20380c560562ffc85779193d8295adbfe513fd2d81bda59d1afea2dc836e054c23596c0bdfe827e7ec674f5e72aeb17765b2bcf773da3670b06ead277adf113f81c3ef938320ad60e149652aff7229ff5c1ae9589f3c4c10c1dbd5db176755a9a06ac5b51229146f7de7cad95574b9aeb9acd01cafcffdf9f4ed2aef6c1bc6ae524ebf86241feb5f4c90dc1bbcf8655fa578ad9749ebf5002a2ed48580acfaf869e590a67a6eceeaeeca1ba09924e01e1eac6267319b5c1fde1909a5f2c8eb1526911395e7b91212fde19a142287730f2d6b12ec34dc741265cb9d51575b2a6f66e106f73893e4cc5f38c180d3179db232bb2a25122e818d55e68483ce8c71fc6e3f574888a56718394423e58259499c934ff78441ab4b853a141f9065a60bebe94c7e25039bcbb3b92e8e6d759be167c22f1a32a262b05bfdabe97d61509a4899f1a16b1d47dff945978a5a9f6544d9a49f5a6eb8779bca8d6967438221285e59938f7fc15d81f0a44df0a19a6ff66aee734617a5bf0054c2d93e83cee9b11e5be3c446b0182df742313f2598a6c0e22d8f560b09ce222b2e61ab2f7d7fc65b81c19e2b41dae3abad2616ad5a0633eb881e789b48926023d64b0f1a51422aeace927f48b0722f4c7a5c8b5a290bb3eff6b3bd7632bef1145627c882a5a283e766e0e5d4ba5bfb514c48720854008ba855d70c4bf201252215ea77ffebf4ac5b39778dcbea758f5e3761a9554acd0ddbd6632a6f939e69ccca548f027ac18bdb3a5c20dafc13252344c719b30ad103b149a1959538b665f70c0545aea144125de9e46bf175385ef3c5ecc6f364c49ba802cf46b60318133320e99a26e91b3deba1a0d026dd38b7528b4af496ff082336fb7e7e809aa8da29f65b9419d587e15201d1940c08fd0630cf8202726c813414095d3c7a0c61635f9a7531b675fcbb04346557d2b8e349d3a50d3c820de0f61f5d500cf8c6cac91650bee782dbb179d278dafd6cb6f1aa7ca28b3f8213334d92517122f85129d74fb3a803edcfe2e57bc23d681e47dc096c1cc3dd85914bba8f39fc2e3a7984671ca32befd08df11c0a8013b1a429335b0ac1e01655f5bdbf11628561d48eacc675141a9f3b0520d0b80380053f3a29187e4b4cb294d3a37426d960c33d9fd0ba3649de0ea388a116f12fdd0975b2909ba1210d94c4c5f3f59127022bf2a76613fb462af9ab6b7a1a727d8b022e0066a5604dcf29db386c3032230c6e7c8e6e491943d3b2ab9296fedd39ac30329e727d5411d9c0176aeebc0f91e3eb3cc946028ec108a32b5a22f1e3f46d04d3c98fb941fa16e95dbf8de7e386e7a117eb5fc83dfd508c64197657a3d23f78d41cb441be91a253edbe4421b679db173a8de43973e91618f575cd5f04c175bbb6a863424035de9d8ed864c6cf0e2786712786c73446e2c8820aa35caf65abb18bb0534e9bc6691453d2f5d3292e06ce358d61eb71fa73544312da6b7a94f0990f9461b3fd05b404e843e4e7367cae71e649a3200ae4b41c829b505776c003eea58392eb7db28dfdd5efff1fb0b525388b13c244566e1acec57e759405b6e6fbc640b65c3b0bded532e8d880c5b53d2ec80c09692d59edc21983bc0b2104d85ef7172ab788663cdb59b8eb5e1e54a25780289c2c6386936182f7ea63421992f48267871ceef9f9492b8436bc3a0f2e99df8de1115f111ccd04b13792157b8d77dc405548ccb6f6815f2fe1767d6b4410be468b7af4ea44a555ebb2b102df4f0856bd5559145aab976a3105b3b335849fb8b695bebb8240881e1b0fbe544a475d38c6feddf91e66eb66c859247963dd1df5111697bf291096381d7691bbc74c4c1950662d26df5f0792b1762a71063f5155d43c6fbccffd4bc5069c1b4cbdeca09ae1390a02e34ee21f6119291287e248f6c02ff50fabf42e1607ac344504e379be26095bfe72b258039200ce05c68118ee6651868e01c07a56b43e9395a81b7923b7b51ee6834e4e50094f2404da880f9c488005fb560e1c3421a3b5f358e4c733a237457a52a1696f76baa343c94500b2e09408a51f2b5f9ffc264d5792d1437ad4c39eba4f3b91b24c18b49e1df025ae270df66217afde354fdb828b72fe145c6542154a74fdcd2a74a07d4d1955b76ae7feebfca9624d783ddab12968aecca5ed85ebbcfb4e888830c4998b961a9c2c5910532842636b4b323ef4a936c75c70f662a9f527bc0f38bb841109f99f4a5a4e8d6e01f09b06c13edd68ca009a83e01c6ca4d73dba695e591d6aecec30b08057df1bb16f4730d12940cc2b223205fa4e77cea3cdca040465d1732c70f8a20ccfe386cc9311d6506281f554e2f0f36eb43591953f1a1f253a966039f6b225a4230e0bd8c63d467d80a67bc57bb9f0857ba54c5d72155879fd23c4f6b8ba55fbefe14013b65af98cf6e4054af9a0ec94d50115c11856ce97b334070c7be8ee7c1576d8dd34f79d3e04a9e742ebc1f740505f2b2453681de43cbcda5c2c5fce5aa6da48c774693d315ca4e2a750ee135dbf11bb06db4564be5e315642969565415193ba4db36966ce27cd1dd62e881b424865e7c0f2e623c1ab1d0f89e11dde743c6326fad62a945bd14535eb1b7076ad4a54c851847377489d7ced96e46f2e6a4a300d7e66a273e1203c0f16de75b3316dda0447b5c61e17ef838ad74ab61fa45b5810f217db1015676a6584f6e9ecc710afe38a40a5148ce040a660020f2ad3889e3918fa41f2a6c469de8b8b3ee3217af0cb45a30d497bc5b0fb40a73cf39450920e20bdf1b2cc47ce601b0a52c95a97795ab5ec9268b2f6807c4eb1538ec48ebf0a97ef548ce40058e2dc37968d91b5e05f7c8d7ef42f64fc96d7ff4f8e83db98ab19d8d1c511258f00be54e285dc0138fc1c7672056efb9d49420e0e9ab2270d8d99d25238f5371b7d90b45baca6ba31a05086d84e486ea039fdeb7d75d615b9333ffe24301c8e2662d1b86719fc939322c88065427651a26187393ef0dac56ac665f18c5bd945b134d592803e8e9aeeb7365815c5255897d17cc23a214411aab95c5700399be553aa4ae33d7e4a8b7c056e55fb51bd9f7f82785db7326109e7d0d7f3febd94cf51bcf91ce243164b6e6d3d7b8a9c0c4e98e376e9e793331de1bf36a4201f9ecb9423b55b780afb63f4706b5ba19093834985bdef3c5d4db340ee9fdfb831e47072e0b4c61ac0aa43466f92085b52b54bef25af548c4e27aee1ea448eed4d8f7438d126e85b09d29f5eb3b62ca39909434ae3d0a4de3be9ea18a87603e9955cffabc0ced79e8c02dcde2a72b0aefbc5ae664cd0cd56e5fe9011e784e2a239d7daa434472da76088f72dc09dbb0388ae1e77b967d85e1ccf080ff96608abc9ab99c89ec1df9e167acc5a138469a9dcf01b49a497e894a9d664b0d06d8f77df8ac20af8e2c57201517322a6cbf5d41c0ddae69f8f0b440f0a285ea0b244d011eb3251ceb36346fa47ba7a9f1c13fe6c0c6b5d7b8349bf7a9c0151e7785f27f65e795d524fdc8bc9aceacefa99d4c3b4d57c062f0e014c3bb319d82ed3c864be97ece802b9a3da4c78a62cd6be78b33acfb468fef8aaf77265930ddef2bafb5019bad70d20e4f4ee665d7f5f5c532c41e6d826b44e7fe6c43af69b88c01b2ceb3f16775ad6c196eaf2c3251e34f32407f3b79fa45251d61ccf68d56a3ab84f2569cd7d66fd896fb81ee121657ba167aa391fbe557508ca56d0ba8159eb7c7695a2838a3b7e773cea9d07211a8fcf7cd74feca8e9c8920808d2878b35f5ff9fdfd00653d43b94713f332152eb198449f2696f708175d67c25282682453ce7546ad62e24016da7676a4288018ca2ef90c5a52440aa7e7c16ee4c6ecab984eed808499a76deb68dc8274ef47340d6c2300b9e1dd3d8d364ea8972ae3d3ef59e2144d94771b50703ebf56aa7365a59622a894b6005d80533d1425191a1606b4023ba4d9556a1b03216745ff7f7eea65c2ff8111d204e88f3767d83c62e259c5ff4c875c8af13484bfa42cea310772350d9578c058cc1ec07a12590b0e2ae00a78234f2079ee0e706dce19f3b319247e2afb6084b17459185f83bee75f34d5dfba4be8bae1d50cd5ab0daed4376725b4a6012488e5dfc078f12af66a0478156bee17292a59a190ba3a478d1c1a99008e04c495869b7859baef8b5d0a4b052f8625bb2165692296399d2b0991db6bb0fa6f422d43e7aafedf571404bc89693134b82b0ba69f8d237d8dbb99111b85e7df1b2b62be6a2491b72921027b009391a010a2473df32562ce1436d6e2ad790ea56cbc9bd568accca3ef324eb20e46ada873b42949baefba53a8ab3e61ef3548284905324684357c73e0f6566db7e30a888f25efe6e6654961f6d7d9366f7db64f6f965bd66a185f4b4704efcdf13e09fa6aa36616d569f1138ac1714b29aad91b60293569479f39e355ea2f967b428e8918b74f35257e5fed9e87b32d894649bc1af02842dc95a74753722728a4f5337f425b153ec1064149d2f48e65b7b3ce5757e97d6410909a805fa26f9b52478043f89332e9d971df1cc94a70474231485d11005f91de34e9f28523be4d08d7f1fe8b5763a1149eda1798b1542e5a0abb582615f398d3c0e6bdad065a21c610e3f22381bfa7df893b1dda0c599d6ef283359cc2e104cb0ed63f73657f74367ad3c9941e4b4c0801d4688a551aa6eedb1cf05972da8bb0fead21e6c261773e5db54638971b8518ce970bf419ea988e957f88ee9e72d86891bd940052b83b02ceba49b516de5bad773e5dc58582a5e0db73146b413dc267ad1c016213185d269b8915f2ae7a68644fdd349ae6ad5006db72d0788bf9250b4c582ad12e628f91866b7b012247edf787bf9fbca0a9a144c9c13cb97206bd423b395523b086a078eccf225168841c611962352453fb5a1ce9e8bcd86ebea7045b48a3a22071b2059d814456dd0471a22f4cd99f09bf3e6925e1f47e4cc4875a3ce78927ad571edbce66638db8d3cb41413dc3e64c7b2abe4558507fa99a33274448ed9bd97b7c0e8a51511025930df5b6f4dc12e21bdaa23b856eded37807c2b0e8c1343d0267dc47ad7bbd91cdec5904c04576d46d504d4d74c3a4f414a5f2f53febf191ed52dbe07fbf91b600c66d21e419b0b4d1a2ff15ba92ef12c2407c994dd64e8a7844bdfa943573ca18e7fda783a6af03c8b5dbbf0b3e15ce050f0e87421360072f91b844fea72acd1f15b924ec1c81ddcad86e6440b4023938e4f1f7700510d4a6d3b8faf5eb7e5b938503090ce0f7eb70efef85f88e6e18f5757e901ce00b8a4b0da85a70cfd4edf330f1fc0c39c7130603445b1a26077484c3ecc5dc6cb355fa6c20805b78b3fac6601a14473cd85969b6e16c624a43a64ce6e1ad9ad5559973f64b7399fdee099458c1c61fc894b84a04c75f8f2d8b986d953861091bbedd4624cf8564a39de36e247aa8490a5cf897c7d70bca8749b1e670998a7561c123f36edc7cf1b3b716d9f5f2b5a81258fe26b1655ed9bddcecc4334a709cd8fc04f803bd7cafd1f28f1ddc32056e5637e44acdd8b7ea9760eb52fabd8ae90f326589f904ec5728b5b7c54d50e896c051508111338d4845c415095158c908857ca498e3f51caf7adb4088561fe095f3652db1819afca5eed9a4754b889de3ef39bb31e5903971a2a28ed864e7880ab5b4c5807a874c6a99050de32729cfb6707e4bd5c016d2a1cd50d336c1d3398b346032ab7060356001f4ed8fbe5b155a4b3f8a19a3be0336cf544e547a7b563cd46cd355d62d0c94154f5f70be76f332bf2ff5c8fe9c6bc0e8b6c5fc7ea0d39fb4c95272e90a7297f17aa21e896a4b7f5dcb4c7d64d665587c96aebc60666e75472f96362a40f551b4a6e3e9ed4946581eed8b653c4c1eaf4ec01149735b026fcd94171b5ed45e796e4bb46327f56a80a22c8d15fcd32d889e2e993d09b2d894f2f4d32d8141c75161c7308443fa6e5691940c33ad49870b5553f2ee7c373009ce44de77ce0454e7cdccac6599ebb342df1c6c963c9536cc86e26400be868ad2f534ff324a1f02dcc6a08260a21900d48d6d1eec0869d8d03cf83787d057bd28e3c487e9f2945c0d868446f07976941b795a4177235d86761698bf02b2a22f741ff2daf644a2a35119dda89ad0dda16ec347fed1dcb32c1e2485930160b15ebdef3c9e3222f62a03ac8f7dc5126af6035244de3960824ce97490b03e28f2aef9cb41343ffd15250e5cf8dfce9511f5cb0d405b95005982e71763f329745f0380e3f6b1a04933ecb2484f34e7b36fe8aa713ce730eb99c638ca3af9631fa0a8695a507b714b4cbf5e236b7745ad240c8c213f6d48cce09f4951b3b81a4161fd5d46664f2c03cb2789d7ee629069c7cd5bf4e2b6e08e35d5d1c594518b498ec8166df85600899ad7c0e4b3d51e2d73250e7e140d68c7cd7c1e00dcef7833b92e713f01a93f39869aba52a05fcbb04f113d9932a915548d79df29424955e32cef554577d3ad7d070e50b95f97912ca8497f6a21e4c5fe05249205f338d19def1cc548d2ec4d305da659774c81f0e0004246c1368d2f93f577768bf99f340674a1ff75fb4f09d9700be4be16094aea2788945d7a66f08a4ea38dcd41acfdb111340dccd5687ea6e7d3eb7a592b6b34659f4c5337d83030cbdf1fb49b726235bf75b47c9e0d4517a340f0ff8ea57316089ccd4ba00bee8251e28b165aa8fa5a13ac0c485ae519e00375138d4d8e458234035eec7ed9a0c0f0642d44e30cabf9589f618a144ff2cb400b1706b9900bdcaebc253ca943cdb1068bc09318fd9a1d6775aa6387209dfaaab1007c657f0cf47612e5681bda0a87f2cae188e998d0b4e72078941de27357f07f0bb5f3d2572adb2109ab383f586bdd6436d73d7913414264db89aec8aacf2da3bbe0acf7259c928bd0e989650f42ef42537e75797c7c97d0ccddb3023f57caebac3b5fc93a0acd1c1c83f9ad6dff40e7260035236e75fd7c9dfbfc9a2ec3992e52db172f4a1e6d3ebbdd72e89890c640e6f458d49c0f5524b75be937d4ad1379e05390c71f034e50c09760d1a08ef7bd32edfbed1d1cbe945a487890352307f85e350994cd617e9e0d4299286956e2e2c7223891480d44b3688981e9c15f752962c38c4947e655e0e5bf5602b9a45563d2513850178b3ad6b139566c2e36b7bafbdaa7a65495dd9b975fddf134cc54600647ca18f027ae83d74a11cd749eed62a23efc96f6674cf055a9d27c5a766864be75412a753b6417ba3ce26e5f35f386b28f951b6212468795b61f424129ee48feb1eeda60ef5a2ac91d3ecd7e8e8a0fd34dacf88c20d06430eb73295780b4cf55ba10065cbb5158785b19bc89dbb19bb50a0ebeb94319012746b8df2d69186fcc77cb0cc872217e537edac141ff1de335f6e679fe147c03a32f8748f75526847f952f7006a4878071ec8b7acc87ec81028930065878f0a752115603fdea106e1372955f9e648eff13dba393b06648f4030b575cec47ca96ba7528747daa55d58b9342579aa3cf2eb7c840f30790e239225c9588395917d4999aba1a2d6f4038707aa110c099576b24fb567696985699c9d4d87368b4d9b6eebdcf97bb73cd196a3422ce52bc2cb4d0c3ea274c3eda9a68468824b90076d78a05218cfafc5fd45ac4b3971e22d24891465aa2beea17b2b3b365922baff92732223ad5fd2f697c953e48c8b15a3d7d55de05a52ae0c7de2d53f590631a2e79c97953e49eb3cf656574020ab7837ea2f7b63919a9c4f09eb9a7a8cd1a91d759fca3446c9dcdb2c16d3d3ed8dba69d63a5f60ae1b54766df3e14c4c6657759cae66ea88e1709ea21bf71b45336ca900d3c09c3903f9599dfbd35ff6feec062438980d1bb7f119749774a727d0a1d32446559348cea49454e2d5aa49074519f6238bb9737216293c495c3419ab9878f2af96a3b22c45ca7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
