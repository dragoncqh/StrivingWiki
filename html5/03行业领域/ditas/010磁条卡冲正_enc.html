<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ed8ff8720ceb0825c87564de511a24fed7e3a2861a2fc96ffb0d97753eeb3417f58d585a957708fa9b0c0d71e87b55ca9a1a817f5053d05d1bcae5b92e039c7558e42628ffbf3c73a300b642dd19b2fef161e11750a1e78f1ae8fb581030a702e2fe795ff977525dc333b0ecbcda4929f5eef0e566ad2e8147b05671a2997d1d296fcab18459e2692369bc2b6f00fcc8b429ca9dda91992f9d456ad6cb08953e7202304d164598823fb0dfbb0c0510d68ae08a76437cb9acb174153dd595e49730b7cc7963c91325826917a676e233b988b36c1ac6acb467353d94170f1181557cc44e5d7c704d0f0549a9e69043e5e1edeeda485af7e7c3de879cb30e53190534f88bb3342326b2f15477706ae622da2135a52991ba778a7b7574712723885d7bcdbf544f495c5fd8cc4c8da4e88cae34aa5b8fe5e82dc75be2601a6f17edc634a46066f88a5a233560e745b6ffe5578c2a1753ea5bc643ebeba2021057385261c5ff976accd3fa434aefabb2dad5907423f666272ac48ccd8feb19e58989bb8ba4219956b7f1ace1939d1785598ddb41374d546815154ab30f86096ab868968917e673dbe6308d2e1223098fccde3fb6d109947be491d4bdbbb73e9c301651117935c4bb93fdc954ea03560c04fc5963fc8bf0581b0918c21848ac665a86bd7145fe312a5b4429dfc8fa14a45d754ef53de2c51c743d82a9b57583e9c4539e7d6c3b6cdda34ca4544a1b14bb8a9d09e3e2de6e0a1c9b993f6070ca5db59043e8be987c2a4e29137266407da50de47874da3ffda27240033165228242c55624f2382a23ab83b9881452309147e2f81116c6f2dac62a343d4de8662d35f16b3180911bf7fa8894adfef07ef528d53d268e1ab007e77654ffd490c19350ce91fe923c096fab27f7bfc0b0e75ab02c83474d5d4d6a5f1142560943779a1f3cafbedd50914c891877e0d69c4f024dc137ea005ca0cecfb38a28a30e76bfd7100cddbc23dca428153ab3bea3e018d6c41366d8d91ef10b305eb9d98b82ed93b1dc946211923e9b562135d3b4117752f03bac7375f8faede6fccfcec68cb5c53e38d619a106cfa8a65732f2437f6704cc8ea23e47808bc99dfbcf6d059fd0332475a6889d1a2d0ff4e4628573d3adf96294d7f6bcd3b4a0455997e56fb051595027270bbff42337f982076d4ab55af2d2c0f94a60f85f9ad215ee8735bd3017befd830845e0c10e30d308facc12e55f99ad476bcfb4a88079e3bafe7a313169df1bf005d5e0c21692134efbe91fe94c17d9c812f5dff842e4ba1ef868c4a751980a8ef1f4cde902138a7847e9c59ba7501f7f86f518521cb350064d8f528ae9a2a7402ba3c8cb4b91ef34baa7c61b75369aa89d4bf87ed5250819531f3829fe431f76de36735a3ee90864245c66428cae7f8b86a0ad2f65a4a7c191bebbc13704d8ff1593f19d95f8b7c2e365a428a922fc9a0d6e33c8d486667ddb2a33d63b5e63c27d80919d447466b06cdc8d4491c2c2237b61fef43515428aa2396b405d9680e9acff67db35d32ce16cee37044fb911240117f1af9fe1fe677660be8f67ace89ff9aa53739abaa58a6f3a75c231aae60322a9dcfd45fb6a9dc2a6698071c06b00d513443e285e38d0aaedd5888db3370f83bf1b7687907a44f270bd2920c0c40a501cacc8e5bb1fe10ada5f13271c2f1035baa482cec123ca61ce02d45a688e641ed45cad70bd221d98df825be2aa8a420afc0bdaddde5ce72deab1219b0142c176de05313cd36a449ec647c151e7cefe7b761f8c80674492e54d42ee9f8482fd03e68f21dd4d9a86255b7478141aa826d5ade5ea8911e3e99672c4177b81548bcf8c59abe1f8281bdf6352fb60ce0359ef29b0d16f646e59de28b5a12f31d4c114a56f55c09c0475790debfe15bc2abbd21b79f799ef9a912e345f4fa2d52058e5fa02990305cd5e060095716235fd73efe44f79e5537d8b968ba17dd8894a8e0a28454ab56701b8c21dcca4134a8c985f948205ddcf94602e2bd0b1cbd377a82b51f4c595ba67d740527e7db43de629183dbd2a6565f25a052770fe5cb860ca22751fc89eed1ed0137ea283167ca4d1555b68071d63445ef76d74731eef4c2ed1139837b7a4a92b9f70a71e8aa54f4f92aa38bb8f3a64091305e62deb3ab210c01e2088b45d407f1ea8660c1dae900cdb0dacf90c268518358eb6c09e32add697903a156cb68811c6c95bfed27aea586afcf0de77c8975e306e7a21e5e72ff2cfd21a05ea3604a6dfc2b08e2947f82ada7160449dc011f2389184beeecced720370cb044b008e2f6456cbf170937bd7d04cbd32245863e52ce118b401e17e2500917d7530e8eda67184c3bfc00e550856645e2ad9cdecd2cd663524f87743fc8fba0271dfeb28084e16723e581fe76ec620200914365d45429fc9c89e2b405ac65d9cf7fbf9a5558c4c0181e6ecd01071e47f4b3dc721c0d74094e2736956c48ceb3d1ab38e9b0e69a57fe7c5e02a9ae779fe96691136ceb585a10041c7ce398ec718c26483c0058e18b217676a83fbbb9c2cadc5bf0833820aeba5082b2957af424418a576b5aada9ebd0344e55daa533db835f64035ca3628ccd9387efbc20b2a4591a5cafaef4423d189d5ce0f3712edc51223c2530f72c1b7540e5bca3b44d306fa7ff16ac8de0d8162137369333efbb35a331e0a7259cf383a5dd0cbaf5e37a26fa107a431cd0bc775b24f38a0221a2d9fa3ac77ba0725036ef6d7d23a61161aad9abd404c18cc35ab205d3f42c0cad99a8fff4b24d1b0be9d90d265f4d0b843852496c7fe1d9c9055adcec1b30fd17f81df1155ec8f235dfb2d426d8e1cb33078b001eb7c872a7531a9f3ccad07969f748d7bc9c9a416177d3cc47613a4a43f71fe9f99ef84716aef65434c9fbce7cd2d0806bb74ce3b8c4d44a3baff7813f972ded36f42f53f6a819cdde8b1bc90fec0d926b302e65c48b2611375ec2dbb72368741e677af8be86a2d5ac1cf1027f69692657bfce8aa5f59bf7bf75382bf9c4657d119841bf9ee5954b1ae8d5dbdf5b7013a82cf05658fd3430badc6cdb6b6fbfb05aab4d9d3a94ee8d92dbaa8e0af52ff34c6b9e6ebae1be24cad189af5953fa6f431f4d7d287d4265bab92256dc8aa683319b6a1bbfa433f5635bc84447ef0c71eb9423e6d9985a12895b27e5a46395fa7d2f41f9eb0576bf6e350c72ecd92b12ce4ab920322afce271e9c85f7c41aca103d8925dd24d0e6ec8f7d5e140e109ebd4bcd7e8f4ca2eb288b41b9dad30b7cffd5956460740bd4db38162c7a6940611e637b0dab314c350e79bf651f7f0a28ea3802c53b24c193df88ccf5b7823dcb158ad0de635b603815bf99c4f098eb824d5f0ea5cba082d9d1ec1eb46cab65700d215d33b43fe4ce4753338a17e81476f629a3da48a34dbe0f358f21848de07d38f20d361e4e2d244db30bda1941e0b5af3fee544cdd32448641bf74d26deeba03ecfd2b4e3bc7ebe354e2ac45c007ba68a3f825a7ee9f8a19df3b52d4882aa742e524b40374e4c4b95c07f0ee7309435c4f294e7c4598914a49b446ff7e2f8ce18293df891b8b5cb60c71e35130986049e72f2ed9fed7eb37a7c1e7a9851adc2a8a25215ebd33aec0c2e6e265efecd27003e30b0ae9a5c83635b71d191e4e93efa7b8a5027ecc2dccc156e3235bf3a28138821b8ef455a89123502b924c8109be47c47eeda43b5e27615c6384056ff712399fe18a48eb9da9713db6562aada2b440ae1dba241dd0cd0c5f91b53acb12de5e8b941bfd815279c8659435baef180d671e9753ac79b4b036214b90a3a59a69b0b7684fc981f8f595551d771642dedfb4386635afe6d7c42fe1ab1c5aca0c070271c9229718b159f9d4da7291277370692a57f4c752e44738c47ea51e48ef4232f1d15942302c6b4bad4f03969ccec20d1d8eb70060d6cfe272d1fc7cee484303e9c4882dc34e07e63a5c0170f9cbde20a98964d1e29d8e8e379aefaa1e8b5bc6e8b0118423970edbbbde4169eacccb5d88fb942d4a4ee2e975810a6af97e7a0853233692faffcbc6768d9b7b53f46e3bb6c531e08c6baa63dcbcda9bebb11eb75390e12ec91776e4ceae4d0bfb846c1d98dd0c1eb6f3bb9b4192475bd30ac66c82c40b80495ed90b95ccff0bc9e136c22c3790f3f043c632fe0b1079cc5d2819f96935e7c6213382bed5e478a195ce2e6e30a591ef83de2057a72198fa44910233cd98ff444e88f05cf7a7f65cc226e5e82e0f02d6c39547f62bee8f7e4573d45431b3093b6393b3f8d040979505ffe18e552e850376239825db7f4e160d7726c3591bbd57b8a640a5143bf84ee55088a1f8cd3d0951fdbe5499af91aef0b7b90f82453766c5c0f8ce2a45542310df8b85aad3aebfb2b392fbef9ec0bd6dcf8a3bb12174a06dba2eb8cfc8567fb13e9d01466a2e661de23c33200c5bd9a3b65215d81701c698ebc876a01a1206aeba75eca7ad834ea0708ac601038412516eb4ff32af8a981e1c66f7c137c1bca4efbfbc761d8a44bd10d8c05d3ba5f885811048b305012eaf5a1bb521bc79245b7a423e15574cb93dc4eb1413a89c8b127cf5358969a7677c5c06d0fac6d7ce5622318ea13d59f3ca7f56b0e58392d3b9042047c3c62991220ff3b2042c40636de3ec7a710c09b759a8de869c5e3252f96ff02c3b52995b4abb408dd8a79acdd6cb219bb709a75a3c314a8f9083a5e268ff6d0074608e5c5a0aa9c9021ed18dd7d4260ef793bfc71f809aa3e887148c1a19ae098954d4148235b3663c1acb961210b7b0ed2703cebb7b6eee295171836d4a72d4acf0c5f5320ca3c7e40e373edaf5a0c004c0d3f58e421d2d4c79d086b5efdd58ac215525d43a26ada9febdcab375c5bd5eea9fdbd50e409c28da9ec88c29e408ac90a9901f570a47d44624a08f8abe05467974bcd5b5845c8e52f9809aaf4ddd09e37191054037bbca57cadb68495ad34e114ba828e4067b4be2b35f89c6c5d1e8672ab225cf8c61eb5be3d8cf126af31b78485cc1ccad21d7cb4141011cc74b97c30198fb13b91089b57222e58e8cbcc94d98181c659d0f73c800bed17f363dd797157e3d1637f4b2c21bf9cfd8fade01c94ae845a64bf18230c614b157daa4779709f0e004ed3151bb530ffc67d78051e6a6672ff7baac4f1beca6d80a91205f158659ae8df6f2fa3b97ae62f0bc10e23ea241633d34b8dcffdb35122c8663833687357b0042f517f04cd78f0783f1a0c2d72a2645972f02cf70bdc52f1fefa6c8ab01c458d9e6dca954c9a8d0d46eb40e27ca6be9cbe83f139fbaed9a4ea3b855223822d5f07580cb6a5b8556fadd384dd46f8976d4331560bc0e11f79ac469bd9a146d2c1d517bc78649624d1164a1eba17e24a27fead95bfd5c167ff16e0442e508b11a62b745f76691e2e4bba39b4c1e2cdb3121ad8f1197a4a466f2f4680dcea7cee7b0c17580ad33cf127bcaf12761b301baebc042e498502193ec6dde7d9e2a065a084400aa4c16e8bfb687d7bfbd94d756581cc001ab6200ac3157623de7b606fae5f7b82ef45df60d7aa097c111feefa2bfb9840b05e554df20490656311a58411dd8ed9ccc3bfb33a0ef46e82d97e2d8a7fde60e272b98887daa9b5f86b2c86d7560fb3c91ad11355dd6e77de68eab3f5b8692ef947fa2bc9ffa98a639571ac79a41aa863d8bf4195d109e74e8da0ab126ae4333c84f602cab9a2d3a3f34c050ea6f9ce6dd9c3277c1d192c691593728ed7cb11238186b37ee24cffd67e6425a7a349e22bc4859e7e5a5921e314dd39758b84b1ca108b1719e9a1028333133aff7f2960c417fb4ee34c947f9145b8e19d8792656ba5a0a3eb4c654a64d1bcab93b25932ebdbb39ddd9e1a2576ee8606ce5a2ac217965fd1d5c11d825d694746f2ddbbcd440ff74acd1d13a23cb3657e3bcf8263f8f2408e9e6a7f869ebad2e3d485daecb57e18afba4ef94da223d8323d04c226f6d89be4f54c8933319862dc09edb640c491e5b2a6693bb9a029c873bbad9129b44cec77d374c186ce886f94624de2eb1fbd56aea5c740099e1573d06bf75f199503c7ffaa6bfa992944f0f1754ed64fd3b76b9064495df12b928b085ff4c041991731f20dbf503ae61fa206a42efd4652dff1c77277b776fa9a2f7c4669ea70b38b45116c3edddd7eb3e2d1eae77ea522beb92b674fb33f6279ea3667ac96584def18a3db78f35ff62afa893bbfbdc388d7105c48a4bfc365fa0ac8136040facd505ebdd9247456d002507cbb3374961eb4785cb9f9816a707153425b82a3237309cbf46ab43502ea0a310dcdba741bd8115e96afff7bd15b4b139b1ca2ce0e479a2365902d4e732a51736673420c39ff5996399966a6d0810dd7c67eaff12626a39f6c6ed956ea22616725fccd45390d63404cb147fcb77342d076be33001afb7ee8db0d58b0420b0fdf96e186602b464c184c6f923b9e6bfc3efffa6f445c7d55d866934f1b76c9f10a498a96c3687682c082e7897e1dabc50508e0b848e3a4e222b5e85b3c9a35cc90a13124f0e23ea9e546074e276ad2e7365f00dee0089c3db87951ebd8e6db86fe981e06a4e35389d74b3ad775099fb534ca47db8676cf73d993473676dd841c2c0967702e2b1b4ef4fbeb258af70caa3b9f16262ab6556988d0d0caa924c613630e761066c90a96309b13bafb0163672980e6f2a71fb711fad26dbca1a77ebcd28f6f03832b6bd3c838c6c058f1cd9d88de7222ce0941ba91082c58de2c83cd3cff3c248d6e727b4a028a513b8a7c21d83eea74db70472c5cb50d424d55f227c8285c989f59eb8e508e3a870f96370209f424b7a50dedd80f15413c208cba8946adf17478a966141fa61e1eee2db431ff6a3b66169aa8c90442f60e33863ad09e560007e1141148b3a97624df7dc3a950c65f8474424727e2f1f231cab2e9814d7bdac1934c7e8480caef47b01e1e05711c31c4186020b5a9febe4491610a6fef5b4a24c73157087628d87cdb8749adc92cf156c0698e94d757bf7a8c2469c1bf3315d18b10676bfbb35ac3eaf03de51bbcccf7aa5e2df636fe976d3b4cc934083ee694bf6df4a7271db697361b3f527309a358c7f65fd6d1f3dc1e6d6a1f1b1bb183ecff0a5ede8f16e4da6fd5868f9212886454f28d5bd9f2fb70ed1b084320285bfb7b7c5752ba4cfc2bad9b804c42d1d90912668dd16c9cd0dba4b374832960ab5c5fc5294794bb99886c509ef8743e55487f65ea7d7df54868f391e083a7a62ec1e415aa4194634cc49fbb242e99e53b4d9e4c5a06c790325b7272a49e23df2a696668e4c9c6be1429619227bf07e77ea6333ddc903779b331bad9ebad577220ad5b654293cbfc2fad629eea67432f73a494012f995feaaae25369bf4ebc64d0d686bc8d024e9e1d0932ebe6af767419a2b39c12b2cd06144cb889be75cd9831a07ecfac848c18311cd855e03d4b5f333adfa54e3fd23893682fcee0b4ea4343a135f2a85f6d07478158fba4543b21841ca6f0ae9a274a4cc04308e9181786da37a8b8e9b235f86e1ec2a9bb48897912c9083a396109cf2205a79e0e7193368ef8a444de7b74bc8570e453ec257f28e5aa8a4dd90d393106ad0b1e92ca55eac16c9254af238ff1cc1a31d1b30fb9b45c1875a7d39baf6c383c5e03c4f524f89baf4f31b95356a3d644ecbb00b18158ef5ba26cc49decfed5dffdcadd3d3de9cb9354f322606d51d08cf97ec4ad7d12ea485d20f914e26125ec14296c7d736482fe59bb718e269fe2897b9d5d85f613989869adb38b4a870a970b5129e80fac9661c040c16ffb717a66f03a249d0b4256faaec077638bf37217ec7f4aed8b88feb6aa15024e93b3ec4c0b3b565dcaa94598967be7fa6a7febba14657f40ad5512675d4cbdd6919d9ee7b4a6a3b3d0ad619d2da51a63a6c51ddc1705e4f53ce6b6510cb2e7bf04982b5fc5b32b2ca2016006a625f15bd5b5746e560c0b927dccbe9b68326439f9725e204c859aab35c4684fb4c7f5dc71f2c91eab387d28b22fb879e63f2704ae6f3381511d33e4178c6e9f9dc1a75357687b072e3e1b50ede552c15a7dc61405f21b7eb7d25279be9b3c4c42221c98e9c1b09c639bf53a81f0986b4a23a41dc195d29138f47ca6e340ea2299648b9bd714d8831556fd2b46f9c7cfcf7dcc3b0bd161ab94eabda5e391b7290e13aa99c348eee04ecd33a519d6162ba67a08cda2dcd32f911ce70d5737bbe8b7dc723ce06e46d444daeb597415b6c7783ead6a1db826803e6430f08e43ce186e205cf3b4c8c7afa398f016dbe5fb3426c3dccbbb59e632b2d89491cfd774316b1689500a5fef19e2ddc65dc3a58b344e93470a2cdcf81c5720a63aaa579abfe74dadbca642fb368b45908e4ba7e2dca96311eed69fe97398e973ce88590971e1a64f96802f903e5916c7a8700c8fda3fa3f5c2aa3874023f45d5ceaa5db9e063e067146332a241d21756fd7fd73d58f33a76c038c1941cb5d6353200006fee239bc60afda2d6bcfb582e8e28d25aaad5a571697d4b6df6254071cdd8d6900e93fb9f9d62f2e78d5d32cb85895e05701ad8b53b2afaa6f9307cd80c9637f8bce92e46307a487dce3e1c557701f844f87bfb7748762aedd14c4ccf12e4634a0bd43576432e44367724f9babf9afcdd9e7a441e8b4db0a686b9914514284e2fc339a60aedf8c54c3e01e88da155ddf9b3991889448a5bbfbe5d335a96076fb64eb3ceab428b120866389684fb938e0032de2b4a00598355c9bc0af697eb745f9216995a55d9bc7f2cdeac094364790e3400c9ab83aaf893470df773133c1a0df18","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
