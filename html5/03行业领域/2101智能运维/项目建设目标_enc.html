<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e9cc7354c3820199bdae2501a617d7d5e8d758342d26a73677354d3613de284e2b789b410a94a0bf4ca63e901b75f5df34296532f6676969409f6960b9c4d53e2f6c06f1fd1ada12aa4bef7c5b201b156b0d111a20b64eab69da009a6ae04dfee4571c8f145164150c295ac46582c88a3e325b21e1503b8d0656ec45eb7cde46456eb90c7708b450f4aebce566ac7bd920fe4cfc105aed32dd325e30a2507f4d88c033fbd184f40efe0aeb3cf657cf0986bc405fd13830015967963d80bdd4e184cdf0fbced6126f8f31d56b72bfbae03b864362336d86c6cd4c9e1f6d48314cc78fe9069b47bab797a5c270699990e3591574654bf30b13a82818bca3aab5affabe5dbabd2faa7dd09a602a8cacef13bae8a548c4a53d0bdd9e732c2706f91576b5088c2b0d61520eaea4e2e64911238ce2666cfb53aa562c0a17a26e855fe73268a943d3bae5bc151c4362bdd893115f028bd82b76eb8b7d069da5169431b453ab5d2519eb66d2b3d6dba0515477421e52d66a46191660ba69a6ee4560ef8e87ec88296fe1771886769b6722ec86268843fa2d9cdff00325100e2b4a6b9f32dcbfeb854a183ab095bb0be999f3bf428b65683e7bf6527c73832b6ca43df8b4819795d07cef472160dd24d291ba990b46e2d30860aa24ba743db2249e2a6249b74bd40fc8c78fb15f32c1a112c1a0103364001cdf564539e6d9034df032cec3bde23365023ac8b5f9e14785259dd532f75df79c4063114d4ef78bab5353d87c173a4f1ad2ee8dcf6afe76dcde6e424f41347a8783d638231e76aa471bcab1819cfee98c034f5bd3f24825f7097813cf90df8649a51071b62f851bd08f6f98a7af312830fb0531f7aa8bd97b8c75ed44fb56f62718fd9e5ae468c54a9286e8559c5ea168a702371f31e6db4d67ccc8a84dfbd9515b429e301265951f297511697b2220fe2b3c4406def4f01684b68d010af01bec825d2bdea19aab02de0ecf5cf5f0da073ef2ed528d8b31c61c744399780ef76e287c00a48120099837b5a2833f132ca1d75229d5918931320ef6f14f1eb39f67aae90f649a2e186597e7003e769278b548710f5780296067f182fbe2f984d8bfe6a7d1478cb460bbc56cb29ca78d6fd7dd66ede34464efaf212c8d9cb59675a88b848f6cb8441cf95015665a89322719dd693b776772598928bba4086060d2dde22cc54de1afa06e65641e90b08e7a7108f572d8a4c954617ebb5bbcb5e0bb8fc077334a00471065ed4b744083bdfb43bd9fe24dc3968e3638d4e71ea64b0785d0acf80c1b26b597f7d48b95a7c6b3904b3af0ca9c89b2732b097f85ce301e368fca3bb447b829376e78ca5d9578d04921289a844886a74b6d3a9ac2b31fa0f79322fb77222ed271edd531bd4a86555fcb7521f45c57e3fb7f778b1d83ce055c6b81c3d032de23845e56af711c27f1ca8590a6f22a0dffd4ed8fa57e0e4ff23c8f3f32a8018d13ee3c4f80e8ae840b2f4ba3831580ee4c757d1bdad6c7f93d58a4fec1372b3f67b2339090398d7a9c3515de5f6666400223475abdcaebad17faa3c484a280f69f4e3c4906311821b184b151b4983a6515a10e1aaa7f60316f6d72f2461607a16b0a16679ecb53748236c5b67b249590556fb966e1f101788c728f47645aea2f1519e3d028df3fcf90aa9350b9d1d8da017b3dbcfbdfd180889544c0586d9f57fd56bfbdb4452aa1f3b957da9ef888ceff9f46a8b88847ad7968d2c3316d94afa096ab62549c9db8a3954c3c91ae0e4ddd05391f708fd8ca5c519781118c69a99778745befe12965c41573de0b14bdcbee78705161bc6523c1b606e8655de398ffe83a17bd891e35e999153c3b5e4c85f4a31ba729114c48e72a77ffb06c7efa11cb93feb8daca673b707a17db3d812aa97af300ded558ed2027f0c6a6fe502068bb83115315913336ff23a17ba56b5beef2e2b0639929d1faa717c5352cb3759339215baf92d5722f0c40d4113616863df1f6bab1698a4fc747b0c3dbf96bb5ceda6bf369c0590fcd0ffda526246fd006eaa87588631b0c7f9869a7f44c9be6622935c0d8e4dced2ec28979ce95483e6f781b5f2b11a006c7d34a68aa8871562c3a3e0157fc05b54b89ee4bd979d54ca5d2d5eac6a4809aeed72a51f155a56a20722d6b51869fa66362da12d569d05b3a748b43d9f2dae6456d6685dcdbc5ee62ceda2c4865f174dabce8bd30dea828e8f0a75eed75808fba5a1307e83f6d8870825f7e5de87f27527099c839abf8a48c819cb7dc2e62d2a1a348ba0daa9b7017e708de322a20433a2a5cf3fd9bfb02e19c47ea0c2eeb00ade743b337abd36cca78771d303e506a584e1ce2431e72a209e9124a7571d748912ac213ab86168af6a2a26115e4e93aa5169699d04992731362997fa855f81588ae7596a9fef904b321980f8c67800ec760c7a976aeb5622f4ce6036de009cee5061a45af17211af7bd98f795f71f4dc5f5e94b8886ef5c81ebc312b3a28e75fb93cbb19d38188d639418f79ec286d5a19d3d6676b172f10becfe93d4f33edfe98b6cf426b13141473cc901a1aa48dc8925a1daf374ed1e6143f420028053808a87fa56ad791e35a17dc4edf29ba37c068de21a5d3143dad3a8808c8ed01dcf1ed2274d6e3acb49bbe7bf3d0d8e60b0346db4b10669250857f292609c4cf46bed304cb8b72a5c5a34db963d37b5719599a6b73bca8fd6eb5b37900406987e69f42fb81cb15429bdeeda3953218a88e8b0330ba503dbd99e6cfc570f7a5e270bb99922742e59d03cb5f7c18f223f528ffc7174257132a2948e1210bad2bb9ab1f9ac39fec241966689d39b64f2745cf2a9981e645bc34e68d370cff0c0c8a85f00a1e888a5a3d3672ef9e8010c0625719f86450cca9d7f64f9a5f0f6a4fa7c811add35902de9128f9be0af62040d2b4740248fd13e195734c15d1c4530662cc6207a777870ee4b1013089ae0b0daa4844b3fa190cc4f75b2d9062d138af975104de8ca6d804131676d39e10f3149f1f805277a98ed755a54e1d9145466b97e9a3b824174052c19041fed9e93a309d6ca948e398ba2912f95666a2d25daba1e421f11f8a3fdbc3bf66625e0f704ca15ed76954fa24cf2a10fb123ce8761e447819e2f7124380d3f8a4c24f9ccba1d61818c3ee415deb8d4b18bd90c511e80fe374eb9998e9a0d5933b4a3deb9ee1fc62cc9ccf5f3dd5c9ac41fe1cb910486b77bbbc08cf769ec352e55ec43684bce45ad58d8b71efadce7e9c2672f5bf8f7ccc9eacdd665c47623e70116bbc5b254f6c15c62d0bb4641b7f3d7918a3cb4d1960134a0bf55b79cfd94fbf84fd63bdcadb4714eac2ed676fa6423b2cad0527ab86f30b397963d77686c81159eb880f5791f02ba498ea188aa19aedd1ef791aeb87460bd8498929ed7cccd75073fcbc4f649f6aac7e372fd9eebd66a56cfc1ccfbde372f8982be3c640e6584988e6d14b3ebcd57c6d13ac83328f6462eeb2a91288216b3e79e19a966ee97cbf154cb8f60f44a7be85a8e13ba4e58e98a445bfa0a999db33a4c2c24dc0972d3769a48d1bcdb7372284d3bfbab6070253af5a75d58afcc69d531379e3834ad399c44c1ce4a52b749759baaec9cfcf7ff8976f4898a2f84d08f738ae31be38e18846ae705fc9f141d0c85908f7f941801a3a5178fbb6b49e6e5d793d745eae404a2a1c3a599a26d48d43b74015519efa8288ad363c7ddbf1427987e6f47de08ef63968672eca4053abaeb94b6eb84d2ea1ff50a53126fc03a79b560a3d269c93433b2514edb5711ce8c1865664b1ae4a298502c6312ba7474d3ab11e72155a8e3e11dc932b573cddb1ef39955d092558ed4e3d51efebfc2902320b57a87b46ad2bb5885953bd935f84ffbd7e058628f247e8d5502a93fea3cff7c0dec131e8520140b82ebcb869af77b5f38040c6e1520f27fdff46dc06d92a52d915400c9dfc4e0f1459138bb0d5c8d5c5248088ecdec9a89e903697f62a6c547b0c6c2ddc34566fa8ddb6e6f5ec7c3247d6a5613c5032a90742e3720f24b53177511150a48abeb51b535faf6d807c7ac55f06b00f1d50b0ddf4e59eae58d9b4cc96eaa786ffffbae13c64fccf6e3609f27abe9a70ef65140ffc88c761300f19f98b72b6a4b0a3ce7c49f37c018d90b8cbc2e0271576b70fe460318761dcba7cf09ea4ee9a7b921ef4534e0f4b5bb9952330206521297f4547299a6bfcc89e9792b9c673e6b5cb54a75f87f6450119939965be672d7f38e3dceed313720a15ced27fd0688fda24175c7903e4b709a403c3bc7f81d488bad721703bc7436f0d3cd3c594a1d9a535112462f081c90776ce042f9bf240a90d3f42d4792d29e775eafcd279de0b508b4e2d57dde6726305b73f5263f28eeab5147883d9399579ccbfd354e3550c0639e3689bf24babd6700e92b9d2b78af2b0bf650298db4d4ad049cbaf1b2bc75e4819061f1c5271060b07f422389bd4f0fb5e06a3a2b80fd8d8686de98a35b61a99a14db9f6f7932bd63e384e8803850b3c0c24df01df477dcb3b0d564aaccaf38925b5ce26ceba50846b1a54f2806b4ee304a5af0530df4d98b21295810aa218ad69ffd7461a54a35f11eae29647e9d97452f24cd82eee277f613d85addf29efc76a555bdacde9ad5c87039d3a28e8895e5f8f4b49f955a6eb9b901d5573cc45442eb400a43df5d4b0ed6d2655839c5934fe12be91cd1f2e04ccc58267fd822645560331aec5873a25712795724900f1dd15a5be2aff92aeee27030920658e3daea57b2f5cfc48473846d03bb46c38a0266437e777ab564d07079e0fbf3d09865edab58dd73781e9383c8ada46c81280682e36e4213872a0c81589a4ade4d54ff11a9278f03f5f775402a88bf90b6b26b730f8af7b95883b34e6a518f89528d1e78f87ad6d5d5ac257f16cd17d9fd20b6786101853c79edaa47c1c3bcbcd0cb498afb3ab85116405c9a88879fd550675abe003646b960ec9a912df416787d8ace28752895aa135141a893268504e7bb67f7d929e430b6ef64a8c0fdd7b08a8afbf916c2634371a67c046eada6fbe16ea6a66f90e7de7d7f693aa6e4ce1102373c721efd2facd83839334874127288d55d16cda49f1ad8371ce8addd982d448da92e71ade2ffd317d9bd92019190d14ebc226df40a60468f91c4d8b33de822a5acf315306fd0d7b4193c9abbc9125b758bbc80100db328f9f3aaf02e891a2a9c3c1eb0639e502911850f032c6334a3db5451b959aa4f918100cf26be99a56648114620d5d3bef4dc5a33dadb674c5a6ec2cbf72b843dc34d6b596f6937176cacbb73cc944240e2eb8b9dcf95b0a0efda74eb4a4da2d992545a28ab25cfa53945773972f79096d7a98fb3c43c916f681d45287bf4f5ac2b7fbfb82eb36e528dca40c0d9da6f005390855c2ca67e02d6c6c9369e354a509c8ec7e3ed32e07c5f4c5e83bbfe6f856ede1b2e4108b29053513abed033a13d74f6aaa657d85c39cb828cbc45d9d62cadfd65e0ad18d3bde331078a25a01cbf993003e907f01eb7387d478d8295ebb699800ce7b0eee2f3fdc8b8cdf6e636d845e4df7f10e6783503cdb40abde444264a847ed341cc20ff951c058eaee57e49b796efe2af526405f1ecd293babe3fcbdacd07c3180a378d82001db4dd342813f095b31ae9b5acfec59f369ce75ca7d445b8a16449825f06b19eaf8c54f5a9c3d55ebef8f8e8dace2557e91c9e937896bdef52e1846eac1ef27dcc7a9c10e94236478de1acf61c258bad8b226dbfebbeacda4890bd7140e2ff28e3ebbcfbbb503ea77fb09b6fb38d84316d63dddd6d5dbfdddc37a8505c0818c2e3a32cd6f50b25fbede39a08798930a75b996aa1a95b056bc6a2c74bf0cdbce4a9f88004120d2f467e2fa8379cedf4e8c29797e0ea6bdcf29b029e455154bc0475a76dfa6a08c32014fd1170fd65220f645c5feef7a2ea9cb721c9bf4889a703f7c81fe16ed49c5b9c7f047892ac50bd290b3b8332658b87d69cc99e9d201ba5893d495d0f5cf1cc0b01d72da0f8f249181ac0b9f35e8926eac6b064e9a894b31529f4144848229ee2410f318834a4dc95f248f9062a47c655d3c3dffd5036a772635ad47e3eeb575d0bba47d7fb889c9e25e72e58728b9776164c5f498c2269c6ec06be907c554893fda20ac8ad2a4792a6ffdea7e4745202374eb6a029b24095f14e0ecaecf64c2d09cd7756d1a9a5be9c6311396cd31bce45ef545402d9abf96d6a138f258987d4e3b8fa220a8651cb0049421386b60b6c0f5d80d78d689596530fad276b06556a86af8ccb760ad353ad1bee056605dc6f3c5799dfe39ecf13cd6a894f0d01cbd81fea2e61cf1eca2f99d93ab76e3bf8ce827e5286762912ecd50e63f233f465921f01548a9ce63e26b9809da58332debe226be941b279a5be1e66ad3950353a67aacb52f906ab0731c055771156a607e8026221c01df87460272ba02265d1101e3ce1fbbc629d6cce0618de574bde7cbe9e177b6a8b18cc93a9ffc145379b42566aae115f84da1fd57ed0149b95e47d7773f5e241fbd9e73c8f6dac9069401cdb7bc528654ba580b682c0da4aa1284a24fb350b57d2fd70c94750a961234f70199495fd33e24a69af14c7673131ff4d2466adf708ceb22645a833bb1c26e2b5b2131cf17ddf9669f8511e2cc3016bf1923164eee9d0004931381902c225ece8d5df6caa52bb4ac5aea954cb7b5055fcbca6d2ade63767463d6d757e227ed726b370f1f8b05baf9b83acb54aa6f24f05ba28ab8f45acf30fbb97b990bddad4faa47278e23f1736f8ecb9fccd990b0a57fb8614dcb7a11a6aa10671ddce7094dbe5769237db33ca408f390897c4bf30a15300baa1ec82fa1b888a38a140dc30ba048bc7b8fc886da42454d86b17d66e337e4c17ee5d0c6b1477d9f3b1eba006750f86ef8e50892884aad034f9affbf9d0f6cdec5c260fc2d8fd8d7ae97e4875f3b2de1cbae21774507d9c2d6270cdfa3caa832d8c2a0f7043df8df0a4628ae4b471582630a3526c5e147be2899944bc56a78b338197b12c8e43265f961a7fd6b5ae8817b94e0f4a28bb5d90b1c77aadd46487166b3f847b8d8a16a18cf91881f06530a3324cd290c5a37ecff881c721e5dab562541eb0e74341441412b75a493c7dd526a1bb2c3e2935c6ac40f3dd7c6d55068fb8ef4fbb5123205b81cbd32923cc966e43bb99860e93c42a68cc50a9c77105603a8322b1e8044e4a38348ede0dddf67e9752041cff34ff43b09ae7428651ee5b77c48e76c384bd5584943cf6f4b28892a9b70afe4189aa0650115e1a60f88fcced5f324bcc07a34645b7cd71a119bc5d095203bc870c1f01076364ef724882a6534ba1e63ab6486d13a82ba455ab0067e1dad23bbfd9967b34e66ba75b218fb86ef193aed8704b0bf471f659cb56af0f272b987552a35352b074e0ea74795c95b3c06649be3dd1edc47661bb71af240bb9b7792fc5e10a1a20a75a526f3df6ec2872e8fbf92d7c5d3191c3d7c702c3992c30363b27930a17b7df6e775711380ae669a3d39535d9f04e228e4b53c68dcc7663d1f64c6091cd244c9403f67e6071fab2d25cd16dc86c8e067fac73093aa6004d7661afa959a93732a0a996ab7dfab9870a62363c1e8ef8dd7d8b27645ec5bc6636d6f2e816f9502ca47ba55977aa2bea92ed691acd0720b561010c11647d1aedab49ba51c09592848e9810516f2bd66fd43adf0507fa83645ec563fb14f0c1487d5501dc782e0a4fc1ffc67e1a65d2c75b139b98b4d541d956470b48f4bfbb5b55de233715d3355c80758bcdeea02677bda2ad88575e6b2f48c091bf9e3050dac587e9a861aebb1467c352a4a76fc2472c1b3a97f3ccc81d156fed4a6e7865658e227ccb181054551179a4041ba2b78a5d4813eb0c32dc26b1b4cd08d38462073fb5f9fb81d5b57501444ec5d5b03b583eea508bc0466f4366b006ea74d48c04bf1a5348fb2d52eceae02ceb7e947a43a171b7f1c914c647d06d56818e2c48ad45fd8358b8ef1a245057b45cdd6e388945400755c8dd8ab0e9496bd3fd08bbe21de18dc10e62c64569d9af6eb06de157bdd56b906c10fa2c7af11cb62e8bbb3b337e7be9521c34532b592b80c91143c6556ce3ea68141aa231f7554a90f27c88a41040d3a69bbf97b6a08b6866b955bf8ad251261dc78300139063993e4e80576c0db0376aa081f13db4dbe98b80a05d82a62a8a3e7d79f8f60bc58b46b4765f7b363f8059abf727e560d1271b1717f80071b85d7a661273cb8853cb3aaf8920ea101c82d7f52b4545f3d62f71f1f9b1205eac9d720f178b63627621ad7026e81e061b941f1b91c2221685bb20448820881edb8c9da331fb6a7d34ea8f01f7feba62cf6e4acc4024e8c849a0d2a9012842152f877d8ddceed2b4ba2d410646246b2b9882b921bb8d852b15463df090571e0fe1db6d5c6a977030dcef3a6ff2ed2e10421ff60f64a2d66696d79a5968d49b96f3bb3b845b10bb85e68b84cb5baeee8635d7e764571cf866294d47591e70860e6f3540e6489a017557ef065fd0b3ca68a287508d8bd0fae2b90eea2a490e50db51b21bebad3f58e48b70ee1f6611f6a8c3bf71fd42704cb2980027017e3dbdb68ba464037bae5c64d80a01b1f615afd00e89bfb8046156b6e2aad128abcd7da43e914eddb46100331144a764a33cea25dc176f07de777ef9d0dbe6574364afdd7b5df1538b580c4ed4a86f342077a975e682b048ed41d0d93297c3b4234994a712a53762fb7d85429b6a3e16a1fb10e1206b2d791dff78611717fc3d3a05870dc7ffe16776c9ee883ce19d5126a9d58f9c282cb38e94a19a31aa9a6c03d3d8cbaed8045f210fe591828fa931dba056ec124466eb773e7469600d3b36aad9900fc61c552336c631981096dd774fbe472838c87b3d5f11419208c62d00f8d6bc90dd71aeec13b190ec24348d8b6503ad57c94f80feb9034b749b9cb9408bf38add5d06ae49c7ad46327fb609c64bd617c8c4a24e5fca398777bffa27adb670d4eff7f5d10691e40ef32cad220e5df541ec3d051de778d546c0597ef09c513d42bc02125758e6ea1fa5161ba2c07201dfc77ea2fdb7670ac9370166dee2628f91070e92223ce5a752b6c265c9d9b2d81d9e2c836f3b21fbb712a4cae79894daef61e497b7e8150b9084cae5e8ae6effeb97e41346ed4d15b7317c9c5f6b9386392777da5d3ad4abe9672c140b98a2be469ac565b7a418c99ac4deba34f77a0bef24316abf75c1fb58f832f7fb8cbedc6f3d73d72dcf490e4008d6daa335fa467c85454841525e7ac3c406f2d35f2b64619836c46eedff7f00430a80336e41b1fe702c0f7c6e00bf75e67363cecfbf3de03c311537473d9d28f4ac9080ab0b041954b1faaa7b2bd8bcebfaf701169cf8ec05243a36aa8533915ab9710fa760a1991dd19db480399ba0cd805c40c1e9e0ab634c7c450339ecc4aee710c4b8dea2f1cf033dcc78917fb11a5a6a0a98f94670813cbf20178f7343e8500ea41bd4070b237d240c93b4a1","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
