<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"967344a8b121ce1e6e87b7c50f3c7b00e6aaad5c247a00be10eae0ccab071d6a64713cfc8204a95731240a5a54c541f0581ad66be27a460191e51de1024efeabc0fda2aedb372c528d8aa4617d5cb3b0ffbd55e8365ea81eedbc642584cc7d2aac069516fad2b685816a34fe0c4f8b97f338918aca143f3e12befd5507719a78621ddfbfeed7d0475ca4baf45796a2757e9865bc04c853a7ddb957e91dd1252ec9ff160097181675c9a6cc658ff8a541eab1472e2af2063f458d9136386f52f0479c872f211e98c612448baa1c042bacefecdb5e6a4fbbd063c5a5efff339aa02dc4d6ca06673931439590bffa070369507970887190359ea8b4fc57b8dc1d03a2d714a814317d1474b70719b7df5509e2a98a993021b209d250f5e4ffc3207d661c48481e9bf4593babd4b18db15bd479c726f58da570968ffa56ce4c69fc13338b190f1a7ee7e3da348decdbdfd6d3b78c77a3a04fbefb3bf175c49a16165311ec6a2b860b1ed99075edecc0e0f3eb81842e81a95b179fec93e281114a834c53bccf9a755a46b9df219da38025acaa627a59e46a51a0bbad5593cbcaf180ba0bd22b197826263eee8809e7df0e663d02221e1d35d8caf689e4c5a0173435a6b78d7ef44cb4ee50bc82ce169bbfcbbe36185b6fedbce6dfb49dbe724ac69090c7a3a32a1c4aa62d45f3c3b2dad75860f849187013e1fa8ab1fafe48fa83bcccdbd90c7cf5e51c35f232cc3bc0e8512b9ad03a7183a8eef01d3be92ade10ef0b5f376a526071409813827ec0ca106c0c246c5c5300c5bc63b42cf286b29c09ee7ef92bc73ddfce8a2d01dcbbe60af95e4baf6d8395e56ba183eec7a1682c0c3c791ddf0219f3ec9e2dc985c1d67baec6be31abd2bb5957c4d519722a1476a65f38883db2fc2642a6f1e2756c7633606b0fb72546d7ea1ab2edfe1a52be5d73f91c3a6000623ba6865af3cd1a0b342d7d817c1d3eb05cdd35406e26c403146f8efb2d0beef28fdc10f4360f3c456b1eb3c91a1dc0f37d959f632244c9f85e721150129ca4d5d218c88899a6693357b7004a9948a0987d58521997be4e717050fd8fed3adcf1cb2de9b2ac6d9297d8253f42e4b04a47c49ac9291b0c3006c411889a508d903bf1e0d32c0e3ed0232e741cbc68629c6d95a000bc81aec06c2702fab8743c06398393ddaf6b0f59c4f7b1fc62d6a3fb0f85f06429a70a00b80815442391eb6be5dbc038a8611915e8a8505818c9b8765f43c88a26d1908e036dc96038defed5f10d4c432c909c69171c2e28256c1237cee81a01210285bf9a8af932dc43e5b0126531759125ab9d6bd97c2de43ef2a9071cf700ce47b3c3e9f4c1c0a0af36a22de617fbc90159d88feea3ee5518b492e7f7e4a40f88571489b61dc41fb94690b59d6402ef949f453acc50b422da9bb4a7b335e21d196bc16f5fcca0573015126020732fa86adc8b29a374831b5e705e76958d655c5b8a9f2d5066d224259328227d8fefc709a590d25b53b5540070c0d8055cf41c8bb653c94afda045c3a1aa815bb392e917b0232cf5156d66c620dee27e5704668f777dbb8ba3d7f65376b89f73edc65d1b0ad751e517caa39868db01520799c8aa49530b1f5690be9b05a89d43b6594ab32da9f19a66a134a15e1245d5be7f344a5dded584047048c16487e69038118bcf54831da63fef67da599ae797926d6a08f6c218366b8b1ac0c8d253bf6ce0d534502eb2bf0151b91d48baf339d3a5d2b836f608901d9a2f7ed9abfb9484494be0de0dad6cbda2a320dd4837c78048473069173a41edc99e03c6a63a165c87dee604665dd8f0a170b7fe18333e73257375e081f60a9887dd0752106abf902c99de9eaf04e780d5d84cceca5e6daee9b87b118a30563fa9fea391aebc3f04ca7f284e0d52c2a1a6a142c0eeb4fc5234a7ff74c260373672578cce5842887158a913db8d37bb11f6b0c64c67a9307675da80297eb72aa01b7da92b7a479e2127ddd580c6f562934cf929100abfd93e72fbaf7d1b895f2c1149d77f8691f16f51f411a5b113c2b1bdd7a59d05dd23d2da881e8a89db67e65d9b2b995fd8979745c517eee5f1966d540c2ae796969329f72a3bbce1eba32206dcea3f98459a59f48b77d56a26feca0defd08aedbbe5d9fe2219dc693f068dca25b9bb90d8896a68cae09a7c62d86a42834965588d49123203fd3c8836c31d653ca24e2a693ee88e99939470813e0f88b41326da5ae10b84ca333b4e6f78967caeced040a00297465903baa947facc5ea085b6a0e6b617e92147040d74fbfcc05f8690a413f95c7ce8e8cb6431a5079b6066496049edd26f5ac1e214ae15f353bb0aa522b0f36fbfcde4bfcf8b46ef30faf7743bd44ff028bf01f77e69bf13628a3d374e8a7c142acb1d336cae71b15e4fbbcef7557501b42de97fbcc4d3f0c3abe726986c6ecf80a8b27d13b6dfc72db92b5c4935c136d84665ac286cd3603ad064c14ca6b9e30363f9847cd69923c50b4aa650bdb2753b80d919a7c5eb77dbf301c94cb34ef289906531b8ac862e639c6dbb2ba3195461a568f29b58c3136411f1f318ea52c3abd80e9a9a2ee3b5a5aee82ab0495e2f46cc2769a3cc6b28c6fd9e41f86c51c4f0bb7d19b4201b7d7e8368bbdd4508ad5aadfc49b7eda98ea3697b4a1ad3bdbe7e30767c4ae96eebae2068a64fb8c78f4ca4a2f9d62e373ab9b6359e2a7de8522473bac27c4fe979a8cbe126109a2de0fb886362c5cd94787de85c50c7a6999205a067013143cc49986e94d92341387a670cac0e49d02b256b7c54309a1b058cf6dc329f747fb6030a8010a7cfc6a8c23dd842d921129cdb72b26f567e65f91657e42f0911a10bf1f6ed3ae8316290c2ba1838f39aa0ab4ae968d7a93e6c669689a97dbade2acacf6471142bb378790d532a9cd350e8306d3fdf0d2361bac58136bd843f9277925f21687d9b6ca83f58e21d36c267f25375dd04c50ea8685e59041522a6666cc5a38aa99e8c72966eec18bd55308f8614c79785355e5fb62f1fc50e2f87cfd9e151410e818b35b02ae634e9aef2aeaf3fd9b303a01a45096618c109a101745d2bc828f822a44e0ad5d60ef1e24ffa7767402f028a8b2022ab02084ef13b1904eef400b3b3f070289d0f51cbfb70813c4865391eceff60b207168e7290fb0c54aa7ca87470f43f42765724c80b89d2190c465c74558dfd8beda820baf866cfd47081daede0b1f0214093a9cdf2f935ff1d0de4dc3aa65b74fd9bb9e98d1310e66fee1c7498f716c0d8c4d5b85b255cfed32d62543f99489c01055439caed3f929f4445e742be10a30038672df747aa01219f04e5cbda75d6552ebd49c167f24f5d03e82338c220bae0e2ce408de0299a0833ce330e51bbd0e5e26e8b7c09ea237c64e920a11fd962e86c705baf248991a20a81e131bcdb7f599a5d59c679f2e01e15b284f8e23afb54aa937a7a484ca8681218c8e58a99ca0cb14ea4f6d5c9753a807c7d471e17251d20b531093a8fcd178f3f5b0523c4f2109d3817ba6b5887e9a21ea4dd3e392056ce7b0b8b4506a955f53b344446b34b4c9affe40062c5ec098f75e0fa84dd4dec521118349354aa95c24cd4eea8f9d07f56f6a38d3f149de5a93744c6bbcc0b47f8ad52798d71f31ca71774a69859d16c4deed1b9a220158a1d320c1ae9dcc4c199769cedfe0e231d87ae8f72e7a28f8887f4049916bc3c79f09a97ae64918b4222d73dcbf75776204b3e8c525cebeba14aaec5f444b17b32cd5470234346f4adddd777c0f7a32ad30002b5a3314dfe4166c5d2ea76b03cf4aaf423f70b4540c323f9ff05993a9dde4eebaba11568e9cd90e57974665007215556674630dee5af93b0dda15ff8d30dd065d4b602f0abfe9fea8460bf125ce01eeebfb38bcbb18d1bd1739db9018b40a5ce2af421f0f37e96cf04f700210e9d18e40bc6d7dffd42a8a0ebe805756012f7960ce54d3c99db787a87f597cbcf9ba329fc583e94536ca8a4ca338c28a6490ec01f917fadf539b438e56fb046b764bd2067494e75f3384f10a62bdfd81bd5218a35e0b82d47f298ac28252a92c86cacc948a6b7b74480e697b96a9f7e5ba0ceb6175dd9910c4c330a6a25000e1637114859580e8150b77b7144aeaccabf7d31ec57e20c30f579187d5427d183a2e3b5d2105ba26b0cfc1081723d7ffa80ffc6721e3721d0655c291c295d4f7688dc0e4c65b37807043e72fb89427f130396b8e103c39a6060aabe3f1938379c07beec048460acd202a1f1dd1b7edff3ea9a28bc1dc93e9c5ef5cb45f0618893ef0fb9fc5dca2bcbd8871f8a90d4ba577a8c73ad1b108084c6b45a548d0bdb8429618852a9f55eedd6688c95c5146673950644db287070a9f4a3f50a3ff5755212cdf303b9d4f1dfecc342258d053ab750fd9f0435b062b425813849f27b7780ccbb9e9643ae02c7c932ebd6aa60f61860dcfae6569bdd0d3017a52f0591be31679e717cf90d56f8f6710ad9d784190736f53d643b73315d7959320c69feaff54d236f304d39659424c76af255f734c958530d90c466bfb65b232a3ac2a8f17ebc95681e28f3b4817f32482c9c9b838379a32d70a44b8ac638aa9ab154e3e4d962bd720c7c3e03c50f1b2293b6599a258bf42ee17610cc88b3492de3365a44db5e1df8434939b09dfd6392cf099c51a37ff989bd11701c1b5f220ba922039848ae43cf3c7a8f1493ebde1feb8c06a820c8cdb795850fd79d66c46b641190722567c42286a68ab502611e9b91b91579c281e2b7cf3ecc41e9b008bc190fe458cc3c80fd9522d302ca7b13303bf46480ae60a036d010ccc0d866c2876d7cd3d226f421e45db227345c03596d22330477a4ee576cbd7d41d1b6c4c3f8e49e845992c09728507c71dd4cee6afd91e92392aa5b5d467771db59a758dece1f9cee57e8402511928ddd023998762cdebba2931d1566fa17aaf9624ebfd1fa1255fe60206e60e2efa0a5d3e31f204b3bb0323e3104253dee33a6739d825871e236f970ab62383e9af59ca59d49e2ce0b7c2966a46108d2474ece09ca9161fb76b1fe2186c790757d7d33779e383734c794e2330a56abb43bbaef8432d285feb7fcd0d50a8d57b4b8c881ef3f575056b8c5e370eda3e695e5d3705f4983eee0a7db94c4ea0333ed8baa83fccf7ef373e84aadeb0d5de6c7d0adf1102cb110d6d42540fa1927bc63f724a4f048185b30b672832f3316f5b1be6a026f6bf5fec2af83040c8cb762f3a4068ee1095258e0faba177b32fe08dcdbf40027d3a6f0aee456d3e63cb80f5ba85949c1f900c45ebe13ccddbd6a71bdbaadb4e8ee9e7ea033c038fc48ae053c94c34165d3c87b3ef1f09bb07b0f84bdb445f05c4cdab30adc7f9da12fd0f80b8fcaf6d474d27b8dd987754aca48f11b13671399ecff051c53e04c1d9cdedc241a4b0eb64200d5171836d7118aaab49b5b755e51feb6f5d2bf185cf53f63133aae052d090994bc1c1d73ee173e66647daa94474279a0b98c5e2e791290dde49ad66091da34fce82c536de28fac80d5d189de90eb2a0be1e30e318b63bc58f73785f2cb90a5afa353af6740c5f71c945eabd653296772da38e3f9bc67acfe097f98809d0dc52ba38de5cfaf24bcc118e3362897167722df96a6383cd4c8ba923fbbf3faa4bb710a1ef78eff0acd624507b461d9cfb166a45372e9ee0f316301772da1fde05406d8f9b44cf0977969a99914ea158230fd5d493d6c943fec7f2f5e1e590bc34b1c66e5c57e2f9e893fa626c2f02d6464b60c203f2d98af3182b4b9bcd07857c06aa18226822beb6ea5d22731c7211a81da5112dcb7ddaebb51c6aa102e9953745cb819aa6c4612e96534c924a8e2332937038c06588e917851aee6bb6ddb3733f1712094decc75abce15aa20250d44bb33eaa8e6779178c2bce8ab580c419b4b75a8d1dab01b7a3e1497783c3279e42e00ab7a1e0ac02c954c69bb78dc0d7320ab10ab912c3c7f758cafdbc5a427deda4029458eeffc16e491aaeb3bbb5f84760e60ae081ad2337bb95773454b4c6b06121597bb822346fe406e690dcd4cd8de225f7b6e08c52f060eb2ab387cd75d5d84ce8715e2902fdd2b75c0da076eec4c044374a5bb70acbc5f132e63b6107bbf95411154ec0709c4a34ae916bc90ac3bcd6c06145df10c9e87583ffd2e2b551d495bbcb003aa3e7f38a0f5a6a447f3f3b8afd2e1259f0d879e1a14c9955f2f93a1b67b05d13d19fc93bc912ef5449fbffd385ec9ab2f405c34eb874185fa88af441c0141cb8f9eef8bf93a167d7d909a24b3f4981d3564a43f0009f1f3e50bd2461fb11fd09239101e2988c69867ce467c2748a729a7fbac4ebbad11c6c4a9c8c6fca5739b2107a7910762d90f9d6171058679065aaa85ba518d570c780b8da210a0d2f5eb6b838a97d2fa3b1a3aeece2269040e28cca95f81e8c11bb8a60981399e30d7b6331665e0e44e01855ae6f19b8d0864f072b1e990b90f9b90e4ea6871bdf4ea6791a28dc4da31fec01b5201d37cd48e83e7e801006acb9eb19bfd2a0043003188bb8d4f6659dd2553208d2c6b6e3af3aad2f520d790f420468936dbd7985e35f6cff450d8338dfea3f429cc8f562db1889e57b7f6127e320d8fc7ba3a8874b2a1e38a9957d33311de71245187883ebe9c5ab674af3e12e40b9363c7a4ea19dc118a990f85c3e5fb0eaffc9a7a7e3c9cb3f74f52cb7502f6252e239eb8bc5f5e19603183635087c37be546aa6a4af4214047ea70ebf2277cc2549400ee85e9ba6a7891c0ea816cd83519729647daf3a7ef3462310e3ad4b8fdbc88b32277ea5c32f42b8f261a2c9acba607f8a26c55233a1ea5dc8fd3ca598711e44222e06fd39be64204fd1320217b36492c3c72c33f337998bc5ac4de2f30c0f1703e4594a75a206e1463f41b8052956b474cdbbdd5cfd42456be42e556a88b582a58b256f0a1f1e69671159da9fe1c3b1ab0678e4811074db0ec226833eaa7da0f3e1e4795016533f4a51f79bd24f2e156d90c4d48ebeb93c95cb79b04b9ac83e70b125ac5323ccd10d6b151d47f232460b0072f6eee2ad782834ea9ea8c507429fdb1bbfb0150146442c1f0c4ef86bf75b8ca9e56bbe6aa3fec47db05562c9b13adb3b639d5852bd338422ceefedfdeb45c806b4ab097ef04fca3a11630d78b4095bc5f1c25bfdb250ed7cd11f4b426b75aacc696802a85863f14f539619f29fbe9d1874b4f0480c375f218ef901a878bf8caf98a309314457c610ce0bf77da8ae38073da53dd4746a45658866cc89db42766745ecee4d8546459abe71ee06f36f6c6ea2ac03396382478dced7be217c4fbc9be93a6ca45f7232c778074ca913c589926498d7fca6c8a0b6cf06d35d3b800863975f320b12b24b109a7bfa823ca42ad7365e536d99d8c37fea1a7dd468ad358b63d5e34a9de3704b7adf80ecd3f4ce93e72e4f355452f4f2d6548059dc588c7990d86d629487ead768be8a7e319fe33acf65196ab3ba5db696d99d59c1f4977b83ea33e99ea4794bc053d1ed8b956c1dd6da8535e98ef9a0b6f757aa089a83e32f4d0f6cff27cfb00cbc2bd140be5a45e5c374697ebb02801439317d14c55204b59edbd5a03874f91cd303295907386ca59465ffe8d31c49544d28e925dc08f066731f7fa49faf99ed2e05b575d362a3e3df93a92ac904ba4e5aae18ab329f4de1da870950bed4499893b5c3b8fdeafe2d94a9d80bc10ba60debb20c8bad83347ec9263100165a2b12a931f39964506f640e5adb5a818fa97067e8d0ac4587a4860701b33d3a96d16cb471b7326c79496785b93a2bbbcf5228ca6f55a6b7de9291453aeaf1c6d010f968c289e74c3a54454c73f27f3611ad275b8f11b695d7b153e7f6bd9d970caf77e18a560e5c9495d512e4602b1307fb0d41ca67e9a6a04d8f847c48e1f6a60c6f86c5ba844e78d98c3f731ba3e269c2e9ac2497f3714cf926798cfdbd327586208e673dbc788910dd3e440ff0aacb63e20f12d13a650b4835d06adf2cbff5ccae44a9ff325dc3154b5bdeef7c5beff6cf63efe54278ae4eefdb2919a44db30c3471f6f04db9f7c55e732546f58dff3ad8f78dcfb6ec31957c09c674b12ea4e20d384258ab98c97add59793585554c1b3285f27cc1b817944c18e87e6a393e06e319c5b75fc79c342a2b9a5f6cfb69c1a70da4916c48d1049891f7e7bd9d2df6cb71aab54301815c65c35f29ee5e69acc4d2268786dcececaf66e125a41aa8bcb64112d55889424bb8e037dfbf8a3b989fa9d45fd4920a1c48f9545f90b667a9b879bd1241772f2ed0151bb56ea2d921c74d68936e1b43063f940c7f4de81a82f68e6e876cdad74d713126b8b52261ce90361f935144876425c18e590d93523f5f743b5720188b3bd82cac14359c0b06caca40df59a7312939fe2f8163e463e1b6eba88c9aae6c3c4e2e0d52227d9aaa854968d855494e1f13dc291b3a9b5b94322c0b48a369ab3a7f14ff8ce22a8c3d193a79ea8876e0261dae55fcb71beff7deed58c664af57ab4a3394c30ec38f342a772d16dc400f8a811502af7c76dc85df0198786d32bee7e8fb8c3a812e768942cbc799178d3af2fe5820a0cb1cad3218dcac422876741c5ac0b3011448a7f1cb4aa834887771fa8fc7bb94b38426c46ae8ff435d7e0a9711c4200129bdc8e4fcc7a36138b837022d6c3cafa1d09132028ce799e85ec3fc2637674c4c306ac627d0d4028d6188efc24623ccf7dd913a8b980cf31865ad56451047b76b74cd5d2cf309e77a3395363935c62b35ce29b812a9061f440f9c9db20f6d1b0bc39da777050569181946b8a39fee493c0a18ca5137d075eae2592a44589ac6223b62506785ea0266a730e4a72583efc6404c5fba6d12f054d317a186bcef534a00f4e5779eb8cd30511a87cf341fdfdafa222891ee9ebe6b63c729b8ffc2b0e531c8f5556372565f291a943ae51f9de30d93d693997a2545c0553abbdfb66effd951f853c2d11399b45e8bbb1b2021f175bf507a823c17f7288b9eaca9fc1aa07ce2bfcb7b6fa93f8867c59cc9813ebbe18660b4f7f8eadba2594f85217771c2009b4ec7d28d0ada6d6b52350d8626ffea54ba0cba00356777e99d635f4bfa108ccaa57168b0e7d4d7fb7b7bc020b1aa9331dc3684d300bca7043ee03b9306073357cf36805f2e27ea90cca0f2b674f1f6cc8ae082fd30616f1f8ea8d5618e7527322bd79bf4d05c164cbb9c7da959fbded8ec3f972010624011e902b5c828066a708056f52e46dc4575b493f881dd4474d3324bde07cda019527242ed7745cd8e5b39553e11ba18e3d0724c9cd992ec9a172a725cc2e31dfa6d1d34d666beef3f74572963fcc7e63db536f0166a894a3696354692302f22e1a8a1936ab26153b64e9c04d84e608cb2dfd82d15989e2d926802e6a399ff97ffc0e5ed0b97c68a74e231054b5e794aa1324598672a9cb6c4e9682225ec46f24eb6d66142f886ccec18541ddfce12d2630633402a30ba2207cbdeaece88f265b679da1f6ff7d092e9f19a125930cb83f4c400b7a0c703c53989bd7123d426ff337ae1bf425104e626ed473a5a6022401e30308b6faf6d624d255bff45a4cc6248b62f99d77cea50f782ec38400c94f7a07ce03ab10c2644ac559bbb4790557a507e4562c92d3de89c4daf50d4c649133959ad57ab0982f77ece23bf4972eea9b59b5f913f18a5deacd7392beb8eb62c62a11532b1a12a4de40b0cf286c6ed16210067d82226153ef5eaf9ab9f5cd19bc44d7641425aa14d240c36a49df01f9e191b3ef17c54b643a7d39754f08a5eddabcd9b21425b4ca304b2908481ffaf4f57ac080c5a1bb39d6c952d12626b6a45ad0677face33648fa3a4c940343dad404483386d634068d21682f55f3b77ada2da67ed45b9397b4ab30c9669a57308394e2cb5067768f0498b1599f0d2707278f2fbac7118ae41f33c5f79c19bddda90022a3cc1cb4e079dc6571c56080c7dd421674255061538a2890f5c5ea68a9a06a4bed7490a518c522af5cf9d4cdf0f0a4e2a5c23445371733b9ae90ff189bb0d0082cef0444897a1ac9b15a398bca04f78bd07161f57a8a5e8dab3416ca91ef499750045417d2671b34b310ce76352cc0a7e0bc07302b6746ca87e70dc619706e7c33c7b91adab012f66ac6d009dae7270419c4b8b7c06566b860c652e66f51ca82bd8ad4bb06eb61f0da36524269d7548cc179d0ecc46c222afe52e00fede1c6e3acc6e93d2ac298adfd7052d503e737cc87364879fe89a575f3e03600bafc62c0566a05c3eeed4bb61d9cff9187f241d4f0a3ea03984872d9799c5f2634c2dc09be82b48b5250d1d4efcda6ef4b99df77fdecece5aa09d03e57613d154f7899e2539fd8998ac8d7a1c9d29bb1150620679c7f6d8875af5065fe0a573d157234689db6b175d330e880379448a1aa3101db90abba625d17e029cf163cea547a9305ba8c4c310ab8f5cf37268ea62149c9638df814899d3207617aea034242f2e1ece7874a0fb9fe578e0008e14633966b8ab82e80b0f0dc939ed1d51753973e02b0530196f4ffc25aecde9893ef164818b469c829486e4bfb5cb4db02df1e940fdee1fb8cb86e5e83e4500ba68cd1e0a99fe626599961c3b5ec580b430fb6c0d71a7a550c2141c44dc48f86c91c712ff524895a9c6d63e47befceace35da58bfc23a932483087e17fad1f55078f923ce38422304cbd248048a56e046125cc0181deeaa7d01380cf5d0cad753ef055ae70fd392d42effcc9493c36927371dffac76eb9c63bd141d457197e13274325aeed54db4a64a3c99cef3eebf18a58e34eaed7b020b16a88f1a88525e38562d92cd1b7d7af22a2d4563b59f95ef6af067045eee8e48b91e656364ab9baa98956b43411e684ccce6191fadabfe846bea73e5769c3f704246a7ba55677dd7d740c6cf1e54c0b6929a9a88b6d744675bc5feaf6ef1f44707332a06887bff74c2e42398f01511a078617427cea5b27c83d64455f87b45538db7905266491639faacf53fee5fc2b9f9da15d2ef35d83acd98e04d96a70d07e80d2214be1f5aee290976b78ad2c1d69c38296a713d7911e610cead6df482c07b104634e09133175c818cf888416a3fde75aab9b9f4e98cb98ac033feca93e2b7a9532a307a06d27e58bf6ccecbfc4e4a7e26ec557603bd0a333561cc4713ee180964c9624ba264b5836af4c9ba3979c7110e3bd5a3a9d3697aaddb65e1aceb74f87aa4b13bf2697bda8aec8bcb5fb5bc4d45aca48fe2ad59f0ecefe33a58c58045f3c5e0d22e90cdd1c5a23c468e4882059aab05dae1ad247aab4ede62c4267ece0bf2cba187bd6025282e078bfa49ad8f0c3e2afb2c1acd2bb497a9c8a7afceaca6affe841e66233cce0fedcd107c4745aa61ad9c88301a5d8724f01b38713b764469a75ff5ee8913814c694b56a3ef1e6363234cda86d869dad8bb63b69b3a527fc14143a9bd8a3cbc3a4c8718b95e2e594b3b0e49a81fb886d66821ea48245535a52c7ae7f4e3b1804b9d41398857eef1b0b4838a8eb4b40175d1cc2a85503a80973a53c71a2fdf657757b3792e3ccfa6d21f34207cd01090995d502a20cdcda3d093dd6468bf7df5665d92e8325ce289b73882999a75b697a2dfe650044abff4a3c5d0afeda044ee37a6251a62aaf3bf444fb27946f5ec26f6c5d62fadaa8a67aff61b1523d0d348978ed7421b08bb354fa9233e16041b640f8b15e09013d9998f612f76c1c951127ebd965b8b36327efd02d7aea66b867e218382cea4c2db5a5c8416918cb1a176f4307c0fcec129af272de418d2e892084680a1f7f5c6983b283c4e7dd3e4ae118478094b078f896926e8bf85fb01df2a6126e0ee4408d8b90877a9cd92ff04e0c97cebb780654623165b06845d35289d34cd16a6abc4c609ab1a84b3d4f787cf9b74f56a2a2df10987083cde4abc909478848f9514fb7c4dc6f58e277a26a4d6e69a02a75f9293f8402ca24338d16c2cb5bdc16efa4b5ec520727ed19df4d010275acebfedfe9b46061d9892c394803693d7ead32ee08256094767e1e47e5e3240cf19deca635d5666331bec7f7a25f0cbb73bfdd714a278515df939f8d4ae62176ebdd6ac065e88d90f8fa4238cd6f6ec517ef2ee0509ffeb620a181730af30f93a1c25c2c8f05b064713c1a9825c32fe4c4d4858b71f9307cc20e2cab06b91750756d0a69d12280bdbb5602fb51352d53f893db01111727cf42db829a6040b1eff92368debc8a4619eb96a8a78e2e540c0b104f72bd430c5272c99e43d7509e52854647cb6a39ec9c3aab8dd4d77842c78709f3fdf958f0694c2697fd8c8f949f12a0e5b0fc4e3b3034bde27065676d05afe468303fcab0b3a32c08eab00744996a06a474dd2ed8e87587889cef94a59a7ce439e618043d160b8aeb8904535c4ebfd8fccf619ff2ed3130573ce31657509b1a49f3609395ef68716a4eb7f627187619792be24eb2c067722663933867b18bf711a1c26190bdc4e6dc1ee84beec1f65d19d17c51e9ca2ee5a4ca0b72c77875a099ded03b6c89cae3571869313ba1975b35644c18793dac30937435648641ace12af494726846433c836f375dadf564b620e75538ff43c5118cce419c26fb7bbd9aa30aa7c63a126e767f7ba33aa004baf6fce28875936f8f58e9b267d96e99cbfcd6fe8bdd0d65bb2dc2764f07bd884a41a12d7ff560f46a58564c7e7f63b3bcf38386eea4de141602d0d48493a125b0f193241ca33c7aa221cb69ed0bcd3b4710ee88aa6a9610bf15d93a5f2b3000dcafffef59af942b479245d6cb4334c4f274506a21a37b98c94cb3a256d1dca783b0c0152a34a7977ff8c3457596e33509ee6cd11d4f4b4393e8a668c7eae18e87a1e1e5d6652d593ae1c3e69f2d33ea4fa9dc36d802e2ef5482807629cfba9779908849d5c4085c331630046bc261a6cd55e54f5221eb2046112f1cf78669a0213af88f0f44cc5c2784b7b12189c1abb8b09ce9ede667d200f27b344b52e9377bb569d1d40c954bb0d91cb08829252009028031c60468bc8c353c9852ebd762fa73a234ab5ef26737412ed94045923648b355764e4308add97dc0704b7382fac0136577a5fb35cffb28c66c899dcdae711e79cada0c16c10e56edca87cec0f23bd72d2e70da65b9cff22ccf94b47ebb591d2c308ec8b6ab5583955df3ddc2af1fa6b3e41740ef311e2ec8dffb99ddbf1d5b4966b067c79fd94385ebeeffb3af0d6aae6b6fcb2918711a3c18bb34e4d84ffd2e58f7dd427a06eb6117d17d4a9edd61a5219769773558eb3d65b652fc1c5456f413a7933fe5523c0ddda513f9d4e8dfde7089f30ae5aba8b3354579c2b1a0791e35f1353ed7629970ea15d8b61e0fdfc19f774a5c2b114c9a2a4cd1c55882da2fd4e243161fcd7b7b7841ddb229f12da243963099b07ce268f5ea5941639f9f19ace9bdf1c706894ce1656f69ab7f5e9e2b600dfd4b9e6cbc9dd69b30e7303aef419710a4bcfc1a5756a653e3e1aaf550f0b079134772866d9390201b7ad5f5ca00fb551b97e018aa1cd0d881d9ddf2eed225a8a22a8e312f626f8ccacd61628db630f7430faf40df8f69790a303ccde51f9613b9b885bfdb075f4c43e52d56db49a58a550c94e83036586590822f31ac1f163a1d3b8485b4a1b98924375f64b1db1f41e39f8c84de2e85069514e84b969a92fafc8f95079c18fe8ab9973f234b2d73ffd8643c30244d986786d2668c216192a0fba1764860c5dc1fe68f3006a9c73be0c74255b7d48bedaf16d9e0cdb2256d7037a10707a53bbffa29707e3ea1487338773ac59253c71059d6659ed273de9157e2aeb5bf54982c39619bd5fe69a84560aba3cf996d7db8dff938a4fe9f99272fbd8bf759bd7d2402bfc7026693c91fe7a561da38a9e31506c5ff37ed9c50709c1fc6c14699f0b4d95aa2e2e37270ca967fbb5a868aa07250727976507b476d660057b8cfe2cc5f8d4c0c84bd14d21cc563b22d19bff8897c626d6c8b092d53a6a5e1982058011c2e6f3d1e8405bd65cc40c6d86c23a11f873c863f030e09649902c1f3a5e9ffd68c1d57cb41fabc7a59e23eeeed6f6d9246e0d043ed58af8f51f8b4b121a700ef0c6910d6f252bce6c72ad6095b0aaf7eccfcea40eef029251ee32462d7bfe14f06b858a2e118f6f25c8371b8fdc83316d13eee116d0909aa4a2d410e33271075ca2c38625446e40a5d05b2dceab6280a6ba96469e92fdd3fcf5e6e1310e595ea6db3dbef4d3de0ac94470427ea87e03473a8b9cebbf354d790493fd38ec2bf03d556fb87e817e99c563366f4df60e9f717dd526de9f59429681751d83d8bbe6de53a11fac904a7c786efbc2001a41dfdcc1fa2793dd1fb719a7a9be9648e11ef7f125d57cd146972dee9892668c09254e2bb74daa3244f7ce3ef0db5d1321925a63f653e852a0b64842d80ff0352e6d198fd41f49de71d94e52a75d903b91ddfdd7fb7d1742275bc112473610789fbd63bd3d4700d0730b72d7e1037e4733d277d64888987b1eaeef79269d431e8e4168ae54eef8ffb6b7155665f7685e916f95e417fbc0f81181589cbc4acd2d63d03481cd0fa6b73e9daba7b5a5ba8c5d7a14213ea7554178a836ac74434439e9ae33b373503e6650dd229d99da1d3be76ec556922a0a9e156178071eb53499a66b293bd3f8963dbc4af1a2ddbfc19d17aff91158f773944f1758bcd9eed5ec6693bd1068524ffb35d5e9ce6413c2159a3d7b060eb68f821ec1dd8dd16b013a4d8ac21456337e53a31066a5ff01c6cd82a0ddea2fcf49a8267471a15c95592894e0d3558b947bec6da2f4c8cb191fcb414f7004aea8ca91f7fb9fe6eee9c546e4cd2482f56fbceebe9cbeb4a8870e04f0089afab0d4242f480be845dc51cf698f95f91b43b34d83cd7b9ba06b9b2b8213af51507c05d5737303a491806156217fe94bbd4d9a7b286e61f715d5001b90f8b9024050e52836f0d55c2ce1f5e5fe6b9c563cdd001f66f56103294f12fa1d9e26e2a15ee8016a321a993ab198fc75824600ce98d7c1c358afb44c19d00f5369a3f7913dff50124183e3c499c4bb643b310c8738996226355c82d87cd8f0ec6543825e599f1c6772ad69c268f3658a1a21aa72fe55fe7d3a7f93a1cd2a6ede21d29dcc8ae39bf52b83875aee52a60103a7fbac2b6734b3e68a6de835293c0a6e3ef13185c17343a27ee656c84785f259bff07d622a1d754f7642c5e77737de400302e308cd936d11b50707bf58e1793a8f7de032339f953944d2c2d4211ea7b0a50e4347a746d4b8833a37149adb131f34d586714072925b512ed6274097daf223fa697a02916b0e53e8818503dc4f25eca97e11f9f34d468b5583e44567ed037e537e912256cb9d87217434a3d8123e8a351df2c94a0e76797ca307584b66f0b9a165afda2263824fcdd74c2de8c8e7b60a3623cca8e7d59e4005b7e0bcac9a59375621a39cf28dc19875e8c50a2b645d1e0ed65f8170ed9be7c174b7aecc9d99555a74005389e466da375759ffdf152831f05188bd3cf763dcffad354184579a76ddf4c62b1773446685f5b1fe071db8b6375785fad479b9a871a405057a9266a0ec2d5e77046dad3e4dc2ef6d953ffc474f18b3258c93573525b23781c375d71fce2caea9619c19a90805dd57a4a1cb65e7007427fdfae17a7c07e8d77146a0ca0c48766298064f81d459c2b07f89359b20bc2efb1672944987247c63eae6ac360c73bff45b893e9df1cc731ea115582fa77d5a666da3c5d14283e7f701129a9c3542eb2a493e58ff178bae5c573798443a472d6f5be8418c3e395e78235306e9efbde5d7351a96aba1f738bed4e7771da27c02a4b7d6e279cbd7b98a49236ec33705fb4ebd4dd4ec90ffcb86ecff93d63d00b6837063537e840cf4936c9c820020b6f1c2d6c824d9fd1c83e82f95c0fb880a71ca6d6474bd0290f32aeb2e7215e95834e9ce37b1a907d7d07906ec48f8c61e4c2194e7e582fed911280e866ccd4281cd6de143acc1cff48408a176e0c84df7da53d556f5472815a330c112d998949b77b1965db8d4474de0d88b4a5639529e795f7fa8cbd8c660d7418d897e4916d293084ef42bfb3ca6691cb86461ab69a99f6a1ad9b2fc62a1ce328dc9b1bb6b67c6c4bd110c51737409f6599533c0ed17fdb9b0d0372e7350fd6da234ca9f4ea27277bcdde60e2b7c876bf2afadb417fc0ca8074353cb55bc66d85a82953697f86274d3cd3e78c12e68f608f51e2d75097e6b93f14767d25805de55fd0e9f33a4be9c7a8830bed3103f87dabdea1be74aa849e2a888ad7edd1b764a24fd0c1c701c81e1c37674c209f1e31829983ee7c791d7a74670b339ee3576665f8650cfec2b25204ea856d5a88fb3d72d9c0498e4f6e6e621a3763ca1f3c468d6bec3506007c0bf25578f9663727cfca2a3fe5239393816e38312a8c81635a860ca02dea26e2341ed54d7594e934b43d224701e50d0206247d2c7f27227c59021bd61ab57c2927d082b92f4a8d3dd12b5c542527f302c9636b22d1038f33a5282a374919dbb7cd1c252d7508c12e471dc2c48723ea8c8ee87c867181b633b30c8c95b9c66e6f91d0107d3372ce70c55c7d5ea21b5ba3c87a9e0bbc70955841570f6a185ceb251e35e0cbc8f8f4889ee3fdf5eb3b841534a0fdf2cb2dde19cff7ca68401f3f2bc5579ed9ecb4d238ebdccb42dd708d8f141089c7a4a49513f6ffb8aed30c1743a11ef435f72db858652afbc34817f9a5b76ca44131b8ecf594fc6d7c4282b75222720b7d63b6baaa2737214211c412fd2845a0c85831052faa906648f8906688968eb8724c26333da7f3d1f9cd14e948edba29b8379537c40ca79171de41cca0a4294cb0ab73f4668190c397c781fb597c1585cefd5080f9aba90b0561f4412c85af14042b04a570e4e9f6e1ee5984d5c4d718d73453b84771bb412835a3698bdde93f906eba270d201c3728af178afce74d353c30b3acf7d728575dc893a75b2440e4e71fb1b079c2369cfe2d5a3d1b62e8e928beb55dc4aa9ef4421a0ac73d60c1bd01e1c006fb37f92b7276b219f5d3a34cac64acafe78e5faf3a083cf3a5a43a60a6cb906a5c4033f2dfee02334654d3104046613e9521f213a0b92744b8feeb6053ca81132e950e6720d2d71216d3a7555fac5950a5ecf556755ade4ec38ed4d80dfe7556610b1a15d41235f42587709b0b38ac8ef9829463aacf997f4ddfc53f049282c82ff2697bc7a54a4f2bf2373fac4c06e0a5f0646b5eec4f254a3dd36de27ba74336131b1b5674c9979826d0b6ef9d2c092f7de34f9ff9e8340dfc530d5031f1760036b6f92146fc1a91371429d3c65703c6e73b4be95d792381a576a8d00adc06419dc919996f1bf697b956eafacaa944b409cf031e387de2267734dccaaf14c56ab9832259db24038b0bd1343fda72bae49c5397b29fe3436265deeba2d67a44d929e867cac6b1df457bac150bcb84543bb1620c37522c4a3f57adf4dc30d0b5ade00e57dd3359c6ab33d9aada4c3612895d3d26e63d168a3e0f4669bf58fb65107db3da74cf28e9acdbccea019ec5cde1d47f03095485417da733d5a12ca3e8904a9ab1a8b118836802900dc67b031a19c2c1f2ee445a93b17d2bf7f6e3e7ad3482442395cb82fb961009b16dc5d6256cfb1af1f5442273cd96fafd51653336d4b9a425d32e83cc8c5439438f6e6bb5982898f3550cd6e946dbf5685ef958b59292516302ccb330a476cb2f953ace003bbcf62994b3d07b6024928d6df6579f359b1c2ac7c5933ea2166e68bd339f76f6413dc50831a1b0b797effa16a6725e45ded5a6a20af53bc6dd3533193cd8fb1d7f189240bab03ffbf8beb1a7d6417d11ec599c29c910e1f6e9a4aa10a9c506814e16f4e71e222c889e6eb9c77a80ae1a15508b49fb4e07bacac3badb69bd4243df9b9e58cb93d9d18be2adc3cdb6cf87fb4703fe5c7a80100e2837a6899759e27d96984aa22e4af0ef5f1d6a69da7ccfd4c05a1d1584a498f12c5e7f2c0f49112ea0f5fdc8d633c2c982e92649adfbc7618f3ce0220f659bf03d94d705ba83091a348e84adffda2d99946e3942689c5206decde7e680369241685a231507d8ce7d799e50374bbd822ad74735e7158acb6edd6ef7b613bb700424a2448f6e641924a9d86b7b456435dc114d50c24e895c8bcd059d0160ee8372301a867b9b9dd13d5725fb8069492999e4b2213c23bb617838b1b1230470c5b320d10a241ece7dcc54d1f0acff1a0690c7a04c29ca217a53cd260abbfa56b7ded68c3208398edff33a2e5a06d7faf570108d3d4ebc0f137246642641ec3d709bfb41198ba29a6ae4ea5f26f1e59557e20bbcf902fc4f8fe6e835f1c38f93c63a5acc5577a8479d490d7584dda7856db55744e0173373443c03aa11f5f3631cd83dc35b65b85179b4dca6573ddb5a3b831e2bf5ea91d38caee619ef83c3709a29c180f63580e567e8eba9a8f966842785774e494c9b5354d0e6116c6053fd2621acec0a8423d028aa054c4181cf79570d2a47db9a071978eadd68bea7e686b05bba6003fe63413e0b77a6515782dc614a8edcd5143bd8841277b30bc8df156f5a22b42495c96a2baabc74a275a3b49deec53f0321cb9f5d613f5d7bf2ad4ecb19e61fbb61efed9cc221460816163a79fce6fbc0108121630a077f83bcc74e376cde5c4c9ab0b6d41c82283f5e1010a6601942686f8e95424ecfdfca680acfd69200c6aa6e3ed5ff7c05f0070ff16560c7a00e0d3ddf7736fc1e95a13365dfe265ce1e8988374e32d109b51868d54efd79fb802ee1b6c1064d34ea43d959574d36add2b107e5fb8cf0e2864cfdcd642627c48a57040072715ed2e42544304977ec0da7df115fceb17fd73831b5d888e356e0bd47b5df2c718427eec173104459c511e9f69d37a2a051757c26ddef64910028b97b5b239c93186dd3ef75d69d407d85e6a83073ede6bc079bbdca22f0de9faab523e7ee28b0adcd481f90796ad0a94b68ddf455dd7358feceec7b8684a0b9b0e8e96e55800fc637f99cbac33d9d8654a9df56d7ba5ee1b1d227374b8da3b9953d01f41a9ab09c619c5e3da9a2e5d985b421c27f15ce9af568742e3010e63dfc5a5ed5076014828b23f8f6aff4802de5dd5c449f63c70f04baf8f5b3e4efc36022f5dada8f1f8ed233d3adbc31d31ccf2fcc2105c047d2595d1afb3f7007905c8271a95dc082b90756172c3620f48b2fb0610452e14e2b9f327c3f295f66019ee97c807b068ea874f44dc6c2650a810fdfcc46e5596984f8c4c6344999ad47e3b6bc2eccc7d824cf9edaf621efbc3f9d1496cf02867234978420c27ff2c5bcfcd2928e07b06d2fcca1621b185c65dd49c02c6c93e36c5e9861f226f3d8c6dd8b0a6efc41996a4e6eedbfce8f3e10d2ea411e5ffbf7578d6dd3f98101444a1ce0d7d02586a45b1b2911cff164abfa5786f9e665448a59a11355fc2f495cc30ccd225825b691ab47d18a3b869b61d8bd36439c7c2fae988910a0880cce40542affb2f763b459e6d76b10ce9cd9bd7b04fbb578cd1c15b9d41c5b675d0f82af996c4466d98a507cb89f8a25e82d857b3cc28a118acc36964bf527eb5a01e75d129dc5850acca404ade999e0d8d8d334797ac3d781636845c3ade07e7eb4329ff10f75f15b06ae027896de9e25ec596c820e3d62d92aa11e5e3f363b252e53ff055035c3ef5f307536d1e612ba57b2221d66b0fa3db7c2e059b86bead6eca3d57b4673130566d08f3dd1e2c90235ef3355f0030160a33b83acc8e1ac3c0cd0eb71a43be1f48e435f256b3473f49446147fd27a5013283c32a18402d6256e88ca1cf57cddbd7b9cd89c1e5ff0efa9ccea98051f1642b11c135417319b3d0c604db0ba3aad69b56d4fb2ae74134ba645c0ed2097af3db198f113affc63f50a1db616523910b6b97fde5a18871553cf0548e152e1f436efa08841a991e7a9c82769df714dbeb449c35a50476dbcd4adce06b2b8268fe55716f1fff56f600b6b04c609c7b72c9f6e8d8aec5b6fbbf39229d5a495a4a942f6919a53f3d2735aa217c99b967a063669af5acc8c5a46355c997e0a1f0d29cb76f94cc320a13cbb604af739f57fc72330f13ccb0f0e978434db1ef3118fd4200dcf3e1e4ae6a2f907f23f901f31bcad5458cd2a320be6c6697361704f2f714e82942cd47abf4e3a751d61942bad928ee6945bb2be7d698c4c049ca7300e2366a2a1872c0d139d7b85c5e3f4a1513d2108bce05df80647a8dee157b65bf2df782b857102a1b5c057dd00bf4b348a2e5dc4594ce5418bfe5c7b629bbee0e22fc9add1edc2b6539c9a0c842cca5c6a91939a6ba5eb51990ef3b4f10f6f508aa1ae1f357ea7c1a9d4c14ef0ace09351c5dfdde057c3969d59b651c9ea99cf08343abf300c355394d90cd7e8be98121df3709696875aaa8a58de2f1c9562b407e6e0998bbcfed555cf1ed465322d1dffda1b301124661c27de9edc7b8a2e451bf983cda50f22313294bbd705834373c2cc2deeba81d2fc9c2131d4d0db2781d0708c327ea02bae4264c396db10363fdf7d5a2007e7f169438ca1d91053ebdda7812b149c79658b586a418a2c347552defeba067c24505a14723bcb6a2073c6a1dd435cbb7c745456cd281cca57af9147eedb90263557ed","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
