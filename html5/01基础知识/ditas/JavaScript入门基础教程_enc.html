<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f6fcaeb0a2a1222c3674f36a02d8c60c22a4db2941c28d44c6f40708b06a944af8e09eb566154eac56039aa1d9bc27ce0727d6787244931189b3b0c2d23b326e8dfdccb4125e5e61bb895f613e9a71a4c0a186bc76425336792b66c78e495528c030f1055225ecbfafc5b204cc1acb5fa14170ed5760e31fd1b401ae64d9f66ade68f0a1f25359fb6608b60d4105d1e5d070004e50eb3c636af8b39230c64ebf23381d2c91b40179e3e52a30919fe64daef90ce96a1cc4548593170f82107d8046c844388368d8709905827722fa17a7d3e302b2f7e49bfb16899fbbed92c5d3a8eb7323103464319f021d3998acab71cc54e46ced55b140599c5a487255b89574ad2ac35809ca1b9272609470a4f97639d21b74b4a064bfac212c6a77ccf3a450177ac9758df1add1d8c73b5c97cf7326bbf89fc0b25bdaca00d5012d849c74e1aa42f36f0ec2c54c77d339b119455808081cd6afab6592ea327fbae43f4be13c66020d919f328039fe8a1275558e881fce315e21b3718f16ccf58a457054b4b26f0637328a4a14dad0ec699c5a2cead0a6ed14aa75341546b860028d1f526519719285354d9c9725a2ea8b5163939e65509aa72984ac78aea70a861f055abdca6f87610446163137084b4d017899b277bfedb75a35cfeaa3c0a5d66b538a0784a44568c1bb2a552e8ab91aba79059c69f53ba390db48a144e723d3fb494a15b5c508487feb4181b978e679477e556af431b23ca1fac6a01a5f50263fcb847f163d1096603403492f792b0872c144a2653be9862c1370dca20512b8b52d35b76fffe5d4c205e502c66484e49afb5f4f4bc7d9551f884b7ceb9fa2c7e8062f0c3fb51f326a11368fcd4429a78b8172eaaa4f82ff172a4e79165ceadae8804df9ecee447a4b586ec3bc9c7d81cf4f8c21f4c5548dd1c7a08c9bc6e193d44f5ad24f6c740f25c7b6f6730172321178c02ddb5f0fa96191b4a4b59e59615d5dcf946d1ad0f651a71f6065f735b67ed641abf69dc65e0d693e17fd7b426f76480effb3f7896d97f10a71622b1cd3545feb670f3877511cd683845f5b86734e8fa715e7d98be4f622b786b640a6f2d4a55506c93e54fae7e4b4594414da4c109b2c98e331bcede1016e0fa2cef49d50ae9b4f823058612d58c39d53a8757e93236a61efb84222a3813ff0cf0532d6797c5d75d3dddfb9c59e432e81d404044e0099f75bf0edf810220ee7d0d40d228b6e74dadd5c87ec473837d2992af67e807aeadde1b705a920966c156978b7ff93416c6b24ab26d0974af278c536a20b867e4a4b9a3d133599714f0c23a37a16532a1869bc9002e92aaffd27771991f66826cc3739e416325f08f49c14b0f7cf58360914cb38724bd4f401056ddf38dc696d5b506775339334a0d91304d6fdd845a318c5c727b99eb969262467f68826dcdccbeaa2f286c5ef788df7e6533ef5f3a7c9610f77143d0975539ac8f43c159b91513d77debc13292cba348159a7614afd400d19d1c2040e2cabc2e23e33638df83f8b3e2d21455856209aaa3bdb2d31f094c7c82ad6a4bb6dfbf606539b10af703967020499e9ce5d23b304f7d8fe82e58c429d9485baeba882d21ddb807bdb2e0269b19ad4fe4ccc1cfcdfab028ccd6a70aaf041d37564a38679481a0d6511789aed7d46e02dc8dbc3ffe0b8c32e49d43c98c023c5388554d79448139ee4e507a91dbcfe29c9f2cd4ae5121c7484464f1d2c4a12c29fff3de0aee59c6aa2772962aea0dc09c97592594fd0e907bb64151fb13a7dda041d3aa9dd558d6418ac433a473afa5599aa4580f3ece742eb704af519df122472d930d965ac0cf98f5901325dad9fd2109451a4b54afceae8e412ce277f4168d76d4cc84d4516c2ee220197e812765df8b647cb5a61d4a86e203a5947ac69c7fc641db3833ab6c6ff1c53a21edbb11d4d41b1573591222d32b377cd24debc7a184e3d0de52d7810e211a3c729723246f18e80ccbb9e32518735dccb1cc2a0736596eaae49aa38e673b49794ce06d79b94ccbf697235644fd447aff4b24ddda5cbd13da56467a2b604212d8022b2853bd5ec33b4ca3220cad9d61ba185c84f78be65f7a255666f77d4e1fef71dfee2acbe05d0e71806b42d585d969697e31d9a5164d4222c816f7d856c2cab8206782ff476d6385699001726404c63375e2ff0f96fe3373e57304117f286a8c34974710838e12e2e7bd59b226bc122057f6979cb3dbf712530ce38cd6a011aa2f5f0c8af945c6b4929b418b78a73de045679bf2c5bd448db35c22f08d6c365cfbb813cc2aaa14ad1ab642d74d9bd46f6ea56826ec6e2a19fd36e716fe27bd70ab44d044197652c6dfe7b87680a21b8f227efd1b67f4eb0c55c2cb00492719eeae22e73911055929afc1f427ddb39da126689cc8946d8ed816fee02f91658be3bd753bc5cdf8184ec3195888fc210ae2ebb2c5ae681aaec9650b594a92d0cf2448f9ddf9364af146a35eaf4c2ca7cd4a23b9c00303a344717c9114922c1252d2a172d0bd5b63edd09afdbba05723bc3788e3ac08457f32669b8fff53fe34ab05798c4ca25f1e979dd1b2bc3222454240ef5f88850f3a479be3375fbdceb7ea464566698fb7672334bc11b8283a2683276e7532880f09ba3ff487f710674accb29f90007fdbe91a3a8395ee3bd0d81f46716778b6e3a8ed9d975874cd015511e7b4af614726ac1fb63d246b87b0defa7079e30f20957b11084a2548d9246498cbaf885a0530090f7931c97d70876b599ad71fcc1867c12fdbcac388a9c5e2a358ba331d95db295bd5a68443c3625a93181509bdf6bff6ef7ad89438a0033a14c32bda14abaef7ea05122f586193677ef6d05702c6355b70a293a24eb945784851271780e3aada8322b9552282d8c9641ad143ec599aab3ef9a7dc1d21ac3e206cb3082419af1d5d1b4405b5cc81906a641270a8d7e9e91e02c48a729f9fa0eafe47fa345c701c93f441370414576119ccfadfb475d57374afb0bb4ce33333fb576d23a652e5435113cce9453d480d9e27233af9da1b86277f9a27acd747f2ba8c4dbf4aca59cacb703df470e557a22587d06680e370b0de5904445fd1f781ab0540d9d56da4035fd80fee12b5ffc6283a76e5baba07570b564f84e1aae53ae5261542ca0ee35ebc7c590667952b857fb315f63c116a6503934cef30007aa60cfa9447a7bec50fba0b7ce8bda17cdf0badad8b1c093d3db6b22195550923a5dabb6d50007d352d1231a77740d3e58c0ab1b46ef3a371f27e80c0a2f8f145a355cae57bbc110eb9be6da6914ffa86b86dce5fef9f702e11fd8e5e508d9a356c481780725ea192156b0a007872ecc6eb7852ed610b73d604412780f40bf22a7aa93e9e27b2fac6123f079f016fb0680c973872bce564fe5507d19d19a13ed8aab4c1541aefd4d256d5a8cf420b23a0d5d9b33e9b55d64200f2d1e10e588aecf269b76dd59e177787789ebc355a5752d74945197e18f300600059d91f52a641204e867eb8cc9613fdd565a50e20669d4cb5fe1860c3b5c28eb8a63847d0e8f72ef4c0538c637fe947fa8db996e680f12d791e5b42a14b211b5dc00b236b2236896bdd8568784e625d3f71ab2d26f608ef1c77d7ec0a9c77ecb7aeb2a6c6a6543c58bf76e00a626d0877a06d09d5c2a7ca871aa87213426b4750ce592c58faf2eb8255b356741e4c825875d4b41c89553290be815baa4415a2de4cfdc183eda1568c7e01887c8c92927f2e00e7f8cbc69f787a29521108eec9067723f6e1f849e39b73787229f09276772afbd9719850bd9155a531bc4ef0b6d29ef85b126ff4de0cd7065ec9dc9114e8fdf540b21f235e833298d1eb3da513ac0c078fe37bfc24420f726900c5afb54ff98f7344c3e072e720f7caf87209c2bf1044f0895e9f73c800b47934b43b6f200a5b25678e5e9f5cb1c31cd75208bebfd6ac192ac506d3d27b9b0393facc4780c2efc5ba3132e9cc87e051dae41b27b26ed34d8c098c9f97c09533022468eb155928eda0b5b38d6b2f89a0ced99247db5252a68d9b95e0323b2b763f21babe1072684951f309605180bc3e8ebe3293becbd57a9a47bb41594a8b1440e728fcd706846dbadc93891bde79fbc5c3d6d2ea0114a5f6dc1fe1fc37f521b8b9d26ed6b541dd0daf67f31e6ff503fd679a427c3cff8e8cd833b573f3cae0f9c877bfe0924614163e7d20119d776d7267d900f51601f5c10fe751b020b0a6b1416cefaa6625301cd6df0ed9355c068262126571841b3d7b62f7ff3776b54e34a670ca46298331c3faa0f0672186dfb93a151e739fba10592c2cf4ad98672f03511e86a124c450b89237866cf6c4319b2499a04681a7fffbc67392c844143696b5bd74f3d3e36f493d7e2317cc041d6ca9f61050994a968dfcc9581fd78987716151e419cf4e9f11ea3e6790d08028c8efdc86ff43cf50f8750b474e2ac4d9e1b53fbe8141f798343202f22de272eceae689de7cb260ce76a87378f58a4d43b543cb70c4e1b31dd38f4d1bfca0bacc41a48d5f586fa849eeae4e2ea2e368dfd6d42880bff810220434bd5b7ff591a31d43c7d329184f9ac835d782e16ecb9308202062a0659371941acf5791fd37bcea18197846b8493eeec5cf8d1db0a3aa863f190d3f68064c0115926a83f5f2d65a6ad045b14d0baa831124fb5b031e52be98bc87770c02695afdb486e47fe49e4e7d8394c95151421dac58c6bd7c10e4d4f2410d239a6096138f051e4efc3e508b264864ec2f1eaaa189cb5a518e93f2e6a5f01bb45f99a666119fe7064b2cabb83fa37186540845822523cc7843982aec833b3d65795b32daf7f72843d4efb905db1346d5edb52196ceeba4b1d2fa33254cddad0510844efb585a58c3809de163f1cf766df7453c4cf4c8c9af82a1f1e95b19fc7cb365a3d57752a5ecf6916acb86e42e742e0fcc13c8e4406d53c8172fb83b170a68faa70423ae478d45c09ebdabe0febd32a4e5a11bd477b318cb306cc45816a55aadd2ad0c6a0e7924ee32b317a9a9ad053dbdac7f701c27518e9c3ffb21427048b0e895bade30279a7fc7823fe70e350c4eaf27aab3c8e4b3b164edc70322ed088f512b164cf4f1072ea49ea4cd7bbf06f4c75b844a15fca30bd315ce07b573c0dd0c563594c60e9f430795f41ac0d16e72e7e510b3508a2e275ffedc4a129d3c1bd9f96db6f4e708399351dd17ddf3142849ab82427aa972ef826950ea989cee31b46d602bffe3f1367c9f93ae720ab03d2952263607732886b2126fe6504509956e0dfd6d49c5eb9b641942b669bd7e559de963313bcb1873f0b1b25e5048c2287c267861d1a12f369345e4a699c1a056b48372a43c56bef05d59d528acf0155ce74140117464e72b730b3f2780ef19df56194fff0dbc71168680d04af6472e4917b6e86a26b1869ef82f3720bffe84372cff5c6204b80d9e2ed2d55f58e594a189b5f7c05da5f71822fbfac20a611f5554b8fa59e28b7cfec9ca40eac980110c66e12df1db212a2d4df4077238cdd57b29c66a6518f17366cab5850082d687bb28c58caf459d2536e77fa115306bd468d3605fba36094c96493555a59aca98be0103f484e570312a92c1bd79bb658121a3f3ef85426d6d507cf6aa3b81ca9df8bd06e6d5d572c12fbae16ce4cba9068013630f3b4eda73fbe2935cfad47a8b4ebad8768e0ad7078c28b8d5404c3f9be6680a6ecae38a5d9d94e58848855e578b1279d7dedebeb4059bf82d86f0a83290f77ab25670f8ac581e489f5f3992210e8e478459c82c0ba2126ca3c36ad1b1caa041c97695cfa1cde82a16c4db10ad5367d031d5c1f6b5c92bb78f0c2d1f0c4b09fa9b10f02fbb5f1eeb4c6d223c6f371503a98e55359b3cab370b812d49ab8aca20049723d6a803b0b7824b729194ef3b08ee21e6f771b6f1f8547dd01d86ad8b64540e12a02a8d4fdbf2f8686ea891fec8a527d450cb026c4499cb8fedd85ad88264a40c6379335ce1a8fc96d4e7ac0f50a335cad4835b2adf48afe0f197285a696abd1c9f7bead90acbaae6a39d414ab8a9e1cdc7683a386463d44524f7cc5a6dc9d5656a8d5b684bee35f59e295c40d952d0834d6d6bbc64fb4bc40bb90786900c8b319f064ef309613370fc41b69622a6e3f49c8fa084ab888f3f9947e85b814b179b4a180c2eb4e10386040304a8d482f43ef14892245c09c994fc5de9a21dce785f7cb0b342bec090e85af88e08847fc90fa634cd623ec229c4273445237364b118992126a6af1da90f0d1a5e3338b512d8dd6e5b70fe0cd9af2ea90975956683dfc9e14a22b5bc02a67e836d03006cf60872f119d3042962b1e6b96cdd51c588f31ab49b0a269d6694063596182b811003f50aa0780c618201e2110c3aee09a54afe57e4974dd49fc1e0630abb566234a96e26add7ac90003f1a4166140b2c037b90d61cb369432e23d91849d4a6765b790d8049611478dd7419cb4e910b2bcd11f2a6282e3f979c99819e42f27ee76bfb55f65f7a86036d736ae0f001e1b7c042f306087a4b5e318dd3c60dcedffc2164ac3dae29a380b9c6418af2d745c5bad56de4b60b5ab730cbf5c12c37939ab41aa6c398e2f556a47164cde70727599383f6f573aa3b482bd45b9fb0e6705e34a0e63949efde443330d7a012943c9a679a619ceb5af0f181863e5132b013815269aee882c2fecb02039d029214c8efcec3db767560f3cc977114b04ed22d1b333e6c6bd2b54abc3e38a17ad481197649e8afafd8f43a507cb647abbd29361a7acae2a2c50dc842a37a23e7e9f81758ca28e965d6fbab4d42f2dce21cd0eade493a19c76fd4908a657c6e9912da88ff904a999b7f35fca603fce40c3b018eff9981ca8e96e54ab827e67b20da34b33e4a5bcc048f867dce77a6d46daa55ef64d5e98a9ab5a62688db7a5a1b42b1647e6726a5d4963b5bafda3293e75a66da3176ae9610798ef25fc135e65f1a38f6ae22b5a49c08c7e7742da7df3d131691bcde9552ba2cda4fbd828d9b97bf89472159876acc191ec2ba3c9499a92cb5f72ee2abeb6faada4701b8f97069051196fcf379e22f83e3cb1cf98f9923a77db5eb94fc9aeb59d92a8119c7dc477003ae1efe94a01760085829bb404650c3fe9371b86b77c56529dfd867c4e3794a9c6af17e1fa09e8370af0db3f9490193c0cc5a55f3a099406b5fd30f8227886aacc35bafc0a10fd3fe62da393a8acb5201080bc7ff3bd5fe2a3222242227d88fde2052db412001edd0dba39c4cf66380bbd5c0f9b41ccf4d772a9f5c0f7ee979c2dd5356dc61980dfb63d6fba7bb66f1d3763f0d276658ced04eb78bdb676f4ce47465bf6e530d6e3524523aca35bbc1bb5cecea2eb780fb63d6df71454a46fcbb866e4a40e7d6deeb8e0365bb9d1a83ce26533fa9ab9951e768efb5ab68d068e935272f20bd28602d329119091aa3ac2c62206cb6388835879a11f452823bf23617954f3cfa63beb5427bdaa13ce96ce9e2b2676e11af78c5b83212dc0832421e6013004e8d6a00610932481fbc6d3560313bd9993f843f9ebe1568f7cc458a5d736828b84777000d74e5be6cf86688dfc7ccf5d4675e9e0757360ae7797dfa68523241449bc4386f0cf501d399e10d0fb2ac2ad68aac3f6ff81d862be2b0d60f7685c1c4c77fe3dba5e489f2cd92292edf5c5372b5017e4f1a229d35d7cae6dab35a1771b439377ead48df11796b71fa0473db5c60debb04ab4fe7af64a608f12ec4933bed33848db929e681817571348bd27ef7e4fb0ba4e1e45fd730a201b50038cf0d962093c7fbb905f7588ec954183b10bdc95c3c7ff938d87d52a48c10a2e4c7df8a80e76374efb41721544da580541bbd45c70b9b031e418667ff6b4010f5e7761e0dabfdfea9afe941a8f5b3d1392d398e72d0af6bf181294293690cc13738abdf98fd70f5077381056d54d9740e46a70f2680610882d0189b6c558ae92aedcb0ac61dc10c4291acd65203e84dc08ac8b250c320a122821c45ff8bfea51b5f4f6048fa23be8b0970ee8a722c6f8bc25d76433871498541783519f53e2e5f67a06071d319dd906df395ee28e2a62c316ee20762e63585d4f0aeaf8b9471f57f04ce5073a4607c49a1f60c1a822590abf098bfd9300d2f7ef793ff71bbee55b8116e7b76509b649d13e94d2d41cd52c9083ca9f08164cb38869b592692f597a2f74f88a8e2720a381074b63976ae6cf17b29c14d389282a917386f2f8c882c66025b6841d147730a073909e8a02c89b22a298e213b04cb9d6dbce8fedb530d785d1f63afc0797d30cd897da5c5852eb8b1f075ab84df23401f5e1e1ad1ec05d9973c1319dd986cc8560484c3a0f94e02772269a447c417359f3fe90bf7e221ccd2127746ed2a2a5fb347f47d78d8a7e8c160ea412b35dceaeaf98512ddd094f6dc6d16bd05c269d06c3d06912f56bedd5ab31d610654df9d655efe7254dd15411aab6cc72790e471c3e19595263c749360cad277f0a3c01ae919b842d8a28907297a073c396d01647e596b8adf1fc393e8108c370ce7a82d2c3ee75cb722ac50a8cd007aabaed35261d0f47b8c1e7486252069d8fa7d1f8ed97d6b6b2999cc0fa8cbce21fa61c03aafe887bb8e48bff5e7bbdcdee64d80811476dc43fda3575260f47d1ca338a83fae97867ca89ae1349f1774eb5c442a39cb635bd48ba6741b2ecd99637b4c9016e596ea3864d580e5f330108ca0263be6a6b9a28410f439658518db65e2cb0c8bb5a8fe1d89f9b23eea96150363ef4bd8e7392ee3e520dfc00883aafa672c8c969474fa0ebf08fa8259524881990824d2035dbec982ba4be2a60b9909b27d0edc0632f2f3c22bb735337874f4705ab11cc3f2e07c16d61e6ced2be4391096783f3467e794506bd76594c2ce9b829cff2fcdabce650147f653ab73297b319329809cd3b33c1ddba186def9f195a87f69b837c06bb8812a9b23f18980e25b6a2c1974051216d287971d6218ab132374ebf5a69c6cdfd3372e8d9b3ce8a76af662d0d72ae20dfb68f626fbc4868f3708aeb086a5f6c0ec1d0aaf83158cc3f5112af4888edd3aaf42aa3bf96eeaa9413145a67556d513879e1b17411f13bbc66d627f859749468226df0148eb6d4101fbee778afb3df4e1056b7877d988cb749872ffffc255e7140c01f7fa89ed9c58f3e16a553fcee14ed885bbf628410dffa7aab29cf20e77f085e774dafb1311fef0a966726e18fe33d8a70ab5605b8d832892e496547d05a6b948e42ddaec1210325fefad73c20d42fbe277b94f20f89e5b2c12cb6c8ce2b0eba3892eaaa6639caf20b09b1cba6841ec9c58af0b58f4c6fa607c8de51a8d36996df77b724b4781879a6892b2ebfe761deebee70275fb6bf2f8c257896dc6b47c069ef10faec4bde615dc93dffc7263d6de15460b50271e5118318016c89afe9afa5e246a121ed90cdba5adce54a331e9d6d127b455ae96440f97e224204de331f95012556b6f5f14a2f72f91040c6a8027830f735edf621b7333904558cbf9dd97557dfc52600cb3ef0a101d03677262370892a0d4d0c75dee5fdbe7fc3fc12fe56eeb0c135b8a11bfd927b4a389720707b143ae1516a3577998d05725bbd29da6590eaf10176a4998bb19a1d4becf97eb171032914e383a45a38e3efb8c5cb3d18f7fd10889cf590734ceba72e3ac8a865aeea039fb1f1adc67d8095e22412c90b6d23376fd76e9130d4eb49fe117a3ba37f396e3a4a265f913c96891f0b07b066d280400b43e4ce65110f51f818fb75fbcf46737febe68bc04cce9cb4dabac3a337600797f7290d43d4c7226b120b69f2818c4c9ad162fc0e810eebe24f22d57c4aef9052aded998a20ca36ae9c6277f00762812cb29c571e9e8d0b0ad532180097726981f66445b362b7d3dac47a78f76fdc075cab47599b0d52c267ba096561a688978b329ac30c352dde1f5957072db7a733a40937ab5d7a172b967f8345486b43b3278e0010a76e4bb58c4d0a9c55fc561d636f0cd5a60436679be14fe0c8e3478a831c75cd3dda34c0bc7e81af636cceafa9471ac43f9b59608ff0e3253785896291a330b4d527a5f054ac759699be730eebb21b35c036bd350b76ff7c14a4a5ee4af3f4d0799e6033ea411176063dc55879365867601ec91c6cc83843923c08c81e8f587108035da29f7f47b01c482feac73954fe4539c69b9c6033b671cd94ee262a25107dd2cf9e9e3e282fef9c884b8ef5234ab2bdfbf11e85fe6142fac41482f50087a84442c618aca15437ac1e5983aaafaf6a3ad7da97003fa4f1582bb46001d186a55a3ade08a70cde1b26a1a647b011b6b9cbc51f93d70c5014bdca713ffb6b876de3c2298001f3180ce944e5b5c204851ef8c9727fdb0c826d0ddc67540347258ac133e9590058da4e9364c46af3da5f3f9e0a352435eed970f928cc015563d0a13e8e04bd5d5de44ff100157b673c98755924900e18291f856192810c88f8452eac7c96be536a6d505386512ff4ea4f8175b88f30f4a0ae961b51b8b7da18970cb8d14a2b14b93cfdc30dbf7aea2db97917b0df6a8ec2cef86d0b9c7182706b4e428f4d4e1d666c7dfce0c3169191f3005e42c813fd08f38c3d5fe686fef7a6a95f1a4128ffec3311185c4565a3aebc9ad148e3c026561e6903dc2231b7c5776618ed7e6678d5b8fcab595aac1ecf7cdce7f80a86264cb8fdfee24f2ba43458bc6bf5706163eb304c551697a17f7c89357ae15b058950ea5398a88afec7a4962270d88a81ef1ab120bd6ab90d45d34c8e462b5dbca1c8d5f23827cfe0a9cba5ddab20398040119dba23ce8a490a788d469939aa64d14452917c691db5b1205867202d0dcaf2642fc43f74be914ed99cd71013a581faf0e4f6205422138cd976dfbd81953766e7308bda0a581338945f8a937d104a47b8553b5685e20b043a709f76dbfbb7bf410f9e7d04591a80936c6ad5f8060be4f3640652b740f3f1053facba2c84018d4432b73bc68212eae396c27775b7fea4d42af0bf5e3611932ec5189195c82fef63e576d3bab41ac3ffd24890cd09f445b1ff84f0f4dac490c464069348698eda9e844d34bbabf158ced909b08ea930fb4d33b2c82947f7676f48d6336003eafbdfd70c41ab3093ed8d70aea7d5af0bdacd39e156348a599f4324c0bec26bb737c005404735a6d72af2d6c0ee9488718e3f8734fe97d1c78b967e100eaf4b6a80b4b5f9c132a4a545bc40833ff3f1f7ce3fb6d390f315e49757a27ac00505ea130f141cfb78a6f8acfa68c9cef76919c54f0300c492634bdcc6096c2cd777c7b591e57270f09826dea9e102d89eaae52a16e3c950ab3a6de4798581e8c10671fa90b659a64258546bd562e479dd57b3e224b55bbd6b95daec43b00c6ac72127aaeb0c6c88f29a2853878e1436c8ff0c73bdd039ef5dd8448e22af4dd9e3f43f5cda7282f09ba6fc3952e3ac63052429787c35c6bef944e32b414801c367fc0739c4a0ea11137af4130aa188b598a493d4b38817838d5028fdc6b878ca86931d0395f9c58f7dcecc13bbb62881769adf8299fb7799e8750db522aa0bed33c106feab298033e053c9ebf24dae743ffdcd5119982dda8a371b23c882bf9cf80ae69c4c2a33ffa4bb19fd9527ab8f1ab187b6635581606bbbe6b3b1c6533dd0f8dba943c3381d9f5add1aa9eb2af556a2c7c90bc20b30da6dab8596f8208f4a65b76a6b080d72b3a72ecd9ec8afd92a663782c2972479b38960e1c5af70fc2ff93a303b2442053512aadc4f83c40dde4dbca0030e8010f89cf28bbe798677b57355f80963c518ffaab23f28a6e0bd0d0dafe6596b6c4341a1c5a1654b496f2afd4b4326f90ba485ca9f1ef819ee8b6cd4bc6e931413e44daba3d1c9a558b09d3ae4c5af89cff848fa398d9af1ff2e612c29043f8812a147b4cd7beb4756b1696b056a81f0ccb5e0a35b07fe67e9e0a666e8672a1b3b5d491a53914ee00f1ab36ae7b3e58816c2a3cd573ebb6d03f8a1e969edee285415eef033926baf7261be1e3bdd5dfefbff985f571fec104a0bdad4cf51ea8a8f6568ac60b871f000e7b09f0f4a353a7af37d86aaeb92b47bc1e3eeb00b4293be6c25253bdfcafe6d9fb2f2541a483f407c7825bcb293ead735e5d52e7f03eb75d92cf76f19e55c79460b7e632f6448ed0d8078db24f0ec488f9f813e7146676d4a67a226860e4b675a4ba1aa8f709778703338d05b3bb2f27ee95d98b3a637b500089e7d029ba46896596f6f3696ff83b19a7c6e96ffc2d68f42549e3462061274a4b3b9f90ed18992a2981bc0337a2500d56c1a03e1675885c9cf81051995e7f7c8107a70e874b05603423a5a3504fbe0ba0a90522621201ebc9d954100f9793861cca70c437184302971e55d159d8d250523ef63acf2e4fd720c527e523057cf2c12e313847182cfc1ea9e217ea4ea1fa4cef9b2514420d26f08b653304537cbf46022bce4c37655e89ae783b79af183f77331a757f56e01ec417a4a5ba089ea60d002aa05f458502c28920abac2f36719063c59b8918c7bd985a0ddcc6f36b230f3278a383b904911f2512db2e4d88b75ed5f2fb8a2a8223145608b8d756f01e8dd6610da421cbb9054704be5ba9dba3533f08d63c7672f61e67100f8e608350b45d5e0bdddc3e774ea57d0f44984a45f38550072b1ca0a44bb86d036f7ec58ba0788d2490f4f1297673d316464493b87181bd8dde4efa53ac37c728888b51067936dd936dd894e38fe918d73925277b444cd4c28d8faad973e5e2bab18ed66c2feac373bd1e187336db170233fd2d57571a0651a99597d710f51cefc2a55a5759e41f04179b7f2f9bdf6ace4318a076f2058d90ffed42bc298667168a4b265e19b1262a896d61f62d9d7ca1aebf1704bdc94db73c7eaed7bad4c7346d44c6883a139f64509b391ef79f15f6db458be72baeca406a25d912bb4916fe02dc29019ab5541025f8fa4b0beea587802ab52898652a9b4f1c1fa62f01fcd80178514c075c1127c8ac9bbed346d613094216afdfeaf4b1c0b609f3b382920771fba435028e165878f284ef117500d2a9b8d0e7719d2092da355b657af89c1dc5893c6b8b8c90bde29168f28a71413480b2d9ce35592b830302b7dd7b072d07a5a355ab351cda6641ea3f181f609eafd04147be4880f257791b662ec5166d38dc07fb7d4dd08f983f7b7d10f1d5792e0af88e082387983d682a1bf65dca1f67a007c86d38ee0717f9999018136eefa94ca0c170d9ab096596743a1f2426b3d9143cb252f74a855029e2117836e366b2b421611c6f5675967836b5fd49ffd8fa81eb62738cdc682f1a0af7a7345563764deac243d17596741152f1a09c5e6ad66c8b367f46e7633edcb7d3a974292609390d0de3b79da089ebe8b1f981829aa8788098eec25fbd6093b0e08425936820abaac316528e6435e0bddfe92a583e8b99c24b606bbca454e63623fc21aa5dcc7885e0fa9dee91f6d4364aa594be2952ee53adffaedc1503a34082ef74482b90b3a2a08601fab0bc922c44ee0cb7a60a513c9b4052e30de2afe071513c201accb6fab37847118b59734e48492074c98960679700387376d93b1e4964b7ac8c4b8080746a92677f8111af47b3bf0ba1b5c55b2ccbd346b1180912bc1f3313a198eb3a6e5303d833179cda15945ae2c07163f5b525a99d4ab188c866e5d17300de90ff45e0c3a2ea2ecf3078d917ed56f1c83dfe11f857182b90133d91a3b5ea3b42601a18e1ca7d877b0822cf692ca3facf0641b57d8cefa48557e863a50574f03e8e544704902b0aeddf4a57dc60fea414f9e3ee192d463e626bb4f3bb9035f0ddb87f6c18a86b24ceede756e12cfd97042f5cf84e693d2d3b52930be0a1c3f00bcec52db7b9e485acaf50931c3cd6e95a6d91d5c5299c49b75dbfb25622b06331bb29ace352e70d8fdb303b6e343d46a5ff4f7fe1ab0125e88f31d0d70a3c82ae2fb4ace6c5d1cb6f0786ca107b1d3e76c73214fc00a24a4881f626580b0be73255afb8d9067f137d8162dac00e7afafb64fa7f046df044005ca878b4e03d345e0b92d59de90a62677c0a32d79bbdb953fecf01c8b18f16a052022e13a7d76c1cbcedf0b263753780e3ffea88f09fcb2ba54ae996e442e921b9879cc444dc739492f1f0c205cefdc00406309e336fbc032bf38060eb58f7c650b6d1433fc900f2b9899d68e78470d5d22da516e958b9ecca121697dcb77c00835ab8036bd2b7552c99a827b0960d595d0fc24efc172a2ac2ff4a50b629746ee14632d898de127063d2c86c9b43ce670e7ccb55771ef36754c8164e491163169ca3d38d48db68205e24d3a8ea380962ba3765f8ed1f3b16faca06e0761fd1a6595dbd2acae2ead5de9d7e910542d46122abe7dbbe07b21857ef6f52620232b0c16776d38f77a633fe8b8d95ede6e6ca8718ae3f96e89155f88fdcc4493eb1585c54b71d6dabd7170eac1a7748625c4a040d7aff003ad6665509a5c946cbb3a516c1ee055aeec2d1ee3e7fa100857d4f6ebe3fa13dc167e38cd895814d216a7c1d4f0afba7b5a481eec6de2fbc485a448b4acb9dfced625adac1fc83cd1d0dc124e7755dac330bf1381534df1d5ca4a829f851802ecbdcb4be565a9b39c7ce76b5685d7851235f9ef09d48e71569301eeb7dfe4f665a7694cfa489d4ac71c812533abd0baa624c8a4847b10d7d9e3ed9ec2ccff59741670c4f9b4e52b5200d62313d7d6d14aacc38184d5144593b688bd9b6de290988adff8c92c3a36b34ec06c6feb7a355afc83c25877ea4843160e1b2d4e69f1caaeebd616a93612e3f46e869b18995443301f274fcaa60cb3b228d225dcb2a78d843d16a79c06c2a0485cc1aefd2c9894d730cde6c3896de9a5e4c1c355b9321e31a2c350fcbdff094377d9ee51b6831739b6254e6167a5fbd24b454bb91a79d3f3e461b0b3c30954f45ffa3c616c4a7c29dbce94b292821a1a1b4a5e25e98e4941d1a2a8cfc7878f4c2751d5006e378b13c600c8f65d5f6828eaa97bb3627af99b971501d723cd591415dd4394c2adb646e5d3c5cf8c2dbe14804ec0370367bf60a151cb0fb319b6dd328772851642ddc39810e6758312a61190121094cde844c72f51e3625384ab9ba4345cb592865180e503de3798e93c3f6b08080003e47840e638e80405f9fd2119792e68f683ec9fd3bae029ca5ce49a0ab71b14fbde7d7245f3a3a8c83b8baf9380d3fc95d98078d155fe0b90db7f2d95c329df564841eafe3eadb51d2f0a9e9e8b545129a51964db11ba093aa1c78b246b4bc1b704a95c68f601c132d542c3945dbe4bdf91a5c3459eaea14a7850a4993f4b5a609f54e8cc5bcf34753388b8e4fe52b1cc4e91448b84af528b946b89deb42c686fac293958ea4de8055de9e52b6b3cadefe2041f90449dbc5134b55e7350363812fb903ca9cdd9ea2ca481a51e811a04dbb8ad5d693fe26b6e73461e9207e16675ad70d694db705c8bbfe0785f3b247b211add15ab6b63731249b4cdd1b4cdc1d0b2c07c56cb422faa564f7c4b7b55948f855d46ea63b89491c0eb5b72898b56f83ab6da5bf7b7df750066cbb2b2dcaf832d06c3644ef88b552fb374e692fc9868a837f5c4a8a627ea805067443bf8b25f7eea0c560780701659388eba2f45bdb43c10f423d90d6ca00a9dca6be24b339a6f06f909f610ea95478ef23d73839abd081c832be189dbb915bc959488a70ae4788bcd5c3f06da6bea8332ff440da6a890a558d01275e3ead08315c4d308df256d769aafd8ab5696b4a94d469d7c4aed7061bd7d16648a43752eb09bc27e64b71e8e49cb60c53249572433f51f65fc69462ebbdf39400c1837e12bf0612e84863cafb739033117d3091fbd902284d5d239281faed6915a1d2df97ae5da9e5437a0da8894f5db6fd411729af82b26d77ac09c28bfd773981d8b2b092021c722810f7f3db8789f16bb9c7125e316fc1c2bae7cc4fa961c2b74e2f28bfdf4c642f37b149c92c24f62acacc030a438a3c64348f76de1add8f7c55646e369a85c3e9d295977378896e0f4a9f5eea71253bd58a1f4de3d499bd0350b3e3d9b89a6f5985a7831e547db639152d014ea7c76ddd0d62c0e86d7a4788a2df4fecf49aa0860350f58f35224937cd711ebe8feaf92c9ce5227fefb92a07f213df1c3c14f5bfa50986081c4999cc9bbdcfed9978a436c52ce4bfdcfa46fc3ee338edc63ba3349983ef14d4f4d17596fe3474a967df851b9ebd6f5275afd4d85dfd94e557084446e22601bb441c1112b40515252ca099d73e441afa3217ad0a8bda4032c5289409479a857b1e86ce1471581ceedc5c9fe8f44dcbd26af2f85f2eb6671630c033abbb534367c6e8028d21563149eede2a2e9f95bcb38e2c02845809df299465367640bf4adc349abf6149926641eb23ac783461ee01982c60160aac65bf710c0aab7e4678e927b478b904ded606d8a2eb0332bed034840fa63a9bf8e4b3ba005a47af4e0ba8abd5954258731d3611760a7316fe701c942bc619d60fa5a1410f1a68a0efe4ee28058a83118a04513268f369a7ceab46d5ad5b2f420126843b37d3755f27c68c6ca6ba5be3620290369a96d972a2be4f8d2efe1ea0916433a4a7e37e033d66ad8eb764af63fecd998d28ef96143e2af37716a8f75f6c9398c404209314f3a3a95b80a05b6ab22639458c5d8f29bf8da1d8c05c2be77c4f7950add8a032981082c175344aec2a7b7702401d5fffc9a4b82a0b5b9b09a365ee91dd1f3b098bb2d1491e1c3983f572d83e4278f24a29c14cffdbf2eb78cf80f70a91ba977ba84fe04d679890eae31bfd2cbbeea6ad1f389d5b2e01f5d189d43689ef63749e9cc4f25f129866b8eb360f1adcc84b8c3470095b89a7ba71d94409490d829244c3a2f1653dc616c2b078c61f77079e60d1f914493536b4ebd86ad389d9d17096f05e76a945cdebc42e56c2cf3eaf21f58c4730c0a90cb2a87533e17cf365d719bb99869689881e33587aa21b708b5555d944ccb91c71915bcab9b9b66e2bf7459c1056ad1e74db8e60adbbeffeab420727d53f02896d9102f846a5880a7e973ab785734a0724e0ca91b59ba1b94c6ed19de73e0d87f1fff7ed6230c9b26f37212bc464a2f3d0e687947a6e39df559ef289a27553d24e88c8f46302d26a1f6bebb29424cb2532a568e167908b3584ab45f7a5f8605675e12614732703b148178e40c2f68fd94ead03ead6adb9da9701332f18993a6b992b7aec28dbfcdc51d678088e64ff7b3c1c9cd563dec9c956a4c039993d87732d93ff83cf99a3640b6f86353442b3b60d074e7ac9194c830f43e5ce8c02e4c9132092ffe0f9cbe03665b85d89beb8b6f47f4cbd90efd800f6b762de463a012f3d4b7d09bd09e0d75e3a6eb7f9d70d6df4ef3625ff14a92604388dab4f15059fa1dea573fbef6bd289dcf456a15eb7c74b6e787888f2a7f3b1178235b6460f9b3729c078c635e219cbc362ebb0a602dead9cbc2f454907d31b7b6cb8457f812ff35c12d86d1540be40fa98f9aae15a353d44ff3c93c4513808c0345c54cecf72066998017e42c61e6e00d8da91a916fc4518f30e40c42f31f4f6e57d316102200e987844804f1855b3ab6aa954aae06239ac1865649725076f8ee8b15c52acfcb29149bc584ca2906eee08592a6809d34be41f5d566a5ac670c7637c3241831f767c5cb9252451b2c69079d4bbd1c2a95f4a555","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
