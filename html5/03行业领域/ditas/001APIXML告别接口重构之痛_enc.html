<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"735867c053406e468f619de2dbb39bf2228d103e8700ba05785093b030e92df4cbaca216670618f2f77e1e7cefb8ce98c63c184cd4db6c5f4b8705287140af5fcad210fcb699e1524b96457cc9f84058ce0470ff78f4965dc384e5be09d22320599daeee7058e7ed9efe826ad0b702d74f9844ccff45a7693f1779775b2af4029c8a9aa2fcacd37bee5ae92ddeb6d403bc93ca558bf308632be09592556594258844048a8f9b3b1a9cef880e7464d8f17e82cbdc1b1303befbdc1b27b11437b50f0c951e3c01d1c1f21e648483886924111d7dbf0d848741a717b5163a8dcb6afd78c9b255df27e4bc5ec133baffb698ca938ca0014828c9b57db6f11958e0b3c56dc4632490b4442eb79685a56933cdd6396b81faa41d8f2f9bb66a48634452fc36f071b4e15c6972dc6d0d9a6c24705f86018801bf38f051fae08a63d105dd4f90d4600036e57196339613c4fa84701ac7601558a89b7db3e78ad0cf86389a52a7087e6e3e186c76b37c6f3b2caa3f6481445fbbfca7891bd227f1832095dcc198ad31038a927d5c34c2d2bf1fe1b3e747ce125b509119c9c26a918064ad586d562fe28a46d2f36b152385296a128606bef0844916e05e61d93ed2b38b73a97ee92fe5e81917663844ad7c787ccfd7a52ee115617bcb46fe1cde60019e2bd25b78d17baae14531b12f61c6d767141a8d7489e71221db7198fb95062a410e96076395fa2a11c04cad3f4cf5d6aaf2001fe15aa0afd72f0aeaf2919fd9b59d62e48819076fdd5db999aa2a1fa6b129865b1f404794dfa23e09decadfc413fb2a0b3b4c0d5fda4b40c24a96deb5ebb865ca75e46730fe6fd99809e03f1ccc0c01ef3113a4a526f340f7cb87b7e19a199284a5565fdbf335e56f0d46e2e6aa2fe50103dd67b0460a318df472c91e53cbbc3e39f4ccc0b5bfda338640764a23a930e1d05589fdd92133316602e62f5f3374495a26569f9669e659059a62a21c592d13a3420815a1bbfb12905eb6706b979000ab9a0c7ee6fd7eb8292872b75680b923e4dbf8f05e8c6944a239c30c5b35b749eaf610c8e8d80a105a8c9db7b720cacc504a009c90de2bd75202b4377071e1d601e0e9448bc42d4184151590e41190a51656a2109de774f83c25ff5c0f8257beff240321cb0971154a01b28264f5f99358d3983248f72d98f74228aca2df1d6578afef429b9325a1df9fe1502f696ddbe18605f57ae3325da107e8191c1f4283a2c6498666cddf0338fda7c97a5f92990fc7c41a7b470cf53a573727f867fea7316aba60cacd7d078b11f4abd0f6ac358769040249deab989694b05f11f680a91e25c0fcce906c00c44522184cf0a2e928a5e295931d7588bf40aa08b101b68b2b2623e9543a5ee6cc3840f55f5e66ba74dc141ae54b454dca07d8a858ab2e72c884f05cf706bdf63129ec70cacc70f568bd11df687cd143fc712d74341a21d6d799c9d1d53955bfcf4d2da9e87bd1d7be7852157c1b66f595a0f7011b84b929adc6ae3e59051fccb8221d98d2b0d939ccc28cdae70a4a298787256840eb748027e71b16ef26ddb332f2bebe6c23ceb4bf47a71975dbca22a4fbd1696783c6b6c69fe7547a2527cda57058043e31de6749993ddb7da2f29583ca22131829b286ba1fb366afb1d2fe8239aa2f3131f4d854c9f729a4f46d7fe2d71f586b5bc1113329e767bb6689291654a49b8eb7809110e9ef44ee78758b9322344e30f8309d8bace8bde674ce9eccf8ae99c08beb809fe493832d08974603a549ada519c36d15d240a3496c9d782c8dcf470444a5d5d129465655aab784672acf5477dd916833bf4ac96042e402056d540c7806e80a5da3bf716beabe059f00ddd1675e3763580dc3dfd6cf8c3a93f91539604b847e705819b73e0a81380e121c5f208ebf9217264b2e825c686bef3a41aa7ea0094444eccc86004a6864abde4b1a049ddcc4f42fb94dc6cbe921c980e794dc6ba49899a703da8d2a6f2ebd330cb308738bf8c226717479c45c1b3ef2e5f78ae339612faf28a69fdc6d3b6471d26d974d0a9d9df6cd56cf78d4d2ac1717c929a36061314fe670b91f1c96951792fd5c79ebb7d6a16f348cc0f1c84f192c3969d9b6d781bfb486ec6946be15dde9a3372e85b707b7f8519085a6e3bacfb58aa04cf0202f89e82460d9961bebb29a1e41b45c6adfb2f672f7d7957cb5ca2cfc2d3baaf875a4d1ebbea1ad0fa7e0ffebf3077d606a3319199eba44aff2c84935eab8b793b91288a174b2fafa3c15c1ae52c3642894bcf4ab3ef29c982ed5bfe973a5c5ed1473f6042256ee276d0e4c0023813a7800f905453908983fa0f74110e2afa6d5e1c09f94018ab16ca634967247cd843835315dcacccc869803c070ebbebe0242c19e62a6b0fb3d1bd771ce21efe88650a5c8a3149b313a426b945954e4348802a38a43198830ed023ade1f3c51e21186b74e88632e8afd505445d307a8ea9fa48cb5fc0102a6d80b6aa9f759b169f939ac8aa5e0afb5a8f1118f74da22af0300e54ff4ec6a2bebc6a962b0fbdd9b36ebc63bddae40ac8e4cecd42823a7c07e10c626b95c48af2de2ed4221ec57702a7f96f92ffe6b6537d00f60f3fe790d04f88e0468e8241b5a6e877f3cf7fe52ee6e219482ba7e6341f5c9c46b58dea7edd3eda5dfcd8da93a1eaefc44a49dc7a8b9f6933685423117de66c46d70aaf15eee7068a947c7f94c82c09e1ae880136c27ceff8c1caf7ba92e89670d8117224ed0137e57ef96da42a8a70a898b33d505a4fa959ce7bb14fb18930a72cdbbf46e6a25d2007e15bf6c9c796bba5fb6c22bede70484d8d6dba60240c571a376a0febe68a4f1d8b17269eb6958e2de65efb6961c2e23ca1567ef892df79fe6096c84351dbf0cb655630ede2555ff0fb84f03b4af36020914669bd4bdfde1bd042185470d6726bdbe6865b675259a553887b7976bc04372a57f904bf4b91734e8cfea09811296ddcaf42f873485c7f74875bb7655f446fa7a0cdba84e99e3d879b33fc24cb64e61dd874a26af2a5af4cffc7e9ecddc1f0337b8a8de55f625ca0e8a04d513ce18274b8680603ae30c0314a5c5af26f67fb46aa404275fbbd7c8690fc0235fb32d18fadfe6bd0fb178347e4aaf0323eaf3130e65b2fb0b2d1aa01f6cb3b863a0130cb016c37f494749dfe8f4dd0a6ed52f136fdce91273aa84d9a0fdf42705ba0014f1ad5c82c1e2798d2feaaef53fe5e2e2ea4f95372e0de27e44f39e4d856abb44a48894576df7a5f8655523c60a58451886e442a55efa3653a6b694be742e8c5efd6245e892c608d6f5cf28f93cf32590135fa06c6e12ddb2c113563736cd5c865ab8e1351649c362d8a675c066d6d472fef8cc229a53576626cd6846037caac9e53a55c2210d118367bed68eea91d89c7e2bbb61e36ce73303049b01d7811c25f46c00f17138e3e3b5e56378e4364446d01355a126c196dcf489fe91f86536dd7eb58d836b31aafe2c6b3ef0c7285bd510dd33783e9d8c52c5b75a191549a5c4378ebf663a125da0203a3ccda3d163d450d8f6047b776f1593530690130cb4486443c385a03b7205b2892d982552a440aca6f6c45d9ed50beb3edfe6500a28e9ce92afc49962c4b8530425e8c8f0b672d71925f83ff8cba8ca398e110f28fb2026fc2b8236661ac565274eefb1b8b7138dcd889b1bd5e7186d39344be691ce3e1a7393c782b42ec13db809afa87d9035d5bb850537bc6e266706595dcb94aea822829174a210a506e91454781d186375fea082fb335fcdf6e627ff625cbfa8632fa84f20c84097727dc2fa38d343a92baf5b43bfd1fe4a91a487e79078b8b8f0b34a77a2769e86f5a07ec016f3ab438c53b95f5def37a9dfcb0d71fbadc94f37012f261c45091f4bd733ae7a9f37b9f589bcd8f96b35613a209394f7edee671039101e6b5bbdf4ae6cfb8a02ab0a8657e36990cc36e69db23e9e920accfed1428d4016d3b0899eb759f4c1d5854037e540f55bad10afc71baeadf4aa012de08d7c4988a84252c5ecd17ea428a7e1229193dcef31854f131176b038ba14f30f61f597499710e51dbf229c86c42b94bbf929ed685285fb224fbd2cf3f99cede99db97c099cf44bed159b28015b42e38e7ed3c405c637509f72b6a4b35ff273f358887802f3cdcc48442d5caf30c4a28e9c1d5eb6eb42796409b82c29f4daf58f8a0c7d41114191ad545bae202a9184616621290bc1091efa33c1262253bc395513c01409b64558dac89349cd8fa957a06f4c7a2cf74acc801cca139a719343753716b91e44c076933eadd613024a0b5d90de8be96094cb80c2e435b4a2faa3c98ed90431e08a161de9caa0ea16b8fd813b8d3bf61a210b415ee1a0a31c3e8e9eb0790c1426d7a5f9b59177650cc39ea5ca17d02ae7543adffaa6ea4a0ad86fcb75d372da20e2815eeef75905646a915ab335a4d30987983dbd2f93682c21079da3549b07f1f308380a8b9831a5fe3fdcd765a11c80008056a8956b36ec653b2a523e2e563092d0b032ef36fa9502ea20a3bc52348a476704ef3b29044b3fceb0dfa5019d27249c3128c7eae088523f93e102fb3d6c8b92b12312854cf0e682dcf64d92b37a1d5c718a9788102205754c8195b4361e9716e85a202a9d17d6f1c28af76f9a0f2332a04ffcc3827c5aba811a8fa38df9b3ce7ac98770f1e3af37f9515c103ca1af1fe0a6bbdc571f61bf0bc22c689d74212676da834a7a2bde3b6dc4297338b7f0773484ef3161cdec0d006d7942bc07dcd143797763cdb4966bdd7ce0c04a971b70614987c464d08f27e137ae0f90e86124bee87e4ca8151c4e528956ef3afdd00d5b80d333e52b163f2d1cd1e9abf63d0d15ef47c454aae0a3bc1ba726cd7d7f7d6722226fc7c9f749c5851a9434c96af3a788b27f355e1e0e376e908eccc293e8c275ea9de232233c1900473a5653069f2744b1c8fe7bf549e41af19bf6b3520770d94ba7de5e837dec9c416dbca36a3da4c9d3510dbce4248d2e3d736453505b87c7cc6e919c8378d700041fc623981f853e2156f8ef2f553d8e6b9ddfea2b4999d990d0c830ce63cdda65a02c784ec343c65b6642089ce7af029b99883a9281fbf41671e23d7e944910bfee834ef490f4af70b6d7e8a3337c9ef5b72ac2bc64e64ffbf181d6a1f79ad659b69fcceb4fcf7400d0fa1c2f01c51ac63cfad80c16d46fdd965bd147eafdbb15f24a6773269d32d72d6d4a7e398e5ca29544a8fa56ebd52b9dc5df0bca65d7ae312758b1a811c14143f2bd0a3bd1cbc4034fa567eb752e1e1054732e0f1b62cee277fbde9ee8b4f135b092d94f7898aacd3d8b582a5db90ae1ad3ab43a5620eb86aceb4fc5e79763b26f6ceb6e41bfd108685011e961df2ccc606a4206f0bd583a332493a9d1065a3fabf09648229116a6f7a513fd9ccf5d1279","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
