<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"02de274b7a0770079d93aa7a40f685093aa4c2f250fdce7c9d1ae526a8ebb38adba4a1bbaeb16def966a78d921e13eac36438b2adf8f7ecff54850a4ff92cebe6430a51a442736c350578a1c40fadc918ff2d4de9ced211d9d6af0f5177a6ee1b152232a49eaa66247bcc1b6280028336ad105851360536c5a3269781185a535f56c2b3a5bc915e7d410b099db76632dda03f9996296af0c2621dfe94f85e9647a077fdfc41435470e800819459ca8bf05e0bcb423e050c277f743bb56def0a36c9fbd697e821d70068b40e2bb417882c3d22ea32522926598a94978962674bb2baf778659698d811455de45f1a1e000ac642349da81d2d386cd4b9c8de0091edca37c23ce32ef8e466c991b1b3aa42c78226ea5fb33d1d382cd069e791c5059951fcc540b5c7d0bf169a3223b558006215cb1aa22ee39a88dde82cd718e8f84013d74eb1606e2bbb0b64a1e1d11025cc5d840c1d7f84c9c37a1c346b0b7d668a85a863ead0645b42076bbd3c4f506ad2f3dc636f893eb2c9e9ab73f3029c71eed2767a7858dfd0d3cfcd98532d7562b384f56277154a9873f47c222f5641edca8031c1693d74d0aed315744f6e283541f33695ac71ad8502c4b6b579820bb1614155638e938f0c2c651b3433b0c3fb7418064fec9052e16ec1b4af11e55cdf9a57d55fdfbaa5e226422ffd3a22254e8f88bc15d8da27f45721a6d56ba85f696a8d9333fb786811e33439ab86ab374b2423936d16af9b5d90158ca3569b2fda61a76289fc105cc78f86e7815df8c2ddccee3dab2cc4cc6e61e86a13b5a9e58ebc331b184372ab968fc00a5daf982645421a07a39a137e660cd6f3c511a0ed6daec1b21a3bd23379d73b2551d6c566a68cefe1c87d1ae5a9421ad42fae24a390382ac181997047b4080730d60dec7c218e80381408b7d680c976fccdfe42ea635cf31924bc16d7fd8f126dabdefb8a79257f27e90308c89929b4aed67e4123b4b3e61e03137b2d6b8fcd3fc911dd28929111f84593dc07fb5ed64aba4fda94c3993e58f78bbc5a1f8b4156bb966f108734976133368677bd8927e215f062078d7576343a1de70f33e2d538cd50920c0be884c511a9f19d253196dbbf39d512cca10d0203f9623ef0f2c2675306972da60c6bcfd4b61f8141b6d94b059ec69a8ebc11efbe283349071cd039d65f99bded75e1d6f873068b2ebc39d2c745b726f804e27395ce60ed13ad036ef9afff7dff61279a51be21eabfa0861a268ded9bbd779d99d2e7ac821bcafd2af714182e4ac762b8a32f5557c8e9e03d3b7745f7cd815cf1091e04b3c15760219353d3327b2fd3dbed929bdd6372b640ca10260530e4fd2a1705d91f2b2465e6133e61d5852781a1b70f3d584090dd07686120f6fad76d111a230a865e073db316def6a13a18af45d35ff85ae2f63b24627f0e2dee8333fcaf3478445943c65ae957d6e40c844a4c0e15ce2cc2df6654f34b8dac6adad3c587330d6e1c829c14a1749f9c3df2335aa94974ad3f65110e443d0114637953d684555a657d276916c8ec4485bd8bdc06334708719913c954e05e54e0a758e1c4de53715030ff8119446cf7bf08606fcca55d74320dda0a7805752805309b467898708778b2a7c57aa240147e2da1cc73067b581b7bc626c61481097549885751179a3d8db63f8ff3ec08055ecfbd53d7d110b42458be5b94668f623cda8e9a0f5106bc6576f367627a24f0570d9f1ba93f5d5de3156a09a4eddb56db6765b988c9fe7c328fc5c9fef1fcb14d18bc41217876908f51f1bd88a5d762154bcde6e889625549f155458122725a96832bf3b582bc063cff00940d2616490b18547b43a23cc1d0d837cf95848048ca573b009b22aac284bb480b75e9c541cdc50c9f594b06a58a2eadad92459dd0f7431e8641d64a9c4ec04428e49713ec4fbe0052db7cd6ba4c82b4a2171ec3a325fc483d496730a07513adf82c124b11c913f9f5e49b341af685fc0f49076c0fafb2efa56e75f6da4bbde004a22310d616a7bea2f786338a11c96b772ea491fec8a06734a1089af238ab0e335c2c9555d8cff9b21cd8c39de1849654f84137001b198b7cb6c5af0e004ad1bdbdd6e7bb6e7a15d0ebe5fb254ff31b3c02f908908b1cad037d121d5234e0fb7cf9bba7de610d5899a41d7c50c8afb6ea47e5862a60cf922c9e9763ef68c0034a04ad44a60b69d9968fede87fb50000a6c6231815e5d4ff1c4da01d6d9826edb68fa46508f1ae424e35382b15ebffad0918bc1d7c28152fedf1ae89295b982376f218adf64fc581f923600f653529341195038e726a1f6a80b0950d7c7bfcbf1ccf17fdb8c5d1f5fdff19cfdd45caa61865969662610e4c3b97e45ace5975a2e38f2650dcffd7fa8fd28114d0d43d92247ed1882ace00836c63e08e849fa49af8021a1f77a6e308f070a874edfbebe1c5ec19621b0a0f2306f2f2924f978530411853f29c998f9471812ec3de267e1f3c59faa3dd1a71c58daf9b75de0d5538eebacf13e8f8e7b68f18536d3e36398798a3bdb4954d9e998be75be02e737f022bca777e8a3d8ca4ef4f7c9b0bede45b27822dd93567271535da2c44d47a9b97ff57dbd071f17dd15de66230be70ac3f3f1b25010db969b754a30ced68fcc8abb9e560f0d83d61a8f1fe4d6633bb7ff908684df91e34a0ff767d42b3054e02e9527f6d7df2db642495fc2eb0903e1cf5de42548415d4d3a457a9f776ee3fb04966e071f6f6f4efec01e0f781559bdf1dc59d96a6b46bedaee9f4e8768f78bc01670a0364303523d3e695316a36912536e74a3ba6d76b24eebd3165e5cc4189920fcddaa00295192fda3bb61eb3e0d4646e8f595d420b011961cad76400aacb55a2f6ba3b39488a528d9657e4d63dc69f84ccc6a4b828b9e6090e4de179e53ca37ecbd9927b47cb4ae1b94794440b6cac246705892d5bff72e235c58c09e8bc4f694334e4253054c7ac7e091e8feb3f8c80040da87128656f7994e848769391b81738f9def2ed8004085fc068ef2ec062bcdc8d2b6d359efbb3b1c7c09107b68bd9c4d45b9c4f15f07ccde420656daaeb5fa299b4bf68d15686fe115cde9f275e11fb7ca8dc8509b94698fa78af51124c576ad5cbc4d5197d52d52e232c673ef6d7ade0ff6a4db7cef4fe0ccd0cfdbae7277d767e2b419b40e5192a27a5b2d1484cfe10dd387305ca062c6ae96764d2496a14598784b247ba443c0e1ec16c1c1bca53ad8219a8e4f6a619a2edcd4b51ef95b013f0ccf78109fb475637b5c473e2cfb5cfdca3ad68bdbe07e77a99c1498b37f4ba422d44dacf9443670cea9afb6e36e38c8b0bc07d0f8b6edf5b87df719e709d15f7f60fb169092e703052282c0bacf59793dac6cddaf1d1ff2fb77248fe82e61eee67072a01589116b65dde3d3302e249ab67f0efda38f7b4ba9500623a67ca6096a243fde7a138b651c9c7b0a79339c23f9b32701399db900fb79948c2dd63f51413441c98ced893f5326173c3b56f388b7ddcfc6bdff12defb0828a86f72226bcc12fda930b0fe3733a1c906442845f6b19657bbee60d8e89892691503fe1b4e1a10d952fcb54fd06b75923e07cd7fd580a5b55342d49e679d0a22e090140fec5b4811f0bca853d9ea745cbe175de5c2ff4b57172acf30ae18a6cdb0aa8e4300127c2257916180af4561f48c5fffc11e328aaacab7fd3f74c201d7800e6ebf53dbdd40eaf0b24ccfec44ec29072963dba4762ce3b4d186bce0d481473d91ffec3c9e1aa3f650d102c5eeff494491b89dfc7b1f9e1ffbaf6a380caaf116e3505368d46f5f5db222629c88bc771b5bb51a0d16264f3127a6af981847ebacf05e60b620e09ba43e9c26f5615734c764c22771aa27afc95e867d72182963c106825c15e5f4a7ef5890e4daf3bec18368ff2ca5aa10ca9905328df2468d78ebf114ed13bb64c4b05a16eb9b4b8032ee873653ddd98dbb0c4b9bf015bd3cd7cd1d71adfade1b14874c198e6f3ec6738ffb8e4a6abd092a83cf93408f13530c146ccf64536413580dce774c373f2ebc0bc92cf43b55c7b42dadc6d3374e26d7626db917ce2db5418edecf76c339c45530ac999f1c82b0217a5cb1727e44a7bd5279736a11117308548d5c0ed3ae9e39623501aa311c3ce2744f606fadcc741d3425b3841205bcad72b64929427c58b825551723cf13535f4866b7a81a1e2acc6a2b5ec200d8bc41447a7c2c390dba08b42ded68e2a0a36471db4cc3c8bd3c0df89a4d2404ca96bbfdcb378ee51c336f734ff9fe328ca168f4503e885d3877715c022089554337eb5e73c27714803b0bc737c87e542f7eccb2b53d74f726380ecce8598ae219eb87e25c45568dccf79afd9a6647f0778272af5a0fb114572ff4f15576d5aeda92dcd9c5bd5988a93eb99654012e0542d4008deb9c1f653ae85ea6975373574b78e594343929ba87f45130650eda766ae292cb7efa6f92bc6da9ca919dfdfdc8c67be43d40950d122282a984d529b36750057e3e72f65b739f0c4aea068002f7c927049c0694dd91640c2fca29406e1d78a3a1c8ccc89ff2309e771200729b9f5eb666d38dbaadcf816643cffc9cda886d6460086d7cc3ea9fdb4a9be6f0c38fac97fbf54bf003d8d4f67d389ebc855709a91431691eb6814af8f53c82894fbd7ffd454abc4bc8b565437f9507c812462638810d3802bf6476eed38e63de5d81c116b4afd2d4c3392985e181db275c4378741398aedf99f4f4cdf4dddfc720888ec1a28b43cdab41d7c6d60349d55d4eb8176bdd4028de7c5dfc267949c23f9bd4431e0bd043eb269f18dfe7a2300a0f5a8f95095ad4af305aa39a6b50f4e8a516e6d83af1f528fd1c1c9cae10604bec38bd386ee5bfd8a3ddfca2d05735e0b5f99bda610c670ac81f3e1cf5bea75f6dd85097658be60642f826030097854298a09f6a26b86e75e61605e95f620a72a5cece986591eedda49555ea2f66c820ea6ce109c1d2c62472ba1b55cf1cdeb9a5ab62b656c00f5256bf87269f17b8c7599ac4844ec621a4cb5934b918ecaa667312bcdbc154e0b0dd4762c3160fb2a11f8b77b9ada9cd93788ea852bc3bed9d904b3ef0f4dc39403b810d3a8bf62b1cedc1c598a21587886a4123d42bd080824710140232da1c1608e60d5cc72833072467a6ad36a7bfb895ccd49ff60222055ed356be73f9c89ed98835dc81a973012c96bdf01cfeb13679b5941423eaeb22adfa30e60212687d7aeffffdbb6ab66acb99ac26bd0864671188232e6efa0becc945364b8c10700c45bd1faa45513ccd89c71470b457b0901ad80b5c6274c99ab0fa7fe5f14759d7156ffcaf770aa3704db928bce04d0abc7967f7ab9a398a57aab8fcbae4ef8fb960390c0092f0f12e40f7ed80e0ee568b40383d708bdabe0c262487b013dc0a85e3e071d8a6c9bb761e608bcae5a666c538c0bfc747882c288dba3a929a4d9399fab820817f70016be62a172359cb948273fb7f9a636a36ba5455ab05653594747d6eb9c22da5f8ebc77cef8989a85c284c3b1c4ef4b2c43260c288e428a8b3ac97b65f6980546a1be6ce2d499ab4d06c547d0c53f1a6a5bf545dcfa55746163337cc2e786136358f88f52b46b12c797fa2bb2a18b80bc8085bd0e623b943a6006a1862063be33fdb9ed06738e1f194de4f9fdc870b4ef7b26e325014a4fee6ca0f8a5d654098abd1e1cec4244709561619f1f690756691d1a6ad95aeea389b58e1134766ae0ab1142c40d4a43e11fb8509abd8e082a90c651bc63356e568ec47ae65d986f3a6f7d9d6d24011c7b5bab26b95a84e022c3b0167fc781ba028a8e6f164063c3da999ac808c4a522d35f82bd059db67f9373613726f914c70f7cb39c3a15c637e9bb310ba7b0fb2ce0f4622254e1002a35af512360aa0daf65b88adcc4c210d3fb1eb917177099f149b78da8a09d5cede612de72eb9010a82f8e7a1f9f661407ccf16c2ba8f361b84e2e8ea5f4c6ead80cc8c30b2dfe84985bd110db78d55d77b0416b76f1e62d4b1e58a8c42f0995771fa3ebf1649ec633bc3dd3c0f888b38e4a88de48e19c5166d8b41d18cec8f10405e12e754d19ae4a293e2264bc4b31c9b0142d2f5fbd96050440dc2b4a8ec3b5e5e9f6b84623917c6177fccccbcf7f5f6c9dd16d592801751ac9420ef7e462298de737ee8523619a9a7a09ece160ff1aba96e1ddbf73de2b2a229d83de3e706521c409e589bdc3e4da7dcbfea6baf6dc659144f5a4eaa9eca4cc85fa10f2ea1edd55b1e44cd61fcb6060d186a23f3db1f197bd5e212a12c4708af9531dd899a71da58045fe9cfc26a674cdd7e2ae3cac75d65dbe8eaf1f4e77da67e0f376e8899e6f60714eba40e77faa470961557450fcb3b9028b9b9ffe08e7b60780096f0191d1bca3496bbe1aba67b7e3b8d547d21232f0742909ae21b72b8d37640d91f8e7ebb5e4397b7ff6d82e46cf44438be3a42c689ddb5dda6984f934e222d3451be0659a0951fa083acc85fcfed686373e9d8e844a0cf783289915c8d1414854ae722486a7bb544a812753c54ac5dad9b4f4586251896f19deaa0008af0956ccf58128102cd2970c53c6961ae027f773f1391630dceb413ec1754cb99cdb8f1fc01b9a97aa36d0e879731a04556af74a88e193546e2518c6b114fb15491c7f6c4cd8d0d729430b5921b593cd1a29b834d5947a866a216f2f6e555dab9b91b7ff46c0dcc3602a5d588ead245ce570968a68c3d3ce9e50877cb2bde7f4b95496e4dc2db1ff195522eda44258636a010013cb610f380c1b3d26a7f2732da3d89f92dedce598301115cd1b63c1c0ad6b4ac9fdb17c77d0cde8a8c9ba87bf6530b697be519f3dc0236b6ec43cd4ef279c5fa0bdf528a517a7cc63b51ae3eb8bbe6d4709c9aa5a8d9eb07ec9f11f39b3bd41d48f778e1293d0de0fc0856f7b585c3c6a1da23f03777802dd74b765084d92531da4c2cac52616d496b7b6949df40fe32b79170f37502ef0683cd48c5dc7e83564bf5b49fba2d71800c71e8424cb6d3e0ba2e45d549b9ad54c69c51cc4ebed3afb374fdd6c3eab15914f26b1985fa22b86260f44eb82e44960a45844faa4eda9290378f8c0f408b72fd101a5e2077774639ad5d85f36efe710a46553c0a492b85369115db317c3620d2cc8598ad0ed13425df96fe3c1440ea44bff1eff9e83a4a4c237d2d7b5692f2257f574ae29f688cc2eb3347ba187781bcc16577ed10f6f3a856ec4dd2749ff334e0264ae75689f404b70b2d3e4917e4f202c385d09cfd262fee695d88fe53a99576befeecf31b9242be1a9abe7b917d3b37ae50b63ab722be0b39afa715c4de248e3e80a2e3540e3960b805cbbad41b39e0e8d9263c203c09ad700f40b3c1253efd76c3e4d720b5e749e27ec8f9024856bb3aa54c51dedd34c918206d413f817fdf38661694e87718c9e95612abb61d2b2483e39005ee32283333de08cfb847e94e5329ebee201bc318a06bc0ac7998ca9378325ce84e6786fb7cf7750eee4f2318bc88fc4017c6c9c475159449d273d67ed02f1b505b50c7026de5f7fd166bf5c60a0a69dad42bf8e6a1631c7b82b7a6d4160df6d53b94eb78176845b5a2643633c6ab540c80be439fd202395e962a81ee086a1b8343574fc35bc362a8a78910977b6bfe4ed1d01896665030e4b26edc8537da5d4e66ecd307f8c71b013d8db88609bd145a620cd3ad37ca6c047790e8ca9982667abca6c5a03dc733a527eb1e9e77e0b352ef33d24fb7167d74cedad91e95252d95a24d7898c29907be0d397e73880911920bc7f55c33fd13d28a6a89aa3cef1a077b57ab3174ebb9b1f7e82aabcb0419008145d3eab21b374929c5bd7e93edb53e378ea425f2e160e3b835edd8aa1c7ce29ad29e50338c1aff01e063747ac9614e19d32190e9ab58fd3b368f4084a98e02ff3ea5499e55c9a90ccfcc91af603e5e799abaeac7a3840a869efabd9f05fb42f3425b35800fba40ddb428aeaf36c6207ad49c1fe874e38dc4175f49b40a57ad25ee31f2d00adf22614bf904d013a7dc3495b2d0f18f7f4fe4c392531516a4d5f0b9f4fc021f2a96c4119f9419a1758ea93457804910ef74c4a3e9e5be9c347591187e78ca0ec9cd0cb6e53ce991b4af67581299c9468b7d17ceeedbf34a9f9bd081d04412b51975b7c7cd363f3b295d1aa0c1d91fa1f92d4ab66c59161cd50e37494c77f319605de56023eec7f8d3def3c16a0d1df92d29ce3e905ae771730ce37de79e8158d7187f4ed7b67df174084b06c21134128c70f1b85ca428fb12e67a7a1381be9816591b758a5ef9c0610d6b36e43f67763dfdbc65c69e46b0d9605c69d4fb72bdd2f9814a147bc9d83a6004a1d4d07908c08ef854bb627d9d01217fc4cecfade2bcbe482484077d4692fd481e5380816bc743c1c3f83062a55e4f36c0ed002b24463dd06fe13f80c922c1c4ea27561960ac466d2e0aed7c92e493b45c5bf0534077f622e6bbbef8f8bb222bb3387a14c997e1a7283f528b6538931f425b873e7c5f3ebc79872473369989f684f1be19317114f15c9e615c2380e9322b15c7dd6005c3d8094467eade37cf5774d5bb867f0fac6c0f1086bf741590429b3102417d9a772f8cc21b78d590cbf19ec18593154e92193c5d649d4f3d44f47fe894be0575e35dee38bbb22c31827ef337bda352fe2be488e521278e15f6a8aa5f5788fe3deb6b18ad61dcc7f467bd30bbcfc9eac0ef42b45df02b7208357df4ab8d637fc67515b3fc6fd958fcc9966738fb46559c867703880e5d82669b387c71dc9d5aa85e996ad0f016818a08a7595bbfd230c4d927760ef79400e01d54122b3115088b75ca20c3035d959ad928b35de94a97b7cfa4eebe6c7655e1301161df243302a02c3743ec5a9e1181ba6f7386787c211b7e89378e64babf38880e5d9021accc18183c4983193b25cbaf0c13c562b593cf7bb1cc44ecdeb9b88a12f6d7f25e36660f25e3c90355b1ee721535b095163a1967a9be5141e0598d8aaca18dfec0ae6d67854680699023d94d969381ed86cae4ed63a7a644a690c22eddc3ad04f154909c2128c02a3ef287e8974f21ed0fea298a8d36d8019e1bd7f076ca71f2d376063b76f07eb9ee663010653a3069785a5c4e813f07f391f632aa7fdfd152e679dff9be42779538866c07a75ca076d85803ec0fda799a47c1b695d5764536f89be1d2acf11c5903387bf407facfb5af4db5b7ccf3ab92484886329d90d7351b663d3db7f2382830d3ae558d361263f1f5cbd6914f6a92cdfce3a695efc54ad745dcc22ac836b6c92f1054f0c3ffe3ad0288069c2f1d2d38af72664924e47d202ffea604b9b20134db4327af500ed17a43e811ee793f65219ccb3aa9d8e32053342838549fd3bb938c44d15316498472bdb620b1db5a779fb2c672555510825e96e27e8475d1aab5928e11b2b92f5dea6bf08402ff0bae1de545ae236ff23b7730cec04ed0bad970efcc013e1b2cb36e14532e3611dfd76a63099e2f8500a82c8183da4132a01fed0eba6b893a0f2801df7bad2fb719c94571ad2257643fdc061c6049d0fb4a6ce97600d2a8347c069c1cdb853c1dcc91f8d9f8d7cfa722f4f0bd7205940a8f0689461d04be3d3f1931180852d4b436ee7fcc1725cff8a927b1a09c60b6e0b8cf48dbdcdaa1b2fc20fcfa4a726fd2fa163c0afa737a4efbb843e115ecfebf8d7399fe49c42e73559483121137c1b04cfa45b86a31e5217c4dc9c890d20ab8dc39e3b1408dcf2ec7cc41d64026b5b4741ced05e03e7ded8d1b89e8a5bb8deeec7cc6f64d596f972d8f43f143d669523895d6c28ac663aebea9359341e21856ff11982127f9dad4e6a15026436950a04f64d4a9c04c615cc0b83e9b8b0d26a0571124f2e9301ad92ea1869ca97ddfb373a15f87c72d1a92d22775f25f8ecfb9a4d3d906fae70880d450e20640d6e80ed414da4de9ba95271d2570dc26eaf4b36c43dbf19c748687ca3022d4cbea766e911017af83bbd165f3d5fc0549565769c0f0d29981c0471cd977308ad87f99be3bc0c265682b9e8dcf35132c3639008f63642049a9ae75a0470e4b35238dc648364ced09efe99d6209309e4595cf968979451afe3bf0bffd0f8a1e51af633d04f8a0aef98c1d90dddfc1dcb9079e95822e32890b39b40491cba7b3685bf98635e2a33de2af04595777267c002e7928c5282bb88998ab15349b262eda4362d09f911a02df8c434d2759cc3b6df2708e80d93e6828cceaac416b26828d8340221d7c762eee8291b201dc0c715ab1b088dd72040d0ebfa222d51b4067989ddd7f8bcf5e4fc409243aafdaa3af0ee156beb0c8d7bc180a2fea5741f35699dcaa128cd4261b8c0e46822c6cb3c8f28131e88e24be9a3747dc90caa6408cd9782471ecbf80846047c249fae1b85f048f1bf8e8445dddff8752dcefb03f19ffa1840f73719c08b5103a7ee7f2bcfa6f0a6ba6f4257963ed61a85473fb9bb0cf8513fb396e0d96d3e89e195b502cf5b9553d7d9be55ccbe91fdc004ccb06beef104feafebcc4322f27777cf07a36cb2f61c7e1d2114750b07a137b6b366231cfd25761b16eef3a78dfdad46c5b12ed929f852c02061abfcae381c6746a47d8b7bbee77dbd45705fae6cd6e70bc32d7637b95875c690e466c2b7054eb216fb3439c86267437f4c12a8c281db16b98d760b743bf7f313398969f198fee4ad1dba20622453194dfea05133e650b50493d2038e36ef2c0b51ef10e7157cdbe1d28e9350ab6eccd25b76a2672a0c1d95faa0c131f5a82ad5e1aec29d295da6f23850674435d1eeeb7a826faefb55302523f9958bc0b8b5faf907321df3a3fbef8415a20a235b3b5208136db4df41c01247b709ae2edebaf99cb44c4adff3daed038230d47d1fe57a2419559abb1466b1e81e960e8eb0cb9f92b54877b8781e47e2da7d1a84090636fdd74ad8dd34fb74c5e580a2ac5ef145d1ec445387043dd1cc3a804f3c3be0d6b036f8574cf65479c3615eb4193572594949869e77e15441011f3cad38f41986ab2d9e6af1ea96f5198bc67a7fefb34758ebff580c2fbf45356a591d4f3393795602cd537112e1c8ef0cb95024ecbaf143aad5842737110c60ddfb7003634c0bcae0b74c8ab44c0deb7f299c08a819a46b591f1f0d79078ac696b9cbf8626e88e36cd4fcfdc3a14f2c8c8ec1f6b69fb7ee24234a3d5daa7a316c7e014248bc9c0987593aee56afc3b3cbac7c32f1699301e50e7e21bd5c067da088c32679d6952e26803616152a6e8f0861b76a470f22ba6f287e41a31b5c876287efdbdc6877b51861f0585c3644a5a917672c3842bf04bc70531f583947deb5964961a6737cc9d58cc23de3d46e4c25e7e65d1be970cd0791bcf5cdfb960fdd0bfb2e266aca771bcda920c5776529d7140bdf5c51b72150d542806ffbcc4572e5343e9ad06730dffc73cdabea6c041f47299b407a28d425b8f0b460a67296e688c3ef712dd654b1b59c8dc6d56159e4e4e14350712e1f5f0fb0cfe28eee39b9b622514ecd633905462ca640c2486c74c724963d8d3f8ca2e408869bced1467cee212db79fa8209a9bc9c1fada1b75fb8667f297d074392748b8f9dadad488001cd28fea19ee4e119f6b8deb202ce7d1f950141f8c20cfc8ea4fe251130b1c22e9f274dd18a83b51f16e122b7b814f37819c6761763968a890fee210593b59fe5f463d10a4da7d01198e753dd8e2227b0202b7e3146419d433cb8ec008dfbe402580859b6078c34e32a7ef0334f9bbfeedb63b706e60ab16221c7390c0f7930e7fad7039807af97d7c285ceab60b0a3e9d7241dddede3dcbaa936131ffc14f3167a26e2bc488b7d61fab5051d3c40c4898cd3773cb5ca60e3a60c10b300f396fde5f2fa328149fdb35ca5407e0ba49ff94e91e484c1576273a26250133aa3a6ac63f7a684d93a2a35feb64eff07c96bb5f67137acb01c5ee4793689d343d174fc9f85d48190f158ebedbdf71b75abf3a3ed5b6add6ff82ea8707c9bda7c8e3fb8b0f38b836803202ada6af663bbabc5bc0c32cf2b50c290e75668cbc29a000fa7f11ca470d6799db413d07daac4a7b297793483e9f9393fec67b5e8b35dabea46553b53f282cac2ff98dbae54f667147e94adf71a10508db4d35930d80f843af8dd57587a8333763882cfe4526bea72b247bd5838e67d7aea6e6982d169e5fd13b3e4d380bea2b4eb59eda470f57e34c79ac32b82a65e6083bd3b220b21329d772bd1da65be76c3372dec419607926b3079bb6c409f8a1d482d9d4856b7ae0b8188d8e23504c2191aa85c7ebb3ce5e4150c69dbe5e79720e7c133204b69a88f3da03cf9148c4f265eecaeba0b053eeb3f473346df3ff7954153bbb7a51b528e12fb02174f0c399e525812203e3cf8b02c2e3ba2e16104c8c876f88710f672056185cf89d3e59a0e9347c6fa5e4aa6067cfac4275319269164f40be0a3773c32663264860cbe1b558a1ba1cc3d95cfe6ffd781ae8b4db192c71bd757b9464c7b83ca4733f20df50f0b64b7f08a083c5abb5fa3c0db4f5d3dad3436e88c33ca6bc4f429260203003ce464dcfc510f025e7f766ea4f65596d8fcb6b7c322f5f77ce7eb104d99078d5e29286e1d48546f06690903888f73f75bef5ebed6293c8c45f6295646d3e53e00ab38ef0989554fd53786c06916b271fc623f20f47495c56138a065cc11551ca842a3f75b2b5879d88dc51cbae45b153ef0f28540211a0e32a4fc65c57127792be23f8a9567539e2d2d441495e60c786ec0299d940a3d4e99147bde0d323efb1d58077fbbd7a16233c4eb234f8a1c61223b4d95d4b86db24ee4baddc9b8ccaeefb19d891eefe02a7f8848efe6e826379a6964428ed662c5f61e45cf5e126f66ac8c3a0afdd628469f280f4d97eba052c4431c9594956d703503b53d1f7a7cc5154c70ba1235672244d4ace171d935e5e7ac39397c904e6b8bc64d36d5756539aa60c2f30c4c2d669864e861fe8e6eff0320a150f6f5cf99f629faba6aca958673e518aa0b59a9ae9b6487a3763741fa60a147d2123b03530dc83c09316421bfecb70e3d37a5d09f69e3388b675f5dbd69c979b0b51fa26f192f39aa1aa13db0b9fb613676a8d141df5461ff6c7843e49ed57c78ccc301cdee70a8346aab19fec89678c0c148f152283ff9b6766979892587c64ba5b1c08b4a72b92f3d4a7cbe7060194e198174c613142e41b514232b7e921f4bce1e52082db99691b1580cab3856b61ec3dd11f6d356f612b4f37ba6e814db4559efdde9493705c480ba1204d8e95df6c38e64ddc0ec0014f529388fd14bc893c42c98b74fe8d5f20e8932e61ce32a0a3a7cb5a743b442b9b962e4a8fa3a81ec6bcd6ed43b946199aa12d20ffd3c30691bd04e8e187fc0c6141f3fb68930dbb776ddffa01c60b89800576c532b4cc51eb3ab6a5e1bfc85b5e514c8ca955e0ee3dcad8ffb974086f3507135d8c970d64758c624ebd2c85dec2c52e7f14fa56f3979b2331031e2ed7826fa502f67b69e252b5ac6b1438d46873eeb78e9afac74db6c369e0ae80420ef3abd18955f4da526974481ada36854837816842808d4dcc915417ae88d9cde944f7f0d51fca8f9ac434510115c84e2e4172b8ef9f86643c7ba6ff68343458ee24287a55ad28a70dcfb83e0d3af0a9c3e644fdef30d0aba99c3d88aa1c3e189b47674bcf384432791729515b2ec1a3a6cfece7468e4d832461b577d2c1210bd329dc6881aef6165fc63287592f57b5b232372e5997153f2fc86a7c2d460c6ddc051cadb0219b2867eaf71f735d0d7fbb89ee1ca3e38489738d01f46c02ca2d208706a2c156ca7d40f82106ae3101a3d41094512d403e2854db47947432370b554588fe93e228cc99c412a25bbdc1f28f50f5174d2fc4f03d9fdaa0c4a7e2cbf1faefe6129015226b14ae08445927b0c1027e50507fd5539143c5ff37bc8ea0a1f43e03f2e9496b5aa3cc9ea039401fe02c8972c0cfe79c3896095e8e329c6a6a9712f269d46bd0dda0bfc0bf178043e3cf2774d451c769f1dae5919bef6bd0e2c94aa3a67e05e984626747ad36ed6ff680d674580583ccf6f840d4c5fadc9569f35c019bc71757e51f3e778d1a3b9397d51a25a32698e2d39adb3bd1e97cc58d20cda32039f2bce2adb32525fbf90710b5f35c85e6f4bd748e4c3bb2b499a3e64f11abb8e678d1b27acb21ceec23a81a2c33b7df6dbee09c196ef9c31c7ade00853a4b5c1d704848fff3eae5da8781899ffaf4acd5415b7bb4bd5e1ae98323208a736aa595054dca589f71f6aa223eab7d384b5885c22cacba10c9d019d2fcfcb1cd7ed040a93baf131ab55237bb391aa7e8bc8d3ec672f6605e9fff98c2feeee9f93b7b544399df13dd536d18e7c15e2aee6c454a0116dee3cd52582eb22a6511de49ac1a3affc21292840145b18cefa43fe3c2a8bd7c88ddec85fd66848a2e946efb189b23eabcc15dcbc3b718a7451f8089f6be2c7717def75fdd4786449978f1f502ce5ec4ffa7667916b4bb6c846c0f9751637b0f9508214701f4943abc9ae7adb0af4e61fc73e1703008f3ff2f1bc5a369d5c2a598ce34c61ff40abe920cec3d67429d297a936dfcb2754cb2080d4ec7602abc77e4217c0d0acd817bd64e88f28b490caf4edf283eb9b5a253e59da9d784da15d600d4c98e51490e3c8005ffadaaead477e060c3ac2a03aa9a4b95a55c36a4393b39c0ae9099e6c09d391424a0b5e415bdc0885e84685b4109a993f798f1a3c89605bcee91e7c758a99fbb871785ca3552141b7ff83412fb00c8fc8c535561cd79f3ba64af9f8d8c11e4ae610d3576bba4bc7e32e540504326e3ba84973df5708093b70445df07215a67c5ae136bdfe0eeb7a4597cb8096d10bd9297d346afa6d9523c3a33dd7f4c88fa863585b35c092fc2625663d5d195b89aded516f3e44023fd793c180e10d091a6643d00d382f093da4622dfc42b089518b30ddd1e6b6a89aeea90f359a918ce23fbc1b08c0015d0d737cac564c2640d58887f27562a471e1e367251ef9cadc93a648e5e713b94ee0204fd9b0b30e6c261ff54911e2dd103c853fcd7567b94e90307b3ffad633019398814906e8ef1ba74e39400ef35ff4946c0ef076482260b4bdff07ceeea521cbb0ea799f0ba1a070ce34d799a93b6297ed97ad8f18548806853cac","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"cb4dac17dd2d3b658155eb3f63bb6c40"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
