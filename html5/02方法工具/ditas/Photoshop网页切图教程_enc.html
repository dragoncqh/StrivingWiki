<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"62d9f8507eb0026a7a452baea69e959850de697d050fab5413697d6b259e8187cba3f47de01de300aefac047ac9e1f3e2e175fe8af4713540a83aaf70899d7e320da8887093495949984325c78c048d0624b4321e1cb64764f930cf89d33d691841134789998a6014c60c3d3d2e1e310f7b1c68354df0ca05a86637857575948e8d296b450670f7c4826e669808d7b3cce885d7c4898c25a03e529036872061715f157b5b76d99cc0190349c4ec5148971f0276347d232429144c17895d49d315ae0013cbb8076aa41f91a718477024a1def240972f9cb2890813ede65bd45ce99b6f83f270742c1069c5dc10f1bd5143a8ea2789ae47ee8876b6dc8a23b9dbb2cd43e9515097bf905cea8ba937317ae01b46ee8d4bbcdb24866a3d8869e79e20c53ab40925dbe364d031e75e4858d02b83c7f242dc218cbd1be01dc34c5097228fc3a8fb637c250877ed975fa26b30f756b8f23349c745aa87e9c253ce6a70caab7dfd72971a9ba80c409bfeca86743b33459eea96e4fe3c3271fc70e8ed4da7b1af5c290f4724c26c8ca180b7ac7087acb5aed88596423733820f79e898821547f096b474032d226209967dc3ff9c0eedee1df2a105dad95fd09e0aed660a8b6e8520fa984991a2d849c1baa25369403fe7d7fb5fbf79dbe7da2e26fddf2704be06b0c08bc599c054a78a419f048e5ed0d9eddbf7f0fcbcffc083e4f87b70331ec7e542eec3a2276354ba3af64e4d6f8a76ffe750f87edaf4f080763a442605f8deab11c1b3932a7e4889b3976c1c229b6f7f3c3981a0a2a40111a3d0b8e901ea7b37cb1eafd2292751cd3bb26c7be14f5b29fe2f41e02a55cce82b61a1a069f4e994fc97a44e145adb8051453fbbcd3f517b1a633c1603b44a7671de6176b42eddb39170dd1c8423b2e8c4ab9a5406e46260ffdb6a383e406cff24cfaed876d98d9e0243587ba30bbb3eff06bbe4656e3c7cc422ae2443a65a9654216a56a2615b144e1df3d97863ecd9bd880536283bd8e1c9338741e435815aa943ed2a15ba48ed7614b616e6536d927a09db8f8ac25f4f1f44a3971f73545ad218dc54a040391687afab1af38b5c22c427834bb9b8e903841c39e30f3ef91fd9d2be71c9cc782a1b8c3aa0f07f1c3ddb0f04390ab23f6fc860f0b02b2de42b7b32e8f7c9e2c9fd8ed56316ca1d0de636842ff45d0e0ca5d69bca5b567cd6dff4fda2a35fc60c09053d451b6ba8cefeabaa52cf553e544f1e6a60271b256ec93d7f8ccc0b299096e9412b9282b8e15ce605468b953e70de78235b63718abf9880c3acc2bc47e72cad57a9c1c5e7a461f3ac4538b0166d8291f316e506deca5067ae89f92b0637202bb23b01f96a5ecf6c2d1a655886bb4e9c55430ec08db8247e8d6ebf6377f01b738340b21e48eb78e8744adc99468f2e0f27fad55208389274b8e34fef428c49d5571dc24872db0c2a49bdb46fd5ab4412bcd72009a8c65a84ba683d52707d8d644730492243a7db30efb16e75666097d72d97b7e7a9a31f185aea1c5b167c45736ffd68f3ae3590bc4c090a0312d6eb0f15f35461b88e2e1e1b7914c4ed8392a68ed8b5a35a548ef2a7dc4fff8ec51f45e7b8081b29f4f966414af751b7d99b8afb9bf8be85868e49c5d5fdfb071c8f5d6801c74dd1508cef68e4f699e9e81e28a9e3e21db82bca6fca7ae54624eccb8dccf8a1dec8ceab5e9a93c8071d2fdb0104f09511c82b306475195b5da631a1c68d2c50b742878e190d0a0507d83b509f8de37b33e7ab1ca468b837d254c84aabe78f8e0a0542e328826ae63b1e92b91bc616002fb8fd69eb39f992d9edc384bd4f95d1e15b9c6c935eb525cdfbf1f34d51049b3ce82584a39fa9972c12de32bb55ac7aea9f75cf2b3ab507fa36917497d6caf37db705c7014712e5bd4832ac64d0ba23bfe9d3d7ef1a94ddaef4c6528eca0da41e5aa81a9b8b03b518c7e8fc21907a5c602fa1421ba76d464b8015d7d9e05dc5ff6629f80820e800babfbd021a0da500b4b9a33112cb6eb38469effe3866d98e638c21d73675f08facccc74623ce893e20e49a0cf15d18dff00c494b364e195f3da430fd3fe822461df3bc091eff0c8b09f1af148b6c99146c655111b49da60c460e7bc1eedc2cd16f1d6bb1609ad23e2c6bdad23b0335ba38f9069ea30e021e5101167694fff4275438a40da14cf8f8bcb1197f0de06382fdbc300e10e38a35a07be2348391d56b224be62d9f175c5c8fea82015bac079c6e8b51dbf678d5da17a8d7910f16219b62b10a8cca773cb1d9d359099e27d0b21665c627975605e2852424c3e73850f2924a1d01b14eb74e5bf11e710eef45280c66fcd2933a19ff1c9fb2e5e669794f6a3a668e1ac7b84def3cb5319a6594eb418871142aa2aea1467f65680888e1c2c241a9d095098d487a6b9ca3772985480a11d6990a048b08361cfdfc1f380692c35c8d5392a42ef5d43a6aae2e7d4b5e87e23de34a4e973f2c03b4669ead85626c2127b3afd05b6e8b65c6f6bfd5858f29325f891d71100dc2b2fe0bc76f75230406aa56a344be9f0bb43050c3ed7b1c272fbb10e068ac3cdac0d0f0b35f9b2499df7559457d2ca11841df1d99831cf8039cb79d086e786bf82a7b66171416d51d763d6f0dbeb7676d4e362d12773903c856930b343be2b243eb4fa367b61350b1ec360607f33728cd8914b3b2cb829365625d8da0c8fd72a286c916830886f6058fdcc4307c0673c32570de024591f4400d77f8266ce5f57910160ba776197234e731a1f9f98bc96d9030fb276433330fc21119906966022de93392c27959259c07404f0844639aa428df7018085b54afd9db466e1f40db0f03dacfe5544fbc47aba210270e98bf07c4dc4f341cef50c03b9d7ab05b278a8b8177f0537f1f0d8961de48b89d7107d1c405bf3911a5338e521846030ad6d2648d7ef470345cf086532950b091dc2eb1401a63fa4528b507ce4cf5effc00272fe3393195a8742ff13e04032d87032eea54bb90a53715ad4d4cb4a2f0aa7b5c66432b997f63ff514247b6b82c576e6e6b073d699b1b4733b09bc0fff351c0f651eda17fb2ed420fc41d8fc6e3401532fffcf1d476fab8f44fc118152363d0b5623e4e8a590b184c6a576901069cc98588514ccb3832740485e34745dc4334542e08656adbe7e7519303761424b678ea6c344b0df9b3b93f3bef9794b08f6474bfc8a16a1ea51e436c4edb9085a8d8b612c4e6262c0a06264b67e00a95d0ebe3074ded23565efa3e893d94b41b8cd45778638d3c1a16519ac1a10a31d84e2f1a8f6d941737e306eef20ecaafa7e9b1ed95fd97e012c95a868135d5b43dfe1c8d07e7e9f250831486e8898b4b45e013a10fec3dcdd5d1c9bcb49f7de191fc15ca55677fd99fc6ecbef73d3cb194fdea9af7b6022ef33c5e5d29c484575b65c206e2f35a5bfbdf657a1710b2c9e2c1e7e4040db647249da96ae68b4407aef25f86f4d38c2e115fdb176b759edbc9a2d1e5c2f2d74b3dbb070680a23e73c2cd4dc4d27a566d7eb1becec82cefb118e63b3440ab75feb47c69e0c20263bb4cc6c08a6bb96e641662ecca092655f8c1649466a11874e956a148fb9bf689b3fe8ea48da29a3e6293e9003b83f988c38af3b022db3c7c823b188a05b0b9ac653ab1bfacfcce1c0aa3914ebb6e6a41a1affda372dfc4913487c521a0dad605e1f9a704636456975035d07e309614860ea1c90756d90f2afab1cfad5daa94572390a64f32200b3b6400534ef24dc235c20106fc0d87749600e751798b9359cf8463ee6be5b1feb2e4c32049d3a9d7d57552eeb939489fac51be1eeb85744fcd4dbb0713cb7c922842513cf7bdc443b99ef37a02b1b155f62400cd2569fa3242843cab2e05ae2fba0ce93a86deab86dbef9c9263637d5afbec9d70cf0e9939806654e0139edb3845089bd272d178806d4afce99af700cc4b456b9bfd3db70bc0ae0a4996f31a67e8d5e8f2f998a8d6d0ca6adb65058c7aeccdb6f7c75ca888404f9919aa223592fc98ab0ff52b244bac80a183f4b144c4ead6edf0398167a48d0fc1d0407aea788411acf8c29bf3647bac24b90d7f716391a91fca72ef9f2698c4f614391382565f0d9faa0b274b8c8bba4a9dcc668f59dd73ca41a72f283ebee8cd513c773284de0e7211f581707b2ef924b26da9b944604ae3e3e4887d6434333e695f30e24262179d69a73feb421b0b74c3f0cf0607bc5f2b44aa84d80247259dbcf977c1b5273c0a9d787fb5372207e7d3b1ebc47bc2b1f5fd9ebd4e553ad2f8a999d7a3f836dd19c9908a41d1638c49a4383855c46cbda1dcc1cfe1195c5932d73d6a11380b8156772f2dd7d71950bdfafcfe816b870bed43c383d154e2fc99941a19c6e0349b891214d2e761687eb2a62f71c9b1e2ae99585deae33a6e2477ae982b254bf5b1bfbfc5f166f5d45710c4b5d75562b6ed1056354ffae038b2c51d812593f16c1498acd006066dd79337d0f86228d3c860d1128e0afe4de40a9f055422c847f6c84b3388da247e2c7cbf1a52e117f15d8d17e1adf59d7a1b62147a5c61fff4431b47700d69ea70b697658a5777ab4b60d9caa2302b52b73fee7a722bbfb6c55ee86697a0a4d6baed0aa17697e781545da1c6f60485ce78e723b973da1f2e68651ecc132b0089e449a824683d9009e8c18aed50d2c1e226c6303abd942d7b7eb9ae165bb5ca577edcfcbcaffd77a3909ecc683b707f0920b94e7b6b0a7dca49141e6f93339b07c2c6b7571b175924375a0f25aba0b443f7df6f21c7f41b00db9dfb58681b3ff95006ca72981217a6746e7d36cd7273ccf4efcf7076f52d2c02ee8e84a526e5a2a69da68aab592c1bea627b9830481b290c6459d95d87adc60d847c2047f76f5d65e8ce632ac3a35af67b42a65cc37ea826ce7142b7f7db61b2eb2d7e5bcee98de7e0d0b655423f417e00a0f19dd3c8d301edd7fa87b4681935623a9bb73d8fa29ccb164b76842d14150ced55df2d54215b3d5ee1617bf675dea76ab97ab4616f5bcaf164e98470f4c520cdddc7a77571836d387676f3f3cb2554810ef5d93e2403bc2d848e4c4fe8edb8d94ccfdb31226c5ee07185f76d2f2562dee9919af230e0589131de268c857757a2e73f56b6f23a22cf8e0306eeca2c56c31eb04bbd0d8c8d3684fa22b8145515fdd29df28a6b2d81246a640a5602b03bdb7a28cf6fa4302ff3c845034816209df307f8e15b368f39e685be0cfd2bd278001eceef8c6d0abbecf4e44ab98de2e1457eddbf201a3d777dd02481ec098f0a1a087f4ed0d35b9f5f49d15c01dee47b411f9069bb763443597a0866779bfdca8aea53ebad850db411625e8db2210a6e41d1ec3b6ab420a258f863b7ad86178f28fe67e33d83585ac47203f57fdacff0701b3194bceb5297b7c016151baf5e7c4cc8d3816c95ca6cb8990ef3882c8566c90fb9fdabf7c557e1982f822cd286c51cf036abfc0e8dd2ba997193c4624dac07cc02f9d0ff31650deb05c6570d211abdf508c3a1cb30e607f8947933050c764bcde5d0047c45be3b30380f8e75ae738ac0a7c58c1f52bc5a49926351b215d8f7aaae090381ec17e28e47a681fe0059615c4b0cf85dee97ab63895a9246b7c392a2adf10708fd8809c2855850c30b2e91f6bb8e86a2854227a14527ffa19c30aa89df62263c514778b58b1b43d4b6c126c0f24af400dfffa574e2b7733b57c5134bcf385d8a398d68aa647c4cb0010344859f9a7c0889874b7c699bbe26a13a985644c208af888e0541b3b67b87aea961a64478acd81460111266a833236e1998fb437b6c4c4d1d5f27999bed1b434d0b77d6039c448a445d40cfe14dfc79626cb5adf52683daa5c6b0bf689a652b0b4ad991d395f23e529745df07643b6e14ac8de530a27ca7d245dad8abd0b3cf99dcb3f67af2b710b7c2097922b07579b24bc7552a4c58c846470051bdd54e619f1efb0a7c2194e5ca0ddce391e51f80ab60982ee34047e7ee8f385f734ffd2941073540b9b3a745e6d6744cd95a2f5cdd2163b5b869497ce32fdbbcdf0414d35bb7d1d62fc3cfaa4de43dc23875f7c510869fae33f61d9d32d4db4407d712e33004cee95f7f17d18371733b55e795b49134bf6378f6408632b4c3f8cf02f42071dff6945e5b2283a7dfa99773d769023f591e4b6a3f6ab07309d7e1706c3873cbfaa452be96e16d7b3236a9f67bddfc941c574d9e29e2e32275c10ad329e35dbe568fe574966680ff7fa587922668a2182eb4b7603d7070eb1e4048e1b670bfeeb3f98a3fc768be67297551116b78456da0b6c0abdca4248a976fee20c8126864c6db9ee37f06e0f32f01ea00a109ddb073551cddb6bac89cc8dd67d8be64aa0bd6063c0eeb29a272bc808bbcd5fc067d1cc38c4d832cbfa83685a7523228266b04ff9bc4a1d0c25ded6873af692663c09412ba3dfabff561a252b8fa7bf54873b0565406a477f3a54e57ed3ab287c7947db0dc55f901fe9b48b17d66e819cd7bf93793e16e76c8ff029c17f0840e589b5911ea45cdf6dd24167da6e2f8ba073e184c1eda900e3c09ba3e703dedf346baf46bfa1f1779868eeef1f92e765e93959ab5b9ade57e43d7e2e54815eeb539be01fe55dab61776384584d0d354761cbf6d217270379dafdcbaaa71171015cbd04cb6e8e5f93b2f590ea081cc6cdc7031808754d5af4ca7dce5047c3dd323e7aae503624327db7c9ca7aa09aee51d0ccf170f5e408a3f4dd433713427e5240f19c1cd0e0df044498e864b2713fe162d18e3d3384a33c82f5a54cb9e87ab26b891ca59a24bc6799fa5f8457dd8bda50a5263c9e1858f10930943ea09a6c757f1a0f4b22d8dda9b13dae573f62125f9ab845ec10fb489e71e079ad2a081ddf729faacc26d4efbc09e8db75a38b14e68f3b170ee4e9ef0412f0b2b440d3ca704d4bbcde628a3681ab2c2dca4112f8835cf4763c39b27c2f21ade56e153822eda9cb3c91954494cffbe59de0aa5d25e82b75bd05b02fdc54a34b537e06c91d2f1b17eb020b2d443778b98ae9787f9cf51cf32a8f350e621b5909be5603de4450bc14435d88499fc66050c6fa66b4c449d1627a45010ff520f13cfcaa353fafa44d625bfb57df4118ec2f213766fff69e3d5def771865cdf3de8cf6346343e42ca895c640c357f3f6a5394d47dd33e9d6308a706425b76ff78825a74ce1436d27fff3901e85788d8a2f550deb328a4a9352db72440b990278790e632ad2c8bdbc55ea0a187d6a1657e0831d07005814ab39b836d3d96d97b9f4eaef35741459a928da3cfa0eede7bf5e90d3f8168535cabfe04308e14a872f480211640c64316341ca868941dc16f3f39e336680d162bd1c759daff45e1b1a14d7285b66a4d773fc09b3318f2e6de712a5bfb4717d359219cff92def21e99661893c010bb6ce1468e44d38201c870d19bd47a8130b37229b4c37ac8c145477435b6993de544f330cdfc515e31097b6a2129c1cfc96391f75bae80413a9d22d40b26d2888308c96b182b7eec1c282906d638ed2af22db3ae09ae910143cbd9dbfeaf609b6e095ca75cbd50705747c74add6f76972c5e64d93d6c56845365b424cd1dc3ef1f2a4a037108a4df90d3d23a12799b3c1206c1f613d1d95aad947d8bcb38da2b64f4e4a9386f7464529ccf3319c6249323d284f2083e8a5cecb8f25fcbdaca8518f6b5e037ce36d5afd163b319c4f7554998c2408445fafa99fdc44635c02c982e93c72f312d557738ffdd44bdc23d84a7e15d33e87f5176d531b465eb794c9b3b0831b736e98fcb34418d404fad90d78947ee77f58787a142b404c0af870826a1ac436009611ab710b1afa57173966ccc0365d446d62a1c3dd0ffd4b08f824409e8a1064ba865b2217de243501234580d224166d712cdaeb2d78b36f76640155d1378928480f1d2af9c68539a79ba3692c8a0fa7b533f301eadbcbc71113b8fbf21a6a8aae1f32ecac5af50eadff3a30c1fdddc064e5cc0b03c6311b0e12a0c2a7922fa46e40d821677fc613525ad96af03cab44bb41eaed9deb57812e87b75d2448ab7904b17f6487ea2b9055949d75e113b5b56661d5b4be82906f77fd3917b3f51949a86e8ce90eb0a58d775611a62c89359bbde2d0156d9aec0cc4d4865ab2a2f8b3a2c4967a89ab44e2da0ce051bb7ab0ce99088205a2e6092cb9e3eeaeb91fa8b43a904dd80e5865cfe1bc4cbf0acbd79866b45801530de777cec864009fc8121f68ba4447b45efbf73121d2e71a58b48c234f51c01551637409adc8c4aacd386f91469d3b5e1481d129a9e8058aef5f7bec60586b67438e14df54ba86c3d388270495a71b7565b80da6666c0db58bc139ca5107c73293b6a69c580863bd849674d67bd702673fb6bdd655d58df06f0ee46f80bd39de414a533d89b9f40541eb2a72295cac0ab391458fff5b30f117c994dcfa975873eca157e87c5fb3f206b4e6327feabdf9249aac5cf15eac4332003ce3acaa57ecd5288fc770c30bf5b0706f16ade06e9700cf94818b1a5145d28b25050041d2931d3e14f96162ef2d2027d83e3c5e833bf084e1ec2df289d22e24b579f7b18ef7f8a75df455446a99a0aa93408dc45241531b2bb7ece22e2b58136c10f4fd5ba26fb41a7b754aa8e804346387d8e6c4536a628d1e9cef87d58b555fbd1191c084771f7c67f68b2b2e3dc4cde61263a11c5d5c3718b2e33a50bf733f19002ece0601c3daf2b24ef2599cf0d38c7fe2759c6957e124dc1d8934f5d41f2ae80a1f3a08e99d59c921e0fc3588258962aea4b39d8aae1376979d56e3e04fef25c9742b5094cdd6c172db17669e2ae04fd0a44c375bcd3746a891f78420aacdfa1d81d6d93c697b0fe2b48b80c4e6ed5e3845779b12210d5a0158bd4dfe59b6247d7db20ab7d427ef5fef4ffb1ae3422c94a34cc7dfc37d89ba47ee741c2555cb4ba596a159d82b01be44c5b0a23b63c52f48076dfcaf013343017c64a070599741724fd5d136e4e9ae1a1ea955e6b2d2a9a98e66c2032fe24a0d37a0687a15b5d36a699b01000217ba913b1f227d40c910d5c66d3f8b2300282cbfb7c40425595c989f4e23b8e5990e25da69a66950e696fa087c9464c4a68bc6eb11656447385caad719b1873a6efc3317650b1adf8842b0a05c36ee97f8910dc563d34960602ccac4875c442fefb2414c5e7286a5c9d0330a6f907eb0f7f960940b25c2d0953d238a7b481e80e71e8870d39f0089f6aaad3d19de1abb7a0c090efdbedbcc8faf1cb25d36d8d1618c381cf4a91a21b80c3e5e1be008ae1b5f3ff0a3adc46406d72e9a86535225b28ed4e9f2d3cadcdb64de6abfc69db14e2c738c821d20f0c393c1996b280b12069893b224de3b14cd6caccfa4e869857e2e06da0088b176acf4a329c1051c34eb43ad75a978f4a6d314b22c3d065d60ea94faabfd857261518ccc2c19e66dc240f2d6fd38d5274befb35976c37eb73537677616872a18e2ea12125ac24eeb81340ff00efd6818f2d0e3ce05f2ab89db3a108094c5748d642a026d2f8d99dbf4ab2fa4be2f5d74c407615e36cc741305f76950413103708ede7cec1c5459dbd24665bbdf2eb88546c2c3077725e83d2ea9bde1bbfe004b7fe81c9b0bd98d44f8d56901a2f0c1f67beaaa83f7f11c99f62e244271b70421ced29cc7b9e2f15f99c7a29d6ee769364aa03052a701902d72d5f1c058a9213e75c10b99e9dcb3ed8c67f3e6a6ebb6cbbd785fb68a97b66d062e800837eb212d351528dfdc53ef4a695502bc4ecb558fbd7b09a4afdf8fedec917d85196f416d8ac50811218738b36818ce948afff4bda35288a241a9c7d69a491c747d71aaa403fd81eb61a5491a4de87a4d35f9af05b7705c9c3af6923bab73e2856bafabefad15bb757ede0545015b594faca553695399830517bcc66ffcda947bde719283d56108ad73fe4001b6f6b961d440de52f2bb518176f0b714e1259b6169a5eaf2f05dde1d3d337e2a4f342cda6caf18bfe12d8bb3b3b506389187d2cd6a53962e1f3c7524189bc704ffd30f5e967ab3af0fabd3c083f1b6a206a79a39591282e08274cf5495e9549f9b7a0dd6827b39ad43e4504df8f6841887ac51c25562cd2fb78f8096c227ced8f1df22af5bbc18773bad8f24fd7bf386cdf78d9353fb1127800033f70eaa800625f0a4bcf822724ee7b959d5b012489f9111fe180004c0d9203ca808cf2864ab631fe38d573a8b2fba936cdfa47fe003609dffd09b2ddb5ecf05c47a5d428306d3f3c42aa7e967d018e28e66da38e18efc6b92537326607e1c32ce78cae1d60a52a105331949bea8e5dcb5f2c2167160cf0c65ece579b8dd31c35fe254d9624c36f5a1458d1b0aedfb182ec159eadf4ad8901f4aa49fd984b37e26e2a868786969c6c798a43338642e6aa4cdc6c33f38ff89756080e7f5cff31b94d08986be538a8bfb8f49aeb0722903cbebda0053a2bdfee0eabdd8e34652c4253ea291fe14a922248ac618c1ae0d201e5bb57a7c53d642573919665b03e17b9910d2c9d1bf5fda1cb9ceac7cbe88b1d8b9cf9416c049e7a3c23b6026b500d2ba9db13154df0fdcae4dd4413fc10e0abc29198ce3fe7dfac1f12f433f83fc8c445e307bd4805fe601ed37326ff4b2e6476ce614db783736ef547f2876cc36bfa8f0b9fbfe824ca19ac618b40a9121a223758cfbb1c7e520909426cdffd5ae0cdf070a5f2fa35af426751a5781e2833b5cf00ebe773a059b051a7713d61b42a94a971fac497f74f1b6359ff02c901b1e757f66564e4543d4590477cf5b24f7a4cbec24a2ce9ff903f1ef9e3d28661a96787b5541d4bd55d9d72eae10067ea29ba09e88b38df1a9011d08ba2d08cb7ce7697c0f5ae3a3b70d4ca9789264b78ea331ed69579db85f45fb1be3338573123a4d205df91b7d4f669410268c2a890fa6373913cdc34269c8b3aa0944c189b3e7fa42791b3df3882c60e0b9e5591bcd074100a93880e8afe299dd9c5e1c6abde7d12a318c55ce3ac96308d2fa99fe2461ccde434f14edd32df6574b23bfe6bd3776e598b8cde74208a51bcc55e949e81bf74ec557291f0e63bd8d49078d88593c5022540d1bdc2ca66023c099fb401b9f541b3efc8231dc2ec159fc4b4e8adbb4863dacc5a575a02304c1df56769a81b6e26cc8ae460403ce92594338f838e7810dc38edef7cc5c6ea798da681874c1d08dc4d4e6fef62bcb727671b00df4e5feeac6ab494bd68bf8e3191565c2392593922f55bee53b6dd37434219c77f7c57a8a44bb0317d66674b86a94bcd02fd622ab354190ab415afa72478618ec08c70f9d55c6877ef069c8456fe61d85074cecac0c169f3894a7fa77813d245e22e80bb796ad878ebbd24ce9987faa764a9e11b08612d279ecbc04335da36f2c7ef674d2d27bf2ccf97dfaf934dffa178601f00d30f23a40432fcdbeaae36a94770402b1396a400f141feafd9485298b26779b3f6b1bef31ff41fb1b53de5a08a27b04cc15d4e0ea01086aa59e87c4bbf826b327a0fb5f9ef67cfb250801b65945ed57235dbbc539e6ce0779f6b446ca28334e87224e0b48a8e1ac4af6985b9b183c5ecf4dbf110487f443bbe62720cd60becfa38d3fdc7699ac569b9fcbe73061a486666d3598288104d90e122d216cfa02a91caa175fdb6b3dc0de88fdbe5e68e9ea34b2fc7dc4dad39a0467a01552986d7403a6c6fe3d670d017bcec4822d551d2292bc4a1dc47527a7d1d919c2f695d100662dd5ad8f6dcf8016909ef4aa5f04e6aa7fa3c4f9dfb1f96e71e7f4f6bf3f1ad83b7280d85da00247dedfe0895db1529d6ac2407bbbb1cbadd1512583c948660a9021766c5dbc43a1b286fc1f49a8cc167e9efe30f2f5b3a97d6a1a79454c8d3058cb63f4cf1ab1751487368f054271000fbd16e6983063b95de147d3b162410bd572b5d07877e947eabe257c634b2881d8852334fd11652990ad8220f884bbbdadcd6ee4195e70eb1e1ed08d75bb9731be0d8c1a95db99ba264dd68e27a34e3688d3f95926feb4454ff2aff6b03d04b459073ea97a9ac769ddb3f0d456de1222b0e4d571370fb6ad01b0612658e7590b2be58a96d61dd783e9d73426af950571976ead105fbeac6e1241c55f9c7bca62f62ef2989bdb0add3e8fdc69eb60d9b25cf7559a3982d934b0edb00935beb2be633d0ab8a877e02d358ae9bbd959d4b65bcb36b7044c9bfb3f971713c992fd502a35e7ea36d32c88ad50f843dc1f4c8498660d1b6160e77ae5c06a51ea058248ce1e626308178eb32250ba6f1183d9a77f78488d04253ddc5e7fa62a627d6581a78dc39645524fdcfac095c0ae4ba4d7b16d755865850db64de96d93f91f94a5a76f173b2fe9fc507dfdd78229a744cf18f67bd076c54af6fbf7d6477c083c23f2cb29a256252d7e5c18066c97f01e26e393bb52a158642ab9a0ea850380f878ff9f164f6fc97205f9efcd176d6f01810605296349b656f2261a3ccf0a055dbb5602285b0b13313cef14d500dcbe0ae29b0796ceb612f9f3c9bbc75dd44244bcb7fdd76b106927f1490b4c07fcee4928ffc135848681451eb06f1b613b100ea18189beabf211ebc75bcdd2b86c42a469b7824371cabe6ce9926e3868528131a2bd3778010ac1111099d79edc3abc755fb7c5ac19900dfc6b91a4c3d57c4802d5dc89771f84ff01a0a69c9b451ecfeef1f7b09d5465d12ef55e7bfd1278d3f586e66ace1a4be96d63a98a93c6e47e55ff748bc59f3e0b79d756e32c56a11271511b37fbf08964c8d46e0fda664884f031e15bcec68994142e456e29b55f54d1e509a59c1c1a413ffd0a45b139800264dc6962a1f8b0afb1ff6f4edab7aede21e089af4ffd1f5163911c894ee1ac3fc0fb1f57786ea8c6d7986065e808134b5185bbebf07ff47affabe46d2252259ab9bbe53423f38d864de521b90b9352de6275221c5d63033f6b2b736613a2a8422650a61a1efdff4ce49e0f08793ec3c5953e4a54de94e5acfde764770657d8d860bd33aee37e518785bf856ef89737502fdec0603904bc8d691eb0a4fcdc9fd29e7e25b1ab8062ec29d8318aaef8c9c64b29f15d7a2d4c03405e27c8f20c2119a3bb6ae92b2c6e99ad8e97ca037903856a2620f5cad5d921ea99bf3ab1573beb698def961d94489cf2dc5db351215a277c7da1855e13b46488deca7c50ad8fd6393707fe966c04948e1c31727514e64a8c6ce327d4c21c8e2275d4b78043b47361e914ccf811ce808acd5b5423d6aaac48d598c50668f87c90927774b7e29c680ffe08d95eac06b9d271256542f092d1dc57877ce8c92a7208a39b9a6d8e670d8129f8ee1b949176c1c58aa2b0a63e45338d884ef77a4f413665bd5ba89c117dd2dbe654e8390acc70cbf8e5887ab3ab55d1519446509dc02181093d41c4ce6e752049e9ce92e2882582296f6ae8c3dfbdb30b213de6aabfa2b6b880f79d775cb5d9bdf8d69a24343d1d6509bece5cf2618d29e79df6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
