<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4e9200b6992e4d1f5afcbab2a3e7b0570c2d20b07c88cfbadb73edd6ff895ec66976b09bec130e370b4b3617cc33e7fe983ec8d4167b3a6990faef36ab6df2c4bd32a98f1d95f7c4faee5d3c7f20b92801928d8c1c2cecf86ca3d5ad3242fc2e88b7d884cc75ed896bb517bd6a0be603cb42c3a4a916aad4103fe95753d189e2aad9ced505d46b08618db8d37c77e1fc700bb1e6b6306e09e3dc1b099371a80b153b0818ab2feeb83275f841136c9b794f121c869c0e5b6f81cc8df23722ad6a2757c8975c2a30e61e6bc074f98e04b831e1ac73e787c6a12dc777c4ee0c84dc6ba654d666ae045a5ebe5deb17f2ceadeca87cfcfaefa7cbfef134bc9dfb465b0068ff57bd3279f81ac99b8ca68e673cf734a2e0013c6c4b5a3eda00f7f0147b3e77def28229ba40ebdd7f1fbd1f077d2df80722e1138e8f25601ebdc7d8bc5b22339aae3789d9f8e9990e5fe7474dc1317669acd63c4495081516c9b962cd74595b7886a1a2afcf9b31a2452ebc89cfc3a2c50c26a9b74cc83a52fe598fcb9bebf885a8cd00d0b7b7bc5065b5a44e951d9a83806d9ef33190a0822c05edee78498fea1858f2bb448bda2dd033928dc0ad8597fbf1aff736738d637170814fdbfd3ff2eb77faee12b6fa75a02b80bcc7b0a75d94f5b26dd25ff3649a09914331a1ec42ce46ea2db42be6ba82b370c58e716166dfded84817d9912c0e89c70ec1ad64a7a24509fa6deeb5001fca4c5cedd3d370bb1f7361efced3ea9e8367c739b9400322a669c056b38612167e4906ca21e79c40a5032445dd2c9409f42026a16641a0d8818d3a00a2bf60908c783b9019f8869f764b4bd8737f29b6753fd2314ae28aab26440ecbdebdefa5cfe0509f8563f344451e1bd54562f1c15e69fe90d4a3b6b3bb49db66c09c3efb16ffe9dc4163c59a98306ec593858515be49be59f1e2615479b991e1edd89c6bb5d09b4b74a8e4c037b3780e0c78bdea75f6d80e6b9a9736312ba24f987e3b937b4fc3723120207c619a27b953a3fda8eb47936275e26fafa237f99d03af0015823a56379029e937bf0dcac2b186d667886070f4e3545fe053b59d49a03cf845629eec5cb4903fd8faeed6c57c14292c7f7f90b87adac436ac9fb2a30fc9d5e4e207e4b4ab7cb928b3df1cc826b581247603b867f36ae4a1a3837ec6f0fd8a16a2df53d7a5a286af12b225d89d4da678c1ca037c8879c4406faefa715b96cfa4f754a559387e14dd713b2f92f75759ae500974f4c5847a08ee22defa10bf8f685ced93defa78515c48647344635bb7420d70d84885016e7133237870ae05925b8f92b1e6f674c3c80fdd533bfef5dce3776db15dad69a855566037b4d576f363f40b3745a31c4ac046b11015c82480d515d4ba22e6273822bef3c2f21fd316554ac4cc5eb4c3d04aed5ea68bc783ed9a55445e67f199e08472cf8857ad58782ae48470020eb82a6de204c08832021a503687171c6ff8eae95e9ac3b1dcce829bbf99d1ab77aaaf346c1de1cbcb8759066a5318495c590a6a6ba561d51d5890995b0ecdbd836897a17a0e2633fd4a4555d7d9115149aa8468c27f86a8d64ca506b9c13a25c2fd98beb7208f045578dc9d0e41737e68ad4be76d25518926fc1262ec633d53f73f8bbed640337d3d47cffdda11606ba4f164ad0f5159296488cbd9ce74555f7104782873a942d0a0e57f2539e9ab1cc779fae0034ace361a2d279ec2f379b7b506bad61b7460ac42031bd51c7329aa93e65f89fd8d47f18f2390ef9c8168a8334cbfac70ac2132e3658f3066cc257f149b45808708501133b216e2bddd5d643e7e16a1be3ed7a372cb6a526d7477a9abdd9db55998da331d18c4eba52e28022e257c87e4e5523e7640752d40456ead24031fcdf58780733e53787dd2fcd90602384ad23365ddf3867fde0facbdc38fb4e34b760966e14d3dd7fad3db9ed54b58f940cfa9fc61f138426e53525e2644e3aa87ee0fc653d35edef3dd1684e2a62390ed4dd99e4b0c19be6c355138133dd73642d4dbbfbe22214be13e28dc2a7a4661f2b098a0bb74a2dbb9f1190d0d734f39e7d4e4dcec4e485924431731bfb714a7cb96755eec08abb7d3342d78f54f5f9e4623c7800226df1226ce97511246ae447194886b3d040f520fae00a38047d08e2c2e68ee4bce815a0789c09084695bc799551eabd40e0c5d6dcd597bb3b19e5c7a377a23fc2bcfff61591b8599b166f27fdc00e83ad45b2b1901dec85731e9a410c2d1486fa37c90488e643e0713a574f619d0e415e02c3f1fe04dc1131842e39ac217a0b2ff6a50520d066754234d34555364042284dadfdf55e766250c67ef3613a2677de262fb25414af4aea048253914f9f27589018151e51060bd6fd365b553c927571aa878bdb9c13154d36efd864dedb6d7af1579d4ace6d7e8be475ec5c11c918c28f89ac943f070775846e4b2b6b0cb54930bbbb08cfece86b46e90751cf0f3f164afa2b74b043399096c9e4ff30ef2788db8e4febffc92c09883482978e8a2afb267a42fe8d3746a4aa2ac9d673781f5b8a0d86ac2911a7e97bcda63f650e4b9d7ec6304f61b004f42335a6f3332c1e11c409f538eb005058d222d23a240832f9f5277af9f459c727477df826e58afe2d955820e2571ad6c85adf42b62ae95b5c47a42c5573b04a9b73ef20d962b01cd72c7062ea38bd7a887f3c0b26f1d4b35dda1b56f4a920914eb3766788dd092c3acb1bccfdb59ec545e5b58dbea0da7ba926e43162925886b28241f399524c7224035650eb98095ac8f66ed411517e41e038a49792ee9d45b4d8bf78dba96aca821690bacfafe720aa8ce1f14aea4df6572628b0672e61903332e3d1287ab4ea61b57e637feea95bf612fb5a2ad1f9dcdf789bc6567e58fc8038a8e88ec59c9b718c03225b44edd0c98f820c436742dcfe3d0bd0dc1cca735d6fec41213aadf569e6bc765fecc909c3893478d4b8ef49bc0df3a8843c1f6552eee721e9cb37b2368f5033263c95904ba54a2a878018e02d5b9222d5f421181d60f844e8e82035af6181b9ce4a6fd13f0e30387416b628dad251946889b7d74465a1937336a4f6e16c3c445d62536820fd98d60b1c1fef5559716f4902b232b69afc5fd238b732720237ee39d11cf685bf421369abee4505a4b5a8e4a4526ed9c3a3673f2915a5de996d038d5c2b4597b0c6313fca1d66d3cfd9afacc076426f2c4c0ae75a5eaebff569ad619e073a9d10046ede8f7f3d9a626153c214493ae30db6b906612e0928e9c311a6909aa1cc2c784f0e2de2c37fa2c1fa42027c82c82f39dd1be47a68f463f1baaa478a0c4d909894b280afa1bb5a6b6b2f8cded333e22e0c2bd20986a4c0b53676ff8a629b1ff32192fe7d2561d8ca0d606caf1546a2630d809a899e62f9a6d2d9ab5ffa3db918a018fa458a96a50a3f41d9db748ee9635089fe1212bb749736ee02e6cdee6fad59e63819d329a21bad85ef8ff4308ac6882624322a8009652c10bf2582112be664a7ef2d39caec38086b4e208a41b3d1744347ec4da6dd86b3da0d269c3bcd01d2ec54ffc7b311ccc21c528d4f277342dc8a7abf3c879673cbd16d1a05d19b47e3d19b9f6c10df687bb56093dd2aa30e515d15f61822eb26d2cfd6cff150513e32c1a0174c9e0b8c6b1a3ea0b0b9e35d74aa1b38c64eca7a1f4c08b158e912a50829dec48cd044f0db21c475c4ad76a7acc89012932c5c839fde9c3912e8adaf418284f1bf4540e4867de10e57eb429675ce13188579703e6c23ef46818b34ef35896c184cef356fe11d07ee4884b435290520afbb681216e58cb43d48aa5dbc1a4445f6702761adbfcbef67a411c7eeeb7a809d48bcd986be14e5c9ea5e39cb467844c4d158c498afa0fa42a13881f937ad64c1909db823aee95971e8b4cc0e5df056fe3844b0eea114d27e989a9906d65a958059d093430d2d108b1ffcadff44d44f09d9bbd0fe3ba063f9d8ae91125294f01b2c1b03252d8a67d8d9fdc754f5164a6e6d609a2ad86b62bbd06ec6ebb6af52ef017ff302dda00c3a269948df55f7fcb4a51ff0c1be3b7baa78f23e669365a7be00f3ec36dbc9be3ba3df7be97941165eb3fa1a8afeaaf15bb3bb9c610d500bfba948dcdeb58cf7b2d02790849a75de137e48e8a67df7a4264da0b6451d51ae5728addab901113b1cbd52c205a7a7351dffe9bd9384a6880567cd69ad7067dde8f95777e3bd6a87754c5c3bf58a2c96e472b3a642805990174721ec4466775ad6938e740ce92bc714cc7f478e2b1beea4ade2c82475cf97e0166934d26c7c1c10a8c5500299ce80940ea2dcc90b63520ed469065ebe99e207bf073f5c81bfe142c8efd9ff33ce92e37d5f292ab4cab7e952d8f546d2f517b1b929a4d836f64d908a0331466d0ce92b242973ce3245be978c8aab0818f35e4e00d14eab34c4c422187ba8f7ae73191ad5650ccf8fc33618eaed1ef1e50ad007074f5f7c86676ecc3633db9c6501e274dff7c8defbb9dd5819ca81991b90c03ab6891f3cc6ccfb572c38701cd5ed52bdf250735c7f7eb085c5197cc3256a5342d733f759b4fdd0a94423c9519daced01ed7ebdff9df6d47d014c385a95bd772f281277ac1a092991fe3638c3482904a2a2c1d5fdb0dd88bce008f14c4708c3a58142591d95e6e3dfba0916da49ac6dfc6e7b65949fdc571466a8e891dfe3fe687024815e8e8c5c85af780ce631ac3ef6a7c45a1b81d285ea2744533a96aae66cf1c9406bca64356cbfa836c459a1308185f939c611031e08279961349b75a1d35881cde49bb782900e53687611afb2d12afdd353fe0d7c5c7e440e5af5abc5028184621819f2d4ab7d24202d883259f84b7f8ebff00ebc7672367f790775218771c3f21879f261b90603cce42b33a36f2c66fd0dc18636c8e3d7271b51d9996a171e4bb2c67ee41eb747c894087f8d6cedb7c5dba0bd11c69ed59dcaccf995f09320815ddd460645feeb23865f9c0f37a925935239a32b40614ecddb441c705616ab4d498e09391d0a9ccd126a3451b0533d8c40d189bec84760c53d9a501cc58b10b13789c6e1d4701005af470229ce87c9156330e62dd43b625be66089443d3b2dd0fb594cb106e8a8e697f8a3c499153301d8f4231c5506056f9c9749ab64478692dca09e986abc4e3e51c80b3f98526f0cd95aec7af5f8a19adc4c84dcf27fb0f6945f359755d8d260c3f1366460c5e49ffc9ce36177e4c6043fe5cc370e2ebe24229d37fe8a5ae2865423c48c11b943d57cb055ef2458ef1c71d2b1b652d9954de10ad3de06fbf20791231c49576bad993e88d5c0f9be0e8fc4e677f8bf075912fb3e3f40069819252d591345513d2beb721b7b98a33e96a82d5d9ec5b145c5aa188644f3b81842bb9c157dd66264450956fc0c10e487a380f906303c152baa03a57423790fee01e0d7aa1b32d60cc097baa719ee853fac44ecb2a7c100233de87084f6deebaa73052386e82b599777b745b4ad13289ca48e4bddd9779dfc6a90c7542e04771f009c0f6119eff3aab79e8e04e080fc1e693b3ee6f4b6300ed93599b6905dc89fbae189541f64356e52713511520be594d27b40a9ed94c8948e7c497de2bef57cbba97188595bdee436d2d125aa15b3aaa559d0b63bba9391663e21f3880102b7caf84e9845ddf95ee18e864db86cf8dc81ea7a960da5ebbfb07512c163acf7712b72b41526840ba34bbdc9a881df7cb4b82602a8b3fd03f68a37ad072f8c309bf33c0021608d98fa60a3a8998bdbb5d6d1d2f0c602ca24b19dba80109d5df93b8248c22232047ba3bd8d811c3d996c762351712c90b1849678043a543f141e834ae58fcf262a53e73f46721bbfa930fece8c485b8ed5287748271158891462471826425d314913aaeb207de6212be6c68490d30130a9479d9ae242cd79a19b853646efcf9bbc7cb1df47e8eaf524572329b5a68e9d6a734c6491d941211f3cdc1a63b951f3888b9c62f1dd74e30851b67adb31dba517c87749ed2aaf01e63c4f110870cbfaebb8a475cb14fa6cccd0130ed69e832b0fabbad1d0a2f552e5fac50028937350f4ebc01b0487ca585d709764b3ecef19e2bb7f19f341e0f18e4a0d0c5e0f2b73731e483b30695980ca15676f8f4310d22a78e8f54ebbee23a3dc9bbed4794a37f96e991174580a5a485ded7dcb4a01c2fcdbf8152a6e0a128510ae8c3477b341182e8bdc2954635096b67d98ae57f5c67152f6bd71e02ee8adadbd44d41800cf922e53e6d5059a3653266e3e402e5c9e62357513cec59bfbbe669f354efe81828aa03d2de595d11620d3620bf774efb0bc808e599f25c28e6600e1e41c8843c5a80fbf4deedaaba25874f638966b057b082907bc428b970de329f464443d33d414567f0ff7ed8e5117d094f308bf67c076890ae613fbcf7742c1f2b6a01c9d7de796040528c352ffaed5a2a6a5fa6952e40c35da5d9a25fbc5807d93a7e391b35287c6079cee56abc67e86586d352f3ca9d043c92b259b7f643e0405332b7de54cb729c259f43f3ef44b4836f66a9f08244c681c2cf36bd6020d2d4c6ed9b25059a2e05b262ac643625553fd50d280faaffbd53050c119fff9f11e107fccff41fe2dcfc1c94489334a103cf568272e7378086598df46bdab291fb8ed77c0633a665a8fd45b48b32bd984ff19cba7f6d7bac81efe4b5c673c3cb34f6798a5d2ec41f0a3c307d0efb4dd9d5f0196389659ebd4e3a6fea95f4ea90ff419aded499d3d52d3d000dd5b2e54fc38a341253c6ab8c8e641decc3677d4103372c5af9c476b0a753f4ec54e0a45dd28c526505dd8319b4bbe1ed2b40fd562bcd98280231bd9f0e67312298d5dc82fd43c093d8e09e1d1b18cc4dadbe46b1a8c827c38e3dc4f59f1f1e1caf9b42928fd3d1ac0d190f12be35efd8d4a1c852324a2d9af6126ddb6dfd1898b8ec48e70524f1ab2e69f54d6269d69eba2f34bd46da745151d5a7d3a6f16ebd9018669fcdc1ed6b96d7a48d903d902647e0bf5286f3f8a93c2bd0980e502f037abbc5c17d98ffe5bef94230a771f397b355fd04c23604ba3042d44e7d8c20aaf9f1acd8cfdee7c6f96ce9a852b885388be69ee6c07a40264aedc9ceaf15d41b5c9ee1b108b75905a7ceffeb9beeec3f7c5a98a1ef6b8ee368ae3f3babb0b59591e09344cbf1d33dbe306fbb1b26b3646787e0b4b88da5ba9ba967bf03e798e7a237d5c0cfe4a693315d69c518a152444ca242659752f3b3760288c185e70798a9d133de2b2b2137862037c69abfa594bc10bca59402c8a01a86d7a53478e4ae4bdceeae6a786d2d43011348d97d08d394f10c9b772a3745f7d9f634d5f1cc2aec33a371cb55a609d851391ee150cb9753bc609d0e420e54391661f31c9ab0a3fd80a41d3ece56778a7509db8c091af620446f91a2ce6841a87c48ce5ffc632c631edf8f5912eee8a40ee7fb2d4ad61ddfadde9f1359d655cfe81157d3f5900ec2d8a7d17930c9c5315144e332aa2bfc9e0984b4af3ec1f99f978c88056e6451c8b796828c331710f49df1da763b7a016b4ee607a829593e911fe5478f6da27e8b250a25f3f6d8d2dcf34521c822761b433e98eea916368b176c0c597e5467b6dab2d78f315e4fbd8b92c0330002958eacb7b0d3a4654e82d2eb81c7e8b2a3080297b110c0ec150ff6287411a1e32cf8905abe26ba46519d3a260bce6ffc992598625bfe312476a72dad06773e6c096f76d36c6fa019ddb22ca7302ea14ad13f61d4e6c1358d4a566d5a12c792eb14bc0d5a4fca92727740748ac948f5e6ade79582056bc074a2fa35340164d160a7b9c6b0b85e313d95d6767e0b1206df9458afde321e1f63a92da4dd58e6c1fa2d007bbe584f360be424f01503e8252284483cc96284b852ca8bb9603e2136b1f852b8c5af41e8f1943a5e96ba3c71d06c0fbdb531b4b1d50a66ccaae7e61d15eb0bdda5554b1a79711f0f906e09dceddc1e7d8811069f60f7f4f34408c02ea7823fc0996a7f1de5981d7a89752e5ddae8e738bcfb97a8fa69a516592455dc82f6b01d726c577ea8ede07d6be6f7f927a7d04af7de3a5b9f5f8c69849832cfc7557b73cd593cc6c7af0d8255f89116d120d8b7a31e1c44dddaac137b6552802599fc44d71403240b1fabe7a67501b6dd9ec0bdc0560da5d7fc2c7499b2f00de37a7ea44126e85f8ef4cbe6ded8f728dfdc5e75ae34ccd50854ace0ae47071a2439ac4ff57c16639942f0b45487497405434c8b47cb8d0953619b4290649ff17fd8aae0e606ca8d2e55a4a1c7ba6a6df8b9010aa075bd8629659193e8ec77601d96bfca8e8e8d5628cca5822f6ba0f157fbfdef59191d3ccc7f488968ab284f28d125feca19aebc48cfe31ae5a570cd4ebd492f9c306f3abd6d4c8dd3555ce8deb53d16ffdfea238e895020a136dcdff33056dfac9c78da4880c9576086804defc43938db66a023c8f7b0c03c8b0e1664db376e09e8f2a20717a8fd7d4e0c070e2a16e22b633a523fdaf293fd49d46cffd920ab9bec29e99afb2929f84b617736e26df68fc0363a93b80293186d70c0422a41f67674164785f9f30e85837f5dfa7cead9ef27ac13e2cdb8456fd091501740ed96dc0d5a62de77e73a5ed144559c0900aa726dc22072d7315ed535b5a4e3bf31c744edf2dbe37efda54a52064ae6b18cdcfc3b837ec232fca091c6777cdd7fe298169bdca52ec1659391e543c2abb0c91407a9c1c8754c012420b965a45df5610b8e386d5f1e2c34c1fc1a22c8892539f699d6e3fc7a903de23b8d691e9ec3cc8849e2069e5af1277d4e1cdafbdb8b6cdd4a0cab5af310009079988fc4b2886ad9e531e09b8d6b86ff3c37f16a3a0040ccf835399535a0037b83e9d998e4e06e38e7e314a08dd67fccc139ff99044304c8880348a810f048dbb4c8aef34d3868824d2458b807d90adc06a7b30abc94942b20a8cffc0fe16790936f8e32915d2ea8d9c81c7c01b59f696ad40ce599e24623bd052b4a979d175f9b6ab6433f001fa863652e055dde5301f8eacace32c049085cc6ee1143d49c106252828d674d149f53699a26107728f39ab2e5379671efc320d99487bf410d1a2866df8709eeba2465197615333b1da30ef9c771a739f00f79dbfc552c7f1cde276be42efce7e696e2eb6d673bacb4d9e60d8d847c7843153361c8d4b7ab87036b016b29d36f82ab2ed21e5948a7e519373bb3c0a8e8401b1bb36ee137baf9855b0fd9fa0cf05ff8265452030424bfa8b3863df512ba15bb1a5db394389fcd728dd4c42132aeaed4c776c5aaa2971ca78731e94f122904a3452381fe0d285c636636058680ebeb6e67fd7e762a419a0d5a448545d09528880ac5ed9323dd1b2a4cd3d981fa300e0518da74bde02aef73f2919984963d177622af936dc5052c21c81dd6242c9e0e2cdac0303ab3f48ff887c8b739c4e2486153993e72b4a039ef1b15ba8970ec1486859cf9ed7e61f73d567a211353c38dfb2ff67f4c8ba7fa5108f36be81474e23a36658089937ced0643f8232e646274be66c0e367900fb911f3a85a6c5bdb356443f3bf64801906f68d930ca67520023caa3c86efb4b3f8e5d723682e97f38bbb5326ef601ca2593cec00d70a0070d61a073bc03533cb538a6bde7151d661e508bb4c5276d5e34cd37407e237f58eb085301e5acd6ec343e0e091ab7aec2766cb1e0db0787ee427c2e6657a9b793dd72c0984db3fa31228347b27ddf2d1b86b69bae9347809273de67c1b81e93f2b9b766550333f5254ef6b85ab5d714b462bfafcedecec3e3ecabd2dd313e1396fc789a2296046d6a344394c184437a3ff82dea255e27d084f9514c693dede38e97c89c58fd2cb3e703b7506d381844ae6a9741f9e89bde64618f26c91a03143f80718c20d333a2e8e8cfb5a862da6e49096f96d62279cad9b36dd1e5f1074d554dfc993dc8fcc34b60c56e103a96fa19a4040cbd1fd0561966b2e01fff8410928035647f07d60006dd1437af2c12ef6af06edd7e82abf7a927701b6bfe81c5dfc92738f3ce46dc8c6b24389396cdadff59d272fc1ace4f96390426b90d2f82fcf5ea9f4419120054a31cfaaca05aac6c93586bb790fd3ccfb1d19e14d492c65cd4b745b35350ee6ed33059269872e4f095de244055efed3e2d3c2d237ea5d3c64d2de51bd07e7b1475db7da6ac6e2fb16c65c38a3cda4a293cd8d5c0a1fc973fa9920c27154a263171096acc9a0f25943a6cb05a9b94b525a161696ccc41c634ffd50b3b31f390f4e52fe5a38024b00a4e1fea2691a57dea2948a3967be14289bd7df93a47b92ef83bd7a5840bcc8d956e3356a9ef5ae432ce9d815768a82c79318d1cfe38b6fc9b98c6e1d38edbe9029dce1d78c95a1de5b7a08aa9927aa0c29bef7b5219679d3d3648584eecbd059ada179ae8772a2730c0604d823cf792f00ba7916dce6f91db2a9d46441aa7bb8f7ff31c858108e2087ce0f15b96b7bc8a0b72f78ec026f53c3f6c1b7f7af820ae505c2d70269d48f9473ef20a152c9610e72338ff72649c9f162c39d640a815a353405d754c2c1575848be4c70625a310273695814964f33b9b7e1aab0311489f97c39d56aab0bbe6fad33d793d441ac01315fb57442ba9147121dbdd8e358dcd492c7afe1acc121553e7e52def3e496e0a3df9793647d7610399e0938fe3fd013064c7ab169b5fe5afb7bf9bd011b7f97bc1adb8686cdeb8d41d7b7d36f3a79e7d1fe8c2c5bdeb2a3fe61d2318f1c41f3e024ed18693ca76dfc7013346213edf1f50ea07931293e0775bba37be60f3ce52ab0091ff15f33be36981a2edd30b73994f40179c71d987d5aaea99eada4bae939099e1d19d73a093b407da905f761547b642f56119cd0d45678ba6949d6ea5019affa78f30b74e755b0dcf8ee720ac3b31bd447348a2163fb5c9faf3f5ac843e867bd8534dee399b58324be0e9ecf725fa5537201debeed8ce8ebe34b1a0bc63c9105e3380e0ff820a7cd71c81e8242c7fb497ef7ca12d15a231c7d413fa68f6a13df0640ceb1417013ee5b06a2ebc7c5c4aa31f30ec1e356c463d9ce6816c37ef221e3dfd67c530aabfb1518e64eab7ed4a32e8a50d90e4ff7cacb8f0a028a96abcb0452a8647d0f94e6fe54bebbe2814743ff60a79905f3238521ad2364809aab015fba386c1fc17f8921564236170f2d6a141acf288adad565a2e03ee9ec4356141468a8a2fd36bfc4123b488e436c59529e066ab537e6e8114807726681815c060686076bb603f66973703651c5600ae1a8a998dedba00301d6bd8f7396439376d58080fb9897c4fe9a9736d336a4a1b1a79941c5c5981ece5c0c1f43c6beb74b7eea6deb548e5f9d305a3af6a721accc75eb06af751783a1e656bc00f3c665fcc446369499faef157699d3ca8b95681e1358069e6e01352895cb40e1653f82473aa92ca84c61a0e86a8aedb1014217ae4099a76c1ad37f5629d72978279d1db31ec6d670c25efb7ceb79fcfca8a9bb2cc293fa795f5e58a747c825b6dbae9df3d976213d5012c4e6ee89af811ec242cb0c8e2b987d22094673573158a2afb8399a12b2258fd4b3af9ed58ad7e3a4175f6ed0b8b02232dea2708d3799a08b5d06e025db739570881bfd7b788a0748ac5f9f7490fb587b043ae776bc15ed7815eb85c5905c5ff434cc36ce192c97195df33fcd51b1e4ad6972e7ffb925ef054fabfbacee2d6860c50f8d26845f2711d6945c9c63454a9a88c80e87c749912ed45167e6f1a027cc447c827fae0b0f34e7ea9fdd80a1886e318fcb509a593bff9715543464d67bf353c0a502a1cd602a670973a8f7e8cddcf2bbb025e25da629ab419ac01a93afbb2dcd9b07b2405bfe1202bd219cea80835b47048ac6f082699fd62d7c818d387e97562311653ab1116573708aaa71a39504a4670e1baf29cf17b36da2a9fabfc03ee4d99a098eb6aed4eea8c5ae31109171da43dd8158748751aed77c6efc91f0dab1dd9595599d497b2090cb47969e85c5c1ffa0a34cd2d0e59663489bdff13dd1147642b182cfd1a2795d7881dc3e8f78726cf1bddb9c0e0a4fab36dffd0a1b456bc5a946a91a3b1612a8723b6878e177ca46b1f5af225c78d4618453cfb20244b6459153aa75bc966e08e4af5b8500959a1ab94b000563196cc32acb6876f0519d00776c722c033d537f355c20990da99c5a3c4d7d2cfc513a794b13ca4cf5ecca2884fd7a3b99c1741037839e1c084e52c8f85a30771f3b1aa370305f81639b6efb475be50a5142241705c68b920a7afa9f35686e6d16873741608f8c00080c5b5a7c8b22442463bc90559119ec0780d60f9541dba3a71c60c40a57591426baa275117d84334c95a38fd4feb99ae918c6e752e49d51866e2be9cb45ac18aed9fa5d19445d7098d327713daab19d62d5b30e3417ca12c9bfdf46bff38ef0ea738950031f6198050b0a2534d13f04a3de9a654237da147440a7059243b1107ef648d513634a67084b7efbfce87e3cd88bc5c2b937feef92a8ecd6542948a3a9cc048658f63029e5257cd331d80b76555afab026827e786b8b69d66e96bdab692b95273c8f1ead463376ad322d9d88b3ecd5f4ed315b7949dc43c5e663c4665e851938c7f4dcdb6781c33a95ffeeade6feba0d6afcffff5ab2e0d49ee877fceb9ac34ec78c7044c58195e4032bf4de2507b6c916440accd1d3f40b3b477a3dbedafb13c68c280693f4292083768bbfde8dfb6c6a7bff0f00e2213c121e4a0de37d27cfd21b6f9ae3fa88588639b00850e2b36eee3281766c126f4fbf9758133622c4cee76ee8937f6ef746f00a42ac4250087f4d5c934572c3161842d6c644aedf691777532741d64b4f77e08fd056b2ad619b93b99bfceb8b941dfaac4c195a1875f93f4f45ae2ca3dbb934f5b58470df1c4d56e852709c608c29d8cac2460bd91a25e822f8ac6002615a866cb818e9ed02599cee7fb5b00b1a1882ce60c02bfa4f293fad6764038ea372d43d11932b45e3ca433cbcea004878e72778807db0e1e56ad6cf7f07fbe869defcf92bf9b63136223685beed45cb0861f29109faec66deee293e475932423467dd5fd546a7dc37163762726e28c3ba929fe7b4bac44382f1b39272dbc495af85016ce2308f639360f2c4abae4dfabc133cbfc362b609181095142a1644d96f04a4bc8594951cbf15ddd0221da84a34a2f50b3fcc09af6dfebc2d2c43fc26a9b7580d6212cd65a6f144fc8d42caacf22385af937241c1e54ab2b810595d8c1ec49a80138a90fb32eac3f06d74395a6c9cd65ac544c95f60aac8d1b3be4f62ab189b46b92cbd7e0a72d9af1dc6505bade3f96b969fe9056885c5659b3b2748d9fa4af71f90ef01e056e4509b4b91241dfe97e8ff1416cc55b03c3f6045e7286feea7a0050c7c34a05dc7933b67447e4a6b864fd6a448a04f7f49257765ad5ba8ea448fee9f62abedd1447e8dac5bfe42f5ed862f18007b16143e7f7ea80e89a8de7b561ac7ead3ae394614fd4cd6c6311ec49db78776e145df3bcdb93f9d51d1b38f7252f2d2cfd1820cbfdd82cfb723c873c4a083715de469a2631a706c6effc8f81de213021f020ca7182fd811280fa91890cfa287e832f3fbf79ca31c3d7dae665765ebb48ed5a24ed52582564e65b6ab7fe08d5b51fdd668ebd3e35ec217e6c20561714da0ab6497f929da288368dcb3cd1818b8be2cdf2f97232f11df4fe177fc222937f4e14c2a16911e371a35789b96e6f2e16468c2b15a99340390f8faf8d35612f57eab8a6d1fd896d7f23c17063dc0d78e213bf784014a98fad6616b242bcc4ca86784f86c135c1ac8523ec5d4b5719f56a75bc5cf901c526a588885da4d7a91babfb159029b14dc8b3b2162b605f1fcaa5c38948a6e4327b6efe773e5620781b4d28208f157d53ea56575e6c550a2277380ea0f4ebc9f17eaf3ce4153b4e1d9c91951c69800f9915d735ee5ca2e1f885533157861da6595b117617be310333ab989bd902d066e494066f37105765722df5d977c9b087dbdc588b53f0a399149d82046eafc5bd7ff135776fb93f435d162fed667598b8f4466f88c1f1335053ce4ebd65b67c6af9e73615ade4002b4259e6cc5f5f047c0ebe795e16f33ad9fca7e8c86d83dc2cda591b10ee04d0e8bbe6c6842e7d6dd322f9361db981909912c75fd6e8f351a0351bc73a03cb8b3cc330223b9f5ef2f19aabe63e20027df1b0862f85b0bdf25f701433de81c139f1847c4b7a5f81fcb021eca26913da98d5bb73816f117eb9736e9486561f80514d0c6c4bb7d603e1cdffb53c121f199c70f2b413512582e1455748cec6f267a5b29560177a158a892c57cb894622860aa9b1d6696fbcc153ee8358fa3592667a4c90002e5dd986ddf2f7210ff04795cda643a8b0d507feb6cd78af646f7110d1ddd2e1754be2cca46b176b0489d443161a8f970a17d3d3fbc3bf4225a3f73c34a578faf1e53a0fb98145f05c9e95a8e87d45f0bec00aad6bcd7eae2d8be587abc8fd25de3a213379fb1504ebff2ad21418fa296677539cda278bd35c9e779c0a56e6f2cb80b2618ed62f29b42193904cfa8ee45727e44dfb0610836c73b9477b15235dd3a9bff66658a626fe543a15f7c29723de6a611bcfc61ce0a6bfe53338a4863e400ae0fb6b1dc5db6b990e259a564dfacf5f5f075c3ee37e0555b80157a11e2a0d76c5607e7112fbd140de65e4c83dfac39736cba9da9d0fa9eb747e69f31446c440748985b4668da51f677dd21c3b8f16bcb1d05c154467eee6ee4d7d19d60b66199d3f0ab4c3ace447a4e9aa8f9c82221fd9a9f19362a5f3ff63a824492cd5605d7947c425b31851b47b8e3f423c756a150b7ce96f6951b37e200c6b7480fb1501d181a497e4e7c36090cebbbe76fef7e3b5a0911e4e62b7da9763cc33782b4e57151c4252154f43d57c6ea4f0efb8fa4d0c677d0321d09bfd08eaecbd8d04685b95d20ba546160a7881df552255c3d5fb6e7201e7c94a6b4d9dcff12ede721be64d651d3f63f01dafd6a7a628bfb3b5a70f5e88e2f61f259f3aee7b1b1f547f409f29d7c8785e875391c2e8e088135668b607bdaf8455d21c9c3b2f576966cd89530de63d045280294c8cda9c1fc4dc535603093e280c58acdb636ac2b56a21785e492e0417a081115e6d4193a5eee0d28a2cd985504bde5a040bd7ffdb7ad32bbd77f2d22fe9ce3c675aa3ea2017344e4261bb65d4c3c355151623b2a870dc77683eca132bd849c9014e11ee092dd388e330e03be18b5a0b650a13d6f376f704b36dd620090a2cde80214864262e246be31aef82c290f5d9a1fbd5818200d177c009925a01328bb0f89d47ccf16aa378477d4fcf3d1faa8b415238e24182bdbb336620f76a5abade62c75a5b2ec95a2cc93b9c764d330eff4fe354dc1e74e6f564bc897c6240442399c428e379c020ed0cd46257363a9254d20cd39c0dd42fabb8760cbca2b05acadf398ab4e2f6804d3b09f767e6643cfcf2dfdf8bb4416e389c1de1445e9ebf42f73efd897b611f5848d53215fef1cd8ce6d84e8a840893f73fc495b936e7ff93b5309397b1c9af92d8e7b268a9c0cbc656c65c9d098af71ebcf4b3062bc35bda2f8c2c00090b745438d0c74ccd906e5c50bc28b3e26b87c47e68f8bc57c1d68253d0d247fedf564fd067d6e800f8d41450dcf103761c28a964f3084bc8d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"db2470865aa068691185dcd60d0115ec"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
