<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fae66e89ea729c47383c9559daee98d8707374c763f3eeb41c82a9995466d2f40aba6053218dde7a821291a07ea5e31d63bb35071e568eaa9a15b7be48055a088812fbc5f1a9ce30b2583768d7ecf379c635e44cfef0ac173a2638b52b0ea954f03ae14901386a1f7fd33ccc0ba562f0ab69cd28b52cbd2bd33d5f4d9189620781a3c41ff487682d4e981d7140ab6d1e2216c5fcf9e75c4e2e03ace41442c1f076f3f1b397dd78aeaeadae15c834aa31a753729f4c12b3144cb938d07bd21c1f6f8ec3fccdecad2c96a20ae2a4ba4349715b9778bcd49d7be56b92960db4321c7fea31f6659e0bacf361af95372094d6bb31e5bd28664d03adbc14dfc18f51d4671c7e5d546d36898561e9a75bf714175c921c81afd1bbb213d8643bc7ac89b94ce10c3dfb9e570a8f6bf458fd27ffa9cae9292c13113820c7fcb53cfd60516b18049e255f948bb6b38524f170d0dad94e25abc67152be3ef3bcf28f2342c37b95028c8ccbbbe7dcf689f8b27768ff298767493ff322623f5cf77f0aef50a37f52b8e57086f8b116e3f89f0053d880b97b8bc0fc8aea1a80a3e39043d5e39e2e8eb482c5065e545bc174a1bb13e6e44e604bd007fb14e71aaeacf2cdee1e864441e68cd9af52c77a944fbcf6eef001ce1ac1f85b22645279a952e6f625443a089a0e81d1b511b26a3125e27dfe9231e782650b4d7c6aad02a96f321a7efb2b3b6ce12d0570081db80868b031d124509df7a350fabb0870a0886de336f466bee880453acebe31722f6a410051c7472434acd95ff55d90542d7c66d159f502dae52f4c9ff71bb75cf4cc39399145927e7f80d697d9e2effe4214347935ccf693935f7ec7de837c26df012b5f13f918ef9a83f76ee1ccf05d70e2fd6c44ba71a62c66015e81108da248f41e7f0ad1accb1b39fccb52b17daaa8e68185bb51df42680558cec79acd3d38299a83488ee64b4d664a2da26bdf094f30a3387fdf74880007af5106b3a8ad3cee4161646bca1264c71b117d0b666d6de69506e1776763bedce6be4033f1029500b76643db0b2b28d0a8a3d8cc57ba66de072da044f3b9637f8ed7b66385fade400286a93e6821285b6f65afaf3508bc2520a4c25fe3e88d89021e6cf961119ffb0f2749925745f3d9181d4da2d5dc03992e7bdc24c23615ab9e8bd44ccf831e7080e8d1dec28c8331afb8cc673aa703250b102a1af5d7e5363524f5703dd8c583fe83e159d85dd561e8d304d233114b630241e021653c98aae2573028d4558499b71fd02b11167dc6c102942ec9ee0e99aaad23a8568d50a6ce843974b7a7de68269ecb7a969b7121fcfae42b74532e37803330b2212c3c0723d4f369b7f02f6b6411329a0778195ded1670e6a31912ab1281c521aa5ddeb63ce3ac5489686ed2df0586ef439ee061ef51c1cf0b5052f99033c8b7f006d94f2b31c99a521fd3f4a7fa9bc1af42a77bb46c1e318b7c87b8aa533603329fece00854d80fe8141aeba64353916d2a1be9d48139ccc56cf2746b0e17f26a193fa4e8104b4e730b06ab19f38f6d471ef9c31733e0d127ce31c1bb4c2201f1811915f951fc7bfd3cb6a3b3586f7afc82f056171a30fd0f300096a3789079edab61aa58f7f686c579258a09c04cf3d43cff5d3dcd5a1193d8e130f6c23cca8375a25bc535ce60a0abbce2287fdba64bfb300f18ede238507a8242c97d0cb6091401b18916a4c3d69c70b9d6640cfe08418bdcd0c7cbce93ec697963cbc469628e10e459dd1078e2928c3530f43092680dad5b8455d26400e37aa762ed4e16f983f4fc69897d219ffc6c4ec8e302226a12bce17c03205b784a8aad1635027e13b18d97b9078b610817418dbc1d6bb16c27409b5e9e3b0887bc2eb794f90eca627ab8f017423c9ba3d7882dd4ac4653ba1962d340c11797e13c20ec1eb7642ef0ce68b2b92e8d98d09b71d0068f28b144f923aa583f276147f0c99b07deab5352034f6e0d85f194ac2cb3f0293e1758a6030a554a7f3484be9754f9a0a31b0bbd7d9c56b4bfedf770307d3ef85060541ada2f666fda22241abd50ee36ba65fe5e6d8f2b2c65d1ae8d458c6c13babefe4dad6108fd64af5bb8e299f0468ca4d6ddce2cf54268ccd544d72d343800cf720949b8b6b8e2f1882262ed48273de9a4c2aba86c0079b48e56b20cc95df8dcf4a52b2dd0e4e8fbb15058dbb5b5af36b0316b5783109dbd0876bffa73ca68572abed0dbaca56d44ec8bd3104153530e80f8d5aec4db318b38938699fedeb37885b1ff33b52fb2dc3cbcc78d35ea12b56558850508345a81c4548a5cc4b8a9577a7b91acea336e6e9b85df4862d35bfe9529eaeb9dde8e1ffbf7d22e36ffd9e6e04c4bc5969af4bee5fb168ce5245d50443630be7dab2048052e92bd9dd0ece4ac1e12f0b6c58ab9f3d74013c7aae58e04a763d2cef73242e0146a0e18a2798368691b43d33e7fea193167760d45bcb8f420034cce7cb2d366858f52c16f772751d7687a2bdfc0a4faf47218da4bf4a0fe185d2d1bc4aad8f9420f4c446e314e4b023247d0057f93816bba5357369d2b15fb6619834c87220067b4fbae24e5fc5fcb4f7f7fb7f309a276b03a963f1df6db0f22bfdff12a9aa93a92e90a23eefef76343d6b58a0f8504f5fa39d766955a92a0daca66598b6f644c2bd50e51e233172f2429d67c57639ac29b4828548f6f93cc27786c3aa9588b4613ca59e2458b4a6bbcc0ee7c6941569a9453aa71de0be72d45b41ba248af60647c2b5ab3f493cde76c455f0cdfffa148f44ef6f5f0a62658be19c70a6ee8a8b378509e6c29f990f0c05ba7416dda2d0d5dde56375d67d7ff6c04b0fc3f78d249565f2edf0f366e33c8ea06c2f988131b7459bc2d2da2f562ac9c8cf9df888987fef5a0b1ac8830719078b9315c179afb69c5f8ac721df4d87b6807b2a8c223f87f6fa1841a04bd5b2a9b9f92bc7de6be384679d3839ff02ea2812ac1154621c284dbeacf76300144c983e92f29f7eec3d3839d26d128cc3b6d386e3455cb09bfea0d76e787b60bf67132a771a24a33bb594b32d5c0b23e35173fe67175da9f8eb122b409f126f7eda86a98d0795a7f1c7e49d785c913c051bda8b74efbc2628194d3fcd68896c82634de7ba00c2dea7fc8296cd77700b191ff2fae5bf2d88edccb56328b8a2c86abd62035bdfb18a9d980351681dd0b75574255a56ba376b5048bb0ba562e7cc689b33f6af784e22960f550ef2944b791586ff0b449990a02b2a47b153e6a9dfc5774af110fdab0f013eb1cbc7b65e7937c914d330592054064dfe0fd82589f7d25341433161ad5099f8f1d0be5be439adffe3ca0a2b91752ac299d49e51794bf72046903fc80521f825f3081f0a9a4754a1d9e3ecef7bd2df94c557c699a8c584f4061b159f009a23525b204e1e53b6370ab140d1f82753fc97d26ff6fe9339bc915204e99fea140db86c9afda30898598fa3ebbc2832cb118efef0f77eb8b36fda382de42f1be21806e2a8212ddec8bb3dd4f3c3d968adef77a65051253303e6fbf63b15f7f9fccd3b5ce11df5c63af11043573c1c67a0c18ed7e2db053d20a540b3b8f5c4eb5fc81ec25db0041ccfca0ffcdd41efd82d6774662b908c818fff0512502ca84c38c4c697af576a661aff8e23521c207e61c620ef951f3b4addb1c955f945b7a9322378587317f635600f8e240f8a7b7105daffece8bc07e553890edf90b4b24c4ece6cffbdf67398b60572a129b7ce6cbe03291a32352d694ac6bb15542dfecb38e27a3f61629f7e53651967661ee937ed53e344812521f655afb9a2f1a7174c6548aa90dd8f28d9563b08cf23ee04d3f46fe62b6d628b79bca7b16e172c6dc06688e172118cad6982e5cad4794a4c7af01185bc1e87c2ce21495bd57d36034796ac40f8717ae42939dab4d67582357c9bec424918ac3d431124bf2cd4888a3e3738c3fe2ed98f354947d803527997e0900b431342533c085508d8d57139a67ba1079dbc1c08726bfa5903743565d6249b2fd1cfa7afe541ca4cddc85a569f893d52cfb2f62704ccd09b7d2622fc9c2cfb9894719e2c166b154488fb0486380c536ea91cf4976496857ad6f29a3406e60a8aabf772a5ee27d2cb11b90b6cad54b0cc90f5b90bc02d10a6d6b8edd8506b47f0a429efa3634fd09c71a2e6bb71633a23b39c684e9b7603e1a438d8a39198f7f19cd90cc854ba0fded5c2ad6d92a00404007c78ca7215f198954d710441ddf735f49e7d292e3841bff0574df681a80607e419f53db709a508cf08b7011f7c18cae4fd4f4cfdcec8ddc41a841ce015e42cad43e2b8779bf51bb0f0b72514227e38b523db30c733b2056eecb4b30eb98505821abec8af1113ddb8218195e5c7e10c530da080a05ee903ec0401f8ef7dc71c9307a93072b7bb5113311980e827b15db918ea77bdff52a853acb4a898ac2638e7654bedc7efa93d7f6c9dc70d6913d3c4c715471862232643bd9171b373949f99ee9fe4149fa526379c73f7716cb9996ace996c4ce8289cd2727808c0f1ad17896ae171dc58465c36a549b48c4ed333dc299e3aa4357579972785f8b767cbe3aa0330afb492f504c1103b954fb1bae376caa644da054229f42dc938157d3197607e9b44393e01ad247e03865fda81b5de2954ca0c939486a49f0c77635aaa5968dd50a4322d0286debfe5c494cac65e026dec345b9735527a55ba2ee68e00582f1603ed6e801bf9bd77b34bc1d45feda86a4bdca527be9a0c8b44a1018b7c1c792a8ce2eac7e90465cdffbe1eb4d851e476e95b5e22bb3ab024ef0099fe8c471d2ef96a181504bf74c034adbeff91111a6d438e11a7cbdadef7fbd47d5789ab8b651c0a3b8140661b34028fefc06286de35a404f55cc5bc1d604a9232cf75c02500bf69bab215cd39eb56e0d5843323e39ed9a36dacae5995bd79ceb1a541bfae7b1d4f051e8e7549b0daea8df7a17188f655f4c7630ebbe70069afa48df388b7cc036b5d944bc4c974bfddf2c8d9adcbffd7431b6007e700630bfd97ce52d2db5082d3b5dc77b611b90e0dd524c9d0a200db37bb1d9d75e057c67a529f08180815d1293857d70afa5e3c5c791925d7ec20796a83e341324f4665fe50edc5c99823c82c2967a3ac95cb66f1af43c0898484634184dc7ed4c42538bc72bc33a0027a99d556685ed80c091bfac700644cd615905a930ba59177a91dd42a13bca631997a2f09b8ed0889d85c004ced10d378ae716e7ea5a8bcda5d5bdce24ed8c2a1d82ddc36006c9790899319b11f2c8109f730b1f45fa5e895cb842b7083f81360ac08172bc63d85d78f8c4227dc1307ae1b30c55d2ff39b0c32e91902c0bcd68d489df6fb2fb69eb75d70273f7fdbd014e4dbc2a9936303c9d11b2ecc5a1e74939bfaad6963cda9999ef35d409bbcc6934aca7b5ba9ef0d9a5e3749705d4ee06356b37b316e97aab1f204c4d271f68db073257db94edc7dacaad1c40a1d66e9d9887d85730442cd29d3b6c1561b56227064c1f2359153ffcc72fa0df2016a85ac3463eeb5bdb4588214f75ac157efb40f54204d17d8e9ea1cc5ad384cdfed814f63a6f084b9fefa9a97e013ac9b311c18887629f9664711af91fbd5157047ea67f5aa47f843aa1726748911069b40be91d11579b36983dca36a860310fd4905fe399073f85f19d389a740d90acb52af984d4ca13db4a46254c39ed7fd413ab7893b633a9f442d819eb10b99aa6767c47d83a4df916979109e07abe4ca3b70405cff425c391351e7b6185b0787c1460e2c8fea88f807775f83aa3245aae95961d9ff64a23fb27e893ae12c282a76c6a10d9187680ff04252287b54c6f4fb79f6ebc0d7a7de4b7d78a98a4ddb8594fe0340c290ce8c0b3b38e67cb71e46da72a87e6ac9a5b211167990b8c10c79f58d583b81df3ff5b8281aa27cf01b4726972e1af16141636556aa8ee33b77d1ccf52ebb0d926886bcf37b1224e6df252b65053677185056d66c4a4ff676d836d9dd4834d53d74d11599d9873a9af7a040f4f219d4c9c27eb44267fb652fe8048b9ca7843d4a953af08433e589647355b89a01a6c6f9076a776fba61367612fa055e580b6507f3d26bb89759427983f0c099db472e5a4ee5069fa1753dc6a1e5476b1f6e229b156429494fb5b3d38ea9f60412d95279dfe12528246f575622fce0568610207cca6b3db5191c3a11b65b31c35b61af2cb5314af1c55ece23755d40d2754ca8c5cc81064950ef43f3a94e2b4d8a64794283c2c7f2f0c6eb32b509d9b2613c846f6b97aa54e6b0c04cf061b1711c2d549a0c67e50f9a5bfd12f505e606282b7ab85fba4c7274bbe3db636c0eec7169e94b360c1c3ec38dbf8746365b33a085cb5fde09c9431cece172a01156ac47c41f7405e673dc5ae836a42452d08c77ad0a2a10adb408f521db4374259c77b0e499bcf73ad38df481f1acb9a105401527209f4042914347ba82d40244b7bdec294dd1ec4aaa471f80ad8c61a259c2b0c121bc67d64dd0fa0a2f86569547996068ff2155adb933a070733212bd48d2121e2d61915d178d263f77d1dadc04284b212629d094b315ed8ccd728484b95d345f254a36722e7ab5960475370dcfb19e49d52a553abe5f4f04194d0ce4c08c2829d4676b51c3f09405645705466dd2d280f9bfada50c27b86112cfcba1b82d36feeb1cc4c6bec5cb7fc33ae365c8bbc21da74f4ae8e72cfd2c6f05615586f8c75d5143c52846e6126f5586dc75bd1b001ec67dc4f8571269cdca329a83fa736225b7defb1e9e4a26fcc07f45e7b5adabf144e315bcf62fe1e2c83c000c9e9aaf9b06000374851d253006ac8a85d0b82b4ec4adb424a95ba490887ceef13cb391e3807f5e85bc4eefeb48cd5b2fbac2792b405a7a62ec8975698379833bc5d5578c41a9a3b5e12e4d2dba83fbd061b91cef6ba0b44558af7ffefa946c603afd9dacdb7acc8fdab30e40c67eb4f27607649b2035b7c50c2752082eedd11d5b6d19055a40c08dbc495dacc35b20824c4216ed05ed977a67ca8cfb47d0c3c562430b6064903b37262049ea35be7035079b5b093fd74ecbb597c677566ea88b29782086315ecf26462ed6a7588b1ef5caa33d294d1c66ed3ba2a8ceca472e447226be4febb84a59e81155120a376164c17f32f8c2ff2f5b14d6d106f36647aae3d7c72084053e5bcdd700949aaa16c0a3d5c663bad0e9bb31cb0e4a8bc0c0ac0910c82ee8bff6610b153707e37fcf7161406a65e19e8df24acd61d01cf11b2302349aacd1bf4b9fe6fb2f211399cef76d2e4aa691a68c5f9aab8544cb6661df0061cb95c22c1515fbd728cea78665feacfcb476565cabcf76776cdece54328eec8dcef514b64140463200257cc9c39b0730e47f628debc3ee52dc5c85dfd17b02bd3617f5b9600fe46ff7f95a7d8fb86f87db8dcc610cbb2e2acceb1a6f25397f96986cb460fbaf86954cfc39389c1705f2a0a69e960b164f2a4f18d3a5d87e537430ddda7fada3a82a6f67bc32019cfb0b89167209cc4338c5ac760121892375c8ace8e882d57dbf2b3749258b67af856da3fd1e0baf2cc58039acca31ba42582c37fbc9005f57cf3a1203f83794472ef14a0231609fe218cb8b70f6c3c957995e85859f28371058b073dbcdb771889f6b29b04103a1e658f8efae38366eae7eff9a764efa3756ed577b07f00686ca19957b04b6730a884b4f163ce201a93599705852b044637bfa7029b7ea36cd3932a254fddba730278e3ea7082ef932002cf39fbeccafdea332143ec68040adb50100ac0c7e8e61cae043545ca7f65ee7de3da2dab77b2a788384a11d57e5110f080c5541986e62df650d9be50faa7de738cf7ff2cc62685b0891da37d17cdbc11cfcbb594b1b12f891595f4e38acec1268f8fcde84e937c847d0247e975c464cd8fb46bb6a2e9b457a580c03a0f64b56a71ebcfe78e1a8f87f6c15ebc4c9853329bca1ac772d6759c1f3524a58fe6b45bd8c37dd8d8ea7a7988cab4224e4f1d337a3072caf672dac558d37d722b0656ce4da56776c15f9d28db16e1442b61304ab8a01f3e19c8c7c238cff912997f11729bd18c68409d8234b601c594bee9f2d368699e38c75de0cca324760dc41188ffda5d41625bc2aea337f695612262456aa0706afac42cf78d49dd43402461a8bcd99dd4adf3c98fe61ad7b756d131ae0b80c5dafa6aae7744cedfc564d1defd7867061cf453c4c61ec822e65ecb53a64634a1fb45fa034aa9e107491549dccc2809640dacb6faa293b2ef9f5a23997d5bb3850567d8144ea886950bbe3b49b1e91eb185047441eaa2e72a68479c8803d937550a0e3e53be1a12566c3b4583e6211388c5a468accd3bc8a1019a6f9b5600b8f5a11d509e01dcab73c660f70eb4568219820a42698443df08fc19a20fbfdf2e25539b33b48165ba24b6c4e03b925976575715cfe84caecf51a54f9ec53e416962170c90516f54d915f1d91d2e125714efdfb5106802d268afc7e67bbc59ba1472f1522b8f9b2a5ca110d8cf602d69d15e7155ee8fe7ecfb2919bc3e66eb696900590d3d077fab7377538a2b7074e5bb7d5cbafa553f54deafe1dded2174a07554f18aded5f2ede53af5f14956a25375dc069bbd5086a8358281555e17bca1e92ba3f6a5b71fb3a5878850f98db701e36c1a103893b1d14e9ac5cc8bed2615d73fafd372cf810b73e41c3a2e5c5dcc216b2249f3da716caaa2d0817213e8d6cfcc291aacf6d28d8c91bc55420fdd9dbd3adecdba938e7bd772555b2c49c62182974a4159e73771e401a8b1dce3f6d1382e2d0bbd37bf6a6dfb5dfbbd80b7806133f77ac22a0f53dbdfa40833c0b7f28b7b75608599628254f92517ba0036734ba45504abe25ab9be9c07e798fe0746fb99eb44713c45bf34c338e45ea26ca545df6b6881b08c3ed931a1fa80ebc1b1314abceb1944def8d3248636fdbdebb8888ec2608b720d0adf195890ae6fd7b4612b4dc4a83e4db3995bb90610f624fc5916a4570347b4578135b5a642e11a71efde01578a7d5d1e5b5c3ffddbc6154611c2b3f2116ebcfbb67c38719c077df0d1a423e6cad422775bb8bbdc3152b89781bbeee08f12f774b93152808599f76903263f40acd7bdebe25d2d388ccd2e1ca9cd0232943e1b16f8ab52aa563c8dae75e1abb7ef243abdc5e46ee04d94e48d1d845b74fa45292c0b8f2505f4fa23cb926973d432d35586e4db044443ba7e6b1c5c35308ed472b76dc6b9de05de231083690a02ccac5782f425373fd6d7b56dafe677174bf049f2ad7c35056c73d2488fcc9342dbecb43cc36ffe593bdfb3239b6faeb3d7627b5a174ad8a75498e6ba2bdf3adcc762e66154fd37efe3e2cd63c57c27370cfd968d3568d9adf8e0ac5f9d9584f9db7cb3cbd588592238d4e3d37ed29d87b5df0be576ed3e83acb717d6648bbf0ffe9fdffc0271c5476f1908a5dad04705f6408985a6e7b4018d1d51fa85551de4ede653eea15ce522d952ed68c8278324931a1dd4fcd10ed7f0b725d7b079ede0c864dfb5a8ec83e3e7c841b2dcfdc338c05a3c8e880ae24c211433d8b30b0f6655521985d22644eabef440a0164d1ebfdc0a835bba381a724f70f016e2b8df50d6b8a4b306cf731a6fb73240979a1e1a5ac53813f0bafe8cb19349ddf16ad229f4dbc5e9564a0a06b472a66c28319fb07539d88f880c3807be2127883fd4856fe2c560180e565891adb07968cab305960b4c543e44e66a0ce55d5df6e9661fb5a0bf72d0ddb85f9bb648dd56a34ff6a7ea003cf008aa19533994f70b798db41b4c23435e2aed3b7df2c89018e62284fc69b199952196d25985f7a0b56395a44e67a577a30249d142787d2c20707d7c3f51002270e72ce2bb8891487d75b0715fb5f23ca13cf92733902bbd080318a344083b9155a08d9921c16fbdd82ab49665035c3320c955310168b92529c8ec3d2e118c6692fa0f2b0c242ec452bbb52fd00a0076b61a11c89df16e610c2be0ab11f895d50b1ee54422d9b1b1ae0e350804e4c8ce0b27859f21485867d2bad84e6e940f262de006cfc2f2989acd7b8577770eaee63bb8f0f8d4b81c18a3186e0313a7d32b36454296eef8ce58795f8c0928a1721d1d8f828b0a2d9bff38167437aaeeb897784e626f87e28375c60f99ad3fd8b239f67ad95cff41e1a64fb17df982345ccb4347d98771f5e015fb08b27d185cddcb0c640fdda01aa43441bf9cfadc43752b19922c9596c6a40777f2026c7c4ac4aaed89ad39ccce76e528c2f427f6fb232564c4faa12365aa6ff89b1828ca0e5ad29556198caac1ff038a20e7d6411bce4751c575e98f5c2615109b7c04947bd1c2582c143b2ba8ec85ffe09a2b905ab09c01bd8d3196f740cc5d47aa494bf7ae43aa42380242084d2df3250a9d3f95d9417ff8703ffce0b4cb8c8f3ce40fb5c0e89089ee8657beb1c23377281cde1ccc095a2be495ad8f8c6c291d024abd2bfb8490c30178de4c7b999e7bdb9da607458e97565bab7c0620439c51940b26d8a9e1f8d833475e246e32bc51085a35176a61c9c947254317b67690a6d6631eb3c6f2cd8c78b0a62e93c64246bcbf61c73b5eb629b58b0d65cd1aa303062dc235b9ad0efa653860afb2bc5c42d12eb3a4f9ac013275ffc78277896e36d31260c620836301ae62550d404ed87fd405795f6d0b635091c0a7e188648b43a05319275924171244c7e671bff04e770975536a51698004a015b42b2a1566fdf8668f2c17f3d6ae395ffaead6affeb12ef7f429e0f77982b98ba3790670fba4ba20813b1a69397b2397bdbffe089cce7e261a2e809d81e434090963f9c723fe35a5c2c732c700baa3d13c0c67eb66f250674bfda605d93479af9cfdbc3fe91eb4c01f8f9d9dd3ee5d8ebe3f1a08404eea59866d160d5cdf8754ec9719d65c65830d7a7450a415675cb603b8c5f6a38b502ea6721aa994950c81b097fe3a229f89750e9d907711750522893e8ce7e09da862086a1009f39c48670f32ee1a31fcaf649d123396d38eda29711e5e8106e1a4d0c41e8a5d3728e1f0710c26253b7c82ac81521fb742a0ca8bee6804a0ca0b3ce6b97b2e2bee768e73ffbfe3f300f6a537fae59dd146cb5e8ff2c705f75800c0291aec346ec1116e5840ea8d55df49c2785971067a88cc4261fa8808690de66ca5fa5f4410fd18e3727569d93074756764e3e1e1f840b7a177e39a2bddf30505c7e6b817d01deaf83833a114f669c1a35c5d2006705bdbe7191125cff78f77daf15da32e79a3ddf451c7c12b367792471d70733231b19d10d174ef967a817f334a7d89ad6d350d44180622549f9e425daf5b8ddd38f1a9916c60593ff1ec8a95a0d2e794f9f36faebd3b639485f0daa451f21591f3ca1b6fcc10e9b2445c2622590e51a9df078484c3bdab1f2d0feaadba82b78ee2e2fc5e2bbb1dcb7770341318e2d6e26c02f8780649e6c2ce3ffbd258c97ebdd95c5992b4bdfa35eb4faa8de4ae3fdf4e36ca37d8d0db32ad65374f959b7581875b185a979e7ed535e662caf7e822286b645df5761fdd36df4ee1497f3547d221faae1678c00c88daad9d735671af1e1c7935766c1e504c5f53e3076729bb310edaba766bba544ece1497af46d35c1453f538688382a09a9a297cb59351e6bc0d667a96fdb5ec6b5b6b71a1c244a0bbdcf58fe25010de0c0eb514c771f98168964c527ee4b8829027b417bf1a13e6d772827d48f3535ff0d2ed2032c85bab0d485a7bbd786e819047b4e6ee2a39f599ba6a953daea032cb2419281931967765712deb6cbc3d6e188ea11c9315123c88ecf2164394d2f8283b3db1e5d9404ec404355b051ca2b3f6954b5aad960f16a2c2eeb729eba04137bc4531735e17ef88bc1a271bece42121fad291f16ca5fad2be4e585655a78642eb3ad9ec2d2a3b135149910d5c792fc9ddbaa462d717372d2b13aa3d7f27f4215f58af6c2e813c606e4fdee07788d84e736ca2d7aeba7ecf71d90255328855aa8a46992dbc906273c608bad0117c95d4264ac5fa7309ee99027fabc9f0731b0b233664522904b001196418f463c59783c7a876c367068a89d7fd8047b5f5f99e500d839e7e342882aff6682fa6f82e3fd5b97109169dc95d71947e0cf046fcff6318e789fec82859c736694a0066f3a28d4285d4b7a8191d585577f9b7cd1e63c94ef0f8c7ac3364dd355dde99ef6c1d45bd050121130324546ae70f4b0b767ed4c8ee0fc557394585b981b6f75ac241f4023b1eafde0fd60c66a4aabc7de31afde6155b605df77ca1229e2872c5380c1c678fd22cfcfc0757549e32f688b9fc78d5be9f9b249b82bba0d16198308cf1945dc9861e26f131eb3713a5dd71e212ab82ff401cd56ad7c5050ca8bada123384d38b22914a76cdad7f932d059646bcd5a439c66b2f716a42249231839ee1785defebaed9d8b1fcf07f214d85db9667f11490261321f04903447559b737544cc79f4144de929f7aedbe2921f00cee7403638aa6e2a573dbf6a407c3d4b48934ed4a38eb862bb865f58b83efbe35e930804da232db4a50669bb3e0dcd74d3f85c201fa31500cfdc77bef36d732e8ce5d6c198058dffa0fecc187193ce1dbaaf07a158a65c98ee369018095179ac40e862958f20a7734d81d9a328fda161de5b2344314cedc3e686cdb22bd6442c7871f597352caf6a3ecaa28e1ffee97c4aa71024e6bec55598c865e918938219a6a71cc0a0594215bd6c6bd3a66941938e62d148d6e376502c6a4af3cb24e07a5cb950bf84bd7c47cf6403aa507100e4be7138ee648d82bd786ca2bd73eb06a8c1b22f1d6845191c95ddb5c496052c356b436c75e320d0d006bb34eefa015eb073dee1647435a169278ec33872f3d64ccb4cad38d921a950ff248c0eedeb893ecc9027348995128883dfafae1a5e50e5febb33e282e13737255c91fe586037d0ab41fdc32ea6f3a8323659e242d9cd1fd678bae365e79826f7135ea5ceec6c9029556d1b2bf094c454d8b0bb171ddd6166147491837b2670492db9448ac1a1c77bd8935288fa29c9b311f47d9ba57552cf2f45d554735c960b73ffef24c82c47ff01e497e8a5faea4ebe3a4872981e0f9c21f6801c42358c2a1e4b4ee1f93897f71b452e7f407bef56676d83c66d45041a5421b34f2bc64487185bae08465c1f17b0cecd47f4c3bfb4b9885632ebd28225706bca3dea41c9f2cc0fdc770761afe672d1b4a55bffba880786fc7e0ecdde659a339bfcec6961bc2b85c562862b2ab4d6cef52d027da5d5ba30694659cce98536e84341a0a739517d29eee2d65b7aae653d56248df58e796de739c8372727fa659c21e669c7be8ba91c434136ea2b012184651eda4c95dc861841d1890b69a2ff6e2db55ab9beab3a80d968f73ad1ed77354686f317530cb98118de53f2bf7b891b9d55a86b33c1ceb9fb401329f1cbaeacfd5aa213c10395b74f8705868231d4c15ec0f78dca07cdea2c9211fda289e66883b684e48a7267d22c5224830df95454eb2706cdb417c73e859f51f9165643e0696173a9506dc2fe639605542e0810774eb0969b4ea8c93f8c65f3ff0fd86ba28cc9fcff9e65305fb559e6ae2a581dedf6d30de6e136edba3c74827c3a1fe542b4f9b9f61a5c32579501ee7720cf70b6fb43875f7ffb6be118d320da613bc6486781ec9d6e0d8e40f2fa5d79c2a919cceb71dc9bb0911ebfae0b2230de91f4d171b87248ad7dcae84a2fcbe7d477a1fda51941fa2051630bf024a25c72fa246bd39c465fbdca3b5e56422e4575d362a10f732b8c77f2bdd567349dbc097574f1b5e376f4f0435a2b10e081fa806acf496d047b8f5c15bf2f8636f64410fc2c1bd10f7b6b89b78786376a0e46fab7c6250dfb80879e7a2b1ecb47f8430e0b44fb2b95f2192e5bc5253764f84ed9b8dc526e3b551a7114da8667773b34272e934e0d01c7eae0ecc9d2b9926d7702b2f4f281a31e08eba18c0c37ed69a1c2f8b02afe31587189165286c8c8e4ccfa51a254038c72645c55d4732052aa95d40f6293ac09c501cc1abf173e3fa3f5adfe03ccc3b348eb68d838d28a7ca91552ace91512563265f57bda4871eabd2c880f401141cb0a54068fbca925be97606e4b14a70e5cdf201c986f92de1806d6f159f490a7f6bb3c9110af0c7a2b5c2068ffe39dd918564db724889cd924aebe0ee278e24e8f638a45a5c8d393d88d0d0f972e6a78ce089159bf059ac8be159b49a3dd5d7ecb832d0351218af5139de65626ff7bc1fcd7922ad574848d65420efbb6514fbccfa58056d8db302a8cbe4c266f337e4906543d117c04f664129e500b582c46d3d553bf19ae3fe5e7abf6190082958ea2dae4d839076eae671cfde5393d390298ead52df1ba0cfe70a2e4100a4008b3d0710fbc194dec6762232873b1e5990badb187241ea0319bb67ec9821ce2fa8f0ebffe11d2ceb467e57a1c1402534d34fcfbbee95190aa71e91e2f134c6b302c960c7004fac52abf343511be71ea8cda87deaca0a07fc7c78ca477b467c33bb8ef30935624f1decdfbbc15fa62f0a2d9e567e90bd34dafcd572c521c047f3e8725a6e7904031132b45aafc8a6a81ab02255740bbc60652ef00b63e50d23dd4fdc41c03adadc64d7862e8b09a8d223ead1ded539489ffc287eb1c8b28a2d528ce0e4f282ad659a5d09c13bf51c2e14f10c2a5b2e7ad40a118890db71bbe8575267ee8580812cb4cf1858f7a354e41680c7ead65057186b4640668a800917e1183627bac347fb42249e63843c508873af61d1416e25906f0b78b36b2b19d800cf9932c29e825926edb8560ff912c1c55506967d36cd2eecff159442ceba9d13d77f5570200363bdb8d2f1c40209bd0a6ed712de771f127a4476177bd6fcb6eabf097be06749d9464bea7a5efebe0325eb241de5ac3ab1fae0c759dfb841373ec3c84b81bca1be5cff0864cf4bd91b091f249f90fe672905bb4971692ea4f88a22022850069cda49d69282483b7dca0a340dee74c0133c6ec0257a0a9b2eb8f89ec60a8e42b45e841391851defe44f27a7c14281539f02f486004c7a619fb399272c8185f32c39eae636ee81e6b8f30e353a1b633366201122672f3548d0c8dfe7ff4276a1d96c7eba4a949eb5e0d19a823fdd938a6b82eb30d28cfbc61f19a981c7685875c558eb735e5e48efb26666f8d9d5ba8bc6e393219301b4d4ef6ca1eaa0667352d68c7a358f7c40fdc1dfb0555d473c4fbe6948ada2818e35260f1a6a04c0e6e8f8a50ae1e6c1f62afaa1242cd5f4ed70e51e51500e018790fdd65ba48f33320dae814a646d4c7d038dc6ba58664b19fd9820061d3ec049d2f4a081a629c401ac070f2549e51580c930e688ccfa1addc5ad054611416abb41d9bb7499beacb519a7f77768a914eaa1f04be24d03450e75e33a88e3f85f4bff67a1f8b56230dc39ab6c6f9bc5261c968f3eb07d2bee2046d143bf69f0493785919ed27bd1ecd0b16ff8173c008551542a0c5209722d17b7feae3508c0f6eaf936c071adcdc768274c04c81b89541f364a6b67c9adfe4cfd9ac9ea4b1df51d5febbbf3f6f9d82b69c25d576d7f9c1f13ae9db8b13457a8dff4853607598412c3247e50ae6a103c43cc2e9f88902d6dffa01e3ce3d92eda4bc6848fee384e639b8201f7889a64aa55231f4bdf03d794f84f5c7de2afd2177775a24d1d0bb9c6797f61a002096b6a4b3d3b9beaf70837ad53d6371a6d6c3393490f9c0b609661b0cfe0d97220e1910899cf188156321aadbf85eaadbb62003baee0a3318a9361c7678ed92efc0d26259a1b02f31cb256de7392cbd9c3219a4cfb68b68e856fbe0afaee0faedbddd340822a599e127e3714a606e702ddda11656d2621b0c828342734050c05660c63954a08c387ee6e1dac82df01086c7aa17660e1fee0a0660b4fdb7875305c678315b66ed6f5863b9dc3d8eae1dc280881ec110f6df942dc2738d64e422fef33d0bb1670671a77d92959534a249541b016ea3b09b88954482a88bf64e47084aa786458d1a7da85a293e2c1b068739ec4c96083dee2cd0b82792dcf1b38b928f1c42f7736c304daaf03daccea743b5fda86fbe757fa14d50f341dc78321b449e9fd064d2386f16bb11ec6047e99546630cca9546bfd7f65c7c49b8c7071806ee21499c69c6a7b5f5315e0c855027b4f767e10b24bdccd3c65629c01efc753646fc4bbbfd429b76e9a8a342ee7c28b7c9f871d17b5a63bc031ded4c25d8d344ff45133593aaaf2cd961652710b1eba5c40b8c6baa246c76d9031150f35b5baf872495b7b59719af11804d753766c791bb5284c5cc78896c0d880f56779f6e33f04e99faecd94ce414ae95ead243c688aa3a788ff30698d2de5a97c18876b8e774ef85f88978c03389fe118f033a0ea26c5873b7dfa4e10ec839e31497e653539958df8db87b6b237fd218d8495739949714217432d21ecce6e2275b04d139db2538ebea807ff0c365351c5ed82d61368da4c91c2a9476a523649d8e6119c0e1782b0932fd9490764aee45ccd1c192f3c146d4cf9677b9655f0d0495a99d71163d6124a19a72adae9768bda1256ca7fce8b01a00f9930383525738451912a9e5c9ada6b8b34f9c04a192b5e09077815caf0cf1a215cd511bb9b8862992613ff446476afa55b32ec4629b65e4e208f543ce5cce1ee6f46668fda692c775a33c323ece25ce196804eee54e080bb356e4fa726dc7724d71fee3e00ff5aaeea14a0a072e46a30965e0be1e7b5bf632ac9411ed2889199d9e041702d8f2cebf6615d99dfbae4c689a206d01d3899841ee1f8dd336b4504f36ccd9b036367de1fa4b0e0fc516fcd5e1338a5494652a05311fd32663d400efeef7372a9d592958f616299a42b7bb1fb743446ad5b3f7ae84aba4b655978b9f596dee213e23a1dddbc69101699122458e013311ad5b9d20df80f9318b5596503e2f98579ac3b9d3331d79153904de686d7246d3006dcde6ebeccef9ffc0c35deddc477fe4615a1faeeccd73eca257678c9af5ac001dc10ad060047c9fce45ef4777135e8a341c7e719c272879d789bbc3508a8af879bf46794679b9b8d5c70cc2f772902034aff3b44a5677711323bfea2468917c43abe05894dfb199db7e4d1006847881c4e6fd3a2fbbd4b3d1f688e2e8d66c65318bd0c9c6f436068a60a75d900c1d2fbf99d96512d3e162caa62d41be9020da50eab37c5d9dd7f4da39094db3086a86a60621646c6d4a30b2d6f15003f86af475ceae9807b7eec06f858efaea1d2a1a5b53d631533479bd7f6e052f73eb4f40aaa9556aaa6da99702306a24dc89576124f8fc407bf3fbd464f91373112aca4fab6143d8ec64e9847b353ec872ce9e212868ff2e2289be6884345371f4336ea9a4a2cf9f48c78e610e6e0f04397c455dfac31db6e38d270d8377aa0741d29f3080e432805c38d3532be9f8a02cbb31ad4a1d884b888e89704c626a9573e9ba6e38f1cdce4d1295671ce538cf48302a185a6b6e8a18954a177a98155d29675d6c77ad73061cf35a1e7619f7ae8269f77f92caff52c9f7b6086e1053489448279e1573ce22ba5975ffc5508c203d1268f0d6fe71a9be23f62655d665126686a6fc0721090782e2dbb39136e977b9b487e2bd40213abecdd69c89724bcc52d90cfeae066692f244266353be5057ebc1a9db13bcf3de8862ecf7092abd2feefbc1d40212b2489c65b3b3727ae5109312e77954f02e2139c45b9185a23861f629f1e369661adb188ccaedc3f9b4b0aaf70ca169832d599d6c95f205037cbe816c74ea12b4b788645e7fc46cee59cc714838b369a3d1868b4c40abd543f3e89cbf6156dc5adb84b7ee0b3cb4b5710024ea7d5f09f7534c38553957aa47cb5bda835c022fa6d4d5df4e2e9e50d90c892178cfc92efb06c3a90a6630e07f3d990365853db9d0fc5205c748fd19072389423f9131f68757a34bc3c82f4c59557759127a222de4496bc98adf193886e17c77a769df5e761ffc84421c2cc08d6ad1e0d8ed5bf5249aec095b3c31d8c213088317087b2b5b1d7a87506622276534f64e8e1d13847f134879df77679f76547359ba067d73a4f6d459664a5b1029615d7d7d7207002794d96d98aa559b9f2074541593f8fe23cfe0367861530c29e2ab7acdc4611d1d0c47e0ac530aa16126792c838fdbe8539c670e62c99e0629bedb308a65ad592cbe93df04784cb8150e9be0ebaad10f1e9522cf972ddf5ef491eeaf96f30c3a438743d8ce419fcbf5f7915a32d06e621e6d62fa1bfa26b1fedbe2ba245a5bd227246a8d887022b9fb2cb43e6f68970b6a83fa3940f306290d66eadccd46e76b5046a3ab1d24bbef30ba57748cb0899a0f6dee7d7d0effbb3088a9744069e346ea025e70c8ede6c47f6c54b6f610d1ebcb8f9bc72a348bdc8682e13cbc27a87d2ee71f07e5da2ef6e04b1c35ddf51b7d088260b0e69b9cc714ccdf4da16b6af153a7b2e742f97276a5d319c0e73a1ed93ca28858be5d494f169aaca96b1d7d07f007413223873b02cfbf643a576ea709f2e223b88b1dd8337b188eacd19c6010f885782bf4347edd6fffe2d4b78746c08361513308dfe9131e45ac570ee5e856b4e3b400449bfa1beb275c692fbd0515f9d2aaf5e9fae73c43fb6724a1ae16fae6027c09d8aaf424b21f2f248b729226b7984b7fe6284415f7db13a65ebf9c43b2f17fdd9fab766acae1b2ad1f736522ac0df55f1618c65f4a81a2bf0d977eae855448db03197b0152ed573a56cada1b81a633b2f52e96b8a3c22cb845a2514f5bc0b4de0ace199a68b80f7b50b3b7f7af64f8e2c3e3eaf0b1e7d51dfcc79fd3777df927cb7e52b50ba8291fa80343fbc7b1151aff0c225b80028ac331e59b5491148ef561abccb11f609dcbf2e087a930735d787b979c5db27e1bf1d353ad8ce6bd2b03557eed0dc8c04c0b0c0594a8bf68a21e6c190cb1475bfcab8a513eba034530a608c88c6b10176baa417e0bb7ffa410b216ff026cecc51475bf733270bab65a810a2510a940140348d35ea560ffdfc3a9fefafea977ced6f011203333933af315b1597428c1df5901470a5da95bd4c968ac5e0a08740a276e45a4f903eedbb5641c1968a915a2d2d1a282b80acf3663aa2b51eafd3e11934a787599423f180bbd827e2023a8d4b79dea6963c216d6838eeefb28b9774c3aac5fc7da0c6952c96cd7f3172996ff7a55bbbe274db5839709bcd57a0e3bff705f68779befaa41ad2a80a66d0d7d68967720fcd2ed24ca08cd201335383229fb1e3919aafbe5386f855e6ceb6019c1b4cc46a135d7a5458be12bc0c9d1ed2eec9b0948ac1a742f7b5fe9598fb69371bc798c668708d655d3bc61276018067b28c67cedea0d46044dfe909acc0cc61f54b939e3ba52eb2c71bc51f52c7b16eecd6405be08707274a39b38c61ede47dec695d27ae20da9c0387c0b3246cd0b4d2f8df5cb136179fef8622226ee30f80ae1dc30b52170b31049d31b73289e51413aaeaac29d17db4bf72f7b8ecaf93044eef1a736d2a23fd5637","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
