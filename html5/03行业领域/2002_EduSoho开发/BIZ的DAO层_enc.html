<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a261a9e6cc1e348da268659e1931030855355340237c540b28c40a12154383a98b55836659648a49b50d11b941a9bfeacf05e42fdafc59deeb8616dcefa351bc31f7d83fbe2c306fdc9f21aff84a14ff13df817d8f7465767e9a1ea18e86a845dfb53e40a213bc187cb19912246ab5b9ee69d8168ca1427a1e0134e907bac0edd3078ff15c539b787666432dcee7415f9059682310cc18344c32098560fcd89350a23e86eeeaa783480177a413b306252ea13ded24a29c51160cdfc30d93568557fc7d4b5aed43779d1da4381c8454db3fc36c2976cbc47f69fcb39e0bb03c4a14c1e640cf23ed81c00caafcb671442aa57252318ce6cbef340d6edadda78479018378d6bc6e9bd5e3cf04c17e4db0255bc1e76b1bfbcd6494becae201aac9070c52a27e452e3b2ef37e0f9848fc875bfb714b63475466566a907db93a35de68cfa307bf61de6725b0e09be56dfc334960a5267a36044b5eb66ec18792f8f9e1535e0bd82a7284fbc3866a669f2db29bd5ff6e8d5f0dabcb44da35b82f5854cef49706774a759b646e126a16eb19508281bc1f88b8381c612d04bc9118d6420dd183c8f25702c823968b5acc6e53577b2903ac05d095f8334337c1ba9719ddee287f1bb442b1b88425139f0a463e56330efb393834680ed59e91f6183620453fd820dd20714c348b168c36845213b59a4dc17ce186e62dd35201d93658d6b15191892777c6b3e74ada906a91f7947929b7eb79f5ab150413acc2ddcf8acc6749cf2a08726d3c495b378fe7efa82fda644f87a7d54b7206474abff2217e9341cfbda1b34ad133a8917c8a6e0d8bc2f1d3d7ed94b3a4a5b0fb5d7d020a2b3ca986f310170f42bb0ce2509ce994e5d5625c4b88a58e53bfe994579e3ce7f7677b1cc5cc4ec57e4e3c55ddc7bab8739d23cadecfdfe6023bda42922b9a22d495d0f160df13bdae54d195e118be04cb59d4c36c0ece24c9808eff5daee989ca7c50e05bb361b6aad8edc4ce7ccaa0a8b9050c637af137a4af8f4c99e67a70e58e9ec795ac73861a879ce140001f25f0aa911f666eaf7a37b9e4d078c28eb57e032caf68893f00bb382c1b3131cad04d54f8335408b15ed9ba648e3f0d331363cbbb9de2d605011374595b7b21361c12aafafa9d5c02ee0e5936e6cfc9fb44e3dbd533206596e3a83d08075d87d9a47bfd0e919000bf0c81df078259a657f22491acc559a011c4dcad85a90a4b906833e514c0e0b94a34f6f19ff4f2bc98830b3246ab0b5694b624d04626e7d6ebdae4a893df465035513918ca67ea44e70a1a804a77c1706513e18a5fd82c663beddca68a994e519cc06c195b3992602d76e6db1b08a617d836a42342e3ea257f08ab0638d0120e75c0eef0c332f43ddbc3712de1c38b2fe4f34377daf6a714b7a3e6d15bebfedfce83d83dcd9581e91219760f8a4ee894f548c8eeee07c235222a05d6b60587e0dab7971fd9e2f80f8f5fa680a7edb9414d0cfcc1749cede41c85c363b5ecdebce6f3ebae728540f9a38f8114ad5364d495908233ecfc7e3f38f27eaabb8e1445ea1db6746406e185b1c524b38ce39053f9be19d0542efc8ffd49702df78a079c6d2969bf9923606149cde1e11cd7c9d82d63aa717937f7279f140d067387d78aeafd969b76ace2e81b48ecc5495205113e225cca44e606ada591d507d160425eda5d66c52abf7a19879df2cb517b773d901ad9592b16871722548c28b307a28324fb4eeaccecdcc1ffbb747b663eb9cd6fb28be4572541c5e216ff1c18e68fa267a2d1948e17743d86ecf509a589ee9aea4f00c376f1c9d5e8d9a05fcb950435113f357942476e2fc5978eebfe0c6e54f1c08ecbd375f8fef84530f723f254be0823af1a1f5186dae5554e8715e4a60ce2d189855f0d72a9bb83b7cbb139e92f28e5282f472c681a345907fad3dbb8944a7a5c78cd1742b16950d3354fec0d60506582faa242098b7b0b996730517ce9e18475db13e8bad2316d035952593b608cd3425c1ec0280f9fd9d79004494f3f6b35f578a743e02cec8dbbf414c97951501f8229453728777b6a3ba7bc0445ec04bd5454a2f3d0ec56b3074184d4751e796eb06d7461799167edf7352cbe6e968ecc49fbac6fd09295af8fa3cae14ec27f425c41d7ddba0017e4116850890b0559f5d687cb60405dd2e5d01216ad054c80f007d5383d550cd8305c921190bfa212fa900742c2346c3e5619cfcf4f05fd0aa8e5405901a26ff6cd393a699ebc1a2728af08992c46826725e8d837496fa9ff0f3b9fb251eab5462687f5388b6dc75f18685024bdd610ba16522ac0b1a2e6d48704400bee92c7d15d88b9e6b3d80905aeec6e28e9239ff69763f70f553f5815f023eb948bfde4f571f3ae84cccf0e80ccdf3702308ccecb029619750c2e94d4ebf7f7368915acd304aeb66f1791e124fd3962b4c8cdc1f03c8eaa942383161e070e8b04e0d8f22dba81483ce18a2ce4d3b3e2db06918289f186b4196a8c350c8aac8781a72715a48fd9c34a897837d5b4c653e0bc0377383d7869cc8456f1bd3f1ff87fa48d28651d3cdd963b4e45ee310c48e18fd3f35c218c84e62e5f213ad63b7ed9b88366e2890d6ae00069222f6ae4c01345afb3ced5ae69d8fdc3dd29d832216ae627f7e9d336b373b648e82ac3a11d9a273b2aca94f83b5b85b600ef8c91773d75dfb760dc294caa6b8a3928fc799bb4ca56cd81629c9d24a23d09fd3e7add2ce94db30124b60db0b13673d248282f11db62004337f37260a8b8ec7ddc29e74c85b38aeef98a9bc6071820d318cb10341f73b1f7df3b3f6fcd23817aa76b910a2f598c29d247c4e3e4177c0db6ded8d4568c6664586726e59981b8257bdd085d2adac4a571eaebce09c83abe079989e087c9f8d5c0f829f9fd52c1d3dee8d57319904eccb9f5548ac5f809eda23f577aa7d91d7b8bababf9bc3e2fd830b755d8f4a293660c9ceada3145f087adbfce8d7dab8ede95f4665c626338b91eefdc52b97173d73451a6e607a9509c80b24e365635e1f64ae4b313a987990962e30bc01cffa5cfccbaab2e53451b810528030ea204687cb5c7c455f9aedb79060d6f34a5999a401a0ec812fbee8a7041a05e9410d4008ce98a8219b95e6bd7bba538c4ead172ceaf23eee7da9e62c4e0644b320ca650396682be0f6e3395e8f16343f14cc2fb35eaf161e9bad0245f628498fa963db0ea7c9d7e7f8beaee7d52e6c0446daf64c30f06e9c18725c21029442cda0a49f5685c6a1fe703184e59e925b5afb30c8cc4036e9943b8d4c890334b115257001f5ec014699e9e0913688500d60c3b142893d20778dbac6da3972772b3e54f21193acdb09d8ca36c84c4320c15cba696d7f3b89a255bfead1336e809fdfbc3786ba7f3331bcdaa89616c99f60bb9832817a06647071498181ff4d39f92f16186ba4a7b40e121f8ebef58401a36a5d650b9bf22769a68259a822b46aa61a9062e64b5400f4a39e67f4d1ddde5d41fe7d0cc777f0dddee53faf1f1378adb2832ee6a4ce4b4a2ad38a47d69d6ba48524b3d3fac4fc76536e7f1b6ea9b9552d761ea4e5e9f03242c41be2148d5e8186758dbe0443d16c19e54153568cafba9b504429c983ace3ae0fa642175f40cf686a48ce6e8496f61dc42df8abefc4d14905ae6a814e3261a8d851ca3df0433d9953a13a6981399c20b6538186417e363806f0b9c6272f73fab81a0a26de2095bcf5c35a93c4657477e78f773920a77d8f2d51842ea15a281aa7152f16fa4455d68c8a2e41c3cedc62ccf19e28678ba5149ae5dfd57f2ff67e9ee776127fec475fc5133e21bb6154dc191edd388e6c8c67190eed4da4313608d4e2707c3b41fad06e45ba7dba6449a1c229930067a4c7eb6f69dbf64f2208bd14aec67a32b22a17d35701953867c09ea1a696d22b380bffedded9a971fa485d8bdd3b8104c4e611f22d56792e02196f41b95b6079a3404a2a8d65f6f0a0e935043c5a80514c268fdfc725b8c339761024b9733e7d1c1e2df430cf4c3dba88d3ca949cc95a61701b73b60fe656cfe908256ec0415a5da8858c37904b34b305935703630b6f53ea2e4f9d325a511594af0dd6b12c861f55e60d1092737cd72e43f9026167a3be6474f9d50ba0c35516df0b1911fb250b0234707f127ddbfb800fcbe6935476849247c913186aee03dcfdded9ca8cb977dc01376d5836272c0cd50a3bebccffe45df8d1744d9f4d8417d6f25e2fec8feeb44e073906a92873f8d074eb74d5cb31b15393f210e2667bc7355427d11a52779a90bb464a3324127ed7ccb780879ad44cb2ab35722c0ebf3e7bd9b6edefe72a9ea086a302216a6b65296387e83e23365f13c5d8486f26f7c3d86839114a537e4f7664818dac2115a06168b94b4ff048b8842303eae6caeb3d477ce283cd6539b1725f6c8a889decf22390f3505fdfafb1bd2600ade521e2f47252d89704fe6896eb0681d5fed9417d75041a1c1fd3d22013170835bb1d0cf7f0898890af7a01011f73a170df69684f25cc20df8dfc28a2bcabaae3a35a53edec1eee90e4810cffe03dd34bb6cadd66dbf1bda5da56edf5937c5abbb3ae76f0178e42913cf25f19c8ff22fafcb2725fca08d12d4fb79f0ed06fbd224375db8bfd8711f3e988652a383bcc4556faca8ba49f5d3e3d5e5b16eeea2172f54718a27133448d4f5ca241ee2850962d758eda81da9e6f58c1d7e72e583e582d9c6a558e4004f181df9031e9cb277f76e2e9cdd448a7929a5b35c56bfcfa422a38b147d8487b5dbafca551ef12594ac10ab286d4817a4db6d2661cd75f16d393baceaa7a1f20bc28ab89db74e79c174686470309f73af54f0c4de3fd01f135157c521944d07d0666e916bb0bac393608e07a48b7a035e9971648af34554d11007957d401cc3f129de5b7e48260e470a931be5916bdcd195b05eb963b71ff693fc09b7b10a1c8624e9d8726060dd03513e6ce752f4930e1448f6f19d914b022fdd57aab803806b62c5b311b99ab3ff2d9e92de294a79c36305b6b8cf1eba754a185b2c18ae3a29f78f4da68ade72257ff04a89debb20d92f6c8fef39b3d68770c24cbd1e629a300d2444ab4360af30da1d2af3dc1193a8d140a8972f4b2cdfce366a39dd71d97a29d23243e881fc33d28474a49de65b5a4de3a139b33bbebbd4b9e11ab4a2be932115bc800e5197b7815aeaddb25f721fddb4feb64c1f75c0223088649b864c636ff5ba6709c794b7bc88804c09e8bbd836c0fe99b5aaa236d830042c42bb288a3d306ebc3285eac8a2116b01398c77767f349e33197cb4b3367026df41345f66c4cdf81eb113c65e6100d968569c36da6e9ce07a81f1c24cc53be9d43338c2619ca3d7e3f09c70c88d9ae64602e240f37dc8d541d453b3eb12ecec7445fb92797049c84598672883742d35aeef761a454b58200e1fb2c4d810767014ad6494a05dc0127c0efb510f36e74358f68d602ccdb55c4a3e0729bb16905e4fc409b1126c3e624fd59fff00b7f40654b60a0a0c36891a14083ebd2109e3fe20b4175b4ca212c81a401cfd4cede6a1b7b3eafd78f3740288c730fec6762b6c6ad1fc5f4229bef9b07a2b2c016e99b1f6f1b33f279553694316cdf4cc0cc8b25a394735703f11d805dc72b1e2b7dbfb1e71b2e615fb099f31f91e892b5bc165f5510838f2436c1ae1ae1a6fa26ceec2bde234362b0e1763a4ec95d2ac128cd241bae54ebcaa1313fd49d27ecda35ca7c2268040ff4e44f36331d454e4310258cf622e078cfdb79c50d367c76a8315f86df11c708b672ad27026754475f41a3b787916ca2d9ebdd8d75134f27f82546673e864ccafc6d869b64672791d050c8887f29f0b38b823060629177a2dfbd9903c167a55c43e2e578a63f2fdee012453b2f24dc206e7956c6dcd129f16ae0d10dd3ec108b4876fe4aaced1ecc85aaad5b9ddb79c57c0bb15a73951acb25ea9ef7775ddd44fa1fda7df9ecb60801393673a2c3672d477b90e8dad49b2228ee60255d299218aed0edaca05f948041a00541b9d9441feac9e4de0b9c536a1fab38bbc7a2f3d6e4df5786052a2c7975ada27ca3766dbbf6eb506a4571c6d25f51b850ae814999538e625926ab9b45f00e5a41cfd44c33c2e6f38adc2eac4019adc4d81e7746270f0062e8ad31a15d320f6d37030b19727ee666448feb2b7f9c2eef2a6e197dfab5d35a62f7d952c7c72e0c5d7c75fa7df4d274bfee05f74a132308545954bc71fec1daafaf59086765ea18d7b0e3ba7c2b86aa80e370a52379872d73193181fa4ece2a2b0ce487ff626369074d70dba319fec7da481a64a3be1820bdfc26d2798eae41f58d31ca6e9db181ed8399ab12f74c4f98fa25594cae63d1ddf28272b2ff4ce84a0f401e857911fb17c8d5b617ef4300c02a30b59a1de28619be60d245d3762ed7ae57f4413d39a7868bfede70a5048cd1eaeefd27347efd16e303057669d44250a6f6aaa6864a5f0d56c8cc4337b06e4a40aaa25a70dc1a5866bb0be1ef42dd96fda52d720ab3a6d481de74dbd4c8c8a896f41de08d3a8476840adb398f73a477d94f8bbaf54ca1b8fcd838a23588698a3361b2205ac82d0d4ec3dd53a7113303b279d62e387925b22e89e83ae55c028c80540ecb212b232c12905e6cd9c87bad34cc490f1b5d6853c2f239babe1ebb3331f0390b09442f5af9315e6cf10aa84f1c42854341eb7b71c7ff8ccec16db2db14d111dd3f0d05611a71d5c4b0a116c4e826b5a62a2a43a3b472ad58db48298c1babb54f1ce03b16f77b89fb13f4324fb1c9c9a9370a36eafbd5163370b3a553c84d84a5ca2d64f7a5a59d527bc8fef5341900e3b032f5436bf5d8b6642877d5bff77a26e42abbd9b1646ed82313906816ec123d730c9425fadd7e87c2dd866dca6a2d915c5e309ef0e240e8037de403ad4bc1a11732527ff23e6167581b78277b0e3174f93841b3fd0aaf2f5c2f7bee211729a7646bdbac78f90d4fef8816146159d517e0ec73e8ef006d0c51a3ea44f46b1c9ec10d51c7d5f7a32c064155c4f730dc5a74631bd09c16d5743a6b1994aa41cb4ebce86e5b03204ce59628f2366f3248164761cba63553c4ee466a1fb7ba09ac6c9a6e530b63f697b1634efa920578bb9b34681fc575a849c46068ec1bdc836b28c8e573a762ea70af58d647f6ee0d1e0218420b98cfc6447cc5e7cbe22dcc37971e07b6b450ba8bf0c7ebf0306f11605d8fcbb8e0e16cfaefc655e2e3034202c100389d1961ce62f9031d106050521be0bf99326335597fa081680d71f6265106d7671de34dcc4124ba718fb7d4e7fd7f7566b21a11a7e2a3e30d119bd5e939bf776f3d8fc639b5b328c69acf40ff69a59607b57aba01e8ddbe7b1362c2996e631d479310e3dbff49816c342642e2b5b17245e60a02b806de2a7bb23f2b9c83a5ffae9fd6000249b0aace670a326e1f34c1618c72e5cc05235dbd15fd797f6fff2ddc855785710cbfff41600307b251ac98745d2dd707a01e875a8e7dcd5ccaa8cdcaf087e40c770e5f71b949d3a53fc4e4e71a2bb8ac71c3cc85b39dc728f020279279f143426151057f93dc7d483865166b39628f4768f4db1fe6b9ba3fd1c3439cdea4cb0a33057cd7b007f88de0db42c7ea9a1ae58d9d1187efc825bbf94155cd193d2e04e613124e26b3d1bde4e677b1bbbf14055fb490be500cd7b6fbd710b44aa23b309cda1fadea06cffce26ce75e8673856d53059bd0c5789ffbb863853dae7cd1312ada423e3ec6798996ac74dcb722ee7f155c9855ecf406a3ba7f09875cc440ee9133627b0819b4b9f792c9ffdd59b950ba7f002e3b96431657e65dd1d1348efe87c2baf4ed6d2f39e1f36503256109985b47ccfbb7df78df915a555af9ee07613ec40c564c494f4d299617fa2275c84f0a52af1b576a2977d14b86f1365e251dda2fe99d823a9666f35e6da1bce7b1858537fe8780432fa5074d9667cad966a3924b564a5a593a5f9f8eee347d5bb97e4f9d4191ed5d7fb93dba09f97075f70a4e6292de7d19a292e296a18e18bc596b4af07e360826594389d8a2a45b47c1de7c66d6c2f69a99536141be7f13898dc0aae2680c6ea1d54cf537e7892371f06841a231478df7c61136edd26826e621f5be88d4033a709253dd6674316e1ac63da9d8e36daa19d14125aebb3c4ad423b7badb29c24f972de541d9aeacec9fb31a3743d006bb10bc228439418853d324c9b9f7fb1243b8bea1e3f9d40b9ec0a18c86d79243cfbe613b99f70559b2a0632a47f79fa1c38c800b96750c628ad508f9ecfd5625da35e681504cf0ba9d19df7d62960bf5497f896bda3822a4db6611591ac246ac63e77a81e050a4917f30250c3d5f42c5ef03b883ebcc83b73d2831b2bb4bcc1587468ce134008e0eb4d769aec89829eb2e19172f0b46c7d17567f9998680411429fd96e6005040e09d393b174e0fd2dfecffcbd13c339f0690713b2096aa6771a18e0c86e50633e90709535ac931321d17f76001d2859339da19811de6a4fc25808f3a18b5d12c38d6274585576a93b60068b4d34cb515e0b6d19a9e880a9a7b4deda297dbdb7d55bb6a2542e204bf79244bab5683f846cdffbe43ff0f224738f9652778b09ef3bc0d57518f5659574501b427fc03c6760b95067b10b3a315a2a44d529565aade1c5b4896e9451f7f886687e68257c49b2778cb8bd920924c9d0735185c89ed6030c8f78d22c25d4079f88adcc4a2e95f05429d0dbfbe4f2c8a43da729cea58c764d73609ba8c8d2ee0202e4b0449d0496dd73ab6cbefc086ee5bb64ac22f9d7726704a91dec599042b9d333cda165de6872c813a6d146422ac22b243a72d35ae7be46f853e0c26583b85653cf2ef5cc6c8a7c56ad649ae111faf4270eda399e3e70a612783953218e229e20a309c484408afc7884863284f3624b1b8e6fd2ed228b6ee9c8985c06b01ed519fab0c2d08ef960c6e98179ed408d958e1fbac9583ec0188372f669acdd458986cb2ef62868a1eb3cce3cc51277e97485a2b7c64a1b0e32855a1c54d969d0b01eca246a02440d5a9cb93af6034d7e0062e3952a4e4f0230d811cd5d80c781b7c43d37a772a2176a8f763ce0dff897cd78324e6b8a8cce2b57a140f57aa91a62154c7f637c6399c8adb2fcb37d8111949d21be69587b02e53a9f2813facc6916d318d981d2b320fe6d5379c7d2711d4eb1b0db4684a24f7486039b9510f4b375d68f0e66fe84a116b7c888c046dc1f14f62018b706723908cba3c2bcf23194897d15b79370b15b986dc7d0136c090b515d3fcd143ce66b5536619bbbdb6836c31c862326d65888eea8d33afefe1a6813bbdebe70f1183a451ad046a71556cd7890149b45e851c999346e14d1ae68ecf07a5a1eef6823bd850b45491f039f36a54099522c1644a0ad7144b053e17ce74ac2025640e300fc4dfed3a2854e1e4337f5ab464a543c781e11f80cceba2d2f41cdab41d89d0faaffa8ce0f0bc7ee31c104e799d2caa30a17265346bcaea0512b4d25a05154e97906d6ecc56a9665833c2a31728ba5c6464ab63b546727da69d96e64bef309428403563e21d3443437f2075315660a18150676e1c8a8d9c2d03ba8494567be156affd7ab8ce1b46f545888345f6672b6d45674e964478d53be9ef06b1b5366cc980c9af9435ee90bbdb6b472aac611da00e75d3457c8ddbd8b8bc80089e4bc60d66bf028c9635c3974e1caccb8dfb0ada7584c60a2c81717447c8dc0f0b38b2d05d4d064c51e308322357887495c631c951bbcb668c514fbed5f01f45cbbf5227347aa49e45fd2b9eaacbdac37900e262ce21864c3649fc96fab4fa57ff71c10e9ca6518c79140ca5b0b6e2a746d5a2f48721dc85da3edfcdb1a43ab3aa2c8a8e496ed074707dac6b3031e52e0172b60164234604002959ad6857ac1a00fbde34756f5b43bec88b14bbb1e0bda60a41e7e9fc78e2203421a4a30b147a32c524a28e277b26e025424428b1c173ede890e664ebf52bc22b1d6184f8880edf09b438fa5f5231fb6fd2eab52f09d3379092fa80b21a9096a9e7a7b7ce480620b9a10b21019657cfa9b43d365ec099dfd65de956757db03ebd166389e85e91a21fae132e59ae3ec3cf4a4c77e1e67896af82c8f7dd9caced1ffe1099058fec5ec8c66c1d5460ba539ea47e0ca8649c77f39f21f61a6a1361d800d1abc19bcb1d53c85131bb777571348cb84961731de7163e634e2f35d5c4a2e814ca091c2a2a715abf44224a54e1ce7f96b696e0b181aa60a7e7fa02e8c141692cee112337907d89d825128b422af60e865f99f817860753cdd7e0628daacacf468c66b00ba45e698035ec872a62d932a6f1c574f3bdc788d82824db5ee225308eae4268cd9aba2d5761c1ed2f8bc09f3bbc971fe9848bf3923b87ab7197df62a12bb923496c1632bfa8a16115163b009f5e1aefd58d67e49e7b1513954e67610376fded09e07bcd0469d9aa3f0f492d57c725ea0fc9be128b52b03ff5ec6993250c3925e2f57d582bfed513dffe16b399217c29ef54923f9b745dc4e62725aa86cb118d0fdde1e8f383dd19c6d5c1052b2264735a3da779fec4048197ae57bf511a020c8b339ab7863d651f4e5880f1fd5804bb633cfa3738b549554d96840d1eea31086863f748f7e060b38ab54b47a687b06639342c4ce86b34b31ce1a1c434bf14dcd9720ef2ff7b4e465c45081ff3991e5ca20de62b6db2636ad5827b9a30a6d30779d0bb7dbd7d11c9059889f54fbd547c3f6caa484f11e215a2bdda764997635f2e99048a5c3a482769fe1173f374f2db5e25c7a9eea4efe03f95839e10115bdd51362542877d6acf6a909f517f2e06d8f00e705a120d51c0a9e97596d4b9c8c3bee6c3955e785b18dbf7bc5966f94f5632d8e94b36fe5b2b49beedffc12365a6b9ee0eba79a1ff51e1a9627f7b8d3659b40bbac5b73cbf5a7576e93e4936cf4a29a1f005ade5957fbe36554399edd1fc42d2f6e70d481e135dc8f512da443e97826d17fde97e416723b6a7fb38758fb52d892a4db6ee87c72e8b47277f714a30a688920af525aaff32119ed477a167cc31774602182a2c50248041d5334d3be91d8eca52d9da0b1daee6586256006a050a1b86ce0942002ca4d7a04f21274f87a12b29f6ec2d6afa78e1ff2971ea7315e3e062aca45ea9457c42af98d6149f5819d8a3c91d4c527b645e39a66780aabd66525739276064cfde2ef4db6e953d4f511bf35bd758dd246bf5093003e12f81d751e0d97cdf0a585cbcaecb8abc8ac953fffabfc8cd5251e57d4fb24221078c6c49c4fca6b2b9a45343c16d1b251a9073fdeb4307a813cc9e53e2700f9a53ee0fe4f076f2650b7705dd7081fe51d884853dfe559c494a4db27d6c97d4a02b6806d575cbec339ce3c39d0f48cb47ab207df4c9de5bbca8dfde3e3bf05b86033b16d32af49a2a30c54348a061cf021f3ac9b64a734c2e817ced1537ba666007896744044075cd4a2694c91afef8a3028ae48fb98a46e6b91d0855f9f1c9f58e4325cf44274ecd1beb2f64650e6bd5284225717bbddda37efe16f32f928b6169cb2e76d07667d23a37e5fd1988173a1191ebe9e38764fc0aac28bead732d49707312e77094bf364add2ac2b757cd32e79176e721499f34af71dbc36273d88ed89394d020ec77ad83f46ec662b7c31ec50ce65358c017bb94301e019b79e5270e165160626d41f2a62ce7c64e13858c14c7f6e6b4d6138c46ab2ca97c9008f9441ebf77a7d8fd579c24fdca7e8c041c1dfe1632eb5b8417d6da646ef0699170e53465699da9a4ac72017377f0522e71629b2ffe1c0d1b84346b2f18efc9a5fe2d21eb25be491bbe4b12fa0fd04e415823e3b438cb9509b047dcef6179af152c4c0ae20cfabe8db8c0abfd4653e5b411b935e0fa1af49e1ffa51f8cded43078a851316a26d15d1d6e3f19ca2b4a19360d89d550bf8e8cedd8e73e84d3cd5738c811e30cb3565e9453e4d7e3115c39df0e325e84e85e5dc13390f2ba609e987d8231003cc2862b256035e4c2dd0f646e3568607e543eec3a329b903326d8637052c01289f9dcc6df8ac56cd618a5914c5399ab04126c6e256b8d2ce045e57b1fb63e754836a30a9fc15b728510328dc107717ea02e09a6aa4e71094a577dd7866d687c91bc9ab5eada7ad5f9aa27b61f1b5bfac6698aa87f35e0867ca2c6b5c01668b6177b4c60210d9a1a33172a379342f41500686d3b8da38921cd50a188aa76c7cc2aa6e6b65b5b7a102853d0fa18142821ae0b6c0a26dede9b6aee3dbd04ad7e9f2191f528632dc7a8c931c112e4e0a4db2d43849d0612ec280c6d0689ea40a9d3637a91d5ad842e7d613459e188d4ce85951b6a4a4512be0c81985d0cdc44dfe76e97d71b7095c6e33326801db4747a953b5e1657540b30a0694e0ba69587fc2f33e7f64e8de33186614a2fc26babfc5865ad43487d22ed505188192ef8f729e38b4db7bc96d1495a3d38bdca2dd33c7d736a1c56f0530d28a3061e294262db9602a995f57f70804304f81f712da2d587378ed84d9cfb50c4974baa96032bc9ffc8b0a870bab26bef93f9b4cc603cc1bd0d731696e9e0fe58a856357a488524545112033729ce73871a9fffb6fa7511cc2cf269d40919e2740eb6ba26d2774786be85422aa41274fa000bb99b0cfe8f3671ca35a4af4889e03dae3ddf465af377922b59ac82b90b57d52b0f7a3059dbc5dd26fda77a118b1e097d3e0335880c191a57d1fbef94658a37b7d38219c4cea9c56eb84086cc8fbce4e17945660081e2765fe841f9546ea796d06e29640f2058f898e497354bd0d1cfc47eef412260dd0032f8b99fa17fce440f035d00009cdedefa017bcb36d1883e65e7468ab967837d2746d59ba93f657566e7c15ca246f284abd08d668d32bfb0519b438d2394a17a33c25b348f656c16b645c47d232d21f8800a6095ddadcb1fae9306442501b150f46e71e9a07c13d781ea7892a402c4a6ed45c5087cbd383fcde49fa85c2bafc9c58a4a10949e8b17424365f349b518c3148dec8ae30f018a6a29e965762c36fe56d135fd771d9b13d421ab72470b6a10b7b1345e39c74f542b772016a8be3589bde4d8ba13e806aad1f884cb6317a234ed3aee3dca5f4f72002f4347ac2b1676051b68228ce1ab41ede8f7f8655f31450c690da3c02dcae981d64a2fae379639ce75d21baf3ce94b3300d7f12b2e32746a7bbb9f592c410187bbd09279bb62726812cdc3d63809beb4ec6f86d7d230e4e4dad027a21ace728f428fd720f05e7d49432e2851fdeee82b38c7546e3b951312ab945575f029b6e80b3fdbee4d6d71ea67795c08660746719f5f8e7c1599ff978fd4f4948c3be677fddc40bd1ddb90e5a872c2ea487319c9691ee7ef5d0a951b6604daf43ca660bea026ed1ca07ee034dd7153fb1edd28ad71ab61cc5f57f2301be520c47e21591dd09c2d16adcb66801f9c72d2be826abc294d4c2e5201d2c96ed21d790834fd3072f7514221066013c5124072884d8728be27f026c6bd7ee7075cb25d0d848ead1f208c18e137a704429501716c8fa4f73b3176e684ad845a5f310fe4ef41d44071e0525ca58adbc98200e2c4a3e14200a57802a476f07fc26d63e4556a7feea4b0e1583cb2321e9d278091eb137bb42fcd699015510c96f0d07453fad620109d37b75b809b5a2ede0cd49d00050d6f30724a76cb267d83728467ba8a7b48f47c80896df015652684f032a29179c0e818f253b3d609d6ef7ba2ba717afd85bca1acefefb25918e9299a283c6d1701834003d5baba9998531e8b359130bd6eaf4bd06d7da937a9064a9980a8e7fe30be5faa866a88b1ae9ebda8c19482265c1de4c44a876c8b44a82aaf48c7fd9d81837fe90c436c38340ae3b27b06efda66e00b58867621a1b7c790820a89264bc49fc30888b74ced2cb97e84ce0f0832f5653b8bfe54e8a3eeeb94bab9082929cf9cc27c228ac5f5e72c2bd3a4c8ed59164bc0a1f0267514e9b448d8ce18e3d7c594c3b66665e38215d36d4bfbf44f3002d5e5023c1612315d80843fafc8730b02c776f4a6145dc22725c266bad81836683cfc1e6c6a77aa75bbccb97482a135111be90fa4594d2b97f971b7a52425463dfc666305909b53e2404c6d99d2b9806e058775dde7cffecbb33d138af9119bd3f878b96165356c201004dc608fbe5050aa0c5fa6aad23aa0d6e9f2e498f2659990f7685e7687cd09e8bad7f85ccbb88a2579660d499b42d97c660b1ef196cfe9ae4ee751fe7e7882a605cec58e94370d9dd059868daeb0ae142be4e64ddd5a119588a5bd658807d3fa624536c64f42d820025336761c347b6ab1fdfbb3f0b9a37d5552a161d6c70557095af7694fab00dcb2c4ea63163b856ddcb279be09b30659d75f008b85163d55b2bb99a7c764131b269cf5b97d07b41c7083cae003fb9a2ae94378dd79992e0a08034a558d9559c954347121f16f054d0cf3bd799b6b70ebe4aaed0ff37090f8aca139e5cd5fc15af5319b16d230960520eea5318427d29df7bf42383e95b1b48b54910372a39d4799459d08974cf4ef86631098d87b79c596209434e5ea217141fc0507c853fa05b54051c559d1e690d0267bc0a0eb091b1663bbbb8cb75b65de457100c00b060353d5e269d6c32cd4a61905828819b07a239c371a3431bf6c39338a106d1d2f6b3f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"539f60c8409285aa19d9f5b148b1ba10"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
