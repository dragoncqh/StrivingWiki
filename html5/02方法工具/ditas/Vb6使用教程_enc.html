<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4488ddcbdeea4c0fd0c5e3ecde0502db822fb4c6ad7fcad46d2ea57328ac958ce8fe0b0cd4d9f57a2b9f700731fa828d8d712ab62d03601342f7ec420ec6131b2f66c16dd269c69cf0d659cf0a8299393617fd0018996389a15da070a743a00f11c7f245d5aa703de6eb1de3f0a5057852456eda816b75d221952ef6bf84c7421cb525397a0c6485b141d2a1e28b0dbac4e0716a074bc50aa55997b79ff2177648e57dbbd0ef2d9905c13bad668bd168d554a0fdd418ddad2614a4bea8e84e4e13b81ac79fa494c3b819ef1fade9e4eeca6eef713b830a3ea4df2a5fab093a6932a03770e02592e2d7af50aef2dff343d501afde7377e75bd5b47cbfcef20e51f867970b3e4dbc9fac3e9e5c5b870b35766c01e188705f404f20189116d4ea1bb72e57e278d2b74f3d7e85654c3cac41476e56c639e2c19529defb3c41abadd913d938bbb981d14f151c785f53d59afc783e222111dd8c8a2a6d4e496beae27b8842a5210ba74b81704dcb9317f402091dfca75b0fd89beb27c0bf5f595aa9042ccfa9cf40a1f4f8077d9f02ee27304c3cd0e497f2b6fee3c012ed806074a43e8c6450d8210803d2b8cdd487f61cb77ef49c0b41255b272751f0682746c2feaedc6de3c1833a17bf59422477da7ec62cc428768f638cfd223fe606ad4b7d084b9d83470b0dab6cfbc8e2908a1a00be532e5ef27e96944b47e0d7d06399f4c766d2dbd6a34420bb8884f11f7e6d13f370f7eadde058b835de774d39581c98b344739df34fe69fcb438ebdd858c7f1d16cd3139cee94fbb2ec25c2ec534a5880e24c0855ac7b527695110135fe50c4d84b30cdf7403549330278a659e19d97e260bb3c4545f033fc4f9d8fb386c4b22df1169a0d8e9c5ff415626b796b090ec270400730d2663dbf0e6e4b70c45451c6f452abada95729714c5e4fdc991ebff762f139fc822650e0b3b2036be32b64d107166d5ba900752371f33b1c26a94dd8a057227612bdbf70173524e722c592731b6b52c301d7da0a701d3c84288f2dfe24a2cdf7ddc923c9410416c5b9d4234ef7556d5f0dee52e0b8a42e149a49620d2ae51a63605f1b28bd0d59cf10d65de35a34e2917860beb3f8c78445fd09f99fc21891fbbc9470fbe96aef6da2483a3ecfe88ce6ec1b2de391681085f3f2f2bd66c65b6c126e70b8038182196d3569655541c762a873c7b572725427608d8808ee31b4b366b2e6d10d6b1c53a66bd8b04d75c9649a721ced0d0b2e87df47b20696f99895f4d22b24aa4f71ea03ff91905978a939eaa43aa33e237537b6f2fd43db2cc2193302b7e5cde810667c084fa24bed02b0dcb9fb664e7fe8f0acea349b47aef5a66a6357b2cbde798df2c47080354d6042371c08616d30a8b3504ded0cce332c9e6a13be3d729ffa7840659b3dc12fb1365ea62a0dfb570b8f65c8d8145d9357e62d88f3fcf76845e13bec14299fd327a772cf1e4df53cc98bf8368a0d157a70692b22b1db6b9fd136b4a171fdb75e58096ee5a118f2d4fb9a98ae133f7c618b99c2fd4765376a64a5df9180b28749a8a90cf35f35b1571b211b1a54d317b2fef59c9f0f329ebd138b8ba7a25b313176f29c401977b57a65379fd5d2094acaafbda3ebe3a8084c11223c06ca6e6f203acfea4403b4802334b980492309fef2c545e5adcf5b79dfb2e2e433def453f58dc65a8781df0abcc49b6140958cc74559077d0ca1767e4b4f865a6ac673381151826691bc9e349cbd7083204b83d92d8beac484717085bac05ce6235950d4c33da2bee77732f84370137ced13495f1818f5d1581d0bb16b9943ebca1e9183ed802245f47e6e1fd7707ef6aef4864f67eae5aaad2fb4cbd46057547eb3186956abbe553306cd1f321d08a0707f4077db237c93ee47f9e7fd42a7a5dcc3a24f3cf4721cd4009f0765419bbdfb5a6743042eaa109b389f64438e8ad5047b2039601b3583256f304703a46e3da9e0148ea4db5d1529638a9842a364946a12c2a887c6551a6222bfed0003cf28b5f7ed18f81ccb9c5e3deed2b6232be41e82de9448d5299cee562845eaad1d1f69b38f11354c037e7ee29ae484e9c49b23dfb937591e3a75c6389646ce90651ffac65d651654144602aa23c9ab44b3d885b5be13249be4a67a951317a0cebcf4c5e2ca4959fbbc7476bed9922c5ce8316c575888095fa1b02b88f3259a099d37588ada7ff4ac5932975534ba43995542ec85fe8a3ace51b4babc96222eb8dba9a1fbd2b7658d07a9b99b62f1357e306da32b4a4fb2cdefb1bcc9545a996b342d79501f5c68c35af58ca4a200061b0ab33c14e1fdc7d92a9f63379ae5bfd4d3843973b9d7ccea1e42b84001c9333fac4b47905a475a63cc5bd537f02eef48e4090e848d82ffb4ecb54b584e8c9b356cf8772db942063fd2f3a71e11cb7435360a0efc4ce7ab707f07fca7a3936552898156fea545db9fd4e9106da8a8e9bed241aa99449e3b77811975fe09ae99ece3320a6858ab3d9a152d1573f174d1ca454f81b40d4c30c64e2749744a7dc8af9e33906a3288e880b06ecc5a6892b8e7ad7dbc90881eac19b363eacd4cbbaac42ba63efaecdc8c8ed34254dbcc0b62c0b6497ccd82e6382311e0b59b91efb7b4adb343f63f41edec24d6dfa8284d94c76a5524369a89b812aa28d8190251c0266b16bfc6a48078b3fc7a60eade580f748abd909608535f9638490764e637c0ace7d2e1d1230af92cea7db1ae8a56426acd6dd6c467a47ee389eb694de496b629ce75851bbfe96bee4bc5d524d83212c1e6ae4b28dd5ed36402ae3f6ac591c2383148db6de245a86387a6553278b0b42f80841d04f8317b89e91bb6aa5454714f7759600229c33df25aeef2ae31c73c8ac78556835ff77520a5ec50402f1fce7a1c221fa4674fe188bf5d181fb5722eead7e4176a55c008245355e2e881e893c1a3ff53b69cccddc6fdbda82cec5429f0ca8705c996f8777def4ff0beb7a59530b54e81c655bad270716c980438d1ac35df6fefe97b4b990ad3dd9600963677d32298e7784ea8472e6c5e39f96a5b253c3811c53526e233a357f364997f58d0f310520f26a702ee20276441501310f483b516201cf976790f532489cb207b1af2eea53afb783227d749ed42a132068f76a1150084de44ee3ae22f2f98c6589684de8d7c9f8de35e64a1d53c3d1642cb6d6bbccee796896f1e0070906bbcc41bdf9b3710ed2c9defce0273bf9ffc5048d45dad117559ad9d8a4d1275fc93b0f6162a580786a3f3819e1da7c5cf5e86abe4dbc2b1345f44aad9b2dd5447ced76eba988f9df7639b3ae38897d52b4187557be952cc92460557f6bd42636f67c4c35a69f9ff54d69c3b85730b59960bb1e963c8beaa927820de46f988a5bc245f5e692e52bab271dc02d2f54f11a06bae9deb4c25803ca7eae5e21e4fe2415549f160bc7fe53d23e95d0a9fa5ac91bd626f111c838383188936e5eaebb4d03816a04d9fd56d12864d51bc6f893af8bec3d87121288b4688051db11a8af28c6773e8c0e8366112be3343b9925f6ed5fe6b2ee82390f79ad42a15b775452113596d2cd99a461fe7092a1aeefd9f662a7f9c29dcac154e599d9dddb1db0215118e9993745e1fe2f46b9a20ba162509e83c59a84e7e444faf84186988d396a0bb6b8d7cff8fcfa2fadee219abcc854b69c07f435c0697cd4bb765f6a174f28008e65e21a50e752585c45ba0be452aefc81359da622c6ab337cd65942ff441aedb7f699a1c3a157cdeb3d0424202200d19f57ca6dbc3af92a06c4d4dbf93987aa9f087b06490ec1414d1793bb17315e7c853ce0c96eafb237ad798bc9e3883307d671f23070235a112c1bca4fea26f844a6c934920e6d5a34a07381592e471220bfaa6147706f45f57b1dd8898f0fcd1c657cf954c9f13b51a661139cc0fea60904677d023388cd5150734fabdae8088ce2997556f96ba97e87fbe1f949f51de731d91e6efdd591d305d09d7abd6fb61ecf5c971c5f860cb22491a2897e9e72635b6d8420d5c08fd45141395f0bbd9bdc99fa91827f5c10f2dcc02875c39291eda35b4da1c02c8a3af97e7a3e259748542dc01366c04944906f7888c689459c8b9e1a392a5185619448e009667e1cfa61a2514700a9d9cff0aa8e13d9a7a70a00551def7d75de635e7c4ede85230e554ee654b4c8b596dbe31416eb387284c59364f5cc87f74c9d11772f6788885761c149b80084b784795d4d0a037c6d78540d5d86d4e719b6abc9538fa90f620b59f86e0ac519f74e0a5a62ff88bfec33f6afb68e928d1e1b6e33edbc170760cd2869fd2500c4a9b353d4bc000d404358ca9ab1886177bf50cd8431819a38a6abc7ca071e4134abeb9c388144b2816728f0a2c1f3f76d654ff82176cd1b55dadefe305f3313dd13059ce988ccd9f08396d04b7c1eeb447d602bc773e4738eaa8c26b7c276a8c301d3e60525e238020847b98cf261c7ef09efaa91d9c6673c83c74c717f7fb7aca6ac13541bc5c82a549d1b5b8743d0d11dde5c704968632ccfe9119b1375709a1271b71421440d7db323e4d69a81ad6757aad86394c7574d1c0143576e1060674207a64f443fa22ec7d729b6a041a093a8a3e1e3d13249e9eb2d2e158893d122aa548ea6b18bbc5f747d9f68b89edd00c27d5c43d160fddf486753ce14dd85c77421e2fdeeef6bd2ff1b3ce6a98f6bcf967d8e1779bd60c09fcf1c39361a1bd12bdfef8ca6ce45eee07e2c6328d998458884cbe9ce8d3641bb5e2ff247ddc432d1cc9ff141e1187b8e0fa1b19aadccd3256935678814e9395fcb7001b7d2ca6ae16b9feea35f4ef26cd7f24986a184e0c81cae60bb84df08cf2683af485def56531930b9f071a3c92650097a1aedde278c4a8a2c3d998bfa764b8f634cd8ace68346fda4891203627d2c02a52a2b8985b97daf86d9aeaa8754735be47618ac0055bd7f8da90bb8f71651222f3dffe88a45b7325f9207ae6b7ba35abb0d02e2d0d5d29932eef1c6cf6a6813bd3ab08f462f7ac8dacb59c301e94b287ef04b0c0c81b6cb2a3d9c427b17cc598b8207c84c1ddc03942411b56d5c3e42b81b6512ea6adbe2e5af1f1136b41819d33f79323025210a99afc1062455d6f68bcf4f9c496a8b2f1eea5f8a21b1c2103094b44d2da6a8372fd704559a85a4091ab8ba0c7050bfa8efe1b8223e24ee2dcf6e3f2a4ec528d4d6f9e83b8171b5278554295bd3963d55c1ecb460a42003080cf32a902ad14b12f3c7ad8e7c69521d69a083c7ff4f061daa8cb41a0641a5d8308b561454545edfee3c2c233bdaa5318bb9351f490ad7905eb3dc5aee045408966130c93353c59a61c29ad89f0f307a8e5dda5a58e4f4e441fea93b44d9b45662d161804ed7f940a1681aefffd42bda1f6f228fe6c1a5a7fe7f018296334d48164bbfee3a9b53f796c7767096ff94d2014f9c8f5ac58cb863794f421039f7be3fec290583cc00e6204c77b300f39486fb05d65a185945e43dc0034cefe38fdc7e879c9a0a160e501cd5686043ad5188abd9ac7c658bf4647c9e1703119664be14bfaef25d2c5f5e140b5018b6c1a202e4f083742777c77d50ce65647850aecfcf237957fc435cee8fad82ad549d846217aee6e82c2d73b87c2b5ad2da482830f0c83f1fd507dcc9df5ffbf4805c10c235df721e5d761e72d520465cd4e620b0b8c3a8bf2f6b8710446e68ca2fd52fbccc220cb691086413209680cc29cde7d1b3e7ef87c857faea423a50ad6ecc15f65c5efac8110ea513e510c313016e3a8b17464d0c6fb0438ab4025ff6227bead64e90328ca3cfd2a185133107850eb6e5ff3f3368a7cbf770f03e3211b60e67b3f829bf8b89c41755f7e12b2b9efa189a128a7689076475d4a718ca6d051492a6a62eac5a1faed7733a8beb45faf49404eced542cabefd8ce9ceeb71b91cee30346852225f55a8ec3a3f03beff2da736b90d8cfbf5747a6874f3e48efcd2bb394cf1a9a5628e1e8a6a0e780c729c636d3b7decc86e1df3d87e9810a91ff9ccdf6980f97d364a9c611e6edf9f7898ab36ef902b80eb37ea9761fd5118d075905c8392570f68820217973afd0659491e6c8783b657a196cf564e4eb8d467fe32f0bb0187a3572421ccd42fac232dfd3f7cfee514978663b488222c65de62b49449b188dbbee63702a86b03a027118e1609e0ddf0c7fb8abb7fc3fb3bf087be853cc1b7ce20794c16d2720677fbd7cfe8f2bfe405629c1a98fd32fad8a78af7b0d136eb194ecbc7efe3ecc62c6d88aafc1d13ab36cd02cb4419ad11674c9f8aa60599c21369cfad4c732c6c85409c633d783ed1d5784ee5e4ec8234aec099aa41fd53b7e126a1624bcd7185cc8d8e91dd24606961b890f5c59b8d4e00ce2f0fa7cc55e67660ce7884acd0eb4ec8e06dec45353cd42302945d3854d40c4b73391b434df93500c46bf3fd58b80bee300bad8c95c4527a16e4c113e4e5e8023908ea36889699daa028f7700e1a190e258c69a06e85e7e21a378b259f9d8db09fad38247633819dd4771a814f09ef7be8a4b1b543b714d34b8b9df64f1125ba00b77a375e1185c404a98cd545f99fb0bdd165db72cb03f3ca8fe615c1c128f334f4887499ab411cc43c5d46e5ce34cb812e1a9bf023f6c8482276e5202c957b08c966f443465b76e908dfdd5bbad7a15ecf77822bd2235989b081fd94e7c83baedb760d9cd73a452ce2cc5ebfead56f95d5f2e06cbe40b696ddf67cf542d2bab7d5ecf8e63808aff4b52d162a1eda307c3502d8af7bdd31aa0cafa180a8755f35bad2d6553198dc9e3a366f1c080cd0b4d76f2865d30b5ffa9a2e9dba230a5e3c88aa74bb555194a1e289b5f4b97f708890ef7a988bfdd0136312bba91c6afc733935e43082c976bf39a14d635613c08f2d9d453d60ddd613713d016557ae624584c910a04efb783826c8a8f8f3201330159cd56b6eb1cc39fbb4a54001abf5f439d07be0cd4efc857b679472eda219e64719831503a6ea82007aa7a7b90c5feef15e660e900d5e815e02600c854e19f99e1131bf4ddd78dd169edbdddb7bd1db097495e735acef010e4676e01db49c3de9e5183a78d75d730825ee3e8b4c5616337e3bdd8380e2a55ec1225ad612de1baa1c319353391fefbd18192a3c3114e5c4649c8d39125b010a365f020a4241fd975fd7075f060bccf4c80500f538445bd43316fc9cca387a340131447e6257ae446b80f0ee8e613b9f654386de315031aad2546d022b1263ec44863630098309442ba078e32ec239f35b3081cbbaf23eb5d1497f05a411b3715f7bd143963f366f1c3d588c263a18f727b50a79a4c44f5ce83bc8b16bd84f1da7ac9ccd033a08faf5d0b9012ee95ae6e9ffc625b1bfbc6790c729d141eb5926184a2db9b80c55231f0a07e69827cade7e91ae7c1f37216e562f8524b06a9d98c7f1a976226227faede0cd54e77eda63977d394bed23df833f35548078c6aeb7444ec9e492740bdb5db9e3b1fb4a22ef263373585ac9619bfd87897b6e9e21afc395d7ccd94e1c2fbd81e2ee9d89267f6577f74a1a0858d9034e6315b6ba9091e5c76d66f6c47924f4690b2042a9beaa0980e170b31b34366a2c92ddb1599384f3b1929e916255d138f63329d97e70255230633bacece2ee5bdb4482263bd297d23e1a3d90031c4032d207d3c56bdff2ecb7127b490b261f0a144e354b4b122865ee339b1b4f101a0eb725deabbc1a80deb225c34a8fb3c28d9e198324ae42c5130f448bf06db703baba990273f9e81df13413a24624ad9b6e9b06562fcf594389e639ee2caa4ff6be1151f13850677679499cb83f8091d9a5782703e85a8e535895b4c62d4c6f14259ff0f099cd5ca5e80f404a240e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"3b5aa761760890965b6f0b0f86ca5d94"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
