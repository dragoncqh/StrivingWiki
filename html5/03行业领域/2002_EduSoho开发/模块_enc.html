<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fc4bdf6583a57179bd9df2db1bced53dfe47e6000fe910ba278094055bae5265837ecacf2af2faece4eaf5109f07b16967acd5601ad2f99b7571dad6ffebd85a17523eb7211a4e110a9984ed9705b95a8a75eb80340221134a397e6c794ad7189a63356d8e4a890e993435a2f2a2450702846d60bce777a52657250bb62803fed8cdeb3e4d4368895896a6070fa1a929d82eff53a5fa5a4ecd3546a30c6a51f78c947d818faf588c848995f69335627e62b03974b98442a6e2595367dc1170f4e0a13f5646bd9b6d82aa6c8afa5e2052d06d88b95c8ca3abebd1db3eb260547bd3b4f7ebc6c06bd61edf0b914c269a35046d417aa30b1ad22e86af6a8d8c4c6e012d236bf77871b8f6df4e434b3c3bf213714781f2bac7bc226b8aafe8f1d0284bfef5a42cffc3df16413ee487ec356a63399aac9c3b7cab82d227d01f51c1eeee8c44197b0867f95daaa05c8b879941370f842035e0d8bc3c78592961c4011af11187fd7ce4ef7b8e2c1473e279de2f58b20e59f6f936b22cf150fadbbb6815e4b3b2af3ef214afdc8b3ca924abc8b1713ba040b7918b54543c241a0842d3dab1468da6d5ce90f07cc058894ae97bbb3577f5acd220eed8892f16978a418f48c2251baa37ca0875edd10a4df113ca3270dcf21aa6598ff08906365dbe2e896c49a830cd99638e6b292f7838874f1608e5a8d7222bbd780279c9dc6bd77bcac66bddb33725f28f0eb91588b3bc9b2f58930356753310f6bd7b9960c92aa239f96f75c1190c07f9cf3b87d6b87972b849d425ec9829b362360be1496fab3707c8132e8a630cfcf09018c059027a12b5d469a7a359850f819510c3ad65b1de6ee7ae96bee5a366c43333a744dc7ca2e210a2fa178e0fc225d1a07702ce2680665267d90dce3bccb421d01e8659422b7d3bd3fcc471e988c36e1a85e3fc63803bffd2146cb5a7b951592c1ef45d6e2bf5b4596325e2c9338db4203dcc48c30e4c23409e502fae88083dcf5273c110d93e4b3536b33b99d6557616a70e1b8f2f49546a78b3090cf6618944a41590b80264f9eacad12e4218ff123754b6021044ee519cbaac112055ff01f94686095755c7ea34a5473627a4882d8eaa6eb92248c406448bdd3b893cab1c69b2c88edfd243feaadf5d2a6845e1dde60b42d7c695c8cfead6a5029586104a5eb9811d8675b6b9dd1a137875e6cc4a3f73cf281a927b60dce405d18dc1bf89d563a1a7dd1ea51bbc8abaf2e1777faa0e810936305488549723db2e3748f16b9b0d3b5d6c0bb432511c3a056ce89985726fe38a82e5ea8c4484a7c253a763df7d72c6ebe960854b63a4b1ab35d257fa6e2239ae268225a931dc39a08a12ca475cca2defe8e1c463bb9a9b9f300d5864810b831499812c506495d8d5fb031faeb4d31e0547d6e2ab6194d0aca1bf00d3319069a48a3ef7880c1fef7d70183178ab2b6f38582f861256835a9c8e34633df516727b907f081c3964e7fbd6aa2b63ac912de05a24bf5b4894178ea0f2df56684837df70be002e42804aa45704dc7eeee09874e8e45ac98f73c191427a6b86041d2fd8225a303c185322dfd09d46491f9d57a3f48f1a956a68e104fd2ccaed6802ec7066e323f2260bc1a2ac3a34c4a445acea7c142fdc212c3cc2f705a53f3f47a53fa8cac92c4fc75a725ded837851875ef2ceb82e3a4932d63323f586844cc58f7b62966308e44df4746570b4c7d64bd514fd7a1a916c9a5b665bfdb2e26c278585a5dca7f12c836835936faa35a73881faed4f9b54690419bc50da8d80cc84b782b2ba0daf32b1d80437cd55ac4165072ed5e34d9d16152c9c2a7bdaa10b5ad7eef1d8ea555cfda1c3cb53ce1eb6faa812796401f77303ec940f66d1c9dacb3f266f29f8865cad762288fefb72de38fc9bd2956b7d1fc942b42587aeeeb0054bf5f4e761394dd82414ad5748e46322051d2073210deba74ed4881ceb110b4b7f528dc2bb982a5ff9288750268ad80c696876a25b353d1203165a3e4f7ee79cafc9190a8785b9ed2e6f21b3a7b6b2e0f63804f7372e0bd2ee8158c84c4e004640315770bdfef98cd7ebf9e429bd0e61d33e2102cc017c83b0501f8be0e3153f0aa8c78bd8cbcd9dc307162c360e220da57a09fdc45edc773ca8f6902c94c33901be8866d4b249acf084edbedd9b6b4230b1b86ec914dd56f0ed69a17152d4e8f34c5b1440d5fc6981322d156edd04ce32c8062b98f5b3dc9794788cbbd6028307d15b013c27e17133867944a648bb24146b8bcfde54e4674e11186a4edf7f178f26ebd67b85932a430f062fc7c0ba692fc8483394c31ba7801905738a55d20ec2aeac1e647db35f91d31c1f0eb5c5f682b993ac052eb5af7ff3ac4048903c29223a5adaddc25c8ac43f076b703522ea28dadd1aac7bdbe21a04e48efb40c2a223e28dd79c265d902710dc857a232c8249fc01feb09ad1c814b52fe28e8b2b4dabf3814ede86945e82ae200603fa14b19d90ca54e66090904aef5f8382e669cd05182ba991559519ac3d9b35f9870f9b0a20bdd3456a633dcf24241ab361c0345d549e6b404a4761c8c6b24bbb664ee2324681deb1a49ce1ee5c3968e0342aace653222de642c53c6c5f1b20e3315c880e007101affb27c1ad9f24b6a91ee2842186085f072e70980db0e1c340fe8c6a0d14962091c27a9bd63f2d54453d675da1ba62457a0e1cf6523bd615c9c44fafe3267e317b5758eb54a7aced4e78e0dcbd4c01fb5872f45bd74b7991ee8aa594a3bbe29fcc0de605f87654771d5939bc3e2dae3d736f42ef035ef4df38940730b124e78b7cd1af15173c0d2c0e30d09b2ef9855f4558015c1fdf4c64d6c4fd3013195a05d348833e1940f8d8f5b85addcffaf718f2a6f827323d15888abc6d11d233535cae8254bceb2b9aad3ed851c98460c57b7ed74f2c291f5ccd762c5b26b0aa948d4d014bd0b27726009fed2facdbb70e0bdd2191158442da969cfa393df2cc9c38c36704fd4ae8a7587608137e36b6fc65556a9a4afc609ac8e2549cd67b7dca9d79045b27eedecc9f774747d317b8273c6ee7ec0460f468b1a304344bb1d054b909affcd3cfa659ee565fbb819a826b3f3fb0e56debd3c8bc46e979509c77992fc2dc6eceb9ca2527a75e0b95e0bb808ab47b369ee6e087762ae0a2acd1978d51199fb94fbd69bfd95e221c1f419fc1ee35bae055257ec7a55fb77f0233157cfee79f717a9d895dc62d4e9017b7f5a4e9548b5e090a1badc4cbe1ddda4ecb45d118e6b68f1b74714d6abdc8947470d872247275f8fcdd88bad2f9474c0cb05e7f028f9555a1d25443dec4bd8c873c7b3d91524d0675cf92875f50edafb5ec2d015e8d1b553643e4e21d865ffc56e6d64fb59725f8f384cfd8ff82ac0737073ef592975067e0fe1ff8eadb475965d5c43b42bc2d9691c99ac471bb171323c0f8909fb2ac1fbefffffd3cb9a044d61e4293e945eb3bfa855d894e833773201ef87c3387820dc52be324204676ce419309a3e3fdf53528448c98d0875667e1b563cf248b5ab78088c2b4de8946322e73c42341d2a85364f3d3621f74e813c165eb859a35bdffeeea7a82a05f921dad9d25a9a1b97d5cd83d289339457cd48bb003b087de82eeea25a4b6545f6c064701da60928914b3147300a887e6189bf4c5182dfadb814cb349e53ae557b5b23d8633afd8a236823fd99ffa11296ede91ca5f48168e2a6b0ce78ce7b428177a33165ab3858e0061729e84dfe529702dc81582d2780987a855d104ac1095b0ae1eb71de2bbb8c2bda228c5d870e2eca3d70b0e7bc27360068365ed6b13be7e9cbcc0d2dcc23d8cfb53fb059faedb76cd6d5e30c694b850f1675b840bd9f26a91eed4bee12d844d7ab206306340caec127b8f19fb737449c86427bdb7858db49864239a89896b761476fb2b8fa78a40359ae4fd3407f18214e6519e8c85e731262da623392574f559ecb360dbdd0f8e17766bfec5b50cbb53e356b1483a365559ccf706337c50c5528bb4ccc97b7c8742bb340951061a09e507215fda7ddf634a4edec84a8c32e069a84015927fc37b9644c75d1b7eb492651613c772d48c3f0f042fe4990ecdb32fcc77dcb4251821d2efa2e7eb891becf3a80087a6789e6f7b13299aeb8575741148492c9fab34caf441250b12e086395dd9bfc24cdd9749f48201a54acb7184b91d60d9dfa1414d2a6c72fa32636574b89ce9127cbbfad2d0190b41862d888d137e7a4bd62c6d5cf64c38c7c54dc858c3c79e30772833bb6900ead19db535986ae08f208d7ccf81387125a6e0d8e86b15189a2098bdc700deaafe42285c7206c5b78aaaf083d708ab0fbf6c16fd4c4ea031d7ae39910778e71bdd1e169a7aac778cc09d665d6ffd9de106dae9e7c948a01c39439bddf43272cc56b198cf0b23fbce4867e84c4767c06216c6aedbe8a8b0279144e8c2be2da72ca871adf56248fe922c77911fd5d721964e8e880717c35a1acb0332e3e0ca005dc557f4879b165cb7a5860b6e1d0bc93aba1e0a4bc136a144b1baf4bd3956b0e750037e55249b1efa1247a4a7ac634f7dad04220c65f5930134d707b90e1b9ea74c89ec1f3482695a513910a5793a073ee0506a36914ab67297f3e16de9868cff5034cee3b2cbab7c7f3aa2a3305d3fed33193252691c919ea0388441fbd48a60427bc41d31760a0790b5fb27aa627dcf620340212196877940d282661425657ea32c3d81f4126484df8c3a40e880b519ff62558a02b6a2f79c0f260424147c6204488852b82d32c2e2dd8e6fe3d2cd5f6c26abde42a4cb3a0f74f8658c0058065dcdc0510b8212a7869fcc985575c4adbf1232e02f30722a152c957f58137c954d9c858936f69774de1f517febb1bd3a4493f4610d49a091696497ad2b0c5e88e56eff0373e2513e236bc5a38867d8b292b606a4529cb53af4beae93ea96c9d521e797ff35b897e81e5d9417ae3d5602488aea1b00c1ff0af34cb81589980472ed1af307fc4308981b323c5daf48cd4ab96351b47ab404b608a7603105a7828249951e98f4140842b8f0f522df46343e689e6188e75ca2b5e28e94fa04e55be53304e9088446330f9b0bd2452a8569c8383d9968564eb89606edb65e93be815e6cf5f00855d5b12f36a1fd4d8f18382136508fa785f0d8dfd55bc1e90afff4f8aef7317a9d3f3e9dfac10376faececcc17e2ca4d0edb1b11e1f2a714425fa80d1b48996dfa2cd808243e245cb8b791b22621d82b618be1f614b7dcb4800a1e324bba03519df0de82e335b8c6f87dbaf6b94ffc30a03507ce0a2f566a7b5fe4969165e59e35df16c3208204f0730e78d2b5e17eba5d0aa0c3f582bd0d88dca5141ca14ad97c56b63f2c6e21fe093e0e2f1a322d79a136acea822031f9da959bd67536b0738171ab549ed66bd9f9d8c5c03d1f651d3fa5d65cfc7f8fb90c78460b027ba665e3ac89d5cdf89e9438c80b4048a9da9ce3bea3c932be4b2e90589054be2b03ca1bf64908d7281c31388753b870535c3c5476ab449cf49d0aa6878a48cc3e2247420427e542fc5f8ba30605ff77d66cb5dec03cfe1659c58aa81780947f56981ec55f1b7c3a90548a52f37b16889d4891cd66742f5fa91ac947a0f8cec1e5f47e3decfcc114e20919ea86b63fe15b18775fa9c4bfa442b018aa967dc2cdd0cc9aee88ac9a16e1d45f9c19681e07ab86edb86848f7adb82e7744492fcd82a734437d825851c93e67ca91b985aa0378dbcf99eea68775cc079a4c7ca518cf7636032faa5207237faac26e2f26711fe21bd3c24eac46c84bfed3488d59804b1d804fd2e7f59aa490d030f3ac67f0069fc30615c0d586724262c5a7b8eef21b1adb4376a2145c81e2540c14f30b9e850b2b41f3df3d36f1accea44b558de4006247e2441d6ab4c5a482bc88a1dae8705fbaacba2f4245a5ea23caf1c034c0585328bcaeb1fc3b3d2685fc85dfbe6e62a4f195980c1930390645752b7cacd76f651a4f55bebef243411e67fe90bc8286b2bfa3c201711d7c895ec337a44cd22cb7e1f81bbe623d17fce4ec55fee1356fda7da993c1fd73ddb0c5084b79da90bb8b923b0551926a749b5b9a6429ed7dacf1220ebb63fe9ec0b9db768d2dd0193ae7f6cf2b4b17cc03e94b334d898a29ff6179221f72c2600f4d82de6e8e2666cd7782fc7717fee9f0943b55b1febd18083d88dfd722b905cc1195368d93bb8c42048826736cd5c6f6a7eaf696cb356058cb004ac6f1c2b48b34b7bcef255f8a4640476cef9c2b264495ce696d60c5f02c9f32d88e29c4a916638198db61e221f66c1e55a65ce22d7f26241841685d031933ec44a7d234c53ce0d75e432e52a73973bed134e6f77c344efeb43f271d0f883e0a31dd240a82bb8380a7373a45a3663c8ab20e6654d35d58d2c0b82dc3cf44fd17dc643bccafdb9bd195514f6b554cc0a091d90ed2fd2211eb7393e00ff1afc361cc2af7371f27a37982e6cb88f3b1fe79377aee43269d1109936b2cebea46aaca2a3cf8ccdc1c1342f0fc48d279a43104f4e191c10cb71b5811d768551ae0681aa75e0695d28107b73dd96a3189fe64d0b3303fb8b5fbf65a56f3cbc10af6d0f6d164aa15314a2f93e8db4286026b81539d08be321806632f997779b4540845e5a6d25494fdbd5920959a547c069402df175bb1bbdd3d49d152242c36ec3473b74ae932ce12bae37f90557863b73fc89f6052f5630e1fb6642de76fcf25489fb9b57d47a125c81960c9248436e15c768ada076b60f0e92e552d52ab7ea4626dad77ab5acc380710a0d328383cc5a0c5a601e195867d66b7bf46cad8d8b8f478befa3ab863baeeb7e9c4b14f69cf26b6aba1454142d06465130e96cc973113bfb3d1a7c1eb344860cbfc1df68998d7ebcdf3789392dfb58d1e1364d07b52cb901584ccb240e173ee693aa04b2a55cea9de44e5bd2eb0840fbbeed4211b89cde3a40f7954692f89c0472f4912a547eea8b16bd851d0b0b39bcad35999135a821eac764370c5280f58f5cb15544d8e4178628860eb6c83d84eceb13790ddacfbfc1316452a3a8cbffc25b8216c7f52883f023747dd98257bdd677da522d70d999a426e749bd3f7dafc2b1a59513a21b5aa9976cf1ce0eee1c72b22ea3b24c49e0c89b5e999384cf7d7159768e75185e9e12ea03b541fc2d9ea398918d0c237d60a57fb22559d41bf589ab97c1492d589425a89387009ff12d3bcb2595bc01b8051fa947f729a8f55cb93cfa2ffb4cd4914cd04114ea178839c5c2e59fcf6dc1531c23f16405ac8e74090de9928c7e96ccaa7011743d3995ca0cee3b815e7c28f0f306bb924c5d3d31a41190bff36cc022b38424ec594dde2036f152ae91026d84095bad3c3f4d1fee9223640a17c21d8d8762427d01d37289f33f74be187c5c3c350190f58fb0ee22efdc8892d29c23589d04370ca2f3a366700caea1ef6d07864cf3b2692a5e945a9fdc8777a3d0e25100026ca699b62c6d60cae3135bf3fb594d031406e83743da405742d80af00b5584d5ab4b81b674c7af0f6d586fe2e9df79f06f9c4798f76d6fc51e9c3c1667cc3605ccfbc7347d4ec055ebf41b96ba98ec30e4d0c92eac27f008a3c90a6a3cfd714ad3cfb0b8934867c29ddbc189d968ebb01b14d2c1f2abea0588acf9e01dc3d06a13aa46208da588dc7928bb8c6f470a050dcc6ead0a7b20a0a55780fbb6817567a6fcdb6471599f32140e0fff3bf572801e3c8987eb992b5f8465a0083a3a5e2912cff9690d136a59b8b282123238a5a23c223d36c16e7faeacc09fbc96bcb474944a31025669cfa54ab262193b14ce8876c1550173667de9e3ade75546bde6c7e184ad0e9345834024b4913a390823bd47e99d03df160b943fe69dbd09a5adab64f25f59a800d569b2b72ad75245250a7a1fcb14d619f9f1c716e051a36623904ec9efdc8df25699d1d2ea9215dcb5e421a9701600421693eb376738f343f03a26a8f563d7ae5d7985648f1086fe4861d5b6106e7e53aa68df0acde7e6a9bfa6c2183918989419361e585310b28b39b193921502eff37362baec3b6889203c975d41f21f5694821c08f53c3d62327647a3d71e1d0303dfd0090d3cfd6e35a8b84aeae622e100cfb2f647b4931cb594b8d2f0f891c38695f89052a1de956de3e96c42a60ddf86233c049e95ca75b4b042ca3322d824a87249d150d37c85c4b2606e68e8e1ac6787e5d23b484a32deb75220c2d142a0faf467b44941eff451e8e2fe0093004902a08838366f5f3f31287779e32251b75963d01bf4b1a873983c69a7af63f40b53a8b9e4f4241fae38ecbf321c941a753c7272b3c43d870d8c4cf8f741dd5711ec0ba561afdcabbcb0adcab5e0a86cf72be8623f965fc1f4c7980ad0f09d832c96e8529db27a36625be08a32c553d8a663258eff15948deaf297a56cd482b7c381e4be05cc80a8f1e5a1c1981163d15e3c17b99000c62851c9acdf7a26b421f2d3c02fe74be1178eee276baf7683301910457320ca3355f5d43c7cc10022ad8e051bae21bd852bb212b1e1ce57351f5661574dad74a624b00393286024cbb31d535f39ec8eff1c767dca1a8d007a230c5b59882e998bc1d3ea12e7df9e2decbe27604bdbc5d5bac1d38c0aecc64253076a246d4dad15629bdd5d72aec1f04a2c1dc077d14c41a967c5a1b1e0ca3eb4a4b22640220d350654cfe537dbe13ad72079c10e2b529976d709714f49a1e49786ecb232dd6d69ece12e9c7ada6909368ccf129e7bcf9d73e1032972ba4989c2326bef4cc67f6fd272d1547ce8d83f9dca53818518e1a291c1a1901e3745aa3e4a95714248cac994ddad5e16eb6a952be781ecdb55703ee3809dba01403bf9af9ab9f82bf812b118841bc85c1cf0d90be1a7bf465c92405cc6135bbf2c5f0315e4b971fb9addf80371fc377d88c31023319c39bd8652acbd27a11fc593cbad3c6012afc4504b127e46865771c8735f4275b2a956db6aba93158b2ef103e098e572ba644c14d7889b4c4685b9387e81b918bc069fabab461d0d557cf8b2805de3ca7722c7e030fab99b85d138d18fc58f5e161b8db02fbd786712ec7787034746de25b2cb89f9d623ed739d8ddba2682a5cd6b0a51f5a3ee893da932529e215089595716e41f7cda7a3cf0b06c6eaa4f53986e23ef622a77fd0407471296d9153e9fd084331daaa5de849b5cf5c8d4fdfc43f0bdc20ce8c0a6d750df8fc2c4b7ab224e572958281ffc37cdf3cea73b87874659a7054d794ff535a408833e469fb64ef9154663956a27c2b2d02cc5aaaa699317df66359618360a9902bdea2212496c4c9076499dd40afc1533bb73c658a6d6925a886263a02d1744576a77bc98cf26f6fec0ba9393a617ec5eb147c331d652139c2871fa866e4f4c6b2ef926a0181296ed9efce10dfa1bc6a1441792de8f5608f1a0276d32582810935c9e28007c518b6b7f5586f8fafac1a25592fa53fdc9081b81dd8377917c3ddd8c5fa26cf9edf166849ff979d282c8f3644a6b45d8042a3872333ef852448b379938b7d2b1774ced9243a02a80b8ca110b54f69c14102e2c18b0927d4f153ce52da45a60733f8093a3841084493de3e50182bb6e51f8c1f3650571b6c939f7fead542d488f25466500ef86a97015b30deb888b44f1db8dcdcf91e1577f9b3a66f7977fa2591077b0f578e957c8de2cddaf893356508be01e575f86fc1fa62c632556213ee2d0b877db843fe87bf1c50c7558dc231b1305f1d23b7093657fc651b4270a817a64eb7322ff5b186d41c54c5b7eab261ce8e7f4ee9ac0fc344f74d3105b71e45da97e135ad4d5d1d97775ccef3033d49eb988ca8ff41c7bd5bae840f071929190bba6059460db51ddd524c96c8c2d64d91d6665366c930a649068ba66461120b09e0511f13ca334bee570f45bee9a2bbc66770390f1970b40847c2c9fb65351e1f2165b4b368e54679c7170f4b2689638f5fe53bf144190f9dd051e2c6447797b4b79241effcf53fd362daf0a968ebbf4aaad7bd545ab9034a62e3a892d9c02a9625f41ea113e4ff669635678264adb240886aa855c9e85f18a5339053b6ef8314d150a6a7bd7664b2c0dcc350aea05a4e3725ebed41a6d5b193d92c07b07326d6d74b4ac5e24502757cde299e1253cd60f1720ab1c1b2b056f3d13919ba3f692d0d1e3b965c78574ca286f01772b926196c1ea0f649b931c624a757e93462c8bbd8efbfcc5cfb0402351f616c6d49b9c5118b2261f01a265dbc71cf483f5bd7783914cae20b238b9f4f90399c2687f88083640162423b086feb72ecb8fcb809656c84ff6a329fc832976b924b18b596bea3dddd1d98e21aedbc7ed89e347768441e0240b4edfc94ce8e3d5599876e4e3cddb1a69dd9be56609fe3b3023de8c9d9edeb65c820ee297157b528dd814510488636bb430c0aa46154e62a6d93828dc45fd133af365363acf62a5a2bb369c35f2fa56da8b53d1790e1dbee8156aeeb3e3f9fef09be5380fac4c2c9fd19e2fe9c3cca06b1ac5ad717a79624af7e98e939e3aba2551f9a7fdae4c8a652381f4aa078e87616ddeee294e41850899ac136a84f11fe59aced42d253d26600edef12ede258791d0ce79ac0e75f8efe9f6511ea23433355deda1ba960d3e47fe649da8c0e20bc13c14d43558ebfab7a7dbaf1cffbcaed8ff9b81002c86991703abc6379fba960bf28c8e373569549c141e84c10459b819adfbc562f19a65db4eaf3e4c56402c0e60d7a5ca1c6a750936611977b5bfbdaf6a0eb3c0c9618adef982879f3927c7c7b3ab5a981aa91c1d6ea20e5814cba462f21e65aba12f8d7d6f8d5a7e1b86607669dcb3466eb66e76bb444f5a1093075ed0992901e258aae5e541b4e5eca58679e4afb47df8dcd6a0cb681898c075cc91276fdf28b0bbf061d20e31f16dc9a60ceca64280146ace515733fbab21de0acce65b6532300fcc856a776e4899bcdac29466ac1c78e910c71f42cdb05664320f4f9264256b020a7403af1c6a50679d254129ec648102f7f01d0ff285ecd7ae7a52700e3b456e28a67b0c2957988963aa1edd22a3b30d7f50d4b39a7e22f50f8869c1a9e51c371d89963104e672005694536eaf9dae4e3c940b9153b079caf696e50298ca95bad060367b1d31e6941cc67f41c0f5283d7c56941b6782244a2bf9a3e4438aef40f1c5247501587dd118a084960a33d5cd88aed7c62aa697baf6bbac12926f590c0c5bc87ff2db5d68c6f83636d0a9c733fad0d2ba7668929349e37198d44eec993b0687929525c512320eb81e636ec87baf493df100e6ff6e8d29cd55ff6b8e392cc47e487c5a56a8ab2bfdcdda630257148362f5478ce35ffa3a2b5232083588b1a04e35dec5a6dbab3ffc92c2c1be53985c62b9dce38fd41df9eb1399f5d7c8ff4ec9eb099a058e8abe70eff494d0a79826b6d94177084ba643d8d19f13953fdd3719d721a75698a790fc0017a79d2866017e8903281283c2623f32b9dd62d54c13b686b9cce42dfdce4a13c230afbc2ef8c23333b2233427ba859864e6188d8b5be157c67d3f2d1805cb7e83027311f8412c76fc7f8752d0b4bc96c32a35f18bd0268cd7ecf01024cbcf749616f96bae671d370cf94f0167577b185b170aa1a8ec1aca9f0ff56310bc9c44a715567872748671c11f704dd03ade280442cdf4b7700585e4f8764e093b6d00089c53d4806a4892a7700d16a8a777021cd4f67a4c107b72d01277e24ee6fa82ea914f3ba3c4933ca28385720741fe383e48b0020c86264def9902485667e052b81183d27d8ce078de605ed1f6ae172056a15cdf4d51345b41da9138152430ed68a4c4572f2760fb3dbc0b6837c7f725db9f4a5b80067c73f5a9ef4766db05f33e5b7fcfb0c9a26b1ef97bde0eeb102314c7bec9c20b9f8c20f7338dba61102727a747ff5adaa71292c7bfbce7b0d0a013befbb592ac434a509694186ffcea1cd599fa93333242276ffce94339906003b7144b58724b3ada6cb5d50354f2516aca7e7c346ce52e1f5dcc506f979ddb3007ef1f480800f3deb7aa560dbef81b98d97ff2575ba3ec4d738bc0d017702754f08cee3818901557d2ba7e280bff9555f5351a6b78847dcda8c76d1355ed5e366416070bc07e0cf6c477a8908f28a2bdf31a5bcb09d7540fedc987bfbbde996ff302091d67a858f23154180496b162cadb7fafee8be6886f9447c464233d64d01867a94d126909a51a280d807478aa3722fe71cef4a0940aa79d92aed89cc64983333324524335113115980f4ca2d88d63dfbe03350f9ac323a297708e0ba14c087546a160832c214e8570ee1544854dc30ce2560d8bfeb55e19d31973c023c71aec175d261cfa3d1fdfd1b930befe61ee0455529d982d375d0edaabc36d747b96f1ae03bd73d6ef17e7aa5cfedd529713a8c73d43cd299fc46f98855c89334f61d6da3104732b23ec6ea12f1206de0c17976e21a04fde3971c904a904f90efd3f71f1be17e273d6270cd79f64f85d14e48adc60fdef2e6f3afcd3ba2e5cb261de624240650d12938a2b7dd590f1e3772b86e3cd8715668647bc88bd934f47a895a235310494579908e4ae5d86c25450b6ddf1eb692cb552d4461bc84edc53dfd7614363a1686512c1c7e3fd3ddf5d1e51ac8e97f41a7f9d5477304e30b278ca96182b12c33611104b3ca934a89e5b549c6aa564418c406354392f22fd303e5ad9b9b56bd350c5eacab4009bd93584e94e2956c0d0ef88a04d85deee0dc2a084f6bf7be705b8126ecd79605b546015b7b3c4bf8e0789438db42918bc2ae377aa7b272a258fc68ddcac835382208773bb87e1826e4f59e78b9c84e292aabfa1101c0e2d7e971f2eb42863cc7104306f0d8f17343c4bdda6b9caf1779a3e265a863e38efc5d8e6afa3c6d3507b4701dcefbfc6397e45e185a62766ee0d96799f3abcfc1a04dd6e5e9114fab246b3abc0d0ab82eb77a2a3a746ed8656bcaf2cefadbeb328bfafed481805ff5888e2ec9199b97455eca698fadd407d01261b334616c48de4ea20455624440f9db8e97ffa3be50ad9d00c1b3d35ba873df16d244395842cab0f50d80504e0ff65645bb6f7b98819d10c49e6b601bd6fc94cec920cf2e280803ad01443f1c63db3f24d5892576eb95b5ebc451f63a79cc15456e94ff70f14db5d81149f987e9d3055e9718aba29864738a3f1e05dc4d912fbab73e1d2852aa595cdfbbb3f64e8cead047f905d8349889f3f3f67a1c31bd72fe93a322cc5d75a856ea141f212f6729046dab9203f20ec6bc199591b8be93b2441d33d132fec8abc08acc28fb3524ae19377babec7c13a87d8d1f903cbc3384f570f2116a45f8093588435413b878db7877d0dab9b20b82503c6c9ebe2ddbd067d3b9792aa4865d21c279c029dfafce801f14634454ad1591c41ef334abd3ec02a158c85af401feaf9c799fdb7cac3df06b4bcd70b1a9eeac2cb2c90bc3772c249166d15d3c7637b0c0431045d7ceb4e344376085d2fc66b59e28d0171cd3869d386c092d4801f7610c116933daf756941fc6de333229b483de77837d433e8ca78ce78124de94ff98766e7057fe2d7793ca3b7402e4adc13c103736651740a011d11bcef8cc3abb9b195f6b12dcecb2a18f12bbb16b3ccddd52c91bd7680336dd7d9a4b94117a49a4709501724e710508746eefd87db7e01e8a7d828a2076d1768dceed1e5742e98b68fdc94370db42d56a18486c0f154acb31f85029153cfa063e24aef82b091816e7c634c6691ee9e9aea52ae49500c8b428d1d9e5d14d5f3060f9a643794e898fc37aa49c51d246db2d7fbf0e33f226f585c948324e8e84ff7970601783c5af0667defe3d9b751d33c30527a15528ea21c6f0e1ef89986d599b071f9337c730dd9c73e090f28045686002f23448b169348695582cc61ec2f68b1701d376a3ec78213581acc81e0c1dfd53ba81dca28db84694c7bf11221dedcdae0cc60ff15070ceb530ac3dd408e3d331e2bcb7e57b5cdfa06f35f39d8f1c0109ae12261a0a7ab89368bf250a06a285f8ab9608a757cff0a0720067141c41a36bea3d63d359be6d30d81b7f685155daabd233362bf89c1374e2cb9544a13c3a2cdcf5e294bfc0ce9639c285554275797a7f4852d61ae4859e94f57f9d82c594ac2db1eea1c73ae0e1e5bc7d34af577c5ad3325ca74e735ebe761d51b6f2bbffa4d5db40423ff244550cd3c37b8c025897178f181ed80865a2d4a8b67c0fa38e4f3c980a809afd225d7970d8fc3a56927580cc9544fddf452a98190e0267ed346138f373eab6d0266cd258373dd92dc294e6fb0ab1ad4095b8ace18e0dc1e5d11438b0d12f9642f79437f3ea070185f06bf9322f090cda10f2c18d7122f3beb898e20f3121f2b1510c36e568365cbf76803f2440cb2ccab573f47540114067fadb624380880f64b6706b8e5397feef5783b96937a3556bd50cedc5ad3df35186e187bdf36bd9b774429b266d181cf8da917367e53340a6c649aa04214a0156891d399b5c6874ebe05b0083d1cc46cd0b512853ae4bab839afee929fd673451dc29bb9334449b9cadfcee45a15a1ed81733b12a92cf5e1eea6570d74858696ec22b767b1aab7a7dd46e219d8601e4ec6f9703cade653d74aec830827bf02ffefab73b89877275a17acc7ded8b611cdb67dd2157f1e81c0a6cfc187f759f68e9f54b841fb54f68e104dd6da2da1b1ac600bc27affc805a5489da07d05016b9c3ad38379f3e31999ceaa8cefd54545d533433d0e7d95e74b7ae858991e241929c6c0b149e758d33f89459403985db25d4a277d2645012a0fe082af5fd396ad4fc03ec2f19c451b51709b9ba5d753e71e7b0ccb00a76140577ae08d5df25a64ace04536d728c95da01db40f1b8ff21d5317caae1466681acde40c2a20594fc62ab15b0c818dbdbb34d4dd6ddbe07fa808d136d4e92f9dc9c01f51c2eafc4fc16d415b5d13f1f52349fc03465c333380385c0cee77ff96453587585a70a4801eada0a3ddfecbb23e8bbaefbe05a1c7825ffd28ac86f818343fa45941a5e625e96b58ef9e72a3b1e7658aef2d8003a7e9634f8dc7075722209d208a9e9d975d9de28004092df663379ea88951eb1bd9cdcfaeb33cf9189cd9409d27916d19a57ab55c6120ef2a07c11a64176da9e1fe5828c182e4bbe08d7b3768839c5465ed493db48aea43e218d43ebd975438738108a711788e078108d49e0aeb1762c9155047fb1e0a43795b3e87151fe3014d39bf0d95d8d8811ad6b190615544add0d8d1357b865f6852b63895a464d93312c54065bd566d7c7d848c2b24cf20d4718875dad4c43b01a8a459b47a28c418e08907a479b33290aab76b09adb9022781a71a0548fbde6148cd8e803b49270b84f8b6ca8a4a3f3dffa0a4c367ae4abb34f6e18527be42ffca34ca82f118173a98a96b06fe2aaf718360f85a2f114dc8edef6726275c7c9fe134bc3fe6faf3fe959fd8cb0d3efb03ddf2d525d89f22e1a9c2062d6fd5755ccc78cf812ef3c3601b7a015e9e1b4a952c1dbd463af3595f4769a98c7f730f2efd24bd85a8b58f393fcf6f7354900c1652b167bd833d2d6e5e11be3fe9cc7c21adc09f616676d7c20591ec4d510b47faed88368b5f7e5cd0dd7512888fb9d81150d24972fbd6d113efc3a52aa525fd8440b1866e2b46e12a6b8f5925e110d3c6b37905316fa2491bcc53ed81617d8bab0911689b26eaa24e8e31d45a751c7b5d781ad1dff664d7120a3620f9e80fd1f5c0d0b56a1d2aef452bbc5f4acb26d8406d1902ce81287ff6d3dccf43a7ad847039f84e81e505f65b1868c59bc5bedce88421063d6c2eec615c8e97c65f5b7df7ed32cdc3b18ca53a5f9ceac568c3e7ee9a05417c49c2eb68b5233c0566b558b8ebea2b3787efc456cdd0fde9a8712fc5ccb6ce109deb43d8501cded873c89ef567ed6c4cdba7e77332ae3d8b469d8788207185a2a619ddcff4593db904b48a966ddef0ec315e3957259e5ff485f57c12613cfff6af365ee40f2a7315363bd1994c72937bd1aa12758fc16003c2f949f92e31e19536596d45a48589d3a7208a89a5f7a29288844a35743454e941845fc1bad2208f90dc1603400ba06a9d5cc4b2ca2c6002d0394058acdfa7efe12f2153f542a7ae43130b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"971ae63c6f2ed4d3e2f83a31621e27de"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
