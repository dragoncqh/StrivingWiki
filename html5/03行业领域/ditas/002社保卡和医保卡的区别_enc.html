<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"46bc606d6ef6ef8ab188393015d0e387336e13e8ef128f10024484dae76dbd8bd38cd9f35b5673498f0eefc4440645f3ee10d82eaf57409b2beeb75e94dc8c6054b66bf66670caa8c07f4f599ff894c12316605939a4225293bf7867f8f0fe8383171d34b38df2bbadae86bc374d8809f0eea6bac2eb9c3e35e5d99832cd8b9a284ad0d7344b5c152a98c30afb9f0ee7452551114d70c6e2f7c78482e86092eee94325ebdd39fca740ddd353bd15d8e1348faa2f68d6d5e20f58767637efcfc3642866a41e450c762a57579104c8473434e24d37645aaae4ea94b0802ffde1a6c3710c11a14f6cafeb72cc99afa6892338ffbec937450fc419220663b1cc32a0b9515ad7428683ac620058fdcb58b167d242b764f300d6fbc0925397f69d7b4b36da31ddcfaa07fd22d1209c4aba1d82f0dc0cf17ff7c314c62d35e112314dc36cbdb4aa4725aa9a3c3231e2a051763e4903c38b372571a3b1df4fa61d2af6021c2c739941db50f0f7b92666e06e3a7109a46b8a402bc0e6ca3ea4bf815a60ea2ff5ed65ca246bd0437299899562863991ffdc65af8a093fc8e2711d91e36f30a2a2e537bf79fbd6f34f20f0f4d7c0a4c8a82cd14f0b032715631de5d881cd8a2e2dfbf292dd19d815d29e7e85d27d1e94fda430bf89e35da8efad4cd3e5a74dc00da528d5ff6357a344903b3351995049da5188a8b6c502233d0afb01d5df1da5693f7d25d13cabe74e2bc7a839e60ac6753f081c2426f56d42e10c8aa12bf799a05c3e1433c42243cdd7885facf90993278b0b09ca8ea55e90e665083f24b6141412f29192e5b885088952dd187d5dff48356184cbcba0ba665b8fd420f3a09cef56dbbb68ce19c6ba7e4e844ceca3c1b2caef784ba082767b09b91306c59684d11c5ba55c6d2c5bd0d00956b54ad4bf738007825bfac516f4b36de82a32d92e499a0cec5b85666fdc32ac53d2fd5460dcfe5cc022983946afa9b566429b33ec56190bae7476c1fee5afb82db842e10b8f062ca77ed4da43a3ab9aec05a247cbea518c1e343994d6970df3411836fab3796f4c8d681b2d650bb95d9bc6e9b70dbb45a8465a14a962a3141ea29143d6cb5efc1cd17e395c445eea270ec2581ab79ff0afda65d2956c96fdddd6add40f52c428c9091880ad29c1ccaab30e1f445d487c7a0758bcdf1d45805d746e111b18d931daf9ad635d42127ff601e12e7798fd66e70782c4e0b2afa8eb0f93683b8515f51d9bcd5a34cf3bf4cfe3c64192914d475558c9a85c313c40aa82e56ccb53aebfb17e9bf8b8f99a06c8adf0c54543e5beb4d810932d82b3dce412a85f9b96741be2ff73913d8e7df5e4bb8b8cdc1630d7446241e96c1b32948182a7d1d798adae2392dfcfa9c5f83aa4fa0ea80564f45d3ec1587e3f802388331c7c27dba6382bb730565e29df58a807759758e2af7e90d4f9042b9c5198748b8f6b365dc2a0db86adc9a24e197a2027fa020a73e01db7c2b4145205f0b3bcd1568ac0b2203c690c3adf1c4202e8c9d72846a5545ccd9110d42253470f64ab910d74920f4bfe329b25126e6b0f1a013053531be58870662a165e8151e3aad1a5c29233608b9313770cfb2f9d19e8b7a1c066317ed7bc03d0d11637b2377ac4510b42b767fdbd6c74b195034c13e1719996c7e3afebe4b557697975d9090ed255183c906edff84738aea2177f1b417cca0b9f6fe7d890554980b13571b05afde09f6a0f3d20ce7ed2669737f4436d091c1800312c96a5ab61e6339dbba5f68dc191ac526f8a78d453c1eea167c7bc6d73f640fcd43da09d03a8257273ef8a738e01551444d53bbde3c6fe636b2ae82b7a022cf6b00e8e25775038392c61019c4af10206582eb05b412570356a34ed60403bd2e40b38b6b4b3361423c25c89246044f6f67e6972653f58a429f7166ea9517232cef99e47c42d06c328e3ac847c4496e034794e81ed56afe6a66998c921104e4a9344469e1cd1a77862666283dd698cf9290005203504cfd1e57cea3d367e35b4d4cafa483c06c326b63c3d5f5a0c8b3ed01b98031ece8690f9ca5126d94208e82295cccc17e55fa39e5cedff16f89421e61c939bbc4bd71785dcae19576a64840065ef6c86019af44a7a5a99cf0cb55efbfbf4cb8ea2761a807ea0114a49423e00c109e21008c9570061c2a58e44299991ff805a5c6800dd7bb856b7072226b68ab99e568f0f94fd72f3c186bac4e2a7fb066ef05f08de3a88fd8e0415d601062bc40f87b58120e3a66c7faf2bc5cec6456f047a06e0be1d0424b40ae639bc489e7c1382e08bf3ba0cb96e9781b3a76434e289663e8f9269af6ca545545396ed7acef528080948bb9a3b08a8f515e1cbf9c97e07fd1a04f882da66d00728d3d6a5b07cc057bc86efb40cab511b0d158841d8b94d26a3582c21c91200b677d476776847405f5006d37ab543a541b215bafff5928fe89d3fec1f3960a58e577e866eff82d64afc929159376cc1b300e50b30de524aa7ff5a6e47d02823c2d6f4c5ddbc25ad1b85bed41555b60967934d534814b6c459a197c281eed5974f19788911accfcc5699cc450b1d583d4152c2528bb286339a09b4793888ce34309269f7e0fa1903d5f2f624b0acfa4c51aa862dedaf047a00f25ae0f115a8b5e1f2adde8db8c19a7821365956e93458dcabaf967408cc3654dbafe831b09988f4c64cd669051b9cda54480e4f63df5cb86942bbcb4af9374408366eb0a5cc70ae7932a2b4e9a80babf7a56e1af23a719c40157411e5787459f56910a921bcfe0338a05bb5404a201f108f0f1cf71c7c884747805067e404dd6d165f4720e89f8914e61e2bed0e2e57ad24e1e5c3820424e1abf8d7d50b6dd048697cf469321578b4c6f05dce8fa9899c053c2933cda219f7a6586cf74190a20600d488047ba2273c3149921ac33f91ada5340c3aa6a93dd639945923cad211a62f1a8b9991b5e8c68a887e82232efbd43859fb33e926c3e58f8cd86fd25fb4d9b31cdd57296454383b3f016867c3a78e3979e6c08b60edc4af756bdeeb8351418301ddbc8fb18fd730026dff4b3cc71121db0fcd86f27c7dc88056b22772e05a1302a853c73a272372caf84a09c984c3aa100d8ecee6bb672e153d4203d69a73d1f9d544b806313478a0f353db9d41c56a9726a686867d7b3b4ec0f31f618a3a017c74ea4fa5b7efe4d3201252a01b5a9c3803b0c9334f8d09d5b5727bfaf70518e0a6c5890ae0b935a2cc2d25351e4ab50252b7965bc8c7cb3680dfdfb8c93ddd9aa4cb5a0123b572895f5a7f64eff8b20362928d0f281b0970ceb4496fa91f15b2e6245b4950150fa1c25d77af5d3098d48404b947137afe2724822d21ff739b2673043f74daf59230a75db66c9d95edc0775a98bcf037e9c37cfd5cc3469ca9a18030b5907fd942e4d4ab7a386e98e9f6174d0c64e61d713cff6280061cc72e4e155abb442314cbd1586520b65328138e1f66ef627ca618ff0067f53069531ae6b53e959973cd5ad0de04d895e9856c02ec79b7a559c6b1569d2fd751d1a60066043c9564df41de19a5c4ff783b45e6424b31ff0ec987629db1101894ab31228ca090e412bd0363e25b73274c44b398a7ebbf1783786e397807d29c5cefdee7093ca45168dfee9887c78f255c19f06ee59b3984f7f18fe3025581e359c5661b0b80208dfdcf26c885d4244391663edc2fc00e736a61754c8d00f33f9fcfc3818ed82e193e7113a6207edc5167ef46be30e570f2c24571be490379a325e18eb063cc029acef76cbe22226afc41b333a451467a4285bfb609a6300c700f7bd8b8e931555f716778bd1d6529273f378da20d2973f2687c279ea63ebd302c11730edec608cdc318cc80b64a9b2eedb6ff7960e0bbc2a9c54ed0171cd7ba4f835275d963c6646986badf14366b93290788c73f62a50592e4bf665ed8235a70cddb821def52ea06f9097e55b83eeed45441323732676c64e03d97b1933bc80c049fc5fc0d381b97bdcdf5748c4d97e63c0b6ea4c4e08ae3057d2b63b6a7c0229328bbfdac5c47933fe4bbc7a06ca2bb5ad07b0c259798fae67980d31bd970636364dab2ddc792387e9f1c2ca36d7341a7ebf7943b92a38d978b7feccdf122440c2161cc8c858af30745763c20fcc4d3f78c33fdc1fa0709dad7a284b316dd6ed030a72398a59374e4fd0e173f104f559491eaf427f6b383470362f8733847dd3bf21603fa35991c783cf12a91fea74545da532e249cec1f012f5e34101fff60cf83f062601a5c2f76fdf0ec3f1d39fab3b31258d1edb1dd800fbe4756eeb35bcb70e05ab37effc0edb81e8c06e6931f212f08d7b58a77245071e5e094d912b53e54d8d136f2ac192a3d54b13f8aa00f4d0e669cebda95321126d18e0e7b03cdb5b2b3c33b90ad5d81f8033ec1e62e3ea3240081241673b5f074b316336c88eea9295a2d62e74e4f039b01b192f59aef021d071c8fe7428a2b1de26a80318f76214b9411b806d876ab70ae3f52bec1049f7c62bf736b4f2c6d28e54598ae8a9266acc360517ce4b01e231c27a17706f13dd34c3169170ffb54c744d02f2b84e2551b8df665288107675dc9d69cbd0c60f06ff5b3e2a349c3883c47001c884b4709f445447ca2f83a6096e964fbb0bb77ad431167e8b15203b6b026329233654e40e5f8b6a5516582a284b9ef617b38768852122fc03790306bf7fc641d9633c527846091768c262728d169b9099e5ff4e6a5c7279bf3518012018cc9e9a0c32f5a8f6e554d5b4f441c185363ef61fbb9a845559e511a55e068cdc7068717331b5b22bf1809beed7cb6d26b697355cbe505da09f19eb436268b090f5801d263453c4332240f100417a05f4ae84b205a7335badcbde1e57dc631736d36588e73bfaacf70c5b68f3adf4e4e0d2fad1dfa85ff0cf021e2867b489046d7bd714b559d9470b6cb9bc3e52975e8195bde16102ecc4cab78edda54c318db94affea4649b2d04120f9178d5384004b377caa7eb7fdfae12e7eefe7e368a04a81959ed077ee134c43cfcccae53c37b6a0260aaf06b478b5f4c67d89b7b536218f3c75739f085a255258cd0f88c02fa81ea32649bdbef25f59b8c4d01ca0ffff5f988f77099d5970b587d74c63a7df11dfa75a598adbbb05528329f9889ece44a342b53c28f6287cfa242823b73b11e41fe751ac74d56298ccec03dff74183d3d14d6f97b255bbe2e9828385537699c85337b7faeb511d743820c371b7f0aef9f36cf294f843430ffb09ec3cec14072b71688e119a1ae30bd0146293989a06d4d01b00e670acce5a16163c9b536b27beec8be2b1bd5366393e44cfc461c6d3ca24273e493e950439dfce9655a87b396d7099b9b5ae7b33283f1f8cae6342b3e6d7822928fa0ab3829a67cca6d7aa4884e9f44b2224fb0bfb543f1dc6be275371a5152000046cebfec25c0966e5a9c9cf608a85a75f465f0b15de1d86a286a51d6b003441ab40b20a0d40763d191fabc8b85f921e789c7c3c299df634f6dc58e894d4c955b092b7ea40bee2a9202271421031a4c8437014d905893378ea9f4063f87acb9d078c24f7d6caef2a1a25461e4463efe2ce813a5f25525003bee67c621e1beea00d9ba607a644be61012a257ecada369f2db257ac6b66f23054c32670880411fccff64e993779accb9f17b61f6154caf1f178067cbd12488f1aefb6ce6e9859065e7794c08c2ce41b412f3a6f9d0ca342884e3a7a7b7b814f225b98072615b88299bcb13b1a196882cb7a37bb9c8a7efbca815a5f6ce9d89986091dfe9af4ccfb22fe879df8116031d23e323f36cecf01d12d5fba7cb805f68f7b23b8bd714f4f540f619d745c68dfdb41434c03932f486458e8b70eb5583cd6f12ae5d0370ada413a02d9f66bedf266937c56fc8f65d243a3e64c1e0f5b016c1af38ceeb9fe360427a667f94d489a2129f10ea5370a991de5963a6ffa16c02ef567d674535f0be3bfa97353c88297e56de1557d4b1c547fdc2c876cf1227c2017a2b99bb43ae7d905bc5d418c53fdbe26a4b3ce9dc580885dcd3d6f60223a8e9199ea8f39006feba78f4e040c30ddc508bd6596fbb10b7f69a83954228187142eb2e4d2020f9b139129e15340255bfbe7f9547d6ff731a7c11fae47a029cd6bb89d33dc11eea47fe2e008dcd4f848c1d99fe5ca352b68fc0669183eba5376f9f23aaaf9a467d2f3c902b475346efd97ce6ffe3a30249d84e5987902a75fe785796d961f2ae096ce0a9b727883fd76fc146dbdb3ae1150395f0f894246e9cc9094672207948d040f887a06e9fb4f22d3003d1cd02e0c25a9a836b3fcae46a154675256aa3f545925ff65035343499f948350e5f0d8c085910d9d268af41c8fab015e138e3779325f5c66e49c1ce9d2936b6f57df7a74d9b1fa6a01dba80f24561e07701cca601ced615c6124616c980b64d41bce228bd659339d848c0215eea89a5b65a187f4a6f59ae80d5d02659eb2fb6c1eb95719d22998743883f3ce7de771ef9944e812aa44fd1c1d2039ee007d871ffbd3b74ee0f2cd71c59568a5dc05b88de2e9d8cfdd1414856a23e67921271f9842f1a73841bd3073b0c44c6ecdfc9d6cdff3f8122457600ad1f3279cd449382d26430b105ba929d4a8ce3d043b639dec0db9ec6cd6179e40400aad47786091f583f6187a8049a2e4c8b886f3468858cb51e9518a51396039c342369f67c3aff4682d36f5133e3b857542ac74939f7f9b218591f4505b8dda490d441a486b42b47011ba11a5606d523d5b68dec91ff81d93a689a99c10bedfd29f1b151c8b358fdac65a55fb58e986c04e6033805b4d1bb270f81c5d7a70e9a4cad0a3663445140d7e0c652fcd9a3216a7b9cd89e19e11d84248104cde9a0051eccd54482cdefc874e5635cd6e9a24c2eb90fda055f74ae33b126c3554f796410b9c885d8b57f885d22711e92fb1cf296e9e53a49aaa033b5096565a01e5ab283da4bff7c9b39de149e0fcc57704bcca95bb3c1ab4ffee8de2910d8e281a68bd21968ff8c79fc1d00c17fb80b51306fe31f5ecc4c1d7c703d7d588ed14278b1567ff506d7e17c5ee795bce8bc5388fb672dcc5651bf56915277bd6ae7daa6b8427bade9e3284d48f809bd43341eb85aa1049d5bd53b045bf1de713ac0f1f03271ad5fcb865be846c4277283bf6e3fc522a4918746ca654ad9fa5f72eae0c5b52c047c24abfb2f399c56565deebd329dbb78b7736a162cce52e28bb33024af60cecee7e58303d4a155797e8b759dd28d73b404c0381aaa9ff1a14c1601f4394b02980f81f140c97723f759e690f14e8d1511c3acac13f391d7142316757b99e7c6369fbfd2de49ccf80e35464e70cbeddaa4229bf4533051a4fff6c3ae0d2b934ff00dab4e05643682ba956bcbc49fa6ad72835f681be238cff7c25b2cad2dd29e36d27496797b81f9485f1b9c97cd939b0e32723f806e70a869e05e1af58f681ab2b0f34ac6e47cbe1fc6ccbc48b4049035cd1f29da1d114cf06c518b5fe61c1f855e3ccceb14b436fe9648834b060a67b37c1382a860c380d74868a1f44f7a3f8643ffcc28a3bbb22ee0043f90fce5c60402eebfd67c6d79736ccde503910dfcbc883cd5114d5cc6d80c15358ca0aaf426b5bc35a9a06567731357128302132e062005163a10158cacb080e3e5435877aa891cfe0af52a6dad92abbb584685e8b19f4830adad16a5656ddc06ce78a58a25ccff4488b8a0531cb0cc687656065687e2ca3eca496d9b2860cbe91ccef2f47713a35da708638682aa8340fe659154d98025e99cbf9435a864910bccfc03cadacd6fc2e2eb039c4a20965d30d3528cc6622c2b5d4e9354d3e5cf364a45d23b3a53203bff597d2694d80fc797aac94d69ef488e39c3eeb9f9f992cbd736539ef84796cf07564f4a6b8811bb061b7b5b39646a7448c239c1729916e87040482837009349a429d880a19f26b1ee8829230556daea22bfad7fa0ccd1e96e7e7838594ae00c7aa2282a0361d1cc1aafa047628801b368540ca4fbec67ed9b66f4da2d268afd45351da565217da16b80c8c4a6f669b6a3ec0ca10322b69245e291790a2d8d3524a0e0deea6d1e6461c94e6e6cc18e4ed9ec158868990c6e7454623cb2e22c8a4cc1a457871fd069caf6e9f4d3b7bff1d4efacbb3386ab2ac936af8ad125f2c3bec2e676df3ec2e9ee0602e795d89554c4a53e71495b2af0e979a3204a4d9bd4c07e9a580b83c1ac1359c7424827bb04bd6b168de62e01d5460f250f5e4ab6ad2032cb76bebcb73b53619e581575238f3e5d59b52b54487563a7d508ceb49227f0f90ad989730bee3fd40c049d0bbeae3d9acfcd8cfdc3dbcff3dadf5ceab120f195fdfcc034b699d6179b0d0bd0605696be3fc276e84ca5f692d784faf99f4183d29cb3ed99ece73ac3d5e1442a889615fdc0e5b7319d52d082f3313334b4d0c7e4ffee356f7c1516cfe101ed7a7b787921a3a545728413bccb7774d55155ae6e7a9284dc8f1c23215f6e8427a6424abe3cb8cb0d9c752ddd1cbe1c3c498892f1a8d9651f69ea7066e42f5f7b774374b3cf58fbb7b6eb685c4cbea1a67743dc97b473635bc77dff4c8b5dbbc3f5331e95ff19619f37ef07c13604168dfe4820f75260245e2b36205c7d9eec55327622e202cc4a3f209486c733c7981f4e3d4e4943eb2421cec7f2af1365e2260fdb7c7abd91db9665ecf08bf57663ba9fd39d1d0de22dde94f3238c4eb3ffff5c40c9efe1ceaff4b2e51a30985685fcaa42301094bc2a8da6e30f4bc0ec99524db21008cabc0efc21fe5c794a7f730203e2d3bed1c65e74cf211f1b199d65d2d7654d1a6f399605bcc01b872184c90fdd3f229f61b497f64e0153e546183da16bed64e573d07d772def589f03908269c7d24dc584ef6e54efa3d1b879ba4b13f8fa27e745c0ac82524be61b1d7bbecf7d055253c0ae01b9779eb24da626c3cdbe2a467d0b7eca1033c46626a41c27235858af4857443d2e66cadda337fd8d34474098b599bd82ccc375aab2985c4c87c70e82e7493416771a1c645407516db3a61771673f875b034d04597aab997747b91ce6485a93fbad98f7b415e983a976e9683e17c5166995b888c4cbc9f60e374a6104845ba8d21edcd5bbbd0239bf2463b4e6e0b90de6634fe21dab0e9f6ef2797f6ac1647395fa2fe5cfe029bae349cee229fb94c1a6fbe2fe0022e65727c1fceadb8abfc0b1a8bc370d3472da2d37d333b5b4bff09fca8336a1af4fdf783ae830b96edfe01f929e4bb2a23e83b359634b66aec3b68fadd4612fc56d3c48fd92cf3d13ef91f956b2b6c0178cf86249c5de2529d57d47c7446488c7fc78f077d4758e116e680ffdb553f83ff047ede566073690d18bc9c2ceac96cb20cbbe0b5b83b5a70d1e5da2ccca91a05391b7fe6390db5e73bcfdc4477c155c52cee55486f1fb1a86e33ac642ee9e157819a2681b61c081dcfb336ada71505a024593ea0e6b6948554767d14da101ff9370d8dfea330ce9ce67bba065bdd39ea16f2412bb98ad4518fae9a77e249242997272184777a2fc55e7afdef3f306ef2931ff3f0c659371a5dd4489fb814a7298a341be1b35e5d3742e16b2ac0b9d7144b968b27719c9f9ba7fc7c29debdd37f85b45e5428f4d211b8124d2f9cc74a5257a795921c4850f5f3b3dc0ca0c1ad73e5ff627c45cbf68b3367e0756fde9fe219e7a033340ecdca8704cbbf3047f78e2b487c0a8e150c2ac38d5281cb0b6f23f145f60550153eb87f8cee643c4c7f34c9d4cbf4074977f08d8831e4d580c01ada114b360bca74c8cdfc5f49aeb340365b2f91b2d14224e0e23960c1a49f9bc2f3da9b21a8622cf2641d96098479736b4f72a4cd3ae18ffab47161638e5dc4e08134f1941cac1e5358a5bcb0ba8c9f0c10331e08d99101dd85fc766ec9e26c3b6ba9be8a612ff372130b999b2f854d1357db65dee065c42a29d8bb513ccabd4f448807b7869acd3ef6f09b16a6099596b4f01619a75733a6c52d559c7db24787c6fe905de110aed74ddf14e20647c070dcc824322fb28c82cad112bc1576c88b9d4d3bece494e28979ec6314033b9dc51f8f850df0f8cf31a15dfb630ca02284f1ea23a6a3a25c4055d54137894f83de4de0723bc9633ea8aabc89957a812b796e387093bcbe683a3671ba10b663cf76043782a57b78d9302913c74921b817bb9f62d3f747f6d2138555a34c8aa8ce08246e3f65282e0bbed12b17d5fd9b2cbc35e11ae3213b1eca1b92b70fc5802066f6559a2b995ee4ff84b6313a1d1ef31822ccd07cd714e476ab31de1b50ec3a6db81cb9009e5128edc501b21250914df749a92a576f12530a4f15705ff9aff05b700697ad5e50472e4ce2ae72210a239bdb0fa4e81a5405f4a0bd0b723d020b1597f74814eff4b0166e78718693d941661588ad1045f47efff3410a16f86c276f24d6aa81ab53d6e6e0889a116b969dd8aaf1c99673d2b07b9357e43d37f0a9229963d3a092603f2be8643d6f7af70b914c9ed3e72ef77d72a644e256bc5222c2b390ddf50cb8fc817ddfe6d489ef922cd83093bb4440abe6bc4a0be9730374cd36ba5338026e2735c51b921dd4d99a60578cdc43525277a569b9d86d0f799312dc7d66524847e66871e2b0245377e9892b81f4bc78a86fcbf49a4ebc28a32cb15fe5f1f1ac8080d136a9f443613b7c96fdf24e210969609460b44243e323cbb34796934a30f46c0b2a1190436dd8f8d9fd91978685621c6fe864f1abdf352192042edf3165ad05ad38356cfa3daa5a82d5a8cfe42061ca2f8864700f79b47671be8b56f965748e765b3e3ad9d1dc644fba23ed1470cee945276578fd87be706d87679ab126a331851cdc240dd0db6f4c65d10da12965d5561dd07b267d8ac14bf8541e8fb98d22bc7d15bd71f80594f9025a336f04110a6a7b159b30129077279fd20fba160664f5d86f1ba03fcb23040b79085fc0f721864f00d99c577876890d535537de808872841e02f0126eba64d50f32fee32f8dca09bd83bcfac8aa6d44b845839fbdc53c3fe65ffd543262f9465e0f644e531e322d314badbbde8081a86651d4e6c1036eff634d735a5324e03b23b9c5ecab15c88362490bcca5deb7a65fdbdf0887616d1fdf777d2722f9ed1be32f2f376fe358398de3dfee0ee06b7e9106935f2d485a6f1631ca938de09745e7d6d01a671ee7c609c175fab1a13e7d015f96f3e22c6411be451ae6895c80b028a31095c9ea5e3a6cd57ed2e8e84da72b29da6149248fc1300152d504034c8893505b26184d57f6684e52f228d667c8edbfb59bab7b4768cdda3776041d08990a88412b20fc75f96c93d34d2c41411ba7fc2ab111c57aff3cd6c4cea2a7c12c8f6d156f5067c8667a99e6952d348d549d4a5e4f153e374e8cd2c49ba5c4f80ecd9054e1c2b2f12b9a9e4f0e60fbeb724f1dd143959e315db0ef698296cdba40a2d0a828f5839cc99cad1d482158a4a0e6e52b9c17beee667e1530b4ccd394748bda77157cf7cb18644d36b1ba99365627e94a01a8ec612138fbd9d48b904403462c45bdb4be58f9abfc21771c02f7ccd76573a87929ebb0d885872786bbb2a5413a0d2290994f95ca4b97961b82ee6ab868fe3c5a5138d8663c9c1d693e946675d36bd170a6870f49a5afbffb2c50e947c919f968577fe321d9b0b14908926f9c4ae4364743950b94c62fdf9ceb19654ad2cddd240cf3161efb36ce789462c35fb6149f271de08336be9ba002bd2c07959cd4f22c2978e1b42153213eef0045173f091a14d0ab814f11adccd8a06cc4e2bc141436eda17e25ab1ebfecc45634cc076681d51c8dc8ad947c33f9540f35848ef7fedb0d5686f7eff8fbf7780c2052825877260214fe482c5da5d7de9a4deab0679b4c5996791cb0d617ec3a1ab84037309ccdba31004fba01461a5343bb67418f1dee517ea76fcbb0e3db6b1c2e325fac3fb959d976e19d87afcd68dd55f17508a79c2dd170349f74a913fdcbbf4f944a1b6f59897e72436356af8caad8dc8f7d33caef9d497df52e84e4873d69c7386c92fc127f80d7fdc9cfa905dd6fdfb6ae4915902833ea1a75d51b4f752838af21b73889480538893a29562d2a56d4c50e964d07a7a8e87b8187fde82eeecbe4f80092fe2deb32dfbb01ed9c2a6b2a4c5e59ace780b4163e661bf4d0993fd5639e05fac0a4b039d2d36fdbe1fb4e0f7533da31ae6ca75a83c866b88a1e27b391611a7dbaee2ebe6d9f3e1dd3cbd9b035d342eecbd848b2cbbd546d1296240194dd8794904e7d4975a3e48a9e494eb6c8c7a5ac4f6be9820d0c54b3e692ad0fbf3f72b978394a37ff154fc1cfb899a7c5a1f9475b2a936003adf056448aea029b8656c6b39003ebbb2370744d63fd13873b7f52af5b2540f78903c5ca72914d28d40cb8fe91967243a998dfbcfec733aff353353d0a39547d2d909700b14aab66feebe972848f8cf71a21738081d6a5c7b9e74cce8cb42dd13b1dd9e77a4f8e9ef12c1e90302319950d769450d217b2838c96085b5772f328e87bee926d89e879a1d80185cb2415a7a404b95ff46f2d88834a3a3b4aef54c52b285c003e310e5d1b2edf19a8a82f1b2b57284aa5c2d93213e0c90db2569e6f8ba53ab6f9ce01545abd785e28afbd9bca972b9a0d8f8aa3206f4d6ec82fbdb8e5e988a4b9400ac1d5cd65f90919222fd255494d442c444354f7bbf117d9f142646a65fff8134325f4631457a483352a8873aa0e8150ac61d24897e6d852e7caabc398d9566bce09efebd3c462df82effbc2eeb33f2281cefa530dd22917368f5855644d5cdb890f164d9595d125359c50256a35efbab253c903a8ddbe8b6203e04e2b1163ce8b58c34d0e759c9712587843b07e678560ab4ae8871b1607c8afacea73ab9265f24bdf4348dcab05e0a49fe361c36ce2d71ea24a9c1c4ee44076185fc81af1765c796bee820e8fb43173b3beb6e4ee7f34fb07af01a629478372d18ca130d9895326ab6d7f2919c0ba96870554c121e59261b4a65a1f5499c618c45d4bba5ddf7438667f9d245d9f8e163d602cda1f7ae7313ed4c8706ac6ad59bbf969951a062a17a99fb455f3761cc3c33199bafe38ed5cf4ecabeda9927e222074814f72cb11789f1594258d67168d7bd6df6c5ed3788c8938419690e8716d90dae5c8e66f134f6a8341e06174afdec92586cc4214ae88a333a4f771ecd6ae85c49ca712304cbaa4c250f773661a0db2559b3e9d47ca32cc5bc0d57a72e4a3b7ca7571cf0e1272cca5b50eabdbd9229da651d06eb8ab73a245eaf8ce72271a1ce17fd79dbe40901fedc352552d03962190ab5a37cc5365068f71157ee7736a01dc6e4a15cc45f2d13ad9fecaea1d8fe4041abe69b3bf7dba2a116bc99bf8c5826b3bf64426ceb75e8b4f9c6aed9a7336769a4af478c20eae0f26508c0e01f8e0499f1a78cb83d412438e3038b927160952d7a49fd73c38bb89f8a5d49ce6c81cadf56c28721c9cfe89cdc405af65bdb96b56cdbf30373e6491d1f7e9236bce3e30ed48b97f947e95eadd6c6b218c79afd2918d3bfbbb2015874e65f50355b62189b7f9b0ae1b4b7f7f89a99bf48ac9b7433a6db9fc365d8b7168ece4bc4f29bbc0b0d08fc1f92e681563531259bf1f83de7cfa63c210a1e20d960434cae508e0d361f1f72a9a54467a1ff4050a02af9092aeb4dec9c0a557a8daa231a9afcb0fe1d53701adba69f52d625a3caddbc62eeaa90a1a2104853cf588d36b45b585ba858ab7fb8318f611ab09727330cc79175616402f3f885611fcedc9bf69f3d4e09267020feb084fe8a0d9d7efe119f46b6878d3cb2ef11e379af193b0b25656f61658ded9077d8139c19d9f8b96d6037285db9f985af91787284a60079af86551f5d319a1800efb1cae4632ba55f4bb673b2895e08551cd0ac38d7c3a13125a0a9c5046f2c2f1563ba9c53d15eb8c8e06d49520e84f6c9fbed28867b420f61669a7b834b5fd41e42e1892f67ef5e6b510e267d3f18c0985537d880fbe3476bfe93504f4e3926c2e6e2ef511af7c4989a8a77ac93ff78f28927c69f408d672bfabab38aecf5465fc98d69bc1e541721834b9e65b2f75b4090fbac21169a789cecca75bcc5a6dcbb70a27991226758f3aa561aa0c4cbbad3ff6973a260bd2348431a9f0cf8d5739fde95c03e1479688dc6267908d02da2e5da1833e8b31de5caf878813074a13b8fb381ecd58228b393a7348ca876f0474ce70eeca19787f958680f4f3600384a996d7d1bd532b148f285a9a8f55374e02a80aab5322385ad35cd855409a7b44a82b5127251fd65ff6d2153d3d58ab5d5ca2e815e7ca6bad7af83cf2bed46a8297e24c98b1d45e120806b22dc52dd1b15022e27f5bdba503dc05bba665b60c51026d5f44ccdef519cf2a6c70a1b2e19e8295901c59fc6bcc30e4d38e95f7c3a879cc46c0373cd37e2494b4fc95a56f8fe8c9d96ff0937685bde3b2d2ff3acf78380889f07e7dd4970a71a4aa4695e5aa3cf653e06616cb3443ee19b209fdb061f99c5ea9032997302f18408f213a4fa7ef464127a5d0dbfd0959fc6f55742b8f9e1194e97545bb04213252427b4cc68cef4b4f27b33c307b4ea87f5c4cbb97addbc32d15a378fc6ad04940e1346ecd78bdb32948b53fa791c4c60049efb0acc1478d0c74c9281034a84901c0807c2dae7670ba3b2af318a65a6c8648c062f19d637fc078a7bba36cf9fd76f90e3a2194d47bfcfbe9ea6d33234fe1ef5839994f4565350374cb547e9a65ab2c0936e004b344143ea330c901421ceb9beaf2ed91e31c140039b0585ae88f8f876dd050fedd587e42bd09129c2ed169c42821c6329896316a486be2c0b5c2f31d1921c07acaaecda80389fe4c0248cbcc4ffc0e36e5661ca495203bbb676aad71c3e3a0c0230f2a7586856580753a518b96410fdc2d7f2c83f717b543487746d62c6fb5dc787fe16127e6f5d64d3491eb9a863085b5441cd04962fb91b8b985fb17a2ae5f0c7f6ea62bc608c64774bf35c61e51a54617f97679950b71577723ec64f4573ccdbcd6843d55955fe55a12e05df8a777c6856e574c4baffe0e8c20208fa2e4d7a8eb33b92d3dfc31daa6b0b9561dde2f212117eb170c7a615e7f5a1b366a836f4d2d3621d51750347262e4fbfdc32c79245ad139f1536d1d97c754e34cbb61961cfd8205a24bf93b98aefc9de20d7c241eabf0283649ccbc9a9eef1506ec67d26e8a25207d2607be0d8aa10d610be0f6bb8703d7555b8ccfe05bb6889c12f716453352db31ab08c0101801a9b3a24bc63aa1943bee67900a0a44746ece3c83d4c2f5e18c49432d3d56ecf25c64275adcff50b9817ba0f6365c46e40b47bd0d06b4dde90917ad7a296cf0967416086819be5965b5963493befb2a4f527b6455dac38a1c5b993aedb81f6ddf775b86fd40574efdfb52505389de932fc77c15ea87bd1060f9cf3b409de9e67092179e945f5995367859cda5a05f8aeb99bdba491dcd1cba661d5187df9c1d3c329c64a1c2cc49984ce270a34394c4d5b1184af6772cb72c47d7a7b70abc3828910fd59fb32fe956e87a43e1da56589ecb13c987c501d07f68bf4501b5d505b543095b0a98903cf70db6d2d04dedd50bd66f63c8b55ec63723d33343aa49a2ada94e500b2bbfea787b06c9dad8ee2e53f58f52b3cb4aee6fa9b2cc5b8254515093ba05092a1464acfc3e478b431eec751864ccd25aed311727b2e63330e291cefb43125619692cfd40c698b57c004bb18b8fc8d9cb6aa9f0997616e4d5f34415204ebf2e0a1c7f47ab9030951672458bc08dc347503f5b62819eeb20c34c51104d862c4f313443531f018802e202fa2803b25cab331241145affe6dc7da6a050bd9b1b04913d5cf4121f3f63e738aef8f47f0ff84d4adfd99fd2df6d6d8bc3ce4d52b7c550d01883d53b9f136428812970e527f68d66d233f467de4bc88e8ef167ebac99fdd413d8dc8649686724e81324afcfb89bde917b829eb202399d2abb3e52cc083cfc5d968ce408020c724ca39f992ca1ea413e4c5350c6074afadde54ea0397ce9f1d206c7a78dd5eb13b9daf6a06c5c53152e0b6b2c6054925fe26da9573e94eda0bdd15857209dbb760fb93c54fd9364247d1ef33645c5b813d5e43382b5e7e37c001a2b6d29b50fcdb891b0bb070e7ae2b11770da8bfdb4d21a99c11fdafca225b2abdf241f7f3b4f155d60a056995ea3b1b714e5d1f81e4b29f70b7be8e5a6c3db0fc40af57eea4400e1b8e0ed161c5e48d7d0412c60e46455fe0c1b8d6ff541892d35a697691956e7737e0f0dfe2844c7c0d7cf8acf1f17fcfa6e1d44d11bf632ace29b8e7a66a9fa951d405c04fc8b81c3deca0421fc5949791f9d1b0d03e6ba77022f3db240cd4631cf5cf8beaba3424f614c7e1e3bce34777a50768662882dcdaa2d89ae6bcbaaa2d3399a4e358efc1ddf8b6cc000052f51799efa6b0c9310c0e9b4b854cb3e1f09a4abbaa67e9d0c4fe1d5cdaebdf905c42825e6c38031777053406629bee5771f02d31b5103d88012a0288b4f8c5cff86bb2be9890b2e5da482d84cded45808b23b033133f5aec0504ceed5cca56a806e04e2a64100e9d52a52f837f093edd905dc707527b0378ab43c578823c4bc0b3f7a05d1b93c3680af611c60bf60d2208a080fa3b47267a347568b039c3490b98c162c05b7f851b6ca02ae01c405169d5e1ea2ab9735644618966c77dee06d88f3d0a8c0a9642e9e41944704c452787767733e471c7f41baa8811020fb2e006e56edd2c796c925c75256a56cd421f8582cf973c06d23f7715ffa09809c7a24253196005345685aaef6be2773890c59a889674c68a441657e284a5d06e573bc74096b1bcd6395218f2e0a51e0cef373ed9117654a8dde257adfe27b5a84d37b0a716589c8b9b4d96ab1c1450a50b8381e5a0414a403683215c663a4219bd0c115d62f4a68d68ec73e399c4792f151d6175dd4d694f9d07b865f46bab0c7b6666fb0dfd2e02dae337f35840bbef3396518452c5e7fdb0fef6ad431a1505b69ec19d952d6ed765f4c736b29a70f2cc1ac5db3c154fa743c3152d161a69da1adaee5520a09531bf70ce100b5189bd5fe0d05afd717270ec325d8989e292d8d26776bc94972ef87e05dda3f5b91e1951ebfb491ffd0ca669e28f3fa9625b3f71474fabf0f68dc0d2a6be9f84537ace1fd82d8e4c33499690a1a03bb692726eca3aee5b726168846dcdd643488c9937b4054a0a092690b263912778d5425ef123d2caaa95bd0410bc67ab9a5f10c79fe3c7a85934c80eb95e6ca3e2761c889ab8d4a8078ecc14bb5d95351d82736549483b3428de680ecd475d6b7e7b096d4cf2e1499fa0e3f111be8f1488a0aa07f099f170fda437884ef9eaca36d2cbdfaa734bd875a8cd433d3f8b56aec4cef5cef47666081191817e2c2767f755e7124ae7aa684b8d7ce13adaa9b5f597b20fb9a9b9b754e2a1146e24f3e0988d8cee8b17b04d385eb28bdaad1ca7dc2a82bcb7c481d50e24b479ff0ea1403f4621c8ee46841e27a9bef9bd6af4be28902c59afd85c0476909f550bde2b940773b81298ca6c336158af9425ceb5fb2565f2ee50e146a56ee08fa7d0cb9d1cfbffb0ab6386703a3eea56360778d48272584edb85775c1d5494bd4ef39c40727ea83fb08d2ec5980fd3d5a89465857d10514b652b400d1dcc9ea412b2cc30ec735aef117a915b74c45746dde621960c5a50047b904d32b117f5468602688b73c9abda44574c3badc22e67bde0ccc2019fc72f615cf3318a50e26d42a915d037d03076a264ee755ebeae8e31c157f0530cbfcd57ea761ebdba4522ee1a9f55070d4763e4fa5ee170980693848f539f4de57eca48bbe4e7020d0cb70df70523aafbceb026990d22e1d1dce7fdf60f1e42872dcf33a0428f0c8302449c52a9122b7835648822850163ee8b5350f54669f83ff8e1d34cf9121346df382f4a6bc631974578f0f305dfb0f4cf3acd28a148ea4141b10be15baa58f300cf0db90ae35fe858fd2cf93ec08043af0ef6ad5aa9777ba2bb00c90e1465d9745890e54769f967de4dbc40a9e4ed5b9f550eb05815974d712f29eab618ec03f0dff18dfdc2132b6134a61ae554eda0ab6f14d6a2787f8c3d39496f6f77c8aa5c0d94ca638b28a483856504abd8fdb2dce1ff0d0189781f65c78097db826e3df1987c5bdf38648c04b4593211f380d1117c770bc5ec504fa8c584cf98f1d52c246b885f9fe3b58fc35d21634e19e4fec3bb6e8bdc29d05b37bead7fc8a37f55326a06a24095f58195518189b6b113050c362aacf0917366138086201597157d675d90079fcc37a57c76439833ea8c3f06b00bee8fded3eb13c03f1cb6efe7b7721b05012d68ef08c103a46cfbbe0f70648b5bfa17b8a2218d8033502437a105e771803d19c228c9045268b2ce8c80ffc5f0aed20f201686c0decee16117cc551a9e417bf52d41ceb63bc61b516a28d8c03631688e0eae02fb79e3cdf5a8d991469ff25fb6881d388f9844dac05b54e6d82248072acedd5db6f51f85c6adf98fd612be58593bc12cc86981e098dac27d83689f3fe88367d2d40ba1e0dd731a8625d8107bc1b5871c65b976e60fdf5365b7cd44bbb20bded82f6bec23837faf13c0f17488c942f481a20aeff69c8b75864e6d91aa7e79a358a3e5289db512e0e59e606da69d8ad331e6868dcf6649f5615079b24cddac88cd62256372a1c1f50fc071abce9e5aa566dd02fa93a8195f3b899a2fccdc55cce5d3c09cce285c8db362be7369faab4757b8521de836ca062ccf31e699227466942006b1f03102aa630431f88ba3d2b0142ad6e1be934134972b38e552e6ef5ee84fbef5176d8ad90c39b48434f33e878c61ff041cde6a57ba439bb07ac763e690f192921f29a1f6822764337be74e2948dab8ec1b346a989222ec89a9caeaf91cd71b2d032aeeebc01fea3aa15a8d9d81ed9d0a79b237bbf798c4e4514d3f82521397215d3f4d76739f5bd63370144d2c703f2e1acc0c8a0903fd4de5ef73bf3fdb26350d4863340c591caf13c1305d9c52ef855d85b52f795d82963f6f0c031d5f267172330e349d2def9494ce135a53b59d552ac31088f7817b0e713998a4ac38adeb86f9c25bca76be6b23d60554612d3d50d73a23a6be2bdf19e7a0ccb94fb76be0d8d7e41ae1c88cd5240debbbd99e04604044d2f05d3baf338fac43b89dccb614e6a8050bc2389a23b18020a0c07b0e28a8539a0afb7caefe064891c6b12f1396b4c61ca985b98f3b23288dda01c7e832ff0ca3032b3cdff7abdda24c5e8369b1eaf1accbdc9cb64c50dfdefd7a17863bc93e02d50027598905ce2f6d1b67cd493d1ee66f9209a109355ca982b5be208004cae5a31f594f3bdb12b9c41300495ba3eb38e73e8316dc3f7adef9d608cee6cb4d48bbc9ad5f267b7b09ae38854bf46a996148788e37d5415e30e78407be5ace5501aad02d9ab923d1591cdbcc93553b077a42fc061f3b34cebe276052167f27fa07f40ee434f2a95e8d8669ce6e68ba79d762217f18ca00c9f9236647245ceef74809150964528d0a00be4d24d4001b96c471b238aad4c923126a7a180f05f79482c428370e346c8a55f1e7dd8df2713845a613de972a801a2d3d37585745f17505b745beeeeb5f0be8aa29073e944429c5411139770a0a4f2df31add71f7cffb6a0635cd845df049464aa414e3a2d4364da742c1f08817778e0a7c0329a27ef867c3377d06f6be193e7f76154d1f0664b05112d25b1577b1017ff979467bd08dae240eb28ff8bd13739ea2a821febd365343e7f31b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"c42515e1e69c1d7e422981b1cd225156"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
