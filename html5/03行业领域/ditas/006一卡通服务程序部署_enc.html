<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4fa40589808b7cf4d0bf929ac8a933aafefa619dbf4d656b05fb8c30758b6a30bd1e4cd2cc72ec37ec7b5e1c08683b561e838b499a05374c2c074f9cae97eb401b28acc2ee2b925b17a3a9e9bcd7cdb3a1ebb230c2a4fcf3cc6efee1de553bc49913e097fb783a7e2eb60291a6ab65b7b0482daf0479cd3b7f45dac7a912eea79b99eb560e7e55d3bf10491f10d9043c0f16e1df24d3b846e5c105d042b1005c989ade8ce3d2e4ff219a548c640594bdb1be0744c60adb85221d6d7618322709ac358e8b7a2f668b31b426aa58303865e3a31f693b526f96288ce33433943594d9ae9b6cffbcd0875bbddf9648bc11c3de63ec70a9ee72f841913c1b6e9312b57404532de7d9cdaa2b0c085a6e6e409121ad60431fd28c2fae89e9fa08061edcac7003a503e67ea01ae70702a648b15a48db35cd577262639befc515ddf0af769c25fb9167497415eb19dda74932ab9b1e570684b0f702b3d980bd37fe2db761904ee96439776f5d1d2cf88e576e423c48e46c1823e17e27cd30d27958e7aa891a44155ca27239639ad07f632a5511ca3e0d24b34ca110927072763e4b6993b23e80d7b86a077bf49d1a6b9116819fcd24d7e7bc4547576999161c2088197021a1e1ee23c77168d321ea9692fca07d03506998d73f289caba6f1a4c9a6ca6005d287572abbe7206a6978aebedb141bf40bbd4651c45bac2fbd1637df61a192a64ef34c8d9e181233c1f9e29dae8aa504a1a82d864a3697cba82f6ee830918ffa5ab29e328629815a553bffda5964579de27948210477c8469e790064ad058dd55e96a24981dacefaef4844db95e765d92958f754f5a96d2d2f1a4718d9558edb064a90f75679a56d32e9d91ae115bb54db831121a9af4122130118e76428e6b520c212d18d5cbb3c3477c0be4d253462f953fd3a482235d4a94acb565abf94358cd44e15f7a526268f5bf3159a93aa712c78ac5f2e10b8e238abfdf5a72322850f8496adf3a31d9cf2033f281df533f86a1b4057905aee6df641741ab3bb1aa069c0033904044429b4cf48d6f14fbebffd894b964ee4d2186c12d7cc41a351890287bd55a6145a202160fa296aa101bc9eab9e74d82c80f5fa3fd06a3df23c0217dc1dccb5a61e5ea320c5501f94b94b8761d59029ca6c793f349b2d913c8455730581d2e115560f657e9ce0d4447f4fc0cd908b1fc0e8806052d37e1b7702774133537f545c11ebacbf1a5f5b88f630f997443d4c15325d803bdbcec044322ef810bd5ac90c3d88c41067021bb14b33acb8074000b2c0b8d85086479b515f0c0b3d31a8d445dde4ae73e6a2ab0f9d01e3d805a2a397719a3c769c849460dbcfeb97463aa8d8eb81500048e70351e3046791f5096d5ef907f648f7d41678731b6aa75c354ffc939ccdac649e3bd1dfc86e1faa4986f951933dd1b84add55b1e69ebc3e1eabe1de6a37921eb643d4684d3d2b52b0d85ab632386f51e8c3d2cf02eac372c22cf1b9d845c5b836f6f5ca83f8795c6a293984881a9e828cfaaaed115be3702e9663f7e2ead0e06ce2523ba0de3132c8e02ee276e64193e8f737b2d20891f2795a567e2255420395f26c793854cad1ad70e35892508ec64b819616e33d4e230fc1de7562611b1cd886581a0ca14ab06f67cbc08f05a3ae3a1f3cb1fc3688f793e5ec6dffc8f0a3350f1b030f9dbb347f028f15a916409c5674743ccb898d55d3ecd15a418126fec86806d42a2b1f04c9505e0b7e8603f324b1440570882c17bff0e781c02816ce746d4a67542ed2213287c0efc58f880b058bc507f76d3e725e428c9d5fd9f8836c16caeb81e81cff531f5ef3d422587bd33bf84a86e3c523ebe7760579ef651581fd7c0b3c38ebe4d132ffcc16745dc58f923eed134034dc6950139c9ffc56cc633613087c6050e2c47e433bce411f4a77c9e8bca03993790a88bf28c0b937caeeea73296a200a6ce445510fd5254da1a69cffad45575b685b18f77f0f1673a2b0c6cbb0c41f31bbf525da4aba04338794369c544e110f1f9f4e973ca77df65fc97d3da9d3b298f6e2034f07b6f9499209fa26526b1f09ccea6c48183c469dd55d188546b61eb3d04638ed477b4d54b11d6a62df40899782cbccb5acb36b86ee3d6a1f0c8ab45859cbf30caea45322e4e6737449ddceda3055e0c4d4d6a4e3655aedfcb2768d3eed8b5b1f4bcea3f8397723de47ac6b0c113d413df617f9a8cd6188602ca59cbe6805ce8f78a89ce770ac292b679f3ad6d6123f7bebea7a2fe0cc72ddcefdd80f1297b2d0a3854ff3f39738b99e8f545f5821bcdec229c9e94dcd799a1207de55c239e4fc91d19ad4a7e9a6b0b9f322a461e02248082e2969fde2fcefccb66814d084700a939700aa0723d793236e897fa4f40b3b6aa7a4ed282305480ccd70b1c43d31b8563be3d360901b683d9d4d0a86d05456802fd1fb4e518530f9074b01a273a1aa5b8ca5cb6245130963ab73be415cca3e591ea9ed07879e5039acb52f7954e55c74dda76f99e678a5bc8ba355934a5f2c8ad0782c25db24be3e57f84999a7d6ccba388c6908b3a3bf571cebdffb726b84baa01648bdf3932167376fa9e42984162560878abb4e0973e2a137adcfe755ddc3871cb4e7e14f6e1a338ed249585f382f30e1a687919c6ef62e93af6663e4045bb5129100712f55057276f6471235fc1a70c47e0ad84ab25f9d3b2fc6905df9af69747c4f6d9324b8e466b8ccef95541e23ab6822f1288d002f22a52aaeb0285c91c0d4c8dee49ba53539c291d847c2e9eb437f0f4a661851e11a8e78a3577f448299c2384910db8b402a563e29d89a7e6b92618175ed2b1f0587849099e668add8059f3b8eaa8b9d0c16f1e6ef8ca7a8b37826ad07495c208d9538daa65520684661490cab727bc690c36b36b106e2dc4899d47f856a39e9eba5c31981f875e469c3e5f67c6ee5696b738eea414c8a0d8abc5a5e03deaf8ec2b83b78fac13978a5133306bed3994587078d71831a2f43f02e3bef1570bfd640e7b31639a637b4d3a814589d714dc6e3edbe87b757986878c353d7e6620bf94dd9deaf328b14c5fd21e3ff0133c5dcde15d4b8fb0cbcdcb9ab172a4b2bd799af5a8ab8146b0d2ff3853684bf92c53080ebe4c27bd64d2b8d1d2a6e1fa6db72b44ca5424e020e13ca06a9180b463fe53912c0f1b05401c0a03b8b4e1714afa9984fb26e3f135469a8eabb140087a309cb7b50026dd95e0158186dd2e81e390ac5296493fcf5b3079440760b57be1a4c49af1b06d379416356c5d36ff3f491140c4aafeb37552f3b0763501d3299d56d8680192a75e976f02e62501344c28c6be35a14f3811f27dba5b9db97c1e9e8fdb718bb590bf5db67ea0228a8c882048e6562b7145da05ed65540eef186a5fa87a165fc8bf01c3f03a83501614f5693b45ad271d9523a591a506d517ae1037f4849c2266ba31cca8a072e83b2fe4198c8489b62fbfbd168c462fc408eb6db76b60e62a0f74d5e1dd764e1a1323674e62c9ac57eeee26f20be93605a65c2944954d7c1a8179239011f8befc5282f0d1c4f1cfa406c136ca23060d1c7cc47dfd014e450326171b5ce9ce413b27de734ba75442cd08ed069343d03a3cfca80901ac5f43024c4ea8c01e542239210c74972fb7b3870fc0bcf126ee6ef3433f1282784f17c850a943fc0a335eb6ad596afd024685d862e66877a099b4b6bc384aaadc07a359104f326396b66a8cff2015411c82465dc982ffb6543409eeced30e7d711c9e1418736d040bac89a658f21990b2265936e7bf02986abbd8fa40bcd1f443fe893e793004f40354b5525181c3a279408813de7326aa8f2244d8f1932a5d04eb77438daeba7d24a8aedd4d5e571dabf6452de3dd2ee39b183a27166925e2a630b8e94e63103a544c5df0521870fa000fc4990e489fb9345bb2da0ba42a4f8dd5926ffc5d278035c397f26010d4f42331b7b58420e431efed6f2c2bf0bfac61571d21a2823dcca8c5528928fb20a73184d38d42e70de04a8d39084111923426c3d18daff3c7d6e9685db8ee3a2cee78cb22402477ff5c1ae69f66a9696231466b54abfb411642e430fca6f05c8b0b95a4d354ea00e82fbe601c02eb44b4896cba698835b0033cf953c52a2d31515b48258b1b07dd5dcd9a2e96df616ddf5b063dc2f621e9b21a2180c58d24561c33484995fb2745bba2c9603f70b5e99619a5109c0b55a88ed666f7919abea99e65dd92def984813029a5b98f3f9c0918b43d8599ab9baf16dfa26f9dc36a9632702b3b2e6edaae87310bd615d01990d5f9c33e5ba67310749f3a3fb89acade016abfd0525b781f03c798979eb78daf1ff5db7f520c2f61658727b1b9be42e26b30656b11ac26b6ae1005aab7431e487e7e2e2e8b66803aeebc87254a628ee5197cecd929e58f5255f7b127c84a22c3bfc2d7c8f1ca3b86d4a9b08feb44697caf31708d144035900cc9ffd8171d4abdde941e8f11fcea46bbac05a56bd3ae71b71dd99cede83231e5c6d3e39c22559d944508f804124931d3ea0d94b9d2f3737f900be52a3534af4d5baec722ee0501efbe2a40dc77b480b70f9e951a2a7fd469468c9a7bf0144f9ab43ba4276174cbfad5ad207592ac550342896ee56c317d5b90763d3f122cbc2c9575d68dfa1803a60bfdc5dedc22221e0d737deb315bfbdda054609e492c90b9ebdb6bf94341fe1592e18d961c948652cdcbb08e96915bdb9881f89aa880bc1233cd6e81c027949a1c0bc95aebd47b251f851a71b4e503d79fde46577d3443a1715944e2fa415977840c26ea59e054bffc4ae746977aea79b95a27fe5f7611f416be822664fe4304876ae57967d08270852c0ddcd22ee17a5b6e442ac08a7be13840d65566498ce642077cbc96579d2e2d33dce7118d6fc9903ee5780ac5d61df6bc0882f7023db05d886d2b6133b0b37c973880753d284da36d4fd6e848e4c96268d3a0b18fe377de8c8e844923726a29f8897fb9a3a74d62d7d3f32070ac5f11d6f439f27436933ce338c53424dfcc2d34d14b2010dfc93ea2d9f4f25d3016f8d55d356936096b463a2d7aaa5fbdbf74fcf12d252b90005a3cf7ae1eb0fa970b2badd08f197b9c7775baebb0e9ffe99a8f81155539c63a1de2b4a915655adea2bc44758fae3446594f3b28d80438fec40ae97f378f1ae0461f5556334de197cbf06522ea25d657e9363a43294c88b6287f8c009f66e871ca9e498736acf35f50be9fbc3489eb496d773c63a2f925875a7e268ec2708edf14da1d7883f6d541837e068c0cd6c37ab5098cee5de7a25c9d43df69e35c226e298e3390a70909b0ce1136163fd08fee014124e507accbe0262ec52f43da858657f641a74f2e22be9badcdce4f0c9475be4c47dd2a6b8f2cc65fdf6222744da3500dd8f964bf46bb255fe94dd1ad236f75adf670fac0b5f1ba5b8ead3de3b9e53abe46a9a8da7bb4d04f6ff13752f9f8b42f63f10c081f73187a0c2a41ff2908f87e838c04035fa6da224faa1608756d192c516db5f8e236d461bdc3da5e205e5303c1f0860811203d16ee0042fc58625abe50cd521503c0615527028c7b79217a77b283896561d2f39a21132f3bc5071c56aef4a07cdc738257e87fc967607aa33effa6070a2c3ffdfdaab461b27b17ac3d8f30302fcae3071f39a703703927ee1f1a1e448046746ba329175247c0f01fbe92e17cb4d1d7293055184e8c7a3b54c363567d5cda0e61cbe2908167699eca805a082f765062f08e68d2480ad34646ad438467d8e3ae1bf92b9552f6c9d0fcb2b12d7ab66faa59fda30447a0ef778a609dcd541398e87331342b15d728a9bb542070d700d9d2d49e64a24b4aabddcc8febc807205662f29111950b3dd94a3fd98cec97fa71d2b89286f347f03eee4c608f695ed2237ae094b011226fa50253016c7afbb44d7d87c3aa4d03ca2bdcf72e17a25a87e936e2fdf978d8f2be4e7611ccfb9b43ab6cc17520a1ee3976f71eac5d93abdfbf7feddba29033658bf397d0de24bb3fbb57304095f8c00460465867dc960f546f96e7ef62420a7a128fbc6d206f101c755b741733bd3fdfb8e9eca654267e1b543b7085c270ea2b3b900ba1abb2b574ee844d8d52725dc9e59621b047f5e547d98437752287c43d5c1284f8c96dfa495e2adec807087400ef321b8016550120e4e82c9151c0bb403675c14dfd32d0022324ea40aec51c1b2f5f4079e4af2b5779ec2685107e613a1788289b292903e381f99e751f49e885d4f9905b9e0c54b4c4b9be136edd00c892e295936afdf56e0cd56a94154024cd84179cdaa2e5138c4dd7f457be5ef2bd4a840fedcf057eec841fb44697d8964b70168ae2508104c5050e57aa51725bb84906aaf8f48422b8070856fb085b43c2a1e4b679ef8ac47a4e73dcd6b243706a7d9e98f26f1cbdcfa316748ca86b1134f901fd38910bf4e98e04808f61f542b68362e28ab70f5104cd0aebd6f8bb3c7fc3fdf2a1d0cb0a8292300078b6cc232092d102ba826a2ae85a16b58ab7619e34bbb80f072f2181bfcb453769255c0a75239cd4262432809e61249101c2cc392a9daa46d7688836a66a286b69df5484ff2a107202cb49e4d6e1552096a0169e541b73ac8cd59f62eb00b230a8194717612b2d31826d01fbacf385eed4e670977a66f460d9c0ec2c0dbaa915ee0bf8014fcaecf2f8dcf4442a3c33125393042c216231df9afc5e77771377b3b456d9ef8aff517a41cbac8564a09596fce7d9e41b7fe43c823b9440143409c00447aed9b6c10cb871f4fa94e19b845b496ee3f897cf1726542d274c3f439d7b58b8d8e88c27290c27e706bab7e200f31f59f4970ed6a3838d46fdb062a1e2c57d53b77ac1f8dd0ee9f22708ec98f60c95ae7724f1d75cb8f879348ea51ce687e410bf11464ad35b4a8807248bb314af63660944c55a7790bb0db936eec06b85a27103213c348a91e2b322050c5b2824b726a3668c751a07a792a9b659a1c70a610ff1f3ed53c55892e2b62c478ea38abc779be3b2c2725e3d12ce3878a413e2ad677d31bd345506b99c784a4f37bf9232a60a6661c6c9cb7dd0d96d12cf41556acb484de51d138d0e3a1035ad615d9611275dbba5d503402a5512327ed9f5bb29877c46eeaa336bf10e08ab6c9492b94e245bee0528b97b47069644cd190a95d68720a210493356b65a2656d76fd7351cedfb420a196baeac21a2a34d7a68c750cba6ec8198e49022b7af7a8df78dfdc990c912a4ad46dccd800a8d3047bdfc33672f93e2d1be707350ecfe5d33d2ece0ec4c0bd8946cf0085bd4d27ee72ccc3715c8f9346e45482451230b20df4a9c847f5e3dc20354f5ddc2b3ccc91d6f018bf3f190ea183df6910a8210eac2f02d84ba0291deb44ea19b38426fa49b1301eb580addeef0060b5f06fe2db8bbd7842896cc3bb6be1135c124817b2aabbea103744f8d766a09335085936f9698ac41e2fad2a17428b212b0641cb3fee20e5e4ce70c0dd7af5cf5a7771f3ae4bec2ec0b509df52f7f2af865e6b4b675a9032752e835ee4e3991258eaca4d4747599f7bcb25d77619c4a263925034f650aa939ef676907565b9642c845e54181c36e40c8e2a786de586cadb5ef452ebaa97e9c3bfb8387274ca4b6b52c3193ace7d4bd4752c723bc6a56aaa0ef8bd1d5e5c3836f547795ee146dc2cedcf730f822256b8557cf7d49112790c6a119d65b41b18374f2d7f692d62bdc6675beff65c83e4a6a84b60bdc0231b210cdf6817d7077dc0d4598f445aeda77147ae1c56534004c0ea8831d07684b1f002bdb93f15f83e58892c4c2c5108761082a8d6dda31da3a7a0ad8ca2579a85532253c38a650124cebf0fd4d189ec2a864384fca92c6c03a6e9e6b346aac1d25bc897613453c6720258b9bc65832ef636186f0dc7046ef68b24040bf1dd07dfa60788740741895e694f0199c27aad3e073b99cd72d3b902c4e5f3aacff66d500427f1c28485dd7d7edf687217151843470ecc8ea4bfacbd651d322f554e1905eb937525c88c558a9a56ad27a525833207567ced8f2760e4a917e35e9279f981919d09b09648a2a5fcfd6a3d369324a7a0d22beb23d72eb7b40c84e1df8a495c6ca6f04828458fc61c83df11a3b8cc293d2d4794d41e2561b914a6562b0c36b18ab08df62bd418a24084e0f0bd5d1cb00762b7490f758e27d69b5417efc7b205fbdc29ba3d4f35055d87dded77a133c7f00c1595e85e79b402cbc85c97610a208eb56265785a2f99d6f881a56fc0c054e2a67398a3020ae982fe4b17ef3e27ffb2e2471ceaa5e6e589c2a0f0c0aeecf47175e8ab49cf675c1105b727f186eabc2e6e86f1070b7d9442bce3b4c553080ff2d1fdfb515ab5f2952f90ce243a1a071058fa0622ea47eab25aad0bdc919a09c949a1125ede0ba18a0e99cd2b028103c57d020044e2e861b9f64b8a45e7eb210c1e1e4e86077f3d27747f60dd81e689dd6051a4f46b0905b950def8969e5307788fa2291e075bcbdb6f12698ed51d2f8ab3dcb9d3c6df277bf57e697d8c85dd1dc012db007803a43801423bebfdc2777aaf908e550841569d168a3e960a933c7440b48848d955c8c8e5c9a75a663c907a2d9ec22987a652343c9fc54e4a9fd033e2113c6be7292533b7d7891b055087663a4258dc6cacb38dc59ffee9e98e3f5cef461be384e1f668ae754ad75bc016c4716b24518b8b7589ced27f591a54985b58a98f059d083376abe108893604f93f408750d5293fc0664c598a0a62abe80c559f1af4f124b87ce367bc051f0a658ee2b155d47c3b25d9aad2f2b3bb7cc1d56886488d395a8e8f72d6b48a4d9e1a5e52e81a0a4d1b16e8c13d66e0140d43d83c03b09d4e7c1b8b00a3efb007e2dc1a6b4cd77bb1c719f52de054a4dab8cb315e94548650588f0b0f24ffeba7b75add593cce2dbb65fb0f3b77116e10239c35e8ec23536e9ec2df54181685921bbc6dc97d7fec16d29ac5e4d348fa13c23312f08426fbc3a7e541b6b6f5c056bc19a4a18d8eaf2f81c61c227985b8a24594edc32004165a9d0979e7f975ad577eda865c16db28abb198e619af9702f1bd32f62212bd32f90e243e0ca23687ddccf68e03999d38f3acf3dae8ab61e3a2707d0cea69a93122b18fb613d8a1918a1ee65fb4594533caaef1177d4604fb870d756c0d7fe02b9e2630143fc3fc5fb3d2737cb3605062893577db5624838eeca36924f66998565d8557cfe29ca75d436d20c5b530ad7111b18d48f6de9541110042b9eeb51f5739cf4cc9bc16b128f2bef78c9144781a6460bdbe7bd31b3719ddb90017d8ca8e39c0d6f7177d7eefabf76f130556b6390c2310582a1ac3e444e4103348fc61e46ccbbd03b3f125c1d5fade9d7ee355eb133e921448e7798924d9a1f8d44a99de3a3085c2c50a38062d06105648fd3ae76f90bdf6ba0d05ba6dcad0a27357de527d5ae8bd6ce9f9a5bbee3894976a6bd696d741a480fefc2819967e62da4fea2b288e032571a2561414c91683adbb592a23a4bf1224fe31edea6a260bab6f42d0bd63057d675ad3a62d2186b0c9815aba0a0364ca158b22899c858a956f0c7eb37044a323bb3cd613241aaf7bfa308b5301a15a4b1f03158f86d4851792668fa77b331bff36e386dd4479a7167c985b93e5b694ee93fc8baf11789fba313800c75aad6bdaf6242d51074661f21e4c99d07d5eca5a7463ab47bc08c5939bc66a1aebf8df6996dce3ecfa051f4d0b8f06f4c59d16ed039ea10ba7e4e172aee795530221f1b3dd694a02a387d6fd6e620cdee80326f0291011ac17bb575d067d1428d1c6196ab0c1c478fda2ab6f32f9abfbaf009194f0dc2bd5cb4d48267486b9b53d11232c57438ae4a4fb2e610e9c0ae6730c0ec37f93d86a0d1676645dc25651bf8f135078aa5ad1073a1848f9a57a19cc37abc1e16e4609073572a68fa3bef0c56839984988bee0ba866194e5c2c29bbb4082d844d73f66496c801d56189b03686dba33056603ade71464bc540b6e2b749092a4aa8ad931df18510305bb155216c5294ac5c096cbf21285ceee37e15280d5837d6204a5d04fd27bbd924b27432371b95d4abe2b019661928ebad7653e6ba7010b16b2861a213a8d737f69f4f47b797f7bd250df8452e96cb1447b333fa02c9433ceb790081aef0b9e17ed21f77545046f5ea1e42404c0cc515be85a65398e37186a58812e22e3a1177feafb7e5c9256d24e57686a84a8468f7380fa8fb27b2feb4493c03850208bac0be6ea1d2fc0149122bffe7f014a604df7c3520cc834603c3f0ffb0cc30a4a9ecd1fa4f1951cf701513ea602e186e78994cbddfb169ad6d170b0f999f5d0941a8f827e32bcd77b943b8f682a32259918d18e974dd56e07f7af22962c9947e4b6a44a4aa7102571c064dc453be42b6eb335090aa5a06a03a744d8db2a12da24679717e8c41213e93f17dcfdd388b7c04e7e56de7e0e0cef85dc60b18fdb3affbd571680348111c02034c6a53114c6405a57cf49e3bb7158f165722fdf97af4aeea0398edfd9b179e1c74c8c5159a7f5efff0779413eddca132359655cc9a2c751f42767bccb0cbd3925482013525d7ee39086c078654f2b1b002e5641fdb7c6589f9bb344256f27c251dc3f87f0eb6f86b3c7e4ce33ac2d93754236ceb6cdf27f57137dc049134892b6676d686f24de298f173d86e46458f3b39c2849b0aede5072921d339b6807c2fc1a6f6dd46691f1c2d0d40fe2545feafc3e41034626fdee64571363017bdce425e0e7056cba41429372d127faf99e8a74017a3147de5c9033ae5ed518ba7e8291cfa4114acb1d2a9d519669dd6516fe3c23a7779bd99c163923c8925d725bdf9e51a1c573972852abb95577ea47869931ccf6bcef794d15cc64d96882f8d33cb736bd871d369fdbc2711d8359d3fe90509d1deddcf61f344f959465ecad7ef559011db3c82cf149dbdf79a4888caa473397277375201038c405b62d353274a36d0720eae8b01685aeddec84b8d929ac31a7b4e9969f3617ff01373483310c8613720da72edc0fe42c0446b0c132e9c1cd7b99548dc6fe005f893e97e8676bdc24b9bd686c522d5ab336ac776999cc5dd5d0316c0592c917a10c","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"30bbdfde9b2c4f766f7c6eb3f61f4238"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
